/**
 * Copyright 2021 Opstrace, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable */
import localVarRequest from "request";
import { Request } from "request";
import {
  createReducer,
  createAsyncAction,
  ActionType,
  createAction
} from "typesafe-actions";
import {
  ApiKeyAuth,
  Authentication,
  ObjectSerializer,
  K8sResource,
  isSameObject,
  ResourceCache,
  VoidAuth } from "../common";
import { IncomingMessage } from "http";
import {
  V1Status,
  V1ListMeta,
  KubeConfig,
  Watch,
  Interceptor
} from "@kubernetes/client-node";
import { log } from "@opstrace/utils";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface V1Jaeger {
  apiVersion?: string;
  kind?: string;
  metadata?: {
    [k: string]: any;
  };
  spec?: {
    affinity?: {
      nodeAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          preference: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
              [k: string]: any;
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          weight: number;
          [k: string]: any;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          nodeSelectorTerms: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
              [k: string]: any;
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
              [k: string]: any;
            }[];
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        [k: string]: any;
      };
      podAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          };
          weight: number;
          [k: string]: any;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
              [k: string]: any;
            }[];
            matchLabels?: {
              [k: string]: string;
            };
            [k: string]: any;
          };
          namespaces?: string[];
          topologyKey: string;
          [k: string]: any;
        }[];
        [k: string]: any;
      };
      podAntiAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          };
          weight: number;
          [k: string]: any;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
              [k: string]: any;
            }[];
            matchLabels?: {
              [k: string]: string;
            };
            [k: string]: any;
          };
          namespaces?: string[];
          topologyKey: string;
          [k: string]: any;
        }[];
        [k: string]: any;
      };
      [k: string]: any;
    };
    agent?: {
      affinity?: {
        nodeAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            preference: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchFields?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            nodeSelectorTerms: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchFields?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          [k: string]: any;
        };
        podAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            podAffinityTerm: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        podAntiAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            podAffinityTerm: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        [k: string]: any;
      };
      annotations?: {
        [k: string]: string;
      };
      config?: {
        [k: string]: any;
      };
      dnsPolicy?: string;
      hostNetwork?: boolean;
      image?: string;
      imagePullSecrets?: {
        name?: string;
        [k: string]: any;
      }[];
      labels?: {
        [k: string]: string;
      };
      options?: {
        [k: string]: any;
      };
      priorityClassName?: string;
      resources?: {
        limits?: {
          [k: string]: number | string;
        };
        requests?: {
          [k: string]: number | string;
        };
        [k: string]: any;
      };
      securityContext?: {
        fsGroup?: number;
        fsGroupChangePolicy?: string;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
          [k: string]: any;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
          [k: string]: any;
        };
        supplementalGroups?: number[];
        sysctls?: {
          name: string;
          value: string;
          [k: string]: any;
        }[];
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          runAsUserName?: string;
          [k: string]: any;
        };
        [k: string]: any;
      };
      serviceAccount?: string;
      sidecarSecurityContext?: {
        allowPrivilegeEscalation?: boolean;
        capabilities?: {
          add?: string[];
          drop?: string[];
          [k: string]: any;
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
          [k: string]: any;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
          [k: string]: any;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          runAsUserName?: string;
          [k: string]: any;
        };
        [k: string]: any;
      };
      strategy?: string;
      tolerations?: {
        effect?: string;
        key?: string;
        operator?: string;
        tolerationSeconds?: number;
        value?: string;
        [k: string]: any;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        subPath?: string;
        subPathExpr?: string;
        [k: string]: any;
      }[];
      volumes?: {
        awsElasticBlockStore?: {
          fsType?: string;
          partition?: number;
          readOnly?: boolean;
          volumeID: string;
          [k: string]: any;
        };
        azureDisk?: {
          cachingMode?: string;
          diskName: string;
          diskURI: string;
          fsType?: string;
          kind?: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        azureFile?: {
          readOnly?: boolean;
          secretName: string;
          shareName: string;
          [k: string]: any;
        };
        cephfs?: {
          monitors: string[];
          path?: string;
          readOnly?: boolean;
          secretFile?: string;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          user?: string;
          [k: string]: any;
        };
        cinder?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          volumeID: string;
          [k: string]: any;
        };
        configMap?: {
          defaultMode?: number;
          items?: {
            key: string;
            mode?: number;
            path: string;
            [k: string]: any;
          }[];
          name?: string;
          optional?: boolean;
          [k: string]: any;
        };
        csi?: {
          driver: string;
          fsType?: string;
          nodePublishSecretRef?: {
            name?: string;
            [k: string]: any;
          };
          readOnly?: boolean;
          volumeAttributes?: {
            [k: string]: string;
          };
          [k: string]: any;
        };
        downwardAPI?: {
          defaultMode?: number;
          items?: {
            fieldRef?: {
              apiVersion?: string;
              fieldPath: string;
              [k: string]: any;
            };
            mode?: number;
            path: string;
            resourceFieldRef?: {
              containerName?: string;
              divisor?: number | string;
              resource: string;
              [k: string]: any;
            };
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        emptyDir?: {
          medium?: string;
          sizeLimit?: number | string;
          [k: string]: any;
        };
        ephemeral?: {
          readOnly?: boolean;
          volumeClaimTemplate?: {
            metadata?: {
              [k: string]: any;
            };
            spec: {
              accessModes?: string[];
              dataSource?: {
                apiGroup?: string;
                kind: string;
                name: string;
                [k: string]: any;
              };
              resources?: {
                limits?: {
                  [k: string]: number | string;
                };
                requests?: {
                  [k: string]: number | string;
                };
                [k: string]: any;
              };
              selector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              storageClassName?: string;
              volumeMode?: string;
              volumeName?: string;
              [k: string]: any;
            };
            [k: string]: any;
          };
          [k: string]: any;
        };
        fc?: {
          fsType?: string;
          lun?: number;
          readOnly?: boolean;
          targetWWNs?: string[];
          wwids?: string[];
          [k: string]: any;
        };
        flexVolume?: {
          driver: string;
          fsType?: string;
          options?: {
            [k: string]: string;
          };
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          [k: string]: any;
        };
        flocker?: {
          datasetName?: string;
          datasetUUID?: string;
          [k: string]: any;
        };
        gcePersistentDisk?: {
          fsType?: string;
          partition?: number;
          pdName: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        gitRepo?: {
          directory?: string;
          repository: string;
          revision?: string;
          [k: string]: any;
        };
        glusterfs?: {
          endpoints: string;
          path: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        hostPath?: {
          path: string;
          type?: string;
          [k: string]: any;
        };
        iscsi?: {
          chapAuthDiscovery?: boolean;
          chapAuthSession?: boolean;
          fsType?: string;
          initiatorName?: string;
          iqn: string;
          iscsiInterface?: string;
          lun: number;
          portals?: string[];
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          targetPortal: string;
          [k: string]: any;
        };
        name: string;
        nfs?: {
          path: string;
          readOnly?: boolean;
          server: string;
          [k: string]: any;
        };
        persistentVolumeClaim?: {
          claimName: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        photonPersistentDisk?: {
          fsType?: string;
          pdID: string;
          [k: string]: any;
        };
        portworxVolume?: {
          fsType?: string;
          readOnly?: boolean;
          volumeID: string;
          [k: string]: any;
        };
        projected?: {
          defaultMode?: number;
          sources?: {
            configMap?: {
              items?: {
                key: string;
                mode?: number;
                path: string;
                [k: string]: any;
              }[];
              name?: string;
              optional?: boolean;
              [k: string]: any;
            };
            downwardAPI?: {
              items?: {
                fieldRef?: {
                  apiVersion?: string;
                  fieldPath: string;
                  [k: string]: any;
                };
                mode?: number;
                path: string;
                resourceFieldRef?: {
                  containerName?: string;
                  divisor?: number | string;
                  resource: string;
                  [k: string]: any;
                };
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            secret?: {
              items?: {
                key: string;
                mode?: number;
                path: string;
                [k: string]: any;
              }[];
              name?: string;
              optional?: boolean;
              [k: string]: any;
            };
            serviceAccountToken?: {
              audience?: string;
              expirationSeconds?: number;
              path: string;
              [k: string]: any;
            };
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        quobyte?: {
          group?: string;
          readOnly?: boolean;
          registry: string;
          tenant?: string;
          user?: string;
          volume: string;
          [k: string]: any;
        };
        rbd?: {
          fsType?: string;
          image: string;
          keyring?: string;
          monitors: string[];
          pool?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          user?: string;
          [k: string]: any;
        };
        scaleIO?: {
          fsType?: string;
          gateway: string;
          protectionDomain?: string;
          readOnly?: boolean;
          secretRef: {
            name?: string;
            [k: string]: any;
          };
          sslEnabled?: boolean;
          storageMode?: string;
          storagePool?: string;
          system: string;
          volumeName?: string;
          [k: string]: any;
        };
        secret?: {
          defaultMode?: number;
          items?: {
            key: string;
            mode?: number;
            path: string;
            [k: string]: any;
          }[];
          optional?: boolean;
          secretName?: string;
          [k: string]: any;
        };
        storageos?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          volumeName?: string;
          volumeNamespace?: string;
          [k: string]: any;
        };
        vsphereVolume?: {
          fsType?: string;
          storagePolicyID?: string;
          storagePolicyName?: string;
          volumePath: string;
          [k: string]: any;
        };
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    allInOne?: {
      affinity?: {
        nodeAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            preference: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchFields?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            nodeSelectorTerms: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchFields?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          [k: string]: any;
        };
        podAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            podAffinityTerm: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        podAntiAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            podAffinityTerm: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        [k: string]: any;
      };
      annotations?: {
        [k: string]: string;
      };
      config?: {
        [k: string]: any;
      };
      image?: string;
      labels?: {
        [k: string]: string;
      };
      options?: {
        [k: string]: any;
      };
      resources?: {
        limits?: {
          [k: string]: number | string;
        };
        requests?: {
          [k: string]: number | string;
        };
        [k: string]: any;
      };
      securityContext?: {
        fsGroup?: number;
        fsGroupChangePolicy?: string;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
          [k: string]: any;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
          [k: string]: any;
        };
        supplementalGroups?: number[];
        sysctls?: {
          name: string;
          value: string;
          [k: string]: any;
        }[];
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          runAsUserName?: string;
          [k: string]: any;
        };
        [k: string]: any;
      };
      serviceAccount?: string;
      strategy?: {
        rollingUpdate?: {
          maxSurge?: number | string;
          maxUnavailable?: number | string;
          [k: string]: any;
        };
        type?: string;
        [k: string]: any;
      };
      tolerations?: {
        effect?: string;
        key?: string;
        operator?: string;
        tolerationSeconds?: number;
        value?: string;
        [k: string]: any;
      }[];
      tracingEnabled?: boolean;
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        subPath?: string;
        subPathExpr?: string;
        [k: string]: any;
      }[];
      volumes?: {
        awsElasticBlockStore?: {
          fsType?: string;
          partition?: number;
          readOnly?: boolean;
          volumeID: string;
          [k: string]: any;
        };
        azureDisk?: {
          cachingMode?: string;
          diskName: string;
          diskURI: string;
          fsType?: string;
          kind?: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        azureFile?: {
          readOnly?: boolean;
          secretName: string;
          shareName: string;
          [k: string]: any;
        };
        cephfs?: {
          monitors: string[];
          path?: string;
          readOnly?: boolean;
          secretFile?: string;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          user?: string;
          [k: string]: any;
        };
        cinder?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          volumeID: string;
          [k: string]: any;
        };
        configMap?: {
          defaultMode?: number;
          items?: {
            key: string;
            mode?: number;
            path: string;
            [k: string]: any;
          }[];
          name?: string;
          optional?: boolean;
          [k: string]: any;
        };
        csi?: {
          driver: string;
          fsType?: string;
          nodePublishSecretRef?: {
            name?: string;
            [k: string]: any;
          };
          readOnly?: boolean;
          volumeAttributes?: {
            [k: string]: string;
          };
          [k: string]: any;
        };
        downwardAPI?: {
          defaultMode?: number;
          items?: {
            fieldRef?: {
              apiVersion?: string;
              fieldPath: string;
              [k: string]: any;
            };
            mode?: number;
            path: string;
            resourceFieldRef?: {
              containerName?: string;
              divisor?: number | string;
              resource: string;
              [k: string]: any;
            };
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        emptyDir?: {
          medium?: string;
          sizeLimit?: number | string;
          [k: string]: any;
        };
        ephemeral?: {
          readOnly?: boolean;
          volumeClaimTemplate?: {
            metadata?: {
              [k: string]: any;
            };
            spec: {
              accessModes?: string[];
              dataSource?: {
                apiGroup?: string;
                kind: string;
                name: string;
                [k: string]: any;
              };
              resources?: {
                limits?: {
                  [k: string]: number | string;
                };
                requests?: {
                  [k: string]: number | string;
                };
                [k: string]: any;
              };
              selector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              storageClassName?: string;
              volumeMode?: string;
              volumeName?: string;
              [k: string]: any;
            };
            [k: string]: any;
          };
          [k: string]: any;
        };
        fc?: {
          fsType?: string;
          lun?: number;
          readOnly?: boolean;
          targetWWNs?: string[];
          wwids?: string[];
          [k: string]: any;
        };
        flexVolume?: {
          driver: string;
          fsType?: string;
          options?: {
            [k: string]: string;
          };
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          [k: string]: any;
        };
        flocker?: {
          datasetName?: string;
          datasetUUID?: string;
          [k: string]: any;
        };
        gcePersistentDisk?: {
          fsType?: string;
          partition?: number;
          pdName: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        gitRepo?: {
          directory?: string;
          repository: string;
          revision?: string;
          [k: string]: any;
        };
        glusterfs?: {
          endpoints: string;
          path: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        hostPath?: {
          path: string;
          type?: string;
          [k: string]: any;
        };
        iscsi?: {
          chapAuthDiscovery?: boolean;
          chapAuthSession?: boolean;
          fsType?: string;
          initiatorName?: string;
          iqn: string;
          iscsiInterface?: string;
          lun: number;
          portals?: string[];
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          targetPortal: string;
          [k: string]: any;
        };
        name: string;
        nfs?: {
          path: string;
          readOnly?: boolean;
          server: string;
          [k: string]: any;
        };
        persistentVolumeClaim?: {
          claimName: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        photonPersistentDisk?: {
          fsType?: string;
          pdID: string;
          [k: string]: any;
        };
        portworxVolume?: {
          fsType?: string;
          readOnly?: boolean;
          volumeID: string;
          [k: string]: any;
        };
        projected?: {
          defaultMode?: number;
          sources?: {
            configMap?: {
              items?: {
                key: string;
                mode?: number;
                path: string;
                [k: string]: any;
              }[];
              name?: string;
              optional?: boolean;
              [k: string]: any;
            };
            downwardAPI?: {
              items?: {
                fieldRef?: {
                  apiVersion?: string;
                  fieldPath: string;
                  [k: string]: any;
                };
                mode?: number;
                path: string;
                resourceFieldRef?: {
                  containerName?: string;
                  divisor?: number | string;
                  resource: string;
                  [k: string]: any;
                };
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            secret?: {
              items?: {
                key: string;
                mode?: number;
                path: string;
                [k: string]: any;
              }[];
              name?: string;
              optional?: boolean;
              [k: string]: any;
            };
            serviceAccountToken?: {
              audience?: string;
              expirationSeconds?: number;
              path: string;
              [k: string]: any;
            };
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        quobyte?: {
          group?: string;
          readOnly?: boolean;
          registry: string;
          tenant?: string;
          user?: string;
          volume: string;
          [k: string]: any;
        };
        rbd?: {
          fsType?: string;
          image: string;
          keyring?: string;
          monitors: string[];
          pool?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          user?: string;
          [k: string]: any;
        };
        scaleIO?: {
          fsType?: string;
          gateway: string;
          protectionDomain?: string;
          readOnly?: boolean;
          secretRef: {
            name?: string;
            [k: string]: any;
          };
          sslEnabled?: boolean;
          storageMode?: string;
          storagePool?: string;
          system: string;
          volumeName?: string;
          [k: string]: any;
        };
        secret?: {
          defaultMode?: number;
          items?: {
            key: string;
            mode?: number;
            path: string;
            [k: string]: any;
          }[];
          optional?: boolean;
          secretName?: string;
          [k: string]: any;
        };
        storageos?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          volumeName?: string;
          volumeNamespace?: string;
          [k: string]: any;
        };
        vsphereVolume?: {
          fsType?: string;
          storagePolicyID?: string;
          storagePolicyName?: string;
          volumePath: string;
          [k: string]: any;
        };
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    annotations?: {
      [k: string]: string;
    };
    collector?: {
      affinity?: {
        nodeAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            preference: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchFields?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            nodeSelectorTerms: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchFields?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          [k: string]: any;
        };
        podAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            podAffinityTerm: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        podAntiAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            podAffinityTerm: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        [k: string]: any;
      };
      annotations?: {
        [k: string]: string;
      };
      autoscale?: boolean;
      config?: {
        [k: string]: any;
      };
      image?: string;
      labels?: {
        [k: string]: string;
      };
      maxReplicas?: number;
      minReplicas?: number;
      options?: {
        [k: string]: any;
      };
      priorityClassName?: string;
      replicas?: number;
      resources?: {
        limits?: {
          [k: string]: number | string;
        };
        requests?: {
          [k: string]: number | string;
        };
        [k: string]: any;
      };
      securityContext?: {
        fsGroup?: number;
        fsGroupChangePolicy?: string;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
          [k: string]: any;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
          [k: string]: any;
        };
        supplementalGroups?: number[];
        sysctls?: {
          name: string;
          value: string;
          [k: string]: any;
        }[];
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          runAsUserName?: string;
          [k: string]: any;
        };
        [k: string]: any;
      };
      serviceAccount?: string;
      serviceType?: string;
      strategy?: {
        rollingUpdate?: {
          maxSurge?: number | string;
          maxUnavailable?: number | string;
          [k: string]: any;
        };
        type?: string;
        [k: string]: any;
      };
      tolerations?: {
        effect?: string;
        key?: string;
        operator?: string;
        tolerationSeconds?: number;
        value?: string;
        [k: string]: any;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        subPath?: string;
        subPathExpr?: string;
        [k: string]: any;
      }[];
      volumes?: {
        awsElasticBlockStore?: {
          fsType?: string;
          partition?: number;
          readOnly?: boolean;
          volumeID: string;
          [k: string]: any;
        };
        azureDisk?: {
          cachingMode?: string;
          diskName: string;
          diskURI: string;
          fsType?: string;
          kind?: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        azureFile?: {
          readOnly?: boolean;
          secretName: string;
          shareName: string;
          [k: string]: any;
        };
        cephfs?: {
          monitors: string[];
          path?: string;
          readOnly?: boolean;
          secretFile?: string;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          user?: string;
          [k: string]: any;
        };
        cinder?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          volumeID: string;
          [k: string]: any;
        };
        configMap?: {
          defaultMode?: number;
          items?: {
            key: string;
            mode?: number;
            path: string;
            [k: string]: any;
          }[];
          name?: string;
          optional?: boolean;
          [k: string]: any;
        };
        csi?: {
          driver: string;
          fsType?: string;
          nodePublishSecretRef?: {
            name?: string;
            [k: string]: any;
          };
          readOnly?: boolean;
          volumeAttributes?: {
            [k: string]: string;
          };
          [k: string]: any;
        };
        downwardAPI?: {
          defaultMode?: number;
          items?: {
            fieldRef?: {
              apiVersion?: string;
              fieldPath: string;
              [k: string]: any;
            };
            mode?: number;
            path: string;
            resourceFieldRef?: {
              containerName?: string;
              divisor?: number | string;
              resource: string;
              [k: string]: any;
            };
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        emptyDir?: {
          medium?: string;
          sizeLimit?: number | string;
          [k: string]: any;
        };
        ephemeral?: {
          readOnly?: boolean;
          volumeClaimTemplate?: {
            metadata?: {
              [k: string]: any;
            };
            spec: {
              accessModes?: string[];
              dataSource?: {
                apiGroup?: string;
                kind: string;
                name: string;
                [k: string]: any;
              };
              resources?: {
                limits?: {
                  [k: string]: number | string;
                };
                requests?: {
                  [k: string]: number | string;
                };
                [k: string]: any;
              };
              selector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              storageClassName?: string;
              volumeMode?: string;
              volumeName?: string;
              [k: string]: any;
            };
            [k: string]: any;
          };
          [k: string]: any;
        };
        fc?: {
          fsType?: string;
          lun?: number;
          readOnly?: boolean;
          targetWWNs?: string[];
          wwids?: string[];
          [k: string]: any;
        };
        flexVolume?: {
          driver: string;
          fsType?: string;
          options?: {
            [k: string]: string;
          };
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          [k: string]: any;
        };
        flocker?: {
          datasetName?: string;
          datasetUUID?: string;
          [k: string]: any;
        };
        gcePersistentDisk?: {
          fsType?: string;
          partition?: number;
          pdName: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        gitRepo?: {
          directory?: string;
          repository: string;
          revision?: string;
          [k: string]: any;
        };
        glusterfs?: {
          endpoints: string;
          path: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        hostPath?: {
          path: string;
          type?: string;
          [k: string]: any;
        };
        iscsi?: {
          chapAuthDiscovery?: boolean;
          chapAuthSession?: boolean;
          fsType?: string;
          initiatorName?: string;
          iqn: string;
          iscsiInterface?: string;
          lun: number;
          portals?: string[];
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          targetPortal: string;
          [k: string]: any;
        };
        name: string;
        nfs?: {
          path: string;
          readOnly?: boolean;
          server: string;
          [k: string]: any;
        };
        persistentVolumeClaim?: {
          claimName: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        photonPersistentDisk?: {
          fsType?: string;
          pdID: string;
          [k: string]: any;
        };
        portworxVolume?: {
          fsType?: string;
          readOnly?: boolean;
          volumeID: string;
          [k: string]: any;
        };
        projected?: {
          defaultMode?: number;
          sources?: {
            configMap?: {
              items?: {
                key: string;
                mode?: number;
                path: string;
                [k: string]: any;
              }[];
              name?: string;
              optional?: boolean;
              [k: string]: any;
            };
            downwardAPI?: {
              items?: {
                fieldRef?: {
                  apiVersion?: string;
                  fieldPath: string;
                  [k: string]: any;
                };
                mode?: number;
                path: string;
                resourceFieldRef?: {
                  containerName?: string;
                  divisor?: number | string;
                  resource: string;
                  [k: string]: any;
                };
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            secret?: {
              items?: {
                key: string;
                mode?: number;
                path: string;
                [k: string]: any;
              }[];
              name?: string;
              optional?: boolean;
              [k: string]: any;
            };
            serviceAccountToken?: {
              audience?: string;
              expirationSeconds?: number;
              path: string;
              [k: string]: any;
            };
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        quobyte?: {
          group?: string;
          readOnly?: boolean;
          registry: string;
          tenant?: string;
          user?: string;
          volume: string;
          [k: string]: any;
        };
        rbd?: {
          fsType?: string;
          image: string;
          keyring?: string;
          monitors: string[];
          pool?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          user?: string;
          [k: string]: any;
        };
        scaleIO?: {
          fsType?: string;
          gateway: string;
          protectionDomain?: string;
          readOnly?: boolean;
          secretRef: {
            name?: string;
            [k: string]: any;
          };
          sslEnabled?: boolean;
          storageMode?: string;
          storagePool?: string;
          system: string;
          volumeName?: string;
          [k: string]: any;
        };
        secret?: {
          defaultMode?: number;
          items?: {
            key: string;
            mode?: number;
            path: string;
            [k: string]: any;
          }[];
          optional?: boolean;
          secretName?: string;
          [k: string]: any;
        };
        storageos?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          volumeName?: string;
          volumeNamespace?: string;
          [k: string]: any;
        };
        vsphereVolume?: {
          fsType?: string;
          storagePolicyID?: string;
          storagePolicyName?: string;
          volumePath: string;
          [k: string]: any;
        };
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    ingester?: {
      affinity?: {
        nodeAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            preference: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchFields?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            nodeSelectorTerms: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchFields?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          [k: string]: any;
        };
        podAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            podAffinityTerm: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        podAntiAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            podAffinityTerm: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        [k: string]: any;
      };
      annotations?: {
        [k: string]: string;
      };
      autoscale?: boolean;
      config?: {
        [k: string]: any;
      };
      image?: string;
      labels?: {
        [k: string]: string;
      };
      maxReplicas?: number;
      minReplicas?: number;
      options?: {
        [k: string]: any;
      };
      replicas?: number;
      resources?: {
        limits?: {
          [k: string]: number | string;
        };
        requests?: {
          [k: string]: number | string;
        };
        [k: string]: any;
      };
      securityContext?: {
        fsGroup?: number;
        fsGroupChangePolicy?: string;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
          [k: string]: any;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
          [k: string]: any;
        };
        supplementalGroups?: number[];
        sysctls?: {
          name: string;
          value: string;
          [k: string]: any;
        }[];
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          runAsUserName?: string;
          [k: string]: any;
        };
        [k: string]: any;
      };
      serviceAccount?: string;
      strategy?: {
        rollingUpdate?: {
          maxSurge?: number | string;
          maxUnavailable?: number | string;
          [k: string]: any;
        };
        type?: string;
        [k: string]: any;
      };
      tolerations?: {
        effect?: string;
        key?: string;
        operator?: string;
        tolerationSeconds?: number;
        value?: string;
        [k: string]: any;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        subPath?: string;
        subPathExpr?: string;
        [k: string]: any;
      }[];
      volumes?: {
        awsElasticBlockStore?: {
          fsType?: string;
          partition?: number;
          readOnly?: boolean;
          volumeID: string;
          [k: string]: any;
        };
        azureDisk?: {
          cachingMode?: string;
          diskName: string;
          diskURI: string;
          fsType?: string;
          kind?: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        azureFile?: {
          readOnly?: boolean;
          secretName: string;
          shareName: string;
          [k: string]: any;
        };
        cephfs?: {
          monitors: string[];
          path?: string;
          readOnly?: boolean;
          secretFile?: string;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          user?: string;
          [k: string]: any;
        };
        cinder?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          volumeID: string;
          [k: string]: any;
        };
        configMap?: {
          defaultMode?: number;
          items?: {
            key: string;
            mode?: number;
            path: string;
            [k: string]: any;
          }[];
          name?: string;
          optional?: boolean;
          [k: string]: any;
        };
        csi?: {
          driver: string;
          fsType?: string;
          nodePublishSecretRef?: {
            name?: string;
            [k: string]: any;
          };
          readOnly?: boolean;
          volumeAttributes?: {
            [k: string]: string;
          };
          [k: string]: any;
        };
        downwardAPI?: {
          defaultMode?: number;
          items?: {
            fieldRef?: {
              apiVersion?: string;
              fieldPath: string;
              [k: string]: any;
            };
            mode?: number;
            path: string;
            resourceFieldRef?: {
              containerName?: string;
              divisor?: number | string;
              resource: string;
              [k: string]: any;
            };
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        emptyDir?: {
          medium?: string;
          sizeLimit?: number | string;
          [k: string]: any;
        };
        ephemeral?: {
          readOnly?: boolean;
          volumeClaimTemplate?: {
            metadata?: {
              [k: string]: any;
            };
            spec: {
              accessModes?: string[];
              dataSource?: {
                apiGroup?: string;
                kind: string;
                name: string;
                [k: string]: any;
              };
              resources?: {
                limits?: {
                  [k: string]: number | string;
                };
                requests?: {
                  [k: string]: number | string;
                };
                [k: string]: any;
              };
              selector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              storageClassName?: string;
              volumeMode?: string;
              volumeName?: string;
              [k: string]: any;
            };
            [k: string]: any;
          };
          [k: string]: any;
        };
        fc?: {
          fsType?: string;
          lun?: number;
          readOnly?: boolean;
          targetWWNs?: string[];
          wwids?: string[];
          [k: string]: any;
        };
        flexVolume?: {
          driver: string;
          fsType?: string;
          options?: {
            [k: string]: string;
          };
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          [k: string]: any;
        };
        flocker?: {
          datasetName?: string;
          datasetUUID?: string;
          [k: string]: any;
        };
        gcePersistentDisk?: {
          fsType?: string;
          partition?: number;
          pdName: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        gitRepo?: {
          directory?: string;
          repository: string;
          revision?: string;
          [k: string]: any;
        };
        glusterfs?: {
          endpoints: string;
          path: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        hostPath?: {
          path: string;
          type?: string;
          [k: string]: any;
        };
        iscsi?: {
          chapAuthDiscovery?: boolean;
          chapAuthSession?: boolean;
          fsType?: string;
          initiatorName?: string;
          iqn: string;
          iscsiInterface?: string;
          lun: number;
          portals?: string[];
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          targetPortal: string;
          [k: string]: any;
        };
        name: string;
        nfs?: {
          path: string;
          readOnly?: boolean;
          server: string;
          [k: string]: any;
        };
        persistentVolumeClaim?: {
          claimName: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        photonPersistentDisk?: {
          fsType?: string;
          pdID: string;
          [k: string]: any;
        };
        portworxVolume?: {
          fsType?: string;
          readOnly?: boolean;
          volumeID: string;
          [k: string]: any;
        };
        projected?: {
          defaultMode?: number;
          sources?: {
            configMap?: {
              items?: {
                key: string;
                mode?: number;
                path: string;
                [k: string]: any;
              }[];
              name?: string;
              optional?: boolean;
              [k: string]: any;
            };
            downwardAPI?: {
              items?: {
                fieldRef?: {
                  apiVersion?: string;
                  fieldPath: string;
                  [k: string]: any;
                };
                mode?: number;
                path: string;
                resourceFieldRef?: {
                  containerName?: string;
                  divisor?: number | string;
                  resource: string;
                  [k: string]: any;
                };
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            secret?: {
              items?: {
                key: string;
                mode?: number;
                path: string;
                [k: string]: any;
              }[];
              name?: string;
              optional?: boolean;
              [k: string]: any;
            };
            serviceAccountToken?: {
              audience?: string;
              expirationSeconds?: number;
              path: string;
              [k: string]: any;
            };
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        quobyte?: {
          group?: string;
          readOnly?: boolean;
          registry: string;
          tenant?: string;
          user?: string;
          volume: string;
          [k: string]: any;
        };
        rbd?: {
          fsType?: string;
          image: string;
          keyring?: string;
          monitors: string[];
          pool?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          user?: string;
          [k: string]: any;
        };
        scaleIO?: {
          fsType?: string;
          gateway: string;
          protectionDomain?: string;
          readOnly?: boolean;
          secretRef: {
            name?: string;
            [k: string]: any;
          };
          sslEnabled?: boolean;
          storageMode?: string;
          storagePool?: string;
          system: string;
          volumeName?: string;
          [k: string]: any;
        };
        secret?: {
          defaultMode?: number;
          items?: {
            key: string;
            mode?: number;
            path: string;
            [k: string]: any;
          }[];
          optional?: boolean;
          secretName?: string;
          [k: string]: any;
        };
        storageos?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          volumeName?: string;
          volumeNamespace?: string;
          [k: string]: any;
        };
        vsphereVolume?: {
          fsType?: string;
          storagePolicyID?: string;
          storagePolicyName?: string;
          volumePath: string;
          [k: string]: any;
        };
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    ingress?: {
      affinity?: {
        nodeAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            preference: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchFields?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            nodeSelectorTerms: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchFields?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          [k: string]: any;
        };
        podAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            podAffinityTerm: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        podAntiAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            podAffinityTerm: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        [k: string]: any;
      };
      annotations?: {
        [k: string]: string;
      };
      enabled?: boolean;
      hosts?: string[];
      ingressClassName?: string;
      labels?: {
        [k: string]: string;
      };
      openshift?: {
        delegateUrls?: string;
        htpasswdFile?: string;
        sar?: string;
        skipLogout?: boolean;
        [k: string]: any;
      };
      options?: {
        [k: string]: any;
      };
      resources?: {
        limits?: {
          [k: string]: number | string;
        };
        requests?: {
          [k: string]: number | string;
        };
        [k: string]: any;
      };
      secretName?: string;
      security?: string;
      securityContext?: {
        fsGroup?: number;
        fsGroupChangePolicy?: string;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
          [k: string]: any;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
          [k: string]: any;
        };
        supplementalGroups?: number[];
        sysctls?: {
          name: string;
          value: string;
          [k: string]: any;
        }[];
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          runAsUserName?: string;
          [k: string]: any;
        };
        [k: string]: any;
      };
      serviceAccount?: string;
      tls?: {
        hosts?: string[];
        secretName?: string;
        [k: string]: any;
      }[];
      tolerations?: {
        effect?: string;
        key?: string;
        operator?: string;
        tolerationSeconds?: number;
        value?: string;
        [k: string]: any;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        subPath?: string;
        subPathExpr?: string;
        [k: string]: any;
      }[];
      volumes?: {
        awsElasticBlockStore?: {
          fsType?: string;
          partition?: number;
          readOnly?: boolean;
          volumeID: string;
          [k: string]: any;
        };
        azureDisk?: {
          cachingMode?: string;
          diskName: string;
          diskURI: string;
          fsType?: string;
          kind?: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        azureFile?: {
          readOnly?: boolean;
          secretName: string;
          shareName: string;
          [k: string]: any;
        };
        cephfs?: {
          monitors: string[];
          path?: string;
          readOnly?: boolean;
          secretFile?: string;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          user?: string;
          [k: string]: any;
        };
        cinder?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          volumeID: string;
          [k: string]: any;
        };
        configMap?: {
          defaultMode?: number;
          items?: {
            key: string;
            mode?: number;
            path: string;
            [k: string]: any;
          }[];
          name?: string;
          optional?: boolean;
          [k: string]: any;
        };
        csi?: {
          driver: string;
          fsType?: string;
          nodePublishSecretRef?: {
            name?: string;
            [k: string]: any;
          };
          readOnly?: boolean;
          volumeAttributes?: {
            [k: string]: string;
          };
          [k: string]: any;
        };
        downwardAPI?: {
          defaultMode?: number;
          items?: {
            fieldRef?: {
              apiVersion?: string;
              fieldPath: string;
              [k: string]: any;
            };
            mode?: number;
            path: string;
            resourceFieldRef?: {
              containerName?: string;
              divisor?: number | string;
              resource: string;
              [k: string]: any;
            };
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        emptyDir?: {
          medium?: string;
          sizeLimit?: number | string;
          [k: string]: any;
        };
        ephemeral?: {
          readOnly?: boolean;
          volumeClaimTemplate?: {
            metadata?: {
              [k: string]: any;
            };
            spec: {
              accessModes?: string[];
              dataSource?: {
                apiGroup?: string;
                kind: string;
                name: string;
                [k: string]: any;
              };
              resources?: {
                limits?: {
                  [k: string]: number | string;
                };
                requests?: {
                  [k: string]: number | string;
                };
                [k: string]: any;
              };
              selector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              storageClassName?: string;
              volumeMode?: string;
              volumeName?: string;
              [k: string]: any;
            };
            [k: string]: any;
          };
          [k: string]: any;
        };
        fc?: {
          fsType?: string;
          lun?: number;
          readOnly?: boolean;
          targetWWNs?: string[];
          wwids?: string[];
          [k: string]: any;
        };
        flexVolume?: {
          driver: string;
          fsType?: string;
          options?: {
            [k: string]: string;
          };
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          [k: string]: any;
        };
        flocker?: {
          datasetName?: string;
          datasetUUID?: string;
          [k: string]: any;
        };
        gcePersistentDisk?: {
          fsType?: string;
          partition?: number;
          pdName: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        gitRepo?: {
          directory?: string;
          repository: string;
          revision?: string;
          [k: string]: any;
        };
        glusterfs?: {
          endpoints: string;
          path: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        hostPath?: {
          path: string;
          type?: string;
          [k: string]: any;
        };
        iscsi?: {
          chapAuthDiscovery?: boolean;
          chapAuthSession?: boolean;
          fsType?: string;
          initiatorName?: string;
          iqn: string;
          iscsiInterface?: string;
          lun: number;
          portals?: string[];
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          targetPortal: string;
          [k: string]: any;
        };
        name: string;
        nfs?: {
          path: string;
          readOnly?: boolean;
          server: string;
          [k: string]: any;
        };
        persistentVolumeClaim?: {
          claimName: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        photonPersistentDisk?: {
          fsType?: string;
          pdID: string;
          [k: string]: any;
        };
        portworxVolume?: {
          fsType?: string;
          readOnly?: boolean;
          volumeID: string;
          [k: string]: any;
        };
        projected?: {
          defaultMode?: number;
          sources?: {
            configMap?: {
              items?: {
                key: string;
                mode?: number;
                path: string;
                [k: string]: any;
              }[];
              name?: string;
              optional?: boolean;
              [k: string]: any;
            };
            downwardAPI?: {
              items?: {
                fieldRef?: {
                  apiVersion?: string;
                  fieldPath: string;
                  [k: string]: any;
                };
                mode?: number;
                path: string;
                resourceFieldRef?: {
                  containerName?: string;
                  divisor?: number | string;
                  resource: string;
                  [k: string]: any;
                };
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            secret?: {
              items?: {
                key: string;
                mode?: number;
                path: string;
                [k: string]: any;
              }[];
              name?: string;
              optional?: boolean;
              [k: string]: any;
            };
            serviceAccountToken?: {
              audience?: string;
              expirationSeconds?: number;
              path: string;
              [k: string]: any;
            };
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        quobyte?: {
          group?: string;
          readOnly?: boolean;
          registry: string;
          tenant?: string;
          user?: string;
          volume: string;
          [k: string]: any;
        };
        rbd?: {
          fsType?: string;
          image: string;
          keyring?: string;
          monitors: string[];
          pool?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          user?: string;
          [k: string]: any;
        };
        scaleIO?: {
          fsType?: string;
          gateway: string;
          protectionDomain?: string;
          readOnly?: boolean;
          secretRef: {
            name?: string;
            [k: string]: any;
          };
          sslEnabled?: boolean;
          storageMode?: string;
          storagePool?: string;
          system: string;
          volumeName?: string;
          [k: string]: any;
        };
        secret?: {
          defaultMode?: number;
          items?: {
            key: string;
            mode?: number;
            path: string;
            [k: string]: any;
          }[];
          optional?: boolean;
          secretName?: string;
          [k: string]: any;
        };
        storageos?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          volumeName?: string;
          volumeNamespace?: string;
          [k: string]: any;
        };
        vsphereVolume?: {
          fsType?: string;
          storagePolicyID?: string;
          storagePolicyName?: string;
          volumePath: string;
          [k: string]: any;
        };
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    labels?: {
      [k: string]: string;
    };
    query?: {
      affinity?: {
        nodeAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            preference: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchFields?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            nodeSelectorTerms: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchFields?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          [k: string]: any;
        };
        podAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            podAffinityTerm: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        podAntiAffinity?: {
          preferredDuringSchedulingIgnoredDuringExecution?: {
            podAffinityTerm: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            };
            weight: number;
            [k: string]: any;
          }[];
          requiredDuringSchedulingIgnoredDuringExecution?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            namespaces?: string[];
            topologyKey: string;
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        [k: string]: any;
      };
      annotations?: {
        [k: string]: string;
      };
      grpcNodePort?: number;
      image?: string;
      labels?: {
        [k: string]: string;
      };
      nodePort?: number;
      options?: {
        [k: string]: any;
      };
      priorityClassName?: string;
      replicas?: number;
      resources?: {
        limits?: {
          [k: string]: number | string;
        };
        requests?: {
          [k: string]: number | string;
        };
        [k: string]: any;
      };
      securityContext?: {
        fsGroup?: number;
        fsGroupChangePolicy?: string;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
          [k: string]: any;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
          [k: string]: any;
        };
        supplementalGroups?: number[];
        sysctls?: {
          name: string;
          value: string;
          [k: string]: any;
        }[];
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          runAsUserName?: string;
          [k: string]: any;
        };
        [k: string]: any;
      };
      serviceAccount?: string;
      serviceType?: string;
      strategy?: {
        rollingUpdate?: {
          maxSurge?: number | string;
          maxUnavailable?: number | string;
          [k: string]: any;
        };
        type?: string;
        [k: string]: any;
      };
      tolerations?: {
        effect?: string;
        key?: string;
        operator?: string;
        tolerationSeconds?: number;
        value?: string;
        [k: string]: any;
      }[];
      tracingEnabled?: boolean;
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        subPath?: string;
        subPathExpr?: string;
        [k: string]: any;
      }[];
      volumes?: {
        awsElasticBlockStore?: {
          fsType?: string;
          partition?: number;
          readOnly?: boolean;
          volumeID: string;
          [k: string]: any;
        };
        azureDisk?: {
          cachingMode?: string;
          diskName: string;
          diskURI: string;
          fsType?: string;
          kind?: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        azureFile?: {
          readOnly?: boolean;
          secretName: string;
          shareName: string;
          [k: string]: any;
        };
        cephfs?: {
          monitors: string[];
          path?: string;
          readOnly?: boolean;
          secretFile?: string;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          user?: string;
          [k: string]: any;
        };
        cinder?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          volumeID: string;
          [k: string]: any;
        };
        configMap?: {
          defaultMode?: number;
          items?: {
            key: string;
            mode?: number;
            path: string;
            [k: string]: any;
          }[];
          name?: string;
          optional?: boolean;
          [k: string]: any;
        };
        csi?: {
          driver: string;
          fsType?: string;
          nodePublishSecretRef?: {
            name?: string;
            [k: string]: any;
          };
          readOnly?: boolean;
          volumeAttributes?: {
            [k: string]: string;
          };
          [k: string]: any;
        };
        downwardAPI?: {
          defaultMode?: number;
          items?: {
            fieldRef?: {
              apiVersion?: string;
              fieldPath: string;
              [k: string]: any;
            };
            mode?: number;
            path: string;
            resourceFieldRef?: {
              containerName?: string;
              divisor?: number | string;
              resource: string;
              [k: string]: any;
            };
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        emptyDir?: {
          medium?: string;
          sizeLimit?: number | string;
          [k: string]: any;
        };
        ephemeral?: {
          readOnly?: boolean;
          volumeClaimTemplate?: {
            metadata?: {
              [k: string]: any;
            };
            spec: {
              accessModes?: string[];
              dataSource?: {
                apiGroup?: string;
                kind: string;
                name: string;
                [k: string]: any;
              };
              resources?: {
                limits?: {
                  [k: string]: number | string;
                };
                requests?: {
                  [k: string]: number | string;
                };
                [k: string]: any;
              };
              selector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              storageClassName?: string;
              volumeMode?: string;
              volumeName?: string;
              [k: string]: any;
            };
            [k: string]: any;
          };
          [k: string]: any;
        };
        fc?: {
          fsType?: string;
          lun?: number;
          readOnly?: boolean;
          targetWWNs?: string[];
          wwids?: string[];
          [k: string]: any;
        };
        flexVolume?: {
          driver: string;
          fsType?: string;
          options?: {
            [k: string]: string;
          };
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          [k: string]: any;
        };
        flocker?: {
          datasetName?: string;
          datasetUUID?: string;
          [k: string]: any;
        };
        gcePersistentDisk?: {
          fsType?: string;
          partition?: number;
          pdName: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        gitRepo?: {
          directory?: string;
          repository: string;
          revision?: string;
          [k: string]: any;
        };
        glusterfs?: {
          endpoints: string;
          path: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        hostPath?: {
          path: string;
          type?: string;
          [k: string]: any;
        };
        iscsi?: {
          chapAuthDiscovery?: boolean;
          chapAuthSession?: boolean;
          fsType?: string;
          initiatorName?: string;
          iqn: string;
          iscsiInterface?: string;
          lun: number;
          portals?: string[];
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          targetPortal: string;
          [k: string]: any;
        };
        name: string;
        nfs?: {
          path: string;
          readOnly?: boolean;
          server: string;
          [k: string]: any;
        };
        persistentVolumeClaim?: {
          claimName: string;
          readOnly?: boolean;
          [k: string]: any;
        };
        photonPersistentDisk?: {
          fsType?: string;
          pdID: string;
          [k: string]: any;
        };
        portworxVolume?: {
          fsType?: string;
          readOnly?: boolean;
          volumeID: string;
          [k: string]: any;
        };
        projected?: {
          defaultMode?: number;
          sources?: {
            configMap?: {
              items?: {
                key: string;
                mode?: number;
                path: string;
                [k: string]: any;
              }[];
              name?: string;
              optional?: boolean;
              [k: string]: any;
            };
            downwardAPI?: {
              items?: {
                fieldRef?: {
                  apiVersion?: string;
                  fieldPath: string;
                  [k: string]: any;
                };
                mode?: number;
                path: string;
                resourceFieldRef?: {
                  containerName?: string;
                  divisor?: number | string;
                  resource: string;
                  [k: string]: any;
                };
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            secret?: {
              items?: {
                key: string;
                mode?: number;
                path: string;
                [k: string]: any;
              }[];
              name?: string;
              optional?: boolean;
              [k: string]: any;
            };
            serviceAccountToken?: {
              audience?: string;
              expirationSeconds?: number;
              path: string;
              [k: string]: any;
            };
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        quobyte?: {
          group?: string;
          readOnly?: boolean;
          registry: string;
          tenant?: string;
          user?: string;
          volume: string;
          [k: string]: any;
        };
        rbd?: {
          fsType?: string;
          image: string;
          keyring?: string;
          monitors: string[];
          pool?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          user?: string;
          [k: string]: any;
        };
        scaleIO?: {
          fsType?: string;
          gateway: string;
          protectionDomain?: string;
          readOnly?: boolean;
          secretRef: {
            name?: string;
            [k: string]: any;
          };
          sslEnabled?: boolean;
          storageMode?: string;
          storagePool?: string;
          system: string;
          volumeName?: string;
          [k: string]: any;
        };
        secret?: {
          defaultMode?: number;
          items?: {
            key: string;
            mode?: number;
            path: string;
            [k: string]: any;
          }[];
          optional?: boolean;
          secretName?: string;
          [k: string]: any;
        };
        storageos?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: {
            name?: string;
            [k: string]: any;
          };
          volumeName?: string;
          volumeNamespace?: string;
          [k: string]: any;
        };
        vsphereVolume?: {
          fsType?: string;
          storagePolicyID?: string;
          storagePolicyName?: string;
          volumePath: string;
          [k: string]: any;
        };
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    resources?: {
      limits?: {
        [k: string]: number | string;
      };
      requests?: {
        [k: string]: number | string;
      };
      [k: string]: any;
    };
    sampling?: {
      options?: {
        [k: string]: any;
      };
      [k: string]: any;
    };
    securityContext?: {
      fsGroup?: number;
      fsGroupChangePolicy?: string;
      runAsGroup?: number;
      runAsNonRoot?: boolean;
      runAsUser?: number;
      seLinuxOptions?: {
        level?: string;
        role?: string;
        type?: string;
        user?: string;
        [k: string]: any;
      };
      seccompProfile?: {
        localhostProfile?: string;
        type: string;
        [k: string]: any;
      };
      supplementalGroups?: number[];
      sysctls?: {
        name: string;
        value: string;
        [k: string]: any;
      }[];
      windowsOptions?: {
        gmsaCredentialSpec?: string;
        gmsaCredentialSpecName?: string;
        runAsUserName?: string;
        [k: string]: any;
      };
      [k: string]: any;
    };
    serviceAccount?: string;
    storage?: {
      cassandraCreateSchema?: {
        affinity?: {
          nodeAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              preference: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchFields?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                [k: string]: any;
              };
              weight: number;
              [k: string]: any;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              nodeSelectorTerms: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchFields?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            [k: string]: any;
          };
          podAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              podAffinityTerm: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                    [k: string]: any;
                  }[];
                  matchLabels?: {
                    [k: string]: string;
                  };
                  [k: string]: any;
                };
                namespaces?: string[];
                topologyKey: string;
                [k: string]: any;
              };
              weight: number;
              [k: string]: any;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          podAntiAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              podAffinityTerm: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                    [k: string]: any;
                  }[];
                  matchLabels?: {
                    [k: string]: string;
                  };
                  [k: string]: any;
                };
                namespaces?: string[];
                topologyKey: string;
                [k: string]: any;
              };
              weight: number;
              [k: string]: any;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          [k: string]: any;
        };
        datacenter?: string;
        enabled?: boolean;
        image?: string;
        mode?: string;
        timeout?: string;
        traceTTL?: string;
        ttlSecondsAfterFinished?: number;
        [k: string]: any;
      };
      dependencies?: {
        affinity?: {
          nodeAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              preference: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchFields?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                [k: string]: any;
              };
              weight: number;
              [k: string]: any;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              nodeSelectorTerms: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchFields?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            [k: string]: any;
          };
          podAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              podAffinityTerm: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                    [k: string]: any;
                  }[];
                  matchLabels?: {
                    [k: string]: string;
                  };
                  [k: string]: any;
                };
                namespaces?: string[];
                topologyKey: string;
                [k: string]: any;
              };
              weight: number;
              [k: string]: any;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          podAntiAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              podAffinityTerm: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                    [k: string]: any;
                  }[];
                  matchLabels?: {
                    [k: string]: string;
                  };
                  [k: string]: any;
                };
                namespaces?: string[];
                topologyKey: string;
                [k: string]: any;
              };
              weight: number;
              [k: string]: any;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          [k: string]: any;
        };
        annotations?: {
          [k: string]: string;
        };
        backoffLimit?: number;
        cassandraClientAuthEnabled?: boolean;
        elasticsearchClientNodeOnly?: boolean;
        elasticsearchNodesWanOnly?: boolean;
        elasticsearchTimeRange?: string;
        enabled?: boolean;
        image?: string;
        javaOpts?: string;
        labels?: {
          [k: string]: string;
        };
        resources?: {
          limits?: {
            [k: string]: number | string;
          };
          requests?: {
            [k: string]: number | string;
          };
          [k: string]: any;
        };
        schedule?: string;
        securityContext?: {
          fsGroup?: number;
          fsGroupChangePolicy?: string;
          runAsGroup?: number;
          runAsNonRoot?: boolean;
          runAsUser?: number;
          seLinuxOptions?: {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
            [k: string]: any;
          };
          seccompProfile?: {
            localhostProfile?: string;
            type: string;
            [k: string]: any;
          };
          supplementalGroups?: number[];
          sysctls?: {
            name: string;
            value: string;
            [k: string]: any;
          }[];
          windowsOptions?: {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
            [k: string]: any;
          };
          [k: string]: any;
        };
        serviceAccount?: string;
        sparkMaster?: string;
        successfulJobsHistoryLimit?: number;
        tolerations?: {
          effect?: string;
          key?: string;
          operator?: string;
          tolerationSeconds?: number;
          value?: string;
          [k: string]: any;
        }[];
        ttlSecondsAfterFinished?: number;
        volumeMounts?: {
          mountPath: string;
          mountPropagation?: string;
          name: string;
          readOnly?: boolean;
          subPath?: string;
          subPathExpr?: string;
          [k: string]: any;
        }[];
        volumes?: {
          awsElasticBlockStore?: {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
            [k: string]: any;
          };
          azureDisk?: {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
            [k: string]: any;
          };
          azureFile?: {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
            [k: string]: any;
          };
          cephfs?: {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            user?: string;
            [k: string]: any;
          };
          cinder?: {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            volumeID: string;
            [k: string]: any;
          };
          configMap?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
              [k: string]: any;
            }[];
            name?: string;
            optional?: boolean;
            [k: string]: any;
          };
          csi?: {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: {
              name?: string;
              [k: string]: any;
            };
            readOnly?: boolean;
            volumeAttributes?: {
              [k: string]: string;
            };
            [k: string]: any;
          };
          downwardAPI?: {
            defaultMode?: number;
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
                [k: string]: any;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: number | string;
                resource: string;
                [k: string]: any;
              };
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          emptyDir?: {
            medium?: string;
            sizeLimit?: number | string;
            [k: string]: any;
          };
          ephemeral?: {
            readOnly?: boolean;
            volumeClaimTemplate?: {
              metadata?: {
                [k: string]: any;
              };
              spec: {
                accessModes?: string[];
                dataSource?: {
                  apiGroup?: string;
                  kind: string;
                  name: string;
                  [k: string]: any;
                };
                resources?: {
                  limits?: {
                    [k: string]: number | string;
                  };
                  requests?: {
                    [k: string]: number | string;
                  };
                  [k: string]: any;
                };
                selector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                    [k: string]: any;
                  }[];
                  matchLabels?: {
                    [k: string]: string;
                  };
                  [k: string]: any;
                };
                storageClassName?: string;
                volumeMode?: string;
                volumeName?: string;
                [k: string]: any;
              };
              [k: string]: any;
            };
            [k: string]: any;
          };
          fc?: {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
            [k: string]: any;
          };
          flexVolume?: {
            driver: string;
            fsType?: string;
            options?: {
              [k: string]: string;
            };
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            [k: string]: any;
          };
          flocker?: {
            datasetName?: string;
            datasetUUID?: string;
            [k: string]: any;
          };
          gcePersistentDisk?: {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
            [k: string]: any;
          };
          gitRepo?: {
            directory?: string;
            repository: string;
            revision?: string;
            [k: string]: any;
          };
          glusterfs?: {
            endpoints: string;
            path: string;
            readOnly?: boolean;
            [k: string]: any;
          };
          hostPath?: {
            path: string;
            type?: string;
            [k: string]: any;
          };
          iscsi?: {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            targetPortal: string;
            [k: string]: any;
          };
          name: string;
          nfs?: {
            path: string;
            readOnly?: boolean;
            server: string;
            [k: string]: any;
          };
          persistentVolumeClaim?: {
            claimName: string;
            readOnly?: boolean;
            [k: string]: any;
          };
          photonPersistentDisk?: {
            fsType?: string;
            pdID: string;
            [k: string]: any;
          };
          portworxVolume?: {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
            [k: string]: any;
          };
          projected?: {
            defaultMode?: number;
            sources?: {
              configMap?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                  [k: string]: any;
                }[];
                name?: string;
                optional?: boolean;
                [k: string]: any;
              };
              downwardAPI?: {
                items?: {
                  fieldRef?: {
                    apiVersion?: string;
                    fieldPath: string;
                    [k: string]: any;
                  };
                  mode?: number;
                  path: string;
                  resourceFieldRef?: {
                    containerName?: string;
                    divisor?: number | string;
                    resource: string;
                    [k: string]: any;
                  };
                  [k: string]: any;
                }[];
                [k: string]: any;
              };
              secret?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                  [k: string]: any;
                }[];
                name?: string;
                optional?: boolean;
                [k: string]: any;
              };
              serviceAccountToken?: {
                audience?: string;
                expirationSeconds?: number;
                path: string;
                [k: string]: any;
              };
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          quobyte?: {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
            [k: string]: any;
          };
          rbd?: {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            user?: string;
            [k: string]: any;
          };
          scaleIO?: {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: {
              name?: string;
              [k: string]: any;
            };
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
            [k: string]: any;
          };
          secret?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
              [k: string]: any;
            }[];
            optional?: boolean;
            secretName?: string;
            [k: string]: any;
          };
          storageos?: {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            volumeName?: string;
            volumeNamespace?: string;
            [k: string]: any;
          };
          vsphereVolume?: {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
            [k: string]: any;
          };
          [k: string]: any;
        }[];
        [k: string]: any;
      };
      elasticsearch?: {
        image?: string;
        nodeCount?: number;
        nodeSelector?: {
          [k: string]: string;
        };
        redundancyPolicy?: string;
        resources?: {
          limits?: {
            [k: string]: number | string;
          };
          requests?: {
            [k: string]: number | string;
          };
          [k: string]: any;
        };
        storage?: {
          size?: number | string;
          storageClassName?: string;
          [k: string]: any;
        };
        tolerations?: {
          effect?: string;
          key?: string;
          operator?: string;
          tolerationSeconds?: number;
          value?: string;
          [k: string]: any;
        }[];
        [k: string]: any;
      };
      esIndexCleaner?: {
        affinity?: {
          nodeAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              preference: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchFields?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                [k: string]: any;
              };
              weight: number;
              [k: string]: any;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              nodeSelectorTerms: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchFields?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            [k: string]: any;
          };
          podAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              podAffinityTerm: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                    [k: string]: any;
                  }[];
                  matchLabels?: {
                    [k: string]: string;
                  };
                  [k: string]: any;
                };
                namespaces?: string[];
                topologyKey: string;
                [k: string]: any;
              };
              weight: number;
              [k: string]: any;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          podAntiAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              podAffinityTerm: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                    [k: string]: any;
                  }[];
                  matchLabels?: {
                    [k: string]: string;
                  };
                  [k: string]: any;
                };
                namespaces?: string[];
                topologyKey: string;
                [k: string]: any;
              };
              weight: number;
              [k: string]: any;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          [k: string]: any;
        };
        annotations?: {
          [k: string]: string;
        };
        backoffLimit?: number;
        enabled?: boolean;
        image?: string;
        labels?: {
          [k: string]: string;
        };
        numberOfDays?: number;
        resources?: {
          limits?: {
            [k: string]: number | string;
          };
          requests?: {
            [k: string]: number | string;
          };
          [k: string]: any;
        };
        schedule?: string;
        securityContext?: {
          fsGroup?: number;
          fsGroupChangePolicy?: string;
          runAsGroup?: number;
          runAsNonRoot?: boolean;
          runAsUser?: number;
          seLinuxOptions?: {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
            [k: string]: any;
          };
          seccompProfile?: {
            localhostProfile?: string;
            type: string;
            [k: string]: any;
          };
          supplementalGroups?: number[];
          sysctls?: {
            name: string;
            value: string;
            [k: string]: any;
          }[];
          windowsOptions?: {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
            [k: string]: any;
          };
          [k: string]: any;
        };
        serviceAccount?: string;
        successfulJobsHistoryLimit?: number;
        tolerations?: {
          effect?: string;
          key?: string;
          operator?: string;
          tolerationSeconds?: number;
          value?: string;
          [k: string]: any;
        }[];
        ttlSecondsAfterFinished?: number;
        volumeMounts?: {
          mountPath: string;
          mountPropagation?: string;
          name: string;
          readOnly?: boolean;
          subPath?: string;
          subPathExpr?: string;
          [k: string]: any;
        }[];
        volumes?: {
          awsElasticBlockStore?: {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
            [k: string]: any;
          };
          azureDisk?: {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
            [k: string]: any;
          };
          azureFile?: {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
            [k: string]: any;
          };
          cephfs?: {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            user?: string;
            [k: string]: any;
          };
          cinder?: {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            volumeID: string;
            [k: string]: any;
          };
          configMap?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
              [k: string]: any;
            }[];
            name?: string;
            optional?: boolean;
            [k: string]: any;
          };
          csi?: {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: {
              name?: string;
              [k: string]: any;
            };
            readOnly?: boolean;
            volumeAttributes?: {
              [k: string]: string;
            };
            [k: string]: any;
          };
          downwardAPI?: {
            defaultMode?: number;
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
                [k: string]: any;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: number | string;
                resource: string;
                [k: string]: any;
              };
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          emptyDir?: {
            medium?: string;
            sizeLimit?: number | string;
            [k: string]: any;
          };
          ephemeral?: {
            readOnly?: boolean;
            volumeClaimTemplate?: {
              metadata?: {
                [k: string]: any;
              };
              spec: {
                accessModes?: string[];
                dataSource?: {
                  apiGroup?: string;
                  kind: string;
                  name: string;
                  [k: string]: any;
                };
                resources?: {
                  limits?: {
                    [k: string]: number | string;
                  };
                  requests?: {
                    [k: string]: number | string;
                  };
                  [k: string]: any;
                };
                selector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                    [k: string]: any;
                  }[];
                  matchLabels?: {
                    [k: string]: string;
                  };
                  [k: string]: any;
                };
                storageClassName?: string;
                volumeMode?: string;
                volumeName?: string;
                [k: string]: any;
              };
              [k: string]: any;
            };
            [k: string]: any;
          };
          fc?: {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
            [k: string]: any;
          };
          flexVolume?: {
            driver: string;
            fsType?: string;
            options?: {
              [k: string]: string;
            };
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            [k: string]: any;
          };
          flocker?: {
            datasetName?: string;
            datasetUUID?: string;
            [k: string]: any;
          };
          gcePersistentDisk?: {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
            [k: string]: any;
          };
          gitRepo?: {
            directory?: string;
            repository: string;
            revision?: string;
            [k: string]: any;
          };
          glusterfs?: {
            endpoints: string;
            path: string;
            readOnly?: boolean;
            [k: string]: any;
          };
          hostPath?: {
            path: string;
            type?: string;
            [k: string]: any;
          };
          iscsi?: {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            targetPortal: string;
            [k: string]: any;
          };
          name: string;
          nfs?: {
            path: string;
            readOnly?: boolean;
            server: string;
            [k: string]: any;
          };
          persistentVolumeClaim?: {
            claimName: string;
            readOnly?: boolean;
            [k: string]: any;
          };
          photonPersistentDisk?: {
            fsType?: string;
            pdID: string;
            [k: string]: any;
          };
          portworxVolume?: {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
            [k: string]: any;
          };
          projected?: {
            defaultMode?: number;
            sources?: {
              configMap?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                  [k: string]: any;
                }[];
                name?: string;
                optional?: boolean;
                [k: string]: any;
              };
              downwardAPI?: {
                items?: {
                  fieldRef?: {
                    apiVersion?: string;
                    fieldPath: string;
                    [k: string]: any;
                  };
                  mode?: number;
                  path: string;
                  resourceFieldRef?: {
                    containerName?: string;
                    divisor?: number | string;
                    resource: string;
                    [k: string]: any;
                  };
                  [k: string]: any;
                }[];
                [k: string]: any;
              };
              secret?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                  [k: string]: any;
                }[];
                name?: string;
                optional?: boolean;
                [k: string]: any;
              };
              serviceAccountToken?: {
                audience?: string;
                expirationSeconds?: number;
                path: string;
                [k: string]: any;
              };
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          quobyte?: {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
            [k: string]: any;
          };
          rbd?: {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            user?: string;
            [k: string]: any;
          };
          scaleIO?: {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: {
              name?: string;
              [k: string]: any;
            };
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
            [k: string]: any;
          };
          secret?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
              [k: string]: any;
            }[];
            optional?: boolean;
            secretName?: string;
            [k: string]: any;
          };
          storageos?: {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            volumeName?: string;
            volumeNamespace?: string;
            [k: string]: any;
          };
          vsphereVolume?: {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
            [k: string]: any;
          };
          [k: string]: any;
        }[];
        [k: string]: any;
      };
      esRollover?: {
        affinity?: {
          nodeAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              preference: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchFields?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                [k: string]: any;
              };
              weight: number;
              [k: string]: any;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              nodeSelectorTerms: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchFields?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                [k: string]: any;
              }[];
              [k: string]: any;
            };
            [k: string]: any;
          };
          podAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              podAffinityTerm: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                    [k: string]: any;
                  }[];
                  matchLabels?: {
                    [k: string]: string;
                  };
                  [k: string]: any;
                };
                namespaces?: string[];
                topologyKey: string;
                [k: string]: any;
              };
              weight: number;
              [k: string]: any;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          podAntiAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              podAffinityTerm: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                    [k: string]: any;
                  }[];
                  matchLabels?: {
                    [k: string]: string;
                  };
                  [k: string]: any;
                };
                namespaces?: string[];
                topologyKey: string;
                [k: string]: any;
              };
              weight: number;
              [k: string]: any;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                  [k: string]: any;
                }[];
                matchLabels?: {
                  [k: string]: string;
                };
                [k: string]: any;
              };
              namespaces?: string[];
              topologyKey: string;
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          [k: string]: any;
        };
        annotations?: {
          [k: string]: string;
        };
        backoffLimit?: number;
        conditions?: string;
        image?: string;
        labels?: {
          [k: string]: string;
        };
        readTTL?: string;
        resources?: {
          limits?: {
            [k: string]: number | string;
          };
          requests?: {
            [k: string]: number | string;
          };
          [k: string]: any;
        };
        schedule?: string;
        securityContext?: {
          fsGroup?: number;
          fsGroupChangePolicy?: string;
          runAsGroup?: number;
          runAsNonRoot?: boolean;
          runAsUser?: number;
          seLinuxOptions?: {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
            [k: string]: any;
          };
          seccompProfile?: {
            localhostProfile?: string;
            type: string;
            [k: string]: any;
          };
          supplementalGroups?: number[];
          sysctls?: {
            name: string;
            value: string;
            [k: string]: any;
          }[];
          windowsOptions?: {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
            [k: string]: any;
          };
          [k: string]: any;
        };
        serviceAccount?: string;
        successfulJobsHistoryLimit?: number;
        tolerations?: {
          effect?: string;
          key?: string;
          operator?: string;
          tolerationSeconds?: number;
          value?: string;
          [k: string]: any;
        }[];
        ttlSecondsAfterFinished?: number;
        volumeMounts?: {
          mountPath: string;
          mountPropagation?: string;
          name: string;
          readOnly?: boolean;
          subPath?: string;
          subPathExpr?: string;
          [k: string]: any;
        }[];
        volumes?: {
          awsElasticBlockStore?: {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
            [k: string]: any;
          };
          azureDisk?: {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
            [k: string]: any;
          };
          azureFile?: {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
            [k: string]: any;
          };
          cephfs?: {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            user?: string;
            [k: string]: any;
          };
          cinder?: {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            volumeID: string;
            [k: string]: any;
          };
          configMap?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
              [k: string]: any;
            }[];
            name?: string;
            optional?: boolean;
            [k: string]: any;
          };
          csi?: {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: {
              name?: string;
              [k: string]: any;
            };
            readOnly?: boolean;
            volumeAttributes?: {
              [k: string]: string;
            };
            [k: string]: any;
          };
          downwardAPI?: {
            defaultMode?: number;
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
                [k: string]: any;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: number | string;
                resource: string;
                [k: string]: any;
              };
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          emptyDir?: {
            medium?: string;
            sizeLimit?: number | string;
            [k: string]: any;
          };
          ephemeral?: {
            readOnly?: boolean;
            volumeClaimTemplate?: {
              metadata?: {
                [k: string]: any;
              };
              spec: {
                accessModes?: string[];
                dataSource?: {
                  apiGroup?: string;
                  kind: string;
                  name: string;
                  [k: string]: any;
                };
                resources?: {
                  limits?: {
                    [k: string]: number | string;
                  };
                  requests?: {
                    [k: string]: number | string;
                  };
                  [k: string]: any;
                };
                selector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                    [k: string]: any;
                  }[];
                  matchLabels?: {
                    [k: string]: string;
                  };
                  [k: string]: any;
                };
                storageClassName?: string;
                volumeMode?: string;
                volumeName?: string;
                [k: string]: any;
              };
              [k: string]: any;
            };
            [k: string]: any;
          };
          fc?: {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
            [k: string]: any;
          };
          flexVolume?: {
            driver: string;
            fsType?: string;
            options?: {
              [k: string]: string;
            };
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            [k: string]: any;
          };
          flocker?: {
            datasetName?: string;
            datasetUUID?: string;
            [k: string]: any;
          };
          gcePersistentDisk?: {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
            [k: string]: any;
          };
          gitRepo?: {
            directory?: string;
            repository: string;
            revision?: string;
            [k: string]: any;
          };
          glusterfs?: {
            endpoints: string;
            path: string;
            readOnly?: boolean;
            [k: string]: any;
          };
          hostPath?: {
            path: string;
            type?: string;
            [k: string]: any;
          };
          iscsi?: {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            targetPortal: string;
            [k: string]: any;
          };
          name: string;
          nfs?: {
            path: string;
            readOnly?: boolean;
            server: string;
            [k: string]: any;
          };
          persistentVolumeClaim?: {
            claimName: string;
            readOnly?: boolean;
            [k: string]: any;
          };
          photonPersistentDisk?: {
            fsType?: string;
            pdID: string;
            [k: string]: any;
          };
          portworxVolume?: {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
            [k: string]: any;
          };
          projected?: {
            defaultMode?: number;
            sources?: {
              configMap?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                  [k: string]: any;
                }[];
                name?: string;
                optional?: boolean;
                [k: string]: any;
              };
              downwardAPI?: {
                items?: {
                  fieldRef?: {
                    apiVersion?: string;
                    fieldPath: string;
                    [k: string]: any;
                  };
                  mode?: number;
                  path: string;
                  resourceFieldRef?: {
                    containerName?: string;
                    divisor?: number | string;
                    resource: string;
                    [k: string]: any;
                  };
                  [k: string]: any;
                }[];
                [k: string]: any;
              };
              secret?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                  [k: string]: any;
                }[];
                name?: string;
                optional?: boolean;
                [k: string]: any;
              };
              serviceAccountToken?: {
                audience?: string;
                expirationSeconds?: number;
                path: string;
                [k: string]: any;
              };
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          quobyte?: {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
            [k: string]: any;
          };
          rbd?: {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            user?: string;
            [k: string]: any;
          };
          scaleIO?: {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: {
              name?: string;
              [k: string]: any;
            };
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
            [k: string]: any;
          };
          secret?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
              [k: string]: any;
            }[];
            optional?: boolean;
            secretName?: string;
            [k: string]: any;
          };
          storageos?: {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
              [k: string]: any;
            };
            volumeName?: string;
            volumeNamespace?: string;
            [k: string]: any;
          };
          vsphereVolume?: {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
            [k: string]: any;
          };
          [k: string]: any;
        }[];
        [k: string]: any;
      };
      grpcPlugin?: {
        image?: string;
        [k: string]: any;
      };
      options?: {
        [k: string]: any;
      };
      secretName?: string;
      type?: string;
      [k: string]: any;
    };
    strategy?: string;
    tolerations?: {
      effect?: string;
      key?: string;
      operator?: string;
      tolerationSeconds?: number;
      value?: string;
      [k: string]: any;
    }[];
    ui?: {
      options?: {
        [k: string]: any;
      };
      [k: string]: any;
    };
    volumeMounts?: {
      mountPath: string;
      mountPropagation?: string;
      name: string;
      readOnly?: boolean;
      subPath?: string;
      subPathExpr?: string;
      [k: string]: any;
    }[];
    volumes?: {
      awsElasticBlockStore?: {
        fsType?: string;
        partition?: number;
        readOnly?: boolean;
        volumeID: string;
        [k: string]: any;
      };
      azureDisk?: {
        cachingMode?: string;
        diskName: string;
        diskURI: string;
        fsType?: string;
        kind?: string;
        readOnly?: boolean;
        [k: string]: any;
      };
      azureFile?: {
        readOnly?: boolean;
        secretName: string;
        shareName: string;
        [k: string]: any;
      };
      cephfs?: {
        monitors: string[];
        path?: string;
        readOnly?: boolean;
        secretFile?: string;
        secretRef?: {
          name?: string;
          [k: string]: any;
        };
        user?: string;
        [k: string]: any;
      };
      cinder?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
          [k: string]: any;
        };
        volumeID: string;
        [k: string]: any;
      };
      configMap?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
          [k: string]: any;
        }[];
        name?: string;
        optional?: boolean;
        [k: string]: any;
      };
      csi?: {
        driver: string;
        fsType?: string;
        nodePublishSecretRef?: {
          name?: string;
          [k: string]: any;
        };
        readOnly?: boolean;
        volumeAttributes?: {
          [k: string]: string;
        };
        [k: string]: any;
      };
      downwardAPI?: {
        defaultMode?: number;
        items?: {
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
            [k: string]: any;
          };
          mode?: number;
          path: string;
          resourceFieldRef?: {
            containerName?: string;
            divisor?: number | string;
            resource: string;
            [k: string]: any;
          };
          [k: string]: any;
        }[];
        [k: string]: any;
      };
      emptyDir?: {
        medium?: string;
        sizeLimit?: number | string;
        [k: string]: any;
      };
      ephemeral?: {
        readOnly?: boolean;
        volumeClaimTemplate?: {
          metadata?: {
            [k: string]: any;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
              [k: string]: any;
            };
            resources?: {
              limits?: {
                [k: string]: number | string;
              };
              requests?: {
                [k: string]: number | string;
              };
              [k: string]: any;
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
                [k: string]: any;
              }[];
              matchLabels?: {
                [k: string]: string;
              };
              [k: string]: any;
            };
            storageClassName?: string;
            volumeMode?: string;
            volumeName?: string;
            [k: string]: any;
          };
          [k: string]: any;
        };
        [k: string]: any;
      };
      fc?: {
        fsType?: string;
        lun?: number;
        readOnly?: boolean;
        targetWWNs?: string[];
        wwids?: string[];
        [k: string]: any;
      };
      flexVolume?: {
        driver: string;
        fsType?: string;
        options?: {
          [k: string]: string;
        };
        readOnly?: boolean;
        secretRef?: {
          name?: string;
          [k: string]: any;
        };
        [k: string]: any;
      };
      flocker?: {
        datasetName?: string;
        datasetUUID?: string;
        [k: string]: any;
      };
      gcePersistentDisk?: {
        fsType?: string;
        partition?: number;
        pdName: string;
        readOnly?: boolean;
        [k: string]: any;
      };
      gitRepo?: {
        directory?: string;
        repository: string;
        revision?: string;
        [k: string]: any;
      };
      glusterfs?: {
        endpoints: string;
        path: string;
        readOnly?: boolean;
        [k: string]: any;
      };
      hostPath?: {
        path: string;
        type?: string;
        [k: string]: any;
      };
      iscsi?: {
        chapAuthDiscovery?: boolean;
        chapAuthSession?: boolean;
        fsType?: string;
        initiatorName?: string;
        iqn: string;
        iscsiInterface?: string;
        lun: number;
        portals?: string[];
        readOnly?: boolean;
        secretRef?: {
          name?: string;
          [k: string]: any;
        };
        targetPortal: string;
        [k: string]: any;
      };
      name: string;
      nfs?: {
        path: string;
        readOnly?: boolean;
        server: string;
        [k: string]: any;
      };
      persistentVolumeClaim?: {
        claimName: string;
        readOnly?: boolean;
        [k: string]: any;
      };
      photonPersistentDisk?: {
        fsType?: string;
        pdID: string;
        [k: string]: any;
      };
      portworxVolume?: {
        fsType?: string;
        readOnly?: boolean;
        volumeID: string;
        [k: string]: any;
      };
      projected?: {
        defaultMode?: number;
        sources?: {
          configMap?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
              [k: string]: any;
            }[];
            name?: string;
            optional?: boolean;
            [k: string]: any;
          };
          downwardAPI?: {
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
                [k: string]: any;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: number | string;
                resource: string;
                [k: string]: any;
              };
              [k: string]: any;
            }[];
            [k: string]: any;
          };
          secret?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
              [k: string]: any;
            }[];
            name?: string;
            optional?: boolean;
            [k: string]: any;
          };
          serviceAccountToken?: {
            audience?: string;
            expirationSeconds?: number;
            path: string;
            [k: string]: any;
          };
          [k: string]: any;
        }[];
        [k: string]: any;
      };
      quobyte?: {
        group?: string;
        readOnly?: boolean;
        registry: string;
        tenant?: string;
        user?: string;
        volume: string;
        [k: string]: any;
      };
      rbd?: {
        fsType?: string;
        image: string;
        keyring?: string;
        monitors: string[];
        pool?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
          [k: string]: any;
        };
        user?: string;
        [k: string]: any;
      };
      scaleIO?: {
        fsType?: string;
        gateway: string;
        protectionDomain?: string;
        readOnly?: boolean;
        secretRef: {
          name?: string;
          [k: string]: any;
        };
        sslEnabled?: boolean;
        storageMode?: string;
        storagePool?: string;
        system: string;
        volumeName?: string;
        [k: string]: any;
      };
      secret?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
          [k: string]: any;
        }[];
        optional?: boolean;
        secretName?: string;
        [k: string]: any;
      };
      storageos?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
          [k: string]: any;
        };
        volumeName?: string;
        volumeNamespace?: string;
        [k: string]: any;
      };
      vsphereVolume?: {
        fsType?: string;
        storagePolicyID?: string;
        storagePolicyName?: string;
        volumePath: string;
        [k: string]: any;
      };
      [k: string]: any;
    }[];
    [k: string]: any;
  };
  status?: {
    phase: string;
    version: string;
    [k: string]: any;
  };
  [k: string]: any;
}

export interface V1JaegerList {
  /**
    * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
    */
   apiVersion?: string;
   /**
   * Items is the list of ControllerRevisions
   */
   items: Array<V1Jaeger>;
   /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
   */
   kind?: string;
   metadata?: V1ListMeta;
}

let defaultBasePath = 'http://localhost';

export enum V1JaegerApiApiKeys {
    BearerToken,
}

export class V1JaegerApi {
  protected _basePath = defaultBasePath;
  protected _defaultHeaders : any = {};
  protected _useQuerystring : boolean = false;

  protected authentications = {
      'default': <Authentication>new VoidAuth(),
      'BearerToken': new ApiKeyAuth('header', 'authorization'),
  }

  protected interceptors: Interceptor[] = [];

  constructor(basePath?: string);
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
      if (password) {
          if (basePath) {
              this.basePath = basePath;
          }
      } else {
          if (basePathOrUsername) {
              this.basePath = basePathOrUsername
          }
      }
  }

  set useQuerystring(value: boolean) {
      this._useQuerystring = value;
  }

  set basePath(basePath: string) {
      this._basePath = basePath;
  }

  set defaultHeaders(defaultHeaders: any) {
      this._defaultHeaders = defaultHeaders;
  }

  get defaultHeaders() {
      return this._defaultHeaders;
  }

  get basePath() {
      return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
      this.authentications.default = auth;
  }

  public setApiKey(key: V1JaegerApiApiKeys, value: string) {
    (this.authentications as any)[V1JaegerApiApiKeys[key]].apiKey = value;
  }

  public addInterceptor(interceptor: Interceptor) {
      this.interceptors.push(interceptor);
  }

  /**
   * create a V1Jaeger
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
   */
  public async createNamespacedV1Jaeger (namespace: string, body: V1Jaeger, includeUninitialized?: boolean, pretty?: string, dryRun?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: IncomingMessage; body: V1Jaeger;  }> {
    const localVarPath = this.basePath + '/apis/jaegertracing.io/v1/namespaces/{namespace}/jaegers'
        .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
        throw new Error('Required parameter namespace was null or undefined when calling createNamespacedV1Jaeger.');
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
        throw new Error('Required parameter body was null or undefined when calling createNamespacedV1Jaeger.');
    }

    if (includeUninitialized !== undefined) {
        localVarQueryParameters['includeUninitialized'] = includeUninitialized;
    }

    if (pretty !== undefined) {
        localVarQueryParameters['pretty'] = pretty;
    }

    if (dryRun !== undefined) {
        localVarQueryParameters['dryRun'] = dryRun;
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
        method: 'POST',
        qs: localVarQueryParameters,
        headers: localVarHeaderParams,
        uri: localVarPath,
        useQuerystring: this._useQuerystring,
        json: true,
        body: body
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() => this.authentications.BearerToken.applyToRequest(localVarRequestOptions));

    authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
    return authenticationPromise.then(() => {
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: IncomingMessage; body: V1Jaeger;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    });
  }

  /**
   * read the specified V1Jaeger
   * @param name name of the V1Jaeger
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param _export Should this value be exported.  Export strips fields that a user can not specify.
   */
  public async readNamespacedV1Jaeger (name: string, namespace: string, pretty?: string, exact?: boolean, _export?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: IncomingMessage; body: V1Jaeger;  }> {
    const localVarPath = this.basePath + '/apis/jaegertracing.io/v1/namespaces/{namespace}/jaegers/{name}'
      .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
      .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'name' is not null or undefined
    if (name === null || name === undefined) {
        throw new Error('Required parameter name was null or undefined when calling readNamespacedV1Jaeger.');
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
        throw new Error('Required parameter namespace was null or undefined when calling readNamespacedV1Jaeger.');
    }

    if (pretty !== undefined) {
      localVarQueryParameters['pretty'] = pretty;
    }

    if (exact !== undefined) {
        localVarQueryParameters['exact'] = exact;
    }

    if (_export !== undefined) {
        localVarQueryParameters['export'] = _export;
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
        method: 'GET',
        qs: localVarQueryParameters,
        headers: localVarHeaderParams,
        uri: localVarPath,
        useQuerystring: this._useQuerystring,
        json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() => this.authentications.BearerToken.applyToRequest(localVarRequestOptions));

    authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
    return authenticationPromise.then(() => {
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: IncomingMessage; body: V1Jaeger;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    });
  }

  /**
   * partially update the specified V1Jaeger
   * @param name name of the V1Jaeger
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
   */
  public async patchNamespacedV1Jaeger (name: string, namespace: string, body: object, pretty?: string, dryRun?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: IncomingMessage; body: V1Jaeger;  }> {
    const localVarPath = this.basePath + '/apis/jaegertracing.io/v1/namespaces/{namespace}/jaegers/{name}'
        .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
        .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'name' is not null or undefined
    if (name === null || name === undefined) {
        throw new Error('Required parameter name was null or undefined when calling patchNamespacedV1Jaeger.');
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
        throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedV1Jaeger.');
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
        throw new Error('Required parameter body was null or undefined when calling patchNamespacedV1Jaeger.');
    }

    if (pretty !== undefined) {
        localVarQueryParameters['pretty'] = pretty;
    }

    if (dryRun !== undefined) {
        localVarQueryParameters['dryRun'] = dryRun;
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
        method: 'PATCH',
        qs: localVarQueryParameters,
        headers: localVarHeaderParams,
        uri: localVarPath,
        useQuerystring: this._useQuerystring,
        json: true,
        body: body
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() => this.authentications.BearerToken.applyToRequest(localVarRequestOptions));

    authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
    return authenticationPromise.then(() => {
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: IncomingMessage; body: V1Jaeger;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    });
  }

  /**
   * delete a V1Jaeger
   * @param name name of the V1Jaeger
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the &quot;orphan&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
   * @param body
   */
  public async deleteNamespacedV1Jaeger (name: string, namespace: string, pretty?: string, dryRun?: string, gracePeriodSeconds?: number, orphanDependents?: boolean, propagationPolicy?: string, body?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: IncomingMessage; body: V1Status;  }> {
    const localVarPath = this.basePath + '/apis/jaegertracing.io/v1/namespaces/{namespace}/jaegers/{name}'
        .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
        .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'name' is not null or undefined
    if (name === null || name === undefined) {
        throw new Error('Required parameter name was null or undefined when calling deleteNamespacedV1Jaeger.');
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
        throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedV1Jaeger.');
    }

    if (pretty !== undefined) {
        localVarQueryParameters['pretty'] = pretty;
    }

    if (dryRun !== undefined) {
        localVarQueryParameters['dryRun'] = dryRun;
    }

    if (gracePeriodSeconds !== undefined) {
        localVarQueryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
    }

    if (orphanDependents !== undefined) {
        localVarQueryParameters['orphanDependents'] = orphanDependents;
    }

    if (propagationPolicy !== undefined) {
        localVarQueryParameters['propagationPolicy'] = propagationPolicy;
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
        method: 'DELETE',
        qs: localVarQueryParameters,
        headers: localVarHeaderParams,
        uri: localVarPath,
        useQuerystring: this._useQuerystring,
        json: true,
        body: {}
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() => this.authentications.BearerToken.applyToRequest(localVarRequestOptions));

    authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
    return authenticationPromise.then(() => {
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: IncomingMessage; body: V1Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    });
  }

  /**
   * list or watch objects of kind V1Jaeger
   * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type &quot;BOOKMARK&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is alpha and can be changed or removed without notice.
   * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the &quot;next key&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  public async listV1JaegerForAllNamespaces (allowWatchBookmarks?: boolean, _continue?: string, fieldSelector?: string, labelSelector?: string, limit?: number, pretty?: string, resourceVersion?: string, timeoutSeconds?: number, watch?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: IncomingMessage; body: V1JaegerList;  }> {
      const localVarPath = this.basePath + '/apis/jaegertracing.io/v1/jaegers';
      let localVarQueryParameters: any = {};
      let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
      let localVarFormParams: any = {};

      if (allowWatchBookmarks !== undefined) {
          localVarQueryParameters['allowWatchBookmarks'] = allowWatchBookmarks;
      }

      if (_continue !== undefined) {
          localVarQueryParameters['continue'] = _continue;
      }

      if (fieldSelector !== undefined) {
          localVarQueryParameters['fieldSelector'] = fieldSelector;
      }

      if (labelSelector !== undefined) {
          localVarQueryParameters['labelSelector'] = labelSelector;
      }

      if (limit !== undefined) {
          localVarQueryParameters['limit'] = limit;
      }

      if (pretty !== undefined) {
          localVarQueryParameters['pretty'] = pretty;
      }

      if (resourceVersion !== undefined) {
          localVarQueryParameters['resourceVersion'] = resourceVersion;
      }

      if (timeoutSeconds !== undefined) {
          localVarQueryParameters['timeoutSeconds'] = timeoutSeconds;
      }

      if (watch !== undefined) {
          localVarQueryParameters['watch'] = watch;
      }

      (<any>Object).assign(localVarHeaderParams, options.headers);

      let localVarUseFormData = false;

      let localVarRequestOptions: localVarRequest.Options = {
          method: 'GET',
          qs: localVarQueryParameters,
          headers: localVarHeaderParams,
          uri: localVarPath,
          useQuerystring: this._useQuerystring,
          json: true,
      };

      let authenticationPromise = Promise.resolve();
      authenticationPromise = authenticationPromise.then(() => this.authentications.BearerToken.applyToRequest(localVarRequestOptions));

      authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
      return authenticationPromise.then(() => {
          if (Object.keys(localVarFormParams).length) {
              if (localVarUseFormData) {
                  (<any>localVarRequestOptions).formData = localVarFormParams;
              } else {
                  localVarRequestOptions.form = localVarFormParams;
              }
          }
          return new Promise<{ response: IncomingMessage; body: V1JaegerList;  }>((resolve, reject) => {
              localVarRequest(localVarRequestOptions, (error, response, body) => {
                  if (error) {
                      reject(error);
                  } else {
                      if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                          resolve({ response: response, body: body });
                      } else {
                          reject({ response: response, body: body });
                      }
                  }
              });
          });
      });
  }};

export type V1JaegerResourceType = V1JaegerResource;
export type V1JaegerResources = V1JaegerResourceType[];

export const isV1JaegerResource = <(r: K8sResource) => r is V1JaegerResourceType>(
  (resource => resource instanceof V1JaegerResource)
);

export const V1JaegerActions = {
  fetch: createAsyncAction(
    "FETCH_K8S_V1JAEGERS_REQUEST",
    "FETCH_K8S_V1JAEGERS_SUCCESS",
    "FETCH_K8S_V1JAEGERS_FAILURE"
  )<{}, { resources: V1JaegerResources }, { error: Error }>(),
  onUpdated: createAction("ON_UPDATED_K8S_V1JAEGER")<V1JaegerResourceType>(),
  onAdded: createAction("ON_ADDED_K8S_V1JAEGER")<V1JaegerResourceType>(),
  onDestroyed: createAction("ON_DESTROYED_K8S_V1JAEGER")<V1JaegerResourceType>()
};
export type V1JaegerResourceActions = ActionType<typeof V1JaegerActions>;
export interface V1JaegerResourceState extends ResourceCache<V1JaegerResourceType> {}

const initialState: V1JaegerResourceState = {
  loaded: false,
  error: null,
  resources: []
};

export const V1JaegerReducer = createReducer<
  V1JaegerResourceState,
  V1JaegerResourceActions
>(initialState)
  .handleAction(
    V1JaegerActions.fetch.request,
    (state, _): V1JaegerResourceState => ({
      ...state,
      loaded: false
    })
  )
  .handleAction(
    V1JaegerActions.fetch.success,
    (state, action): V1JaegerResourceState => ({
      ...state,
      ...action.payload,
      error: null,
      loaded: true
    })
  )
  .handleAction(
    V1JaegerActions.fetch.failure,
    (state, action): V1JaegerResourceState => ({
      ...state,
      ...action.payload,
      loaded: false
    })
  )
  .handleAction(
    [V1JaegerActions.onUpdated, V1JaegerActions.onAdded],
    (state, action): V1JaegerResourceState => ({
      ...state,
      resources: [
        ...state.resources.filter(
          s => !isSameObject(s, action.payload)
        ),
        action.payload
      ]
    })
  )
  .handleAction(
    V1JaegerActions.onDestroyed,
    (state, action): V1JaegerResourceState => ({
      ...state,
      resources: state.resources.filter(
        s => !isSameObject(s, action.payload)
      )
    })
  );

export class V1JaegerResource extends K8sResource {
  protected api: V1JaegerApi;
  protected resource: V1Jaeger;

  constructor(resource: V1Jaeger, kubeConfig: KubeConfig) {
    super(resource, kubeConfig);

    this.resource = resource;
    this.api = kubeConfig.makeApiClient(V1JaegerApi);
  }
  get spec(): V1Jaeger {
    return this.resource;
  }
  static startInformer(
    kubeConfig: KubeConfig,
    channel: (input: unknown) => void
  ): () => void {
    const client = kubeConfig.makeApiClient(V1JaegerApi);
    let cancelled = false;
    let request: Request;
    //@ts-ignore: error TS7023: 'watch' implicitly has return type 'any'
    const watch = async () => {
      if (cancelled) {
        return;
      }
      try {
        const res = await client.listV1JaegerForAllNamespaces();
        channel(
          V1JaegerActions.fetch.success({
            resources: res.body.items.map(r => new V1JaegerResource(r, kubeConfig))
          })
        );
      } catch (error: any) {
        channel(V1JaegerActions.fetch.failure({ error }));
        log.warning("starting informer failed (will retry):  %s", error);
        return setTimeout(watch, 3000);
      }
      const informer = new Watch(kubeConfig);
      const watchHandler = (phase: string, obj: V1Jaeger) => {
        switch (phase) {
          case "ADDED":
            channel(V1JaegerActions.onAdded(new V1JaegerResource(obj, kubeConfig)));
            break;
          case "MODIFIED":
            channel(V1JaegerActions.onUpdated(new V1JaegerResource(obj, kubeConfig)));
            break;
          case "DELETED":
            channel(
              V1JaegerActions.onDestroyed(new V1JaegerResource(obj, kubeConfig))
            );
            break;
        }
      };
      request = await informer.watch(
        "/apis/jaegertracing.io/v1/jaegers",
        { resourceVersion: undefined },
        watchHandler,
        watch
      );
      return request;
    };
    watch();
    // Return a function to disable the informer and close the request
    return () => {
      cancelled = true;
      request && request.abort();
    };
  }
  create(): Promise<{
    response: IncomingMessage;
    body: V1Jaeger;
  }> {
    return this.api.createNamespacedV1Jaeger(this.namespace, this.resource)

  }
  read(): Promise<{
    response: IncomingMessage;
    body: V1Jaeger;
  }> {
    return this.api.readNamespacedV1Jaeger(this.name, this.namespace)

  }
  update(): Promise<{
    response: IncomingMessage;
    body: V1Jaeger;
  }> {
    return this.api.patchNamespacedV1Jaeger(
        this.name,
        this.namespace,
        this.resource,
        undefined,
        undefined,
        { headers: { "Content-Type": "application/merge-patch+json" } }
      )

  }
  delete(): Promise<{
    response: IncomingMessage;
    body: V1Status;
  }> {
    return this.api.deleteNamespacedV1Jaeger(this.name, this.namespace)
  }
}
