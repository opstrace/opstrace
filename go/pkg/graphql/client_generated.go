package graphql

// Code generated by graphql-codegen-golang ; DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

type Client struct {
	*http.Client
	Url string
}

// NewClient creates a GraphQL client ready to use.
func NewClient(url string) *Client {
	return &Client{
		Client: &http.Client{},
		Url:    url,
	}
}

type GraphQLOperation struct {
	Query         string          `json:"query"`
	OperationName string          `json:"operationName,omitempty"`
	Variables     json.RawMessage `json:"variables,omitempty"`
}

type GraphQLResponse struct {
	Data   json.RawMessage `json:"data,omitempty"`
	Errors []GraphQLError  `json:"errors,omitempty"`
}

type GraphQLError map[string]interface{}

func (err GraphQLError) Error() string {
	return fmt.Sprintf("graphql: %v", map[string]interface{}(err))
}

func (resp *GraphQLResponse) Error() string {
	if len(resp.Errors) == 0 {
		return ""
	}
	errs := strings.Builder{}
	for _, err := range resp.Errors {
		errs.WriteString(err.Error())
		errs.WriteString("\n")
	}
	return errs.String()
}

func execute(client *http.Client, req *http.Request) (*GraphQLResponse, error) {
	if client == nil {
		client = http.DefaultClient
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, err
	}
	return unmarshalGraphQLReponse(body)
}

func unmarshalGraphQLReponse(b []byte) (*GraphQLResponse, error) {
	resp := GraphQLResponse{}
	if err := json.Unmarshal(b, &resp); err != nil {
		return nil, err
	}
	if len(resp.Errors) > 0 {
		return &resp, &resp
	}
	return &resp, nil
}

//
// mutation CreateBranch($name: String!)
//

type CreateBranchVariables struct {
	Name String `json:"name"`
}

type CreateBranchResponse struct {
	InsertBranchOne struct {
		Name string `json:"Name"`
	} `json:"InsertBranchOne"`
}

type CreateBranchRequest struct {
	*http.Request
}

func NewCreateBranchRequest(url string, vars *CreateBranchVariables) (*CreateBranchRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation CreateBranch($name: String!) {
  insert_branch_one(object: {name: $name}) {
    name
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &CreateBranchRequest{req}, nil
}

func (req *CreateBranchRequest) Execute(client *http.Client) (*CreateBranchResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result CreateBranchResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func CreateBranch(url string, client *http.Client, vars *CreateBranchVariables) (*CreateBranchResponse, error) {
	req, err := NewCreateBranchRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) CreateBranch(vars *CreateBranchVariables) (*CreateBranchResponse, error) {
	return CreateBranch(client.Url, client.Client, vars)
}

//
// mutation DeleteBranch($name: String!)
//

type DeleteBranchVariables struct {
	Name String `json:"name"`
}

type DeleteBranchResponse struct {
	DeleteBranchByPk struct {
		Name string `json:"Name"`
	} `json:"DeleteBranchByPk"`
}

type DeleteBranchRequest struct {
	*http.Request
}

func NewDeleteBranchRequest(url string, vars *DeleteBranchVariables) (*DeleteBranchRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation DeleteBranch($name: String!) {
  delete_branch_by_pk(name: $name) {
    name
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &DeleteBranchRequest{req}, nil
}

func (req *DeleteBranchRequest) Execute(client *http.Client) (*DeleteBranchResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result DeleteBranchResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func DeleteBranch(url string, client *http.Client, vars *DeleteBranchVariables) (*DeleteBranchResponse, error) {
	req, err := NewDeleteBranchRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) DeleteBranch(vars *DeleteBranchVariables) (*DeleteBranchResponse, error) {
	return DeleteBranch(client.Url, client.Client, vars)
}

//
// mutation CreateCredentials($credentials: [credential_insert_input!]!)
//

type CreateCredentialsVariables struct {
	Credentials *[]CredentialInsertInput `json:"credentials,omitempty"`
}

type CreateCredentialsResponse struct {
	InsertCredential struct {
		Returning []struct {
			Tenant string `json:"Tenant"`
			Name   string `json:"Name"`
		} `json:"Returning"`
	} `json:"InsertCredential"`
}

type CreateCredentialsRequest struct {
	*http.Request
}

func NewCreateCredentialsRequest(url string, vars *CreateCredentialsVariables) (*CreateCredentialsRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation CreateCredentials($credentials: [credential_insert_input!]!) {
  insert_credential(objects: $credentials) {
    returning {
      tenant
      name
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &CreateCredentialsRequest{req}, nil
}

func (req *CreateCredentialsRequest) Execute(client *http.Client) (*CreateCredentialsResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result CreateCredentialsResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func CreateCredentials(url string, client *http.Client, vars *CreateCredentialsVariables) (*CreateCredentialsResponse, error) {
	req, err := NewCreateCredentialsRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) CreateCredentials(vars *CreateCredentialsVariables) (*CreateCredentialsResponse, error) {
	return CreateCredentials(client.Url, client.Client, vars)
}

//
// mutation DeleteCredential($tenant: String!, $name: String!)
//

type DeleteCredentialVariables struct {
	Tenant String `json:"tenant"`
	Name   String `json:"name"`
}

type DeleteCredentialResponse struct {
	DeleteCredentialByPk struct {
		Tenant string `json:"Tenant"`
		Name   string `json:"Name"`
	} `json:"DeleteCredentialByPk"`
}

type DeleteCredentialRequest struct {
	*http.Request
}

func NewDeleteCredentialRequest(url string, vars *DeleteCredentialVariables) (*DeleteCredentialRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation DeleteCredential($tenant: String!, $name: String!) {
  delete_credential_by_pk(tenant: $tenant, name: $name) {
    tenant
    name
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &DeleteCredentialRequest{req}, nil
}

func (req *DeleteCredentialRequest) Execute(client *http.Client) (*DeleteCredentialResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result DeleteCredentialResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func DeleteCredential(url string, client *http.Client, vars *DeleteCredentialVariables) (*DeleteCredentialResponse, error) {
	req, err := NewDeleteCredentialRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) DeleteCredential(vars *DeleteCredentialVariables) (*DeleteCredentialResponse, error) {
	return DeleteCredential(client.Url, client.Client, vars)
}

//
// query GetCredential($tenant: String!, $name: String!)
//

type GetCredentialVariables struct {
	Tenant String `json:"tenant"`
	Name   String `json:"name"`
}

type GetCredentialResponse struct {
	CredentialByPk struct {
		Tenant    string `json:"Tenant"`
		Name      string `json:"Name"`
		Type      string `json:"Type"`
		CreatedAt string `json:"CreatedAt"`
		UpdatedAt string `json:"UpdatedAt"`
	} `json:"CredentialByPk"`
}

type GetCredentialRequest struct {
	*http.Request
}

func NewGetCredentialRequest(url string, vars *GetCredentialVariables) (*GetCredentialRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetCredential($tenant: String!, $name: String!) {
  credential_by_pk(tenant: $tenant, name: $name) {
    tenant
    name
    type
    created_at
    updated_at
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetCredentialRequest{req}, nil
}

func (req *GetCredentialRequest) Execute(client *http.Client) (*GetCredentialResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetCredentialResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetCredential(url string, client *http.Client, vars *GetCredentialVariables) (*GetCredentialResponse, error) {
	req, err := NewGetCredentialRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetCredential(vars *GetCredentialVariables) (*GetCredentialResponse, error) {
	return GetCredential(client.Url, client.Client, vars)
}

//
// query GetCredentials($tenant: String!)
//

type GetCredentialsVariables struct {
	Tenant String `json:"tenant"`
}

type GetCredentialsResponse struct {
	Credential []struct {
		Tenant    string `json:"Tenant"`
		Name      string `json:"Name"`
		Type      string `json:"Type"`
		CreatedAt string `json:"CreatedAt"`
		UpdatedAt string `json:"UpdatedAt"`
	} `json:"Credential"`
}

type GetCredentialsRequest struct {
	*http.Request
}

func NewGetCredentialsRequest(url string, vars *GetCredentialsVariables) (*GetCredentialsRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetCredentials($tenant: String!) {
  credential(where: {tenant: {_eq: $tenant}}) {
    tenant
    name
    type
    created_at
    updated_at
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetCredentialsRequest{req}, nil
}

func (req *GetCredentialsRequest) Execute(client *http.Client) (*GetCredentialsResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetCredentialsResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetCredentials(url string, client *http.Client, vars *GetCredentialsVariables) (*GetCredentialsResponse, error) {
	req, err := NewGetCredentialsRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetCredentials(vars *GetCredentialsVariables) (*GetCredentialsResponse, error) {
	return GetCredentials(client.Url, client.Client, vars)
}

//
// query GetCredentialsDump
//

type GetCredentialsDumpResponse struct {
	Credential []struct {
		Tenant    string `json:"Tenant"`
		Name      string `json:"Name"`
		Type      string `json:"Type"`
		Value     string `json:"Value"`
		CreatedAt string `json:"CreatedAt"`
		UpdatedAt string `json:"UpdatedAt"`
	} `json:"Credential"`
}

type GetCredentialsDumpRequest struct {
	*http.Request
}

func NewGetCredentialsDumpRequest(url string) (*GetCredentialsDumpRequest, error) {
	b, err := json.Marshal(&GraphQLOperation{
		Query: `query GetCredentialsDump {
  credential {
    tenant
    name
    type
    value
    created_at
    updated_at
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetCredentialsDumpRequest{req}, nil
}

func (req *GetCredentialsDumpRequest) Execute(client *http.Client) (*GetCredentialsDumpResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetCredentialsDumpResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetCredentialsDump(url string, client *http.Client) (*GetCredentialsDumpResponse, error) {
	req, err := NewGetCredentialsDumpRequest(url)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetCredentialsDump() (*GetCredentialsDumpResponse, error) {
	return GetCredentialsDump(client.Url, client.Client)
}

//
// mutation UpdateCredential($tenant: String!, $name: String!, $value: json!, $updated_at: timestamptz!)
//

type UpdateCredentialVariables struct {
	Tenant    String      `json:"tenant"`
	Name      String      `json:"name"`
	Value     Json        `json:"value"`
	UpdatedAt Timestamptz `json:"updated_at"`
}

type UpdateCredentialResponse struct {
	UpdateCredentialByPk struct {
		Tenant string `json:"Tenant"`
		Name   string `json:"Name"`
	} `json:"UpdateCredentialByPk"`
}

type UpdateCredentialRequest struct {
	*http.Request
}

func NewUpdateCredentialRequest(url string, vars *UpdateCredentialVariables) (*UpdateCredentialRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation UpdateCredential($tenant: String!, $name: String!, $value: json!, $updated_at: timestamptz!) {
  update_credential_by_pk(_set: {value: $value, updated_at: $updated_at}, pk_columns: {tenant: $tenant, name: $name}) {
    tenant
    name
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &UpdateCredentialRequest{req}, nil
}

func (req *UpdateCredentialRequest) Execute(client *http.Client) (*UpdateCredentialResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result UpdateCredentialResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func UpdateCredential(url string, client *http.Client, vars *UpdateCredentialVariables) (*UpdateCredentialResponse, error) {
	req, err := NewUpdateCredentialRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) UpdateCredential(vars *UpdateCredentialVariables) (*UpdateCredentialResponse, error) {
	return UpdateCredential(client.Url, client.Client, vars)
}

//
// mutation CreateExporters($exporters: [exporter_insert_input!]!)
//

type CreateExportersVariables struct {
	Exporters *[]ExporterInsertInput `json:"exporters,omitempty"`
}

type CreateExportersResponse struct {
	InsertExporter struct {
		Returning []struct {
			Tenant string `json:"Tenant"`
			Name   string `json:"Name"`
		} `json:"Returning"`
	} `json:"InsertExporter"`
}

type CreateExportersRequest struct {
	*http.Request
}

func NewCreateExportersRequest(url string, vars *CreateExportersVariables) (*CreateExportersRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation CreateExporters($exporters: [exporter_insert_input!]!) {
  insert_exporter(objects: $exporters) {
    returning {
      tenant
      name
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &CreateExportersRequest{req}, nil
}

func (req *CreateExportersRequest) Execute(client *http.Client) (*CreateExportersResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result CreateExportersResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func CreateExporters(url string, client *http.Client, vars *CreateExportersVariables) (*CreateExportersResponse, error) {
	req, err := NewCreateExportersRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) CreateExporters(vars *CreateExportersVariables) (*CreateExportersResponse, error) {
	return CreateExporters(client.Url, client.Client, vars)
}

//
// mutation DeleteExporter($tenant: String!, $name: String!)
//

type DeleteExporterVariables struct {
	Tenant String `json:"tenant"`
	Name   String `json:"name"`
}

type DeleteExporterResponse struct {
	DeleteExporterByPk struct {
		Tenant string `json:"Tenant"`
		Name   string `json:"Name"`
	} `json:"DeleteExporterByPk"`
}

type DeleteExporterRequest struct {
	*http.Request
}

func NewDeleteExporterRequest(url string, vars *DeleteExporterVariables) (*DeleteExporterRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation DeleteExporter($tenant: String!, $name: String!) {
  delete_exporter_by_pk(tenant: $tenant, name: $name) {
    tenant
    name
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &DeleteExporterRequest{req}, nil
}

func (req *DeleteExporterRequest) Execute(client *http.Client) (*DeleteExporterResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result DeleteExporterResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func DeleteExporter(url string, client *http.Client, vars *DeleteExporterVariables) (*DeleteExporterResponse, error) {
	req, err := NewDeleteExporterRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) DeleteExporter(vars *DeleteExporterVariables) (*DeleteExporterResponse, error) {
	return DeleteExporter(client.Url, client.Client, vars)
}

//
// query GetExporter($tenant: String!, $name: String!)
//

type GetExporterVariables struct {
	Tenant String `json:"tenant"`
	Name   String `json:"name"`
}

type GetExporterResponse struct {
	ExporterByPk struct {
		Tenant     string `json:"Tenant"`
		Name       string `json:"Name"`
		Type       string `json:"Type"`
		Credential string `json:"Credential"`
		Config     string `json:"Config"`
		CreatedAt  string `json:"CreatedAt"`
		UpdatedAt  string `json:"UpdatedAt"`
	} `json:"ExporterByPk"`
}

type GetExporterRequest struct {
	*http.Request
}

func NewGetExporterRequest(url string, vars *GetExporterVariables) (*GetExporterRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetExporter($tenant: String!, $name: String!) {
  exporter_by_pk(tenant: $tenant, name: $name) {
    tenant
    name
    type
    credential
    config
    created_at
    updated_at
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetExporterRequest{req}, nil
}

func (req *GetExporterRequest) Execute(client *http.Client) (*GetExporterResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetExporterResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetExporter(url string, client *http.Client, vars *GetExporterVariables) (*GetExporterResponse, error) {
	req, err := NewGetExporterRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetExporter(vars *GetExporterVariables) (*GetExporterResponse, error) {
	return GetExporter(client.Url, client.Client, vars)
}

//
// query GetExporters($tenant: String!)
//

type GetExportersVariables struct {
	Tenant String `json:"tenant"`
}

type GetExportersResponse struct {
	Exporter []struct {
		Tenant     string `json:"Tenant"`
		Name       string `json:"Name"`
		Type       string `json:"Type"`
		Credential string `json:"Credential"`
		Config     string `json:"Config"`
		CreatedAt  string `json:"CreatedAt"`
		UpdatedAt  string `json:"UpdatedAt"`
	} `json:"Exporter"`
}

type GetExportersRequest struct {
	*http.Request
}

func NewGetExportersRequest(url string, vars *GetExportersVariables) (*GetExportersRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetExporters($tenant: String!) {
  exporter(where: {tenant: {_eq: $tenant}}) {
    tenant
    name
    type
    credential
    config
    created_at
    updated_at
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetExportersRequest{req}, nil
}

func (req *GetExportersRequest) Execute(client *http.Client) (*GetExportersResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetExportersResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetExporters(url string, client *http.Client, vars *GetExportersVariables) (*GetExportersResponse, error) {
	req, err := NewGetExportersRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetExporters(vars *GetExportersVariables) (*GetExportersResponse, error) {
	return GetExporters(client.Url, client.Client, vars)
}

//
// mutation UpdateExporter($tenant: String!, $name: String!, $config: json!, $credential: String, $updated_at: timestamptz!)
//

type UpdateExporterVariables struct {
	Tenant     String      `json:"tenant"`
	Name       String      `json:"name"`
	Config     Json        `json:"config"`
	Credential *String     `json:"credential,omitempty"`
	UpdatedAt  Timestamptz `json:"updated_at"`
}

type UpdateExporterResponse struct {
	UpdateExporterByPk struct {
		Tenant string `json:"Tenant"`
		Name   string `json:"Name"`
	} `json:"UpdateExporterByPk"`
}

type UpdateExporterRequest struct {
	*http.Request
}

func NewUpdateExporterRequest(url string, vars *UpdateExporterVariables) (*UpdateExporterRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation UpdateExporter($tenant: String!, $name: String!, $config: json!, $credential: String, $updated_at: timestamptz!) {
  update_exporter_by_pk(_set: {config: $config, credential: $credential, updated_at: $updated_at}, pk_columns: {tenant: $tenant, name: $name}) {
    tenant
    name
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &UpdateExporterRequest{req}, nil
}

func (req *UpdateExporterRequest) Execute(client *http.Client) (*UpdateExporterResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result UpdateExporterResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func UpdateExporter(url string, client *http.Client, vars *UpdateExporterVariables) (*UpdateExporterResponse, error) {
	req, err := NewUpdateExporterRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) UpdateExporter(vars *UpdateExporterVariables) (*UpdateExporterResponse, error) {
	return UpdateExporter(client.Url, client.Client, vars)
}

//
// query GetCompiledOutput($id: uuid!)
//

type GetCompiledOutputVariables struct {
	ID UUID `json:"id"`
}

type GetCompiledOutputResponse struct {
	FileByPk struct {
		Js            string `json:"Js"`
		Dts           string `json:"Dts"`
		Map           string `json:"Map"`
		CompileErrors string `json:"CompileErrors"`
	} `json:"FileByPk"`
}

type GetCompiledOutputRequest struct {
	*http.Request
}

func NewGetCompiledOutputRequest(url string, vars *GetCompiledOutputVariables) (*GetCompiledOutputRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetCompiledOutput($id: uuid!) {
  file_by_pk(id: $id) {
    js
    dts
    map
    compile_errors
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetCompiledOutputRequest{req}, nil
}

func (req *GetCompiledOutputRequest) Execute(client *http.Client) (*GetCompiledOutputResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetCompiledOutputResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetCompiledOutput(url string, client *http.Client, vars *GetCompiledOutputVariables) (*GetCompiledOutputResponse, error) {
	req, err := NewGetCompiledOutputRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetCompiledOutput(vars *GetCompiledOutputVariables) (*GetCompiledOutputResponse, error) {
	return GetCompiledOutput(client.Url, client.Client, vars)
}

//
// query GetFile($id: uuid!)
//

type GetFileVariables struct {
	ID UUID `json:"id"`
}

type GetFileResponse struct {
	FileByPk struct {
		ID            string `json:"ID"`
		Ext           string `json:"Ext"`
		Path          string `json:"Path"`
		ModuleName    string `json:"ModuleName"`
		ModuleScope   string `json:"ModuleScope"`
		ModuleVersion string `json:"ModuleVersion"`
		CreatedAt     string `json:"CreatedAt"`
		BranchName    string `json:"BranchName"`
		BaseFileId    string `json:"BaseFileId"`
		MarkDeleted   string `json:"MarkDeleted"`
		Contents      string `json:"Contents"`
	} `json:"FileByPk"`
}

type GetFileRequest struct {
	*http.Request
}

func NewGetFileRequest(url string, vars *GetFileVariables) (*GetFileRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetFile($id: uuid!) {
  file_by_pk(id: $id) {
    id
    ext
    path
    module_name
    module_scope
    module_version
    created_at
    branch_name
    base_file_id
    mark_deleted
    contents
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetFileRequest{req}, nil
}

func (req *GetFileRequest) Execute(client *http.Client) (*GetFileResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetFileResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetFile(url string, client *http.Client, vars *GetFileVariables) (*GetFileResponse, error) {
	req, err := NewGetFileRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetFile(vars *GetFileVariables) (*GetFileResponse, error) {
	return GetFile(client.Url, client.Client, vars)
}

//
// query GetFileId($branch: String, $module: String, $scope: String, $version: String, $path: String)
//

type GetFileIdVariables struct {
	Branch  *String `json:"branch,omitempty"`
	Module  *String `json:"module,omitempty"`
	Scope   *String `json:"scope,omitempty"`
	Version *String `json:"version,omitempty"`
	Path    *String `json:"path,omitempty"`
}

type GetFileIdResponse struct {
	File []struct {
		ID         string `json:"ID"`
		BranchName string `json:"BranchName"`
	} `json:"File"`
}

type GetFileIdRequest struct {
	*http.Request
}

func NewGetFileIdRequest(url string, vars *GetFileIdVariables) (*GetFileIdRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetFileId($branch: String, $module: String, $scope: String, $version: String, $path: String) {
  file(where: {_or: [{branch_name: {_eq: $branch}, module_name: {_eq: $module}, module_scope: {_eq: $scope}, module_version: {_eq: $version}, path: {_eq: $path}}, {branch_name: {_eq: "main"}, module_name: {_eq: $module}, module_scope: {_eq: $scope}, module_version: {_eq: $version}, path: {_eq: $path}}]}) {
    id
    branch_name
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetFileIdRequest{req}, nil
}

func (req *GetFileIdRequest) Execute(client *http.Client) (*GetFileIdResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetFileIdResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetFileId(url string, client *http.Client, vars *GetFileIdVariables) (*GetFileIdResponse, error) {
	req, err := NewGetFileIdRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetFileId(vars *GetFileIdVariables) (*GetFileIdResponse, error) {
	return GetFileId(client.Url, client.Client, vars)
}

//
// mutation UpdateContents($id: uuid!, $contents: String!, $js: String!, $dts: String!, $map: String!, $errors: jsonb!)
//

type UpdateContentsVariables struct {
	ID       UUID   `json:"id"`
	Contents String `json:"contents"`
	Js       String `json:"js"`
	Dts      String `json:"dts"`
	Map      String `json:"map"`
	Errors   Jsonb  `json:"errors"`
}

type UpdateContentsResponse struct {
	UpdateFileByPk struct {
		ID string `json:"ID"`
	} `json:"UpdateFileByPk"`
}

type UpdateContentsRequest struct {
	*http.Request
}

func NewUpdateContentsRequest(url string, vars *UpdateContentsVariables) (*UpdateContentsRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation UpdateContents($id: uuid!, $contents: String!, $js: String!, $dts: String!, $map: String!, $errors: jsonb!) {
  update_file_by_pk(pk_columns: {id: $id}, _set: {contents: $contents, js: $js, dts: $dts, map: $map, compile_errors: $errors}) {
    id
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &UpdateContentsRequest{req}, nil
}

func (req *UpdateContentsRequest) Execute(client *http.Client) (*UpdateContentsResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result UpdateContentsResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func UpdateContents(url string, client *http.Client, vars *UpdateContentsVariables) (*UpdateContentsResponse, error) {
	req, err := NewUpdateContentsRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) UpdateContents(vars *UpdateContentsVariables) (*UpdateContentsResponse, error) {
	return UpdateContents(client.Url, client.Client, vars)
}

//
// mutation CreateModule($name: String!, $scope: String!, $branch: String!, $version: String!, $files: [file_insert_input!]!)
//

type CreateModuleVariables struct {
	Name    String             `json:"name"`
	Scope   String             `json:"scope"`
	Branch  String             `json:"branch"`
	Version String             `json:"version"`
	Files   *[]FileInsertInput `json:"files,omitempty"`
}

type CreateModuleResponse struct {
	InsertModuleOne struct {
		CreatedAt string `json:"CreatedAt"`
	} `json:"InsertModuleOne"`
	InsertModuleVersion struct {
		Returning []struct {
			CreatedAt string `json:"CreatedAt"`
		} `json:"Returning"`
	} `json:"InsertModuleVersion"`
	InsertFile struct {
		Returning []struct {
			ID string `json:"ID"`
		} `json:"Returning"`
	} `json:"InsertFile"`
}

type CreateModuleRequest struct {
	*http.Request
}

func NewCreateModuleRequest(url string, vars *CreateModuleVariables) (*CreateModuleRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation CreateModule($name: String!, $scope: String!, $branch: String!, $version: String!, $files: [file_insert_input!]!) {
  insert_module_one(object: {name: $name, scope: $scope, branch_name: $branch}) {
    created_at
  }
  insert_module_version(objects: [{module_name: $name, module_scope: $scope, branch_name: $branch, version: $version}, {module_name: $name, module_scope: $scope, branch_name: $branch, version: "latest"}]) {
    returning {
      created_at
    }
  }
  insert_file(objects: $files) {
    returning {
      id
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &CreateModuleRequest{req}, nil
}

func (req *CreateModuleRequest) Execute(client *http.Client) (*CreateModuleResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result CreateModuleResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func CreateModule(url string, client *http.Client, vars *CreateModuleVariables) (*CreateModuleResponse, error) {
	req, err := NewCreateModuleRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) CreateModule(vars *CreateModuleVariables) (*CreateModuleResponse, error) {
	return CreateModule(client.Url, client.Client, vars)
}

//
// query GetModule($name: String!, $scope: String!, $branch: String!)
//

type GetModuleVariables struct {
	Name   String `json:"name"`
	Scope  String `json:"scope"`
	Branch String `json:"branch"`
}

type GetModuleResponse struct {
	ModuleByPk struct {
		CreatedAt string `json:"CreatedAt"`
	} `json:"ModuleByPk"`
	BranchByPk struct {
		Protected string `json:"Protected"`
	} `json:"BranchByPk"`
}

type GetModuleRequest struct {
	*http.Request
}

func NewGetModuleRequest(url string, vars *GetModuleVariables) (*GetModuleRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetModule($name: String!, $scope: String!, $branch: String!) {
  module_by_pk(branch_name: $branch, name: $name, scope: $scope) {
    created_at
  }
  branch_by_pk(name: $branch) {
    protected
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetModuleRequest{req}, nil
}

func (req *GetModuleRequest) Execute(client *http.Client) (*GetModuleResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetModuleResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetModule(url string, client *http.Client, vars *GetModuleVariables) (*GetModuleResponse, error) {
	req, err := NewGetModuleRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetModule(vars *GetModuleVariables) (*GetModuleResponse, error) {
	return GetModule(client.Url, client.Client, vars)
}

//
// mutation CreateVersionedFiles($name: String!, $scope: String!, $branch: String!, $version: String!, $files: [file_insert_input!]!)
//

type CreateVersionedFilesVariables struct {
	Name    String             `json:"name"`
	Scope   String             `json:"scope"`
	Branch  String             `json:"branch"`
	Version String             `json:"version"`
	Files   *[]FileInsertInput `json:"files,omitempty"`
}

type CreateVersionedFilesResponse struct {
	InsertModuleVersion struct {
		Returning []struct {
			CreatedAt string `json:"CreatedAt"`
		} `json:"Returning"`
	} `json:"InsertModuleVersion"`
	InsertFile struct {
		Returning []struct {
			ID string `json:"ID"`
		} `json:"Returning"`
	} `json:"InsertFile"`
}

type CreateVersionedFilesRequest struct {
	*http.Request
}

func NewCreateVersionedFilesRequest(url string, vars *CreateVersionedFilesVariables) (*CreateVersionedFilesRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation CreateVersionedFiles($name: String!, $scope: String!, $branch: String!, $version: String!, $files: [file_insert_input!]!) {
  insert_module_version(objects: [{module_name: $name, module_scope: $scope, branch_name: $branch, version: $version}]) {
    returning {
      created_at
    }
  }
  insert_file(objects: $files) {
    returning {
      id
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &CreateVersionedFilesRequest{req}, nil
}

func (req *CreateVersionedFilesRequest) Execute(client *http.Client) (*CreateVersionedFilesResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result CreateVersionedFilesResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func CreateVersionedFiles(url string, client *http.Client, vars *CreateVersionedFilesVariables) (*CreateVersionedFilesResponse, error) {
	req, err := NewCreateVersionedFilesRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) CreateVersionedFiles(vars *CreateVersionedFilesVariables) (*CreateVersionedFilesResponse, error) {
	return CreateVersionedFiles(client.Url, client.Client, vars)
}

//
// query GetExportersDump
//

type GetExportersDumpResponse struct {
	Exporter []struct {
		Tenant     string `json:"Tenant"`
		Name       string `json:"Name"`
		Type       string `json:"Type"`
		Credential string `json:"Credential"`
		Config     string `json:"Config"`
		CreatedAt  string `json:"CreatedAt"`
		UpdatedAt  string `json:"UpdatedAt"`
	} `json:"Exporter"`
}

type GetExportersDumpRequest struct {
	*http.Request
}

func NewGetExportersDumpRequest(url string) (*GetExportersDumpRequest, error) {
	b, err := json.Marshal(&GraphQLOperation{
		Query: `query GetExportersDump {
  exporter {
    tenant
    name
    type
    credential
    config
    created_at
    updated_at
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetExportersDumpRequest{req}, nil
}

func (req *GetExportersDumpRequest) Execute(client *http.Client) (*GetExportersDumpResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetExportersDumpResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetExportersDump(url string, client *http.Client) (*GetExportersDumpResponse, error) {
	req, err := NewGetExportersDumpRequest(url)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetExportersDump() (*GetExportersDumpResponse, error) {
	return GetExportersDump(client.Url, client.Client)
}

//
// query GetModuleVersionFiles($branch: String, $name: String, $scope: String, $version: String)
//

type GetModuleVersionFilesVariables struct {
	Branch  *String `json:"branch,omitempty"`
	Name    *String `json:"name,omitempty"`
	Scope   *String `json:"scope,omitempty"`
	Version *String `json:"version,omitempty"`
}

type GetModuleVersionFilesResponse struct {
	File []struct {
		ID            string `json:"ID"`
		Ext           string `json:"Ext"`
		Path          string `json:"Path"`
		ModuleName    string `json:"ModuleName"`
		ModuleScope   string `json:"ModuleScope"`
		ModuleVersion string `json:"ModuleVersion"`
		CreatedAt     string `json:"CreatedAt"`
		BranchName    string `json:"BranchName"`
		BaseFileId    string `json:"BaseFileId"`
		MarkDeleted   string `json:"MarkDeleted"`
		Contents      string `json:"Contents"`
	} `json:"File"`
	ModuleVersion []struct {
		Version string `json:"Version"`
	} `json:"ModuleVersion"`
}

type GetModuleVersionFilesRequest struct {
	*http.Request
}

func NewGetModuleVersionFilesRequest(url string, vars *GetModuleVersionFilesVariables) (*GetModuleVersionFilesRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetModuleVersionFiles($branch: String, $name: String, $scope: String, $version: String) {
  file(where: {_and: {branch_name: {_eq: $branch}, module_version: {_eq: $version}, module_scope: {_eq: $scope}, module_name: {_eq: $name}}}) {
    id
    ext
    path
    module_name
    module_scope
    module_version
    created_at
    branch_name
    base_file_id
    mark_deleted
    contents
  }
  module_version(limit: 1, order_by: {created_at: desc}, where: {_and: {branch_name: {_eq: $branch}, module_scope: {_eq: $scope}, module_name: {_eq: $name}}}) {
    version
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetModuleVersionFilesRequest{req}, nil
}

func (req *GetModuleVersionFilesRequest) Execute(client *http.Client) (*GetModuleVersionFilesResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetModuleVersionFilesResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetModuleVersionFiles(url string, client *http.Client, vars *GetModuleVersionFilesVariables) (*GetModuleVersionFilesResponse, error) {
	req, err := NewGetModuleVersionFilesRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetModuleVersionFiles(vars *GetModuleVersionFilesVariables) (*GetModuleVersionFilesResponse, error) {
	return GetModuleVersionFiles(client.Url, client.Client, vars)
}

//
// mutation CreateTenants($tenants: [tenant_insert_input!]!)
//

type CreateTenantsVariables struct {
	Tenants *[]TenantInsertInput `json:"tenants,omitempty"`
}

type CreateTenantsResponse struct {
	InsertTenant struct {
		Returning []struct {
			Name string `json:"Name"`
		} `json:"Returning"`
	} `json:"InsertTenant"`
}

type CreateTenantsRequest struct {
	*http.Request
}

func NewCreateTenantsRequest(url string, vars *CreateTenantsVariables) (*CreateTenantsRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation CreateTenants($tenants: [tenant_insert_input!]!) {
  insert_tenant(objects: $tenants) {
    returning {
      name
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &CreateTenantsRequest{req}, nil
}

func (req *CreateTenantsRequest) Execute(client *http.Client) (*CreateTenantsResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result CreateTenantsResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func CreateTenants(url string, client *http.Client, vars *CreateTenantsVariables) (*CreateTenantsResponse, error) {
	req, err := NewCreateTenantsRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) CreateTenants(vars *CreateTenantsVariables) (*CreateTenantsResponse, error) {
	return CreateTenants(client.Url, client.Client, vars)
}

//
// mutation DeleteTenant($name: String!)
//

type DeleteTenantVariables struct {
	Name String `json:"name"`
}

type DeleteTenantResponse struct {
	DeleteTenantByPk struct {
		Name string `json:"Name"`
	} `json:"DeleteTenantByPk"`
}

type DeleteTenantRequest struct {
	*http.Request
}

func NewDeleteTenantRequest(url string, vars *DeleteTenantVariables) (*DeleteTenantRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation DeleteTenant($name: String!) {
  delete_tenant_by_pk(name: $name) {
    name
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &DeleteTenantRequest{req}, nil
}

func (req *DeleteTenantRequest) Execute(client *http.Client) (*DeleteTenantResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result DeleteTenantResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func DeleteTenant(url string, client *http.Client, vars *DeleteTenantVariables) (*DeleteTenantResponse, error) {
	req, err := NewDeleteTenantRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) DeleteTenant(vars *DeleteTenantVariables) (*DeleteTenantResponse, error) {
	return DeleteTenant(client.Url, client.Client, vars)
}

//
// query GetTenants
//

type GetTenantsResponse struct {
	Tenant []struct {
		Name      string `json:"Name"`
		CreatedAt string `json:"CreatedAt"`
		Type      string `json:"Type"`
	} `json:"Tenant"`
}

type GetTenantsRequest struct {
	*http.Request
}

func NewGetTenantsRequest(url string) (*GetTenantsRequest, error) {
	b, err := json.Marshal(&GraphQLOperation{
		Query: `query GetTenants {
  tenant {
    name
    created_at
    type
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetTenantsRequest{req}, nil
}

func (req *GetTenantsRequest) Execute(client *http.Client) (*GetTenantsResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetTenantsResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetTenants(url string, client *http.Client) (*GetTenantsResponse, error) {
	req, err := NewGetTenantsRequest(url)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetTenants() (*GetTenantsResponse, error) {
	return GetTenants(client.Url, client.Client)
}

//
// mutation CreateUser($email: String!, $username: String!, $avatar: String!)
//

type CreateUserVariables struct {
	Email    String `json:"email"`
	Username String `json:"username"`
	Avatar   String `json:"avatar"`
}

type CreateUserResponse struct {
	InsertUserPreferenceOne struct {
		Email string `json:"Email"`
	} `json:"InsertUserPreferenceOne"`
}

type CreateUserRequest struct {
	*http.Request
}

func NewCreateUserRequest(url string, vars *CreateUserVariables) (*CreateUserRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation CreateUser($email: String!, $username: String!, $avatar: String!) {
  insert_user_preference_one(object: {dark_mode: true, user: {data: {avatar: $avatar, email: $email, username: $username}}}) {
    email
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &CreateUserRequest{req}, nil
}

func (req *CreateUserRequest) Execute(client *http.Client) (*CreateUserResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result CreateUserResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func CreateUser(url string, client *http.Client, vars *CreateUserVariables) (*CreateUserResponse, error) {
	req, err := NewCreateUserRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) CreateUser(vars *CreateUserVariables) (*CreateUserResponse, error) {
	return CreateUser(client.Url, client.Client, vars)
}

//
// mutation DeleteUser($email: String!)
//

type DeleteUserVariables struct {
	Email String `json:"email"`
}

type DeleteUserResponse struct {
	UpdateUserByPk struct {
		Email    string `json:"Email"`
		OpaqueId string `json:"OpaqueId"`
	} `json:"UpdateUserByPk"`
}

type DeleteUserRequest struct {
	*http.Request
}

func NewDeleteUserRequest(url string, vars *DeleteUserVariables) (*DeleteUserRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation DeleteUser($email: String!) {
  update_user_by_pk(_set: {active: false}, pk_columns: {email: $email}) {
    email
    opaque_id
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &DeleteUserRequest{req}, nil
}

func (req *DeleteUserRequest) Execute(client *http.Client) (*DeleteUserResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result DeleteUserResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func DeleteUser(url string, client *http.Client, vars *DeleteUserVariables) (*DeleteUserResponse, error) {
	req, err := NewDeleteUserRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) DeleteUser(vars *DeleteUserVariables) (*DeleteUserResponse, error) {
	return DeleteUser(client.Url, client.Client, vars)
}

//
// query GetCurrentUser
//

type GetCurrentUserResponse struct {
	User []struct {
		Email      string `json:"Email"`
		Avatar     string `json:"Avatar"`
		Username   string `json:"Username"`
		Active     string `json:"Active"`
		Preference struct {
			DarkMode string `json:"DarkMode"`
		} `json:"Preference"`
	} `json:"User"`
}

type GetCurrentUserRequest struct {
	*http.Request
}

func NewGetCurrentUserRequest(url string) (*GetCurrentUserRequest, error) {
	b, err := json.Marshal(&GraphQLOperation{
		Query: `query GetCurrentUser {
  user {
    email
    avatar
    username
    active
    preference {
      dark_mode
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetCurrentUserRequest{req}, nil
}

func (req *GetCurrentUserRequest) Execute(client *http.Client) (*GetCurrentUserResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetCurrentUserResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetCurrentUser(url string, client *http.Client) (*GetCurrentUserResponse, error) {
	req, err := NewGetCurrentUserRequest(url)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetCurrentUser() (*GetCurrentUserResponse, error) {
	return GetCurrentUser(client.Url, client.Client)
}

//
// query GetUser($email: String!)
//

type GetUserVariables struct {
	Email String `json:"email"`
}

type GetUserResponse struct {
	UserByPk struct {
		Email    string `json:"Email"`
		Avatar   string `json:"Avatar"`
		Username string `json:"Username"`
		Active   string `json:"Active"`
	} `json:"UserByPk"`
	UserAggregate struct {
		Aggregate struct {
			Count string `json:"Count"`
		} `json:"Aggregate"`
	} `json:"UserAggregate"`
}

type GetUserRequest struct {
	*http.Request
}

func NewGetUserRequest(url string, vars *GetUserVariables) (*GetUserRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetUser($email: String!) {
  user_by_pk(email: $email) {
    email
    avatar
    username
    active
  }
  user_aggregate(where: {active: {_eq: true}}) {
    aggregate {
      count
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetUserRequest{req}, nil
}

func (req *GetUserRequest) Execute(client *http.Client) (*GetUserResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetUserResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetUser(url string, client *http.Client, vars *GetUserVariables) (*GetUserResponse, error) {
	req, err := NewGetUserRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetUser(vars *GetUserVariables) (*GetUserResponse, error) {
	return GetUser(client.Url, client.Client, vars)
}

//
// mutation ReactivateUser($email: String!)
//

type ReactivateUserVariables struct {
	Email String `json:"email"`
}

type ReactivateUserResponse struct {
	UpdateUserByPk struct {
		Email    string `json:"Email"`
		OpaqueId string `json:"OpaqueId"`
	} `json:"UpdateUserByPk"`
}

type ReactivateUserRequest struct {
	*http.Request
}

func NewReactivateUserRequest(url string, vars *ReactivateUserVariables) (*ReactivateUserRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation ReactivateUser($email: String!) {
  update_user_by_pk(_set: {active: true}, pk_columns: {email: $email}) {
    email
    opaque_id
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &ReactivateUserRequest{req}, nil
}

func (req *ReactivateUserRequest) Execute(client *http.Client) (*ReactivateUserResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result ReactivateUserResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func ReactivateUser(url string, client *http.Client, vars *ReactivateUserVariables) (*ReactivateUserResponse, error) {
	req, err := NewReactivateUserRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) ReactivateUser(vars *ReactivateUserVariables) (*ReactivateUserResponse, error) {
	return ReactivateUser(client.Url, client.Client, vars)
}

//
// mutation SetDarkMode($email: String!, $darkMode: Boolean!)
//

type SetDarkModeVariables struct {
	Email    String  `json:"email"`
	DarkMode Boolean `json:"darkMode"`
}

type SetDarkModeResponse struct {
	UpdateUserPreferenceByPk struct {
		DarkMode string `json:"DarkMode"`
	} `json:"UpdateUserPreferenceByPk"`
}

type SetDarkModeRequest struct {
	*http.Request
}

func NewSetDarkModeRequest(url string, vars *SetDarkModeVariables) (*SetDarkModeRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation SetDarkMode($email: String!, $darkMode: Boolean!) {
  update_user_preference_by_pk(pk_columns: {email: $email}, _set: {dark_mode: $darkMode}) {
    dark_mode
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &SetDarkModeRequest{req}, nil
}

func (req *SetDarkModeRequest) Execute(client *http.Client) (*SetDarkModeResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result SetDarkModeResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func SetDarkMode(url string, client *http.Client, vars *SetDarkModeVariables) (*SetDarkModeResponse, error) {
	req, err := NewSetDarkModeRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) SetDarkMode(vars *SetDarkModeVariables) (*SetDarkModeResponse, error) {
	return SetDarkMode(client.Url, client.Client, vars)
}

//
// mutation UpdateUser($email: String!, $username: String!, $avatar: String!, $time: timestamptz!)
//

type UpdateUserVariables struct {
	Email    String      `json:"email"`
	Username String      `json:"username"`
	Avatar   String      `json:"avatar"`
	Time     Timestamptz `json:"time"`
}

type UpdateUserResponse struct {
	UpdateUserByPk struct {
		Email    string `json:"Email"`
		OpaqueId string `json:"OpaqueId"`
	} `json:"UpdateUserByPk"`
}

type UpdateUserRequest struct {
	*http.Request
}

func NewUpdateUserRequest(url string, vars *UpdateUserVariables) (*UpdateUserRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation UpdateUser($email: String!, $username: String!, $avatar: String!, $time: timestamptz!) {
  update_user_by_pk(_set: {username: $username, email: $email, avatar: $avatar, session_last_updated: $time}, pk_columns: {email: $email}) {
    email
    opaque_id
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &UpdateUserRequest{req}, nil
}

func (req *UpdateUserRequest) Execute(client *http.Client) (*UpdateUserResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result UpdateUserResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func UpdateUser(url string, client *http.Client, vars *UpdateUserVariables) (*UpdateUserResponse, error) {
	req, err := NewUpdateUserRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) UpdateUser(vars *UpdateUserVariables) (*UpdateUserResponse, error) {
	return UpdateUser(client.Url, client.Client, vars)
}

//
// Scalars
//

type Int int32
type Float float64
type Boolean bool
type String string
type ID string
type Json string
type Jsonb string
type Timestamp string
type Timestamptz string
type UUID string

//
// Enums
//

type BranchConstraint string

const (
	BranchConstraintBranchNameKey BranchConstraint = "Branch_name_key"
	BranchConstraintBranchPkey    BranchConstraint = "branch_pkey"
)

type BranchSelectColumn string

const (
	BranchSelectColumnCreatedAt BranchSelectColumn = "created_at"
	BranchSelectColumnHasMerged BranchSelectColumn = "has_merged"
	BranchSelectColumnName      BranchSelectColumn = "name"
	BranchSelectColumnProtected BranchSelectColumn = "protected"
)

type BranchUpdateColumn string

const (
	BranchUpdateColumnCreatedAt BranchUpdateColumn = "created_at"
	BranchUpdateColumnHasMerged BranchUpdateColumn = "has_merged"
	BranchUpdateColumnName      BranchUpdateColumn = "name"
	BranchUpdateColumnProtected BranchUpdateColumn = "protected"
)

type CredentialConstraint string

const (
	CredentialConstraintCredentialPkey CredentialConstraint = "credential_pkey"
)

type CredentialSelectColumn string

const (
	CredentialSelectColumnCreatedAt CredentialSelectColumn = "created_at"
	CredentialSelectColumnName      CredentialSelectColumn = "name"
	CredentialSelectColumnTenant    CredentialSelectColumn = "tenant"
	CredentialSelectColumnType      CredentialSelectColumn = "type"
	CredentialSelectColumnUpdatedAt CredentialSelectColumn = "updated_at"
	CredentialSelectColumnValue     CredentialSelectColumn = "value"
)

type CredentialUpdateColumn string

const (
	CredentialUpdateColumnCreatedAt CredentialUpdateColumn = "created_at"
	CredentialUpdateColumnName      CredentialUpdateColumn = "name"
	CredentialUpdateColumnTenant    CredentialUpdateColumn = "tenant"
	CredentialUpdateColumnType      CredentialUpdateColumn = "type"
	CredentialUpdateColumnUpdatedAt CredentialUpdateColumn = "updated_at"
	CredentialUpdateColumnValue     CredentialUpdateColumn = "value"
)

type ExporterConstraint string

const (
	ExporterConstraintExporterPkey ExporterConstraint = "exporter_pkey"
)

type ExporterSelectColumn string

const (
	ExporterSelectColumnConfig     ExporterSelectColumn = "config"
	ExporterSelectColumnCreatedAt  ExporterSelectColumn = "created_at"
	ExporterSelectColumnCredential ExporterSelectColumn = "credential"
	ExporterSelectColumnName       ExporterSelectColumn = "name"
	ExporterSelectColumnTenant     ExporterSelectColumn = "tenant"
	ExporterSelectColumnType       ExporterSelectColumn = "type"
	ExporterSelectColumnUpdatedAt  ExporterSelectColumn = "updated_at"
)

type ExporterUpdateColumn string

const (
	ExporterUpdateColumnConfig     ExporterUpdateColumn = "config"
	ExporterUpdateColumnCreatedAt  ExporterUpdateColumn = "created_at"
	ExporterUpdateColumnCredential ExporterUpdateColumn = "credential"
	ExporterUpdateColumnName       ExporterUpdateColumn = "name"
	ExporterUpdateColumnTenant     ExporterUpdateColumn = "tenant"
	ExporterUpdateColumnType       ExporterUpdateColumn = "type"
	ExporterUpdateColumnUpdatedAt  ExporterUpdateColumn = "updated_at"
)

type FileConstraint string

const (
	FileConstraintFilePathModuleVersionModuleNameModuleScopeBranchNameE FileConstraint = "file_path_module_version_module_name_module_scope_branch_name_e"
	FileConstraintFilePkey                                              FileConstraint = "file_pkey"
)

type FileSelectColumn string

const (
	FileSelectColumnBaseFileId    FileSelectColumn = "base_file_id"
	FileSelectColumnBranchName    FileSelectColumn = "branch_name"
	FileSelectColumnCompileErrors FileSelectColumn = "compile_errors"
	FileSelectColumnContents      FileSelectColumn = "contents"
	FileSelectColumnCreatedAt     FileSelectColumn = "created_at"
	FileSelectColumnDts           FileSelectColumn = "dts"
	FileSelectColumnExt           FileSelectColumn = "ext"
	FileSelectColumnID            FileSelectColumn = "id"
	FileSelectColumnJs            FileSelectColumn = "js"
	FileSelectColumnMap           FileSelectColumn = "map"
	FileSelectColumnMarkDeleted   FileSelectColumn = "mark_deleted"
	FileSelectColumnModuleName    FileSelectColumn = "module_name"
	FileSelectColumnModuleScope   FileSelectColumn = "module_scope"
	FileSelectColumnModuleVersion FileSelectColumn = "module_version"
	FileSelectColumnPath          FileSelectColumn = "path"
)

type FileUpdateColumn string

const (
	FileUpdateColumnBaseFileId    FileUpdateColumn = "base_file_id"
	FileUpdateColumnBranchName    FileUpdateColumn = "branch_name"
	FileUpdateColumnCompileErrors FileUpdateColumn = "compile_errors"
	FileUpdateColumnContents      FileUpdateColumn = "contents"
	FileUpdateColumnCreatedAt     FileUpdateColumn = "created_at"
	FileUpdateColumnDts           FileUpdateColumn = "dts"
	FileUpdateColumnExt           FileUpdateColumn = "ext"
	FileUpdateColumnID            FileUpdateColumn = "id"
	FileUpdateColumnJs            FileUpdateColumn = "js"
	FileUpdateColumnMap           FileUpdateColumn = "map"
	FileUpdateColumnMarkDeleted   FileUpdateColumn = "mark_deleted"
	FileUpdateColumnModuleName    FileUpdateColumn = "module_name"
	FileUpdateColumnModuleScope   FileUpdateColumn = "module_scope"
	FileUpdateColumnModuleVersion FileUpdateColumn = "module_version"
	FileUpdateColumnPath          FileUpdateColumn = "path"
)

type ModuleConstraint string

const (
	ModuleConstraintModulePkey ModuleConstraint = "module_pkey"
)

type ModuleSelectColumn string

const (
	ModuleSelectColumnBranchName ModuleSelectColumn = "branch_name"
	ModuleSelectColumnCreatedAt  ModuleSelectColumn = "created_at"
	ModuleSelectColumnName       ModuleSelectColumn = "name"
	ModuleSelectColumnScope      ModuleSelectColumn = "scope"
)

type ModuleUpdateColumn string

const (
	ModuleUpdateColumnBranchName ModuleUpdateColumn = "branch_name"
	ModuleUpdateColumnCreatedAt  ModuleUpdateColumn = "created_at"
	ModuleUpdateColumnName       ModuleUpdateColumn = "name"
	ModuleUpdateColumnScope      ModuleUpdateColumn = "scope"
)

type ModuleVersionConstraint string

const (
	ModuleVersionConstraintModuleVersionPkey ModuleVersionConstraint = "module_version_pkey"
)

type ModuleVersionSelectColumn string

const (
	ModuleVersionSelectColumnBranchName  ModuleVersionSelectColumn = "branch_name"
	ModuleVersionSelectColumnCreatedAt   ModuleVersionSelectColumn = "created_at"
	ModuleVersionSelectColumnModuleName  ModuleVersionSelectColumn = "module_name"
	ModuleVersionSelectColumnModuleScope ModuleVersionSelectColumn = "module_scope"
	ModuleVersionSelectColumnVersion     ModuleVersionSelectColumn = "version"
)

type ModuleVersionUpdateColumn string

const (
	ModuleVersionUpdateColumnBranchName  ModuleVersionUpdateColumn = "branch_name"
	ModuleVersionUpdateColumnCreatedAt   ModuleVersionUpdateColumn = "created_at"
	ModuleVersionUpdateColumnModuleName  ModuleVersionUpdateColumn = "module_name"
	ModuleVersionUpdateColumnModuleScope ModuleVersionUpdateColumn = "module_scope"
	ModuleVersionUpdateColumnVersion     ModuleVersionUpdateColumn = "version"
)

type OrderBy string

const (
	OrderByAsc            OrderBy = "asc"
	OrderByAscNullsFirst  OrderBy = "asc_nulls_first"
	OrderByAscNullsLast   OrderBy = "asc_nulls_last"
	OrderByDesc           OrderBy = "desc"
	OrderByDescNullsFirst OrderBy = "desc_nulls_first"
	OrderByDescNullsLast  OrderBy = "desc_nulls_last"
)

type TenantConstraint string

const (
	TenantConstraintTenantPkey TenantConstraint = "tenant_pkey"
)

type TenantSelectColumn string

const (
	TenantSelectColumnCreatedAt TenantSelectColumn = "created_at"
	TenantSelectColumnName      TenantSelectColumn = "name"
	TenantSelectColumnType      TenantSelectColumn = "type"
)

type TenantUpdateColumn string

const (
	TenantUpdateColumnCreatedAt TenantUpdateColumn = "created_at"
	TenantUpdateColumnName      TenantUpdateColumn = "name"
	TenantUpdateColumnType      TenantUpdateColumn = "type"
)

type UserConstraint string

const (
	UserConstraintUserPkey UserConstraint = "user_pkey"
)

type UserPreferenceConstraint string

const (
	UserPreferenceConstraintUserPreferencePkey UserPreferenceConstraint = "user_preference_pkey"
)

type UserPreferenceSelectColumn string

const (
	UserPreferenceSelectColumnDarkMode UserPreferenceSelectColumn = "dark_mode"
	UserPreferenceSelectColumnEmail    UserPreferenceSelectColumn = "email"
)

type UserPreferenceUpdateColumn string

const (
	UserPreferenceUpdateColumnDarkMode UserPreferenceUpdateColumn = "dark_mode"
	UserPreferenceUpdateColumnEmail    UserPreferenceUpdateColumn = "email"
)

type UserSelectColumn string

const (
	UserSelectColumnActive             UserSelectColumn = "active"
	UserSelectColumnAvatar             UserSelectColumn = "avatar"
	UserSelectColumnCreatedAt          UserSelectColumn = "created_at"
	UserSelectColumnEmail              UserSelectColumn = "email"
	UserSelectColumnOpaqueId           UserSelectColumn = "opaque_id"
	UserSelectColumnRole               UserSelectColumn = "role"
	UserSelectColumnSessionLastUpdated UserSelectColumn = "session_last_updated"
	UserSelectColumnUsername           UserSelectColumn = "username"
)

type UserUpdateColumn string

const (
	UserUpdateColumnActive             UserUpdateColumn = "active"
	UserUpdateColumnAvatar             UserUpdateColumn = "avatar"
	UserUpdateColumnCreatedAt          UserUpdateColumn = "created_at"
	UserUpdateColumnEmail              UserUpdateColumn = "email"
	UserUpdateColumnOpaqueId           UserUpdateColumn = "opaque_id"
	UserUpdateColumnRole               UserUpdateColumn = "role"
	UserUpdateColumnSessionLastUpdated UserUpdateColumn = "session_last_updated"
	UserUpdateColumnUsername           UserUpdateColumn = "username"
)

//
// Inputs
//

type BooleanComparisonExp struct {
	Eq     *Boolean   `json:"_eq,omitempty"`
	Gt     *Boolean   `json:"_gt,omitempty"`
	Gte    *Boolean   `json:"_gte,omitempty"`
	In     *[]Boolean `json:"_in,omitempty"`
	IsNull *Boolean   `json:"_is_null,omitempty"`
	Lt     *Boolean   `json:"_lt,omitempty"`
	Lte    *Boolean   `json:"_lte,omitempty"`
	Neq    *Boolean   `json:"_neq,omitempty"`
	Nin    *[]Boolean `json:"_nin,omitempty"`
}

type StringComparisonExp struct {
	Eq       *String   `json:"_eq,omitempty"`
	Gt       *String   `json:"_gt,omitempty"`
	Gte      *String   `json:"_gte,omitempty"`
	Ilike    *String   `json:"_ilike,omitempty"`
	In       *[]String `json:"_in,omitempty"`
	IsNull   *Boolean  `json:"_is_null,omitempty"`
	Like     *String   `json:"_like,omitempty"`
	Lt       *String   `json:"_lt,omitempty"`
	Lte      *String   `json:"_lte,omitempty"`
	Neq      *String   `json:"_neq,omitempty"`
	Nilike   *String   `json:"_nilike,omitempty"`
	Nin      *[]String `json:"_nin,omitempty"`
	Nlike    *String   `json:"_nlike,omitempty"`
	Nsimilar *String   `json:"_nsimilar,omitempty"`
	Similar  *String   `json:"_similar,omitempty"`
}

type BranchAggregateOrderBy struct {
	Count *OrderBy          `json:"count,omitempty"`
	Max   *BranchMaxOrderBy `json:"max,omitempty"`
	Min   *BranchMinOrderBy `json:"min,omitempty"`
}

type BranchArrRelInsertInput struct {
	Data       *[]BranchInsertInput `json:"data,omitempty"`
	OnConflict *BranchOnConflict    `json:"on_conflict,omitempty"`
}

type BranchBoolExp struct {
	And       *[]BranchBoolExp          `json:"_and,omitempty"`
	Not       *BranchBoolExp            `json:"_not,omitempty"`
	Or        *[]BranchBoolExp          `json:"_or,omitempty"`
	CreatedAt *TimestamptzComparisonExp `json:"created_at,omitempty"`
	Files     *FileBoolExp              `json:"files,omitempty"`
	HasMerged *BooleanComparisonExp     `json:"has_merged,omitempty"`
	Modules   *ModuleBoolExp            `json:"modules,omitempty"`
	Name      *StringComparisonExp      `json:"name,omitempty"`
	Protected *BooleanComparisonExp     `json:"protected,omitempty"`
	Versions  *ModuleVersionBoolExp     `json:"versions,omitempty"`
}

type BranchInsertInput struct {
	CreatedAt *Timestamptz                    `json:"created_at,omitempty"`
	Files     *FileArrRelInsertInput          `json:"files,omitempty"`
	HasMerged *Boolean                        `json:"has_merged,omitempty"`
	Modules   *ModuleArrRelInsertInput        `json:"modules,omitempty"`
	Name      *String                         `json:"name,omitempty"`
	Protected *Boolean                        `json:"protected,omitempty"`
	Versions  *ModuleVersionArrRelInsertInput `json:"versions,omitempty"`
}

type BranchMaxOrderBy struct {
	CreatedAt *OrderBy `json:"created_at,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
}

type BranchMinOrderBy struct {
	CreatedAt *OrderBy `json:"created_at,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
}

type BranchObjRelInsertInput struct {
	Data       BranchInsertInput `json:"data"`
	OnConflict *BranchOnConflict `json:"on_conflict,omitempty"`
}

type BranchOnConflict struct {
	Constraint    BranchConstraint      `json:"constraint"`
	UpdateColumns *[]BranchUpdateColumn `json:"update_columns,omitempty"`
	Where         *BranchBoolExp        `json:"where,omitempty"`
}

type BranchOrderBy struct {
	CreatedAt         *OrderBy                       `json:"created_at,omitempty"`
	FilesAggregate    *FileAggregateOrderBy          `json:"files_aggregate,omitempty"`
	HasMerged         *OrderBy                       `json:"has_merged,omitempty"`
	ModulesAggregate  *ModuleAggregateOrderBy        `json:"modules_aggregate,omitempty"`
	Name              *OrderBy                       `json:"name,omitempty"`
	Protected         *OrderBy                       `json:"protected,omitempty"`
	VersionsAggregate *ModuleVersionAggregateOrderBy `json:"versions_aggregate,omitempty"`
}

type BranchPkColumnsInput struct {
	Name String `json:"name"`
}

type BranchSetInput struct {
	CreatedAt *Timestamptz `json:"created_at,omitempty"`
	HasMerged *Boolean     `json:"has_merged,omitempty"`
	Name      *String      `json:"name,omitempty"`
	Protected *Boolean     `json:"protected,omitempty"`
}

type CredentialAggregateOrderBy struct {
	Count *OrderBy              `json:"count,omitempty"`
	Max   *CredentialMaxOrderBy `json:"max,omitempty"`
	Min   *CredentialMinOrderBy `json:"min,omitempty"`
}

type CredentialArrRelInsertInput struct {
	Data       *[]CredentialInsertInput `json:"data,omitempty"`
	OnConflict *CredentialOnConflict    `json:"on_conflict,omitempty"`
}

type CredentialBoolExp struct {
	And            *[]CredentialBoolExp      `json:"_and,omitempty"`
	Not            *CredentialBoolExp        `json:"_not,omitempty"`
	Or             *[]CredentialBoolExp      `json:"_or,omitempty"`
	CreatedAt      *TimestamptzComparisonExp `json:"created_at,omitempty"`
	Exporters      *ExporterBoolExp          `json:"exporters,omitempty"`
	Name           *StringComparisonExp      `json:"name,omitempty"`
	Tenant         *StringComparisonExp      `json:"tenant,omitempty"`
	TenantByTenant *TenantBoolExp            `json:"tenantByTenant,omitempty"`
	Type           *StringComparisonExp      `json:"type,omitempty"`
	UpdatedAt      *TimestamptzComparisonExp `json:"updated_at,omitempty"`
	Value          *JsonComparisonExp        `json:"value,omitempty"`
}

type CredentialInsertInput struct {
	CreatedAt      *Timestamptz               `json:"created_at,omitempty"`
	Exporters      *ExporterArrRelInsertInput `json:"exporters,omitempty"`
	Name           *String                    `json:"name,omitempty"`
	Tenant         *String                    `json:"tenant,omitempty"`
	TenantByTenant *TenantObjRelInsertInput   `json:"tenantByTenant,omitempty"`
	Type           *String                    `json:"type,omitempty"`
	UpdatedAt      *Timestamptz               `json:"updated_at,omitempty"`
	Value          *Json                      `json:"value,omitempty"`
}

type CredentialMaxOrderBy struct {
	CreatedAt *OrderBy `json:"created_at,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
	Tenant    *OrderBy `json:"tenant,omitempty"`
	Type      *OrderBy `json:"type,omitempty"`
	UpdatedAt *OrderBy `json:"updated_at,omitempty"`
}

type CredentialMinOrderBy struct {
	CreatedAt *OrderBy `json:"created_at,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
	Tenant    *OrderBy `json:"tenant,omitempty"`
	Type      *OrderBy `json:"type,omitempty"`
	UpdatedAt *OrderBy `json:"updated_at,omitempty"`
}

type CredentialObjRelInsertInput struct {
	Data       CredentialInsertInput `json:"data"`
	OnConflict *CredentialOnConflict `json:"on_conflict,omitempty"`
}

type CredentialOnConflict struct {
	Constraint    CredentialConstraint      `json:"constraint"`
	UpdateColumns *[]CredentialUpdateColumn `json:"update_columns,omitempty"`
	Where         *CredentialBoolExp        `json:"where,omitempty"`
}

type CredentialOrderBy struct {
	CreatedAt          *OrderBy                  `json:"created_at,omitempty"`
	ExportersAggregate *ExporterAggregateOrderBy `json:"exporters_aggregate,omitempty"`
	Name               *OrderBy                  `json:"name,omitempty"`
	Tenant             *OrderBy                  `json:"tenant,omitempty"`
	TenantByTenant     *TenantOrderBy            `json:"tenantByTenant,omitempty"`
	Type               *OrderBy                  `json:"type,omitempty"`
	UpdatedAt          *OrderBy                  `json:"updated_at,omitempty"`
	Value              *OrderBy                  `json:"value,omitempty"`
}

type CredentialPkColumnsInput struct {
	Name   String `json:"name"`
	Tenant String `json:"tenant"`
}

type CredentialSetInput struct {
	CreatedAt *Timestamptz `json:"created_at,omitempty"`
	Name      *String      `json:"name,omitempty"`
	Tenant    *String      `json:"tenant,omitempty"`
	Type      *String      `json:"type,omitempty"`
	UpdatedAt *Timestamptz `json:"updated_at,omitempty"`
	Value     *Json        `json:"value,omitempty"`
}

type ExporterAggregateOrderBy struct {
	Count *OrderBy            `json:"count,omitempty"`
	Max   *ExporterMaxOrderBy `json:"max,omitempty"`
	Min   *ExporterMinOrderBy `json:"min,omitempty"`
}

type ExporterArrRelInsertInput struct {
	Data       *[]ExporterInsertInput `json:"data,omitempty"`
	OnConflict *ExporterOnConflict    `json:"on_conflict,omitempty"`
}

type ExporterBoolExp struct {
	And                          *[]ExporterBoolExp        `json:"_and,omitempty"`
	Not                          *ExporterBoolExp          `json:"_not,omitempty"`
	Or                           *[]ExporterBoolExp        `json:"_or,omitempty"`
	Config                       *JsonComparisonExp        `json:"config,omitempty"`
	CreatedAt                    *TimestamptzComparisonExp `json:"created_at,omitempty"`
	Credential                   *StringComparisonExp      `json:"credential,omitempty"`
	CredentialByCredentialTenant *CredentialBoolExp        `json:"credentialByCredentialTenant,omitempty"`
	Name                         *StringComparisonExp      `json:"name,omitempty"`
	Tenant                       *StringComparisonExp      `json:"tenant,omitempty"`
	TenantByTenant               *TenantBoolExp            `json:"tenantByTenant,omitempty"`
	Type                         *StringComparisonExp      `json:"type,omitempty"`
	UpdatedAt                    *TimestamptzComparisonExp `json:"updated_at,omitempty"`
}

type ExporterInsertInput struct {
	Config                       *Json                        `json:"config,omitempty"`
	CreatedAt                    *Timestamptz                 `json:"created_at,omitempty"`
	Credential                   *String                      `json:"credential,omitempty"`
	CredentialByCredentialTenant *CredentialObjRelInsertInput `json:"credentialByCredentialTenant,omitempty"`
	Name                         *String                      `json:"name,omitempty"`
	Tenant                       *String                      `json:"tenant,omitempty"`
	TenantByTenant               *TenantObjRelInsertInput     `json:"tenantByTenant,omitempty"`
	Type                         *String                      `json:"type,omitempty"`
	UpdatedAt                    *Timestamptz                 `json:"updated_at,omitempty"`
}

type ExporterMaxOrderBy struct {
	CreatedAt  *OrderBy `json:"created_at,omitempty"`
	Credential *OrderBy `json:"credential,omitempty"`
	Name       *OrderBy `json:"name,omitempty"`
	Tenant     *OrderBy `json:"tenant,omitempty"`
	Type       *OrderBy `json:"type,omitempty"`
	UpdatedAt  *OrderBy `json:"updated_at,omitempty"`
}

type ExporterMinOrderBy struct {
	CreatedAt  *OrderBy `json:"created_at,omitempty"`
	Credential *OrderBy `json:"credential,omitempty"`
	Name       *OrderBy `json:"name,omitempty"`
	Tenant     *OrderBy `json:"tenant,omitempty"`
	Type       *OrderBy `json:"type,omitempty"`
	UpdatedAt  *OrderBy `json:"updated_at,omitempty"`
}

type ExporterObjRelInsertInput struct {
	Data       ExporterInsertInput `json:"data"`
	OnConflict *ExporterOnConflict `json:"on_conflict,omitempty"`
}

type ExporterOnConflict struct {
	Constraint    ExporterConstraint      `json:"constraint"`
	UpdateColumns *[]ExporterUpdateColumn `json:"update_columns,omitempty"`
	Where         *ExporterBoolExp        `json:"where,omitempty"`
}

type ExporterOrderBy struct {
	Config                       *OrderBy           `json:"config,omitempty"`
	CreatedAt                    *OrderBy           `json:"created_at,omitempty"`
	Credential                   *OrderBy           `json:"credential,omitempty"`
	CredentialByCredentialTenant *CredentialOrderBy `json:"credentialByCredentialTenant,omitempty"`
	Name                         *OrderBy           `json:"name,omitempty"`
	Tenant                       *OrderBy           `json:"tenant,omitempty"`
	TenantByTenant               *TenantOrderBy     `json:"tenantByTenant,omitempty"`
	Type                         *OrderBy           `json:"type,omitempty"`
	UpdatedAt                    *OrderBy           `json:"updated_at,omitempty"`
}

type ExporterPkColumnsInput struct {
	Name   String `json:"name"`
	Tenant String `json:"tenant"`
}

type ExporterSetInput struct {
	Config     *Json        `json:"config,omitempty"`
	CreatedAt  *Timestamptz `json:"created_at,omitempty"`
	Credential *String      `json:"credential,omitempty"`
	Name       *String      `json:"name,omitempty"`
	Tenant     *String      `json:"tenant,omitempty"`
	Type       *String      `json:"type,omitempty"`
	UpdatedAt  *Timestamptz `json:"updated_at,omitempty"`
}

type FileAggregateOrderBy struct {
	Count *OrderBy        `json:"count,omitempty"`
	Max   *FileMaxOrderBy `json:"max,omitempty"`
	Min   *FileMinOrderBy `json:"min,omitempty"`
}

type FileAppendInput struct {
	CompileErrors *Jsonb `json:"compile_errors,omitempty"`
}

type FileArrRelInsertInput struct {
	Data       *[]FileInsertInput `json:"data,omitempty"`
	OnConflict *FileOnConflict    `json:"on_conflict,omitempty"`
}

type FileBoolExp struct {
	And           *[]FileBoolExp          `json:"_and,omitempty"`
	Not           *FileBoolExp            `json:"_not,omitempty"`
	Or            *[]FileBoolExp          `json:"_or,omitempty"`
	BaseFileId    *UuidComparisonExp      `json:"base_file_id,omitempty"`
	Branch        *BranchBoolExp          `json:"branch,omitempty"`
	BranchName    *StringComparisonExp    `json:"branch_name,omitempty"`
	CompileErrors *JsonbComparisonExp     `json:"compile_errors,omitempty"`
	Contents      *StringComparisonExp    `json:"contents,omitempty"`
	CreatedAt     *TimestampComparisonExp `json:"created_at,omitempty"`
	Dts           *StringComparisonExp    `json:"dts,omitempty"`
	Ext           *StringComparisonExp    `json:"ext,omitempty"`
	ID            *UuidComparisonExp      `json:"id,omitempty"`
	Js            *StringComparisonExp    `json:"js,omitempty"`
	Map           *StringComparisonExp    `json:"map,omitempty"`
	MarkDeleted   *BooleanComparisonExp   `json:"mark_deleted,omitempty"`
	Module        *ModuleBoolExp          `json:"module,omitempty"`
	ModuleName    *StringComparisonExp    `json:"module_name,omitempty"`
	ModuleScope   *StringComparisonExp    `json:"module_scope,omitempty"`
	ModuleVersion *StringComparisonExp    `json:"module_version,omitempty"`
	Path          *StringComparisonExp    `json:"path,omitempty"`
	Version       *ModuleVersionBoolExp   `json:"version,omitempty"`
}

type FileDeleteAtPathInput struct {
	CompileErrors *[]String `json:"compile_errors,omitempty"`
}

type FileDeleteElemInput struct {
	CompileErrors *Int `json:"compile_errors,omitempty"`
}

type FileDeleteKeyInput struct {
	CompileErrors *String `json:"compile_errors,omitempty"`
}

type FileInsertInput struct {
	BaseFileId    *UUID                           `json:"base_file_id,omitempty"`
	Branch        *BranchObjRelInsertInput        `json:"branch,omitempty"`
	BranchName    *String                         `json:"branch_name,omitempty"`
	CompileErrors *Jsonb                          `json:"compile_errors,omitempty"`
	Contents      *String                         `json:"contents,omitempty"`
	CreatedAt     *Timestamp                      `json:"created_at,omitempty"`
	Dts           *String                         `json:"dts,omitempty"`
	Ext           *String                         `json:"ext,omitempty"`
	ID            *UUID                           `json:"id,omitempty"`
	Js            *String                         `json:"js,omitempty"`
	Map           *String                         `json:"map,omitempty"`
	MarkDeleted   *Boolean                        `json:"mark_deleted,omitempty"`
	Module        *ModuleObjRelInsertInput        `json:"module,omitempty"`
	ModuleName    *String                         `json:"module_name,omitempty"`
	ModuleScope   *String                         `json:"module_scope,omitempty"`
	ModuleVersion *String                         `json:"module_version,omitempty"`
	Path          *String                         `json:"path,omitempty"`
	Version       *ModuleVersionObjRelInsertInput `json:"version,omitempty"`
}

type FileMaxOrderBy struct {
	BaseFileId    *OrderBy `json:"base_file_id,omitempty"`
	BranchName    *OrderBy `json:"branch_name,omitempty"`
	Contents      *OrderBy `json:"contents,omitempty"`
	CreatedAt     *OrderBy `json:"created_at,omitempty"`
	Dts           *OrderBy `json:"dts,omitempty"`
	Ext           *OrderBy `json:"ext,omitempty"`
	ID            *OrderBy `json:"id,omitempty"`
	Js            *OrderBy `json:"js,omitempty"`
	Map           *OrderBy `json:"map,omitempty"`
	ModuleName    *OrderBy `json:"module_name,omitempty"`
	ModuleScope   *OrderBy `json:"module_scope,omitempty"`
	ModuleVersion *OrderBy `json:"module_version,omitempty"`
	Path          *OrderBy `json:"path,omitempty"`
}

type FileMinOrderBy struct {
	BaseFileId    *OrderBy `json:"base_file_id,omitempty"`
	BranchName    *OrderBy `json:"branch_name,omitempty"`
	Contents      *OrderBy `json:"contents,omitempty"`
	CreatedAt     *OrderBy `json:"created_at,omitempty"`
	Dts           *OrderBy `json:"dts,omitempty"`
	Ext           *OrderBy `json:"ext,omitempty"`
	ID            *OrderBy `json:"id,omitempty"`
	Js            *OrderBy `json:"js,omitempty"`
	Map           *OrderBy `json:"map,omitempty"`
	ModuleName    *OrderBy `json:"module_name,omitempty"`
	ModuleScope   *OrderBy `json:"module_scope,omitempty"`
	ModuleVersion *OrderBy `json:"module_version,omitempty"`
	Path          *OrderBy `json:"path,omitempty"`
}

type FileObjRelInsertInput struct {
	Data       FileInsertInput `json:"data"`
	OnConflict *FileOnConflict `json:"on_conflict,omitempty"`
}

type FileOnConflict struct {
	Constraint    FileConstraint      `json:"constraint"`
	UpdateColumns *[]FileUpdateColumn `json:"update_columns,omitempty"`
	Where         *FileBoolExp        `json:"where,omitempty"`
}

type FileOrderBy struct {
	BaseFileId    *OrderBy              `json:"base_file_id,omitempty"`
	Branch        *BranchOrderBy        `json:"branch,omitempty"`
	BranchName    *OrderBy              `json:"branch_name,omitempty"`
	CompileErrors *OrderBy              `json:"compile_errors,omitempty"`
	Contents      *OrderBy              `json:"contents,omitempty"`
	CreatedAt     *OrderBy              `json:"created_at,omitempty"`
	Dts           *OrderBy              `json:"dts,omitempty"`
	Ext           *OrderBy              `json:"ext,omitempty"`
	ID            *OrderBy              `json:"id,omitempty"`
	Js            *OrderBy              `json:"js,omitempty"`
	Map           *OrderBy              `json:"map,omitempty"`
	MarkDeleted   *OrderBy              `json:"mark_deleted,omitempty"`
	Module        *ModuleOrderBy        `json:"module,omitempty"`
	ModuleName    *OrderBy              `json:"module_name,omitempty"`
	ModuleScope   *OrderBy              `json:"module_scope,omitempty"`
	ModuleVersion *OrderBy              `json:"module_version,omitempty"`
	Path          *OrderBy              `json:"path,omitempty"`
	Version       *ModuleVersionOrderBy `json:"version,omitempty"`
}

type FilePkColumnsInput struct {
	ID UUID `json:"id"`
}

type FilePrependInput struct {
	CompileErrors *Jsonb `json:"compile_errors,omitempty"`
}

type FileSetInput struct {
	BaseFileId    *UUID      `json:"base_file_id,omitempty"`
	BranchName    *String    `json:"branch_name,omitempty"`
	CompileErrors *Jsonb     `json:"compile_errors,omitempty"`
	Contents      *String    `json:"contents,omitempty"`
	CreatedAt     *Timestamp `json:"created_at,omitempty"`
	Dts           *String    `json:"dts,omitempty"`
	Ext           *String    `json:"ext,omitempty"`
	ID            *UUID      `json:"id,omitempty"`
	Js            *String    `json:"js,omitempty"`
	Map           *String    `json:"map,omitempty"`
	MarkDeleted   *Boolean   `json:"mark_deleted,omitempty"`
	ModuleName    *String    `json:"module_name,omitempty"`
	ModuleScope   *String    `json:"module_scope,omitempty"`
	ModuleVersion *String    `json:"module_version,omitempty"`
	Path          *String    `json:"path,omitempty"`
}

type JsonComparisonExp struct {
	Eq     *Json    `json:"_eq,omitempty"`
	Gt     *Json    `json:"_gt,omitempty"`
	Gte    *Json    `json:"_gte,omitempty"`
	In     *[]Json  `json:"_in,omitempty"`
	IsNull *Boolean `json:"_is_null,omitempty"`
	Lt     *Json    `json:"_lt,omitempty"`
	Lte    *Json    `json:"_lte,omitempty"`
	Neq    *Json    `json:"_neq,omitempty"`
	Nin    *[]Json  `json:"_nin,omitempty"`
}

type JsonbComparisonExp struct {
	ContainedIn *Jsonb    `json:"_contained_in,omitempty"`
	Contains    *Jsonb    `json:"_contains,omitempty"`
	Eq          *Jsonb    `json:"_eq,omitempty"`
	Gt          *Jsonb    `json:"_gt,omitempty"`
	Gte         *Jsonb    `json:"_gte,omitempty"`
	HasKey      *String   `json:"_has_key,omitempty"`
	HasKeysAll  *[]String `json:"_has_keys_all,omitempty"`
	HasKeysAny  *[]String `json:"_has_keys_any,omitempty"`
	In          *[]Jsonb  `json:"_in,omitempty"`
	IsNull      *Boolean  `json:"_is_null,omitempty"`
	Lt          *Jsonb    `json:"_lt,omitempty"`
	Lte         *Jsonb    `json:"_lte,omitempty"`
	Neq         *Jsonb    `json:"_neq,omitempty"`
	Nin         *[]Jsonb  `json:"_nin,omitempty"`
}

type ModuleAggregateOrderBy struct {
	Count *OrderBy          `json:"count,omitempty"`
	Max   *ModuleMaxOrderBy `json:"max,omitempty"`
	Min   *ModuleMinOrderBy `json:"min,omitempty"`
}

type ModuleArrRelInsertInput struct {
	Data       *[]ModuleInsertInput `json:"data,omitempty"`
	OnConflict *ModuleOnConflict    `json:"on_conflict,omitempty"`
}

type ModuleBoolExp struct {
	And        *[]ModuleBoolExp          `json:"_and,omitempty"`
	Not        *ModuleBoolExp            `json:"_not,omitempty"`
	Or         *[]ModuleBoolExp          `json:"_or,omitempty"`
	Branch     *BranchBoolExp            `json:"branch,omitempty"`
	BranchName *StringComparisonExp      `json:"branch_name,omitempty"`
	CreatedAt  *TimestamptzComparisonExp `json:"created_at,omitempty"`
	Files      *FileBoolExp              `json:"files,omitempty"`
	Name       *StringComparisonExp      `json:"name,omitempty"`
	Scope      *StringComparisonExp      `json:"scope,omitempty"`
	Versions   *ModuleVersionBoolExp     `json:"versions,omitempty"`
}

type ModuleInsertInput struct {
	Branch     *BranchObjRelInsertInput        `json:"branch,omitempty"`
	BranchName *String                         `json:"branch_name,omitempty"`
	CreatedAt  *Timestamptz                    `json:"created_at,omitempty"`
	Files      *FileArrRelInsertInput          `json:"files,omitempty"`
	Name       *String                         `json:"name,omitempty"`
	Scope      *String                         `json:"scope,omitempty"`
	Versions   *ModuleVersionArrRelInsertInput `json:"versions,omitempty"`
}

type ModuleMaxOrderBy struct {
	BranchName *OrderBy `json:"branch_name,omitempty"`
	CreatedAt  *OrderBy `json:"created_at,omitempty"`
	Name       *OrderBy `json:"name,omitempty"`
	Scope      *OrderBy `json:"scope,omitempty"`
}

type ModuleMinOrderBy struct {
	BranchName *OrderBy `json:"branch_name,omitempty"`
	CreatedAt  *OrderBy `json:"created_at,omitempty"`
	Name       *OrderBy `json:"name,omitempty"`
	Scope      *OrderBy `json:"scope,omitempty"`
}

type ModuleObjRelInsertInput struct {
	Data       ModuleInsertInput `json:"data"`
	OnConflict *ModuleOnConflict `json:"on_conflict,omitempty"`
}

type ModuleOnConflict struct {
	Constraint    ModuleConstraint      `json:"constraint"`
	UpdateColumns *[]ModuleUpdateColumn `json:"update_columns,omitempty"`
	Where         *ModuleBoolExp        `json:"where,omitempty"`
}

type ModuleOrderBy struct {
	Branch            *BranchOrderBy                 `json:"branch,omitempty"`
	BranchName        *OrderBy                       `json:"branch_name,omitempty"`
	CreatedAt         *OrderBy                       `json:"created_at,omitempty"`
	FilesAggregate    *FileAggregateOrderBy          `json:"files_aggregate,omitempty"`
	Name              *OrderBy                       `json:"name,omitempty"`
	Scope             *OrderBy                       `json:"scope,omitempty"`
	VersionsAggregate *ModuleVersionAggregateOrderBy `json:"versions_aggregate,omitempty"`
}

type ModulePkColumnsInput struct {
	BranchName String `json:"branch_name"`
	Name       String `json:"name"`
	Scope      String `json:"scope"`
}

type ModuleSetInput struct {
	BranchName *String      `json:"branch_name,omitempty"`
	CreatedAt  *Timestamptz `json:"created_at,omitempty"`
	Name       *String      `json:"name,omitempty"`
	Scope      *String      `json:"scope,omitempty"`
}

type ModuleVersionAggregateOrderBy struct {
	Count *OrderBy                 `json:"count,omitempty"`
	Max   *ModuleVersionMaxOrderBy `json:"max,omitempty"`
	Min   *ModuleVersionMinOrderBy `json:"min,omitempty"`
}

type ModuleVersionArrRelInsertInput struct {
	Data       *[]ModuleVersionInsertInput `json:"data,omitempty"`
	OnConflict *ModuleVersionOnConflict    `json:"on_conflict,omitempty"`
}

type ModuleVersionBoolExp struct {
	And         *[]ModuleVersionBoolExp   `json:"_and,omitempty"`
	Not         *ModuleVersionBoolExp     `json:"_not,omitempty"`
	Or          *[]ModuleVersionBoolExp   `json:"_or,omitempty"`
	Branch      *BranchBoolExp            `json:"branch,omitempty"`
	BranchName  *StringComparisonExp      `json:"branch_name,omitempty"`
	CreatedAt   *TimestamptzComparisonExp `json:"created_at,omitempty"`
	Files       *FileBoolExp              `json:"files,omitempty"`
	Module      *ModuleBoolExp            `json:"module,omitempty"`
	ModuleName  *StringComparisonExp      `json:"module_name,omitempty"`
	ModuleScope *StringComparisonExp      `json:"module_scope,omitempty"`
	Version     *StringComparisonExp      `json:"version,omitempty"`
}

type ModuleVersionInsertInput struct {
	Branch      *BranchObjRelInsertInput `json:"branch,omitempty"`
	BranchName  *String                  `json:"branch_name,omitempty"`
	CreatedAt   *Timestamptz             `json:"created_at,omitempty"`
	Files       *FileArrRelInsertInput   `json:"files,omitempty"`
	Module      *ModuleObjRelInsertInput `json:"module,omitempty"`
	ModuleName  *String                  `json:"module_name,omitempty"`
	ModuleScope *String                  `json:"module_scope,omitempty"`
	Version     *String                  `json:"version,omitempty"`
}

type ModuleVersionMaxOrderBy struct {
	BranchName  *OrderBy `json:"branch_name,omitempty"`
	CreatedAt   *OrderBy `json:"created_at,omitempty"`
	ModuleName  *OrderBy `json:"module_name,omitempty"`
	ModuleScope *OrderBy `json:"module_scope,omitempty"`
	Version     *OrderBy `json:"version,omitempty"`
}

type ModuleVersionMinOrderBy struct {
	BranchName  *OrderBy `json:"branch_name,omitempty"`
	CreatedAt   *OrderBy `json:"created_at,omitempty"`
	ModuleName  *OrderBy `json:"module_name,omitempty"`
	ModuleScope *OrderBy `json:"module_scope,omitempty"`
	Version     *OrderBy `json:"version,omitempty"`
}

type ModuleVersionObjRelInsertInput struct {
	Data       ModuleVersionInsertInput `json:"data"`
	OnConflict *ModuleVersionOnConflict `json:"on_conflict,omitempty"`
}

type ModuleVersionOnConflict struct {
	Constraint    ModuleVersionConstraint      `json:"constraint"`
	UpdateColumns *[]ModuleVersionUpdateColumn `json:"update_columns,omitempty"`
	Where         *ModuleVersionBoolExp        `json:"where,omitempty"`
}

type ModuleVersionOrderBy struct {
	Branch         *BranchOrderBy        `json:"branch,omitempty"`
	BranchName     *OrderBy              `json:"branch_name,omitempty"`
	CreatedAt      *OrderBy              `json:"created_at,omitempty"`
	FilesAggregate *FileAggregateOrderBy `json:"files_aggregate,omitempty"`
	Module         *ModuleOrderBy        `json:"module,omitempty"`
	ModuleName     *OrderBy              `json:"module_name,omitempty"`
	ModuleScope    *OrderBy              `json:"module_scope,omitempty"`
	Version        *OrderBy              `json:"version,omitempty"`
}

type ModuleVersionPkColumnsInput struct {
	BranchName  String `json:"branch_name"`
	ModuleName  String `json:"module_name"`
	ModuleScope String `json:"module_scope"`
	Version     String `json:"version"`
}

type ModuleVersionSetInput struct {
	BranchName  *String      `json:"branch_name,omitempty"`
	CreatedAt   *Timestamptz `json:"created_at,omitempty"`
	ModuleName  *String      `json:"module_name,omitempty"`
	ModuleScope *String      `json:"module_scope,omitempty"`
	Version     *String      `json:"version,omitempty"`
}

type TenantAggregateOrderBy struct {
	Count *OrderBy          `json:"count,omitempty"`
	Max   *TenantMaxOrderBy `json:"max,omitempty"`
	Min   *TenantMinOrderBy `json:"min,omitempty"`
}

type TenantArrRelInsertInput struct {
	Data       *[]TenantInsertInput `json:"data,omitempty"`
	OnConflict *TenantOnConflict    `json:"on_conflict,omitempty"`
}

type TenantBoolExp struct {
	And         *[]TenantBoolExp        `json:"_and,omitempty"`
	Not         *TenantBoolExp          `json:"_not,omitempty"`
	Or          *[]TenantBoolExp        `json:"_or,omitempty"`
	CreatedAt   *TimestampComparisonExp `json:"created_at,omitempty"`
	Credentials *CredentialBoolExp      `json:"credentials,omitempty"`
	Exporters   *ExporterBoolExp        `json:"exporters,omitempty"`
	Name        *StringComparisonExp    `json:"name,omitempty"`
	Type        *StringComparisonExp    `json:"type,omitempty"`
}

type TenantInsertInput struct {
	CreatedAt   *Timestamp                   `json:"created_at,omitempty"`
	Credentials *CredentialArrRelInsertInput `json:"credentials,omitempty"`
	Exporters   *ExporterArrRelInsertInput   `json:"exporters,omitempty"`
	Name        *String                      `json:"name,omitempty"`
	Type        *String                      `json:"type,omitempty"`
}

type TenantMaxOrderBy struct {
	CreatedAt *OrderBy `json:"created_at,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
	Type      *OrderBy `json:"type,omitempty"`
}

type TenantMinOrderBy struct {
	CreatedAt *OrderBy `json:"created_at,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
	Type      *OrderBy `json:"type,omitempty"`
}

type TenantObjRelInsertInput struct {
	Data       TenantInsertInput `json:"data"`
	OnConflict *TenantOnConflict `json:"on_conflict,omitempty"`
}

type TenantOnConflict struct {
	Constraint    TenantConstraint      `json:"constraint"`
	UpdateColumns *[]TenantUpdateColumn `json:"update_columns,omitempty"`
	Where         *TenantBoolExp        `json:"where,omitempty"`
}

type TenantOrderBy struct {
	CreatedAt            *OrderBy                    `json:"created_at,omitempty"`
	CredentialsAggregate *CredentialAggregateOrderBy `json:"credentials_aggregate,omitempty"`
	ExportersAggregate   *ExporterAggregateOrderBy   `json:"exporters_aggregate,omitempty"`
	Name                 *OrderBy                    `json:"name,omitempty"`
	Type                 *OrderBy                    `json:"type,omitempty"`
}

type TenantPkColumnsInput struct {
	Name String `json:"name"`
}

type TenantSetInput struct {
	CreatedAt *Timestamp `json:"created_at,omitempty"`
	Name      *String    `json:"name,omitempty"`
	Type      *String    `json:"type,omitempty"`
}

type TimestampComparisonExp struct {
	Eq     *Timestamp   `json:"_eq,omitempty"`
	Gt     *Timestamp   `json:"_gt,omitempty"`
	Gte    *Timestamp   `json:"_gte,omitempty"`
	In     *[]Timestamp `json:"_in,omitempty"`
	IsNull *Boolean     `json:"_is_null,omitempty"`
	Lt     *Timestamp   `json:"_lt,omitempty"`
	Lte    *Timestamp   `json:"_lte,omitempty"`
	Neq    *Timestamp   `json:"_neq,omitempty"`
	Nin    *[]Timestamp `json:"_nin,omitempty"`
}

type TimestamptzComparisonExp struct {
	Eq     *Timestamptz   `json:"_eq,omitempty"`
	Gt     *Timestamptz   `json:"_gt,omitempty"`
	Gte    *Timestamptz   `json:"_gte,omitempty"`
	In     *[]Timestamptz `json:"_in,omitempty"`
	IsNull *Boolean       `json:"_is_null,omitempty"`
	Lt     *Timestamptz   `json:"_lt,omitempty"`
	Lte    *Timestamptz   `json:"_lte,omitempty"`
	Neq    *Timestamptz   `json:"_neq,omitempty"`
	Nin    *[]Timestamptz `json:"_nin,omitempty"`
}

type UserAggregateOrderBy struct {
	Count *OrderBy        `json:"count,omitempty"`
	Max   *UserMaxOrderBy `json:"max,omitempty"`
	Min   *UserMinOrderBy `json:"min,omitempty"`
}

type UserArrRelInsertInput struct {
	Data       *[]UserInsertInput `json:"data,omitempty"`
	OnConflict *UserOnConflict    `json:"on_conflict,omitempty"`
}

type UserBoolExp struct {
	And                *[]UserBoolExp            `json:"_and,omitempty"`
	Not                *UserBoolExp              `json:"_not,omitempty"`
	Or                 *[]UserBoolExp            `json:"_or,omitempty"`
	Active             *BooleanComparisonExp     `json:"active,omitempty"`
	Avatar             *StringComparisonExp      `json:"avatar,omitempty"`
	CreatedAt          *TimestamptzComparisonExp `json:"created_at,omitempty"`
	Email              *StringComparisonExp      `json:"email,omitempty"`
	OpaqueId           *UuidComparisonExp        `json:"opaque_id,omitempty"`
	Preference         *UserPreferenceBoolExp    `json:"preference,omitempty"`
	Role               *StringComparisonExp      `json:"role,omitempty"`
	SessionLastUpdated *TimestamptzComparisonExp `json:"session_last_updated,omitempty"`
	UserPreferences    *UserPreferenceBoolExp    `json:"user_preferences,omitempty"`
	Username           *StringComparisonExp      `json:"username,omitempty"`
}

type UserInsertInput struct {
	Active             *Boolean                         `json:"active,omitempty"`
	Avatar             *String                          `json:"avatar,omitempty"`
	CreatedAt          *Timestamptz                     `json:"created_at,omitempty"`
	Email              *String                          `json:"email,omitempty"`
	OpaqueId           *UUID                            `json:"opaque_id,omitempty"`
	Preference         *UserPreferenceObjRelInsertInput `json:"preference,omitempty"`
	Role               *String                          `json:"role,omitempty"`
	SessionLastUpdated *Timestamptz                     `json:"session_last_updated,omitempty"`
	UserPreferences    *UserPreferenceArrRelInsertInput `json:"user_preferences,omitempty"`
	Username           *String                          `json:"username,omitempty"`
}

type UserMaxOrderBy struct {
	Avatar             *OrderBy `json:"avatar,omitempty"`
	CreatedAt          *OrderBy `json:"created_at,omitempty"`
	Email              *OrderBy `json:"email,omitempty"`
	OpaqueId           *OrderBy `json:"opaque_id,omitempty"`
	Role               *OrderBy `json:"role,omitempty"`
	SessionLastUpdated *OrderBy `json:"session_last_updated,omitempty"`
	Username           *OrderBy `json:"username,omitempty"`
}

type UserMinOrderBy struct {
	Avatar             *OrderBy `json:"avatar,omitempty"`
	CreatedAt          *OrderBy `json:"created_at,omitempty"`
	Email              *OrderBy `json:"email,omitempty"`
	OpaqueId           *OrderBy `json:"opaque_id,omitempty"`
	Role               *OrderBy `json:"role,omitempty"`
	SessionLastUpdated *OrderBy `json:"session_last_updated,omitempty"`
	Username           *OrderBy `json:"username,omitempty"`
}

type UserObjRelInsertInput struct {
	Data       UserInsertInput `json:"data"`
	OnConflict *UserOnConflict `json:"on_conflict,omitempty"`
}

type UserOnConflict struct {
	Constraint    UserConstraint      `json:"constraint"`
	UpdateColumns *[]UserUpdateColumn `json:"update_columns,omitempty"`
	Where         *UserBoolExp        `json:"where,omitempty"`
}

type UserOrderBy struct {
	Active                   *OrderBy                        `json:"active,omitempty"`
	Avatar                   *OrderBy                        `json:"avatar,omitempty"`
	CreatedAt                *OrderBy                        `json:"created_at,omitempty"`
	Email                    *OrderBy                        `json:"email,omitempty"`
	OpaqueId                 *OrderBy                        `json:"opaque_id,omitempty"`
	Preference               *UserPreferenceOrderBy          `json:"preference,omitempty"`
	Role                     *OrderBy                        `json:"role,omitempty"`
	SessionLastUpdated       *OrderBy                        `json:"session_last_updated,omitempty"`
	UserPreferencesAggregate *UserPreferenceAggregateOrderBy `json:"user_preferences_aggregate,omitempty"`
	Username                 *OrderBy                        `json:"username,omitempty"`
}

type UserPkColumnsInput struct {
	Email String `json:"email"`
}

type UserPreferenceAggregateOrderBy struct {
	Count *OrderBy                  `json:"count,omitempty"`
	Max   *UserPreferenceMaxOrderBy `json:"max,omitempty"`
	Min   *UserPreferenceMinOrderBy `json:"min,omitempty"`
}

type UserPreferenceArrRelInsertInput struct {
	Data       *[]UserPreferenceInsertInput `json:"data,omitempty"`
	OnConflict *UserPreferenceOnConflict    `json:"on_conflict,omitempty"`
}

type UserPreferenceBoolExp struct {
	And      *[]UserPreferenceBoolExp `json:"_and,omitempty"`
	Not      *UserPreferenceBoolExp   `json:"_not,omitempty"`
	Or       *[]UserPreferenceBoolExp `json:"_or,omitempty"`
	DarkMode *BooleanComparisonExp    `json:"dark_mode,omitempty"`
	Email    *StringComparisonExp     `json:"email,omitempty"`
	User     *UserBoolExp             `json:"user,omitempty"`
}

type UserPreferenceInsertInput struct {
	DarkMode *Boolean               `json:"dark_mode,omitempty"`
	Email    *String                `json:"email,omitempty"`
	User     *UserObjRelInsertInput `json:"user,omitempty"`
}

type UserPreferenceMaxOrderBy struct {
	Email *OrderBy `json:"email,omitempty"`
}

type UserPreferenceMinOrderBy struct {
	Email *OrderBy `json:"email,omitempty"`
}

type UserPreferenceObjRelInsertInput struct {
	Data       UserPreferenceInsertInput `json:"data"`
	OnConflict *UserPreferenceOnConflict `json:"on_conflict,omitempty"`
}

type UserPreferenceOnConflict struct {
	Constraint    UserPreferenceConstraint      `json:"constraint"`
	UpdateColumns *[]UserPreferenceUpdateColumn `json:"update_columns,omitempty"`
	Where         *UserPreferenceBoolExp        `json:"where,omitempty"`
}

type UserPreferenceOrderBy struct {
	DarkMode *OrderBy     `json:"dark_mode,omitempty"`
	Email    *OrderBy     `json:"email,omitempty"`
	User     *UserOrderBy `json:"user,omitempty"`
}

type UserPreferencePkColumnsInput struct {
	Email String `json:"email"`
}

type UserPreferenceSetInput struct {
	DarkMode *Boolean `json:"dark_mode,omitempty"`
	Email    *String  `json:"email,omitempty"`
}

type UserSetInput struct {
	Active             *Boolean     `json:"active,omitempty"`
	Avatar             *String      `json:"avatar,omitempty"`
	CreatedAt          *Timestamptz `json:"created_at,omitempty"`
	Email              *String      `json:"email,omitempty"`
	OpaqueId           *UUID        `json:"opaque_id,omitempty"`
	Role               *String      `json:"role,omitempty"`
	SessionLastUpdated *Timestamptz `json:"session_last_updated,omitempty"`
	Username           *String      `json:"username,omitempty"`
}

type UuidComparisonExp struct {
	Eq     *UUID    `json:"_eq,omitempty"`
	Gt     *UUID    `json:"_gt,omitempty"`
	Gte    *UUID    `json:"_gte,omitempty"`
	In     *[]UUID  `json:"_in,omitempty"`
	IsNull *Boolean `json:"_is_null,omitempty"`
	Lt     *UUID    `json:"_lt,omitempty"`
	Lte    *UUID    `json:"_lte,omitempty"`
	Neq    *UUID    `json:"_neq,omitempty"`
	Nin    *[]UUID  `json:"_nin,omitempty"`
}

//
// Objects
//

type Branch struct {
	CreatedAt         Timestamptz            `json:"created_at"`
	Files             *[]File                `json:"files,omitempty"`
	FilesAggregate    FileAggregate          `json:"files_aggregate"`
	HasMerged         Boolean                `json:"has_merged"`
	Modules           *[]Module              `json:"modules,omitempty"`
	ModulesAggregate  ModuleAggregate        `json:"modules_aggregate"`
	Name              String                 `json:"name"`
	Protected         Boolean                `json:"protected"`
	Versions          *[]ModuleVersion       `json:"versions,omitempty"`
	VersionsAggregate ModuleVersionAggregate `json:"versions_aggregate"`
}

type BranchAggregate struct {
	Aggregate *BranchAggregateFields `json:"aggregate,omitempty"`
	Nodes     *[]Branch              `json:"nodes,omitempty"`
}

type BranchAggregateFields struct {
	Count *Int             `json:"count,omitempty"`
	Max   *BranchMaxFields `json:"max,omitempty"`
	Min   *BranchMinFields `json:"min,omitempty"`
}

type BranchMaxFields struct {
	CreatedAt *Timestamptz `json:"created_at,omitempty"`
	Name      *String      `json:"name,omitempty"`
}

type BranchMinFields struct {
	CreatedAt *Timestamptz `json:"created_at,omitempty"`
	Name      *String      `json:"name,omitempty"`
}

type BranchMutationResponse struct {
	AffectedRows Int       `json:"affected_rows"`
	Returning    *[]Branch `json:"returning,omitempty"`
}

type Credential struct {
	CreatedAt          Timestamptz       `json:"created_at"`
	Exporters          *[]Exporter       `json:"exporters,omitempty"`
	ExportersAggregate ExporterAggregate `json:"exporters_aggregate"`
	Name               String            `json:"name"`
	Tenant             String            `json:"tenant"`
	TenantByTenant     Tenant            `json:"tenantByTenant"`
	Type               String            `json:"type"`
	UpdatedAt          Timestamptz       `json:"updated_at"`
	Value              Json              `json:"value"`
}

type CredentialAggregate struct {
	Aggregate *CredentialAggregateFields `json:"aggregate,omitempty"`
	Nodes     *[]Credential              `json:"nodes,omitempty"`
}

type CredentialAggregateFields struct {
	Count *Int                 `json:"count,omitempty"`
	Max   *CredentialMaxFields `json:"max,omitempty"`
	Min   *CredentialMinFields `json:"min,omitempty"`
}

type CredentialMaxFields struct {
	CreatedAt *Timestamptz `json:"created_at,omitempty"`
	Name      *String      `json:"name,omitempty"`
	Tenant    *String      `json:"tenant,omitempty"`
	Type      *String      `json:"type,omitempty"`
	UpdatedAt *Timestamptz `json:"updated_at,omitempty"`
}

type CredentialMinFields struct {
	CreatedAt *Timestamptz `json:"created_at,omitempty"`
	Name      *String      `json:"name,omitempty"`
	Tenant    *String      `json:"tenant,omitempty"`
	Type      *String      `json:"type,omitempty"`
	UpdatedAt *Timestamptz `json:"updated_at,omitempty"`
}

type CredentialMutationResponse struct {
	AffectedRows Int           `json:"affected_rows"`
	Returning    *[]Credential `json:"returning,omitempty"`
}

type Exporter struct {
	Config                       Json        `json:"config"`
	CreatedAt                    Timestamptz `json:"created_at"`
	Credential                   *String     `json:"credential,omitempty"`
	CredentialByCredentialTenant *Credential `json:"credentialByCredentialTenant,omitempty"`
	Name                         String      `json:"name"`
	Tenant                       String      `json:"tenant"`
	TenantByTenant               Tenant      `json:"tenantByTenant"`
	Type                         String      `json:"type"`
	UpdatedAt                    Timestamptz `json:"updated_at"`
}

type ExporterAggregate struct {
	Aggregate *ExporterAggregateFields `json:"aggregate,omitempty"`
	Nodes     *[]Exporter              `json:"nodes,omitempty"`
}

type ExporterAggregateFields struct {
	Count *Int               `json:"count,omitempty"`
	Max   *ExporterMaxFields `json:"max,omitempty"`
	Min   *ExporterMinFields `json:"min,omitempty"`
}

type ExporterMaxFields struct {
	CreatedAt  *Timestamptz `json:"created_at,omitempty"`
	Credential *String      `json:"credential,omitempty"`
	Name       *String      `json:"name,omitempty"`
	Tenant     *String      `json:"tenant,omitempty"`
	Type       *String      `json:"type,omitempty"`
	UpdatedAt  *Timestamptz `json:"updated_at,omitempty"`
}

type ExporterMinFields struct {
	CreatedAt  *Timestamptz `json:"created_at,omitempty"`
	Credential *String      `json:"credential,omitempty"`
	Name       *String      `json:"name,omitempty"`
	Tenant     *String      `json:"tenant,omitempty"`
	Type       *String      `json:"type,omitempty"`
	UpdatedAt  *Timestamptz `json:"updated_at,omitempty"`
}

type ExporterMutationResponse struct {
	AffectedRows Int         `json:"affected_rows"`
	Returning    *[]Exporter `json:"returning,omitempty"`
}

type File struct {
	BaseFileId    *UUID          `json:"base_file_id,omitempty"`
	Branch        Branch         `json:"branch"`
	BranchName    String         `json:"branch_name"`
	CompileErrors *Jsonb         `json:"compile_errors,omitempty"`
	Contents      String         `json:"contents"`
	CreatedAt     Timestamp      `json:"created_at"`
	Dts           *String        `json:"dts,omitempty"`
	Ext           String         `json:"ext"`
	ID            UUID           `json:"id"`
	Js            *String        `json:"js,omitempty"`
	Map           *String        `json:"map,omitempty"`
	MarkDeleted   Boolean        `json:"mark_deleted"`
	Module        *Module        `json:"module,omitempty"`
	ModuleName    String         `json:"module_name"`
	ModuleScope   String         `json:"module_scope"`
	ModuleVersion String         `json:"module_version"`
	Path          String         `json:"path"`
	Version       *ModuleVersion `json:"version,omitempty"`
}

type FileAggregate struct {
	Aggregate *FileAggregateFields `json:"aggregate,omitempty"`
	Nodes     *[]File              `json:"nodes,omitempty"`
}

type FileAggregateFields struct {
	Count *Int           `json:"count,omitempty"`
	Max   *FileMaxFields `json:"max,omitempty"`
	Min   *FileMinFields `json:"min,omitempty"`
}

type FileMaxFields struct {
	BaseFileId    *UUID      `json:"base_file_id,omitempty"`
	BranchName    *String    `json:"branch_name,omitempty"`
	Contents      *String    `json:"contents,omitempty"`
	CreatedAt     *Timestamp `json:"created_at,omitempty"`
	Dts           *String    `json:"dts,omitempty"`
	Ext           *String    `json:"ext,omitempty"`
	ID            *UUID      `json:"id,omitempty"`
	Js            *String    `json:"js,omitempty"`
	Map           *String    `json:"map,omitempty"`
	ModuleName    *String    `json:"module_name,omitempty"`
	ModuleScope   *String    `json:"module_scope,omitempty"`
	ModuleVersion *String    `json:"module_version,omitempty"`
	Path          *String    `json:"path,omitempty"`
}

type FileMinFields struct {
	BaseFileId    *UUID      `json:"base_file_id,omitempty"`
	BranchName    *String    `json:"branch_name,omitempty"`
	Contents      *String    `json:"contents,omitempty"`
	CreatedAt     *Timestamp `json:"created_at,omitempty"`
	Dts           *String    `json:"dts,omitempty"`
	Ext           *String    `json:"ext,omitempty"`
	ID            *UUID      `json:"id,omitempty"`
	Js            *String    `json:"js,omitempty"`
	Map           *String    `json:"map,omitempty"`
	ModuleName    *String    `json:"module_name,omitempty"`
	ModuleScope   *String    `json:"module_scope,omitempty"`
	ModuleVersion *String    `json:"module_version,omitempty"`
	Path          *String    `json:"path,omitempty"`
}

type FileMutationResponse struct {
	AffectedRows Int     `json:"affected_rows"`
	Returning    *[]File `json:"returning,omitempty"`
}

type Module struct {
	Branch            Branch                 `json:"branch"`
	BranchName        String                 `json:"branch_name"`
	CreatedAt         Timestamptz            `json:"created_at"`
	Files             *[]File                `json:"files,omitempty"`
	FilesAggregate    FileAggregate          `json:"files_aggregate"`
	Name              String                 `json:"name"`
	Scope             String                 `json:"scope"`
	Versions          *[]ModuleVersion       `json:"versions,omitempty"`
	VersionsAggregate ModuleVersionAggregate `json:"versions_aggregate"`
}

type ModuleAggregate struct {
	Aggregate *ModuleAggregateFields `json:"aggregate,omitempty"`
	Nodes     *[]Module              `json:"nodes,omitempty"`
}

type ModuleAggregateFields struct {
	Count *Int             `json:"count,omitempty"`
	Max   *ModuleMaxFields `json:"max,omitempty"`
	Min   *ModuleMinFields `json:"min,omitempty"`
}

type ModuleMaxFields struct {
	BranchName *String      `json:"branch_name,omitempty"`
	CreatedAt  *Timestamptz `json:"created_at,omitempty"`
	Name       *String      `json:"name,omitempty"`
	Scope      *String      `json:"scope,omitempty"`
}

type ModuleMinFields struct {
	BranchName *String      `json:"branch_name,omitempty"`
	CreatedAt  *Timestamptz `json:"created_at,omitempty"`
	Name       *String      `json:"name,omitempty"`
	Scope      *String      `json:"scope,omitempty"`
}

type ModuleMutationResponse struct {
	AffectedRows Int       `json:"affected_rows"`
	Returning    *[]Module `json:"returning,omitempty"`
}

type ModuleVersion struct {
	Branch         Branch        `json:"branch"`
	BranchName     String        `json:"branch_name"`
	CreatedAt      Timestamptz   `json:"created_at"`
	Files          *[]File       `json:"files,omitempty"`
	FilesAggregate FileAggregate `json:"files_aggregate"`
	Module         *Module       `json:"module,omitempty"`
	ModuleName     String        `json:"module_name"`
	ModuleScope    String        `json:"module_scope"`
	Version        String        `json:"version"`
}

type ModuleVersionAggregate struct {
	Aggregate *ModuleVersionAggregateFields `json:"aggregate,omitempty"`
	Nodes     *[]ModuleVersion              `json:"nodes,omitempty"`
}

type ModuleVersionAggregateFields struct {
	Count *Int                    `json:"count,omitempty"`
	Max   *ModuleVersionMaxFields `json:"max,omitempty"`
	Min   *ModuleVersionMinFields `json:"min,omitempty"`
}

type ModuleVersionMaxFields struct {
	BranchName  *String      `json:"branch_name,omitempty"`
	CreatedAt   *Timestamptz `json:"created_at,omitempty"`
	ModuleName  *String      `json:"module_name,omitempty"`
	ModuleScope *String      `json:"module_scope,omitempty"`
	Version     *String      `json:"version,omitempty"`
}

type ModuleVersionMinFields struct {
	BranchName  *String      `json:"branch_name,omitempty"`
	CreatedAt   *Timestamptz `json:"created_at,omitempty"`
	ModuleName  *String      `json:"module_name,omitempty"`
	ModuleScope *String      `json:"module_scope,omitempty"`
	Version     *String      `json:"version,omitempty"`
}

type ModuleVersionMutationResponse struct {
	AffectedRows Int              `json:"affected_rows"`
	Returning    *[]ModuleVersion `json:"returning,omitempty"`
}

type MutationRoot struct {
	DeleteBranch             *BranchMutationResponse         `json:"delete_branch,omitempty"`
	DeleteBranchByPk         *Branch                         `json:"delete_branch_by_pk,omitempty"`
	DeleteCredential         *CredentialMutationResponse     `json:"delete_credential,omitempty"`
	DeleteCredentialByPk     *Credential                     `json:"delete_credential_by_pk,omitempty"`
	DeleteExporter           *ExporterMutationResponse       `json:"delete_exporter,omitempty"`
	DeleteExporterByPk       *Exporter                       `json:"delete_exporter_by_pk,omitempty"`
	DeleteFile               *FileMutationResponse           `json:"delete_file,omitempty"`
	DeleteFileByPk           *File                           `json:"delete_file_by_pk,omitempty"`
	DeleteModule             *ModuleMutationResponse         `json:"delete_module,omitempty"`
	DeleteModuleByPk         *Module                         `json:"delete_module_by_pk,omitempty"`
	DeleteModuleVersion      *ModuleVersionMutationResponse  `json:"delete_module_version,omitempty"`
	DeleteModuleVersionByPk  *ModuleVersion                  `json:"delete_module_version_by_pk,omitempty"`
	DeleteTenant             *TenantMutationResponse         `json:"delete_tenant,omitempty"`
	DeleteTenantByPk         *Tenant                         `json:"delete_tenant_by_pk,omitempty"`
	DeleteUser               *UserMutationResponse           `json:"delete_user,omitempty"`
	DeleteUserByPk           *User                           `json:"delete_user_by_pk,omitempty"`
	DeleteUserPreference     *UserPreferenceMutationResponse `json:"delete_user_preference,omitempty"`
	DeleteUserPreferenceByPk *UserPreference                 `json:"delete_user_preference_by_pk,omitempty"`
	InsertBranch             *BranchMutationResponse         `json:"insert_branch,omitempty"`
	InsertBranchOne          *Branch                         `json:"insert_branch_one,omitempty"`
	InsertCredential         *CredentialMutationResponse     `json:"insert_credential,omitempty"`
	InsertCredentialOne      *Credential                     `json:"insert_credential_one,omitempty"`
	InsertExporter           *ExporterMutationResponse       `json:"insert_exporter,omitempty"`
	InsertExporterOne        *Exporter                       `json:"insert_exporter_one,omitempty"`
	InsertFile               *FileMutationResponse           `json:"insert_file,omitempty"`
	InsertFileOne            *File                           `json:"insert_file_one,omitempty"`
	InsertModule             *ModuleMutationResponse         `json:"insert_module,omitempty"`
	InsertModuleOne          *Module                         `json:"insert_module_one,omitempty"`
	InsertModuleVersion      *ModuleVersionMutationResponse  `json:"insert_module_version,omitempty"`
	InsertModuleVersionOne   *ModuleVersion                  `json:"insert_module_version_one,omitempty"`
	InsertTenant             *TenantMutationResponse         `json:"insert_tenant,omitempty"`
	InsertTenantOne          *Tenant                         `json:"insert_tenant_one,omitempty"`
	InsertUser               *UserMutationResponse           `json:"insert_user,omitempty"`
	InsertUserOne            *User                           `json:"insert_user_one,omitempty"`
	InsertUserPreference     *UserPreferenceMutationResponse `json:"insert_user_preference,omitempty"`
	InsertUserPreferenceOne  *UserPreference                 `json:"insert_user_preference_one,omitempty"`
	UpdateBranch             *BranchMutationResponse         `json:"update_branch,omitempty"`
	UpdateBranchByPk         *Branch                         `json:"update_branch_by_pk,omitempty"`
	UpdateCredential         *CredentialMutationResponse     `json:"update_credential,omitempty"`
	UpdateCredentialByPk     *Credential                     `json:"update_credential_by_pk,omitempty"`
	UpdateExporter           *ExporterMutationResponse       `json:"update_exporter,omitempty"`
	UpdateExporterByPk       *Exporter                       `json:"update_exporter_by_pk,omitempty"`
	UpdateFile               *FileMutationResponse           `json:"update_file,omitempty"`
	UpdateFileByPk           *File                           `json:"update_file_by_pk,omitempty"`
	UpdateModule             *ModuleMutationResponse         `json:"update_module,omitempty"`
	UpdateModuleByPk         *Module                         `json:"update_module_by_pk,omitempty"`
	UpdateModuleVersion      *ModuleVersionMutationResponse  `json:"update_module_version,omitempty"`
	UpdateModuleVersionByPk  *ModuleVersion                  `json:"update_module_version_by_pk,omitempty"`
	UpdateTenant             *TenantMutationResponse         `json:"update_tenant,omitempty"`
	UpdateTenantByPk         *Tenant                         `json:"update_tenant_by_pk,omitempty"`
	UpdateUser               *UserMutationResponse           `json:"update_user,omitempty"`
	UpdateUserByPk           *User                           `json:"update_user_by_pk,omitempty"`
	UpdateUserPreference     *UserPreferenceMutationResponse `json:"update_user_preference,omitempty"`
	UpdateUserPreferenceByPk *UserPreference                 `json:"update_user_preference_by_pk,omitempty"`
}

type QueryRoot struct {
	Branch                  *[]Branch               `json:"branch,omitempty"`
	BranchAggregate         BranchAggregate         `json:"branch_aggregate"`
	BranchByPk              *Branch                 `json:"branch_by_pk,omitempty"`
	Credential              *[]Credential           `json:"credential,omitempty"`
	CredentialAggregate     CredentialAggregate     `json:"credential_aggregate"`
	CredentialByPk          *Credential             `json:"credential_by_pk,omitempty"`
	Exporter                *[]Exporter             `json:"exporter,omitempty"`
	ExporterAggregate       ExporterAggregate       `json:"exporter_aggregate"`
	ExporterByPk            *Exporter               `json:"exporter_by_pk,omitempty"`
	File                    *[]File                 `json:"file,omitempty"`
	FileAggregate           FileAggregate           `json:"file_aggregate"`
	FileByPk                *File                   `json:"file_by_pk,omitempty"`
	Module                  *[]Module               `json:"module,omitempty"`
	ModuleAggregate         ModuleAggregate         `json:"module_aggregate"`
	ModuleByPk              *Module                 `json:"module_by_pk,omitempty"`
	ModuleVersion           *[]ModuleVersion        `json:"module_version,omitempty"`
	ModuleVersionAggregate  ModuleVersionAggregate  `json:"module_version_aggregate"`
	ModuleVersionByPk       *ModuleVersion          `json:"module_version_by_pk,omitempty"`
	Tenant                  *[]Tenant               `json:"tenant,omitempty"`
	TenantAggregate         TenantAggregate         `json:"tenant_aggregate"`
	TenantByPk              *Tenant                 `json:"tenant_by_pk,omitempty"`
	User                    *[]User                 `json:"user,omitempty"`
	UserAggregate           UserAggregate           `json:"user_aggregate"`
	UserByPk                *User                   `json:"user_by_pk,omitempty"`
	UserPreference          *[]UserPreference       `json:"user_preference,omitempty"`
	UserPreferenceAggregate UserPreferenceAggregate `json:"user_preference_aggregate"`
	UserPreferenceByPk      *UserPreference         `json:"user_preference_by_pk,omitempty"`
}

type SubscriptionRoot struct {
	Branch                  *[]Branch               `json:"branch,omitempty"`
	BranchAggregate         BranchAggregate         `json:"branch_aggregate"`
	BranchByPk              *Branch                 `json:"branch_by_pk,omitempty"`
	Credential              *[]Credential           `json:"credential,omitempty"`
	CredentialAggregate     CredentialAggregate     `json:"credential_aggregate"`
	CredentialByPk          *Credential             `json:"credential_by_pk,omitempty"`
	Exporter                *[]Exporter             `json:"exporter,omitempty"`
	ExporterAggregate       ExporterAggregate       `json:"exporter_aggregate"`
	ExporterByPk            *Exporter               `json:"exporter_by_pk,omitempty"`
	File                    *[]File                 `json:"file,omitempty"`
	FileAggregate           FileAggregate           `json:"file_aggregate"`
	FileByPk                *File                   `json:"file_by_pk,omitempty"`
	Module                  *[]Module               `json:"module,omitempty"`
	ModuleAggregate         ModuleAggregate         `json:"module_aggregate"`
	ModuleByPk              *Module                 `json:"module_by_pk,omitempty"`
	ModuleVersion           *[]ModuleVersion        `json:"module_version,omitempty"`
	ModuleVersionAggregate  ModuleVersionAggregate  `json:"module_version_aggregate"`
	ModuleVersionByPk       *ModuleVersion          `json:"module_version_by_pk,omitempty"`
	Tenant                  *[]Tenant               `json:"tenant,omitempty"`
	TenantAggregate         TenantAggregate         `json:"tenant_aggregate"`
	TenantByPk              *Tenant                 `json:"tenant_by_pk,omitempty"`
	User                    *[]User                 `json:"user,omitempty"`
	UserAggregate           UserAggregate           `json:"user_aggregate"`
	UserByPk                *User                   `json:"user_by_pk,omitempty"`
	UserPreference          *[]UserPreference       `json:"user_preference,omitempty"`
	UserPreferenceAggregate UserPreferenceAggregate `json:"user_preference_aggregate"`
	UserPreferenceByPk      *UserPreference         `json:"user_preference_by_pk,omitempty"`
}

type Tenant struct {
	CreatedAt            Timestamp           `json:"created_at"`
	Credentials          *[]Credential       `json:"credentials,omitempty"`
	CredentialsAggregate CredentialAggregate `json:"credentials_aggregate"`
	Exporters            *[]Exporter         `json:"exporters,omitempty"`
	ExportersAggregate   ExporterAggregate   `json:"exporters_aggregate"`
	Name                 String              `json:"name"`
	Type                 String              `json:"type"`
}

type TenantAggregate struct {
	Aggregate *TenantAggregateFields `json:"aggregate,omitempty"`
	Nodes     *[]Tenant              `json:"nodes,omitempty"`
}

type TenantAggregateFields struct {
	Count *Int             `json:"count,omitempty"`
	Max   *TenantMaxFields `json:"max,omitempty"`
	Min   *TenantMinFields `json:"min,omitempty"`
}

type TenantMaxFields struct {
	CreatedAt *Timestamp `json:"created_at,omitempty"`
	Name      *String    `json:"name,omitempty"`
	Type      *String    `json:"type,omitempty"`
}

type TenantMinFields struct {
	CreatedAt *Timestamp `json:"created_at,omitempty"`
	Name      *String    `json:"name,omitempty"`
	Type      *String    `json:"type,omitempty"`
}

type TenantMutationResponse struct {
	AffectedRows Int       `json:"affected_rows"`
	Returning    *[]Tenant `json:"returning,omitempty"`
}

type User struct {
	Active                   Boolean                 `json:"active"`
	Avatar                   *String                 `json:"avatar,omitempty"`
	CreatedAt                Timestamptz             `json:"created_at"`
	Email                    String                  `json:"email"`
	OpaqueId                 UUID                    `json:"opaque_id"`
	Preference               *UserPreference         `json:"preference,omitempty"`
	Role                     String                  `json:"role"`
	SessionLastUpdated       *Timestamptz            `json:"session_last_updated,omitempty"`
	UserPreferences          *[]UserPreference       `json:"user_preferences,omitempty"`
	UserPreferencesAggregate UserPreferenceAggregate `json:"user_preferences_aggregate"`
	Username                 String                  `json:"username"`
}

type UserAggregate struct {
	Aggregate *UserAggregateFields `json:"aggregate,omitempty"`
	Nodes     *[]User              `json:"nodes,omitempty"`
}

type UserAggregateFields struct {
	Count *Int           `json:"count,omitempty"`
	Max   *UserMaxFields `json:"max,omitempty"`
	Min   *UserMinFields `json:"min,omitempty"`
}

type UserMaxFields struct {
	Avatar             *String      `json:"avatar,omitempty"`
	CreatedAt          *Timestamptz `json:"created_at,omitempty"`
	Email              *String      `json:"email,omitempty"`
	OpaqueId           *UUID        `json:"opaque_id,omitempty"`
	Role               *String      `json:"role,omitempty"`
	SessionLastUpdated *Timestamptz `json:"session_last_updated,omitempty"`
	Username           *String      `json:"username,omitempty"`
}

type UserMinFields struct {
	Avatar             *String      `json:"avatar,omitempty"`
	CreatedAt          *Timestamptz `json:"created_at,omitempty"`
	Email              *String      `json:"email,omitempty"`
	OpaqueId           *UUID        `json:"opaque_id,omitempty"`
	Role               *String      `json:"role,omitempty"`
	SessionLastUpdated *Timestamptz `json:"session_last_updated,omitempty"`
	Username           *String      `json:"username,omitempty"`
}

type UserMutationResponse struct {
	AffectedRows Int     `json:"affected_rows"`
	Returning    *[]User `json:"returning,omitempty"`
}

type UserPreference struct {
	DarkMode Boolean `json:"dark_mode"`
	Email    String  `json:"email"`
	User     User    `json:"user"`
}

type UserPreferenceAggregate struct {
	Aggregate *UserPreferenceAggregateFields `json:"aggregate,omitempty"`
	Nodes     *[]UserPreference              `json:"nodes,omitempty"`
}

type UserPreferenceAggregateFields struct {
	Count *Int                     `json:"count,omitempty"`
	Max   *UserPreferenceMaxFields `json:"max,omitempty"`
	Min   *UserPreferenceMinFields `json:"min,omitempty"`
}

type UserPreferenceMaxFields struct {
	Email *String `json:"email,omitempty"`
}

type UserPreferenceMinFields struct {
	Email *String `json:"email,omitempty"`
}

type UserPreferenceMutationResponse struct {
	AffectedRows Int               `json:"affected_rows"`
	Returning    *[]UserPreference `json:"returning,omitempty"`
}
