package graphql

// Code generated by graphql-codegen-golang ; DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

type Client struct {
	*http.Client
	Url string
}

// NewClient creates a GraphQL client ready to use.
func NewClient(url string) *Client {
	return &Client{
		Client: &http.Client{},
		Url:    url,
	}
}

type GraphQLOperation struct {
	Query         string          `json:"query"`
	OperationName string          `json:"operationName,omitempty"`
	Variables     json.RawMessage `json:"variables,omitempty"`
}

type GraphQLResponse struct {
	Data   json.RawMessage `json:"data,omitempty"`
	Errors []GraphQLError  `json:"errors,omitempty"`
}

type GraphQLError map[string]interface{}

func (err GraphQLError) Error() string {
	return fmt.Sprintf("graphql: %v", map[string]interface{}(err))
}

func (resp *GraphQLResponse) Error() string {
	if len(resp.Errors) == 0 {
		return ""
	}
	errs := strings.Builder{}
	for _, err := range resp.Errors {
		errs.WriteString(err.Error())
		errs.WriteString("\n")
	}
	return errs.String()
}

func execute(client *http.Client, req *http.Request) (*GraphQLResponse, error) {
	if client == nil {
		client = http.DefaultClient
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, err
	}
	return unmarshalGraphQLReponse(body)
}

func unmarshalGraphQLReponse(b []byte) (*GraphQLResponse, error) {
	resp := GraphQLResponse{}
	if err := json.Unmarshal(b, &resp); err != nil {
		return nil, err
	}
	if len(resp.Errors) > 0 {
		return &resp, &resp
	}
	return &resp, nil
}

//
// mutation DeleteIntegration($tenant_id: uuid!, $id: uuid!)
//

type DeleteIntegrationVariables struct {
	TenantId UUID `json:"tenant_id"`
	ID       UUID `json:"id"`
}

type DeleteIntegrationResponse struct {
	DeleteIntegration struct {
		Returning []struct {
			ID string `json:"id"`
		} `json:"returning"`
	} `json:"delete_integration"`
}

type DeleteIntegrationRequest struct {
	*http.Request
}

func NewDeleteIntegrationRequest(url string, vars *DeleteIntegrationVariables) (*DeleteIntegrationRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation DeleteIntegration($tenant_id: uuid!, $id: uuid!) {
  delete_integration(where: {id: {_eq: $id}, tenant_id: {_eq: $tenant_id}}) {
    returning {
      id
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &DeleteIntegrationRequest{req}, nil
}

func (req *DeleteIntegrationRequest) Execute(client *http.Client) (*DeleteIntegrationResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result DeleteIntegrationResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func DeleteIntegration(url string, client *http.Client, vars *DeleteIntegrationVariables) (*DeleteIntegrationResponse, error) {
	req, err := NewDeleteIntegrationRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) DeleteIntegration(vars *DeleteIntegrationVariables) (*DeleteIntegrationResponse, error) {
	return DeleteIntegration(client.Url, client.Client, vars)
}

//
// query GetIntegration($tenant_id: uuid!, $name: String!)
//

type GetIntegrationVariables struct {
	TenantId UUID   `json:"tenant_id"`
	Name     String `json:"name"`
}

type GetIntegrationResponse struct {
	Integration []struct {
		ID        string `json:"id"`
		TenantId  string `json:"tenant_id"`
		Name      string `json:"name"`
		Kind      string `json:"kind"`
		Data      string `json:"data"`
		CreatedAt string `json:"created_at"`
		UpdatedAt string `json:"updated_at"`
	} `json:"integration"`
}

type GetIntegrationRequest struct {
	*http.Request
}

func NewGetIntegrationRequest(url string, vars *GetIntegrationVariables) (*GetIntegrationRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetIntegration($tenant_id: uuid!, $name: String!) {
  integration(where: {tenant_id: {_eq: $tenant_id}, name: {_eq: $name}}) {
    id
    tenant_id
    name
    kind
    data
    created_at
    updated_at
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetIntegrationRequest{req}, nil
}

func (req *GetIntegrationRequest) Execute(client *http.Client) (*GetIntegrationResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetIntegrationResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetIntegration(url string, client *http.Client, vars *GetIntegrationVariables) (*GetIntegrationResponse, error) {
	req, err := NewGetIntegrationRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetIntegration(vars *GetIntegrationVariables) (*GetIntegrationResponse, error) {
	return GetIntegration(client.Url, client.Client, vars)
}

//
// query GetIntegrations($tenant_id: uuid!)
//

type GetIntegrationsVariables struct {
	TenantId UUID `json:"tenant_id"`
}

type GetIntegrationsResponse struct {
	Integration []struct {
		ID        string `json:"id"`
		TenantId  string `json:"tenant_id"`
		Name      string `json:"name"`
		Kind      string `json:"kind"`
		Data      string `json:"data"`
		CreatedAt string `json:"created_at"`
		UpdatedAt string `json:"updated_at"`
	} `json:"integration"`
}

type GetIntegrationsRequest struct {
	*http.Request
}

func NewGetIntegrationsRequest(url string, vars *GetIntegrationsVariables) (*GetIntegrationsRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetIntegrations($tenant_id: uuid!) {
  integration(where: {tenant_id: {_eq: $tenant_id}}) {
    id
    tenant_id
    name
    kind
    data
    created_at
    updated_at
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetIntegrationsRequest{req}, nil
}

func (req *GetIntegrationsRequest) Execute(client *http.Client) (*GetIntegrationsResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetIntegrationsResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetIntegrations(url string, client *http.Client, vars *GetIntegrationsVariables) (*GetIntegrationsResponse, error) {
	req, err := NewGetIntegrationsRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetIntegrations(vars *GetIntegrationsVariables) (*GetIntegrationsResponse, error) {
	return GetIntegrations(client.Url, client.Client, vars)
}

//
// mutation InsertIntegration($name: String!, $kind: String!, $data: jsonb!, $tenant_id: uuid!)
//

type InsertIntegrationVariables struct {
	Name     String `json:"name"`
	Kind     String `json:"kind"`
	Data     Jsonb  `json:"data"`
	TenantId UUID   `json:"tenant_id"`
}

type InsertIntegrationResponse struct {
	InsertIntegrationOne struct {
		ID              string `json:"id"`
		Kind            string `json:"kind"`
		Name            string `json:"name"`
		Data            string `json:"data"`
		TenantId        string `json:"tenant_id"`
		GrafanaMetadata string `json:"grafana_metadata"`
		CreatedAt       string `json:"created_at"`
		UpdatedAt       string `json:"updated_at"`
	} `json:"insert_integration_one"`
}

type InsertIntegrationRequest struct {
	*http.Request
}

func NewInsertIntegrationRequest(url string, vars *InsertIntegrationVariables) (*InsertIntegrationRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation InsertIntegration($name: String!, $kind: String!, $data: jsonb!, $tenant_id: uuid!) {
  insert_integration_one(object: {name: $name, kind: $kind, data: $data, tenant_id: $tenant_id}) {
    id
    kind
    name
    data
    tenant_id
    grafana_metadata
    created_at
    updated_at
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &InsertIntegrationRequest{req}, nil
}

func (req *InsertIntegrationRequest) Execute(client *http.Client) (*InsertIntegrationResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result InsertIntegrationResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func InsertIntegration(url string, client *http.Client, vars *InsertIntegrationVariables) (*InsertIntegrationResponse, error) {
	req, err := NewInsertIntegrationRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) InsertIntegration(vars *InsertIntegrationVariables) (*InsertIntegrationResponse, error) {
	return InsertIntegration(client.Url, client.Client, vars)
}

//
// mutation InsertIntegrations($integrations: [integration_insert_input!]!)
//

type InsertIntegrationsVariables struct {
	Integrations *[]IntegrationInsertInput `json:"integrations,omitempty"`
}

type InsertIntegrationsResponse struct {
	InsertIntegration struct {
		Returning []struct {
			TenantId string `json:"tenant_id"`
			ID       string `json:"id"`
			Name     string `json:"name"`
		} `json:"returning"`
	} `json:"insert_integration"`
}

type InsertIntegrationsRequest struct {
	*http.Request
}

func NewInsertIntegrationsRequest(url string, vars *InsertIntegrationsVariables) (*InsertIntegrationsRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation InsertIntegrations($integrations: [integration_insert_input!]!) {
  insert_integration(objects: $integrations) {
    returning {
      tenant_id
      id
      name
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &InsertIntegrationsRequest{req}, nil
}

func (req *InsertIntegrationsRequest) Execute(client *http.Client) (*InsertIntegrationsResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result InsertIntegrationsResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func InsertIntegrations(url string, client *http.Client, vars *InsertIntegrationsVariables) (*InsertIntegrationsResponse, error) {
	req, err := NewInsertIntegrationsRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) InsertIntegrations(vars *InsertIntegrationsVariables) (*InsertIntegrationsResponse, error) {
	return InsertIntegrations(client.Url, client.Client, vars)
}

//
// mutation UpdateIntegrationData($id: uuid!, $data: jsonb!)
//

type UpdateIntegrationDataVariables struct {
	ID   UUID  `json:"id"`
	Data Jsonb `json:"data"`
}

type UpdateIntegrationDataResponse struct {
	UpdateIntegrationByPk struct {
		ID        string `json:"id"`
		Data      string `json:"data"`
		UpdatedAt string `json:"updated_at"`
	} `json:"update_integration_by_pk"`
}

type UpdateIntegrationDataRequest struct {
	*http.Request
}

func NewUpdateIntegrationDataRequest(url string, vars *UpdateIntegrationDataVariables) (*UpdateIntegrationDataRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation UpdateIntegrationData($id: uuid!, $data: jsonb!) {
  update_integration_by_pk(pk_columns: {id: $id}, _set: {data: $data}) {
    id
    data
    updated_at
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &UpdateIntegrationDataRequest{req}, nil
}

func (req *UpdateIntegrationDataRequest) Execute(client *http.Client) (*UpdateIntegrationDataResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result UpdateIntegrationDataResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func UpdateIntegrationData(url string, client *http.Client, vars *UpdateIntegrationDataVariables) (*UpdateIntegrationDataResponse, error) {
	req, err := NewUpdateIntegrationDataRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) UpdateIntegrationData(vars *UpdateIntegrationDataVariables) (*UpdateIntegrationDataResponse, error) {
	return UpdateIntegrationData(client.Url, client.Client, vars)
}

//
// mutation UpdateIntegrationGrafanaMetadata($id: uuid!, $grafana_metadata: jsonb!)
//

type UpdateIntegrationGrafanaMetadataVariables struct {
	ID              UUID  `json:"id"`
	GrafanaMetadata Jsonb `json:"grafana_metadata"`
}

type UpdateIntegrationGrafanaMetadataResponse struct {
	UpdateIntegrationByPk struct {
		ID              string `json:"id"`
		GrafanaMetadata string `json:"grafana_metadata"`
		UpdatedAt       string `json:"updated_at"`
	} `json:"update_integration_by_pk"`
}

type UpdateIntegrationGrafanaMetadataRequest struct {
	*http.Request
}

func NewUpdateIntegrationGrafanaMetadataRequest(url string, vars *UpdateIntegrationGrafanaMetadataVariables) (*UpdateIntegrationGrafanaMetadataRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation UpdateIntegrationGrafanaMetadata($id: uuid!, $grafana_metadata: jsonb!) {
  update_integration_by_pk(pk_columns: {id: $id}, _set: {grafana_metadata: $grafana_metadata}) {
    id
    grafana_metadata
    updated_at
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &UpdateIntegrationGrafanaMetadataRequest{req}, nil
}

func (req *UpdateIntegrationGrafanaMetadataRequest) Execute(client *http.Client) (*UpdateIntegrationGrafanaMetadataResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result UpdateIntegrationGrafanaMetadataResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func UpdateIntegrationGrafanaMetadata(url string, client *http.Client, vars *UpdateIntegrationGrafanaMetadataVariables) (*UpdateIntegrationGrafanaMetadataResponse, error) {
	req, err := NewUpdateIntegrationGrafanaMetadataRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) UpdateIntegrationGrafanaMetadata(vars *UpdateIntegrationGrafanaMetadataVariables) (*UpdateIntegrationGrafanaMetadataResponse, error) {
	return UpdateIntegrationGrafanaMetadata(client.Url, client.Client, vars)
}

//
// mutation UpdateIntegrationName($id: uuid!, $name: String!)
//

type UpdateIntegrationNameVariables struct {
	ID   UUID   `json:"id"`
	Name String `json:"name"`
}

type UpdateIntegrationNameResponse struct {
	UpdateIntegrationByPk struct {
		ID        string `json:"id"`
		Name      string `json:"name"`
		UpdatedAt string `json:"updated_at"`
	} `json:"update_integration_by_pk"`
}

type UpdateIntegrationNameRequest struct {
	*http.Request
}

func NewUpdateIntegrationNameRequest(url string, vars *UpdateIntegrationNameVariables) (*UpdateIntegrationNameRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation UpdateIntegrationName($id: uuid!, $name: String!) {
  update_integration_by_pk(pk_columns: {id: $id}, _set: {name: $name}) {
    id
    name
    updated_at
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &UpdateIntegrationNameRequest{req}, nil
}

func (req *UpdateIntegrationNameRequest) Execute(client *http.Client) (*UpdateIntegrationNameResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result UpdateIntegrationNameResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func UpdateIntegrationName(url string, client *http.Client, vars *UpdateIntegrationNameVariables) (*UpdateIntegrationNameResponse, error) {
	req, err := NewUpdateIntegrationNameRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) UpdateIntegrationName(vars *UpdateIntegrationNameVariables) (*UpdateIntegrationNameResponse, error) {
	return UpdateIntegrationName(client.Url, client.Client, vars)
}

//
// mutation CreateTenants($tenants: [tenant_insert_input!]!)
//

type CreateTenantsVariables struct {
	Tenants *[]TenantInsertInput `json:"tenants,omitempty"`
}

type CreateTenantsResponse struct {
	InsertTenant struct {
		Returning []struct {
			Name string `json:"name"`
		} `json:"returning"`
	} `json:"insert_tenant"`
}

type CreateTenantsRequest struct {
	*http.Request
}

func NewCreateTenantsRequest(url string, vars *CreateTenantsVariables) (*CreateTenantsRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation CreateTenants($tenants: [tenant_insert_input!]!) {
  insert_tenant(objects: $tenants) {
    returning {
      name
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &CreateTenantsRequest{req}, nil
}

func (req *CreateTenantsRequest) Execute(client *http.Client) (*CreateTenantsResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result CreateTenantsResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func CreateTenants(url string, client *http.Client, vars *CreateTenantsVariables) (*CreateTenantsResponse, error) {
	req, err := NewCreateTenantsRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) CreateTenants(vars *CreateTenantsVariables) (*CreateTenantsResponse, error) {
	return CreateTenants(client.Url, client.Client, vars)
}

//
// mutation DeleteTenant($name: String!)
//

type DeleteTenantVariables struct {
	Name String `json:"name"`
}

type DeleteTenantResponse struct {
	DeleteTenantByPk struct {
		Name string `json:"name"`
	} `json:"delete_tenant_by_pk"`
}

type DeleteTenantRequest struct {
	*http.Request
}

func NewDeleteTenantRequest(url string, vars *DeleteTenantVariables) (*DeleteTenantRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation DeleteTenant($name: String!) {
  delete_tenant_by_pk(name: $name) {
    name
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &DeleteTenantRequest{req}, nil
}

func (req *DeleteTenantRequest) Execute(client *http.Client) (*DeleteTenantResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result DeleteTenantResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func DeleteTenant(url string, client *http.Client, vars *DeleteTenantVariables) (*DeleteTenantResponse, error) {
	req, err := NewDeleteTenantRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) DeleteTenant(vars *DeleteTenantVariables) (*DeleteTenantResponse, error) {
	return DeleteTenant(client.Url, client.Client, vars)
}

//
// query GetAlertmanager($tenant_id: String!)
//

type GetAlertmanagerVariables struct {
	TenantId String `json:"tenant_id"`
}

type GetAlertmanagerResponse struct {
	GetAlertmanager struct {
		Config string `json:"config"`
		Online string `json:"online"`
	} `json:"getAlertmanager"`
}

type GetAlertmanagerRequest struct {
	*http.Request
}

func NewGetAlertmanagerRequest(url string, vars *GetAlertmanagerVariables) (*GetAlertmanagerRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetAlertmanager($tenant_id: String!) {
  getAlertmanager(tenant_id: $tenant_id) {
    config
    online
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetAlertmanagerRequest{req}, nil
}

func (req *GetAlertmanagerRequest) Execute(client *http.Client) (*GetAlertmanagerResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetAlertmanagerResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetAlertmanager(url string, client *http.Client, vars *GetAlertmanagerVariables) (*GetAlertmanagerResponse, error) {
	req, err := NewGetAlertmanagerRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetAlertmanager(vars *GetAlertmanagerVariables) (*GetAlertmanagerResponse, error) {
	return GetAlertmanager(client.Url, client.Client, vars)
}

//
// query GetTenants
//

type GetTenantsResponse struct {
	Tenant []struct {
		ID        string `json:"id"`
		Name      string `json:"name"`
		CreatedAt string `json:"created_at"`
		UpdatedAt string `json:"updated_at"`
		Type      string `json:"type"`
		Key       string `json:"key"`
	} `json:"tenant"`
}

type GetTenantsRequest struct {
	*http.Request
}

func NewGetTenantsRequest(url string) (*GetTenantsRequest, error) {
	b, err := json.Marshal(&GraphQLOperation{
		Query: `query GetTenants {
  tenant {
    id
    name
    created_at
    updated_at
    type
    key
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetTenantsRequest{req}, nil
}

func (req *GetTenantsRequest) Execute(client *http.Client) (*GetTenantsResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetTenantsResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetTenants(url string, client *http.Client) (*GetTenantsResponse, error) {
	req, err := NewGetTenantsRequest(url)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetTenants() (*GetTenantsResponse, error) {
	return GetTenants(client.Url, client.Client)
}

//
// mutation UpdateAlertmanager($tenant_id: String!, $input: AlertmanagerInput!)
//

type UpdateAlertmanagerVariables struct {
	TenantId String            `json:"tenant_id"`
	Input    AlertmanagerInput `json:"input"`
}

type UpdateAlertmanagerResponse struct {
	UpdateAlertmanager struct {
		Success          string `json:"success"`
		ErrorType        string `json:"error_type"`
		ErrorMessage     string `json:"error_message"`
		ErrorRawResponse string `json:"error_raw_response"`
	} `json:"updateAlertmanager"`
}

type UpdateAlertmanagerRequest struct {
	*http.Request
}

func NewUpdateAlertmanagerRequest(url string, vars *UpdateAlertmanagerVariables) (*UpdateAlertmanagerRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation UpdateAlertmanager($tenant_id: String!, $input: AlertmanagerInput!) {
  updateAlertmanager(tenant_id: $tenant_id, input: $input) {
    success
    error_type
    error_message
    error_raw_response
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &UpdateAlertmanagerRequest{req}, nil
}

func (req *UpdateAlertmanagerRequest) Execute(client *http.Client) (*UpdateAlertmanagerResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result UpdateAlertmanagerResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func UpdateAlertmanager(url string, client *http.Client, vars *UpdateAlertmanagerVariables) (*UpdateAlertmanagerResponse, error) {
	req, err := NewUpdateAlertmanagerRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) UpdateAlertmanager(vars *UpdateAlertmanagerVariables) (*UpdateAlertmanagerResponse, error) {
	return UpdateAlertmanager(client.Url, client.Client, vars)
}

//
// mutation CreateUser($email: String!, $username: String!, $avatar: String!)
//

type CreateUserVariables struct {
	Email    String `json:"email"`
	Username String `json:"username"`
	Avatar   String `json:"avatar"`
}

type CreateUserResponse struct {
	InsertUserPreferenceOne struct {
		User struct {
			ID                 string `json:"id"`
			Email              string `json:"email"`
			Username           string `json:"username"`
			Role               string `json:"role"`
			Active             string `json:"active"`
			Avatar             string `json:"avatar"`
			CreatedAt          string `json:"created_at"`
			SessionLastUpdated string `json:"session_last_updated"`
		} `json:"user"`
	} `json:"insert_user_preference_one"`
}

type CreateUserRequest struct {
	*http.Request
}

func NewCreateUserRequest(url string, vars *CreateUserVariables) (*CreateUserRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation CreateUser($email: String!, $username: String!, $avatar: String!) {
  insert_user_preference_one(object: {dark_mode: false, user: {data: {email: $email, username: $username, active: true, avatar: $avatar}}}) {
    user {
      id
      email
      username
      role
      active
      avatar
      created_at
      session_last_updated
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &CreateUserRequest{req}, nil
}

func (req *CreateUserRequest) Execute(client *http.Client) (*CreateUserResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result CreateUserResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func CreateUser(url string, client *http.Client, vars *CreateUserVariables) (*CreateUserResponse, error) {
	req, err := NewCreateUserRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) CreateUser(vars *CreateUserVariables) (*CreateUserResponse, error) {
	return CreateUser(client.Url, client.Client, vars)
}

//
// mutation DeactivateUser($id: uuid!)
//

type DeactivateUserVariables struct {
	ID UUID `json:"id"`
}

type DeactivateUserResponse struct {
	UpdateUserByPk struct {
		ID     string `json:"id"`
		Active string `json:"active"`
	} `json:"update_user_by_pk"`
}

type DeactivateUserRequest struct {
	*http.Request
}

func NewDeactivateUserRequest(url string, vars *DeactivateUserVariables) (*DeactivateUserRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation DeactivateUser($id: uuid!) {
  update_user_by_pk(_set: {active: false}, pk_columns: {id: $id}) {
    id
    active
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &DeactivateUserRequest{req}, nil
}

func (req *DeactivateUserRequest) Execute(client *http.Client) (*DeactivateUserResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result DeactivateUserResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func DeactivateUser(url string, client *http.Client, vars *DeactivateUserVariables) (*DeactivateUserResponse, error) {
	req, err := NewDeactivateUserRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) DeactivateUser(vars *DeactivateUserVariables) (*DeactivateUserResponse, error) {
	return DeactivateUser(client.Url, client.Client, vars)
}

//
// query GetActiveUserForAuth($email: String!)
//

type GetActiveUserForAuthVariables struct {
	Email String `json:"email"`
}

type GetActiveUserForAuthResponse struct {
	User []struct {
		ID       string `json:"id"`
		Email    string `json:"email"`
		Avatar   string `json:"avatar"`
		Username string `json:"username"`
		Active   string `json:"active"`
	} `json:"user"`
	UserAggregate struct {
		Aggregate struct {
			Count string `json:"count"`
		} `json:"aggregate"`
	} `json:"user_aggregate"`
}

type GetActiveUserForAuthRequest struct {
	*http.Request
}

func NewGetActiveUserForAuthRequest(url string, vars *GetActiveUserForAuthVariables) (*GetActiveUserForAuthRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetActiveUserForAuth($email: String!) {
  user(where: {email: {_eq: $email}, active: {_eq: true}}, limit: 1, order_by: {created_at: asc}) {
    id
    email
    avatar
    username
    active
  }
  active_user_count: user_aggregate(where: {active: {_eq: true}}) {
    aggregate {
      count
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetActiveUserForAuthRequest{req}, nil
}

func (req *GetActiveUserForAuthRequest) Execute(client *http.Client) (*GetActiveUserForAuthResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetActiveUserForAuthResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetActiveUserForAuth(url string, client *http.Client, vars *GetActiveUserForAuthVariables) (*GetActiveUserForAuthResponse, error) {
	req, err := NewGetActiveUserForAuthRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetActiveUserForAuth(vars *GetActiveUserForAuthVariables) (*GetActiveUserForAuthResponse, error) {
	return GetActiveUserForAuth(client.Url, client.Client, vars)
}

//
// query GetCurrentUser
//

type GetCurrentUserResponse struct {
	User []struct {
		ID         string `json:"id"`
		Email      string `json:"email"`
		Avatar     string `json:"avatar"`
		Username   string `json:"username"`
		Active     string `json:"active"`
		Preference struct {
			DarkMode string `json:"dark_mode"`
		} `json:"preference"`
	} `json:"user"`
}

type GetCurrentUserRequest struct {
	*http.Request
}

func NewGetCurrentUserRequest(url string) (*GetCurrentUserRequest, error) {
	b, err := json.Marshal(&GraphQLOperation{
		Query: `query GetCurrentUser {
  user {
    id
    email
    avatar
    username
    active
    preference {
      dark_mode
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetCurrentUserRequest{req}, nil
}

func (req *GetCurrentUserRequest) Execute(client *http.Client) (*GetCurrentUserResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetCurrentUserResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetCurrentUser(url string, client *http.Client) (*GetCurrentUserResponse, error) {
	req, err := NewGetCurrentUserRequest(url)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetCurrentUser() (*GetCurrentUserResponse, error) {
	return GetCurrentUser(client.Url, client.Client)
}

//
// query GetUser($id: uuid!)
//

type GetUserVariables struct {
	ID UUID `json:"id"`
}

type GetUserResponse struct {
	UserByPk struct {
		ID         string `json:"id"`
		Email      string `json:"email"`
		Avatar     string `json:"avatar"`
		Username   string `json:"username"`
		Active     string `json:"active"`
		Preference struct {
			DarkMode string `json:"dark_mode"`
		} `json:"preference"`
	} `json:"user_by_pk"`
}

type GetUserRequest struct {
	*http.Request
}

func NewGetUserRequest(url string, vars *GetUserVariables) (*GetUserRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `query GetUser($id: uuid!) {
  user_by_pk(id: $id) {
    id
    email
    avatar
    username
    active
    preference {
      dark_mode
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &GetUserRequest{req}, nil
}

func (req *GetUserRequest) Execute(client *http.Client) (*GetUserResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result GetUserResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func GetUser(url string, client *http.Client, vars *GetUserVariables) (*GetUserResponse, error) {
	req, err := NewGetUserRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) GetUser(vars *GetUserVariables) (*GetUserResponse, error) {
	return GetUser(client.Url, client.Client, vars)
}

//
// mutation ReactivateUser($id: uuid!)
//

type ReactivateUserVariables struct {
	ID UUID `json:"id"`
}

type ReactivateUserResponse struct {
	UpdateUserByPk struct {
		ID     string `json:"id"`
		Active string `json:"active"`
	} `json:"update_user_by_pk"`
}

type ReactivateUserRequest struct {
	*http.Request
}

func NewReactivateUserRequest(url string, vars *ReactivateUserVariables) (*ReactivateUserRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation ReactivateUser($id: uuid!) {
  update_user_by_pk(pk_columns: {id: $id}, _set: {active: true}) {
    id
    active
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &ReactivateUserRequest{req}, nil
}

func (req *ReactivateUserRequest) Execute(client *http.Client) (*ReactivateUserResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result ReactivateUserResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func ReactivateUser(url string, client *http.Client, vars *ReactivateUserVariables) (*ReactivateUserResponse, error) {
	req, err := NewReactivateUserRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) ReactivateUser(vars *ReactivateUserVariables) (*ReactivateUserResponse, error) {
	return ReactivateUser(client.Url, client.Client, vars)
}

//
// mutation SetDarkMode($user_id: uuid!, $dark_mode: Boolean = true)
//

type SetDarkModeVariables struct {
	UserId   UUID     `json:"user_id"`
	DarkMode *Boolean `json:"dark_mode,omitempty"`
}

type SetDarkModeResponse struct {
	UpdateUserPreference struct {
		Returning []struct {
			DarkMode string `json:"dark_mode"`
		} `json:"returning"`
	} `json:"update_user_preference"`
}

type SetDarkModeRequest struct {
	*http.Request
}

func NewSetDarkModeRequest(url string, vars *SetDarkModeVariables) (*SetDarkModeRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation SetDarkMode($user_id: uuid!, $dark_mode: Boolean = true) {
  update_user_preference(where: {user_id: {_eq: $user_id}}, _set: {dark_mode: $dark_mode}) {
    returning {
      dark_mode
    }
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &SetDarkModeRequest{req}, nil
}

func (req *SetDarkModeRequest) Execute(client *http.Client) (*SetDarkModeResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result SetDarkModeResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func SetDarkMode(url string, client *http.Client, vars *SetDarkModeVariables) (*SetDarkModeResponse, error) {
	req, err := NewSetDarkModeRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) SetDarkMode(vars *SetDarkModeVariables) (*SetDarkModeResponse, error) {
	return SetDarkMode(client.Url, client.Client, vars)
}

//
// mutation UpdateUser($id: uuid!, $email: String!, $avatar: String!, $username: String!)
//

type UpdateUserVariables struct {
	ID       UUID   `json:"id"`
	Email    String `json:"email"`
	Avatar   String `json:"avatar"`
	Username String `json:"username"`
}

type UpdateUserResponse struct {
	UpdateUserByPk struct {
		ID                 string `json:"id"`
		Email              string `json:"email"`
		Username           string `json:"username"`
		Avatar             string `json:"avatar"`
		SessionLastUpdated string `json:"session_last_updated"`
	} `json:"update_user_by_pk"`
}

type UpdateUserRequest struct {
	*http.Request
}

func NewUpdateUserRequest(url string, vars *UpdateUserVariables) (*UpdateUserRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation UpdateUser($id: uuid!, $email: String!, $avatar: String!, $username: String!) {
  update_user_by_pk(pk_columns: {id: $id}, _set: {email: $email, avatar: $avatar, username: $username}) {
    id
    email
    username
    avatar
    session_last_updated
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &UpdateUserRequest{req}, nil
}

func (req *UpdateUserRequest) Execute(client *http.Client) (*UpdateUserResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result UpdateUserResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func UpdateUser(url string, client *http.Client, vars *UpdateUserVariables) (*UpdateUserResponse, error) {
	req, err := NewUpdateUserRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) UpdateUser(vars *UpdateUserVariables) (*UpdateUserResponse, error) {
	return UpdateUser(client.Url, client.Client, vars)
}

//
// mutation UpdateUserSession($id: uuid!, $timestamp: timestamptz!)
//

type UpdateUserSessionVariables struct {
	ID        UUID        `json:"id"`
	Timestamp Timestamptz `json:"timestamp"`
}

type UpdateUserSessionResponse struct {
	UpdateUserByPk struct {
		ID                 string `json:"id"`
		SessionLastUpdated string `json:"session_last_updated"`
	} `json:"update_user_by_pk"`
}

type UpdateUserSessionRequest struct {
	*http.Request
}

func NewUpdateUserSessionRequest(url string, vars *UpdateUserSessionVariables) (*UpdateUserSessionRequest, error) {
	variables, err := json.Marshal(vars)
	if err != nil {
		return nil, err
	}
	b, err := json.Marshal(&GraphQLOperation{
		Variables: variables,
		Query: `mutation UpdateUserSession($id: uuid!, $timestamp: timestamptz!) {
  update_user_by_pk(pk_columns: {id: $id}, _set: {session_last_updated: $timestamp}) {
    id
    session_last_updated
  }
}`,
	})
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(b))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	return &UpdateUserSessionRequest{req}, nil
}

func (req *UpdateUserSessionRequest) Execute(client *http.Client) (*UpdateUserSessionResponse, error) {
	resp, err := execute(client, req.Request)
	if err != nil {
		return nil, err
	}
	var result UpdateUserSessionResponse
	if err := json.Unmarshal(resp.Data, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

func UpdateUserSession(url string, client *http.Client, vars *UpdateUserSessionVariables) (*UpdateUserSessionResponse, error) {
	req, err := NewUpdateUserSessionRequest(url, vars)
	if err != nil {
		return nil, err
	}
	return req.Execute(client)
}

func (client *Client) UpdateUserSession(vars *UpdateUserSessionVariables) (*UpdateUserSessionResponse, error) {
	return UpdateUserSession(client.Url, client.Client, vars)
}

//
// Scalars
//

type Int int32
type Float float64
type Boolean bool
type String string
type ID string
type Json string
type Jsonb string
type Timestamp string
type Timestamptz string
type UUID string

//
// Enums
//

type ErrorType string

const (
	ErrorTypeSERVICEERROR     ErrorType = "SERVICE_ERROR"
	ErrorTypeSERVICEOFFLINE   ErrorType = "SERVICE_OFFLINE"
	ErrorTypeVALIDATIONFAILED ErrorType = "VALIDATION_FAILED"
)

type IntegrationConstraint string

const (
	IntegrationConstraintIntegrationsNameTenantIdKey IntegrationConstraint = "integrations_name_tenant_id_key"
	IntegrationConstraintIntegrationsPkey            IntegrationConstraint = "integrations_pkey"
)

type IntegrationSelectColumn string

const (
	IntegrationSelectColumnCreatedAt       IntegrationSelectColumn = "created_at"
	IntegrationSelectColumnData            IntegrationSelectColumn = "data"
	IntegrationSelectColumnGrafanaMetadata IntegrationSelectColumn = "grafana_metadata"
	IntegrationSelectColumnID              IntegrationSelectColumn = "id"
	IntegrationSelectColumnKind            IntegrationSelectColumn = "kind"
	IntegrationSelectColumnName            IntegrationSelectColumn = "name"
	IntegrationSelectColumnTenantId        IntegrationSelectColumn = "tenant_id"
	IntegrationSelectColumnUpdatedAt       IntegrationSelectColumn = "updated_at"
)

type IntegrationUpdateColumn string

const (
	IntegrationUpdateColumnCreatedAt       IntegrationUpdateColumn = "created_at"
	IntegrationUpdateColumnData            IntegrationUpdateColumn = "data"
	IntegrationUpdateColumnGrafanaMetadata IntegrationUpdateColumn = "grafana_metadata"
	IntegrationUpdateColumnID              IntegrationUpdateColumn = "id"
	IntegrationUpdateColumnKind            IntegrationUpdateColumn = "kind"
	IntegrationUpdateColumnName            IntegrationUpdateColumn = "name"
	IntegrationUpdateColumnTenantId        IntegrationUpdateColumn = "tenant_id"
	IntegrationUpdateColumnUpdatedAt       IntegrationUpdateColumn = "updated_at"
)

type OrderBy string

const (
	OrderByAsc            OrderBy = "asc"
	OrderByAscNullsFirst  OrderBy = "asc_nulls_first"
	OrderByAscNullsLast   OrderBy = "asc_nulls_last"
	OrderByDesc           OrderBy = "desc"
	OrderByDescNullsFirst OrderBy = "desc_nulls_first"
	OrderByDescNullsLast  OrderBy = "desc_nulls_last"
)

type TenantConstraint string

const (
	TenantConstraintTenantIdKey  TenantConstraint = "tenant_id_key"
	TenantConstraintTenantKeyKey TenantConstraint = "tenant_key_key"
	TenantConstraintTenantPkey   TenantConstraint = "tenant_pkey"
)

type TenantSelectColumn string

const (
	TenantSelectColumnCreatedAt TenantSelectColumn = "created_at"
	TenantSelectColumnID        TenantSelectColumn = "id"
	TenantSelectColumnKey       TenantSelectColumn = "key"
	TenantSelectColumnName      TenantSelectColumn = "name"
	TenantSelectColumnType      TenantSelectColumn = "type"
	TenantSelectColumnUpdatedAt TenantSelectColumn = "updated_at"
)

type TenantUpdateColumn string

const (
	TenantUpdateColumnCreatedAt TenantUpdateColumn = "created_at"
	TenantUpdateColumnID        TenantUpdateColumn = "id"
	TenantUpdateColumnKey       TenantUpdateColumn = "key"
	TenantUpdateColumnName      TenantUpdateColumn = "name"
	TenantUpdateColumnType      TenantUpdateColumn = "type"
	TenantUpdateColumnUpdatedAt TenantUpdateColumn = "updated_at"
)

type UserConstraint string

const (
	UserConstraintUserEmailKey UserConstraint = "user_email_key"
	UserConstraintUserIdKey    UserConstraint = "user_id_key"
	UserConstraintUserPkey     UserConstraint = "user_pkey"
)

type UserPreferenceConstraint string

const (
	UserPreferenceConstraintUserPreferenceIdKey     UserPreferenceConstraint = "user_preference_id_key"
	UserPreferenceConstraintUserPreferencePkey      UserPreferenceConstraint = "user_preference_pkey"
	UserPreferenceConstraintUserPreferenceUserIdKey UserPreferenceConstraint = "user_preference_user_id_key"
)

type UserPreferenceSelectColumn string

const (
	UserPreferenceSelectColumnDarkMode UserPreferenceSelectColumn = "dark_mode"
	UserPreferenceSelectColumnID       UserPreferenceSelectColumn = "id"
	UserPreferenceSelectColumnUserId   UserPreferenceSelectColumn = "user_id"
)

type UserPreferenceUpdateColumn string

const (
	UserPreferenceUpdateColumnDarkMode UserPreferenceUpdateColumn = "dark_mode"
	UserPreferenceUpdateColumnID       UserPreferenceUpdateColumn = "id"
	UserPreferenceUpdateColumnUserId   UserPreferenceUpdateColumn = "user_id"
)

type UserSelectColumn string

const (
	UserSelectColumnActive             UserSelectColumn = "active"
	UserSelectColumnAvatar             UserSelectColumn = "avatar"
	UserSelectColumnCreatedAt          UserSelectColumn = "created_at"
	UserSelectColumnEmail              UserSelectColumn = "email"
	UserSelectColumnID                 UserSelectColumn = "id"
	UserSelectColumnRole               UserSelectColumn = "role"
	UserSelectColumnSessionLastUpdated UserSelectColumn = "session_last_updated"
	UserSelectColumnUsername           UserSelectColumn = "username"
)

type UserUpdateColumn string

const (
	UserUpdateColumnActive             UserUpdateColumn = "active"
	UserUpdateColumnAvatar             UserUpdateColumn = "avatar"
	UserUpdateColumnCreatedAt          UserUpdateColumn = "created_at"
	UserUpdateColumnEmail              UserUpdateColumn = "email"
	UserUpdateColumnID                 UserUpdateColumn = "id"
	UserUpdateColumnRole               UserUpdateColumn = "role"
	UserUpdateColumnSessionLastUpdated UserUpdateColumn = "session_last_updated"
	UserUpdateColumnUsername           UserUpdateColumn = "username"
)

//
// Inputs
//

type AlertmanagerInput struct {
	Config String `json:"config"`
}

type BooleanComparisonExp struct {
	Eq     *Boolean   `json:"_eq,omitempty"`
	Gt     *Boolean   `json:"_gt,omitempty"`
	Gte    *Boolean   `json:"_gte,omitempty"`
	In     *[]Boolean `json:"_in,omitempty"`
	IsNull *Boolean   `json:"_is_null,omitempty"`
	Lt     *Boolean   `json:"_lt,omitempty"`
	Lte    *Boolean   `json:"_lte,omitempty"`
	Neq    *Boolean   `json:"_neq,omitempty"`
	Nin    *[]Boolean `json:"_nin,omitempty"`
}

type RuleGroupInput struct {
	RuleGroup String `json:"rule_group"`
}

type StringComparisonExp struct {
	Eq       *String   `json:"_eq,omitempty"`
	Gt       *String   `json:"_gt,omitempty"`
	Gte      *String   `json:"_gte,omitempty"`
	Ilike    *String   `json:"_ilike,omitempty"`
	In       *[]String `json:"_in,omitempty"`
	IsNull   *Boolean  `json:"_is_null,omitempty"`
	Like     *String   `json:"_like,omitempty"`
	Lt       *String   `json:"_lt,omitempty"`
	Lte      *String   `json:"_lte,omitempty"`
	Neq      *String   `json:"_neq,omitempty"`
	Nilike   *String   `json:"_nilike,omitempty"`
	Nin      *[]String `json:"_nin,omitempty"`
	Nlike    *String   `json:"_nlike,omitempty"`
	Nsimilar *String   `json:"_nsimilar,omitempty"`
	Similar  *String   `json:"_similar,omitempty"`
}

type IntegrationAggregateOrderBy struct {
	Count *OrderBy               `json:"count,omitempty"`
	Max   *IntegrationMaxOrderBy `json:"max,omitempty"`
	Min   *IntegrationMinOrderBy `json:"min,omitempty"`
}

type IntegrationAppendInput struct {
	Data            *Jsonb `json:"data,omitempty"`
	GrafanaMetadata *Jsonb `json:"grafana_metadata,omitempty"`
}

type IntegrationArrRelInsertInput struct {
	Data       *[]IntegrationInsertInput `json:"data,omitempty"`
	OnConflict *IntegrationOnConflict    `json:"on_conflict,omitempty"`
}

type IntegrationBoolExp struct {
	And             *[]IntegrationBoolExp   `json:"_and,omitempty"`
	Not             *IntegrationBoolExp     `json:"_not,omitempty"`
	Or              *[]IntegrationBoolExp   `json:"_or,omitempty"`
	CreatedAt       *TimestampComparisonExp `json:"created_at,omitempty"`
	Data            *JsonbComparisonExp     `json:"data,omitempty"`
	GrafanaMetadata *JsonbComparisonExp     `json:"grafana_metadata,omitempty"`
	ID              *UuidComparisonExp      `json:"id,omitempty"`
	Kind            *StringComparisonExp    `json:"kind,omitempty"`
	Name            *StringComparisonExp    `json:"name,omitempty"`
	Tenant          *TenantBoolExp          `json:"tenant,omitempty"`
	TenantId        *UuidComparisonExp      `json:"tenant_id,omitempty"`
	UpdatedAt       *TimestampComparisonExp `json:"updated_at,omitempty"`
}

type IntegrationDeleteAtPathInput struct {
	Data            *[]String `json:"data,omitempty"`
	GrafanaMetadata *[]String `json:"grafana_metadata,omitempty"`
}

type IntegrationDeleteElemInput struct {
	Data            *Int `json:"data,omitempty"`
	GrafanaMetadata *Int `json:"grafana_metadata,omitempty"`
}

type IntegrationDeleteKeyInput struct {
	Data            *String `json:"data,omitempty"`
	GrafanaMetadata *String `json:"grafana_metadata,omitempty"`
}

type IntegrationInsertInput struct {
	CreatedAt       *Timestamp               `json:"created_at,omitempty"`
	Data            *Jsonb                   `json:"data,omitempty"`
	GrafanaMetadata *Jsonb                   `json:"grafana_metadata,omitempty"`
	ID              *UUID                    `json:"id,omitempty"`
	Kind            *String                  `json:"kind,omitempty"`
	Name            *String                  `json:"name,omitempty"`
	Tenant          *TenantObjRelInsertInput `json:"tenant,omitempty"`
	TenantId        *UUID                    `json:"tenant_id,omitempty"`
	UpdatedAt       *Timestamp               `json:"updated_at,omitempty"`
}

type IntegrationMaxOrderBy struct {
	CreatedAt *OrderBy `json:"created_at,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	Kind      *OrderBy `json:"kind,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
	TenantId  *OrderBy `json:"tenant_id,omitempty"`
	UpdatedAt *OrderBy `json:"updated_at,omitempty"`
}

type IntegrationMinOrderBy struct {
	CreatedAt *OrderBy `json:"created_at,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	Kind      *OrderBy `json:"kind,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
	TenantId  *OrderBy `json:"tenant_id,omitempty"`
	UpdatedAt *OrderBy `json:"updated_at,omitempty"`
}

type IntegrationObjRelInsertInput struct {
	Data       IntegrationInsertInput `json:"data"`
	OnConflict *IntegrationOnConflict `json:"on_conflict,omitempty"`
}

type IntegrationOnConflict struct {
	Constraint    IntegrationConstraint      `json:"constraint"`
	UpdateColumns *[]IntegrationUpdateColumn `json:"update_columns,omitempty"`
	Where         *IntegrationBoolExp        `json:"where,omitempty"`
}

type IntegrationOrderBy struct {
	CreatedAt       *OrderBy       `json:"created_at,omitempty"`
	Data            *OrderBy       `json:"data,omitempty"`
	GrafanaMetadata *OrderBy       `json:"grafana_metadata,omitempty"`
	ID              *OrderBy       `json:"id,omitempty"`
	Kind            *OrderBy       `json:"kind,omitempty"`
	Name            *OrderBy       `json:"name,omitempty"`
	Tenant          *TenantOrderBy `json:"tenant,omitempty"`
	TenantId        *OrderBy       `json:"tenant_id,omitempty"`
	UpdatedAt       *OrderBy       `json:"updated_at,omitempty"`
}

type IntegrationPkColumnsInput struct {
	ID UUID `json:"id"`
}

type IntegrationPrependInput struct {
	Data            *Jsonb `json:"data,omitempty"`
	GrafanaMetadata *Jsonb `json:"grafana_metadata,omitempty"`
}

type IntegrationSetInput struct {
	CreatedAt       *Timestamp `json:"created_at,omitempty"`
	Data            *Jsonb     `json:"data,omitempty"`
	GrafanaMetadata *Jsonb     `json:"grafana_metadata,omitempty"`
	ID              *UUID      `json:"id,omitempty"`
	Kind            *String    `json:"kind,omitempty"`
	Name            *String    `json:"name,omitempty"`
	TenantId        *UUID      `json:"tenant_id,omitempty"`
	UpdatedAt       *Timestamp `json:"updated_at,omitempty"`
}

type JsonComparisonExp struct {
	Eq     *Json    `json:"_eq,omitempty"`
	Gt     *Json    `json:"_gt,omitempty"`
	Gte    *Json    `json:"_gte,omitempty"`
	In     *[]Json  `json:"_in,omitempty"`
	IsNull *Boolean `json:"_is_null,omitempty"`
	Lt     *Json    `json:"_lt,omitempty"`
	Lte    *Json    `json:"_lte,omitempty"`
	Neq    *Json    `json:"_neq,omitempty"`
	Nin    *[]Json  `json:"_nin,omitempty"`
}

type JsonbComparisonExp struct {
	ContainedIn *Jsonb    `json:"_contained_in,omitempty"`
	Contains    *Jsonb    `json:"_contains,omitempty"`
	Eq          *Jsonb    `json:"_eq,omitempty"`
	Gt          *Jsonb    `json:"_gt,omitempty"`
	Gte         *Jsonb    `json:"_gte,omitempty"`
	HasKey      *String   `json:"_has_key,omitempty"`
	HasKeysAll  *[]String `json:"_has_keys_all,omitempty"`
	HasKeysAny  *[]String `json:"_has_keys_any,omitempty"`
	In          *[]Jsonb  `json:"_in,omitempty"`
	IsNull      *Boolean  `json:"_is_null,omitempty"`
	Lt          *Jsonb    `json:"_lt,omitempty"`
	Lte         *Jsonb    `json:"_lte,omitempty"`
	Neq         *Jsonb    `json:"_neq,omitempty"`
	Nin         *[]Jsonb  `json:"_nin,omitempty"`
}

type TenantAggregateOrderBy struct {
	Count *OrderBy          `json:"count,omitempty"`
	Max   *TenantMaxOrderBy `json:"max,omitempty"`
	Min   *TenantMinOrderBy `json:"min,omitempty"`
}

type TenantArrRelInsertInput struct {
	Data       *[]TenantInsertInput `json:"data,omitempty"`
	OnConflict *TenantOnConflict    `json:"on_conflict,omitempty"`
}

type TenantBoolExp struct {
	And          *[]TenantBoolExp        `json:"_and,omitempty"`
	Not          *TenantBoolExp          `json:"_not,omitempty"`
	Or           *[]TenantBoolExp        `json:"_or,omitempty"`
	CreatedAt    *TimestampComparisonExp `json:"created_at,omitempty"`
	ID           *UuidComparisonExp      `json:"id,omitempty"`
	Integrations *IntegrationBoolExp     `json:"integrations,omitempty"`
	Key          *StringComparisonExp    `json:"key,omitempty"`
	Name         *StringComparisonExp    `json:"name,omitempty"`
	Type         *StringComparisonExp    `json:"type,omitempty"`
	UpdatedAt    *TimestampComparisonExp `json:"updated_at,omitempty"`
}

type TenantInsertInput struct {
	CreatedAt    *Timestamp                    `json:"created_at,omitempty"`
	ID           *UUID                         `json:"id,omitempty"`
	Integrations *IntegrationArrRelInsertInput `json:"integrations,omitempty"`
	Key          *String                       `json:"key,omitempty"`
	Name         *String                       `json:"name,omitempty"`
	Type         *String                       `json:"type,omitempty"`
	UpdatedAt    *Timestamp                    `json:"updated_at,omitempty"`
}

type TenantMaxOrderBy struct {
	CreatedAt *OrderBy `json:"created_at,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	Key       *OrderBy `json:"key,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
	Type      *OrderBy `json:"type,omitempty"`
	UpdatedAt *OrderBy `json:"updated_at,omitempty"`
}

type TenantMinOrderBy struct {
	CreatedAt *OrderBy `json:"created_at,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	Key       *OrderBy `json:"key,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
	Type      *OrderBy `json:"type,omitempty"`
	UpdatedAt *OrderBy `json:"updated_at,omitempty"`
}

type TenantObjRelInsertInput struct {
	Data       TenantInsertInput `json:"data"`
	OnConflict *TenantOnConflict `json:"on_conflict,omitempty"`
}

type TenantOnConflict struct {
	Constraint    TenantConstraint      `json:"constraint"`
	UpdateColumns *[]TenantUpdateColumn `json:"update_columns,omitempty"`
	Where         *TenantBoolExp        `json:"where,omitempty"`
}

type TenantOrderBy struct {
	CreatedAt             *OrderBy                     `json:"created_at,omitempty"`
	ID                    *OrderBy                     `json:"id,omitempty"`
	IntegrationsAggregate *IntegrationAggregateOrderBy `json:"integrations_aggregate,omitempty"`
	Key                   *OrderBy                     `json:"key,omitempty"`
	Name                  *OrderBy                     `json:"name,omitempty"`
	Type                  *OrderBy                     `json:"type,omitempty"`
	UpdatedAt             *OrderBy                     `json:"updated_at,omitempty"`
}

type TenantPkColumnsInput struct {
	Name String `json:"name"`
}

type TenantSetInput struct {
	CreatedAt *Timestamp `json:"created_at,omitempty"`
	ID        *UUID      `json:"id,omitempty"`
	Key       *String    `json:"key,omitempty"`
	Name      *String    `json:"name,omitempty"`
	Type      *String    `json:"type,omitempty"`
	UpdatedAt *Timestamp `json:"updated_at,omitempty"`
}

type TimestampComparisonExp struct {
	Eq     *Timestamp   `json:"_eq,omitempty"`
	Gt     *Timestamp   `json:"_gt,omitempty"`
	Gte    *Timestamp   `json:"_gte,omitempty"`
	In     *[]Timestamp `json:"_in,omitempty"`
	IsNull *Boolean     `json:"_is_null,omitempty"`
	Lt     *Timestamp   `json:"_lt,omitempty"`
	Lte    *Timestamp   `json:"_lte,omitempty"`
	Neq    *Timestamp   `json:"_neq,omitempty"`
	Nin    *[]Timestamp `json:"_nin,omitempty"`
}

type TimestamptzComparisonExp struct {
	Eq     *Timestamptz   `json:"_eq,omitempty"`
	Gt     *Timestamptz   `json:"_gt,omitempty"`
	Gte    *Timestamptz   `json:"_gte,omitempty"`
	In     *[]Timestamptz `json:"_in,omitempty"`
	IsNull *Boolean       `json:"_is_null,omitempty"`
	Lt     *Timestamptz   `json:"_lt,omitempty"`
	Lte    *Timestamptz   `json:"_lte,omitempty"`
	Neq    *Timestamptz   `json:"_neq,omitempty"`
	Nin    *[]Timestamptz `json:"_nin,omitempty"`
}

type UserAggregateOrderBy struct {
	Count *OrderBy        `json:"count,omitempty"`
	Max   *UserMaxOrderBy `json:"max,omitempty"`
	Min   *UserMinOrderBy `json:"min,omitempty"`
}

type UserArrRelInsertInput struct {
	Data       *[]UserInsertInput `json:"data,omitempty"`
	OnConflict *UserOnConflict    `json:"on_conflict,omitempty"`
}

type UserBoolExp struct {
	And                *[]UserBoolExp            `json:"_and,omitempty"`
	Not                *UserBoolExp              `json:"_not,omitempty"`
	Or                 *[]UserBoolExp            `json:"_or,omitempty"`
	Active             *BooleanComparisonExp     `json:"active,omitempty"`
	Avatar             *StringComparisonExp      `json:"avatar,omitempty"`
	CreatedAt          *TimestamptzComparisonExp `json:"created_at,omitempty"`
	Email              *StringComparisonExp      `json:"email,omitempty"`
	ID                 *UuidComparisonExp        `json:"id,omitempty"`
	Preference         *UserPreferenceBoolExp    `json:"preference,omitempty"`
	Role               *StringComparisonExp      `json:"role,omitempty"`
	SessionLastUpdated *TimestamptzComparisonExp `json:"session_last_updated,omitempty"`
	Username           *StringComparisonExp      `json:"username,omitempty"`
}

type UserInsertInput struct {
	Active             *Boolean                         `json:"active,omitempty"`
	Avatar             *String                          `json:"avatar,omitempty"`
	CreatedAt          *Timestamptz                     `json:"created_at,omitempty"`
	Email              *String                          `json:"email,omitempty"`
	ID                 *UUID                            `json:"id,omitempty"`
	Preference         *UserPreferenceObjRelInsertInput `json:"preference,omitempty"`
	Role               *String                          `json:"role,omitempty"`
	SessionLastUpdated *Timestamptz                     `json:"session_last_updated,omitempty"`
	Username           *String                          `json:"username,omitempty"`
}

type UserMaxOrderBy struct {
	Avatar             *OrderBy `json:"avatar,omitempty"`
	CreatedAt          *OrderBy `json:"created_at,omitempty"`
	Email              *OrderBy `json:"email,omitempty"`
	ID                 *OrderBy `json:"id,omitempty"`
	Role               *OrderBy `json:"role,omitempty"`
	SessionLastUpdated *OrderBy `json:"session_last_updated,omitempty"`
	Username           *OrderBy `json:"username,omitempty"`
}

type UserMinOrderBy struct {
	Avatar             *OrderBy `json:"avatar,omitempty"`
	CreatedAt          *OrderBy `json:"created_at,omitempty"`
	Email              *OrderBy `json:"email,omitempty"`
	ID                 *OrderBy `json:"id,omitempty"`
	Role               *OrderBy `json:"role,omitempty"`
	SessionLastUpdated *OrderBy `json:"session_last_updated,omitempty"`
	Username           *OrderBy `json:"username,omitempty"`
}

type UserObjRelInsertInput struct {
	Data       UserInsertInput `json:"data"`
	OnConflict *UserOnConflict `json:"on_conflict,omitempty"`
}

type UserOnConflict struct {
	Constraint    UserConstraint      `json:"constraint"`
	UpdateColumns *[]UserUpdateColumn `json:"update_columns,omitempty"`
	Where         *UserBoolExp        `json:"where,omitempty"`
}

type UserOrderBy struct {
	Active             *OrderBy               `json:"active,omitempty"`
	Avatar             *OrderBy               `json:"avatar,omitempty"`
	CreatedAt          *OrderBy               `json:"created_at,omitempty"`
	Email              *OrderBy               `json:"email,omitempty"`
	ID                 *OrderBy               `json:"id,omitempty"`
	Preference         *UserPreferenceOrderBy `json:"preference,omitempty"`
	Role               *OrderBy               `json:"role,omitempty"`
	SessionLastUpdated *OrderBy               `json:"session_last_updated,omitempty"`
	Username           *OrderBy               `json:"username,omitempty"`
}

type UserPkColumnsInput struct {
	ID UUID `json:"id"`
}

type UserPreferenceAggregateOrderBy struct {
	Count *OrderBy                  `json:"count,omitempty"`
	Max   *UserPreferenceMaxOrderBy `json:"max,omitempty"`
	Min   *UserPreferenceMinOrderBy `json:"min,omitempty"`
}

type UserPreferenceArrRelInsertInput struct {
	Data       *[]UserPreferenceInsertInput `json:"data,omitempty"`
	OnConflict *UserPreferenceOnConflict    `json:"on_conflict,omitempty"`
}

type UserPreferenceBoolExp struct {
	And      *[]UserPreferenceBoolExp `json:"_and,omitempty"`
	Not      *UserPreferenceBoolExp   `json:"_not,omitempty"`
	Or       *[]UserPreferenceBoolExp `json:"_or,omitempty"`
	DarkMode *BooleanComparisonExp    `json:"dark_mode,omitempty"`
	ID       *UuidComparisonExp       `json:"id,omitempty"`
	User     *UserBoolExp             `json:"user,omitempty"`
	UserId   *UuidComparisonExp       `json:"user_id,omitempty"`
}

type UserPreferenceInsertInput struct {
	DarkMode *Boolean               `json:"dark_mode,omitempty"`
	ID       *UUID                  `json:"id,omitempty"`
	User     *UserObjRelInsertInput `json:"user,omitempty"`
	UserId   *UUID                  `json:"user_id,omitempty"`
}

type UserPreferenceMaxOrderBy struct {
	ID     *OrderBy `json:"id,omitempty"`
	UserId *OrderBy `json:"user_id,omitempty"`
}

type UserPreferenceMinOrderBy struct {
	ID     *OrderBy `json:"id,omitempty"`
	UserId *OrderBy `json:"user_id,omitempty"`
}

type UserPreferenceObjRelInsertInput struct {
	Data       UserPreferenceInsertInput `json:"data"`
	OnConflict *UserPreferenceOnConflict `json:"on_conflict,omitempty"`
}

type UserPreferenceOnConflict struct {
	Constraint    UserPreferenceConstraint      `json:"constraint"`
	UpdateColumns *[]UserPreferenceUpdateColumn `json:"update_columns,omitempty"`
	Where         *UserPreferenceBoolExp        `json:"where,omitempty"`
}

type UserPreferenceOrderBy struct {
	DarkMode *OrderBy     `json:"dark_mode,omitempty"`
	ID       *OrderBy     `json:"id,omitempty"`
	User     *UserOrderBy `json:"user,omitempty"`
	UserId   *OrderBy     `json:"user_id,omitempty"`
}

type UserPreferencePkColumnsInput struct {
	ID UUID `json:"id"`
}

type UserPreferenceSetInput struct {
	DarkMode *Boolean `json:"dark_mode,omitempty"`
	ID       *UUID    `json:"id,omitempty"`
	UserId   *UUID    `json:"user_id,omitempty"`
}

type UserSetInput struct {
	Active             *Boolean     `json:"active,omitempty"`
	Avatar             *String      `json:"avatar,omitempty"`
	CreatedAt          *Timestamptz `json:"created_at,omitempty"`
	Email              *String      `json:"email,omitempty"`
	ID                 *UUID        `json:"id,omitempty"`
	Role               *String      `json:"role,omitempty"`
	SessionLastUpdated *Timestamptz `json:"session_last_updated,omitempty"`
	Username           *String      `json:"username,omitempty"`
}

type UuidComparisonExp struct {
	Eq     *UUID    `json:"_eq,omitempty"`
	Gt     *UUID    `json:"_gt,omitempty"`
	Gte    *UUID    `json:"_gte,omitempty"`
	In     *[]UUID  `json:"_in,omitempty"`
	IsNull *Boolean `json:"_is_null,omitempty"`
	Lt     *UUID    `json:"_lt,omitempty"`
	Lte    *UUID    `json:"_lte,omitempty"`
	Neq    *UUID    `json:"_neq,omitempty"`
	Nin    *[]UUID  `json:"_nin,omitempty"`
}

//
// Objects
//

type Alertmanager struct {
	Config   *String `json:"config,omitempty"`
	Online   Boolean `json:"online"`
	TenantId String  `json:"tenant_id"`
}

type RuleGroup struct {
	Namespace     String  `json:"namespace"`
	Online        Boolean `json:"online"`
	RuleGroup     *String `json:"rule_group,omitempty"`
	RuleGroupName String  `json:"rule_group_name"`
	TenantId      String  `json:"tenant_id"`
}

type Rules struct {
	Online   Boolean `json:"online"`
	Rules    *String `json:"rules,omitempty"`
	TenantId String  `json:"tenant_id"`
}

type StatusResponse struct {
	ErrorMessage     *String    `json:"error_message,omitempty"`
	ErrorRawResponse *String    `json:"error_raw_response,omitempty"`
	ErrorType        *ErrorType `json:"error_type,omitempty"`
	Success          Boolean    `json:"success"`
}

type Integration struct {
	CreatedAt       Timestamp `json:"created_at"`
	Data            Jsonb     `json:"data"`
	GrafanaMetadata Jsonb     `json:"grafana_metadata"`
	ID              UUID      `json:"id"`
	Kind            String    `json:"kind"`
	Name            String    `json:"name"`
	Tenant          Tenant    `json:"tenant"`
	TenantId        UUID      `json:"tenant_id"`
	UpdatedAt       Timestamp `json:"updated_at"`
}

type IntegrationAggregate struct {
	Aggregate *IntegrationAggregateFields `json:"aggregate,omitempty"`
	Nodes     *[]Integration              `json:"nodes,omitempty"`
}

type IntegrationAggregateFields struct {
	Count *Int                  `json:"count,omitempty"`
	Max   *IntegrationMaxFields `json:"max,omitempty"`
	Min   *IntegrationMinFields `json:"min,omitempty"`
}

type IntegrationMaxFields struct {
	CreatedAt *Timestamp `json:"created_at,omitempty"`
	ID        *UUID      `json:"id,omitempty"`
	Kind      *String    `json:"kind,omitempty"`
	Name      *String    `json:"name,omitempty"`
	TenantId  *UUID      `json:"tenant_id,omitempty"`
	UpdatedAt *Timestamp `json:"updated_at,omitempty"`
}

type IntegrationMinFields struct {
	CreatedAt *Timestamp `json:"created_at,omitempty"`
	ID        *UUID      `json:"id,omitempty"`
	Kind      *String    `json:"kind,omitempty"`
	Name      *String    `json:"name,omitempty"`
	TenantId  *UUID      `json:"tenant_id,omitempty"`
	UpdatedAt *Timestamp `json:"updated_at,omitempty"`
}

type IntegrationMutationResponse struct {
	AffectedRows Int            `json:"affected_rows"`
	Returning    *[]Integration `json:"returning,omitempty"`
}

type MutationRoot struct {
	DeleteRuleGroup          *StatusResponse                 `json:"deleteRuleGroup,omitempty"`
	DeleteIntegration        *IntegrationMutationResponse    `json:"delete_integration,omitempty"`
	DeleteIntegrationByPk    *Integration                    `json:"delete_integration_by_pk,omitempty"`
	DeleteTenant             *TenantMutationResponse         `json:"delete_tenant,omitempty"`
	DeleteTenantByPk         *Tenant                         `json:"delete_tenant_by_pk,omitempty"`
	DeleteUser               *UserMutationResponse           `json:"delete_user,omitempty"`
	DeleteUserByPk           *User                           `json:"delete_user_by_pk,omitempty"`
	DeleteUserPreference     *UserPreferenceMutationResponse `json:"delete_user_preference,omitempty"`
	DeleteUserPreferenceByPk *UserPreference                 `json:"delete_user_preference_by_pk,omitempty"`
	InsertIntegration        *IntegrationMutationResponse    `json:"insert_integration,omitempty"`
	InsertIntegrationOne     *Integration                    `json:"insert_integration_one,omitempty"`
	InsertTenant             *TenantMutationResponse         `json:"insert_tenant,omitempty"`
	InsertTenantOne          *Tenant                         `json:"insert_tenant_one,omitempty"`
	InsertUser               *UserMutationResponse           `json:"insert_user,omitempty"`
	InsertUserOne            *User                           `json:"insert_user_one,omitempty"`
	InsertUserPreference     *UserPreferenceMutationResponse `json:"insert_user_preference,omitempty"`
	InsertUserPreferenceOne  *UserPreference                 `json:"insert_user_preference_one,omitempty"`
	UpdateAlertmanager       *StatusResponse                 `json:"updateAlertmanager,omitempty"`
	UpdateRuleGroup          *StatusResponse                 `json:"updateRuleGroup,omitempty"`
	UpdateIntegration        *IntegrationMutationResponse    `json:"update_integration,omitempty"`
	UpdateIntegrationByPk    *Integration                    `json:"update_integration_by_pk,omitempty"`
	UpdateTenant             *TenantMutationResponse         `json:"update_tenant,omitempty"`
	UpdateTenantByPk         *Tenant                         `json:"update_tenant_by_pk,omitempty"`
	UpdateUser               *UserMutationResponse           `json:"update_user,omitempty"`
	UpdateUserByPk           *User                           `json:"update_user_by_pk,omitempty"`
	UpdateUserPreference     *UserPreferenceMutationResponse `json:"update_user_preference,omitempty"`
	UpdateUserPreferenceByPk *UserPreference                 `json:"update_user_preference_by_pk,omitempty"`
}

type QueryRoot struct {
	GetAlertmanager         *Alertmanager           `json:"getAlertmanager,omitempty"`
	GetRuleGroup            *RuleGroup              `json:"getRuleGroup,omitempty"`
	Integration             *[]Integration          `json:"integration,omitempty"`
	IntegrationAggregate    IntegrationAggregate    `json:"integration_aggregate"`
	IntegrationByPk         *Integration            `json:"integration_by_pk,omitempty"`
	ListRules               *Rules                  `json:"listRules,omitempty"`
	Tenant                  *[]Tenant               `json:"tenant,omitempty"`
	TenantAggregate         TenantAggregate         `json:"tenant_aggregate"`
	TenantByPk              *Tenant                 `json:"tenant_by_pk,omitempty"`
	User                    *[]User                 `json:"user,omitempty"`
	UserAggregate           UserAggregate           `json:"user_aggregate"`
	UserByPk                *User                   `json:"user_by_pk,omitempty"`
	UserPreference          *[]UserPreference       `json:"user_preference,omitempty"`
	UserPreferenceAggregate UserPreferenceAggregate `json:"user_preference_aggregate"`
	UserPreferenceByPk      *UserPreference         `json:"user_preference_by_pk,omitempty"`
	ValidateIntegration     *StatusResponse         `json:"validateIntegration,omitempty"`
}

type SubscriptionRoot struct {
	GetAlertmanager         *Alertmanager           `json:"getAlertmanager,omitempty"`
	GetRuleGroup            *RuleGroup              `json:"getRuleGroup,omitempty"`
	Integration             *[]Integration          `json:"integration,omitempty"`
	IntegrationAggregate    IntegrationAggregate    `json:"integration_aggregate"`
	IntegrationByPk         *Integration            `json:"integration_by_pk,omitempty"`
	ListRules               *Rules                  `json:"listRules,omitempty"`
	Tenant                  *[]Tenant               `json:"tenant,omitempty"`
	TenantAggregate         TenantAggregate         `json:"tenant_aggregate"`
	TenantByPk              *Tenant                 `json:"tenant_by_pk,omitempty"`
	User                    *[]User                 `json:"user,omitempty"`
	UserAggregate           UserAggregate           `json:"user_aggregate"`
	UserByPk                *User                   `json:"user_by_pk,omitempty"`
	UserPreference          *[]UserPreference       `json:"user_preference,omitempty"`
	UserPreferenceAggregate UserPreferenceAggregate `json:"user_preference_aggregate"`
	UserPreferenceByPk      *UserPreference         `json:"user_preference_by_pk,omitempty"`
	ValidateIntegration     *StatusResponse         `json:"validateIntegration,omitempty"`
}

type Tenant struct {
	CreatedAt             Timestamp            `json:"created_at"`
	ID                    UUID                 `json:"id"`
	Integrations          *[]Integration       `json:"integrations,omitempty"`
	IntegrationsAggregate IntegrationAggregate `json:"integrations_aggregate"`
	Key                   String               `json:"key"`
	Name                  String               `json:"name"`
	Type                  String               `json:"type"`
	UpdatedAt             Timestamp            `json:"updated_at"`
}

type TenantAggregate struct {
	Aggregate *TenantAggregateFields `json:"aggregate,omitempty"`
	Nodes     *[]Tenant              `json:"nodes,omitempty"`
}

type TenantAggregateFields struct {
	Count *Int             `json:"count,omitempty"`
	Max   *TenantMaxFields `json:"max,omitempty"`
	Min   *TenantMinFields `json:"min,omitempty"`
}

type TenantMaxFields struct {
	CreatedAt *Timestamp `json:"created_at,omitempty"`
	ID        *UUID      `json:"id,omitempty"`
	Key       *String    `json:"key,omitempty"`
	Name      *String    `json:"name,omitempty"`
	Type      *String    `json:"type,omitempty"`
	UpdatedAt *Timestamp `json:"updated_at,omitempty"`
}

type TenantMinFields struct {
	CreatedAt *Timestamp `json:"created_at,omitempty"`
	ID        *UUID      `json:"id,omitempty"`
	Key       *String    `json:"key,omitempty"`
	Name      *String    `json:"name,omitempty"`
	Type      *String    `json:"type,omitempty"`
	UpdatedAt *Timestamp `json:"updated_at,omitempty"`
}

type TenantMutationResponse struct {
	AffectedRows Int       `json:"affected_rows"`
	Returning    *[]Tenant `json:"returning,omitempty"`
}

type User struct {
	Active             Boolean         `json:"active"`
	Avatar             *String         `json:"avatar,omitempty"`
	CreatedAt          Timestamptz     `json:"created_at"`
	Email              String          `json:"email"`
	ID                 UUID            `json:"id"`
	Preference         *UserPreference `json:"preference,omitempty"`
	Role               String          `json:"role"`
	SessionLastUpdated *Timestamptz    `json:"session_last_updated,omitempty"`
	Username           String          `json:"username"`
}

type UserAggregate struct {
	Aggregate *UserAggregateFields `json:"aggregate,omitempty"`
	Nodes     *[]User              `json:"nodes,omitempty"`
}

type UserAggregateFields struct {
	Count *Int           `json:"count,omitempty"`
	Max   *UserMaxFields `json:"max,omitempty"`
	Min   *UserMinFields `json:"min,omitempty"`
}

type UserMaxFields struct {
	Avatar             *String      `json:"avatar,omitempty"`
	CreatedAt          *Timestamptz `json:"created_at,omitempty"`
	Email              *String      `json:"email,omitempty"`
	ID                 *UUID        `json:"id,omitempty"`
	Role               *String      `json:"role,omitempty"`
	SessionLastUpdated *Timestamptz `json:"session_last_updated,omitempty"`
	Username           *String      `json:"username,omitempty"`
}

type UserMinFields struct {
	Avatar             *String      `json:"avatar,omitempty"`
	CreatedAt          *Timestamptz `json:"created_at,omitempty"`
	Email              *String      `json:"email,omitempty"`
	ID                 *UUID        `json:"id,omitempty"`
	Role               *String      `json:"role,omitempty"`
	SessionLastUpdated *Timestamptz `json:"session_last_updated,omitempty"`
	Username           *String      `json:"username,omitempty"`
}

type UserMutationResponse struct {
	AffectedRows Int     `json:"affected_rows"`
	Returning    *[]User `json:"returning,omitempty"`
}

type UserPreference struct {
	DarkMode Boolean `json:"dark_mode"`
	ID       UUID    `json:"id"`
	User     *User   `json:"user,omitempty"`
	UserId   *UUID   `json:"user_id,omitempty"`
}

type UserPreferenceAggregate struct {
	Aggregate *UserPreferenceAggregateFields `json:"aggregate,omitempty"`
	Nodes     *[]UserPreference              `json:"nodes,omitempty"`
}

type UserPreferenceAggregateFields struct {
	Count *Int                     `json:"count,omitempty"`
	Max   *UserPreferenceMaxFields `json:"max,omitempty"`
	Min   *UserPreferenceMinFields `json:"min,omitempty"`
}

type UserPreferenceMaxFields struct {
	ID     *UUID `json:"id,omitempty"`
	UserId *UUID `json:"user_id,omitempty"`
}

type UserPreferenceMinFields struct {
	ID     *UUID `json:"id,omitempty"`
	UserId *UUID `json:"user_id,omitempty"`
}

type UserPreferenceMutationResponse struct {
	AffectedRows Int               `json:"affected_rows"`
	Returning    *[]UserPreference `json:"returning,omitempty"`
}
