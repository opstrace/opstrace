import {
  Button_default,
  fade
} from "./chunk.JB4WRZVB.js";
import {
  Box_default,
  Column_default,
  Layout_default,
  Row_default
} from "./chunk.4LX6JVCO.js";
import {
  ButtonListItem,
  ListContext_default,
  ListItemSecondaryAction,
  ListItemText,
  ListItem_default,
  List_default,
  Typography_default
} from "./chunk.QYNTIDVB.js";
import {
  ButtonBase_default,
  TransitionGroupContext_default,
  capitalize,
  getThemeProps,
  setRef,
  useEventCallback,
  useForkRef,
  withStyles_default
} from "./chunk.L67S57WQ.js";
import {
  Scrollable_default
} from "./chunk.GJTYBYO4.js";
import {
  React,
  StylesContext,
  ThemeContext_default,
  __commonJS,
  __defProp,
  __markAsModule,
  __toModule,
  _createClass,
  _defineProperty,
  _extends,
  _inheritsLoose,
  _objectWithoutProperties,
  _objectWithoutPropertiesLoose,
  _slicedToArray,
  _toConsumableArray,
  blue_default,
  clsx_m_default,
  common_default,
  create,
  createMuiTheme_default,
  darken,
  defaultTheme_default,
  duration,
  formatMuiErrorMessage,
  getLuminance,
  green_default,
  grey_default,
  jssPreset,
  lighten,
  makeStyles,
  nested_default,
  orange_default,
  pink_default,
  red_default,
  require_hoist_non_react_statics_cjs,
  require_index_cjs,
  require_prop_types,
  useTheme,
  zIndex_default
} from "./chunk.MAS4Q2ZR.js";
import {
  $,
  AccessibilityHelpNLS,
  Action,
  ActionBar,
  ActionRunner,
  ActionViewItem,
  BaseActionViewItem,
  BrowserFeatures,
  CONTEXT_ACCESSIBILITY_MODE_ENABLED,
  CancellationToken,
  CancellationTokenSource,
  CharacterClassifier,
  CodeActionProviderRegistry,
  CodeEditorWidget,
  CodeLensProviderRegistry,
  Codicon,
  Color,
  ColorProviderRegistry,
  CommandsRegistry,
  CompletionProviderRegistry,
  ContextKeyExpr,
  CopyOptions,
  CoreEditingCommands,
  CountBadge,
  CursorMoveCommands,
  CursorState,
  DataUri,
  DeclarationProviderRegistry,
  DefinitionProviderRegistry,
  Delayer,
  Disposable,
  DisposableStore,
  DocumentFormattingEditProviderRegistry,
  DocumentHighlightKind,
  DocumentHighlightProviderRegistry,
  DocumentRangeFormattingEditProviderRegistry,
  DocumentRangeSemanticTokensProviderRegistry,
  DocumentSymbolProviderRegistry,
  DomScrollableElement,
  EditOperation,
  EditorAction,
  EditorCommand,
  EditorContextKeys,
  EditorContributionRegistry,
  EditorOptions,
  EditorType,
  EditorZoom,
  Emitter,
  Emitter2,
  Event,
  EventHelper,
  EventType,
  EventType2,
  Extensions as Extensions2,
  Extensions2 as Extensions,
  FoldingRangeKind,
  FoldingRangeProviderRegistry,
  FuzzyScore,
  Gesture,
  GlobalMouseMoveMonitor,
  GoToLineNLS,
  HIGH_CONTRAST,
  HSVA,
  HighlightedLabel,
  HoverProviderRegistry,
  IAccessibilityService,
  IBulkEditService,
  IClipboardService,
  ICodeEditorService,
  ICommandService,
  IConfigurationService,
  IContextKeyService,
  IContextMenuService,
  IContextViewService,
  IDialogService,
  IEditorCancellationTokens,
  IEditorProgressService,
  IEditorWorkerService,
  IInstantiationService,
  IKeybindingService,
  ILabelService,
  IListService,
  ILogService,
  IMarkerData,
  IMarkerDecorationsService,
  IMarkerService,
  IMenuService,
  IModeService,
  IModelService,
  INotificationService,
  IOpenerService,
  IQuickInputService,
  IStandaloneThemeService,
  IStorageKeysSyncRegistryService,
  IStorageService,
  ITelemetryService,
  ITextModelService,
  ITextResourceConfigurationService,
  IThemeService,
  IUndoRedoService,
  IWorkspaceContextService,
  IconLabel,
  IdGenerator,
  IdleValue,
  ImplementationProviderRegistry,
  InMemoryClipboardMetadataManager,
  IndentAction,
  InputBox,
  InspectTokensNLS,
  Iterable,
  KeyChord,
  KeybindingsRegistry,
  LRUCache,
  LanguageConfigurationRegistry,
  LineTokens,
  LinkProviderRegistry,
  LinkedList,
  List,
  MarkerSeverity,
  MenuId,
  MenuItemAction,
  MenuRegistry,
  MinimapPosition,
  ModelDecorationOptions,
  MoveOperations,
  MultiCommand,
  NULL_STATE,
  NullOpenerService,
  OnTypeFormattingEditProviderRegistry,
  OnTypeRenameProviderRegistry,
  OverviewRulerLane,
  PLAINTEXT_MODE_ID,
  Position,
  Progress,
  QuickCommandNLS,
  QuickHelpNLS,
  QuickOutlineNLS,
  RGBA,
  Range as Range2,
  Range2 as Range,
  RawContextKey,
  ReferenceProviderRegistry,
  Registry,
  RenameProviderRegistry,
  ReplaceCommand,
  ReplaceCommandThatPreservesSelection,
  ResourceEdit,
  ResourceMap,
  RunOnceScheduler,
  SEMANTIC_HIGHLIGHTING_SETTING_ID,
  Sash,
  Schemas,
  ScrollableElement,
  SearchParams,
  Selection,
  SelectionRangeRegistry,
  Separator,
  ShiftCommand,
  SignatureHelpProviderRegistry,
  SignatureHelpTriggerKind,
  SimpleKeybinding,
  StableEditorScrollState,
  StandardKeyboardEvent,
  StandardMouseEvent,
  StopWatch,
  SubmenuAction,
  SubmenuItemAction,
  SymbolKinds,
  TabFocus,
  TextModel,
  ThemeIcon,
  TimeoutTimer,
  ToggleHighContrastNLS,
  TokenMetadata,
  TokenizationRegistry,
  TypeDefinitionProviderRegistry,
  TypeOperations,
  URI,
  Widget,
  WillSaveStateReason,
  WordOperations,
  WorkbenchAsyncDataTree,
  WorkbenchListFocusContextKey,
  _hasOwnProperty,
  _maxLen,
  _wrapAsStandardMouseEvent,
  activeContrastBorder,
  addClass,
  addClasses,
  addDisposableListener,
  addDisposableNonBubblingMouseOutListener,
  addStandardDisposableListener,
  alert,
  append,
  ariaContainer,
  asCSSUrl,
  asDomUri,
  attachListStyler,
  attachStyler,
  badgeBackground,
  badgeForeground,
  basename,
  basename2,
  basenameOrAuthority,
  binarySearch,
  canceled,
  clamp,
  clearNode,
  coalesce,
  combinedDisposable,
  commonPrefixLength,
  commonSuffixLength,
  compare,
  completionKindFromString,
  completionKindToCssClass,
  contrastBorder,
  createCSSRule,
  createCancelablePromise,
  createDecorator,
  createElement,
  createFastDomNode,
  createStyleSheet,
  deepClone,
  defaultGenerator,
  dirname,
  dirname2,
  disposableTimeout,
  dispose,
  domEvent,
  editor,
  editorActiveLinkForeground,
  editorBracketMatchBackground,
  editorBracketMatchBorder,
  editorCodeLensForeground,
  editorErrorBorder,
  editorErrorForeground,
  editorFindMatch,
  editorFindMatchBorder,
  editorFindMatchHighlight,
  editorFindMatchHighlightBorder,
  editorFindRangeHighlight,
  editorFindRangeHighlightBorder,
  editorForeground,
  editorHoverBackground,
  editorHoverBorder,
  editorHoverForeground,
  editorHoverHighlight,
  editorHoverStatusBarBackground,
  editorInfoBorder,
  editorInfoForeground,
  editorLightBulbAutoFixForeground,
  editorLightBulbForeground,
  editorSelectionBackground,
  editorSelectionHighlight,
  editorSelectionHighlightBorder,
  editorWarningBorder,
  editorWarningForeground,
  editorWidgetBackground,
  editorWidgetBorder,
  editorWidgetForeground,
  editorWidgetResizeBorder,
  equals,
  errorForeground,
  errorHandler,
  escape,
  escapeRegExpCharacters,
  extUri,
  firstIndex,
  firstNonWhitespaceIndex,
  focusBorder,
  foreground,
  format,
  fuzzyScore,
  getComputedStyle,
  getDomNodePagePosition,
  getLeadingWhitespace,
  getMapForWordSeparators,
  getShadowRoot,
  getTopLeftOffset,
  getTotalWidth,
  hasClass,
  hide,
  iconForeground,
  illegalArgument,
  inputActiveOptionBackground,
  inputActiveOptionBorder,
  inputActiveOptionForeground,
  inputBackground,
  inputBorder,
  inputForeground,
  inputValidationErrorBackground,
  inputValidationErrorBorder,
  inputValidationErrorForeground,
  inputValidationInfoBackground,
  inputValidationInfoBorder,
  inputValidationInfoForeground,
  inputValidationWarningBackground,
  inputValidationWarningBorder,
  inputValidationWarningForeground,
  insertMessage,
  isCodeEditor,
  isDisposable,
  isEdge,
  isEqual,
  isFalsyOrEmpty,
  isFalsyOrWhitespace,
  isFirefox,
  isHighSurrogate,
  isIOS,
  isIPad,
  isInDOM,
  isInShadowDOM,
  isLinux,
  isLowSurrogate,
  isLowerAsciiLetter,
  isMacintosh,
  isNative,
  isNonEmptyArray,
  isNumber,
  isObject,
  isPromiseCanceledError,
  isSemanticColoringEnabled,
  isStandalone,
  isString,
  isUndefined,
  isUndefinedOrNull,
  isUpperAsciiLetter,
  isWeb,
  isWhitespace,
  isWindows,
  join,
  joinPath,
  languages,
  lastNonWhitespaceIndex,
  listFocusBackground,
  listHighlightForeground,
  localize,
  ltrim,
  markTracked,
  matchesContiguousSubString,
  matchesPrefix,
  mergeSort,
  minimapFindMatch,
  mixin,
  normalize,
  nullTokenize,
  nullTokenize2,
  numberHash,
  onDidChangeZoomLevel,
  onUnexpectedError,
  once,
  optional,
  or,
  originalFSPath,
  overviewRulerFindMatchForeground,
  overviewRulerRangeHighlight,
  overviewRulerSelectionHighlightForeground,
  parse,
  posix,
  problemsErrorIconForeground,
  problemsInfoIconForeground,
  problemsWarningIconForeground,
  range,
  registerColor,
  registerEditorAction,
  registerEditorCommand,
  registerEditorContribution,
  registerIcon,
  registerSingleton,
  registerThemingParticipant,
  relativePath,
  removeCSSRulesContainingSelector,
  removeClass,
  removeClasses,
  removeTabIndexAndUpdateFocus,
  renderCodicons,
  renderFormattedText,
  reset,
  resolveColorValue,
  resolvePath,
  rtrim,
  runWhenIdle,
  sep,
  severity_default,
  show,
  snippetFinalTabstopHighlightBackground,
  snippetFinalTabstopHighlightBorder,
  snippetTabstopHighlightBackground,
  snippetTabstopHighlightBorder,
  standardMouseMoveMerger,
  startsWith,
  startsWithIgnoreCase,
  statusContainer,
  statusContainer2,
  stringHash,
  stripCodicons,
  textCodeBlockBackground,
  textLinkForeground,
  themeColorFromId,
  timeout,
  toDisposable,
  toMultilineTokens2,
  toggleClass,
  trackDisposable,
  trackFocus,
  transparent,
  widgetShadow,
  withNullAsUndefined,
  wordSeparators
} from "./chunk.BQHVVPWU.js";
var __export = (target, all2) => {
  __markAsModule(target);
  for (var name in all2)
    __defProp(target, name, {get: all2[name], enumerable: true});
};

// ../../node_modules/react-router/node_modules/isarray/index.js
var require_isarray = __commonJS((exports, module) => {
  module.exports = Array.isArray || function(arr) {
    return Object.prototype.toString.call(arr) == "[object Array]";
  };
});

// ../../node_modules/react-router/node_modules/path-to-regexp/index.js
var require_path_to_regexp = __commonJS((exports, module) => {
  var isarray = require_isarray();
  module.exports = pathToRegexp2;
  module.exports.parse = parse4;
  module.exports.compile = compile;
  module.exports.tokensToFunction = tokensToFunction;
  module.exports.tokensToRegExp = tokensToRegExp;
  var PATH_REGEXP = new RegExp([
    "(\\\\.)",
    "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
  ].join("|"), "g");
  function parse4(str, options) {
    var tokens = [];
    var key = 0;
    var index2 = 0;
    var path3 = "";
    var defaultDelimiter = options && options.delimiter || "/";
    var res;
    while ((res = PATH_REGEXP.exec(str)) != null) {
      var m = res[0];
      var escaped = res[1];
      var offset = res.index;
      path3 += str.slice(index2, offset);
      index2 = offset + m.length;
      if (escaped) {
        path3 += escaped[1];
        continue;
      }
      var next = str[index2];
      var prefix2 = res[2];
      var name = res[3];
      var capture = res[4];
      var group = res[5];
      var modifier = res[6];
      var asterisk = res[7];
      if (path3) {
        tokens.push(path3);
        path3 = "";
      }
      var partial = prefix2 != null && next != null && next !== prefix2;
      var repeat = modifier === "+" || modifier === "*";
      var optional2 = modifier === "?" || modifier === "*";
      var delimiter = res[2] || defaultDelimiter;
      var pattern3 = capture || group;
      tokens.push({
        name: name || key++,
        prefix: prefix2 || "",
        delimiter,
        optional: optional2,
        repeat,
        partial,
        asterisk: !!asterisk,
        pattern: pattern3 ? escapeGroup(pattern3) : asterisk ? ".*" : "[^" + escapeString(delimiter) + "]+?"
      });
    }
    if (index2 < str.length) {
      path3 += str.substr(index2);
    }
    if (path3) {
      tokens.push(path3);
    }
    return tokens;
  }
  function compile(str, options) {
    return tokensToFunction(parse4(str, options), options);
  }
  function encodeURIComponentPretty(str) {
    return encodeURI(str).replace(/[\/?#]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeAsterisk(str) {
    return encodeURI(str).replace(/[?#]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function tokensToFunction(tokens, options) {
    var matches = new Array(tokens.length);
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] === "object") {
        matches[i] = new RegExp("^(?:" + tokens[i].pattern + ")$", flags(options));
      }
    }
    return function(obj, opts) {
      var path3 = "";
      var data = obj || {};
      var options2 = opts || {};
      var encode = options2.pretty ? encodeURIComponentPretty : encodeURIComponent;
      for (var i2 = 0; i2 < tokens.length; i2++) {
        var token = tokens[i2];
        if (typeof token === "string") {
          path3 += token;
          continue;
        }
        var value = data[token.name];
        var segment;
        if (value == null) {
          if (token.optional) {
            if (token.partial) {
              path3 += token.prefix;
            }
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to be defined');
          }
        }
        if (isarray(value)) {
          if (!token.repeat) {
            throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
          }
          if (value.length === 0) {
            if (token.optional) {
              continue;
            } else {
              throw new TypeError('Expected "' + token.name + '" to not be empty');
            }
          }
          for (var j = 0; j < value.length; j++) {
            segment = encode(value[j]);
            if (!matches[i2].test(segment)) {
              throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + "`");
            }
            path3 += (j === 0 ? token.prefix : token.delimiter) + segment;
          }
          continue;
        }
        segment = token.asterisk ? encodeAsterisk(value) : encode(value);
        if (!matches[i2].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
        }
        path3 += token.prefix + segment;
      }
      return path3;
    };
  }
  function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
  }
  function escapeGroup(group) {
    return group.replace(/([=!:$\/()])/g, "\\$1");
  }
  function attachKeys(re, keys) {
    re.keys = keys;
    return re;
  }
  function flags(options) {
    return options && options.sensitive ? "" : "i";
  }
  function regexpToRegexp(path3, keys) {
    var groups = path3.source.match(/\((?!\?)/g);
    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          partial: false,
          asterisk: false,
          pattern: null
        });
      }
    }
    return attachKeys(path3, keys);
  }
  function arrayToRegexp(path3, keys, options) {
    var parts = [];
    for (var i = 0; i < path3.length; i++) {
      parts.push(pathToRegexp2(path3[i], keys, options).source);
    }
    var regexp = new RegExp("(?:" + parts.join("|") + ")", flags(options));
    return attachKeys(regexp, keys);
  }
  function stringToRegexp(path3, keys, options) {
    return tokensToRegExp(parse4(path3, options), keys, options);
  }
  function tokensToRegExp(tokens, keys, options) {
    if (!isarray(keys)) {
      options = keys || options;
      keys = [];
    }
    options = options || {};
    var strict = options.strict;
    var end = options.end !== false;
    var route = "";
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (typeof token === "string") {
        route += escapeString(token);
      } else {
        var prefix2 = escapeString(token.prefix);
        var capture = "(?:" + token.pattern + ")";
        keys.push(token);
        if (token.repeat) {
          capture += "(?:" + prefix2 + capture + ")*";
        }
        if (token.optional) {
          if (!token.partial) {
            capture = "(?:" + prefix2 + "(" + capture + "))?";
          } else {
            capture = prefix2 + "(" + capture + ")?";
          }
        } else {
          capture = prefix2 + "(" + capture + ")";
        }
        route += capture;
      }
    }
    var delimiter = escapeString(options.delimiter || "/");
    var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
    if (!strict) {
      route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?";
    }
    if (end) {
      route += "$";
    } else {
      route += strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)";
    }
    return attachKeys(new RegExp("^" + route, flags(options)), keys);
  }
  function pathToRegexp2(path3, keys, options) {
    if (!isarray(keys)) {
      options = keys || options;
      keys = [];
    }
    options = options || {};
    if (path3 instanceof RegExp) {
      return regexpToRegexp(path3, keys);
    }
    if (isarray(path3)) {
      return arrayToRegexp(path3, keys, options);
    }
    return stringToRegexp(path3, keys, options);
  }
});

// ../../node_modules/react-router/node_modules/react-is/cjs/react-is.production.min.js
var require_react_is_production_min = __commonJS((exports) => {
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  "use strict";
  var b = typeof Symbol === "function" && Symbol.for;
  var c = b ? Symbol.for("react.element") : 60103;
  var d = b ? Symbol.for("react.portal") : 60106;
  var e = b ? Symbol.for("react.fragment") : 60107;
  var f = b ? Symbol.for("react.strict_mode") : 60108;
  var g = b ? Symbol.for("react.profiler") : 60114;
  var h = b ? Symbol.for("react.provider") : 60109;
  var k = b ? Symbol.for("react.context") : 60110;
  var l = b ? Symbol.for("react.async_mode") : 60111;
  var m = b ? Symbol.for("react.concurrent_mode") : 60111;
  var n = b ? Symbol.for("react.forward_ref") : 60112;
  var p = b ? Symbol.for("react.suspense") : 60113;
  var q = b ? Symbol.for("react.suspense_list") : 60120;
  var r = b ? Symbol.for("react.memo") : 60115;
  var t = b ? Symbol.for("react.lazy") : 60116;
  var v = b ? Symbol.for("react.block") : 60121;
  var w = b ? Symbol.for("react.fundamental") : 60117;
  var x = b ? Symbol.for("react.responder") : 60118;
  var y = b ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if (typeof a === "object" && a !== null) {
      var u = a.$$typeof;
      switch (u) {
        case c:
          switch (a = a.type, a) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case n:
                case t:
                case r:
                case h:
                  return a;
                default:
                  return u;
              }
          }
        case d:
          return u;
      }
    }
  }
  function A2(a) {
    return z(a) === m;
  }
  exports.AsyncMode = l;
  exports.ConcurrentMode = m;
  exports.ContextConsumer = k;
  exports.ContextProvider = h;
  exports.Element = c;
  exports.ForwardRef = n;
  exports.Fragment = e;
  exports.Lazy = t;
  exports.Memo = r;
  exports.Portal = d;
  exports.Profiler = g;
  exports.StrictMode = f;
  exports.Suspense = p;
  exports.isAsyncMode = function(a) {
    return A2(a) || z(a) === l;
  };
  exports.isConcurrentMode = A2;
  exports.isContextConsumer = function(a) {
    return z(a) === k;
  };
  exports.isContextProvider = function(a) {
    return z(a) === h;
  };
  exports.isElement = function(a) {
    return typeof a === "object" && a !== null && a.$$typeof === c;
  };
  exports.isForwardRef = function(a) {
    return z(a) === n;
  };
  exports.isFragment = function(a) {
    return z(a) === e;
  };
  exports.isLazy = function(a) {
    return z(a) === t;
  };
  exports.isMemo = function(a) {
    return z(a) === r;
  };
  exports.isPortal = function(a) {
    return z(a) === d;
  };
  exports.isProfiler = function(a) {
    return z(a) === g;
  };
  exports.isStrictMode = function(a) {
    return z(a) === f;
  };
  exports.isSuspense = function(a) {
    return z(a) === p;
  };
  exports.isValidElementType = function(a) {
    return typeof a === "string" || typeof a === "function" || a === e || a === m || a === g || a === f || a === p || a === q || typeof a === "object" && a !== null && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
  };
  exports.typeOf = z;
});

// ../../node_modules/react-router/node_modules/react-is/index.js
var require_react_is = __commonJS((exports, module) => {
  "use strict";
  if (true) {
    module.exports = require_react_is_production_min();
  } else {
    module.exports = null;
  }
});

// ../../node_modules/new-github-issue-url/index.js
var require_new_github_issue_url = __commonJS((exports, module) => {
  "use strict";
  module.exports = (options = {}) => {
    let repoUrl;
    if (options.repoUrl) {
      repoUrl = options.repoUrl;
    } else if (options.user && options.repo) {
      repoUrl = `https://github.com/${options.user}/${options.repo}`;
    } else {
      throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
    }
    const url = new URL(`${repoUrl}/issues/new`);
    const types4 = [
      "body",
      "title",
      "labels",
      "template",
      "milestone",
      "assignee",
      "projects"
    ];
    for (const type of types4) {
      let value = options[type];
      if (value === void 0) {
        continue;
      }
      if (type === "labels" || type === "projects") {
        if (!Array.isArray(value)) {
          throw new TypeError(`The \`${type}\` option should be an array`);
        }
        value = value.join(",");
      }
      url.searchParams.set(type, value);
    }
    return url.toString();
  };
  module.exports.default = module.exports;
});

// ../../node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS((exports, module) => {
  "use strict";
  var isMergeableObject = function isMergeableObject2(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge3(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge3;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge3;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol5) {
      return target.propertyIsEnumerable(symbol5);
    }) : [];
  }
  function getKeys2(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object2, property) {
    try {
      return property in object2;
    } catch (_) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys2(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys2(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge3(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge3.all = function deepmergeAll(array4, options) {
    if (!Array.isArray(array4)) {
      throw new Error("first argument should be an array");
    }
    return array4.reduce(function(prev, next) {
      return deepmerge3(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge3;
  module.exports = deepmerge_1;
});

// ../../node_modules/dot-object/index.js
var require_dot_object = __commonJS((exports, module) => {
  "use strict";
  function _process(v, mod) {
    var i;
    var r;
    if (typeof mod === "function") {
      r = mod(v);
      if (r !== void 0) {
        v = r;
      }
    } else if (Array.isArray(mod)) {
      for (i = 0; i < mod.length; i++) {
        r = mod[i](v);
        if (r !== void 0) {
          v = r;
        }
      }
    }
    return v;
  }
  function parseKey(key, val) {
    if (key[0] === "-" && Array.isArray(val) && /^-\d+$/.test(key)) {
      return val.length + parseInt(key, 10);
    }
    return key;
  }
  function isIndex(k) {
    return /^\d+$/.test(k);
  }
  function isObject3(val) {
    return Object.prototype.toString.call(val) === "[object Object]";
  }
  function isArrayOrObject(val) {
    return Object(val) === val;
  }
  function isEmptyObject(val) {
    return Object.keys(val).length === 0;
  }
  var blacklist = ["__proto__", "prototype", "constructor"];
  var blacklistFilter = function(part) {
    return blacklist.indexOf(part) === -1;
  };
  function parsePath2(path3, sep2) {
    if (path3.indexOf("[") >= 0) {
      path3 = path3.replace(/\[/g, sep2).replace(/]/g, "");
    }
    var parts = path3.split(sep2);
    var check3 = parts.filter(blacklistFilter);
    if (check3.length !== parts.length) {
      throw Error("Refusing to update blacklisted property " + path3);
    }
    return parts;
  }
  var hasOwnProperty5 = Object.prototype.hasOwnProperty;
  function DotObject(separator, override, useArray, useBrackets) {
    if (!(this instanceof DotObject)) {
      return new DotObject(separator, override, useArray, useBrackets);
    }
    if (typeof override === "undefined")
      override = false;
    if (typeof useArray === "undefined")
      useArray = true;
    if (typeof useBrackets === "undefined")
      useBrackets = true;
    this.separator = separator || ".";
    this.override = override;
    this.useArray = useArray;
    this.useBrackets = useBrackets;
    this.keepArray = false;
    this.cleanup = [];
  }
  var dotDefault = new DotObject(".", false, true, true);
  function wrap2(method) {
    return function() {
      return dotDefault[method].apply(dotDefault, arguments);
    };
  }
  DotObject.prototype._fill = function(a, obj, v, mod) {
    var k = a.shift();
    if (a.length > 0) {
      obj[k] = obj[k] || (this.useArray && isIndex(a[0]) ? [] : {});
      if (!isArrayOrObject(obj[k])) {
        if (this.override) {
          obj[k] = {};
        } else {
          if (!(isArrayOrObject(v) && isEmptyObject(v))) {
            throw new Error("Trying to redefine `" + k + "` which is a " + typeof obj[k]);
          }
          return;
        }
      }
      this._fill(a, obj[k], v, mod);
    } else {
      if (!this.override && isArrayOrObject(obj[k]) && !isEmptyObject(obj[k])) {
        if (!(isArrayOrObject(v) && isEmptyObject(v))) {
          throw new Error("Trying to redefine non-empty obj['" + k + "']");
        }
        return;
      }
      obj[k] = _process(v, mod);
    }
  };
  DotObject.prototype.object = function(obj, mods) {
    var self2 = this;
    Object.keys(obj).forEach(function(k) {
      var mod = mods === void 0 ? null : mods[k];
      var ok = parsePath2(k, self2.separator).join(self2.separator);
      if (ok.indexOf(self2.separator) !== -1) {
        self2._fill(ok.split(self2.separator), obj, obj[k], mod);
        delete obj[k];
      } else {
        obj[k] = _process(obj[k], mod);
      }
    });
    return obj;
  };
  DotObject.prototype.str = function(path3, v, obj, mod) {
    var ok = parsePath2(path3, this.separator).join(this.separator);
    if (path3.indexOf(this.separator) !== -1) {
      this._fill(ok.split(this.separator), obj, v, mod);
    } else {
      obj[path3] = _process(v, mod);
    }
    return obj;
  };
  DotObject.prototype.pick = function(path3, obj, remove2, reindexArray) {
    var i;
    var keys;
    var val;
    var key;
    var cp;
    keys = parsePath2(path3, this.separator);
    for (i = 0; i < keys.length; i++) {
      key = parseKey(keys[i], obj);
      if (obj && typeof obj === "object" && key in obj) {
        if (i === keys.length - 1) {
          if (remove2) {
            val = obj[key];
            if (reindexArray && Array.isArray(obj)) {
              obj.splice(key, 1);
            } else {
              delete obj[key];
            }
            if (Array.isArray(obj)) {
              cp = keys.slice(0, -1).join(".");
              if (this.cleanup.indexOf(cp) === -1) {
                this.cleanup.push(cp);
              }
            }
            return val;
          } else {
            return obj[key];
          }
        } else {
          obj = obj[key];
        }
      } else {
        return void 0;
      }
    }
    if (remove2 && Array.isArray(obj)) {
      obj = obj.filter(function(n) {
        return n !== void 0;
      });
    }
    return obj;
  };
  DotObject.prototype.delete = function(path3, obj) {
    return this.remove(path3, obj, true);
  };
  DotObject.prototype.remove = function(path3, obj, reindexArray) {
    var i;
    this.cleanup = [];
    if (Array.isArray(path3)) {
      for (i = 0; i < path3.length; i++) {
        this.pick(path3[i], obj, true, reindexArray);
      }
      if (!reindexArray) {
        this._cleanup(obj);
      }
      return obj;
    } else {
      return this.pick(path3, obj, true, reindexArray);
    }
  };
  DotObject.prototype._cleanup = function(obj) {
    var ret;
    var i;
    var keys;
    var root;
    if (this.cleanup.length) {
      for (i = 0; i < this.cleanup.length; i++) {
        keys = this.cleanup[i].split(".");
        root = keys.splice(0, -1).join(".");
        ret = root ? this.pick(root, obj) : obj;
        ret = ret[keys[0]].filter(function(v) {
          return v !== void 0;
        });
        this.set(this.cleanup[i], ret, obj);
      }
      this.cleanup = [];
    }
  };
  DotObject.prototype.del = DotObject.prototype.remove;
  DotObject.prototype.move = function(source, target, obj, mods, merge) {
    if (typeof mods === "function" || Array.isArray(mods)) {
      this.set(target, _process(this.pick(source, obj, true), mods), obj, merge);
    } else {
      merge = mods;
      this.set(target, this.pick(source, obj, true), obj, merge);
    }
    return obj;
  };
  DotObject.prototype.transfer = function(source, target, obj1, obj2, mods, merge) {
    if (typeof mods === "function" || Array.isArray(mods)) {
      this.set(target, _process(this.pick(source, obj1, true), mods), obj2, merge);
    } else {
      merge = mods;
      this.set(target, this.pick(source, obj1, true), obj2, merge);
    }
    return obj2;
  };
  DotObject.prototype.copy = function(source, target, obj1, obj2, mods, merge) {
    if (typeof mods === "function" || Array.isArray(mods)) {
      this.set(target, _process(JSON.parse(JSON.stringify(this.pick(source, obj1, false))), mods), obj2, merge);
    } else {
      merge = mods;
      this.set(target, this.pick(source, obj1, false), obj2, merge);
    }
    return obj2;
  };
  DotObject.prototype.set = function(path3, val, obj, merge) {
    var i;
    var k;
    var keys;
    var key;
    if (typeof val === "undefined") {
      return obj;
    }
    keys = parsePath2(path3, this.separator);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      if (i === keys.length - 1) {
        if (merge && isObject3(val) && isObject3(obj[key])) {
          for (k in val) {
            if (hasOwnProperty5.call(val, k)) {
              obj[key][k] = val[k];
            }
          }
        } else if (merge && Array.isArray(obj[key]) && Array.isArray(val)) {
          for (var j = 0; j < val.length; j++) {
            obj[keys[i]].push(val[j]);
          }
        } else {
          obj[key] = val;
        }
      } else if (!hasOwnProperty5.call(obj, key) || !isObject3(obj[key]) && !Array.isArray(obj[key])) {
        if (/^\d+$/.test(keys[i + 1])) {
          obj[key] = [];
        } else {
          obj[key] = {};
        }
      }
      obj = obj[key];
    }
    return obj;
  };
  DotObject.prototype.transform = function(recipe, obj, tgt) {
    obj = obj || {};
    tgt = tgt || {};
    Object.keys(recipe).forEach(function(key) {
      this.set(recipe[key], this.pick(key, obj), tgt);
    }.bind(this));
    return tgt;
  };
  DotObject.prototype.dot = function(obj, tgt, path3) {
    tgt = tgt || {};
    path3 = path3 || [];
    var isArray2 = Array.isArray(obj);
    Object.keys(obj).forEach(function(key) {
      var index2 = isArray2 && this.useBrackets ? "[" + key + "]" : key;
      if (isArrayOrObject(obj[key]) && (isObject3(obj[key]) && !isEmptyObject(obj[key]) || Array.isArray(obj[key]) && !this.keepArray && obj[key].length !== 0)) {
        if (isArray2 && this.useBrackets) {
          var previousKey = path3[path3.length - 1] || "";
          return this.dot(obj[key], tgt, path3.slice(0, -1).concat(previousKey + index2));
        } else {
          return this.dot(obj[key], tgt, path3.concat(index2));
        }
      } else {
        if (isArray2 && this.useBrackets) {
          tgt[path3.join(this.separator).concat("[" + key + "]")] = obj[key];
        } else {
          tgt[path3.concat(index2).join(this.separator)] = obj[key];
        }
      }
    }.bind(this));
    return tgt;
  };
  DotObject.pick = wrap2("pick");
  DotObject.move = wrap2("move");
  DotObject.transfer = wrap2("transfer");
  DotObject.transform = wrap2("transform");
  DotObject.copy = wrap2("copy");
  DotObject.object = wrap2("object");
  DotObject.str = wrap2("str");
  DotObject.set = wrap2("set");
  DotObject.delete = wrap2("delete");
  DotObject.del = DotObject.remove = wrap2("remove");
  DotObject.dot = wrap2("dot");
  ["override", "overwrite"].forEach(function(prop) {
    Object.defineProperty(DotObject, prop, {
      get: function() {
        return dotDefault.override;
      },
      set: function(val) {
        dotDefault.override = !!val;
      }
    });
  });
  ["useArray", "keepArray", "useBrackets"].forEach(function(prop) {
    Object.defineProperty(DotObject, prop, {
      get: function() {
        return dotDefault[prop];
      },
      set: function(val) {
        dotDefault[prop] = val;
      }
    });
  });
  DotObject._process = _process;
  module.exports = DotObject;
});

// ../../node_modules/typesafe-actions/dist/typesafe-actions.umd.production.js
var require_typesafe_actions_umd_production = __commonJS((exports, module) => {
  !function(n, t) {
    typeof exports == "object" && typeof module != "undefined" ? t(exports) : typeof define == "function" && define.amd ? define(["exports"], t) : t((n = n || self).TypesafeActions = {});
  }(exports, function(n) {
    "use strict";
    function t(n2) {
      return n2 == null;
    }
    function r(n2) {
      throw new Error("Argument " + n2 + " is empty.");
    }
    function e(n2) {
      return typeof n2 == "function" && "getType" in n2;
    }
    function i(n2) {
      throw new Error("Argument " + n2 + ' is invalid, it should be an action-creator instance from "typesafe-actions"');
    }
    function o(n2, t2) {
      if (n2 == null)
        throw new Error("Argument contains array with empty element at index " + t2);
      if (n2.getType == null)
        throw new Error("Argument contains array with invalid element at index " + t2 + ', it should be an action-creator instance from "typesafe-actions"');
    }
    function u(n2) {
      return typeof n2 == "string" || typeof n2 == "symbol";
    }
    function a(n2) {
      return !u(n2);
    }
    function c(n2) {
      throw new Error("Argument " + n2 + " is invalid, it should be an action type of type: string | symbol");
    }
    function f(n2, t2) {
      if (n2 == null)
        throw new Error("Argument contains array with empty element at index " + t2);
      if (typeof n2 != "string" && typeof n2 != "symbol")
        throw new Error("Argument contains array with invalid element at index " + t2 + ", it should be of type: string | symbol");
    }
    function s(n2, e2, o2, u2) {
      return t(n2) && r(1), a(n2) && i(1), {type: n2, payload: e2, meta: o2, error: u2};
    }
    function y(n2, e2) {
      t(n2) && r(1), a(n2) && c(1);
      return Object.assign(function() {
        var t2 = e2 != null ? e2.apply(void 0, arguments) : void 0;
        return Object.assign({type: n2}, t2);
      }, {getType: function() {
        return n2;
      }, toString: function() {
        return n2;
      }});
    }
    function l(n2, e2, i2) {
      return t(n2) && r(1), a(n2) && c(1), function() {
        return y(n2, function() {
          var n3 = arguments.length <= 0 ? void 0 : arguments[0], t2 = arguments.length <= 1 ? void 0 : arguments[1];
          return e2 == null && i2 == null || (n3 = e2 != null ? e2.apply(void 0, arguments) : void 0, t2 = i2 != null ? i2.apply(void 0, arguments) : void 0), Object.assign({}, n3 !== void 0 && {payload: n3}, {}, t2 !== void 0 && {meta: t2});
        });
      };
    }
    function p(n2) {
      return t(n2) && r(1), e(n2) || i(1), n2.getType();
    }
    function d(n2, e2) {
      t(n2) && r(1), a(n2) && c(1);
      var i2 = e2 != null ? e2(n2) : function() {
        return {type: n2};
      };
      return Object.assign(i2, {getType: function() {
        return n2;
      }, toString: function() {
        return n2;
      }});
    }
    var g = {createAction: function(n2, t2) {
      var r2 = t2 == null ? function() {
        return s(n2);
      } : t2(s.bind(null, n2));
      return Object.assign(r2, {getType: function() {
        return n2;
      }, toString: function() {
        return n2;
      }});
    }, createCustomAction: d, createStandardAction: function(n2) {
      return t(n2) && r(1), a(n2) && c(1), Object.assign(function() {
        return d(n2, function(n3) {
          return function(t2, r2) {
            return {type: n3, payload: t2, meta: r2};
          };
        });
      }, {map: function(t2) {
        return d(n2, function(n3) {
          return function(r2, e2) {
            return Object.assign(t2(r2, e2), {type: n3});
          };
        });
      }});
    }};
    n.action = s, n.createAction = l, n.createAsyncAction = function(n2, t2, r2, e2) {
      return function() {
        var i2 = [n2, t2, r2, e2].map(function(n3, t3) {
          return Array.isArray(n3) ? l(n3[0], n3[1], n3[2])() : typeof n3 == "string" || typeof n3 == "symbol" ? l(n3)() : void (t3 < 3 && function(n4) {
            throw new Error("Argument " + n4 + ' is invalid, it should be an action type of "string | symbol" or a tuple of "[string | symbol, Function, Function?]"');
          }(t3));
        });
        return {request: i2[0], success: i2[1], failure: i2[2], cancel: i2[3]};
      };
    }, n.createCustomAction = y, n.createReducer = function n2(t2, r2) {
      r2 === void 0 && (r2 = {});
      var i2 = Object.assign({}, r2), o2 = function(r3, o3) {
        var a2 = Array.isArray(r3) ? r3 : [r3], c2 = {};
        return a2.map(function(n3, t3) {
          return e(n3) ? p(n3) : u(n3) ? n3 : function(n4) {
            throw new Error("Argument " + n4 + ' is invalid, it should be an action-creator instance from "typesafe-actions" or action type of type: string | symbol');
          }(t3 + 1);
        }).forEach(function(n3) {
          return c2[n3] = o3;
        }), n2(t2, Object.assign({}, i2, {}, c2));
      };
      return Object.assign(function(n3, r3) {
        if (n3 === void 0 && (n3 = t2), i2.hasOwnProperty(r3.type)) {
          var e2 = i2[r3.type];
          if (typeof e2 != "function")
            throw Error('Reducer under "' + r3.type + '" key is not a valid reducer');
          return e2(n3, r3);
        }
        return n3;
      }, {handlers: Object.assign({}, i2), handleAction: o2, handleType: o2});
    }, n.deprecated = g, n.getType = p, n.isActionOf = function(n2, e2) {
      t(n2) && r(1);
      var i2 = Array.isArray(n2) ? n2 : [n2];
      i2.forEach(o);
      var u2 = function(n3) {
        return i2.some(function(t2) {
          return n3.type === t2.getType();
        });
      };
      return e2 === void 0 ? u2 : u2(e2);
    }, n.isOfType = function(n2, e2) {
      t(n2) && r(1);
      var i2 = Array.isArray(n2) ? n2 : [n2];
      i2.forEach(f);
      var o2 = function(n3) {
        return i2.includes(n3.type);
      };
      return e2 === void 0 ? o2 : o2(e2);
    };
  });
});

// ../../node_modules/remove-accents/index.js
var require_remove_accents = __commonJS((exports, module) => {
  var characterMap = {
    \u00C0: "A",
    \u00C1: "A",
    \u00C2: "A",
    \u00C3: "A",
    \u00C4: "A",
    \u00C5: "A",
    \u1EA4: "A",
    \u1EAE: "A",
    \u1EB2: "A",
    \u1EB4: "A",
    \u1EB6: "A",
    \u00C6: "AE",
    \u1EA6: "A",
    \u1EB0: "A",
    \u0202: "A",
    \u00C7: "C",
    \u1E08: "C",
    \u00C8: "E",
    \u00C9: "E",
    \u00CA: "E",
    \u00CB: "E",
    \u1EBE: "E",
    \u1E16: "E",
    \u1EC0: "E",
    \u1E14: "E",
    \u1E1C: "E",
    \u0206: "E",
    \u00CC: "I",
    \u00CD: "I",
    \u00CE: "I",
    \u00CF: "I",
    \u1E2E: "I",
    \u020A: "I",
    \u00D0: "D",
    \u00D1: "N",
    \u00D2: "O",
    \u00D3: "O",
    \u00D4: "O",
    \u00D5: "O",
    \u00D6: "O",
    \u00D8: "O",
    \u1ED0: "O",
    \u1E4C: "O",
    \u1E52: "O",
    \u020E: "O",
    \u00D9: "U",
    \u00DA: "U",
    \u00DB: "U",
    \u00DC: "U",
    \u00DD: "Y",
    \u00E0: "a",
    \u00E1: "a",
    \u00E2: "a",
    \u00E3: "a",
    \u00E4: "a",
    \u00E5: "a",
    \u1EA5: "a",
    \u1EAF: "a",
    \u1EB3: "a",
    \u1EB5: "a",
    \u1EB7: "a",
    \u00E6: "ae",
    \u1EA7: "a",
    \u1EB1: "a",
    \u0203: "a",
    \u00E7: "c",
    \u1E09: "c",
    \u00E8: "e",
    \u00E9: "e",
    \u00EA: "e",
    \u00EB: "e",
    \u1EBF: "e",
    \u1E17: "e",
    \u1EC1: "e",
    \u1E15: "e",
    \u1E1D: "e",
    \u0207: "e",
    \u00EC: "i",
    \u00ED: "i",
    \u00EE: "i",
    \u00EF: "i",
    \u1E2F: "i",
    \u020B: "i",
    \u00F0: "d",
    \u00F1: "n",
    \u00F2: "o",
    \u00F3: "o",
    \u00F4: "o",
    \u00F5: "o",
    \u00F6: "o",
    \u00F8: "o",
    \u1ED1: "o",
    \u1E4D: "o",
    \u1E53: "o",
    \u020F: "o",
    \u00F9: "u",
    \u00FA: "u",
    \u00FB: "u",
    \u00FC: "u",
    \u00FD: "y",
    \u00FF: "y",
    \u0100: "A",
    \u0101: "a",
    \u0102: "A",
    \u0103: "a",
    \u0104: "A",
    \u0105: "a",
    \u0106: "C",
    \u0107: "c",
    \u0108: "C",
    \u0109: "c",
    \u010A: "C",
    \u010B: "c",
    \u010C: "C",
    \u010D: "c",
    C\u0306: "C",
    c\u0306: "c",
    \u010E: "D",
    \u010F: "d",
    \u0110: "D",
    \u0111: "d",
    \u0112: "E",
    \u0113: "e",
    \u0114: "E",
    \u0115: "e",
    \u0116: "E",
    \u0117: "e",
    \u0118: "E",
    \u0119: "e",
    \u011A: "E",
    \u011B: "e",
    \u011C: "G",
    \u01F4: "G",
    \u011D: "g",
    \u01F5: "g",
    \u011E: "G",
    \u011F: "g",
    \u0120: "G",
    \u0121: "g",
    \u0122: "G",
    \u0123: "g",
    \u0124: "H",
    \u0125: "h",
    \u0126: "H",
    \u0127: "h",
    \u1E2A: "H",
    \u1E2B: "h",
    \u0128: "I",
    \u0129: "i",
    \u012A: "I",
    \u012B: "i",
    \u012C: "I",
    \u012D: "i",
    \u012E: "I",
    \u012F: "i",
    \u0130: "I",
    \u0131: "i",
    \u0132: "IJ",
    \u0133: "ij",
    \u0134: "J",
    \u0135: "j",
    \u0136: "K",
    \u0137: "k",
    \u1E30: "K",
    \u1E31: "k",
    K\u0306: "K",
    k\u0306: "k",
    \u0139: "L",
    \u013A: "l",
    \u013B: "L",
    \u013C: "l",
    \u013D: "L",
    \u013E: "l",
    \u013F: "L",
    \u0140: "l",
    \u0141: "l",
    \u0142: "l",
    \u1E3E: "M",
    \u1E3F: "m",
    M\u0306: "M",
    m\u0306: "m",
    \u0143: "N",
    \u0144: "n",
    \u0145: "N",
    \u0146: "n",
    \u0147: "N",
    \u0148: "n",
    \u0149: "n",
    N\u0306: "N",
    n\u0306: "n",
    \u014C: "O",
    \u014D: "o",
    \u014E: "O",
    \u014F: "o",
    \u0150: "O",
    \u0151: "o",
    \u0152: "OE",
    \u0153: "oe",
    P\u0306: "P",
    p\u0306: "p",
    \u0154: "R",
    \u0155: "r",
    \u0156: "R",
    \u0157: "r",
    \u0158: "R",
    \u0159: "r",
    R\u0306: "R",
    r\u0306: "r",
    \u0212: "R",
    \u0213: "r",
    \u015A: "S",
    \u015B: "s",
    \u015C: "S",
    \u015D: "s",
    \u015E: "S",
    \u0218: "S",
    \u0219: "s",
    \u015F: "s",
    \u0160: "S",
    \u0161: "s",
    \u0162: "T",
    \u0163: "t",
    \u021B: "t",
    \u021A: "T",
    \u0164: "T",
    \u0165: "t",
    \u0166: "T",
    \u0167: "t",
    T\u0306: "T",
    t\u0306: "t",
    \u0168: "U",
    \u0169: "u",
    \u016A: "U",
    \u016B: "u",
    \u016C: "U",
    \u016D: "u",
    \u016E: "U",
    \u016F: "u",
    \u0170: "U",
    \u0171: "u",
    \u0172: "U",
    \u0173: "u",
    \u0216: "U",
    \u0217: "u",
    V\u0306: "V",
    v\u0306: "v",
    \u0174: "W",
    \u0175: "w",
    \u1E82: "W",
    \u1E83: "w",
    X\u0306: "X",
    x\u0306: "x",
    \u0176: "Y",
    \u0177: "y",
    \u0178: "Y",
    Y\u0306: "Y",
    y\u0306: "y",
    \u0179: "Z",
    \u017A: "z",
    \u017B: "Z",
    \u017C: "z",
    \u017D: "Z",
    \u017E: "z",
    \u017F: "s",
    \u0192: "f",
    \u01A0: "O",
    \u01A1: "o",
    \u01AF: "U",
    \u01B0: "u",
    \u01CD: "A",
    \u01CE: "a",
    \u01CF: "I",
    \u01D0: "i",
    \u01D1: "O",
    \u01D2: "o",
    \u01D3: "U",
    \u01D4: "u",
    \u01D5: "U",
    \u01D6: "u",
    \u01D7: "U",
    \u01D8: "u",
    \u01D9: "U",
    \u01DA: "u",
    \u01DB: "U",
    \u01DC: "u",
    \u1EE8: "U",
    \u1EE9: "u",
    \u1E78: "U",
    \u1E79: "u",
    \u01FA: "A",
    \u01FB: "a",
    \u01FC: "AE",
    \u01FD: "ae",
    \u01FE: "O",
    \u01FF: "o",
    \u00DE: "TH",
    \u00FE: "th",
    \u1E54: "P",
    \u1E55: "p",
    \u1E64: "S",
    \u1E65: "s",
    X\u0301: "X",
    x\u0301: "x",
    \u0403: "\u0413",
    \u0453: "\u0433",
    \u040C: "\u041A",
    \u045C: "\u043A",
    A\u030B: "A",
    a\u030B: "a",
    E\u030B: "E",
    e\u030B: "e",
    I\u030B: "I",
    i\u030B: "i",
    \u01F8: "N",
    \u01F9: "n",
    \u1ED2: "O",
    \u1ED3: "o",
    \u1E50: "O",
    \u1E51: "o",
    \u1EEA: "U",
    \u1EEB: "u",
    \u1E80: "W",
    \u1E81: "w",
    \u1EF2: "Y",
    \u1EF3: "y",
    \u0200: "A",
    \u0201: "a",
    \u0204: "E",
    \u0205: "e",
    \u0208: "I",
    \u0209: "i",
    \u020C: "O",
    \u020D: "o",
    \u0210: "R",
    \u0211: "r",
    \u0214: "U",
    \u0215: "u",
    B\u030C: "B",
    b\u030C: "b",
    \u010C\u0323: "C",
    \u010D\u0323: "c",
    \u00CA\u030C: "E",
    \u00EA\u030C: "e",
    F\u030C: "F",
    f\u030C: "f",
    \u01E6: "G",
    \u01E7: "g",
    \u021E: "H",
    \u021F: "h",
    J\u030C: "J",
    \u01F0: "j",
    \u01E8: "K",
    \u01E9: "k",
    M\u030C: "M",
    m\u030C: "m",
    P\u030C: "P",
    p\u030C: "p",
    Q\u030C: "Q",
    q\u030C: "q",
    \u0158\u0329: "R",
    \u0159\u0329: "r",
    \u1E66: "S",
    \u1E67: "s",
    V\u030C: "V",
    v\u030C: "v",
    W\u030C: "W",
    w\u030C: "w",
    X\u030C: "X",
    x\u030C: "x",
    Y\u030C: "Y",
    y\u030C: "y",
    A\u0327: "A",
    a\u0327: "a",
    B\u0327: "B",
    b\u0327: "b",
    \u1E10: "D",
    \u1E11: "d",
    \u0228: "E",
    \u0229: "e",
    \u0190\u0327: "E",
    \u025B\u0327: "e",
    \u1E28: "H",
    \u1E29: "h",
    I\u0327: "I",
    i\u0327: "i",
    \u0197\u0327: "I",
    \u0268\u0327: "i",
    M\u0327: "M",
    m\u0327: "m",
    O\u0327: "O",
    o\u0327: "o",
    Q\u0327: "Q",
    q\u0327: "q",
    U\u0327: "U",
    u\u0327: "u",
    X\u0327: "X",
    x\u0327: "x",
    Z\u0327: "Z",
    z\u0327: "z"
  };
  var chars = Object.keys(characterMap).join("|");
  var allAccents = new RegExp(chars, "g");
  var firstAccent = new RegExp(chars, "");
  var removeAccents2 = function(string5) {
    return string5.replace(allAccents, function(match) {
      return characterMap[match];
    });
  };
  var hasAccents = function(string5) {
    return !!string5.match(firstAccent);
  };
  module.exports = removeAccents2;
  module.exports.has = hasAccents;
  module.exports.remove = removeAccents2;
});

// ../../node_modules/react-redux/node_modules/react-is/cjs/react-is.production.min.js
var require_react_is_production_min2 = __commonJS((exports) => {
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  "use strict";
  var b = typeof Symbol === "function" && Symbol.for;
  var c = b ? Symbol.for("react.element") : 60103;
  var d = b ? Symbol.for("react.portal") : 60106;
  var e = b ? Symbol.for("react.fragment") : 60107;
  var f = b ? Symbol.for("react.strict_mode") : 60108;
  var g = b ? Symbol.for("react.profiler") : 60114;
  var h = b ? Symbol.for("react.provider") : 60109;
  var k = b ? Symbol.for("react.context") : 60110;
  var l = b ? Symbol.for("react.async_mode") : 60111;
  var m = b ? Symbol.for("react.concurrent_mode") : 60111;
  var n = b ? Symbol.for("react.forward_ref") : 60112;
  var p = b ? Symbol.for("react.suspense") : 60113;
  var q = b ? Symbol.for("react.suspense_list") : 60120;
  var r = b ? Symbol.for("react.memo") : 60115;
  var t = b ? Symbol.for("react.lazy") : 60116;
  var v = b ? Symbol.for("react.block") : 60121;
  var w = b ? Symbol.for("react.fundamental") : 60117;
  var x = b ? Symbol.for("react.responder") : 60118;
  var y = b ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if (typeof a === "object" && a !== null) {
      var u = a.$$typeof;
      switch (u) {
        case c:
          switch (a = a.type, a) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case n:
                case t:
                case r:
                case h:
                  return a;
                default:
                  return u;
              }
          }
        case d:
          return u;
      }
    }
  }
  function A2(a) {
    return z(a) === m;
  }
  exports.AsyncMode = l;
  exports.ConcurrentMode = m;
  exports.ContextConsumer = k;
  exports.ContextProvider = h;
  exports.Element = c;
  exports.ForwardRef = n;
  exports.Fragment = e;
  exports.Lazy = t;
  exports.Memo = r;
  exports.Portal = d;
  exports.Profiler = g;
  exports.StrictMode = f;
  exports.Suspense = p;
  exports.isAsyncMode = function(a) {
    return A2(a) || z(a) === l;
  };
  exports.isConcurrentMode = A2;
  exports.isContextConsumer = function(a) {
    return z(a) === k;
  };
  exports.isContextProvider = function(a) {
    return z(a) === h;
  };
  exports.isElement = function(a) {
    return typeof a === "object" && a !== null && a.$$typeof === c;
  };
  exports.isForwardRef = function(a) {
    return z(a) === n;
  };
  exports.isFragment = function(a) {
    return z(a) === e;
  };
  exports.isLazy = function(a) {
    return z(a) === t;
  };
  exports.isMemo = function(a) {
    return z(a) === r;
  };
  exports.isPortal = function(a) {
    return z(a) === d;
  };
  exports.isProfiler = function(a) {
    return z(a) === g;
  };
  exports.isStrictMode = function(a) {
    return z(a) === f;
  };
  exports.isSuspense = function(a) {
    return z(a) === p;
  };
  exports.isValidElementType = function(a) {
    return typeof a === "string" || typeof a === "function" || a === e || a === m || a === g || a === f || a === p || a === q || typeof a === "object" && a !== null && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
  };
  exports.typeOf = z;
});

// ../../node_modules/react-redux/node_modules/react-is/index.js
var require_react_is2 = __commonJS((exports, module) => {
  "use strict";
  if (true) {
    module.exports = require_react_is_production_min2();
  } else {
    module.exports = null;
  }
});

// ../../node_modules/symbol-observable/lib/ponyfill.js
var require_ponyfill = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = symbolObservablePonyfill2;
  function symbolObservablePonyfill2(root) {
    var result;
    var _Symbol = root.Symbol;
    if (typeof _Symbol === "function") {
      if (_Symbol.observable) {
        result = _Symbol.observable;
      } else {
        result = _Symbol("observable");
        _Symbol.observable = result;
      }
    } else {
      result = "@@observable";
    }
    return result;
  }
});

// ../../node_modules/symbol-observable/lib/index.js
var require_lib = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _ponyfill = require_ponyfill();
  var _ponyfill2 = _interopRequireDefault(_ponyfill);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var root;
  if (typeof self !== "undefined") {
    root = self;
  } else if (typeof window !== "undefined") {
    root = window;
  } else if (typeof self !== "undefined") {
    root = self;
  } else if (typeof module !== "undefined") {
    root = module;
  } else {
    root = Function("return this")();
  }
  var result = (0, _ponyfill2["default"])(root);
  exports["default"] = result;
});

// ../../node_modules/redux/lib/redux.js
var require_redux = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var $$observable = _interopDefault(require_lib());
  var randomString = function randomString2() {
    return Math.random().toString(36).substring(7).split("").join(".");
  };
  var ActionTypes = {
    INIT: "@@redux/INIT" + randomString(),
    REPLACE: "@@redux/REPLACE" + randomString(),
    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
      return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
    }
  };
  function isPlainObject2(obj) {
    if (typeof obj !== "object" || obj === null)
      return false;
    var proto = obj;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(obj) === proto;
  }
  function createStore(reducer8, preloadedState, enhancer) {
    var _ref2;
    if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
      throw new Error("It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function.");
    }
    if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
      enhancer = preloadedState;
      preloadedState = void 0;
    }
    if (typeof enhancer !== "undefined") {
      if (typeof enhancer !== "function") {
        throw new Error("Expected the enhancer to be a function.");
      }
      return enhancer(createStore)(reducer8, preloadedState);
    }
    if (typeof reducer8 !== "function") {
      throw new Error("Expected the reducer to be a function.");
    }
    var currentReducer = reducer8;
    var currentState = preloadedState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;
    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }
    function getState() {
      if (isDispatching) {
        throw new Error("You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
      }
      return currentState;
    }
    function subscribe5(listener) {
      if (typeof listener !== "function") {
        throw new Error("Expected the listener to be a function.");
      }
      if (isDispatching) {
        throw new Error("You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api-reference/store#subscribelistener for more details.");
      }
      var isSubscribed = true;
      ensureCanMutateNextListeners();
      nextListeners.push(listener);
      return function unsubscribe5() {
        if (!isSubscribed) {
          return;
        }
        if (isDispatching) {
          throw new Error("You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api-reference/store#subscribelistener for more details.");
        }
        isSubscribed = false;
        ensureCanMutateNextListeners();
        var index2 = nextListeners.indexOf(listener);
        nextListeners.splice(index2, 1);
        currentListeners = null;
      };
    }
    function dispatch2(action) {
      if (!isPlainObject2(action)) {
        throw new Error("Actions must be plain objects. Use custom middleware for async actions.");
      }
      if (typeof action.type === "undefined") {
        throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');
      }
      if (isDispatching) {
        throw new Error("Reducers may not dispatch actions.");
      }
      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }
      var listeners = currentListeners = nextListeners;
      for (var i = 0; i < listeners.length; i++) {
        var listener = listeners[i];
        listener();
      }
      return action;
    }
    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== "function") {
        throw new Error("Expected the nextReducer to be a function.");
      }
      currentReducer = nextReducer;
      dispatch2({
        type: ActionTypes.REPLACE
      });
    }
    function observable() {
      var _ref3;
      var outerSubscribe = subscribe5;
      return _ref3 = {
        subscribe: function subscribe6(observer) {
          if (typeof observer !== "object" || observer === null) {
            throw new TypeError("Expected the observer to be an object.");
          }
          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }
          observeState();
          var unsubscribe5 = outerSubscribe(observeState);
          return {
            unsubscribe: unsubscribe5
          };
        }
      }, _ref3[$$observable] = function() {
        return this;
      }, _ref3;
    }
    dispatch2({
      type: ActionTypes.INIT
    });
    return _ref2 = {
      dispatch: dispatch2,
      subscribe: subscribe5,
      getState,
      replaceReducer
    }, _ref2[$$observable] = observable, _ref2;
  }
  function getUndefinedStateErrorMessage(key, action) {
    var actionType = action && action.type;
    var actionDescription = actionType && 'action "' + String(actionType) + '"' || "an action";
    return "Given " + actionDescription + ', reducer "' + key + '" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.';
  }
  function assertReducerShape(reducers) {
    Object.keys(reducers).forEach(function(key) {
      var reducer8 = reducers[key];
      var initialState5 = reducer8(void 0, {
        type: ActionTypes.INIT
      });
      if (typeof initialState5 === "undefined") {
        throw new Error('Reducer "' + key + `" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
      }
      if (typeof reducer8(void 0, {
        type: ActionTypes.PROBE_UNKNOWN_ACTION()
      }) === "undefined") {
        throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ("Don't try to handle " + ActionTypes.INIT + ' or other actions in "redux/*" ') + "namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.");
      }
    });
  }
  function combineReducers2(reducers) {
    var reducerKeys = Object.keys(reducers);
    var finalReducers = {};
    for (var i = 0; i < reducerKeys.length; i++) {
      var key = reducerKeys[i];
      if (false) {
        if (typeof reducers[key] === "undefined") {
          warning2('No reducer provided for key "' + key + '"');
        }
      }
      if (typeof reducers[key] === "function") {
        finalReducers[key] = reducers[key];
      }
    }
    var finalReducerKeys = Object.keys(finalReducers);
    var unexpectedKeyCache;
    if (false) {
      unexpectedKeyCache = {};
    }
    var shapeAssertionError;
    try {
      assertReducerShape(finalReducers);
    } catch (e) {
      shapeAssertionError = e;
    }
    return function combination(state, action) {
      if (state === void 0) {
        state = {};
      }
      if (shapeAssertionError) {
        throw shapeAssertionError;
      }
      if (false) {
        var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
        if (warningMessage) {
          warning2(warningMessage);
        }
      }
      var hasChanged = false;
      var nextState = {};
      for (var _i = 0; _i < finalReducerKeys.length; _i++) {
        var _key = finalReducerKeys[_i];
        var reducer8 = finalReducers[_key];
        var previousStateForKey = state[_key];
        var nextStateForKey = reducer8(previousStateForKey, action);
        if (typeof nextStateForKey === "undefined") {
          var errorMessage = getUndefinedStateErrorMessage(_key, action);
          throw new Error(errorMessage);
        }
        nextState[_key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }
      hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
      return hasChanged ? nextState : state;
    };
  }
  function bindActionCreator(actionCreator, dispatch2) {
    return function() {
      return dispatch2(actionCreator.apply(this, arguments));
    };
  }
  function bindActionCreators(actionCreators, dispatch2) {
    if (typeof actionCreators === "function") {
      return bindActionCreator(actionCreators, dispatch2);
    }
    if (typeof actionCreators !== "object" || actionCreators === null) {
      throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? "null" : typeof actionCreators) + '. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
    }
    var boundActionCreators = {};
    for (var key in actionCreators) {
      var actionCreator = actionCreators[key];
      if (typeof actionCreator === "function") {
        boundActionCreators[key] = bindActionCreator(actionCreator, dispatch2);
      }
    }
    return boundActionCreators;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      keys.push.apply(keys, Object.getOwnPropertySymbols(object2));
    }
    if (enumerableOnly)
      keys = keys.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(source, true).forEach(function(key) {
          _defineProperty2(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function compose2() {
    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }
    if (funcs.length === 0) {
      return function(arg) {
        return arg;
      };
    }
    if (funcs.length === 1) {
      return funcs[0];
    }
    return funcs.reduce(function(a, b) {
      return function() {
        return a(b.apply(void 0, arguments));
      };
    });
  }
  function applyMiddleware2() {
    for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }
    return function(createStore2) {
      return function() {
        var store = createStore2.apply(void 0, arguments);
        var _dispatch = function dispatch2() {
          throw new Error("Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
        };
        var middlewareAPI = {
          getState: store.getState,
          dispatch: function dispatch2() {
            return _dispatch.apply(void 0, arguments);
          }
        };
        var chain = middlewares.map(function(middleware) {
          return middleware(middlewareAPI);
        });
        _dispatch = compose2.apply(void 0, chain)(store.dispatch);
        return _objectSpread2({}, store, {
          dispatch: _dispatch
        });
      };
    };
  }
  if (false) {
    warning2('You are currently using minified code outside of NODE_ENV === "production". This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) to ensure you have the correct code for your production build.');
  }
  exports.__DO_NOT_USE__ActionTypes = ActionTypes;
  exports.applyMiddleware = applyMiddleware2;
  exports.bindActionCreators = bindActionCreators;
  exports.combineReducers = combineReducers2;
  exports.compose = compose2;
  exports.createStore = createStore;
});

// ../../node_modules/redux-devtools-extension/index.js
var require_redux_devtools_extension = __commonJS((exports) => {
  "use strict";
  var compose2 = require_redux().compose;
  exports.__esModule = true;
  exports.composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
    if (arguments.length === 0)
      return void 0;
    if (typeof arguments[0] === "object")
      return compose2;
    return compose2.apply(null, arguments);
  };
  exports.devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
    return function(noop5) {
      return noop5;
    };
  };
});

// ../../node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS((exports, module) => {
  "use strict";
  module.exports = function bind2(fn, thisArg) {
    return function wrap2() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
});

// ../../node_modules/axios/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  "use strict";
  var bind2 = require_bind();
  var toString5 = Object.prototype.toString;
  function isArray2(val) {
    return toString5.call(val) === "[object Array]";
  }
  function isUndefined2(val) {
    return typeof val === "undefined";
  }
  function isBuffer(val) {
    return val !== null && !isUndefined2(val) && val.constructor !== null && !isUndefined2(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  function isArrayBuffer(val) {
    return toString5.call(val) === "[object ArrayBuffer]";
  }
  function isFormData(val) {
    return typeof FormData !== "undefined" && val instanceof FormData;
  }
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }
    return result;
  }
  function isString2(val) {
    return typeof val === "string";
  }
  function isNumber2(val) {
    return typeof val === "number";
  }
  function isObject3(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject2(val) {
    if (toString5.call(val) !== "[object Object]") {
      return false;
    }
    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  function isDate(val) {
    return toString5.call(val) === "[object Date]";
  }
  function isFile(val) {
    return toString5.call(val) === "[object File]";
  }
  function isBlob(val) {
    return toString5.call(val) === "[object Blob]";
  }
  function isFunction(val) {
    return toString5.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject3(val) && isFunction(val.pipe);
  }
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
  }
  function trim2(str) {
    return str.replace(/^\s*/, "").replace(/\s*$/, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach2(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray2(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge() {
    var result = {};
    function assignValue(val, key) {
      if (isPlainObject2(result[key]) && isPlainObject2(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject2(val)) {
        result[key] = merge({}, val);
      } else if (isArray2(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }
    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach2(arguments[i], assignValue);
    }
    return result;
  }
  function extend(a, b, thisArg) {
    forEach2(b, function assignValue(val, key) {
      if (thisArg && typeof val === "function") {
        a[key] = bind2(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  module.exports = {
    isArray: isArray2,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString: isString2,
    isNumber: isNumber2,
    isObject: isObject3,
    isPlainObject: isPlainObject2,
    isUndefined: isUndefined2,
    isDate,
    isFile,
    isBlob,
    isFunction,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach: forEach2,
    merge,
    extend,
    trim: trim2,
    stripBOM
  };
});

// ../../node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS((exports, module) => {
  "use strict";
  var utils = require_utils();
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  module.exports = function buildURL(url, params, paramsSerializer) {
    if (!params) {
      return url;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }
        utils.forEach(val, function parseValue(v) {
          if (utils.isDate(v)) {
            v = v.toISOString();
          } else if (utils.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + "=" + encode(v));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  };
});

// ../../node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS((exports, module) => {
  "use strict";
  var utils = require_utils();
  function InterceptorManager() {
    this.handlers = [];
  }
  InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled,
      rejected
    });
    return this.handlers.length - 1;
  };
  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager.prototype.forEach = function forEach2(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };
  module.exports = InterceptorManager;
});

// ../../node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS((exports, module) => {
  "use strict";
  var utils = require_utils();
  module.exports = function transformData(data, headers2, fns) {
    utils.forEach(fns, function transform(fn) {
      data = fn(data, headers2);
    });
    return data;
  };
});

// ../../node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS((exports, module) => {
  "use strict";
  module.exports = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };
});

// ../../node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS((exports, module) => {
  "use strict";
  var utils = require_utils();
  module.exports = function normalizeHeaderName(headers2, normalizedName) {
    utils.forEach(headers2, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers2[normalizedName] = value;
        delete headers2[name];
      }
    });
  };
});

// ../../node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS((exports, module) => {
  "use strict";
  module.exports = function enhanceError(error, config, code3, request, response) {
    error.config = config;
    if (code3) {
      error.code = code3;
    }
    error.request = request;
    error.response = response;
    error.isAxiosError = true;
    error.toJSON = function toJSON() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: this.config,
        code: this.code
      };
    };
    return error;
  };
});

// ../../node_modules/axios/lib/core/createError.js
var require_createError = __commonJS((exports, module) => {
  "use strict";
  var enhanceError = require_enhanceError();
  module.exports = function createError(message, config, code3, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code3, request, response);
  };
});

// ../../node_modules/axios/lib/core/settle.js
var require_settle = __commonJS((exports, module) => {
  "use strict";
  var createError = require_createError();
  module.exports = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
    }
  };
});

// ../../node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS((exports, module) => {
  "use strict";
  var utils = require_utils();
  module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path3, domain, secure) {
        var cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils.isString(path3)) {
          cookie.push("path=" + path3);
        }
        if (utils.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove2(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove2() {
      }
    };
  }();
});

// ../../node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS((exports, module) => {
  "use strict";
  module.exports = function isAbsoluteURL(url) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };
});

// ../../node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS((exports, module) => {
  "use strict";
  module.exports = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
});

// ../../node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS((exports, module) => {
  "use strict";
  var isAbsoluteURL = require_isAbsoluteURL();
  var combineURLs = require_combineURLs();
  module.exports = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  };
});

// ../../node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS((exports, module) => {
  "use strict";
  var utils = require_utils();
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  module.exports = function parseHeaders(headers2) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers2) {
      return parsed;
    }
    utils.forEach(headers2.split("\n"), function parser(line) {
      i = line.indexOf(":");
      key = utils.trim(line.substr(0, i)).toLowerCase();
      val = utils.trim(line.substr(i + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
});

// ../../node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS((exports, module) => {
  "use strict";
  var utils = require_utils();
  module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }();
});

// ../../node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS((exports, module) => {
  "use strict";
  var utils = require_utils();
  var settle = require_settle();
  var cookies = require_cookies();
  var buildURL = require_buildURL();
  var buildFullPath = require_buildFullPath();
  var parseHeaders = require_parseHeaders();
  var isURLSameOrigin = require_isURLSameOrigin();
  var createError = require_createError();
  module.exports = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      if (utils.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath(config.baseURL, config.url);
      request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
      request.timeout = config.timeout;
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === "text" ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(resolve, reject, response);
        request = null;
      };
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(createError("Request aborted", config, "ECONNABORTED", request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(createError("Network Error", config, null, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(createError(timeoutErrorMessage, config, "ECONNABORTED", request));
        request = null;
      };
      if (utils.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request) {
        utils.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request.setRequestHeader(key, val);
          }
        });
      }
      if (!utils.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      }
      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          if (config.responseType !== "json") {
            throw e;
          }
        }
      }
      if (typeof config.onDownloadProgress === "function") {
        request.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken) {
        config.cancelToken.promise.then(function onCanceled(cancel2) {
          if (!request) {
            return;
          }
          request.abort();
          reject(cancel2);
          request = null;
        });
      }
      if (!requestData) {
        requestData = null;
      }
      request.send(requestData);
    });
  };
});

// ../../node_modules/axios/lib/defaults.js
var require_defaults = __commonJS((exports, module) => {
  "use strict";
  var utils = require_utils();
  var normalizeHeaderName = require_normalizeHeaderName();
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers2, value) {
    if (!utils.isUndefined(headers2) && utils.isUndefined(headers2["Content-Type"])) {
      headers2["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = require_xhr();
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = require_xhr();
    }
    return adapter;
  }
  var defaults = {
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers2) {
      normalizeHeaderName(headers2, "Accept");
      normalizeHeaderName(headers2, "Content-Type");
      if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
        return data;
      }
      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers2, "application/x-www-form-urlencoded;charset=utf-8");
        return data.toString();
      }
      if (utils.isObject(data)) {
        setContentTypeIfUnset(headers2, "application/json;charset=utf-8");
        return JSON.stringify(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      if (typeof data === "string") {
        try {
          data = JSON.parse(data);
        } catch (e) {
        }
      }
      return data;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status2) {
      return status2 >= 200 && status2 < 300;
    }
  };
  defaults.headers = {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  };
  utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });
  utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
  });
  module.exports = defaults;
});

// ../../node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS((exports, module) => {
  "use strict";
  var utils = require_utils();
  var transformData = require_transformData();
  var isCancel = require_isCancel();
  var defaults = require_defaults();
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  module.exports = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData(config.data, config.headers, config.transformRequest);
    config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData(response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
        }
      }
      return Promise.reject(reason);
    });
  };
});

// ../../node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS((exports, module) => {
  "use strict";
  var utils = require_utils();
  module.exports = function mergeConfig(config1, config2) {
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = ["url", "method", "data"];
    var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
    var defaultToConfig2Keys = [
      "baseURL",
      "transformRequest",
      "transformResponse",
      "paramsSerializer",
      "timeout",
      "timeoutMessage",
      "withCredentials",
      "adapter",
      "responseType",
      "xsrfCookieName",
      "xsrfHeaderName",
      "onUploadProgress",
      "onDownloadProgress",
      "decompress",
      "maxContentLength",
      "maxBodyLength",
      "maxRedirects",
      "transport",
      "httpAgent",
      "httpsAgent",
      "cancelToken",
      "socketPath",
      "responseEncoding"
    ];
    var directMergeKeys = ["validateStatus"];
    function getMergedValue(target, source) {
      if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
        return utils.merge(target, source);
      } else if (utils.isPlainObject(source)) {
        return utils.merge({}, source);
      } else if (utils.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (!utils.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    }
    utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      }
    });
    utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      } else if (!utils.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    utils.forEach(directMergeKeys, function merge(prop) {
      if (prop in config2) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });
    utils.forEach(otherKeys, mergeDeepProperties);
    return config;
  };
});

// ../../node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS((exports, module) => {
  "use strict";
  var utils = require_utils();
  var buildURL = require_buildURL();
  var InterceptorManager = require_InterceptorManager();
  var dispatchRequest = require_dispatchRequest();
  var mergeConfig = require_mergeConfig();
  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios.prototype.request = function request(config) {
    if (typeof config === "string") {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }
    config = mergeConfig(this.defaults, config);
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = "get";
    }
    var chain = [dispatchRequest, void 0];
    var promise3 = Promise.resolve(config);
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });
    while (chain.length) {
      promise3 = promise3.then(chain.shift(), chain.shift());
    }
    return promise3;
  };
  Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
  };
  utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    Axios.prototype[method] = function(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url,
        data
      }));
    };
  });
  module.exports = Axios;
});

// ../../node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS((exports, module) => {
  "use strict";
  function Cancel(message) {
    this.message = message;
  }
  Cancel.prototype.toString = function toString5() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel.prototype.__CANCEL__ = true;
  module.exports = Cancel;
});

// ../../node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS((exports, module) => {
  "use strict";
  var Cancel = require_Cancel();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise2;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise2 = resolve;
    });
    var token = this;
    executor(function cancel2(message) {
      if (token.reason) {
        return;
      }
      token.reason = new Cancel(message);
      resolvePromise2(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.source = function source() {
    var cancel2;
    var token = new CancelToken(function executor(c) {
      cancel2 = c;
    });
    return {
      token,
      cancel: cancel2
    };
  };
  module.exports = CancelToken;
});

// ../../node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS((exports, module) => {
  "use strict";
  module.exports = function spread(callback) {
    return function wrap2(arr) {
      return callback.apply(null, arr);
    };
  };
});

// ../../node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS((exports, module) => {
  "use strict";
  module.exports = function isAxiosError(payload) {
    return typeof payload === "object" && payload.isAxiosError === true;
  };
});

// ../../node_modules/axios/lib/axios.js
var require_axios = __commonJS((exports, module) => {
  "use strict";
  var utils = require_utils();
  var bind2 = require_bind();
  var Axios = require_Axios();
  var mergeConfig = require_mergeConfig();
  var defaults = require_defaults();
  function createInstance(defaultConfig2) {
    var context2 = new Axios(defaultConfig2);
    var instance = bind2(Axios.prototype.request, context2);
    utils.extend(instance, Axios.prototype, context2);
    utils.extend(instance, context2);
    return instance;
  }
  var axios2 = createInstance(defaults);
  axios2.Axios = Axios;
  axios2.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(axios2.defaults, instanceConfig));
  };
  axios2.Cancel = require_Cancel();
  axios2.CancelToken = require_CancelToken();
  axios2.isCancel = require_isCancel();
  axios2.all = function all2(promises) {
    return Promise.all(promises);
  };
  axios2.spread = require_spread();
  axios2.isAxiosError = require_isAxiosError();
  module.exports = axios2;
  module.exports.default = axios2;
});

// ../../node_modules/axios/index.js
var require_axios2 = __commonJS((exports, module) => {
  module.exports = require_axios();
});

// ../../node_modules/parseuri/index.js
var require_parseuri = __commonJS((exports, module) => {
  var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
  var parts = [
    "source",
    "protocol",
    "authority",
    "userInfo",
    "user",
    "password",
    "host",
    "port",
    "relative",
    "path",
    "directory",
    "file",
    "query",
    "anchor"
  ];
  module.exports = function parseuri(str) {
    var src = str, b = str.indexOf("["), e = str.indexOf("]");
    if (b != -1 && e != -1) {
      str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
    }
    var m = re.exec(str || ""), uri = {}, i = 14;
    while (i--) {
      uri[parts[i]] = m[i] || "";
    }
    if (b != -1 && e != -1) {
      uri.source = src;
      uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
      uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
      uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri["path"]);
    uri.queryKey = queryKey(uri, uri["query"]);
    return uri;
  };
  function pathNames(obj, path3) {
    var regx = /\/{2,9}/g, names = path3.replace(regx, "/").split("/");
    if (path3.substr(0, 1) == "/" || path3.length === 0) {
      names.splice(0, 1);
    }
    if (path3.substr(path3.length - 1, 1) == "/") {
      names.splice(names.length - 1, 1);
    }
    return names;
  }
  function queryKey(uri, query) {
    var data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $22) {
      if ($1) {
        data[$1] = $22;
      }
    });
    return data;
  }
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse4(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse4(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// ../../node_modules/socket.io-client/node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.instances = [];
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return match;
          }
          index2++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = createDebug.enabled(namespace);
      debug.useColors = createDebug.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      debug.extend = extend;
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      createDebug.instances.push(debug);
      return debug;
    }
    function destroy() {
      const index2 = createDebug.instances.indexOf(this);
      if (index2 !== -1) {
        createDebug.instances.splice(index2, 1);
        return true;
      }
      return false;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split2.length;
      for (i = 0; i < len; i++) {
        if (!split2[i]) {
          continue;
        }
        namespaces = split2[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
      for (i = 0; i < createDebug.instances.length; i++) {
        const instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// ../../node_modules/socket.io-client/node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index2 = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index2++;
      if (match === "%c") {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log(...args) {
    return typeof console === "object" && console.log && console.log(...args);
  }
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = require_common()(exports);
  var {formatters} = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../../node_modules/socket.io-client/build/url.js
var require_url = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.url = void 0;
  var parseuri = require_parseuri();
  var debug = require_browser()("socket.io-client:url");
  function url(uri, loc) {
    let obj = uri;
    loc = loc || typeof location !== "undefined" && location;
    if (uri == null)
      uri = loc.protocol + "//" + loc.host;
    if (typeof uri === "string") {
      if (uri.charAt(0) === "/") {
        if (uri.charAt(1) === "/") {
          uri = loc.protocol + uri;
        } else {
          uri = loc.host + uri;
        }
      }
      if (!/^(https?|wss?):\/\//.test(uri)) {
        debug("protocol-less url %s", uri);
        if (typeof loc !== "undefined") {
          uri = loc.protocol + "//" + uri;
        } else {
          uri = "https://" + uri;
        }
      }
      debug("parse %s", uri);
      obj = parseuri(uri);
    }
    if (!obj.port) {
      if (/^(http|ws)$/.test(obj.protocol)) {
        obj.port = "80";
      } else if (/^(http|ws)s$/.test(obj.protocol)) {
        obj.port = "443";
      }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host2 = ipv6 ? "[" + obj.host + "]" : obj.host;
    obj.id = obj.protocol + "://" + host2 + ":" + obj.port;
    obj.href = obj.protocol + "://" + host2 + (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
  }
  exports.url = url;
});

// ../../node_modules/has-cors/index.js
var require_has_cors = __commonJS((exports, module) => {
  try {
    module.exports = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
  } catch (err) {
    module.exports = false;
  }
});

// ../../node_modules/engine.io-client/lib/globalThis.browser.js
var require_globalThis_browser = __commonJS((exports, module) => {
  module.exports = (() => {
    if (typeof self !== "undefined") {
      return self;
    } else if (typeof window !== "undefined") {
      return window;
    } else {
      return Function("return this")();
    }
  })();
});

// ../../node_modules/engine.io-client/lib/xmlhttprequest.js
var require_xmlhttprequest = __commonJS((exports, module) => {
  var hasCORS = require_has_cors();
  var globalThis2 = require_globalThis_browser();
  module.exports = function(opts) {
    const xdomain = opts.xdomain;
    const xscheme = opts.xscheme;
    const enablesXDR = opts.enablesXDR;
    try {
      if (typeof XMLHttpRequest !== "undefined" && (!xdomain || hasCORS)) {
        return new XMLHttpRequest();
      }
    } catch (e) {
    }
    try {
      if (typeof XDomainRequest !== "undefined" && !xscheme && enablesXDR) {
        return new XDomainRequest();
      }
    } catch (e) {
    }
    if (!xdomain) {
      try {
        return new globalThis2[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
      } catch (e) {
      }
    }
  };
});

// ../../node_modules/engine.io-parser/lib/commons.js
var require_commons = __commonJS((exports, module) => {
  var PACKET_TYPES = Object.create(null);
  PACKET_TYPES["open"] = "0";
  PACKET_TYPES["close"] = "1";
  PACKET_TYPES["ping"] = "2";
  PACKET_TYPES["pong"] = "3";
  PACKET_TYPES["message"] = "4";
  PACKET_TYPES["upgrade"] = "5";
  PACKET_TYPES["noop"] = "6";
  var PACKET_TYPES_REVERSE = Object.create(null);
  Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
  });
  var ERROR_PACKET = {type: "error", data: "parser error"};
  module.exports = {
    PACKET_TYPES,
    PACKET_TYPES_REVERSE,
    ERROR_PACKET
  };
});

// ../../node_modules/engine.io-parser/lib/encodePacket.browser.js
var require_encodePacket_browser = __commonJS((exports, module) => {
  var {PACKET_TYPES} = require_commons();
  var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
  var withNativeArrayBuffer = typeof ArrayBuffer === "function";
  var isView = (obj) => {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
  };
  var encodePacket = ({type, data}, supportsBinary, callback) => {
    if (withNativeBlob && data instanceof Blob) {
      if (supportsBinary) {
        return callback(data);
      } else {
        return encodeBlobAsBase64(data, callback);
      }
    } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
      if (supportsBinary) {
        return callback(data instanceof ArrayBuffer ? data : data.buffer);
      } else {
        return encodeBlobAsBase64(new Blob([data]), callback);
      }
    }
    return callback(PACKET_TYPES[type] + (data || ""));
  };
  var encodeBlobAsBase64 = (data, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function() {
      const content = fileReader.result.split(",")[1];
      callback("b" + content);
    };
    return fileReader.readAsDataURL(data);
  };
  module.exports = encodePacket;
});

// ../../node_modules/base64-arraybuffer/lib/base64-arraybuffer.js
var require_base64_arraybuffer = __commonJS((exports) => {
  (function(chars) {
    "use strict";
    exports.encode = function(arraybuffer) {
      var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
      for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64 += chars[bytes[i + 2] & 63];
      }
      if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }
      return base64;
    };
    exports.decode = function(base64) {
      var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
      for (i = 0; i < len; i += 4) {
        encoded1 = chars.indexOf(base64[i]);
        encoded2 = chars.indexOf(base64[i + 1]);
        encoded3 = chars.indexOf(base64[i + 2]);
        encoded4 = chars.indexOf(base64[i + 3]);
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
  })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
});

// ../../node_modules/engine.io-parser/lib/decodePacket.browser.js
var require_decodePacket_browser = __commonJS((exports, module) => {
  var {PACKET_TYPES_REVERSE, ERROR_PACKET} = require_commons();
  var withNativeArrayBuffer = typeof ArrayBuffer === "function";
  var base64decoder;
  if (withNativeArrayBuffer) {
    base64decoder = require_base64_arraybuffer();
  }
  var decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
      return {
        type: "message",
        data: mapBinary(encodedPacket, binaryType)
      };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
      return {
        type: "message",
        data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
      };
    }
    const packetType = PACKET_TYPES_REVERSE[type];
    if (!packetType) {
      return ERROR_PACKET;
    }
    return encodedPacket.length > 1 ? {
      type: PACKET_TYPES_REVERSE[type],
      data: encodedPacket.substring(1)
    } : {
      type: PACKET_TYPES_REVERSE[type]
    };
  };
  var decodeBase64Packet = (data, binaryType) => {
    if (base64decoder) {
      const decoded = base64decoder.decode(data);
      return mapBinary(decoded, binaryType);
    } else {
      return {base64: true, data};
    }
  };
  var mapBinary = (data, binaryType) => {
    switch (binaryType) {
      case "blob":
        return data instanceof ArrayBuffer ? new Blob([data]) : data;
      case "arraybuffer":
      default:
        return data;
    }
  };
  module.exports = decodePacket;
});

// ../../node_modules/engine.io-parser/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var encodePacket = require_encodePacket_browser();
  var decodePacket = require_decodePacket_browser();
  var SEPARATOR = String.fromCharCode(30);
  var encodePayload = (packets, callback) => {
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i) => {
      encodePacket(packet, false, (encodedPacket) => {
        encodedPackets[i] = encodedPacket;
        if (++count === length) {
          callback(encodedPackets.join(SEPARATOR));
        }
      });
    });
  };
  var decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
      const decodedPacket = decodePacket(encodedPackets[i], binaryType);
      packets.push(decodedPacket);
      if (decodedPacket.type === "error") {
        break;
      }
    }
    return packets;
  };
  module.exports = {
    protocol: 4,
    encodePacket,
    encodePayload,
    decodePacket,
    decodePayload
  };
});

// ../../node_modules/component-emitter/index.js
var require_component_emitter = __commonJS((exports, module) => {
  if (typeof module !== "undefined") {
    module.exports = Emitter3;
  }
  function Emitter3(obj) {
    if (obj)
      return mixin2(obj);
  }
  function mixin2(obj) {
    for (var key in Emitter3.prototype) {
      obj[key] = Emitter3.prototype[key];
    }
    return obj;
  }
  Emitter3.prototype.on = Emitter3.prototype.addEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
    return this;
  };
  Emitter3.prototype.once = function(event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }
    on.fn = fn;
    this.on(event, on);
    return this;
  };
  Emitter3.prototype.off = Emitter3.prototype.removeListener = Emitter3.prototype.removeAllListeners = Emitter3.prototype.removeEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    if (arguments.length == 0) {
      this._callbacks = {};
      return this;
    }
    var callbacks = this._callbacks["$" + event];
    if (!callbacks)
      return this;
    if (arguments.length == 1) {
      delete this._callbacks["$" + event];
      return this;
    }
    var cb;
    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }
    if (callbacks.length === 0) {
      delete this._callbacks["$" + event];
    }
    return this;
  };
  Emitter3.prototype.emit = function(event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }
    return this;
  };
  Emitter3.prototype.listeners = function(event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks["$" + event] || [];
  };
  Emitter3.prototype.hasListeners = function(event) {
    return !!this.listeners(event).length;
  };
});

// ../../node_modules/engine.io-client/lib/transport.js
var require_transport = __commonJS((exports, module) => {
  var parser = require_lib2();
  var Emitter3 = require_component_emitter();
  var Transport = class extends Emitter3 {
    constructor(opts) {
      super();
      this.opts = opts;
      this.query = opts.query;
      this.readyState = "";
      this.socket = opts.socket;
    }
    onError(msg, desc) {
      const err = new Error(msg);
      err.type = "TransportError";
      err.description = desc;
      this.emit("error", err);
      return this;
    }
    open() {
      if (this.readyState === "closed" || this.readyState === "") {
        this.readyState = "opening";
        this.doOpen();
      }
      return this;
    }
    close() {
      if (this.readyState === "opening" || this.readyState === "open") {
        this.doClose();
        this.onClose();
      }
      return this;
    }
    send(packets) {
      if (this.readyState === "open") {
        this.write(packets);
      } else {
        throw new Error("Transport not open");
      }
    }
    onOpen() {
      this.readyState = "open";
      this.writable = true;
      this.emit("open");
    }
    onData(data) {
      const packet = parser.decodePacket(data, this.socket.binaryType);
      this.onPacket(packet);
    }
    onPacket(packet) {
      this.emit("packet", packet);
    }
    onClose() {
      this.readyState = "closed";
      this.emit("close");
    }
  };
  module.exports = Transport;
});

// ../../node_modules/parseqs/index.js
var require_parseqs = __commonJS((exports) => {
  exports.encode = function(obj) {
    var str = "";
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (str.length)
          str += "&";
        str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
      }
    }
    return str;
  };
  exports.decode = function(qs) {
    var qry = {};
    var pairs = qs.split("&");
    for (var i = 0, l = pairs.length; i < l; i++) {
      var pair = pairs[i].split("=");
      qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
  };
});

// ../../node_modules/yeast/index.js
var require_yeast = __commonJS((exports, module) => {
  "use strict";
  var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
  var length = 64;
  var map = {};
  var seed = 0;
  var i = 0;
  var prev;
  function encode(num) {
    var encoded = "";
    do {
      encoded = alphabet[num % length] + encoded;
      num = Math.floor(num / length);
    } while (num > 0);
    return encoded;
  }
  function decode(str) {
    var decoded = 0;
    for (i = 0; i < str.length; i++) {
      decoded = decoded * length + map[str.charAt(i)];
    }
    return decoded;
  }
  function yeast() {
    var now = encode(+new Date());
    if (now !== prev)
      return seed = 0, prev = now;
    return now + "." + encode(seed++);
  }
  for (; i < length; i++)
    map[alphabet[i]] = i;
  yeast.encode = encode;
  yeast.decode = decode;
  module.exports = yeast;
});

// ../../node_modules/debug/node_modules/ms/index.js
var require_ms2 = __commonJS((exports, module) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse4(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse4(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// ../../node_modules/debug/src/common.js
var require_common2 = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms2();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split2.length;
      for (i = 0; i < len; i++) {
        if (!split2[i]) {
          continue;
        }
        namespaces = split2[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// ../../node_modules/debug/src/browser.js
var require_browser2 = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index2 = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index2++;
      if (match === "%c") {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = require_common2()(exports);
  var {formatters} = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../../node_modules/engine.io-client/lib/transports/polling.js
var require_polling = __commonJS((exports, module) => {
  var Transport = require_transport();
  var parseqs = require_parseqs();
  var parser = require_lib2();
  var yeast = require_yeast();
  var debug = require_browser2()("engine.io-client:polling");
  var Polling = class extends Transport {
    get name() {
      return "polling";
    }
    doOpen() {
      this.poll();
    }
    pause(onPause) {
      const self2 = this;
      this.readyState = "pausing";
      function pause() {
        debug("paused");
        self2.readyState = "paused";
        onPause();
      }
      if (this.polling || !this.writable) {
        let total = 0;
        if (this.polling) {
          debug("we are currently polling - waiting to pause");
          total++;
          this.once("pollComplete", function() {
            debug("pre-pause polling complete");
            --total || pause();
          });
        }
        if (!this.writable) {
          debug("we are currently writing - waiting to pause");
          total++;
          this.once("drain", function() {
            debug("pre-pause writing complete");
            --total || pause();
          });
        }
      } else {
        pause();
      }
    }
    poll() {
      debug("polling");
      this.polling = true;
      this.doPoll();
      this.emit("poll");
    }
    onData(data) {
      const self2 = this;
      debug("polling got data %s", data);
      const callback = function(packet, index2, total) {
        if (self2.readyState === "opening" && packet.type === "open") {
          self2.onOpen();
        }
        if (packet.type === "close") {
          self2.onClose();
          return false;
        }
        self2.onPacket(packet);
      };
      parser.decodePayload(data, this.socket.binaryType).forEach(callback);
      if (this.readyState !== "closed") {
        this.polling = false;
        this.emit("pollComplete");
        if (this.readyState === "open") {
          this.poll();
        } else {
          debug('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    }
    doClose() {
      const self2 = this;
      function close() {
        debug("writing close packet");
        self2.write([{type: "close"}]);
      }
      if (this.readyState === "open") {
        debug("transport open - closing");
        close();
      } else {
        debug("transport not open - deferring close");
        this.once("open", close);
      }
    }
    write(packets) {
      this.writable = false;
      parser.encodePayload(packets, (data) => {
        this.doWrite(data, () => {
          this.writable = true;
          this.emit("drain");
        });
      });
    }
    uri() {
      let query = this.query || {};
      const schema = this.opts.secure ? "https" : "http";
      let port = "";
      if (this.opts.timestampRequests !== false) {
        query[this.opts.timestampParam] = yeast();
      }
      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }
      query = parseqs.encode(query);
      if (this.opts.port && (schema === "https" && Number(this.opts.port) !== 443 || schema === "http" && Number(this.opts.port) !== 80)) {
        port = ":" + this.opts.port;
      }
      if (query.length) {
        query = "?" + query;
      }
      const ipv6 = this.opts.hostname.indexOf(":") !== -1;
      return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query;
    }
  };
  module.exports = Polling;
});

// ../../node_modules/engine.io-client/lib/util.js
var require_util = __commonJS((exports, module) => {
  module.exports.pick = (obj, ...attr) => {
    return attr.reduce((acc, k) => {
      acc[k] = obj[k];
      return acc;
    }, {});
  };
});

// ../../node_modules/engine.io-client/lib/transports/polling-xhr.js
var require_polling_xhr = __commonJS((exports, module) => {
  var XMLHttpRequest2 = require_xmlhttprequest();
  var Polling = require_polling();
  var Emitter3 = require_component_emitter();
  var {pick} = require_util();
  var globalThis2 = require_globalThis_browser();
  var debug = require_browser2()("engine.io-client:polling-xhr");
  function empty2() {
  }
  var hasXHR2 = function() {
    const xhr = new XMLHttpRequest2({xdomain: false});
    return xhr.responseType != null;
  }();
  var XHR = class extends Polling {
    constructor(opts) {
      super(opts);
      if (typeof location !== "undefined") {
        const isSSL = location.protocol === "https:";
        let port = location.port;
        if (!port) {
          port = isSSL ? 443 : 80;
        }
        this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
        this.xs = opts.secure !== isSSL;
      }
      const forceBase64 = opts && opts.forceBase64;
      this.supportsBinary = hasXHR2 && !forceBase64;
    }
    request(opts = {}) {
      Object.assign(opts, {xd: this.xd, xs: this.xs}, this.opts);
      return new Request(this.uri(), opts);
    }
    doWrite(data, fn) {
      const req = this.request({
        method: "POST",
        data
      });
      const self2 = this;
      req.on("success", fn);
      req.on("error", function(err) {
        self2.onError("xhr post error", err);
      });
    }
    doPoll() {
      debug("xhr poll");
      const req = this.request();
      const self2 = this;
      req.on("data", function(data) {
        self2.onData(data);
      });
      req.on("error", function(err) {
        self2.onError("xhr poll error", err);
      });
      this.pollXhr = req;
    }
  };
  var Request = class extends Emitter3 {
    constructor(uri, opts) {
      super();
      this.opts = opts;
      this.method = opts.method || "GET";
      this.uri = uri;
      this.async = opts.async !== false;
      this.data = opts.data !== void 0 ? opts.data : null;
      this.create();
    }
    create() {
      const opts = pick(this.opts, "agent", "enablesXDR", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized");
      opts.xdomain = !!this.opts.xd;
      opts.xscheme = !!this.opts.xs;
      const xhr = this.xhr = new XMLHttpRequest2(opts);
      const self2 = this;
      try {
        debug("xhr open %s: %s", this.method, this.uri);
        xhr.open(this.method, this.uri, this.async);
        try {
          if (this.opts.extraHeaders) {
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
            for (let i in this.opts.extraHeaders) {
              if (this.opts.extraHeaders.hasOwnProperty(i)) {
                xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
              }
            }
          }
        } catch (e) {
        }
        if (this.method === "POST") {
          try {
            xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
          } catch (e) {
          }
        }
        try {
          xhr.setRequestHeader("Accept", "*/*");
        } catch (e) {
        }
        if ("withCredentials" in xhr) {
          xhr.withCredentials = this.opts.withCredentials;
        }
        if (this.opts.requestTimeout) {
          xhr.timeout = this.opts.requestTimeout;
        }
        if (this.hasXDR()) {
          xhr.onload = function() {
            self2.onLoad();
          };
          xhr.onerror = function() {
            self2.onError(xhr.responseText);
          };
        } else {
          xhr.onreadystatechange = function() {
            if (xhr.readyState !== 4)
              return;
            if (xhr.status === 200 || xhr.status === 1223) {
              self2.onLoad();
            } else {
              setTimeout(function() {
                self2.onError(typeof xhr.status === "number" ? xhr.status : 0);
              }, 0);
            }
          };
        }
        debug("xhr data %s", this.data);
        xhr.send(this.data);
      } catch (e) {
        setTimeout(function() {
          self2.onError(e);
        }, 0);
        return;
      }
      if (typeof document !== "undefined") {
        this.index = Request.requestsCount++;
        Request.requests[this.index] = this;
      }
    }
    onSuccess() {
      this.emit("success");
      this.cleanup();
    }
    onData(data) {
      this.emit("data", data);
      this.onSuccess();
    }
    onError(err) {
      this.emit("error", err);
      this.cleanup(true);
    }
    cleanup(fromError2) {
      if (typeof this.xhr === "undefined" || this.xhr === null) {
        return;
      }
      if (this.hasXDR()) {
        this.xhr.onload = this.xhr.onerror = empty2;
      } else {
        this.xhr.onreadystatechange = empty2;
      }
      if (fromError2) {
        try {
          this.xhr.abort();
        } catch (e) {
        }
      }
      if (typeof document !== "undefined") {
        delete Request.requests[this.index];
      }
      this.xhr = null;
    }
    onLoad() {
      const data = this.xhr.responseText;
      if (data !== null) {
        this.onData(data);
      }
    }
    hasXDR() {
      return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
    }
    abort() {
      this.cleanup();
    }
  };
  Request.requestsCount = 0;
  Request.requests = {};
  if (typeof document !== "undefined") {
    if (typeof attachEvent === "function") {
      attachEvent("onunload", unloadHandler);
    } else if (typeof addEventListener === "function") {
      const terminationEvent = "onpagehide" in globalThis2 ? "pagehide" : "unload";
      addEventListener(terminationEvent, unloadHandler, false);
    }
  }
  function unloadHandler() {
    for (let i in Request.requests) {
      if (Request.requests.hasOwnProperty(i)) {
        Request.requests[i].abort();
      }
    }
  }
  module.exports = XHR;
  module.exports.Request = Request;
});

// ../../node_modules/engine.io-client/lib/transports/polling-jsonp.js
var require_polling_jsonp = __commonJS((exports, module) => {
  var Polling = require_polling();
  var globalThis2 = require_globalThis_browser();
  var rNewline = /\n/g;
  var rEscapedNewline = /\\n/g;
  var callbacks;
  function empty2() {
  }
  var JSONPPolling = class extends Polling {
    constructor(opts) {
      super(opts);
      this.query = this.query || {};
      if (!callbacks) {
        callbacks = globalThis2.___eio = globalThis2.___eio || [];
      }
      this.index = callbacks.length;
      const self2 = this;
      callbacks.push(function(msg) {
        self2.onData(msg);
      });
      this.query.j = this.index;
      if (typeof addEventListener === "function") {
        addEventListener("beforeunload", function() {
          if (self2.script)
            self2.script.onerror = empty2;
        }, false);
      }
    }
    get supportsBinary() {
      return false;
    }
    doClose() {
      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }
      if (this.form) {
        this.form.parentNode.removeChild(this.form);
        this.form = null;
        this.iframe = null;
      }
      super.doClose();
    }
    doPoll() {
      const self2 = this;
      const script = document.createElement("script");
      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }
      script.async = true;
      script.src = this.uri();
      script.onerror = function(e) {
        self2.onError("jsonp poll error", e);
      };
      const insertAt = document.getElementsByTagName("script")[0];
      if (insertAt) {
        insertAt.parentNode.insertBefore(script, insertAt);
      } else {
        (document.head || document.body).appendChild(script);
      }
      this.script = script;
      const isUAgecko = typeof navigator !== "undefined" && /gecko/i.test(navigator.userAgent);
      if (isUAgecko) {
        setTimeout(function() {
          const iframe = document.createElement("iframe");
          document.body.appendChild(iframe);
          document.body.removeChild(iframe);
        }, 100);
      }
    }
    doWrite(data, fn) {
      const self2 = this;
      let iframe;
      if (!this.form) {
        const form = document.createElement("form");
        const area = document.createElement("textarea");
        const id = this.iframeId = "eio_iframe_" + this.index;
        form.className = "socketio";
        form.style.position = "absolute";
        form.style.top = "-1000px";
        form.style.left = "-1000px";
        form.target = id;
        form.method = "POST";
        form.setAttribute("accept-charset", "utf-8");
        area.name = "d";
        form.appendChild(area);
        document.body.appendChild(form);
        this.form = form;
        this.area = area;
      }
      this.form.action = this.uri();
      function complete() {
        initIframe();
        fn();
      }
      function initIframe() {
        if (self2.iframe) {
          try {
            self2.form.removeChild(self2.iframe);
          } catch (e) {
            self2.onError("jsonp polling iframe removal error", e);
          }
        }
        try {
          const html2 = '<iframe src="javascript:0" name="' + self2.iframeId + '">';
          iframe = document.createElement(html2);
        } catch (e) {
          iframe = document.createElement("iframe");
          iframe.name = self2.iframeId;
          iframe.src = "javascript:0";
        }
        iframe.id = self2.iframeId;
        self2.form.appendChild(iframe);
        self2.iframe = iframe;
      }
      initIframe();
      data = data.replace(rEscapedNewline, "\\\n");
      this.area.value = data.replace(rNewline, "\\n");
      try {
        this.form.submit();
      } catch (e) {
      }
      if (this.iframe.attachEvent) {
        this.iframe.onreadystatechange = function() {
          if (self2.iframe.readyState === "complete") {
            complete();
          }
        };
      } else {
        this.iframe.onload = complete;
      }
    }
  };
  module.exports = JSONPPolling;
});

// ../../node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js
var require_websocket_constructor_browser = __commonJS((exports, module) => {
  var globalThis2 = require_globalThis_browser();
  module.exports = {
    WebSocket: globalThis2.WebSocket || globalThis2.MozWebSocket,
    usingBrowserWebSocket: true,
    defaultBinaryType: "arraybuffer"
  };
});

// ../../node_modules/engine.io-client/lib/transports/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var Transport = require_transport();
  var parser = require_lib2();
  var parseqs = require_parseqs();
  var yeast = require_yeast();
  var {pick} = require_util();
  var {
    WebSocket,
    usingBrowserWebSocket,
    defaultBinaryType
  } = require_websocket_constructor_browser();
  var debug = require_browser2()("engine.io-client:websocket");
  var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
  var WS = class extends Transport {
    constructor(opts) {
      super(opts);
      this.supportsBinary = !opts.forceBase64;
    }
    get name() {
      return "websocket";
    }
    doOpen() {
      if (!this.check()) {
        return;
      }
      const uri = this.uri();
      const protocols = this.opts.protocols;
      const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress");
      if (this.opts.extraHeaders) {
        opts.headers = this.opts.extraHeaders;
      }
      try {
        this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
      } catch (err) {
        return this.emit("error", err);
      }
      this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
      this.addEventListeners();
    }
    addEventListeners() {
      const self2 = this;
      this.ws.onopen = function() {
        self2.onOpen();
      };
      this.ws.onclose = function() {
        self2.onClose();
      };
      this.ws.onmessage = function(ev) {
        self2.onData(ev.data);
      };
      this.ws.onerror = function(e) {
        self2.onError("websocket error", e);
      };
    }
    write(packets) {
      const self2 = this;
      this.writable = false;
      let total = packets.length;
      let i = 0;
      const l = total;
      for (; i < l; i++) {
        (function(packet) {
          parser.encodePacket(packet, self2.supportsBinary, function(data) {
            const opts = {};
            if (!usingBrowserWebSocket) {
              if (packet.options) {
                opts.compress = packet.options.compress;
              }
              if (self2.opts.perMessageDeflate) {
                const len = typeof data === "string" ? Buffer.byteLength(data) : data.length;
                if (len < self2.opts.perMessageDeflate.threshold) {
                  opts.compress = false;
                }
              }
            }
            try {
              if (usingBrowserWebSocket) {
                self2.ws.send(data);
              } else {
                self2.ws.send(data, opts);
              }
            } catch (e) {
              debug("websocket closed before onclose event");
            }
            --total || done3();
          });
        })(packets[i]);
      }
      function done3() {
        self2.emit("flush");
        setTimeout(function() {
          self2.writable = true;
          self2.emit("drain");
        }, 0);
      }
    }
    onClose() {
      Transport.prototype.onClose.call(this);
    }
    doClose() {
      if (typeof this.ws !== "undefined") {
        this.ws.close();
      }
    }
    uri() {
      let query = this.query || {};
      const schema = this.opts.secure ? "wss" : "ws";
      let port = "";
      if (this.opts.port && (schema === "wss" && Number(this.opts.port) !== 443 || schema === "ws" && Number(this.opts.port) !== 80)) {
        port = ":" + this.opts.port;
      }
      if (this.opts.timestampRequests) {
        query[this.opts.timestampParam] = yeast();
      }
      if (!this.supportsBinary) {
        query.b64 = 1;
      }
      query = parseqs.encode(query);
      if (query.length) {
        query = "?" + query;
      }
      const ipv6 = this.opts.hostname.indexOf(":") !== -1;
      return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query;
    }
    check() {
      return !!WebSocket && !("__initialize" in WebSocket && this.name === WS.prototype.name);
    }
  };
  module.exports = WS;
});

// ../../node_modules/engine.io-client/lib/transports/index.js
var require_transports = __commonJS((exports) => {
  var XMLHttpRequest2 = require_xmlhttprequest();
  var XHR = require_polling_xhr();
  var JSONP = require_polling_jsonp();
  var websocket2 = require_websocket();
  exports.polling = polling;
  exports.websocket = websocket2;
  function polling(opts) {
    let xhr;
    let xd = false;
    let xs = false;
    const jsonp = opts.jsonp !== false;
    if (typeof location !== "undefined") {
      const isSSL = location.protocol === "https:";
      let port = location.port;
      if (!port) {
        port = isSSL ? 443 : 80;
      }
      xd = opts.hostname !== location.hostname || port !== opts.port;
      xs = opts.secure !== isSSL;
    }
    opts.xdomain = xd;
    opts.xscheme = xs;
    xhr = new XMLHttpRequest2(opts);
    if ("open" in xhr && !opts.forceJSONP) {
      return new XHR(opts);
    } else {
      if (!jsonp)
        throw new Error("JSONP disabled");
      return new JSONP(opts);
    }
  }
});

// ../../node_modules/engine.io-client/lib/socket.js
var require_socket = __commonJS((exports, module) => {
  var transports = require_transports();
  var Emitter3 = require_component_emitter();
  var debug = require_browser2()("engine.io-client:socket");
  var parser = require_lib2();
  var parseuri = require_parseuri();
  var parseqs = require_parseqs();
  var Socket = class extends Emitter3 {
    constructor(uri, opts = {}) {
      super();
      if (uri && typeof uri === "object") {
        opts = uri;
        uri = null;
      }
      if (uri) {
        uri = parseuri(uri);
        opts.hostname = uri.host;
        opts.secure = uri.protocol === "https" || uri.protocol === "wss";
        opts.port = uri.port;
        if (uri.query)
          opts.query = uri.query;
      } else if (opts.host) {
        opts.hostname = parseuri(opts.host).host;
      }
      this.secure = opts.secure != null ? opts.secure : typeof location !== "undefined" && location.protocol === "https:";
      if (opts.hostname && !opts.port) {
        opts.port = this.secure ? "443" : "80";
      }
      this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
      this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? 443 : 80);
      this.transports = opts.transports || ["polling", "websocket"];
      this.readyState = "";
      this.writeBuffer = [];
      this.prevBufferLen = 0;
      this.opts = Object.assign({
        path: "/engine.io",
        agent: false,
        withCredentials: false,
        upgrade: true,
        jsonp: true,
        timestampParam: "t",
        rememberUpgrade: false,
        rejectUnauthorized: true,
        perMessageDeflate: {
          threshold: 1024
        },
        transportOptions: {}
      }, opts);
      this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
      if (typeof this.opts.query === "string") {
        this.opts.query = parseqs.decode(this.opts.query);
      }
      this.id = null;
      this.upgrades = null;
      this.pingInterval = null;
      this.pingTimeout = null;
      this.pingTimeoutTimer = null;
      this.open();
    }
    createTransport(name) {
      debug('creating transport "%s"', name);
      const query = clone(this.opts.query);
      query.EIO = parser.protocol;
      query.transport = name;
      if (this.id)
        query.sid = this.id;
      const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {
        query,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      });
      debug("options: %j", opts);
      return new transports[name](opts);
    }
    open() {
      let transport;
      if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
        transport = "websocket";
      } else if (this.transports.length === 0) {
        const self2 = this;
        setTimeout(function() {
          self2.emit("error", "No transports available");
        }, 0);
        return;
      } else {
        transport = this.transports[0];
      }
      this.readyState = "opening";
      try {
        transport = this.createTransport(transport);
      } catch (e) {
        debug("error while creating transport: %s", e);
        this.transports.shift();
        this.open();
        return;
      }
      transport.open();
      this.setTransport(transport);
    }
    setTransport(transport) {
      debug("setting transport %s", transport.name);
      const self2 = this;
      if (this.transport) {
        debug("clearing existing transport %s", this.transport.name);
        this.transport.removeAllListeners();
      }
      this.transport = transport;
      transport.on("drain", function() {
        self2.onDrain();
      }).on("packet", function(packet) {
        self2.onPacket(packet);
      }).on("error", function(e) {
        self2.onError(e);
      }).on("close", function() {
        self2.onClose("transport close");
      });
    }
    probe(name) {
      debug('probing transport "%s"', name);
      let transport = this.createTransport(name, {probe: 1});
      let failed = false;
      const self2 = this;
      Socket.priorWebsocketSuccess = false;
      function onTransportOpen() {
        if (self2.onlyBinaryUpgrades) {
          const upgradeLosesBinary = !this.supportsBinary && self2.transport.supportsBinary;
          failed = failed || upgradeLosesBinary;
        }
        if (failed)
          return;
        debug('probe transport "%s" opened', name);
        transport.send([{type: "ping", data: "probe"}]);
        transport.once("packet", function(msg) {
          if (failed)
            return;
          if (msg.type === "pong" && msg.data === "probe") {
            debug('probe transport "%s" pong', name);
            self2.upgrading = true;
            self2.emit("upgrading", transport);
            if (!transport)
              return;
            Socket.priorWebsocketSuccess = transport.name === "websocket";
            debug('pausing current transport "%s"', self2.transport.name);
            self2.transport.pause(function() {
              if (failed)
                return;
              if (self2.readyState === "closed")
                return;
              debug("changing transport and sending upgrade packet");
              cleanup();
              self2.setTransport(transport);
              transport.send([{type: "upgrade"}]);
              self2.emit("upgrade", transport);
              transport = null;
              self2.upgrading = false;
              self2.flush();
            });
          } else {
            debug('probe transport "%s" failed', name);
            const err = new Error("probe error");
            err.transport = transport.name;
            self2.emit("upgradeError", err);
          }
        });
      }
      function freezeTransport() {
        if (failed)
          return;
        failed = true;
        cleanup();
        transport.close();
        transport = null;
      }
      function onerror(err) {
        const error = new Error("probe error: " + err);
        error.transport = transport.name;
        freezeTransport();
        debug('probe transport "%s" failed because of error: %s', name, err);
        self2.emit("upgradeError", error);
      }
      function onTransportClose() {
        onerror("transport closed");
      }
      function onclose() {
        onerror("socket closed");
      }
      function onupgrade(to) {
        if (transport && to.name !== transport.name) {
          debug('"%s" works - aborting "%s"', to.name, transport.name);
          freezeTransport();
        }
      }
      function cleanup() {
        transport.removeListener("open", onTransportOpen);
        transport.removeListener("error", onerror);
        transport.removeListener("close", onTransportClose);
        self2.removeListener("close", onclose);
        self2.removeListener("upgrading", onupgrade);
      }
      transport.once("open", onTransportOpen);
      transport.once("error", onerror);
      transport.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      transport.open();
    }
    onOpen() {
      debug("socket open");
      this.readyState = "open";
      Socket.priorWebsocketSuccess = this.transport.name === "websocket";
      this.emit("open");
      this.flush();
      if (this.readyState === "open" && this.opts.upgrade && this.transport.pause) {
        debug("starting upgrade probes");
        let i = 0;
        const l = this.upgrades.length;
        for (; i < l; i++) {
          this.probe(this.upgrades[i]);
        }
      }
    }
    onPacket(packet) {
      if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
        debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
        this.emit("packet", packet);
        this.emit("heartbeat");
        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;
          case "ping":
            this.resetPingTimeout();
            this.sendPacket("pong");
            this.emit("pong");
            break;
          case "error":
            const err = new Error("server error");
            err.code = packet.data;
            this.onError(err);
            break;
          case "message":
            this.emit("data", packet.data);
            this.emit("message", packet.data);
            break;
        }
      } else {
        debug('packet received with socket readyState "%s"', this.readyState);
      }
    }
    onHandshake(data) {
      this.emit("handshake", data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this.upgrades = this.filterUpgrades(data.upgrades);
      this.pingInterval = data.pingInterval;
      this.pingTimeout = data.pingTimeout;
      this.onOpen();
      if (this.readyState === "closed")
        return;
      this.resetPingTimeout();
    }
    resetPingTimeout() {
      clearTimeout(this.pingTimeoutTimer);
      this.pingTimeoutTimer = setTimeout(() => {
        this.onClose("ping timeout");
      }, this.pingInterval + this.pingTimeout);
    }
    onDrain() {
      this.writeBuffer.splice(0, this.prevBufferLen);
      this.prevBufferLen = 0;
      if (this.writeBuffer.length === 0) {
        this.emit("drain");
      } else {
        this.flush();
      }
    }
    flush() {
      if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        debug("flushing %d packets in socket", this.writeBuffer.length);
        this.transport.send(this.writeBuffer);
        this.prevBufferLen = this.writeBuffer.length;
        this.emit("flush");
      }
    }
    write(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
    send(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
    sendPacket(type, data, options, fn) {
      if (typeof data === "function") {
        fn = data;
        data = void 0;
      }
      if (typeof options === "function") {
        fn = options;
        options = null;
      }
      if (this.readyState === "closing" || this.readyState === "closed") {
        return;
      }
      options = options || {};
      options.compress = options.compress !== false;
      const packet = {
        type,
        data,
        options
      };
      this.emit("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn)
        this.once("flush", fn);
      this.flush();
    }
    close() {
      const self2 = this;
      if (this.readyState === "opening" || this.readyState === "open") {
        this.readyState = "closing";
        if (this.writeBuffer.length) {
          this.once("drain", function() {
            if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }
      function close() {
        self2.onClose("forced close");
        debug("socket closing - telling transport to close");
        self2.transport.close();
      }
      function cleanupAndClose() {
        self2.removeListener("upgrade", cleanupAndClose);
        self2.removeListener("upgradeError", cleanupAndClose);
        close();
      }
      function waitForUpgrade() {
        self2.once("upgrade", cleanupAndClose);
        self2.once("upgradeError", cleanupAndClose);
      }
      return this;
    }
    onError(err) {
      debug("socket error %j", err);
      Socket.priorWebsocketSuccess = false;
      this.emit("error", err);
      this.onClose("transport error", err);
    }
    onClose(reason, desc) {
      if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
        debug('socket close with reason: "%s"', reason);
        const self2 = this;
        clearTimeout(this.pingIntervalTimer);
        clearTimeout(this.pingTimeoutTimer);
        this.transport.removeAllListeners("close");
        this.transport.close();
        this.transport.removeAllListeners();
        this.readyState = "closed";
        this.id = null;
        this.emit("close", reason, desc);
        self2.writeBuffer = [];
        self2.prevBufferLen = 0;
      }
    }
    filterUpgrades(upgrades) {
      const filteredUpgrades = [];
      let i = 0;
      const j = upgrades.length;
      for (; i < j; i++) {
        if (~this.transports.indexOf(upgrades[i]))
          filteredUpgrades.push(upgrades[i]);
      }
      return filteredUpgrades;
    }
  };
  Socket.priorWebsocketSuccess = false;
  Socket.protocol = parser.protocol;
  function clone(obj) {
    const o = {};
    for (let i in obj) {
      if (obj.hasOwnProperty(i)) {
        o[i] = obj[i];
      }
    }
    return o;
  }
  module.exports = Socket;
});

// ../../node_modules/engine.io-client/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  var Socket = require_socket();
  module.exports = (uri, opts) => new Socket(uri, opts);
  module.exports.Socket = Socket;
  module.exports.protocol = Socket.protocol;
  module.exports.Transport = require_transport();
  module.exports.transports = require_transports();
  module.exports.parser = require_lib2();
});

// ../../node_modules/socket.io-parser/dist/is-binary.js
var require_is_binary = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.hasBinary = exports.isBinary = void 0;
  var withNativeArrayBuffer = typeof ArrayBuffer === "function";
  var isView = (obj) => {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
  };
  var toString5 = Object.prototype.toString;
  var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString5.call(Blob) === "[object BlobConstructor]";
  var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString5.call(File) === "[object FileConstructor]";
  function isBinary(obj) {
    return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
  }
  exports.isBinary = isBinary;
  function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    if (Array.isArray(obj)) {
      for (let i = 0, l = obj.length; i < l; i++) {
        if (hasBinary(obj[i])) {
          return true;
        }
      }
      return false;
    }
    if (isBinary(obj)) {
      return true;
    }
    if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
      return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
        return true;
      }
    }
    return false;
  }
  exports.hasBinary = hasBinary;
});

// ../../node_modules/socket.io-parser/dist/binary.js
var require_binary = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.reconstructPacket = exports.deconstructPacket = void 0;
  var is_binary_1 = require_is_binary();
  function deconstructPacket(packet) {
    const buffers2 = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers2);
    pack.attachments = buffers2.length;
    return {packet: pack, buffers: buffers2};
  }
  exports.deconstructPacket = deconstructPacket;
  function _deconstructPacket(data, buffers2) {
    if (!data)
      return data;
    if (is_binary_1.isBinary(data)) {
      const placeholder = {_placeholder: true, num: buffers2.length};
      buffers2.push(data);
      return placeholder;
    } else if (Array.isArray(data)) {
      const newData = new Array(data.length);
      for (let i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i], buffers2);
      }
      return newData;
    } else if (typeof data === "object" && !(data instanceof Date)) {
      const newData = {};
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          newData[key] = _deconstructPacket(data[key], buffers2);
        }
      }
      return newData;
    }
    return data;
  }
  function reconstructPacket(packet, buffers2) {
    packet.data = _reconstructPacket(packet.data, buffers2);
    packet.attachments = void 0;
    return packet;
  }
  exports.reconstructPacket = reconstructPacket;
  function _reconstructPacket(data, buffers2) {
    if (!data)
      return data;
    if (data && data._placeholder) {
      return buffers2[data.num];
    } else if (Array.isArray(data)) {
      for (let i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i], buffers2);
      }
    } else if (typeof data === "object") {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          data[key] = _reconstructPacket(data[key], buffers2);
        }
      }
    }
    return data;
  }
});

// ../../node_modules/socket.io-parser/dist/index.js
var require_dist = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
  var Emitter3 = require_component_emitter();
  var binary_1 = require_binary();
  var is_binary_1 = require_is_binary();
  var debug = require_browser2()("socket.io-parser");
  exports.protocol = 5;
  var PacketType;
  (function(PacketType2) {
    PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
    PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
    PacketType2[PacketType2["ACK"] = 3] = "ACK";
    PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
  })(PacketType = exports.PacketType || (exports.PacketType = {}));
  var Encoder = class {
    encode(obj) {
      debug("encoding packet %j", obj);
      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if (is_binary_1.hasBinary(obj)) {
          obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
          return this.encodeAsBinary(obj);
        }
      }
      return [this.encodeAsString(obj)];
    }
    encodeAsString(obj) {
      let str = "" + obj.type;
      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      }
      if (obj.nsp && obj.nsp !== "/") {
        str += obj.nsp + ",";
      }
      if (obj.id != null) {
        str += obj.id;
      }
      if (obj.data != null) {
        str += JSON.stringify(obj.data);
      }
      debug("encoded %j as %s", obj, str);
      return str;
    }
    encodeAsBinary(obj) {
      const deconstruction = binary_1.deconstructPacket(obj);
      const pack = this.encodeAsString(deconstruction.packet);
      const buffers2 = deconstruction.buffers;
      buffers2.unshift(pack);
      return buffers2;
    }
  };
  exports.Encoder = Encoder;
  var Decoder = class extends Emitter3 {
    constructor() {
      super();
    }
    add(obj) {
      let packet;
      if (typeof obj === "string") {
        packet = this.decodeString(obj);
        if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
          this.reconstructor = new BinaryReconstructor(packet);
          if (packet.attachments === 0) {
            super.emit("decoded", packet);
          }
        } else {
          super.emit("decoded", packet);
        }
      } else if (is_binary_1.isBinary(obj) || obj.base64) {
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            this.reconstructor = null;
            super.emit("decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    decodeString(str) {
      let i = 0;
      const p = {
        type: Number(str.charAt(0))
      };
      if (PacketType[p.type] === void 0) {
        throw new Error("unknown packet type " + p.type);
      }
      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
        const start = i + 1;
        while (str.charAt(++i) !== "-" && i != str.length) {
        }
        const buf = str.substring(start, i);
        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }
        p.attachments = Number(buf);
      }
      if (str.charAt(i + 1) === "/") {
        const start = i + 1;
        while (++i) {
          const c = str.charAt(i);
          if (c === ",")
            break;
          if (i === str.length)
            break;
        }
        p.nsp = str.substring(start, i);
      } else {
        p.nsp = "/";
      }
      const next = str.charAt(i + 1);
      if (next !== "" && Number(next) == next) {
        const start = i + 1;
        while (++i) {
          const c = str.charAt(i);
          if (c == null || Number(c) != c) {
            --i;
            break;
          }
          if (i === str.length)
            break;
        }
        p.id = Number(str.substring(start, i + 1));
      }
      if (str.charAt(++i)) {
        const payload = tryParse(str.substr(i));
        if (Decoder.isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }
      debug("decoded %s as %j", str, p);
      return p;
    }
    static isPayloadValid(type, payload) {
      switch (type) {
        case PacketType.CONNECT:
          return typeof payload === "object";
        case PacketType.DISCONNECT:
          return payload === void 0;
        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || typeof payload === "object";
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && payload.length > 0;
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
    destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    }
  };
  exports.Decoder = Decoder;
  function tryParse(str) {
    try {
      return JSON.parse(str);
    } catch (e) {
      return false;
    }
  }
  var BinaryReconstructor = class {
    constructor(packet) {
      this.packet = packet;
      this.buffers = [];
      this.reconPack = packet;
    }
    takeBinaryData(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        const packet = binary_1.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    }
    finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  };
});

// ../../node_modules/socket.io-client/build/on.js
var require_on = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.on = void 0;
  function on(obj, ev, fn) {
    obj.on(ev, fn);
    return {
      destroy: function() {
        obj.off(ev, fn);
      }
    };
  }
  exports.on = on;
});

// ../../node_modules/component-bind/index.js
var require_component_bind = __commonJS((exports, module) => {
  var slice2 = [].slice;
  module.exports = function(obj, fn) {
    if (typeof fn == "string")
      fn = obj[fn];
    if (typeof fn != "function")
      throw new Error("bind() requires a function");
    var args = slice2.call(arguments, 2);
    return function() {
      return fn.apply(obj, args.concat(slice2.call(arguments)));
    };
  };
});

// ../../node_modules/socket.io-client/build/socket.js
var require_socket2 = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Socket = void 0;
  var socket_io_parser_1 = require_dist();
  var Emitter3 = require_component_emitter();
  var on_1 = require_on();
  var bind2 = require_component_bind();
  var debug = require_browser()("socket.io-client:socket");
  var RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    newListener: 1,
    removeListener: 1
  });
  var Socket = class extends Emitter3 {
    constructor(io2, nsp, opts) {
      super();
      this.ids = 0;
      this.acks = {};
      this.receiveBuffer = [];
      this.sendBuffer = [];
      this.flags = {};
      this.io = io2;
      this.nsp = nsp;
      this.ids = 0;
      this.acks = {};
      this.receiveBuffer = [];
      this.sendBuffer = [];
      this.connected = false;
      this.disconnected = true;
      this.flags = {};
      if (opts && opts.auth) {
        this.auth = opts.auth;
      }
      if (this.io._autoConnect)
        this.open();
    }
    subEvents() {
      if (this.subs)
        return;
      const io2 = this.io;
      this.subs = [
        on_1.on(io2, "open", bind2(this, "onopen")),
        on_1.on(io2, "packet", bind2(this, "onpacket")),
        on_1.on(io2, "close", bind2(this, "onclose"))
      ];
    }
    get active() {
      return !!this.subs;
    }
    connect() {
      if (this.connected)
        return this;
      this.subEvents();
      if (!this.io["_reconnecting"])
        this.io.open();
      if (this.io._readyState === "open")
        this.onopen();
      return this;
    }
    open() {
      return this.connect();
    }
    send(...args) {
      args.unshift("message");
      this.emit.apply(this, args);
      return this;
    }
    emit(ev, ...args) {
      if (RESERVED_EVENTS.hasOwnProperty(ev)) {
        throw new Error('"' + ev + '" is a reserved event name');
      }
      args.unshift(ev);
      const packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: args
      };
      packet.options = {};
      packet.options.compress = this.flags.compress !== false;
      if (typeof args[args.length - 1] === "function") {
        debug("emitting packet with ack id %d", this.ids);
        this.acks[this.ids] = args.pop();
        packet.id = this.ids++;
      }
      const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
      const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
      if (discardPacket) {
        debug("discard packet as the transport is not currently writable");
      } else if (this.connected) {
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }
      this.flags = {};
      return this;
    }
    packet(packet) {
      packet.nsp = this.nsp;
      this.io._packet(packet);
    }
    onopen() {
      debug("transport is open - connecting");
      if (typeof this.auth == "function") {
        this.auth((data) => {
          this.packet({type: socket_io_parser_1.PacketType.CONNECT, data});
        });
      } else {
        this.packet({type: socket_io_parser_1.PacketType.CONNECT, data: this.auth});
      }
    }
    onclose(reason) {
      debug("close (%s)", reason);
      this.connected = false;
      this.disconnected = true;
      delete this.id;
      super.emit("disconnect", reason);
    }
    onpacket(packet) {
      const sameNamespace = packet.nsp === this.nsp;
      if (!sameNamespace)
        return;
      switch (packet.type) {
        case socket_io_parser_1.PacketType.CONNECT:
          if (packet.data && packet.data.sid) {
            const id = packet.data.sid;
            this.onconnect(id);
          } else {
            super.emit("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          }
          break;
        case socket_io_parser_1.PacketType.EVENT:
          this.onevent(packet);
          break;
        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;
        case socket_io_parser_1.PacketType.ACK:
          this.onack(packet);
          break;
        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(packet);
          break;
        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case socket_io_parser_1.PacketType.CONNECT_ERROR:
          const err = new Error(packet.data.message);
          err.data = packet.data.data;
          super.emit("connect_error", err);
          break;
      }
    }
    onevent(packet) {
      const args = packet.data || [];
      debug("emitting event %j", args);
      if (packet.id != null) {
        debug("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }
      if (this.connected) {
        this.emitEvent(args);
      } else {
        this.receiveBuffer.push(Object.freeze(args));
      }
    }
    emitEvent(args) {
      if (this._anyListeners && this._anyListeners.length) {
        const listeners = this._anyListeners.slice();
        for (const listener of listeners) {
          listener.apply(this, args);
        }
      }
      super.emit.apply(this, args);
    }
    ack(id) {
      const self2 = this;
      let sent = false;
      return function(...args) {
        if (sent)
          return;
        sent = true;
        debug("sending ack %j", args);
        self2.packet({
          type: socket_io_parser_1.PacketType.ACK,
          id,
          data: args
        });
      };
    }
    onack(packet) {
      const ack = this.acks[packet.id];
      if (typeof ack === "function") {
        debug("calling ack %s with %j", packet.id, packet.data);
        ack.apply(this, packet.data);
        delete this.acks[packet.id];
      } else {
        debug("bad ack %s", packet.id);
      }
    }
    onconnect(id) {
      debug("socket connected with id %s", id);
      this.id = id;
      this.connected = true;
      this.disconnected = false;
      super.emit("connect");
      this.emitBuffered();
    }
    emitBuffered() {
      this.receiveBuffer.forEach((args) => this.emitEvent(args));
      this.receiveBuffer = [];
      this.sendBuffer.forEach((packet) => this.packet(packet));
      this.sendBuffer = [];
    }
    ondisconnect() {
      debug("server disconnect (%s)", this.nsp);
      this.destroy();
      this.onclose("io server disconnect");
    }
    destroy() {
      if (this.subs) {
        for (let i = 0; i < this.subs.length; i++) {
          this.subs[i].destroy();
        }
        this.subs = null;
      }
      this.io["_destroy"](this);
    }
    disconnect() {
      if (this.connected) {
        debug("performing disconnect (%s)", this.nsp);
        this.packet({type: socket_io_parser_1.PacketType.DISCONNECT});
      }
      this.destroy();
      if (this.connected) {
        this.onclose("io client disconnect");
      }
      return this;
    }
    close() {
      return this.disconnect();
    }
    compress(compress) {
      this.flags.compress = compress;
      return this;
    }
    get volatile() {
      this.flags.volatile = true;
      return this;
    }
    onAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.push(listener);
      return this;
    }
    prependAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.unshift(listener);
      return this;
    }
    offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }
      if (listener) {
        const listeners = this._anyListeners;
        for (let i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }
      return this;
    }
    listenersAny() {
      return this._anyListeners || [];
    }
  };
  exports.Socket = Socket;
});

// ../../node_modules/backo2/index.js
var require_backo2 = __commonJS((exports, module) => {
  module.exports = Backoff;
  function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 1e4;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
  }
  Backoff.prototype.duration = function() {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
      var rand = Math.random();
      var deviation = Math.floor(rand * this.jitter * ms);
      ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
  };
  Backoff.prototype.reset = function() {
    this.attempts = 0;
  };
  Backoff.prototype.setMin = function(min) {
    this.ms = min;
  };
  Backoff.prototype.setMax = function(max) {
    this.max = max;
  };
  Backoff.prototype.setJitter = function(jitter) {
    this.jitter = jitter;
  };
});

// ../../node_modules/socket.io-client/build/manager.js
var require_manager = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Manager = void 0;
  var eio = require_lib3();
  var socket_1 = require_socket2();
  var Emitter3 = require_component_emitter();
  var parser = require_dist();
  var on_1 = require_on();
  var bind2 = require_component_bind();
  var Backoff = require_backo2();
  var debug = require_browser()("socket.io-client:manager");
  var Manager = class extends Emitter3 {
    constructor(uri, opts) {
      super();
      this.nsps = {};
      this.subs = [];
      if (uri && typeof uri === "object") {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      opts.path = opts.path || "/socket.io";
      this.opts = opts;
      this.reconnection(opts.reconnection !== false);
      this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
      this.reconnectionDelay(opts.reconnectionDelay || 1e3);
      this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
      this.randomizationFactor(opts.randomizationFactor || 0.5);
      this.backoff = new Backoff({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      });
      this.timeout(opts.timeout == null ? 2e4 : opts.timeout);
      this._readyState = "closed";
      this.uri = uri;
      const _parser = opts.parser || parser;
      this.encoder = new _parser.Encoder();
      this.decoder = new _parser.Decoder();
      this._autoConnect = opts.autoConnect !== false;
      if (this._autoConnect)
        this.open();
    }
    reconnection(v) {
      if (!arguments.length)
        return this._reconnection;
      this._reconnection = !!v;
      return this;
    }
    reconnectionAttempts(v) {
      if (v === void 0)
        return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    }
    reconnectionDelay(v) {
      var _a5;
      if (v === void 0)
        return this._reconnectionDelay;
      this._reconnectionDelay = v;
      (_a5 = this.backoff) === null || _a5 === void 0 ? void 0 : _a5.setMin(v);
      return this;
    }
    randomizationFactor(v) {
      var _a5;
      if (v === void 0)
        return this._randomizationFactor;
      this._randomizationFactor = v;
      (_a5 = this.backoff) === null || _a5 === void 0 ? void 0 : _a5.setJitter(v);
      return this;
    }
    reconnectionDelayMax(v) {
      var _a5;
      if (v === void 0)
        return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      (_a5 = this.backoff) === null || _a5 === void 0 ? void 0 : _a5.setMax(v);
      return this;
    }
    timeout(v) {
      if (!arguments.length)
        return this._timeout;
      this._timeout = v;
      return this;
    }
    maybeReconnectOnOpen() {
      if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
        this.reconnect();
      }
    }
    open(fn) {
      debug("readyState %s", this._readyState);
      if (~this._readyState.indexOf("open"))
        return this;
      debug("opening %s", this.uri);
      this.engine = eio(this.uri, this.opts);
      const socket2 = this.engine;
      const self2 = this;
      this._readyState = "opening";
      this.skipReconnect = false;
      const openSub = on_1.on(socket2, "open", function() {
        self2.onopen();
        fn && fn();
      });
      const errorSub = on_1.on(socket2, "error", (err) => {
        debug("error");
        self2.cleanup();
        self2._readyState = "closed";
        super.emit("error", err);
        if (fn) {
          fn(err);
        } else {
          self2.maybeReconnectOnOpen();
        }
      });
      if (this._timeout !== false) {
        const timeout3 = this._timeout;
        debug("connect attempt will timeout after %d", timeout3);
        if (timeout3 === 0) {
          openSub.destroy();
        }
        const timer = setTimeout(() => {
          debug("connect attempt timed out after %d", timeout3);
          openSub.destroy();
          socket2.close();
          socket2.emit("error", new Error("timeout"));
        }, timeout3);
        this.subs.push({
          destroy: function() {
            clearTimeout(timer);
          }
        });
      }
      this.subs.push(openSub);
      this.subs.push(errorSub);
      return this;
    }
    connect(fn) {
      return this.open(fn);
    }
    onopen() {
      debug("open");
      this.cleanup();
      this._readyState = "open";
      super.emit("open");
      const socket2 = this.engine;
      this.subs.push(on_1.on(socket2, "data", bind2(this, "ondata")), on_1.on(socket2, "ping", bind2(this, "onping")), on_1.on(socket2, "error", bind2(this, "onerror")), on_1.on(socket2, "close", bind2(this, "onclose")), on_1.on(this.decoder, "decoded", bind2(this, "ondecoded")));
    }
    onping() {
      super.emit("ping");
    }
    ondata(data) {
      this.decoder.add(data);
    }
    ondecoded(packet) {
      super.emit("packet", packet);
    }
    onerror(err) {
      debug("error", err);
      super.emit("error", err);
    }
    socket(nsp, opts) {
      let socket2 = this.nsps[nsp];
      if (!socket2) {
        socket2 = new socket_1.Socket(this, nsp, opts);
        this.nsps[nsp] = socket2;
      }
      return socket2;
    }
    _destroy(socket2) {
      const nsps = Object.keys(this.nsps);
      for (const nsp of nsps) {
        const socket3 = this.nsps[nsp];
        if (socket3.active) {
          debug("socket %s is still active, skipping close", nsp);
          return;
        }
      }
      this._close();
    }
    _packet(packet) {
      debug("writing packet %j", packet);
      if (packet.query && packet.type === 0)
        packet.nsp += "?" + packet.query;
      const encodedPackets = this.encoder.encode(packet);
      for (let i = 0; i < encodedPackets.length; i++) {
        this.engine.write(encodedPackets[i], packet.options);
      }
    }
    cleanup() {
      debug("cleanup");
      const subsLength = this.subs.length;
      for (let i = 0; i < subsLength; i++) {
        const sub = this.subs.shift();
        sub.destroy();
      }
      this.decoder.destroy();
    }
    _close() {
      debug("disconnect");
      this.skipReconnect = true;
      this._reconnecting = false;
      if (this._readyState === "opening") {
        this.cleanup();
      }
      this.backoff.reset();
      this._readyState = "closed";
      if (this.engine)
        this.engine.close();
    }
    disconnect() {
      return this._close();
    }
    onclose(reason) {
      debug("onclose");
      this.cleanup();
      this.backoff.reset();
      this._readyState = "closed";
      super.emit("close", reason);
      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    }
    reconnect() {
      if (this._reconnecting || this.skipReconnect)
        return this;
      const self2 = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug("reconnect failed");
        this.backoff.reset();
        super.emit("reconnect_failed");
        this._reconnecting = false;
      } else {
        const delay2 = this.backoff.duration();
        debug("will wait %dms before reconnect attempt", delay2);
        this._reconnecting = true;
        const timer = setTimeout(() => {
          if (self2.skipReconnect)
            return;
          debug("attempting reconnect");
          super.emit("reconnect_attempt", self2.backoff.attempts);
          if (self2.skipReconnect)
            return;
          self2.open((err) => {
            if (err) {
              debug("reconnect attempt error");
              self2._reconnecting = false;
              self2.reconnect();
              super.emit("reconnect_error", err);
            } else {
              debug("reconnect success");
              self2.onreconnect();
            }
          });
        }, delay2);
        this.subs.push({
          destroy: function() {
            clearTimeout(timer);
          }
        });
      }
    }
    onreconnect() {
      const attempt = this.backoff.attempts;
      this._reconnecting = false;
      this.backoff.reset();
      super.emit("reconnect", attempt);
    }
  };
  exports.Manager = Manager;
});

// ../../node_modules/socket.io-client/build/index.js
var require_build = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Socket = exports.io = exports.Manager = exports.protocol = void 0;
  var url_1 = require_url();
  var manager_1 = require_manager();
  var socket_1 = require_socket2();
  Object.defineProperty(exports, "Socket", {enumerable: true, get: function() {
    return socket_1.Socket;
  }});
  var debug = require_browser()("socket.io-client");
  module.exports = exports = lookup;
  var cache = exports.managers = {};
  function lookup(uri, opts) {
    if (typeof uri === "object") {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    const parsed = url_1.url(uri);
    const source = parsed.source;
    const id = parsed.id;
    const path3 = parsed.path;
    const sameNamespace = cache[id] && path3 in cache[id]["nsps"];
    const newConnection = opts.forceNew || opts["force new connection"] || opts.multiplex === false || sameNamespace;
    let io2;
    if (newConnection) {
      debug("ignoring socket cache for %s", source);
      io2 = new manager_1.Manager(source, opts);
    } else {
      if (!cache[id]) {
        debug("new io instance for %s", source);
        cache[id] = new manager_1.Manager(source, opts);
      }
      io2 = cache[id];
    }
    if (parsed.query && !opts.query) {
      opts.query = parsed.query;
    }
    return io2.socket(parsed.path, opts);
  }
  exports.io = lookup;
  var socket_io_parser_1 = require_dist();
  Object.defineProperty(exports, "protocol", {enumerable: true, get: function() {
    return socket_io_parser_1.protocol;
  }});
  exports.connect = lookup;
  var manager_2 = require_manager();
  Object.defineProperty(exports, "Manager", {enumerable: true, get: function() {
    return manager_2.Manager;
  }});
});

// ../../node_modules/lodash/lodash.js
var require_lodash = __commonJS((exports, module) => {
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  (function() {
    var undefined2;
    var VERSION = "4.17.20";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH2 = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH2 - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH2 >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof self == "object" && self && self.Object === Object && self;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types4 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types4) {
          return types4;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply2(func3, thisArg, args) {
      switch (args.length) {
        case 0:
          return func3.call(thisArg);
        case 1:
          return func3.call(thisArg, args[0]);
        case 2:
          return func3.call(thisArg, args[0], args[1]);
        case 3:
          return func3.call(thisArg, args[0], args[1], args[2]);
      }
      return func3.apply(thisArg, args);
    }
    function arrayAggregator(array4, setter, iteratee, accumulator) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        var value = array4[index2];
        setter(accumulator, value, iteratee(value), array4);
      }
      return accumulator;
    }
    function arrayEach(array4, iteratee) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        if (iteratee(array4[index2], index2, array4) === false) {
          break;
        }
      }
      return array4;
    }
    function arrayEachRight(array4, iteratee) {
      var length = array4 == null ? 0 : array4.length;
      while (length--) {
        if (iteratee(array4[length], length, array4) === false) {
          break;
        }
      }
      return array4;
    }
    function arrayEvery(array4, predicate3) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        if (!predicate3(array4[index2], index2, array4)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array4, predicate3) {
      var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array4[index2];
        if (predicate3(value, index2, array4)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array4, value) {
      var length = array4 == null ? 0 : array4.length;
      return !!length && baseIndexOf(array4, value, 0) > -1;
    }
    function arrayIncludesWith(array4, value, comparator) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        if (comparator(value, array4[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array4, iteratee) {
      var index2 = -1, length = array4 == null ? 0 : array4.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array4[index2], index2, array4);
      }
      return result;
    }
    function arrayPush(array4, values) {
      var index2 = -1, length = values.length, offset = array4.length;
      while (++index2 < length) {
        array4[offset + index2] = values[index2];
      }
      return array4;
    }
    function arrayReduce(array4, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      if (initAccum && length) {
        accumulator = array4[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array4[index2], index2, array4);
      }
      return accumulator;
    }
    function arrayReduceRight(array4, iteratee, accumulator, initAccum) {
      var length = array4 == null ? 0 : array4.length;
      if (initAccum && length) {
        accumulator = array4[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array4[length], length, array4);
      }
      return accumulator;
    }
    function arraySome(array4, predicate3) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        if (predicate3(array4[index2], index2, array4)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string5) {
      return string5.split("");
    }
    function asciiWords(string5) {
      return string5.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate3, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate3(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array4, predicate3, fromIndex, fromRight) {
      var length = array4.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate3(array4[index2], index2, array4)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array4, value, fromIndex) {
      return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array4, value, fromIndex, comparator) {
      var index2 = fromIndex - 1, length = array4.length;
      while (++index2 < length) {
        if (comparator(array4[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array4, iteratee) {
      var length = array4 == null ? 0 : array4.length;
      return length ? baseSum(array4, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object2) {
        return object2 == null ? undefined2 : object2[key];
      };
    }
    function basePropertyOf(object2) {
      return function(key) {
        return object2 == null ? undefined2 : object2[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array4, comparer) {
      var length = array4.length;
      array4.sort(comparer);
      while (length--) {
        array4[length] = array4[length].value;
      }
      return array4;
    }
    function baseSum(array4, iteratee) {
      var result, index2 = -1, length = array4.length;
      while (++index2 < length) {
        var current2 = iteratee(array4[index2]);
        if (current2 !== undefined2) {
          result = result === undefined2 ? current2 : result + current2;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object2, props) {
      return arrayMap(props, function(key) {
        return [key, object2[key]];
      });
    }
    function baseUnary(func3) {
      return function(value) {
        return func3(value);
      };
    }
    function baseValues(object2, props) {
      return arrayMap(props, function(key) {
        return object2[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array4, placeholder) {
      var length = array4.length, result = 0;
      while (length--) {
        if (array4[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object2, key) {
      return object2 == null ? undefined2 : object2[key];
    }
    function hasUnicode(string5) {
      return reHasUnicode.test(string5);
    }
    function hasUnicodeWord(string5) {
      return reHasUnicodeWord.test(string5);
    }
    function iteratorToArray(iterator3) {
      var data, result = [];
      while (!(data = iterator3.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func3, transform) {
      return function(arg) {
        return func3(transform(arg));
      };
    }
    function replaceHolders(array4, placeholder) {
      var index2 = -1, length = array4.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array4[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array4[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set5) {
      var index2 = -1, result = Array(set5.size);
      set5.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set5) {
      var index2 = -1, result = Array(set5.size);
      set5.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array4, value, fromIndex) {
      var index2 = fromIndex - 1, length = array4.length;
      while (++index2 < length) {
        if (array4[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array4, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array4[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string5) {
      return hasUnicode(string5) ? unicodeSize(string5) : asciiSize(string5);
    }
    function stringToArray(string5) {
      return hasUnicode(string5) ? unicodeToArray(string5) : asciiToArray(string5);
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string5) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string5)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string5) {
      return string5.match(reUnicode) || [];
    }
    function unicodeWords(string5) {
      return string5.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context2) {
      context2 = context2 == null ? root : _.defaults(root.Object(), context2, _.pick(root, contextProps));
      var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context2["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty5 = objectProto.hasOwnProperty;
      var idCounter2 = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty5).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context2.Buffer : undefined2, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
      var defineProperty = function() {
        try {
          var func3 = getNative(Object2, "defineProperty");
          func3({}, "", {});
          return func3;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context2.clearTimeout !== root.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root.setTimeout && context2.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash(value) {
        if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty5.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object2() {
        }
        return function(proto) {
          if (!isObject3(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object2.prototype = proto;
          var result2 = new object2();
          object2.prototype = undefined2;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined2;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH2;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array4 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array4), isRight = dir < 0, arrLength = isArr ? array4.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array4, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array4[index2];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries3) {
        var index2 = -1, length = entries3 == null ? 0 : entries3.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries3[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined2 : result2;
        }
        return hasOwnProperty5.call(data, key) ? data[key] : undefined2;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty5.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries3) {
        var index2 = -1, length = entries3 == null ? 0 : entries3.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries3[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? undefined2 : data[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries3) {
        var index2 = -1, length = entries3 == null ? 0 : entries3.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries3[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash(),
          map: new (Map2 || ListCache)(),
          string: new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries3) {
        var data = this.__data__ = new ListCache(entries3);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array4) {
        var length = array4.length;
        return length ? array4[baseRandom(0, length - 1)] : undefined2;
      }
      function arraySampleSize(array4, n) {
        return shuffleSelf(copyArray(array4), baseClamp(n, 0, array4.length));
      }
      function arrayShuffle(array4) {
        return shuffleSelf(copyArray(array4));
      }
      function assignMergeValue(object2, key, value) {
        if (value !== undefined2 && !eq(object2[key], value) || value === undefined2 && !(key in object2)) {
          baseAssignValue(object2, key, value);
        }
      }
      function assignValue(object2, key, value) {
        var objValue = object2[key];
        if (!(hasOwnProperty5.call(object2, key) && eq(objValue, value)) || value === undefined2 && !(key in object2)) {
          baseAssignValue(object2, key, value);
        }
      }
      function assocIndexOf(array4, key) {
        var length = array4.length;
        while (length--) {
          if (eq(array4[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object2, source) {
        return object2 && copyObject(source, keys(source), object2);
      }
      function baseAssignIn(object2, source) {
        return object2 && copyObject(source, keysIn(source), object2);
      }
      function baseAssignValue(object2, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object2, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        } else {
          object2[key] = value;
        }
      }
      function baseAt(object2, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object2 == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined2 : get(object2, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined2) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined2) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object2, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object2 ? customizer(value, key, object2, stack) : customizer(value);
        }
        if (result2 !== undefined2) {
          return result2;
        }
        if (!isObject3(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object2) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object2 ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined2 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object2) {
          return baseConformsTo(object2, source, props);
        };
      }
      function baseConformsTo(object2, source, props) {
        var length = props.length;
        if (object2 == null) {
          return !length;
        }
        object2 = Object2(object2);
        while (length--) {
          var key = props[length], predicate3 = source[key], value = object2[key];
          if (value === undefined2 && !(key in object2) || !predicate3(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func3, wait, args) {
        if (typeof func3 != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func3.apply(undefined2, args);
        }, wait);
      }
      function baseDifference(array4, values2, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array4.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array4[index2], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate3) {
        var result2 = true;
        baseEach(collection, function(value, index2, collection2) {
          result2 = !!predicate3(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array4, iteratee2, comparator) {
        var index2 = -1, length = array4.length;
        while (++index2 < length) {
          var value = array4[index2], current2 = iteratee2(value);
          if (current2 != null && (computed === undefined2 ? current2 === current2 && !isSymbol(current2) : comparator(current2, computed))) {
            var computed = current2, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array4, value, start, end) {
        var length = array4.length;
        start = toInteger2(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined2 || end > length ? length : toInteger2(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array4[start++] = value;
        }
        return array4;
      }
      function baseFilter(collection, predicate3) {
        var result2 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate3(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array4, depth, predicate3, isStrict, result2) {
        var index2 = -1, length = array4.length;
        predicate3 || (predicate3 = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value = array4[index2];
          if (depth > 0 && predicate3(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate3, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object2, iteratee2) {
        return object2 && baseFor(object2, iteratee2, keys);
      }
      function baseForOwnRight(object2, iteratee2) {
        return object2 && baseForRight(object2, iteratee2, keys);
      }
      function baseFunctions(object2, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object2[key]);
        });
      }
      function baseGet(object2, path3) {
        path3 = castPath(path3, object2);
        var index2 = 0, length = path3.length;
        while (object2 != null && index2 < length) {
          object2 = object2[toKey(path3[index2++])];
        }
        return index2 && index2 == length ? object2 : undefined2;
      }
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object2);
        return isArray2(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined2 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object2, key) {
        return object2 != null && hasOwnProperty5.call(object2, key);
      }
      function baseHasIn(object2, key) {
        return object2 != null && key in Object2(object2);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays5, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays5[0].length, othLength = arrays5.length, othIndex = othLength, caches2 = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array4 = arrays5[othIndex];
          if (othIndex && iteratee2) {
            array4 = arrayMap(array4, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array4.length, maxLength);
          caches2[othIndex] = !comparator && (iteratee2 || length >= 120 && array4.length >= 120) ? new SetCache(othIndex && array4) : undefined2;
        }
        array4 = arrays5[0];
        var index2 = -1, seen = caches2[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value = array4[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches2[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays5[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object2, setter, iteratee2, accumulator) {
        baseForOwn(object2, function(value, key, object3) {
          setter(accumulator, iteratee2(value), key, object3);
        });
        return accumulator;
      }
      function baseInvoke(object2, path3, args) {
        path3 = castPath(path3, object2);
        object2 = parent2(object2, path3);
        var func3 = object2 == null ? object2 : object2[toKey(last(path3))];
        return func3 == null ? undefined2 : apply2(func3, object2, args);
      }
      function baseIsArguments(value) {
        return isObjectLike2(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike2(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike2(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object2)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty5.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty5.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike2(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object2, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object2 == null) {
          return !length;
        }
        object2 = Object2(object2);
        while (index2--) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
            return false;
          }
        }
        while (++index2 < length) {
          data = matchData[index2];
          var key = data[0], objValue = object2[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined2 && !(key in object2)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object2, source, stack);
            }
            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject3(value) || isMasked(value)) {
          return false;
        }
        var pattern3 = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern3.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike2(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike2(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity3;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys(object2);
        }
        var result2 = [];
        for (var key in Object2(object2)) {
          if (hasOwnProperty5.call(object2, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object2) {
        if (!isObject3(object2)) {
          return nativeKeysIn(object2);
        }
        var isProto = isPrototype(object2), result2 = [];
        for (var key in object2) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty5.call(object2, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index2] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object2) {
          return object2 === source || baseIsMatch(object2, source, matchData);
        };
      }
      function baseMatchesProperty(path3, srcValue) {
        if (isKey(path3) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path3), srcValue);
        }
        return function(object2) {
          var objValue = get(object2, path3);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object2, path3) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object2, source, srcIndex, customizer, stack) {
        if (object2 === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject3(srcValue)) {
            baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object2, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object2, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject3(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object2, key, newValue);
      }
      function baseNth(array4, n) {
        var length = array4.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array4[n] : undefined2;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity3];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return {criteria, index: ++index2, value};
        });
        return baseSortBy(result2, function(object2, other) {
          return compareMultiple(object2, other, orders);
        });
      }
      function basePick(object2, paths) {
        return basePickBy(object2, paths, function(value, path3) {
          return hasIn(object2, path3);
        });
      }
      function basePickBy(object2, paths, predicate3) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path3 = paths[index2], value = baseGet(object2, path3);
          if (predicate3(value, path3)) {
            baseSet(result2, castPath(path3, object2), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path3) {
        return function(object2) {
          return baseGet(object2, path3);
        };
      }
      function basePullAll(array4, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array4;
        if (array4 === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array4, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array4) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array4, fromIndex, 1);
          }
        }
        return array4;
      }
      function basePullAt(array4, indexes) {
        var length = array4 ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice.call(array4, index2, 1);
            } else {
              baseUnset(array4, index2);
            }
          }
        }
        return array4;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string5, n) {
        var result2 = "";
        if (!string5 || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string5;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string5 += string5;
          }
        } while (n);
        return result2;
      }
      function baseRest(func3, start) {
        return setToString(overRest(func3, start, identity3), func3 + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array4 = values(collection);
        return shuffleSelf(array4, baseClamp(n, 0, array4.length));
      }
      function baseSet(object2, path3, value, customizer) {
        if (!isObject3(object2)) {
          return object2;
        }
        path3 = castPath(path3, object2);
        var index2 = -1, length = path3.length, lastIndex = length - 1, nested = object2;
        while (nested != null && ++index2 < length) {
          var key = toKey(path3[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object2;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined2;
            if (newValue === undefined2) {
              newValue = isObject3(objValue) ? objValue : isIndex(path3[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object2;
      }
      var baseSetData = !metaMap ? identity3 : function(func3, data) {
        metaMap.set(func3, data);
        return func3;
      };
      var baseSetToString = !defineProperty ? identity3 : function(func3, string5) {
        return defineProperty(func3, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string5),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array4, start, end) {
        var index2 = -1, length = array4.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array4[index2 + start];
        }
        return result2;
      }
      function baseSome(collection, predicate3) {
        var result2;
        baseEach(collection, function(value, index2, collection2) {
          result2 = predicate3(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array4, value, retHighest) {
        var low = 0, high = array4 == null ? low : array4.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array4[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array4, value, identity3, retHighest);
      }
      function baseSortedIndexBy(array4, value, iteratee2, retHighest) {
        var low = 0, high = array4 == null ? 0 : array4.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array4[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array4, iteratee2) {
        var index2 = -1, length = array4.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array4[index2], computed = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array4, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length = array4.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set6 = iteratee2 ? null : createSet(array4);
          if (set6) {
            return setToArray(set6);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value = array4[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object2, path3) {
        path3 = castPath(path3, object2);
        object2 = parent2(object2, path3);
        return object2 == null || delete object2[toKey(last(path3))];
      }
      function baseUpdate(object2, path3, updater, customizer) {
        return baseSet(object2, path3, updater(baseGet(object2, path3)), customizer);
      }
      function baseWhile(array4, predicate3, isDrop, fromRight) {
        var length = array4.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate3(array4[index2], index2, array4)) {
        }
        return isDrop ? baseSlice(array4, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array4, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value, actions25) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions25, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays5, iteratee2, comparator) {
        var length = arrays5.length;
        if (length < 2) {
          return length ? baseUniq(arrays5[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array4 = arrays5[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array4, arrays5[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : undefined2;
          assignFunc(result2, props[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity3;
      }
      function castPath(value, object2) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object2) ? [value] : stringToPath(toString5(value));
      }
      var castRest = baseRest;
      function castSlice(array4, start, end) {
        var length = array4.length;
        end = end === undefined2 ? length : end;
        return !start && end >= length ? array4 : baseSlice(array4, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer2, isDeep) {
        if (isDeep) {
          return buffer2.slice();
        }
        var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
        buffer2.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol5) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol5)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object2, other, orders) {
        var index2 = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object2.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array4) {
        var index2 = -1, length = source.length;
        array4 || (array4 = Array2(length));
        while (++index2 < length) {
          array4[index2] = source[index2];
        }
        return array4;
      }
      function copyObject(source, props, object2, customizer) {
        var isNew = !object2;
        object2 || (object2 = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : undefined2;
          if (newValue === undefined2) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object2, key, newValue);
          } else {
            assignValue(object2, key, newValue);
          }
        }
        return object2;
      }
      function copySymbols(source, object2) {
        return copyObject(source, getSymbols(source), object2);
      }
      function copySymbolsIn(source, object2) {
        return copyObject(source, getSymbolsIn(source), object2);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func3 = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func3(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object2, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object2 = Object2(object2);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object2, source, index2, customizer);
            }
          }
          return object2;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object2, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object2), props = keysFunc(object2), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object2;
        };
      }
      function createBind(func3, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func3);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func3;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string5) {
          string5 = toString5(string5);
          var strSymbols = hasUnicode(string5) ? stringToArray(string5) : undefined2;
          var chr = strSymbols ? strSymbols[0] : string5.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string5.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string5) {
          return arrayReduce(words(deburr(string5).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject3(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func3, bitmask, arity) {
        var Ctor = createCtor(func3);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func3, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func3;
          return apply2(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate3, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate3, 3);
            collection = keys(collection);
            predicate3 = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate3, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func3 = funcs[index2];
            if (typeof func3 != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func3) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func3 = funcs[index2];
            var funcName = getFuncName(func3), data = funcName == "wrapper" ? getData(func3) : undefined2;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func3.length == 1 && isLaziable(func3) ? wrapper[funcName]() : wrapper.thru(func3);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func3, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func3);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func3, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func3] : func3;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object2, iteratee2) {
          return baseInverter(object2, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined2 && other === undefined2) {
            return defaultValue;
          }
          if (value !== undefined2) {
            result2 = value;
          }
          if (other !== undefined2) {
            if (result2 === undefined2) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply2(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined2 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func3, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func3);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func3;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply2(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined2;
          }
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func3, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func3,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined2, newData);
        if (isLaziable(func3)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func3, bitmask);
      }
      function createRound(methodName) {
        var func3 = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger2(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString5(number) + "e").split("e"), value = func3(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString5(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func3(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop5 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object2) {
          var tag = getTag(object2);
          if (tag == mapTag) {
            return mapToArray(object2);
          }
          if (tag == setTag) {
            return setToPairs(object2);
          }
          return baseToPairs(object2, keysFunc(object2));
        };
      }
      function createWrap(func3, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func3 != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined2;
        }
        ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger2(ary2), 0);
        arity = arity === undefined2 ? arity : toInteger2(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined2;
        }
        var data = isBindKey ? undefined2 : getData(func3);
        var newData = [
          func3,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func3 = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func3.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func3, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func3, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func3, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined2, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func3, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object2) {
        if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty5.call(object2, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
        if (isObject3(objValue) && isObject3(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined2 : value;
      }
      function equalArrays(array4, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array4.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array4);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array4;
        }
        var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
        stack.set(array4, other);
        stack.set(other, array4);
        while (++index2 < arrLength) {
          var arrValue = array4[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack) : customizer(arrValue, othValue, index2, array4, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array4);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object2, other);
            var result2 = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty5.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object2);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object2;
        }
        var result2 = true;
        stack.set(object2, other);
        stack.set(other, object2);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object2[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object2);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func3) {
        return setToString(overRest(func3, undefined2, flatten3), func3 + "");
      }
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys, getSymbols);
      }
      function getAllKeysIn(object2) {
        return baseGetAllKeys(object2, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop5 : function(func3) {
        return metaMap.get(func3);
      };
      function getFuncName(func3) {
        var result2 = func3.name + "", array4 = realNames[result2], length = hasOwnProperty5.call(realNames, result2) ? array4.length : 0;
        while (length--) {
          var data = array4[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func3) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func3) {
        var object2 = hasOwnProperty5.call(lodash, "placeholder") ? lodash : func3;
        return object2.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object2) {
        var result2 = keys(object2), length = result2.length;
        while (length--) {
          var key = result2[length], value = object2[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object2, key) {
        var value = getValue(object2, key);
        return baseIsNative(value) ? value : undefined2;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty5.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined2;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object2(object2);
        return arrayFilter(nativeGetSymbols(object2), function(symbol5) {
          return propertyIsEnumerable.call(object2, symbol5);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
        var result2 = [];
        while (object2) {
          arrayPush(result2, getSymbols(object2));
          object2 = getPrototype(object2);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data = transforms[index2], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return {start, end};
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object2, path3, hasFunc) {
        path3 = castPath(path3, object2);
        var index2 = -1, length = path3.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path3[index2]);
          if (!(result2 = object2 != null && hasFunc(object2, key))) {
            break;
          }
          object2 = object2[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object2 == null ? 0 : object2.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray2(object2) || isArguments(object2));
      }
      function initCloneArray(array4) {
        var length = array4.length, result2 = new array4.constructor(length);
        if (length && typeof array4[0] == "string" && hasOwnProperty5.call(array4, "index")) {
          result2.index = array4.index;
          result2.input = array4.input;
        }
        return result2;
      }
      function initCloneObject(object2) {
        return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
      }
      function initCloneByTag(object2, tag, isDeep) {
        var Ctor = object2.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object2);
          case boolTag:
          case dateTag:
            return new Ctor(+object2);
          case dataViewTag:
            return cloneDataView(object2, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object2, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object2);
          case regexpTag:
            return cloneRegExp(object2);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object2);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index2, object2) {
        if (!isObject3(object2)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object2) && isIndex(index2, object2.length) : type == "string" && index2 in object2) {
          return eq(object2[index2], value);
        }
        return false;
      }
      function isKey(value, object2) {
        if (isArray2(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object2(object2);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func3) {
        var funcName = getFuncName(func3), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func3 === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func3 === data[0];
      }
      function isMasked(func3) {
        return !!maskSrcKey && maskSrcKey in func3;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject3(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object2) {
          if (object2 == null) {
            return false;
          }
          return object2[key] === srcValue && (srcValue !== undefined2 || key in Object2(object2));
        };
      }
      function memoizeCapped(func3) {
        var result2 = memoize(func3, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object2) {
        var result2 = [];
        if (object2 != null) {
          for (var key in Object2(object2)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func3, start, transform2) {
        start = nativeMax(start === undefined2 ? func3.length - 1 : start, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array4 = Array2(length);
          while (++index2 < length) {
            array4[index2] = args[start + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start] = transform2(array4);
          return apply2(func3, this, otherArgs);
        };
      }
      function parent2(object2, path3) {
        return path3.length < 2 ? object2 : baseGet(object2, baseSlice(path3, 0, -1));
      }
      function reorder(array4, indexes) {
        var arrLength = array4.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array4);
        while (length--) {
          var index2 = indexes[length];
          array4[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
        }
        return array4;
      }
      function safeGet(object2, key) {
        if (key === "constructor" && typeof object2[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object2[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func3, wait) {
        return root.setTimeout(func3, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func3) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func3.apply(undefined2, arguments);
        };
      }
      function shuffleSelf(array4, size2) {
        var index2 = -1, length = array4.length, lastIndex = length - 1;
        size2 = size2 === undefined2 ? length : size2;
        while (++index2 < size2) {
          var rand = baseRandom(index2, lastIndex), value = array4[rand];
          array4[rand] = array4[index2];
          array4[index2] = value;
        }
        array4.length = size2;
        return array4;
      }
      var stringToPath = memoizeCapped(function(string5) {
        var result2 = [];
        if (string5.charCodeAt(0) === 46) {
          result2.push("");
        }
        string5.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func3) {
        if (func3 != null) {
          try {
            return funcToString.call(func3);
          } catch (e) {
          }
          try {
            return func3 + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array4, size2, guard) {
        if (guard ? isIterateeCall(array4, size2, guard) : size2 === undefined2) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger2(size2), 0);
        }
        var length = array4 == null ? 0 : array4.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array4, index2, index2 += size2);
        }
        return result2;
      }
      function compact2(array4) {
        var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array4[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat2() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array4 = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray2(array4) ? copyArray(array4) : [array4], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array4, values2) {
        return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array4, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array4, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined2;
        }
        return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
      });
      function drop(array4, n, guard) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger2(n);
        return baseSlice(array4, n < 0 ? 0 : n, length);
      }
      function dropRight(array4, n, guard) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger2(n);
        n = length - n;
        return baseSlice(array4, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array4, predicate3) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate3, 3), true, true) : [];
      }
      function dropWhile(array4, predicate3) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate3, 3), true) : [];
      }
      function fill(array4, value, start, end) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array4, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array4, value, start, end);
      }
      function findIndex(array4, predicate3, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array4, getIteratee(predicate3, 3), index2);
      }
      function findLastIndex(array4, predicate3, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined2) {
          index2 = toInteger2(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array4, getIteratee(predicate3, 3), index2, true);
      }
      function flatten3(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseFlatten(array4, 1) : [];
      }
      function flattenDeep(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseFlatten(array4, INFINITY) : [];
      }
      function flattenDepth(array4, depth) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined2 ? 1 : toInteger2(depth);
        return baseFlatten(array4, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array4) {
        return array4 && array4.length ? array4[0] : undefined2;
      }
      function indexOf(array4, value, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array4, value, index2);
      }
      function initial(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseSlice(array4, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays5) {
        var mapped = arrayMap(arrays5, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays5[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays5) {
        var iteratee2 = last(arrays5), mapped = arrayMap(arrays5, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined2;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays5[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays5) {
        var comparator = last(arrays5), mapped = arrayMap(arrays5, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays5[0] ? baseIntersection(mapped, undefined2, comparator) : [];
      });
      function join4(array4, separator) {
        return array4 == null ? "" : nativeJoin.call(array4, separator);
      }
      function last(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? array4[length - 1] : undefined2;
      }
      function lastIndexOf(array4, value, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined2) {
          index2 = toInteger2(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array4, value, index2) : baseFindIndex(array4, baseIsNaN, index2, true);
      }
      function nth(array4, n) {
        return array4 && array4.length ? baseNth(array4, toInteger2(n)) : undefined2;
      }
      var pull = baseRest(pullAll);
      function pullAll(array4, values2) {
        return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2) : array4;
      }
      function pullAllBy(array4, values2, iteratee2) {
        return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, getIteratee(iteratee2, 2)) : array4;
      }
      function pullAllWith(array4, values2, comparator) {
        return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, undefined2, comparator) : array4;
      }
      var pullAt = flatRest(function(array4, indexes) {
        var length = array4 == null ? 0 : array4.length, result2 = baseAt(array4, indexes);
        basePullAt(array4, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove2(array4, predicate3) {
        var result2 = [];
        if (!(array4 && array4.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array4.length;
        predicate3 = getIteratee(predicate3, 3);
        while (++index2 < length) {
          var value = array4[index2];
          if (predicate3(value, index2, array4)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array4, indexes);
        return result2;
      }
      function reverse(array4) {
        return array4 == null ? array4 : nativeReverse.call(array4);
      }
      function slice2(array4, start, end) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array4, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger2(start);
          end = end === undefined2 ? length : toInteger2(end);
        }
        return baseSlice(array4, start, end);
      }
      function sortedIndex(array4, value) {
        return baseSortedIndex(array4, value);
      }
      function sortedIndexBy(array4, value, iteratee2) {
        return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array4, value) {
        var length = array4 == null ? 0 : array4.length;
        if (length) {
          var index2 = baseSortedIndex(array4, value);
          if (index2 < length && eq(array4[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array4, value) {
        return baseSortedIndex(array4, value, true);
      }
      function sortedLastIndexBy(array4, value, iteratee2) {
        return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array4, value) {
        var length = array4 == null ? 0 : array4.length;
        if (length) {
          var index2 = baseSortedIndex(array4, value, true) - 1;
          if (eq(array4[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array4) {
        return array4 && array4.length ? baseSortedUniq(array4) : [];
      }
      function sortedUniqBy(array4, iteratee2) {
        return array4 && array4.length ? baseSortedUniq(array4, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseSlice(array4, 1, length) : [];
      }
      function take2(array4, n, guard) {
        if (!(array4 && array4.length)) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger2(n);
        return baseSlice(array4, 0, n < 0 ? 0 : n);
      }
      function takeRight(array4, n, guard) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger2(n);
        n = length - n;
        return baseSlice(array4, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array4, predicate3) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate3, 3), false, true) : [];
      }
      function takeWhile(array4, predicate3) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate3, 3)) : [];
      }
      var union = baseRest(function(arrays5) {
        return baseUniq(baseFlatten(arrays5, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays5) {
        var iteratee2 = last(arrays5);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseUniq(baseFlatten(arrays5, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays5) {
        var comparator = last(arrays5);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseUniq(baseFlatten(arrays5, 1, isArrayLikeObject, true), undefined2, comparator);
      });
      function uniq(array4) {
        return array4 && array4.length ? baseUniq(array4) : [];
      }
      function uniqBy(array4, iteratee2) {
        return array4 && array4.length ? baseUniq(array4, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array4, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return array4 && array4.length ? baseUniq(array4, undefined2, comparator) : [];
      }
      function unzip(array4) {
        if (!(array4 && array4.length)) {
          return [];
        }
        var length = 0;
        array4 = arrayFilter(array4, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array4, baseProperty(index2));
        });
      }
      function unzipWith(array4, iteratee2) {
        if (!(array4 && array4.length)) {
          return [];
        }
        var result2 = unzip(array4);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply2(iteratee2, undefined2, group);
        });
      }
      var without = baseRest(function(array4, values2) {
        return isArrayLikeObject(array4) ? baseDifference(array4, values2) : [];
      });
      var xor = baseRest(function(arrays5) {
        return baseXor(arrayFilter(arrays5, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays5) {
        var iteratee2 = last(arrays5);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseXor(arrayFilter(arrays5, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays5) {
        var comparator = last(arrays5);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseXor(arrayFilter(arrays5, isArrayLikeObject), undefined2, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays5) {
        var length = arrays5.length, iteratee2 = length > 1 ? arrays5[length - 1] : undefined2;
        iteratee2 = typeof iteratee2 == "function" ? (arrays5.pop(), iteratee2) : undefined2;
        return unzipWith(arrays5, iteratee2);
      });
      function chain(value) {
        var result2 = lodash(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
          return baseAt(object2, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined2
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array4) {
          if (length && !array4.length) {
            array4.push(undefined2);
          }
          return array4;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined2) {
          this.__values__ = toArray(this.value());
        }
        var done3 = this.__index__ >= this.__values__.length, value = done3 ? undefined2 : this.__values__[this.__index__++];
        return {done: done3, value};
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent3 = this;
        while (parent3 instanceof baseLodash) {
          var clone2 = wrapperClone(parent3);
          clone2.__index__ = 0;
          clone2.__values__ = undefined2;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent3 = parent3.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined2
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty5.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate3, guard) {
        var func3 = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate3, guard)) {
          predicate3 = undefined2;
        }
        return func3(collection, getIteratee(predicate3, 3));
      }
      function filter2(collection, predicate3) {
        var func3 = isArray2(collection) ? arrayFilter : baseFilter;
        return func3(collection, getIteratee(predicate3, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap3(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined2 ? 1 : toInteger2(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach2(collection, iteratee2) {
        var func3 = isArray2(collection) ? arrayEach : baseEach;
        return func3(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func3 = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func3(collection, getIteratee(iteratee2, 3));
      }
      var groupBy2 = createAggregator(function(result2, value, key) {
        if (hasOwnProperty5.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path3, args) {
        var index2 = -1, isFunc = typeof path3 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply2(path3, value, args) : baseInvoke(value, path3, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func3 = isArray2(collection) ? arrayMap : baseMap;
        return func3(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined2 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func3 = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func3(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func3 = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func3(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate3) {
        var func3 = isArray2(collection) ? arrayFilter : baseFilter;
        return func3(collection, negate(getIteratee(predicate3, 3)));
      }
      function sample(collection) {
        var func3 = isArray2(collection) ? arraySample : baseSample;
        return func3(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger2(n);
        }
        var func3 = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func3(collection, n);
      }
      function shuffle(collection) {
        var func3 = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func3(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate3, guard) {
        var func3 = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate3, guard)) {
          predicate3 = undefined2;
        }
        return func3(collection, getIteratee(predicate3, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func3) {
        if (typeof func3 != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger2(n);
        return function() {
          if (--n < 1) {
            return func3.apply(this, arguments);
          }
        };
      }
      function ary(func3, n, guard) {
        n = guard ? undefined2 : n;
        n = func3 && n == null ? func3.length : n;
        return createWrap(func3, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
      }
      function before(n, func3) {
        var result2;
        if (typeof func3 != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger2(n);
        return function() {
          if (--n > 0) {
            result2 = func3.apply(this, arguments);
          }
          if (n <= 1) {
            func3 = undefined2;
          }
          return result2;
        };
      }
      var bind2 = baseRest(function(func3, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind2));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func3, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object2, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object2, partials, holders);
      });
      function curry(func3, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func3, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func3, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func3, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce3(func3, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func3 != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject3(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined2;
          lastInvokeTime = time;
          result2 = func3.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined2;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined2;
          return result2;
        }
        function cancel2() {
          if (timerId !== undefined2) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined2;
        }
        function flush3() {
          return timerId === undefined2 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined2) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined2) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel2;
        debounced.flush = flush3;
        return debounced;
      }
      var defer = baseRest(function(func3, args) {
        return baseDelay(func3, 1, args);
      });
      var delay2 = baseRest(function(func3, wait, args) {
        return baseDelay(func3, toNumber(wait) || 0, args);
      });
      function flip(func3) {
        return createWrap(func3, WRAP_FLIP_FLAG);
      }
      function memoize(func3, resolver) {
        if (typeof func3 != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func3.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate3) {
        if (typeof predicate3 != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate3.call(this);
            case 1:
              return !predicate3.call(this, args[0]);
            case 2:
              return !predicate3.call(this, args[0], args[1]);
            case 3:
              return !predicate3.call(this, args[0], args[1], args[2]);
          }
          return !predicate3.apply(this, args);
        };
      }
      function once3(func3) {
        return before(2, func3);
      }
      var overArgs = castRest(function(func3, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply2(func3, this, args);
        });
      });
      var partial = baseRest(function(func3, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func3, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
      });
      var partialRight = baseRest(function(func3, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func3, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
      });
      var rearg = flatRest(function(func3, indexes) {
        return createWrap(func3, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
      });
      function rest(func3, start) {
        if (typeof func3 != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined2 ? start : toInteger2(start);
        return baseRest(func3, start);
      }
      function spread(func3, start) {
        if (typeof func3 != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger2(start), 0);
        return baseRest(function(args) {
          var array4 = args[start], otherArgs = castSlice(args, 0, start);
          if (array4) {
            arrayPush(otherArgs, array4);
          }
          return apply2(func3, this, otherArgs);
        });
      }
      function throttle(func3, wait, options) {
        var leading = true, trailing = true;
        if (typeof func3 != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject3(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce3(func3, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func3) {
        return ary(func3, 1);
      }
      function wrap2(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep2(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object2, source) {
        return source == null || baseConformsTo(object2, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike2(value) && hasOwnProperty5.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike2(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike2(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty2(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty5.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual2(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        var result2 = customizer ? customizer(value, other) : undefined2;
        return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject3(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger2(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject3(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object2, source) {
        return object2 === source || baseIsMatch(object2, source, getMatchData(source));
      }
      function isMatchWith(object2, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseIsMatch(object2, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative2(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike2(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty5.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined2;
      }
      function isWeakMap(value) {
        return isObjectLike2(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike2(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString2(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func3 = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func3(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger2(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH2) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject3(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject3(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString5(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object2, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object2);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty5.call(source, key)) {
            assignValue(object2, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object2, source) {
        copyObject(source, keysIn(source), object2);
      });
      var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object2, customizer);
      });
      var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
        copyObject(source, keys(source), object2, customizer);
      });
      var at = flatRest(baseAt);
      function create2(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object2, sources) {
        object2 = Object2(object2);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined2;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object2[key];
            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty5.call(object2, key)) {
              object2[key] = source[key];
            }
          }
        }
        return object2;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined2, customDefaultsMerge);
        return apply2(mergeWith, undefined2, args);
      });
      function findKey(object2, predicate3) {
        return baseFindKey(object2, getIteratee(predicate3, 3), baseForOwn);
      }
      function findLastKey(object2, predicate3) {
        return baseFindKey(object2, getIteratee(predicate3, 3), baseForOwnRight);
      }
      function forIn(object2, iteratee2) {
        return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object2, iteratee2) {
        return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object2, iteratee2) {
        return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object2, iteratee2) {
        return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
      }
      function functions(object2) {
        return object2 == null ? [] : baseFunctions(object2, keys(object2));
      }
      function functionsIn(object2) {
        return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
      }
      function get(object2, path3, defaultValue) {
        var result2 = object2 == null ? undefined2 : baseGet(object2, path3);
        return result2 === undefined2 ? defaultValue : result2;
      }
      function has(object2, path3) {
        return object2 != null && hasPath(object2, path3, baseHas);
      }
      function hasIn(object2, path3) {
        return object2 != null && hasPath(object2, path3, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity3));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty5.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      function keysIn(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
      }
      function mapKeys(object2, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object2, function(value, key, object3) {
          baseAssignValue(result2, iteratee2(value, key, object3), value);
        });
        return result2;
      }
      function mapValues(object2, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object2, function(value, key, object3) {
          baseAssignValue(result2, key, iteratee2(value, key, object3));
        });
        return result2;
      }
      var merge = createAssigner(function(object2, source, srcIndex) {
        baseMerge(object2, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {
        baseMerge(object2, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object2, paths) {
        var result2 = {};
        if (object2 == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path3) {
          path3 = castPath(path3, object2);
          isDeep || (isDeep = path3.length > 1);
          return path3;
        });
        copyObject(object2, getAllKeysIn(object2), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object2, predicate3) {
        return pickBy(object2, negate(getIteratee(predicate3)));
      }
      var pick = flatRest(function(object2, paths) {
        return object2 == null ? {} : basePick(object2, paths);
      });
      function pickBy(object2, predicate3) {
        if (object2 == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object2), function(prop) {
          return [prop];
        });
        predicate3 = getIteratee(predicate3);
        return basePickBy(object2, props, function(value, path3) {
          return predicate3(value, path3[0]);
        });
      }
      function result(object2, path3, defaultValue) {
        path3 = castPath(path3, object2);
        var index2 = -1, length = path3.length;
        if (!length) {
          length = 1;
          object2 = undefined2;
        }
        while (++index2 < length) {
          var value = object2 == null ? undefined2 : object2[toKey(path3[index2])];
          if (value === undefined2) {
            index2 = length;
            value = defaultValue;
          }
          object2 = isFunction(value) ? value.call(object2) : value;
        }
        return object2;
      }
      function set5(object2, path3, value) {
        return object2 == null ? object2 : baseSet(object2, path3, value);
      }
      function setWith(object2, path3, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object2 == null ? object2 : baseSet(object2, path3, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object2, iteratee2, accumulator) {
        var isArr = isArray2(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray(object2);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object2 && object2.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject3(object2)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object2)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index2, object3) {
          return iteratee2(accumulator, value, index2, object3);
        });
        return accumulator;
      }
      function unset(object2, path3) {
        return object2 == null ? true : baseUnset(object2, path3);
      }
      function update(object2, path3, updater) {
        return object2 == null ? object2 : baseUpdate(object2, path3, castFunction(updater));
      }
      function updateWith(object2, path3, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object2 == null ? object2 : baseUpdate(object2, path3, castFunction(updater), customizer);
      }
      function values(object2) {
        return object2 == null ? [] : baseValues(object2, keys(object2));
      }
      function valuesIn(object2) {
        return object2 == null ? [] : baseValues(object2, keysIn(object2));
      }
      function clamp3(number, lower, upper) {
        if (upper === undefined2) {
          upper = lower;
          lower = undefined2;
        }
        if (upper !== undefined2) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined2) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined2) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined2;
        }
        if (floating === undefined2) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined2;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined2;
          }
        }
        if (lower === undefined2 && upper === undefined2) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined2) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize2(word) : word);
      });
      function capitalize2(string5) {
        return upperFirst(toString5(string5).toLowerCase());
      }
      function deburr(string5) {
        string5 = toString5(string5);
        return string5 && string5.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith2(string5, target, position) {
        string5 = toString5(string5);
        target = baseToString(target);
        var length = string5.length;
        position = position === undefined2 ? length : baseClamp(toInteger2(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string5.slice(position, end) == target;
      }
      function escape2(string5) {
        string5 = toString5(string5);
        return string5 && reHasUnescapedHtml.test(string5) ? string5.replace(reUnescapedHtml, escapeHtmlChar) : string5;
      }
      function escapeRegExp(string5) {
        string5 = toString5(string5);
        return string5 && reHasRegExpChar.test(string5) ? string5.replace(reRegExpChar, "\\$&") : string5;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad2(string5, length, chars) {
        string5 = toString5(string5);
        length = toInteger2(length);
        var strLength = length ? stringSize(string5) : 0;
        if (!length || strLength >= length) {
          return string5;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string5 + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string5, length, chars) {
        string5 = toString5(string5);
        length = toInteger2(length);
        var strLength = length ? stringSize(string5) : 0;
        return length && strLength < length ? string5 + createPadding(length - strLength, chars) : string5;
      }
      function padStart(string5, length, chars) {
        string5 = toString5(string5);
        length = toInteger2(length);
        var strLength = length ? stringSize(string5) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string5 : string5;
      }
      function parseInt2(string5, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString5(string5).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string5, n, guard) {
        if (guard ? isIterateeCall(string5, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger2(n);
        }
        return baseRepeat(toString5(string5), n);
      }
      function replace() {
        var args = arguments, string5 = toString5(args[0]);
        return args.length < 3 ? string5 : string5.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split2(string5, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string5, separator, limit)) {
          separator = limit = undefined2;
        }
        limit = limit === undefined2 ? MAX_ARRAY_LENGTH2 : limit >>> 0;
        if (!limit) {
          return [];
        }
        string5 = toString5(string5);
        if (string5 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string5)) {
            return castSlice(stringToArray(string5), 0, limit);
          }
        }
        return string5.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith2(string5, target, position) {
        string5 = toString5(string5);
        position = position == null ? 0 : baseClamp(toInteger2(position), 0, string5.length);
        target = baseToString(target);
        return string5.slice(position, position + target.length) == target;
      }
      function template(string5, options, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string5, options, guard)) {
          options = undefined2;
        }
        string5 = toString5(string5);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty5.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string5.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string5.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty5.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString5(value).toLowerCase();
      }
      function toUpper(value) {
        return toString5(value).toUpperCase();
      }
      function trim2(string5, chars, guard) {
        string5 = toString5(string5);
        if (string5 && (guard || chars === undefined2)) {
          return string5.replace(reTrim, "");
        }
        if (!string5 || !(chars = baseToString(chars))) {
          return string5;
        }
        var strSymbols = stringToArray(string5), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string5, chars, guard) {
        string5 = toString5(string5);
        if (string5 && (guard || chars === undefined2)) {
          return string5.replace(reTrimEnd, "");
        }
        if (!string5 || !(chars = baseToString(chars))) {
          return string5;
        }
        var strSymbols = stringToArray(string5), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string5, chars, guard) {
        string5 = toString5(string5);
        if (string5 && (guard || chars === undefined2)) {
          return string5.replace(reTrimStart, "");
        }
        if (!string5 || !(chars = baseToString(chars))) {
          return string5;
        }
        var strSymbols = stringToArray(string5), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string5, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject3(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger2(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string5 = toString5(string5);
        var strLength = string5.length;
        if (hasUnicode(string5)) {
          var strSymbols = stringToArray(string5);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string5;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string5.slice(0, end);
        if (separator === undefined2) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string5.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString5(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
          }
        } else if (string5.indexOf(baseToString(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape2(string5) {
        string5 = toString5(string5);
        return string5 && reHasEscapedHtml.test(string5) ? string5.replace(reEscapedHtml, unescapeHtmlChar) : string5;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string5, pattern3, guard) {
        string5 = toString5(string5);
        pattern3 = guard ? undefined2 : pattern3;
        if (pattern3 === undefined2) {
          return hasUnicodeWord(string5) ? unicodeWords(string5) : asciiWords(string5);
        }
        return string5.match(pattern3) || [];
      }
      var attempt = baseRest(function(func3, args) {
        try {
          return apply2(func3, undefined2, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object2, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object2, key, bind2(object2[key], object2));
        });
        return object2;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply2(pair[0], this, args)) {
              return apply2(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity3(value) {
        return value;
      }
      function iteratee(func3) {
        return baseIteratee(typeof func3 == "function" ? func3 : baseClone(func3, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path3, srcValue) {
        return baseMatchesProperty(path3, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path3, args) {
        return function(object2) {
          return baseInvoke(object2, path3, args);
        };
      });
      var methodOf = baseRest(function(object2, args) {
        return function(path3) {
          return baseInvoke(object2, path3, args);
        };
      });
      function mixin2(object2, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject3(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object2;
          object2 = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject3(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object2);
        arrayEach(methodNames, function(methodName) {
          var func3 = source[methodName];
          object2[methodName] = func3;
          if (isFunc) {
            object2.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object2(this.__wrapped__), actions25 = result2.__actions__ = copyArray(this.__actions__);
                actions25.push({func: func3, args: arguments, thisArg: object2});
                result2.__chain__ = chainAll;
                return result2;
              }
              return func3.apply(object2, arrayPush([this.value()], arguments));
            };
          }
        });
        return object2;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop5() {
      }
      function nthArg(n) {
        n = toInteger2(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path3) {
        return isKey(path3) ? baseProperty(toKey(path3)) : basePropertyDeep(path3);
      }
      function propertyOf(object2) {
        return function(path3) {
          return object2 == null ? undefined2 : baseGet(object2, path3);
        };
      }
      var range2 = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger2(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH2, length = nativeMin(n, MAX_ARRAY_LENGTH2);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH2;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString5(value)));
      }
      function uniqueId(prefix2) {
        var id = ++idCounter2;
        return toString5(prefix2) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array4) {
        return array4 && array4.length ? baseExtremum(array4, identity3, baseGt) : undefined2;
      }
      function maxBy(array4, iteratee2) {
        return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseGt) : undefined2;
      }
      function mean(array4) {
        return baseMean(array4, identity3);
      }
      function meanBy(array4, iteratee2) {
        return baseMean(array4, getIteratee(iteratee2, 2));
      }
      function min(array4) {
        return array4 && array4.length ? baseExtremum(array4, identity3, baseLt) : undefined2;
      }
      function minBy(array4, iteratee2) {
        return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseLt) : undefined2;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array4) {
        return array4 && array4.length ? baseSum(array4, identity3) : 0;
      }
      function sumBy(array4, iteratee2) {
        return array4 && array4.length ? baseSum(array4, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind2;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact2;
      lodash.concat = concat2;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create2;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce3;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay2;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter2;
      lodash.flatMap = flatMap3;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten3;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy2;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin2;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once3;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range2;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove2;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set5;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice2;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split2;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take2;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap2;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin2(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize2;
      lodash.ceil = ceil;
      lodash.clamp = clamp3;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep2;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith2;
      lodash.eq = eq;
      lodash.escape = escape2;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach2;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity3;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray2;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty2;
      lodash.isEqual = isEqual2;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite2;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative2;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber2;
      lodash.isObject = isObject3;
      lodash.isObjectLike = isObjectLike2;
      lodash.isPlainObject = isPlainObject2;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString2;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined2;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join4;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop5;
      lodash.now = now;
      lodash.pad = pad2;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext2;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith2;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger2;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString5;
      lodash.toUpper = toUpper;
      lodash.trim = trim2;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape2;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach2;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin2(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func3, methodName) {
          if (!hasOwnProperty5.call(lodash.prototype, methodName)) {
            source[methodName] = func3;
          }
        });
        return source;
      }(), {chain: false});
      lodash.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined2 ? 1 : nativeMax(toInteger2(n), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n, MAX_ARRAY_LENGTH2),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity3);
      };
      LazyWrapper.prototype.find = function(predicate3) {
        return this.filter(predicate3).head();
      };
      LazyWrapper.prototype.findLast = function(predicate3) {
        return this.reverse().find(predicate3);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path3, args) {
        if (typeof path3 == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path3, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate3) {
        return this.filter(negate(getIteratee(predicate3)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger2(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined2) {
          end = toInteger2(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate3) {
        return this.reverse().takeWhile(predicate3).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH2);
      };
      baseForOwn(LazyWrapper.prototype, function(func3, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func3.apply(value, args);
            result2.__actions__.push({func: thru, args: [interceptor], thisArg: undefined2});
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func3.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func3 = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func3.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func3.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func3, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty5.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({name: methodName, func: lodashFunc});
        }
      });
      realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined2
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _;
      define(function() {
        return _;
      });
    } else if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(exports);
});

// ../../node_modules/object-assign/index.js
var require_object_assign = __commonJS((exports, module) => {
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  "use strict";
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty5 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  module.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from2;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
      from2 = Object(arguments[s]);
      for (var key in from2) {
        if (hasOwnProperty5.call(from2, key)) {
          to[key] = from2[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from2);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from2, symbols[i])) {
            to[symbols[i]] = from2[symbols[i]];
          }
        }
      }
    }
    return to;
  };
});

// ../../node_modules/glamor/lib/sheet.js
var require_sheet = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StyleSheet = StyleSheet;
  var _objectAssign = require_object_assign();
  var _objectAssign2 = _interopRequireDefault(_objectAssign);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _toConsumableArray2(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function last(arr) {
    return arr[arr.length - 1];
  }
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        return document.styleSheets[i];
      }
    }
  }
  var isBrowser = typeof window !== "undefined";
  var isDev = false;
  var isTest2 = false;
  var oldIE = function() {
    if (isBrowser) {
      var div = document.createElement("div");
      div.innerHTML = "<!--[if lt IE 10]><i></i><![endif]-->";
      return div.getElementsByTagName("i").length === 1;
    }
  }();
  function makeStyleTag() {
    var tag = document.createElement("style");
    tag.type = "text/css";
    tag.setAttribute("data-glamor", "");
    tag.appendChild(document.createTextNode(""));
    (document.head || document.getElementsByTagName("head")[0]).appendChild(tag);
    return tag;
  }
  function StyleSheet() {
    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$speedy = _ref2.speedy, speedy = _ref$speedy === void 0 ? !isDev && !isTest2 : _ref$speedy, _ref$maxLength = _ref2.maxLength, maxLength = _ref$maxLength === void 0 ? isBrowser && oldIE ? 4e3 : 65e3 : _ref$maxLength;
    this.isSpeedy = speedy;
    this.sheet = void 0;
    this.tags = [];
    this.maxLength = maxLength;
    this.ctr = 0;
  }
  (0, _objectAssign2.default)(StyleSheet.prototype, {
    getSheet: function getSheet() {
      return sheetForTag(last(this.tags));
    },
    inject: function inject() {
      var _this = this;
      if (this.injected) {
        throw new Error("already injected stylesheet!");
      }
      if (isBrowser) {
        this.tags[0] = makeStyleTag();
      } else {
        this.sheet = {
          cssRules: [],
          insertRule: function insertRule(rule) {
            _this.sheet.cssRules.push({cssText: rule});
          }
        };
      }
      this.injected = true;
    },
    speedy: function speedy(bool) {
      if (this.ctr !== 0) {
        throw new Error("cannot change speedy mode after inserting any rule to sheet. Either call speedy(" + bool + ") earlier in your app, or call flush() before speedy(" + bool + ")");
      }
      this.isSpeedy = !!bool;
    },
    _insert: function _insert(rule) {
      try {
        var sheet = this.getSheet();
        sheet.insertRule(rule, rule.indexOf("@import") !== -1 ? 0 : sheet.cssRules.length);
      } catch (e) {
        if (isDev) {
          console.warn("whoops, illegal rule inserted", rule);
        }
      }
    },
    insert: function insert(rule) {
      if (isBrowser) {
        if (this.isSpeedy && this.getSheet().insertRule) {
          this._insert(rule);
        } else {
          if (rule.indexOf("@import") !== -1) {
            var tag = last(this.tags);
            tag.insertBefore(document.createTextNode(rule), tag.firstChild);
          } else {
            last(this.tags).appendChild(document.createTextNode(rule));
          }
        }
      } else {
        this.sheet.insertRule(rule, rule.indexOf("@import") !== -1 ? 0 : this.sheet.cssRules.length);
      }
      this.ctr++;
      if (isBrowser && this.ctr % this.maxLength === 0) {
        this.tags.push(makeStyleTag());
      }
      return this.ctr - 1;
    },
    delete: function _delete(index2) {
      return this.replace(index2, "");
    },
    flush: function flush3() {
      if (isBrowser) {
        this.tags.forEach(function(tag) {
          return tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.sheet = null;
        this.ctr = 0;
      } else {
        this.sheet.cssRules = [];
      }
      this.injected = false;
    },
    rules: function rules() {
      if (!isBrowser) {
        return this.sheet.cssRules;
      }
      var arr = [];
      this.tags.forEach(function(tag) {
        return arr.splice.apply(arr, [arr.length, 0].concat(_toConsumableArray2(Array.from(sheetForTag(tag).cssRules))));
      });
      return arr;
    }
  });
});

// ../../node_modules/fbjs/lib/camelize.js
var require_camelize = __commonJS((exports, module) => {
  "use strict";
  var _hyphenPattern = /-(.)/g;
  function camelize(string5) {
    return string5.replace(_hyphenPattern, function(_, character) {
      return character.toUpperCase();
    });
  }
  module.exports = camelize;
});

// ../../node_modules/fbjs/lib/camelizeStyleName.js
var require_camelizeStyleName = __commonJS((exports, module) => {
  "use strict";
  var camelize = require_camelize();
  var msPattern = /^-ms-/;
  function camelizeStyleName(string5) {
    return camelize(string5.replace(msPattern, "ms-"));
  }
  module.exports = camelizeStyleName;
});

// ../../node_modules/glamor/lib/CSSPropertyOperations/CSSProperty.js
var require_CSSProperty = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowStart: true,
    gridRowEnd: true,
    gridColumn: true,
    gridColumnStart: true,
    gridColumnEnd: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  function prefixKey(prefix2, key) {
    return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
  }
  var prefixes = ["Webkit", "ms", "Moz", "O"];
  Object.keys(isUnitlessNumber).forEach(function(prop) {
    prefixes.forEach(function(prefix2) {
      isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
    });
  });
  var shorthandPropertyExpansions = {
    background: {
      backgroundAttachment: true,
      backgroundColor: true,
      backgroundImage: true,
      backgroundPositionX: true,
      backgroundPositionY: true,
      backgroundRepeat: true
    },
    backgroundPosition: {
      backgroundPositionX: true,
      backgroundPositionY: true
    },
    border: {
      borderWidth: true,
      borderStyle: true,
      borderColor: true
    },
    borderBottom: {
      borderBottomWidth: true,
      borderBottomStyle: true,
      borderBottomColor: true
    },
    borderLeft: {
      borderLeftWidth: true,
      borderLeftStyle: true,
      borderLeftColor: true
    },
    borderRight: {
      borderRightWidth: true,
      borderRightStyle: true,
      borderRightColor: true
    },
    borderTop: {
      borderTopWidth: true,
      borderTopStyle: true,
      borderTopColor: true
    },
    font: {
      fontStyle: true,
      fontVariant: true,
      fontWeight: true,
      fontSize: true,
      lineHeight: true,
      fontFamily: true
    },
    outline: {
      outlineWidth: true,
      outlineStyle: true,
      outlineColor: true
    }
  };
  var CSSProperty = {
    isUnitlessNumber,
    shorthandPropertyExpansions
  };
  exports.default = CSSProperty;
});

// ../../node_modules/fbjs/lib/emptyFunction.js
var require_emptyFunction = __commonJS((exports, module) => {
  "use strict";
  function makeEmptyFunction(arg) {
    return function() {
      return arg;
    };
  }
  var emptyFunction = function emptyFunction2() {
  };
  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function() {
    return this;
  };
  emptyFunction.thatReturnsArgument = function(arg) {
    return arg;
  };
  module.exports = emptyFunction;
});

// ../../node_modules/fbjs/lib/warning.js
var require_warning = __commonJS((exports, module) => {
  "use strict";
  var emptyFunction = require_emptyFunction();
  var warning2 = emptyFunction;
  if (false) {
    printWarning = function printWarning2(format2) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var argIndex = 0;
      var message = "Warning: " + format2.replace(/%s/g, function() {
        return args[argIndex++];
      });
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x) {
      }
    };
    warning2 = function warning3(condition, format2) {
      if (format2 === void 0) {
        throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
      }
      if (format2.indexOf("Failed Composite propType: ") === 0) {
        return;
      }
      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }
        printWarning.apply(void 0, [format2].concat(args));
      }
    };
  }
  var printWarning;
  module.exports = warning2;
});

// ../../node_modules/glamor/lib/CSSPropertyOperations/dangerousStyleValue.js
var require_dangerousStyleValue = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _CSSProperty = require_CSSProperty();
  var _CSSProperty2 = _interopRequireDefault(_CSSProperty);
  var _warning = require_warning();
  var _warning2 = _interopRequireDefault(_warning);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var isUnitlessNumber = _CSSProperty2.default.isUnitlessNumber;
  function dangerousStyleValue(name, value, component) {
    var isEmpty2 = value == null || typeof value === "boolean" || value === "";
    if (isEmpty2) {
      return "";
    }
    var isNonNumeric = isNaN(value);
    if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
      return "" + value;
    }
    if (typeof value === "string") {
      if (false) {
        if (component && value !== "0") {
          var owner = component._currentElement._owner;
          var ownerName = owner ? owner.getName() : null;
          if (ownerName && !styleWarnings[ownerName]) {
            styleWarnings[ownerName] = {};
          }
          var warned = false;
          if (ownerName) {
            var warnings2 = styleWarnings[ownerName];
            warned = warnings2[name];
            if (!warned) {
              warnings2[name] = true;
            }
          }
          if (!warned) {
            false ? (0, _warning2.default)(false, "a `%s` tag (owner: `%s`) was passed a numeric string value for CSS property `%s` (value: `%s`) which will be treated as a unitless number in a future version of React.", component._currentElement.type, ownerName || "unknown", name, value) : void 0;
          }
        }
      }
      value = value.trim();
    }
    return value + "px";
  }
  exports.default = dangerousStyleValue;
});

// ../../node_modules/fbjs/lib/hyphenate.js
var require_hyphenate = __commonJS((exports, module) => {
  "use strict";
  var _uppercasePattern = /([A-Z])/g;
  function hyphenate(string5) {
    return string5.replace(_uppercasePattern, "-$1").toLowerCase();
  }
  module.exports = hyphenate;
});

// ../../node_modules/fbjs/lib/hyphenateStyleName.js
var require_hyphenateStyleName = __commonJS((exports, module) => {
  "use strict";
  var hyphenate = require_hyphenate();
  var msPattern = /^ms-/;
  function hyphenateStyleName(string5) {
    return hyphenate(string5).replace(msPattern, "-ms-");
  }
  module.exports = hyphenateStyleName;
});

// ../../node_modules/fbjs/lib/memoizeStringOnly.js
var require_memoizeStringOnly = __commonJS((exports, module) => {
  "use strict";
  function memoizeStringOnly(callback) {
    var cache = {};
    return function(string5) {
      if (!cache.hasOwnProperty(string5)) {
        cache[string5] = callback.call(this, string5);
      }
      return cache[string5];
    };
  }
  module.exports = memoizeStringOnly;
});

// ../../node_modules/glamor/lib/CSSPropertyOperations/index.js
var require_CSSPropertyOperations = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.processStyleName = void 0;
  exports.createMarkupForStyles = createMarkupForStyles;
  var _camelizeStyleName = require_camelizeStyleName();
  var _camelizeStyleName2 = _interopRequireDefault(_camelizeStyleName);
  var _dangerousStyleValue = require_dangerousStyleValue();
  var _dangerousStyleValue2 = _interopRequireDefault(_dangerousStyleValue);
  var _hyphenateStyleName = require_hyphenateStyleName();
  var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);
  var _memoizeStringOnly = require_memoizeStringOnly();
  var _memoizeStringOnly2 = _interopRequireDefault(_memoizeStringOnly);
  var _warning = require_warning();
  var _warning2 = _interopRequireDefault(_warning);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var processStyleName = exports.processStyleName = (0, _memoizeStringOnly2.default)(_hyphenateStyleName2.default);
  if (false) {
    badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
    badStyleValueWithSemicolonPattern = /;\s*$/;
    warnedStyleNames = {};
    warnedStyleValues = {};
    warnedForNaNValue = false;
    warnHyphenatedStyleName = function warnHyphenatedStyleName2(name, owner) {
      if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
        return;
      }
      warnedStyleNames[name] = true;
      false ? (0, _warning2.default)(false, "Unsupported style property %s. Did you mean %s?%s", name, (0, _camelizeStyleName2.default)(name), checkRenderMessage(owner)) : void 0;
    };
    warnBadVendoredStyleName = function warnBadVendoredStyleName2(name, owner) {
      if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
        return;
      }
      warnedStyleNames[name] = true;
      false ? (0, _warning2.default)(false, "Unsupported vendor-prefixed style property %s. Did you mean %s?%s", name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
    };
    warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon2(name, value, owner) {
      if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
        return;
      }
      warnedStyleValues[value] = true;
      false ? (0, _warning2.default)(false, `Style property values shouldn't contain a semicolon.%s Try "%s: %s" instead.`, checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, "")) : void 0;
    };
    warnStyleValueIsNaN = function warnStyleValueIsNaN2(name, value, owner) {
      if (warnedForNaNValue) {
        return;
      }
      warnedForNaNValue = true;
      false ? (0, _warning2.default)(false, "`NaN` is an invalid value for the `%s` css style property.%s", name, checkRenderMessage(owner)) : void 0;
    };
    checkRenderMessage = function checkRenderMessage2(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return " Check the render method of `" + name + "`.";
        }
      }
      return "";
    };
    warnValidStyle = function warnValidStyle2(name, value, component) {
      var owner = void 0;
      if (component) {
        owner = component._currentElement._owner;
      }
      if (name.indexOf("-") > -1) {
        warnHyphenatedStyleName(name, owner);
      } else if (badVendoredStyleNamePattern.test(name)) {
        warnBadVendoredStyleName(name, owner);
      } else if (badStyleValueWithSemicolonPattern.test(value)) {
        warnStyleValueWithSemicolon(name, value, owner);
      }
      if (typeof value === "number" && isNaN(value)) {
        warnStyleValueIsNaN(name, value, owner);
      }
    };
  }
  var badVendoredStyleNamePattern;
  var badStyleValueWithSemicolonPattern;
  var warnedStyleNames;
  var warnedStyleValues;
  var warnedForNaNValue;
  var warnHyphenatedStyleName;
  var warnBadVendoredStyleName;
  var warnStyleValueWithSemicolon;
  var warnStyleValueIsNaN;
  var checkRenderMessage;
  var warnValidStyle;
  function createMarkupForStyles(styles40, component) {
    var serialized = "";
    for (var styleName in styles40) {
      var isCustomProp = styleName.indexOf("--") === 0;
      if (!styles40.hasOwnProperty(styleName)) {
        continue;
      }
      if (styleName === "label") {
        continue;
      }
      var styleValue = styles40[styleName];
      if (false) {
        warnValidStyle(styleName, styleValue, component);
      }
      if (styleValue != null) {
        if (isCustomProp) {
          serialized += styleName + ":" + styleValue + ";";
        } else {
          serialized += processStyleName(styleName) + ":";
          serialized += (0, _dangerousStyleValue2.default)(styleName, styleValue, component) + ";";
        }
      }
    }
    return serialized || null;
  }
});

// ../../node_modules/glamor/lib/clean.js
var require_clean = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _typeof4 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  exports.default = clean;
  function isFalsy(value) {
    return value === null || value === void 0 || value === false || (typeof value === "undefined" ? "undefined" : _typeof4(value)) === "object" && Object.keys(value).length === 0;
  }
  function cleanObject(object2) {
    if (isFalsy(object2))
      return null;
    if ((typeof object2 === "undefined" ? "undefined" : _typeof4(object2)) !== "object")
      return object2;
    var acc = {}, keys = Object.keys(object2), hasFalsy = false;
    for (var i = 0; i < keys.length; i++) {
      var value = object2[keys[i]];
      var filteredValue = clean(value);
      if (filteredValue === null || filteredValue !== value) {
        hasFalsy = true;
      }
      if (filteredValue !== null) {
        acc[keys[i]] = filteredValue;
      }
    }
    return Object.keys(acc).length === 0 ? null : hasFalsy ? acc : object2;
  }
  function cleanArray(rules) {
    var hasFalsy = false;
    var filtered = [];
    rules.forEach(function(rule) {
      var filteredRule = clean(rule);
      if (filteredRule === null || filteredRule !== rule) {
        hasFalsy = true;
      }
      if (filteredRule !== null) {
        filtered.push(filteredRule);
      }
    });
    return filtered.length == 0 ? null : hasFalsy ? filtered : rules;
  }
  function clean(input) {
    return Array.isArray(input) ? cleanArray(input) : cleanObject(input);
  }
});

// ../../node_modules/inline-style-prefixer/static/staticData.js
var require_staticData = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var w = ["Webkit"];
  var m = ["Moz"];
  var ms = ["ms"];
  var wm = ["Webkit", "Moz"];
  var wms = ["Webkit", "ms"];
  var wmms = ["Webkit", "Moz", "ms"];
  exports.default = {
    plugins: [],
    prefixMap: {appearance: wm, userSelect: wmms, textEmphasisPosition: w, textEmphasis: w, textEmphasisStyle: w, textEmphasisColor: w, boxDecorationBreak: w, clipPath: w, maskImage: w, maskMode: w, maskRepeat: w, maskPosition: w, maskClip: w, maskOrigin: w, maskSize: w, maskComposite: w, mask: w, maskBorderSource: w, maskBorderMode: w, maskBorderSlice: w, maskBorderWidth: w, maskBorderOutset: w, maskBorderRepeat: w, maskBorder: w, maskType: w, textDecorationStyle: w, textDecorationSkip: w, textDecorationLine: w, textDecorationColor: w, filter: w, fontFeatureSettings: w, breakAfter: wmms, breakBefore: wmms, breakInside: wmms, columnCount: wm, columnFill: wm, columnGap: wm, columnRule: wm, columnRuleColor: wm, columnRuleStyle: wm, columnRuleWidth: wm, columns: wm, columnSpan: wm, columnWidth: wm, writingMode: wms, flex: w, flexBasis: w, flexDirection: w, flexGrow: w, flexFlow: w, flexShrink: w, flexWrap: w, alignContent: w, alignItems: w, alignSelf: w, justifyContent: w, order: w, transform: w, transformOrigin: w, transformOriginX: w, transformOriginY: w, backfaceVisibility: w, perspective: w, perspectiveOrigin: w, transformStyle: w, transformOriginZ: w, animation: w, animationDelay: w, animationDirection: w, animationFillMode: w, animationDuration: w, animationIterationCount: w, animationName: w, animationPlayState: w, animationTimingFunction: w, backdropFilter: w, fontKerning: w, scrollSnapType: wms, scrollSnapPointsX: wms, scrollSnapPointsY: wms, scrollSnapDestination: wms, scrollSnapCoordinate: wms, shapeImageThreshold: w, shapeImageMargin: w, shapeImageOutside: w, hyphens: wmms, flowInto: wms, flowFrom: wms, regionFragment: wms, textAlignLast: m, tabSize: m, wrapFlow: ms, wrapThrough: ms, wrapMargin: ms, gridTemplateColumns: ms, gridTemplateRows: ms, gridTemplateAreas: ms, gridTemplate: ms, gridAutoColumns: ms, gridAutoRows: ms, gridAutoFlow: ms, grid: ms, gridRowStart: ms, gridColumnStart: ms, gridRowEnd: ms, gridRow: ms, gridColumn: ms, gridColumnEnd: ms, gridColumnGap: ms, gridRowGap: ms, gridArea: ms, gridGap: ms, textSizeAdjust: wms, borderImage: w, borderImageOutset: w, borderImageRepeat: w, borderImageSlice: w, borderImageSource: w, borderImageWidth: w, transitionDelay: w, transitionDuration: w, transitionProperty: w, transitionTimingFunction: w}
  };
  module.exports = exports["default"];
});

// ../../node_modules/inline-style-prefixer/utils/capitalizeString.js
var require_capitalizeString = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = capitalizeString;
  function capitalizeString(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  module.exports = exports["default"];
});

// ../../node_modules/inline-style-prefixer/utils/prefixProperty.js
var require_prefixProperty = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixProperty;
  var _capitalizeString = require_capitalizeString();
  var _capitalizeString2 = _interopRequireDefault(_capitalizeString);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function prefixProperty(prefixProperties, property, style) {
    if (prefixProperties.hasOwnProperty(property)) {
      var requiredPrefixes = prefixProperties[property];
      for (var i = 0, len = requiredPrefixes.length; i < len; ++i) {
        style[requiredPrefixes[i] + (0, _capitalizeString2.default)(property)] = style[property];
      }
    }
  }
  module.exports = exports["default"];
});

// ../../node_modules/inline-style-prefixer/utils/prefixValue.js
var require_prefixValue = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixValue;
  function prefixValue(plugins, property, value, style, metaData) {
    for (var i = 0, len = plugins.length; i < len; ++i) {
      var processedValue = plugins[i](property, value, style, metaData);
      if (processedValue) {
        return processedValue;
      }
    }
  }
  module.exports = exports["default"];
});

// ../../node_modules/inline-style-prefixer/static/plugins/cursor.js
var require_cursor = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cursor;
  var prefixes = ["-webkit-", "-moz-", ""];
  var values = {
    "zoom-in": true,
    "zoom-out": true,
    grab: true,
    grabbing: true
  };
  function cursor(property, value) {
    if (property === "cursor" && values.hasOwnProperty(value)) {
      return prefixes.map(function(prefix2) {
        return prefix2 + value;
      });
    }
  }
  module.exports = exports["default"];
});

// ../../node_modules/css-in-js-utils/lib/isPrefixedValue.js
var require_isPrefixedValue = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPrefixedValue;
  var regex = /-webkit-|-moz-|-ms-/;
  function isPrefixedValue(value) {
    return typeof value === "string" && regex.test(value);
  }
  module.exports = exports["default"];
});

// ../../node_modules/inline-style-prefixer/static/plugins/crossFade.js
var require_crossFade = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = crossFade;
  var _isPrefixedValue = require_isPrefixedValue();
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var prefixes = ["-webkit-", ""];
  function crossFade(property, value) {
    if (typeof value === "string" && !(0, _isPrefixedValue2.default)(value) && value.indexOf("cross-fade(") > -1) {
      return prefixes.map(function(prefix2) {
        return value.replace(/cross-fade\(/g, prefix2 + "cross-fade(");
      });
    }
  }
  module.exports = exports["default"];
});

// ../../node_modules/inline-style-prefixer/static/plugins/filter.js
var require_filter = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = filter2;
  var _isPrefixedValue = require_isPrefixedValue();
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var prefixes = ["-webkit-", ""];
  function filter2(property, value) {
    if (typeof value === "string" && !(0, _isPrefixedValue2.default)(value) && value.indexOf("filter(") > -1) {
      return prefixes.map(function(prefix2) {
        return value.replace(/filter\(/g, prefix2 + "filter(");
      });
    }
  }
  module.exports = exports["default"];
});

// ../../node_modules/inline-style-prefixer/static/plugins/flex.js
var require_flex = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = flex;
  var values = {
    flex: ["-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex", "flex"],
    "inline-flex": ["-webkit-inline-box", "-moz-inline-box", "-ms-inline-flexbox", "-webkit-inline-flex", "inline-flex"]
  };
  function flex(property, value) {
    if (property === "display" && values.hasOwnProperty(value)) {
      return values[value];
    }
  }
  module.exports = exports["default"];
});

// ../../node_modules/inline-style-prefixer/static/plugins/flexboxOld.js
var require_flexboxOld = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = flexboxOld;
  var alternativeValues = {
    "space-around": "justify",
    "space-between": "justify",
    "flex-start": "start",
    "flex-end": "end",
    "wrap-reverse": "multiple",
    wrap: "multiple"
  };
  var alternativeProps = {
    alignItems: "WebkitBoxAlign",
    justifyContent: "WebkitBoxPack",
    flexWrap: "WebkitBoxLines"
  };
  function flexboxOld(property, value, style) {
    if (property === "flexDirection" && typeof value === "string") {
      if (value.indexOf("column") > -1) {
        style.WebkitBoxOrient = "vertical";
      } else {
        style.WebkitBoxOrient = "horizontal";
      }
      if (value.indexOf("reverse") > -1) {
        style.WebkitBoxDirection = "reverse";
      } else {
        style.WebkitBoxDirection = "normal";
      }
    }
    if (alternativeProps.hasOwnProperty(property)) {
      style[alternativeProps[property]] = alternativeValues[value] || value;
    }
  }
  module.exports = exports["default"];
});

// ../../node_modules/inline-style-prefixer/static/plugins/gradient.js
var require_gradient = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = gradient;
  var _isPrefixedValue = require_isPrefixedValue();
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var prefixes = ["-webkit-", "-moz-", ""];
  var values = /linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient/;
  function gradient(property, value) {
    if (typeof value === "string" && !(0, _isPrefixedValue2.default)(value) && values.test(value)) {
      return prefixes.map(function(prefix2) {
        return prefix2 + value;
      });
    }
  }
  module.exports = exports["default"];
});

// ../../node_modules/inline-style-prefixer/static/plugins/imageSet.js
var require_imageSet = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = imageSet;
  var _isPrefixedValue = require_isPrefixedValue();
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var prefixes = ["-webkit-", ""];
  function imageSet(property, value) {
    if (typeof value === "string" && !(0, _isPrefixedValue2.default)(value) && value.indexOf("image-set(") > -1) {
      return prefixes.map(function(prefix2) {
        return value.replace(/image-set\(/g, prefix2 + "image-set(");
      });
    }
  }
  module.exports = exports["default"];
});

// ../../node_modules/inline-style-prefixer/static/plugins/position.js
var require_position = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = position;
  function position(property, value) {
    if (property === "position" && value === "sticky") {
      return ["-webkit-sticky", "sticky"];
    }
  }
  module.exports = exports["default"];
});

// ../../node_modules/inline-style-prefixer/static/plugins/sizing.js
var require_sizing = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = sizing;
  var prefixes = ["-webkit-", "-moz-", ""];
  var properties = {
    maxHeight: true,
    maxWidth: true,
    width: true,
    height: true,
    columnWidth: true,
    minWidth: true,
    minHeight: true
  };
  var values = {
    "min-content": true,
    "max-content": true,
    "fill-available": true,
    "fit-content": true,
    "contain-floats": true
  };
  function sizing(property, value) {
    if (properties.hasOwnProperty(property) && values.hasOwnProperty(value)) {
      return prefixes.map(function(prefix2) {
        return prefix2 + value;
      });
    }
  }
  module.exports = exports["default"];
});

// ../../node_modules/css-in-js-utils/lib/hyphenateProperty.js
var require_hyphenateProperty = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = hyphenateProperty;
  var _hyphenateStyleName = require_index_cjs();
  var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function hyphenateProperty(property) {
    return (0, _hyphenateStyleName2.default)(property);
  }
  module.exports = exports["default"];
});

// ../../node_modules/inline-style-prefixer/static/plugins/transition.js
var require_transition = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = transition;
  var _hyphenateProperty = require_hyphenateProperty();
  var _hyphenateProperty2 = _interopRequireDefault(_hyphenateProperty);
  var _isPrefixedValue = require_isPrefixedValue();
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  var _capitalizeString = require_capitalizeString();
  var _capitalizeString2 = _interopRequireDefault(_capitalizeString);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var properties = {
    transition: true,
    transitionProperty: true,
    WebkitTransition: true,
    WebkitTransitionProperty: true,
    MozTransition: true,
    MozTransitionProperty: true
  };
  var prefixMapping = {
    Webkit: "-webkit-",
    Moz: "-moz-",
    ms: "-ms-"
  };
  function prefixValue(value, propertyPrefixMap) {
    if ((0, _isPrefixedValue2.default)(value)) {
      return value;
    }
    var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g);
    for (var i = 0, len = multipleValues.length; i < len; ++i) {
      var singleValue = multipleValues[i];
      var values = [singleValue];
      for (var property in propertyPrefixMap) {
        var dashCaseProperty = (0, _hyphenateProperty2.default)(property);
        if (singleValue.indexOf(dashCaseProperty) > -1 && dashCaseProperty !== "order") {
          var prefixes = propertyPrefixMap[property];
          for (var j = 0, pLen = prefixes.length; j < pLen; ++j) {
            values.unshift(singleValue.replace(dashCaseProperty, prefixMapping[prefixes[j]] + dashCaseProperty));
          }
        }
      }
      multipleValues[i] = values.join(",");
    }
    return multipleValues.join(",");
  }
  function transition(property, value, style, propertyPrefixMap) {
    if (typeof value === "string" && properties.hasOwnProperty(property)) {
      var outputValue = prefixValue(value, propertyPrefixMap);
      var webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function(val) {
        return !/-moz-|-ms-/.test(val);
      }).join(",");
      if (property.indexOf("Webkit") > -1) {
        return webkitOutput;
      }
      var mozOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function(val) {
        return !/-webkit-|-ms-/.test(val);
      }).join(",");
      if (property.indexOf("Moz") > -1) {
        return mozOutput;
      }
      style["Webkit" + (0, _capitalizeString2.default)(property)] = webkitOutput;
      style["Moz" + (0, _capitalizeString2.default)(property)] = mozOutput;
      return outputValue;
    }
  }
  module.exports = exports["default"];
});

// ../../node_modules/glamor/lib/prefixer.js
var require_prefixer = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixer;
  var _staticData = require_staticData();
  var _staticData2 = _interopRequireDefault(_staticData);
  var _prefixProperty = require_prefixProperty();
  var _prefixProperty2 = _interopRequireDefault(_prefixProperty);
  var _prefixValue = require_prefixValue();
  var _prefixValue2 = _interopRequireDefault(_prefixValue);
  var _cursor = require_cursor();
  var _cursor2 = _interopRequireDefault(_cursor);
  var _crossFade = require_crossFade();
  var _crossFade2 = _interopRequireDefault(_crossFade);
  var _filter = require_filter();
  var _filter2 = _interopRequireDefault(_filter);
  var _flex = require_flex();
  var _flex2 = _interopRequireDefault(_flex);
  var _flexboxOld = require_flexboxOld();
  var _flexboxOld2 = _interopRequireDefault(_flexboxOld);
  var _gradient = require_gradient();
  var _gradient2 = _interopRequireDefault(_gradient);
  var _imageSet = require_imageSet();
  var _imageSet2 = _interopRequireDefault(_imageSet);
  var _position = require_position();
  var _position2 = _interopRequireDefault(_position);
  var _sizing = require_sizing();
  var _sizing2 = _interopRequireDefault(_sizing);
  var _transition = require_transition();
  var _transition2 = _interopRequireDefault(_transition);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var plugins = [_crossFade2.default, _cursor2.default, _filter2.default, _flexboxOld2.default, _gradient2.default, _imageSet2.default, _position2.default, _sizing2.default, _transition2.default, _flex2.default];
  var prefixMap = _staticData2.default.prefixMap;
  function prefixer(style) {
    for (var property in style) {
      var value = style[property];
      var processedValue = (0, _prefixValue2.default)(plugins, property, value, style, prefixMap);
      if (processedValue) {
        style[property] = processedValue;
      }
      (0, _prefixProperty2.default)(prefixMap, property, style);
    }
    return style;
  }
});

// ../../node_modules/glamor/lib/plugins.js
var require_plugins = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  exports.PluginSet = PluginSet;
  exports.fallbacks = fallbacks;
  exports.contentWrap = contentWrap;
  exports.prefixes = prefixes;
  var _objectAssign = require_object_assign();
  var _objectAssign2 = _interopRequireDefault(_objectAssign);
  var _CSSPropertyOperations = require_CSSPropertyOperations();
  var _prefixer = require_prefixer();
  var _prefixer2 = _interopRequireDefault(_prefixer);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var isDev = function(x) {
    return x === "development" || !x;
  }("production");
  function PluginSet(initial) {
    this.fns = initial || [];
  }
  (0, _objectAssign2.default)(PluginSet.prototype, {
    add: function add() {
      var _this = this;
      for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
      }
      fns.forEach(function(fn) {
        if (_this.fns.indexOf(fn) >= 0) {
          if (isDev) {
            console.warn("adding the same plugin again, ignoring");
          }
        } else {
          _this.fns = [fn].concat(_this.fns);
        }
      });
    },
    remove: function remove2(fn) {
      this.fns = this.fns.filter(function(x) {
        return x !== fn;
      });
    },
    clear: function clear3() {
      this.fns = [];
    },
    transform: function transform(o) {
      return this.fns.reduce(function(o2, fn) {
        return fn(o2);
      }, o);
    }
  });
  function fallbacks(node) {
    var hasArray = Object.keys(node.style).map(function(x) {
      return Array.isArray(node.style[x]);
    }).indexOf(true) >= 0;
    if (hasArray) {
      var style = node.style;
      var flattened = Object.keys(style).reduce(function(o, key) {
        o[key] = Array.isArray(style[key]) ? style[key].join("; " + (0, _CSSPropertyOperations.processStyleName)(key) + ": ") : style[key];
        return o;
      }, {});
      return (0, _objectAssign2.default)({}, node, {style: flattened});
    }
    return node;
  }
  var contentValues = ["normal", "none", "counter", "open-quote", "close-quote", "no-open-quote", "no-close-quote", "initial", "inherit"];
  function contentWrap(node) {
    if (node.style.content) {
      var cont = node.style.content;
      if (contentValues.indexOf(cont) >= 0) {
        return node;
      }
      if (/^(attr|calc|counters?|url)\(/.test(cont)) {
        return node;
      }
      if (cont.charAt(0) === cont.charAt(cont.length - 1) && (cont.charAt(0) === '"' || cont.charAt(0) === "'")) {
        return node;
      }
      return _extends2({}, node, {style: _extends2({}, node.style, {content: '"' + cont + '"'})});
    }
    return node;
  }
  function prefixes(node) {
    return (0, _objectAssign2.default)({}, node, {style: (0, _prefixer2.default)(_extends2({}, node.style))});
  }
});

// ../../node_modules/glamor/lib/hash.js
var require_hash = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = doHash2;
  function doHash2(str, seed) {
    var m = 1540483477;
    var r = 24;
    var h = seed ^ str.length;
    var length = str.length;
    var currentIndex = 0;
    while (length >= 4) {
      var k = UInt32(str, currentIndex);
      k = Umul32(k, m);
      k ^= k >>> r;
      k = Umul32(k, m);
      h = Umul32(h, m);
      h ^= k;
      currentIndex += 4;
      length -= 4;
    }
    switch (length) {
      case 3:
        h ^= UInt16(str, currentIndex);
        h ^= str.charCodeAt(currentIndex + 2) << 16;
        h = Umul32(h, m);
        break;
      case 2:
        h ^= UInt16(str, currentIndex);
        h = Umul32(h, m);
        break;
      case 1:
        h ^= str.charCodeAt(currentIndex);
        h = Umul32(h, m);
        break;
    }
    h ^= h >>> 13;
    h = Umul32(h, m);
    h ^= h >>> 15;
    return h >>> 0;
  }
  function UInt32(str, pos) {
    return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8) + (str.charCodeAt(pos++) << 16) + (str.charCodeAt(pos) << 24);
  }
  function UInt16(str, pos) {
    return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8);
  }
  function Umul32(n, m) {
    n = n | 0;
    m = m | 0;
    var nlo = n & 65535;
    var nhi = n >>> 16;
    var res = nlo * m + ((nhi * m & 65535) << 16) | 0;
    return res;
  }
});

// ../../node_modules/glamor/lib/index.js
var require_lib4 = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.compose = exports.merge = exports.$ = exports.style = exports.presets = exports.keyframes = exports.fontFace = exports.insertGlobal = exports.insertRule = exports.plugins = exports.styleSheet = void 0;
  exports.speedy = speedy;
  exports.simulations = simulations;
  exports.simulate = simulate;
  exports.cssLabels = cssLabels;
  exports.isLikeRule = isLikeRule;
  exports.idFor = idFor;
  exports.css = css5;
  exports.rehydrate = rehydrate;
  exports.flush = flush3;
  exports.select = select3;
  exports.parent = parent2;
  exports.media = media;
  exports.pseudo = pseudo;
  exports.active = active;
  exports.any = any;
  exports.checked = checked;
  exports.disabled = disabled;
  exports.empty = empty2;
  exports.enabled = enabled;
  exports._default = _default;
  exports.first = first2;
  exports.firstChild = firstChild;
  exports.firstOfType = firstOfType;
  exports.fullscreen = fullscreen;
  exports.focus = focus;
  exports.hover = hover;
  exports.indeterminate = indeterminate;
  exports.inRange = inRange;
  exports.invalid = invalid;
  exports.lastChild = lastChild;
  exports.lastOfType = lastOfType;
  exports.left = left;
  exports.link = link;
  exports.onlyChild = onlyChild2;
  exports.onlyOfType = onlyOfType;
  exports.optional = optional2;
  exports.outOfRange = outOfRange;
  exports.readOnly = readOnly;
  exports.readWrite = readWrite;
  exports.required = required;
  exports.right = right;
  exports.root = root;
  exports.scope = scope;
  exports.target = target;
  exports.valid = valid;
  exports.visited = visited;
  exports.dir = dir;
  exports.lang = lang;
  exports.not = not;
  exports.nthChild = nthChild;
  exports.nthLastChild = nthLastChild;
  exports.nthLastOfType = nthLastOfType;
  exports.nthOfType = nthOfType;
  exports.after = after;
  exports.before = before;
  exports.firstLetter = firstLetter;
  exports.firstLine = firstLine;
  exports.selection = selection;
  exports.backdrop = backdrop;
  exports.placeholder = placeholder;
  exports.cssFor = cssFor;
  exports.attribsFor = attribsFor;
  var _objectAssign = require_object_assign();
  var _objectAssign2 = _interopRequireDefault(_objectAssign);
  var _sheet = require_sheet();
  var _CSSPropertyOperations = require_CSSPropertyOperations();
  var _clean = require_clean();
  var _clean2 = _interopRequireDefault(_clean);
  var _plugins = require_plugins();
  var _hash = require_hash();
  var _hash2 = _interopRequireDefault(_hash);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _toConsumableArray2(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var styleSheet = exports.styleSheet = new _sheet.StyleSheet();
  styleSheet.inject();
  function speedy(bool) {
    return styleSheet.speedy(bool);
  }
  var plugins = exports.plugins = styleSheet.plugins = new _plugins.PluginSet([_plugins.prefixes, _plugins.contentWrap, _plugins.fallbacks]);
  plugins.media = new _plugins.PluginSet();
  plugins.fontFace = new _plugins.PluginSet();
  plugins.keyframes = new _plugins.PluginSet([_plugins.prefixes, _plugins.fallbacks]);
  var isDev = false;
  var isTest2 = false;
  var isBrowser = typeof window !== "undefined";
  var canSimulate = isDev;
  var warned1 = false;
  var warned2 = false;
  function simulations() {
    var bool = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    canSimulate = !!bool;
  }
  function simulate() {
    for (var _len = arguments.length, pseudos = Array(_len), _key = 0; _key < _len; _key++) {
      pseudos[_key] = arguments[_key];
    }
    pseudos = (0, _clean2.default)(pseudos);
    if (!pseudos)
      return {};
    if (!canSimulate) {
      if (!warned1) {
        console.warn("can't simulate without once calling simulations(true)");
        warned1 = true;
      }
      if (!isDev && !isTest2 && !warned2) {
        console.warn("don't use simulation outside dev");
        warned2 = true;
      }
      return {};
    }
    return pseudos.reduce(function(o, p) {
      return o["data-simulate-" + simple(p)] = "", o;
    }, {});
  }
  var hasLabels = isDev;
  function cssLabels(bool) {
    hasLabels = !!bool;
  }
  function simple(str) {
    var char = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return str.toLowerCase().replace(/[^a-z0-9]/g, char);
  }
  function hashify(obj) {
    var str = JSON.stringify(obj);
    var toRet = (0, _hash2.default)(str).toString(36);
    if (obj.label && obj.label.length > 0 && isDev) {
      return simple(obj.label.join("."), "-") + "-" + toRet;
    }
    return toRet;
  }
  function isLikeRule(rule) {
    var keys = Object.keys(rule).filter(function(x) {
      return x !== "toString";
    });
    if (keys.length !== 1) {
      return false;
    }
    return !!/data\-css\-([a-zA-Z0-9\-_]+)/.exec(keys[0]);
  }
  function idFor(rule) {
    var keys = Object.keys(rule).filter(function(x) {
      return x !== "toString";
    });
    if (keys.length !== 1)
      throw new Error("not a rule");
    var regex = /data\-css\-([a-zA-Z0-9\-_]+)/;
    var match = regex.exec(keys[0]);
    if (!match)
      throw new Error("not a rule");
    return match[1];
  }
  var selectorTokenizer = /[(),]|"(?:\\.|[^"\n])*"|'(?:\\.|[^'\n])*'|\/\*[\s\S]*?\*\//g;
  function splitSelector(selector2) {
    if (selector2.indexOf(",") === -1) {
      return [selector2];
    }
    var indices = [], res = [], inParen = 0, o;
    while (o = selectorTokenizer.exec(selector2)) {
      switch (o[0]) {
        case "(":
          inParen++;
          break;
        case ")":
          inParen--;
          break;
        case ",":
          if (inParen)
            break;
          indices.push(o.index);
      }
    }
    for (o = indices.length; o--; ) {
      res.unshift(selector2.slice(indices[o] + 1));
      selector2 = selector2.slice(0, indices[o]);
    }
    res.unshift(selector2);
    return res;
  }
  function selector(id, path3) {
    if (!id) {
      return path3.replace(/\&/g, "");
    }
    if (!path3)
      return ".css-" + id + ",[data-css-" + id + "]";
    var x = splitSelector(path3).map(function(x2) {
      return x2.indexOf("&") >= 0 ? [x2.replace(/\&/mg, ".css-" + id), x2.replace(/\&/mg, "[data-css-" + id + "]")].join(",") : ".css-" + id + x2 + ",[data-css-" + id + "]" + x2;
    }).join(",");
    if (canSimulate && /^\&\:/.exec(path3) && !/\s/.exec(path3)) {
      x += ",.css-" + id + "[data-simulate-" + simple(path3) + "],[data-css-" + id + "][data-simulate-" + simple(path3) + "]";
    }
    return x;
  }
  function toCSS(_ref2) {
    var selector2 = _ref2.selector, style2 = _ref2.style;
    var result = plugins.transform({selector: selector2, style: style2});
    return result.selector + "{" + (0, _CSSPropertyOperations.createMarkupForStyles)(result.style) + "}";
  }
  function deconstruct(style2) {
    var plain = void 0, selects = void 0, medias = void 0, supports = void 0;
    Object.keys(style2).forEach(function(key) {
      if (key.indexOf("&") >= 0) {
        selects = selects || {};
        selects[key] = style2[key];
      } else if (key.indexOf("@media") === 0) {
        medias = medias || {};
        medias[key] = deconstruct(style2[key]);
      } else if (key.indexOf("@supports") === 0) {
        supports = supports || {};
        supports[key] = deconstruct(style2[key]);
      } else if (key === "label") {
        if (style2.label.length > 0) {
          plain = plain || {};
          plain.label = hasLabels ? style2.label.join(".") : "";
        }
      } else {
        plain = plain || {};
        plain[key] = style2[key];
      }
    });
    return {plain, selects, medias, supports};
  }
  function deconstructedStyleToCSS(id, style2) {
    var css6 = [];
    var plain = style2.plain, selects = style2.selects, medias = style2.medias, supports = style2.supports;
    if (plain) {
      css6.push(toCSS({style: plain, selector: selector(id)}));
    }
    if (selects) {
      Object.keys(selects).forEach(function(key) {
        return css6.push(toCSS({style: selects[key], selector: selector(id, key)}));
      });
    }
    if (medias) {
      Object.keys(medias).forEach(function(key) {
        return css6.push(key + "{" + deconstructedStyleToCSS(id, medias[key]).join("") + "}");
      });
    }
    if (supports) {
      Object.keys(supports).forEach(function(key) {
        return css6.push(key + "{" + deconstructedStyleToCSS(id, supports[key]).join("") + "}");
      });
    }
    return css6;
  }
  var inserted = styleSheet.inserted = {};
  function insert(spec) {
    if (!inserted[spec.id]) {
      inserted[spec.id] = true;
      var deconstructed = deconstruct(spec.style);
      var rules = deconstructedStyleToCSS(spec.id, deconstructed);
      inserted[spec.id] = isBrowser ? true : rules;
      rules.forEach(function(cssRule) {
        return styleSheet.insert(cssRule);
      });
    }
  }
  var registered = styleSheet.registered = {};
  function register(spec) {
    if (!registered[spec.id]) {
      registered[spec.id] = spec;
    }
  }
  function _getRegistered(rule) {
    if (isLikeRule(rule)) {
      var ret = registered[idFor(rule)];
      if (ret == null) {
        throw new Error("[glamor] an unexpected rule cache miss occurred. This is probably a sign of multiple glamor instances in your app. See https://github.com/threepointone/glamor/issues/79");
      }
      return ret;
    }
    return rule;
  }
  var ruleCache = {};
  function toRule(spec) {
    register(spec);
    insert(spec);
    if (ruleCache[spec.id]) {
      return ruleCache[spec.id];
    }
    var ret = _defineProperty2({}, "data-css-" + spec.id, hasLabels ? spec.label || "" : "");
    Object.defineProperty(ret, "toString", {
      enumerable: false,
      value: function value() {
        return "css-" + spec.id;
      }
    });
    ruleCache[spec.id] = ret;
    return ret;
  }
  function isSelector(key) {
    var possibles = [":", ".", "[", ">", " "], found = false, ch = key.charAt(0);
    for (var i = 0; i < possibles.length; i++) {
      if (ch === possibles[i]) {
        found = true;
        break;
      }
    }
    return found || key.indexOf("&") >= 0;
  }
  function joinSelectors(a, b) {
    var as = splitSelector(a).map(function(a2) {
      return !(a2.indexOf("&") >= 0) ? "&" + a2 : a2;
    });
    var bs = splitSelector(b).map(function(b2) {
      return !(b2.indexOf("&") >= 0) ? "&" + b2 : b2;
    });
    return bs.reduce(function(arr, b2) {
      return arr.concat(as.map(function(a2) {
        return b2.replace(/\&/g, a2);
      }));
    }, []).join(",");
  }
  function joinMediaQueries(a, b) {
    return a ? "@media " + a.substring(6) + " and " + b.substring(6) : b;
  }
  function isMediaQuery(key) {
    return key.indexOf("@media") === 0;
  }
  function isSupports(key) {
    return key.indexOf("@supports") === 0;
  }
  function joinSupports(a, b) {
    return a ? "@supports " + a.substring(9) + " and " + b.substring(9) : b;
  }
  function flatten3(inArr) {
    var arr = [];
    for (var i = 0; i < inArr.length; i++) {
      if (Array.isArray(inArr[i]))
        arr = arr.concat(flatten3(inArr[i]));
      else
        arr = arr.concat(inArr[i]);
    }
    return arr;
  }
  var prefixedPseudoSelectors = {
    "::placeholder": ["::-webkit-input-placeholder", "::-moz-placeholder", "::-ms-input-placeholder"],
    ":fullscreen": [":-webkit-full-screen", ":-moz-full-screen", ":-ms-fullscreen"]
  };
  function build(dest, _ref2) {
    var _ref2$selector = _ref2.selector, selector2 = _ref2$selector === void 0 ? "" : _ref2$selector, _ref2$mq = _ref2.mq, mq = _ref2$mq === void 0 ? "" : _ref2$mq, _ref2$supp = _ref2.supp, supp = _ref2$supp === void 0 ? "" : _ref2$supp, _ref2$src = _ref2.src, src = _ref2$src === void 0 ? {} : _ref2$src;
    if (!Array.isArray(src)) {
      src = [src];
    }
    src = flatten3(src);
    src.forEach(function(_src) {
      if (isLikeRule(_src)) {
        var reg = _getRegistered(_src);
        if (reg.type !== "css") {
          throw new Error("cannot merge this rule");
        }
        _src = reg.style;
      }
      _src = (0, _clean2.default)(_src);
      if (_src && _src.composes) {
        build(dest, {selector: selector2, mq, supp, src: _src.composes});
      }
      Object.keys(_src || {}).forEach(function(key) {
        if (isSelector(key)) {
          if (prefixedPseudoSelectors[key]) {
            prefixedPseudoSelectors[key].forEach(function(p) {
              return build(dest, {selector: joinSelectors(selector2, p), mq, supp, src: _src[key]});
            });
          }
          build(dest, {selector: joinSelectors(selector2, key), mq, supp, src: _src[key]});
        } else if (isMediaQuery(key)) {
          build(dest, {selector: selector2, mq: joinMediaQueries(mq, key), supp, src: _src[key]});
        } else if (isSupports(key)) {
          build(dest, {selector: selector2, mq, supp: joinSupports(supp, key), src: _src[key]});
        } else if (key === "composes") {
        } else {
          var _dest = dest;
          if (supp) {
            _dest[supp] = _dest[supp] || {};
            _dest = _dest[supp];
          }
          if (mq) {
            _dest[mq] = _dest[mq] || {};
            _dest = _dest[mq];
          }
          if (selector2) {
            _dest[selector2] = _dest[selector2] || {};
            _dest = _dest[selector2];
          }
          if (key === "label") {
            if (hasLabels) {
              dest.label = dest.label.concat(_src.label);
            }
          } else {
            _dest[key] = _src[key];
          }
        }
      });
    });
  }
  function _css(rules) {
    var style2 = {label: []};
    build(style2, {src: rules});
    var spec = {
      id: hashify(style2),
      style: style2,
      label: hasLabels ? style2.label.join(".") : "",
      type: "css"
    };
    return toRule(spec);
  }
  var nullrule = {};
  Object.defineProperty(nullrule, "toString", {
    enumerable: false,
    value: function value() {
      return "css-nil";
    }
  });
  var inputCaches = typeof WeakMap !== "undefined" ? [nullrule, new WeakMap(), new WeakMap(), new WeakMap()] : [nullrule];
  var warnedWeakMapError = false;
  function multiIndexCache(fn) {
    return function(args) {
      if (inputCaches[args.length]) {
        var coi = inputCaches[args.length];
        var ctr = 0;
        while (ctr < args.length - 1) {
          if (!coi.has(args[ctr])) {
            coi.set(args[ctr], new WeakMap());
          }
          coi = coi.get(args[ctr]);
          ctr++;
        }
        if (coi.has(args[args.length - 1])) {
          var ret = coi.get(args[ctr]);
          if (registered[ret.toString().substring(4)]) {
            return ret;
          }
        }
      }
      var value = fn(args);
      if (inputCaches[args.length]) {
        var _ctr = 0, _coi = inputCaches[args.length];
        while (_ctr < args.length - 1) {
          _coi = _coi.get(args[_ctr]);
          _ctr++;
        }
        try {
          _coi.set(args[_ctr], value);
        } catch (err) {
          if (isDev && !warnedWeakMapError) {
            var _console;
            warnedWeakMapError = true;
            (_console = console).warn.apply(_console, ["failed setting the WeakMap cache for args:"].concat(_toConsumableArray2(args)));
            console.warn("this should NOT happen, please file a bug on the github repo.");
          }
        }
      }
      return value;
    };
  }
  var cachedCss = typeof WeakMap !== "undefined" ? multiIndexCache(_css) : _css;
  function css5() {
    for (var _len2 = arguments.length, rules = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      rules[_key2] = arguments[_key2];
    }
    if (rules[0] && rules[0].length && rules[0].raw) {
      throw new Error("you forgot to include glamor/babel in your babel plugins.");
    }
    rules = (0, _clean2.default)(rules);
    if (!rules) {
      return nullrule;
    }
    return cachedCss(rules);
  }
  css5.insert = function(css6) {
    var spec = {
      id: hashify(css6),
      css: css6,
      type: "raw"
    };
    register(spec);
    if (!inserted[spec.id]) {
      styleSheet.insert(spec.css);
      inserted[spec.id] = isBrowser ? true : [spec.css];
    }
  };
  var insertRule = exports.insertRule = css5.insert;
  css5.global = function(selector2, style2) {
    style2 = (0, _clean2.default)(style2);
    if (style2) {
      return css5.insert(toCSS({selector: selector2, style: style2}));
    }
  };
  var insertGlobal = exports.insertGlobal = css5.global;
  function insertKeyframe(spec) {
    if (!inserted[spec.id]) {
      var inner = Object.keys(spec.keyframes).map(function(kf) {
        var result = plugins.keyframes.transform({id: spec.id, name: kf, style: spec.keyframes[kf]});
        return result.name + "{" + (0, _CSSPropertyOperations.createMarkupForStyles)(result.style) + "}";
      }).join("");
      var rules = ["-webkit-", "-moz-", "-o-", ""].map(function(prefix2) {
        return "@" + prefix2 + "keyframes " + (spec.name + "_" + spec.id) + "{" + inner + "}";
      });
      rules.forEach(function(rule) {
        return styleSheet.insert(rule);
      });
      inserted[spec.id] = isBrowser ? true : rules;
    }
  }
  css5.keyframes = function(name, kfs) {
    if (!kfs) {
      kfs = name, name = "animation";
    }
    kfs = (0, _clean2.default)(kfs) || {};
    var spec = {
      id: hashify({name, kfs}),
      type: "keyframes",
      name,
      keyframes: kfs
    };
    register(spec);
    insertKeyframe(spec);
    return name + "_" + spec.id;
  };
  css5.fontFace = function(font) {
    font = (0, _clean2.default)(font);
    var spec = {
      id: hashify(font),
      type: "font-face",
      font
    };
    register(spec);
    insertFontFace(spec);
    return font.fontFamily;
  };
  var fontFace = exports.fontFace = css5.fontFace;
  var keyframes = exports.keyframes = css5.keyframes;
  function insertFontFace(spec) {
    if (!inserted[spec.id]) {
      var rule = "@font-face{" + (0, _CSSPropertyOperations.createMarkupForStyles)(spec.font) + "}";
      styleSheet.insert(rule);
      inserted[spec.id] = isBrowser ? true : [rule];
    }
  }
  function rehydrate(ids2) {
    (0, _objectAssign2.default)(inserted, ids2.reduce(function(o, i) {
      return o[i] = true, o;
    }, {}));
  }
  function flush3() {
    inserted = styleSheet.inserted = {};
    registered = styleSheet.registered = {};
    ruleCache = {};
    styleSheet.flush();
    styleSheet.inject();
  }
  var presets = exports.presets = {
    mobile: "(min-width: 400px)",
    Mobile: "@media (min-width: 400px)",
    phablet: "(min-width: 550px)",
    Phablet: "@media (min-width: 550px)",
    tablet: "(min-width: 750px)",
    Tablet: "@media (min-width: 750px)",
    desktop: "(min-width: 1000px)",
    Desktop: "@media (min-width: 1000px)",
    hd: "(min-width: 1200px)",
    Hd: "@media (min-width: 1200px)"
  };
  var style = exports.style = css5;
  function select3(selector2) {
    for (var _len3 = arguments.length, styles40 = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      styles40[_key3 - 1] = arguments[_key3];
    }
    if (!selector2) {
      return style(styles40);
    }
    return css5(_defineProperty2({}, selector2, styles40));
  }
  var $6 = exports.$ = select3;
  function parent2(selector2) {
    for (var _len4 = arguments.length, styles40 = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      styles40[_key4 - 1] = arguments[_key4];
    }
    return css5(_defineProperty2({}, selector2 + " &", styles40));
  }
  var merge = exports.merge = css5;
  var compose2 = exports.compose = css5;
  function media(query) {
    for (var _len5 = arguments.length, rules = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
      rules[_key5 - 1] = arguments[_key5];
    }
    return css5(_defineProperty2({}, "@media " + query, rules));
  }
  function pseudo(selector2) {
    for (var _len6 = arguments.length, styles40 = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
      styles40[_key6 - 1] = arguments[_key6];
    }
    return css5(_defineProperty2({}, selector2, styles40));
  }
  function active(x) {
    return pseudo(":active", x);
  }
  function any(x) {
    return pseudo(":any", x);
  }
  function checked(x) {
    return pseudo(":checked", x);
  }
  function disabled(x) {
    return pseudo(":disabled", x);
  }
  function empty2(x) {
    return pseudo(":empty", x);
  }
  function enabled(x) {
    return pseudo(":enabled", x);
  }
  function _default(x) {
    return pseudo(":default", x);
  }
  function first2(x) {
    return pseudo(":first", x);
  }
  function firstChild(x) {
    return pseudo(":first-child", x);
  }
  function firstOfType(x) {
    return pseudo(":first-of-type", x);
  }
  function fullscreen(x) {
    return pseudo(":fullscreen", x);
  }
  function focus(x) {
    return pseudo(":focus", x);
  }
  function hover(x) {
    return pseudo(":hover", x);
  }
  function indeterminate(x) {
    return pseudo(":indeterminate", x);
  }
  function inRange(x) {
    return pseudo(":in-range", x);
  }
  function invalid(x) {
    return pseudo(":invalid", x);
  }
  function lastChild(x) {
    return pseudo(":last-child", x);
  }
  function lastOfType(x) {
    return pseudo(":last-of-type", x);
  }
  function left(x) {
    return pseudo(":left", x);
  }
  function link(x) {
    return pseudo(":link", x);
  }
  function onlyChild2(x) {
    return pseudo(":only-child", x);
  }
  function onlyOfType(x) {
    return pseudo(":only-of-type", x);
  }
  function optional2(x) {
    return pseudo(":optional", x);
  }
  function outOfRange(x) {
    return pseudo(":out-of-range", x);
  }
  function readOnly(x) {
    return pseudo(":read-only", x);
  }
  function readWrite(x) {
    return pseudo(":read-write", x);
  }
  function required(x) {
    return pseudo(":required", x);
  }
  function right(x) {
    return pseudo(":right", x);
  }
  function root(x) {
    return pseudo(":root", x);
  }
  function scope(x) {
    return pseudo(":scope", x);
  }
  function target(x) {
    return pseudo(":target", x);
  }
  function valid(x) {
    return pseudo(":valid", x);
  }
  function visited(x) {
    return pseudo(":visited", x);
  }
  function dir(p, x) {
    return pseudo(":dir(" + p + ")", x);
  }
  function lang(p, x) {
    return pseudo(":lang(" + p + ")", x);
  }
  function not(p, x) {
    var selector2 = p.split(",").map(function(x2) {
      return x2.trim();
    }).map(function(x2) {
      return ":not(" + x2 + ")";
    });
    if (selector2.length === 1) {
      return pseudo(":not(" + p + ")", x);
    }
    return select3(selector2.join(""), x);
  }
  function nthChild(p, x) {
    return pseudo(":nth-child(" + p + ")", x);
  }
  function nthLastChild(p, x) {
    return pseudo(":nth-last-child(" + p + ")", x);
  }
  function nthLastOfType(p, x) {
    return pseudo(":nth-last-of-type(" + p + ")", x);
  }
  function nthOfType(p, x) {
    return pseudo(":nth-of-type(" + p + ")", x);
  }
  function after(x) {
    return pseudo("::after", x);
  }
  function before(x) {
    return pseudo("::before", x);
  }
  function firstLetter(x) {
    return pseudo("::first-letter", x);
  }
  function firstLine(x) {
    return pseudo("::first-line", x);
  }
  function selection(x) {
    return pseudo("::selection", x);
  }
  function backdrop(x) {
    return pseudo("::backdrop", x);
  }
  function placeholder(x) {
    return css5({"::placeholder": x});
  }
  function cssFor() {
    for (var _len7 = arguments.length, rules = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      rules[_key7] = arguments[_key7];
    }
    rules = (0, _clean2.default)(rules);
    return rules ? rules.map(function(r) {
      var style2 = {label: []};
      build(style2, {src: r});
      return deconstructedStyleToCSS(hashify(style2), deconstruct(style2)).join("");
    }).join("") : "";
  }
  function attribsFor() {
    for (var _len8 = arguments.length, rules = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      rules[_key8] = arguments[_key8];
    }
    rules = (0, _clean2.default)(rules);
    var htmlAttributes = rules ? rules.map(function(rule) {
      idFor(rule);
      var key = Object.keys(rule)[0], value = rule[key];
      return key + '="' + (value || "") + '"';
    }).join(" ") : "";
    return htmlAttributes;
  }
});

// ../../node_modules/monaco-editor/esm/vs/base/common/marked/marked.js
var require_marked = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.marked = factory());
  })(exports, function() {
    "use strict";
    function _defineProperties3(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass4(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties3(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties3(Constructor, staticProps);
      return Constructor;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          return function() {
            if (i >= o.length)
              return {
                done: true
              };
            return {
              done: false,
              value: o[i++]
            };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      it = o[Symbol.iterator]();
      return it.next.bind(it);
    }
    function createCommonjsModule(fn, module2) {
      return module2 = {exports: {}}, fn(module2, module2.exports), module2.exports;
    }
    var defaults = createCommonjsModule(function(module2) {
      function getDefaults2() {
        return {
          baseUrl: null,
          breaks: false,
          gfm: true,
          headerIds: true,
          headerPrefix: "",
          highlight: null,
          langPrefix: "language-",
          mangle: true,
          pedantic: false,
          renderer: null,
          sanitize: false,
          sanitizer: null,
          silent: false,
          smartLists: false,
          smartypants: false,
          tokenizer: null,
          walkTokens: null,
          xhtml: false
        };
      }
      function changeDefaults2(newDefaults) {
        module2.exports.defaults = newDefaults;
      }
      module2.exports = {
        defaults: getDefaults2(),
        getDefaults: getDefaults2,
        changeDefaults: changeDefaults2
      };
    });
    var defaults_1 = defaults.defaults;
    var defaults_2 = defaults.getDefaults;
    var defaults_3 = defaults.changeDefaults;
    var escapeTest = /[&<>"']/;
    var escapeReplace = /[&<>"']/g;
    var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
    var escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var getEscapeReplacement = function getEscapeReplacement2(ch) {
      return escapeReplacements[ch];
    };
    function escape2(html2, encode) {
      if (encode) {
        if (escapeTest.test(html2)) {
          return html2.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html2)) {
          return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html2;
    }
    var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape2(html2) {
      return html2.replace(unescapeTest, function(_, n) {
        n = n.toLowerCase();
        if (n === "colon")
          return ":";
        if (n.charAt(0) === "#") {
          return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
        }
        return "";
      });
    }
    var caret = /(^|[^\[])\^/g;
    function edit2(regex, opt) {
      regex = regex.source || regex;
      opt = opt || "";
      var obj = {
        replace: function replace(name, val) {
          val = val.source || val;
          val = val.replace(caret, "$1");
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: function getRegex() {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }
    var nonWordAndColonTest = /[^\w:]/g;
    var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        var prot;
        try {
          prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e) {
        return null;
      }
      return href;
    }
    var baseUrls = {};
    var justDomain = /^[^:]+:\/*[^/]*$/;
    var protocol = /^([^:]+:)[\s\S]*$/;
    var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    function resolveUrl(base, href) {
      if (!baseUrls[" " + base]) {
        if (justDomain.test(base)) {
          baseUrls[" " + base] = base + "/";
        } else {
          baseUrls[" " + base] = rtrim2(base, "/", true);
        }
      }
      base = baseUrls[" " + base];
      var relativeBase = base.indexOf(":") === -1;
      if (href.substring(0, 2) === "//") {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, "$1") + href;
      } else if (href.charAt(0) === "/") {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, "$1") + href;
      } else {
        return base + href;
      }
    }
    var noopTest = {
      exec: function noopTest2() {
      }
    };
    function merge(obj) {
      var i = 1, target, key;
      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }
      return obj;
    }
    function splitCells(tableRow, count) {
      var row = tableRow.replace(/\|/g, function(match, offset, str) {
        var escaped = false, curr = offset;
        while (--curr >= 0 && str[curr] === "\\") {
          escaped = !escaped;
        }
        if (escaped) {
          return "|";
        } else {
          return " |";
        }
      }), cells = row.split(/ \|/);
      var i = 0;
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count) {
          cells.push("");
        }
      }
      for (; i < cells.length; i++) {
        cells[i] = cells[i].trim().replace(/\\\|/g, "|");
      }
      return cells;
    }
    function rtrim2(str, c, invert) {
      var l = str.length;
      if (l === 0) {
        return "";
      }
      var suffLen = 0;
      while (suffLen < l) {
        var currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }
      return str.substr(0, l - suffLen);
    }
    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      var l = str.length;
      var level = 0, i = 0;
      for (; i < l; i++) {
        if (str[i] === "\\") {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }
    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
      }
    }
    var helpers = {
      escape: escape2,
      unescape: unescape2,
      edit: edit2,
      cleanUrl,
      resolveUrl,
      noopTest,
      merge,
      splitCells,
      rtrim: rtrim2,
      findClosingBracket,
      checkSanitizeDeprecation
    };
    var defaults$1 = defaults.defaults;
    var rtrim$1 = helpers.rtrim, splitCells$1 = helpers.splitCells, _escape = helpers.escape, findClosingBracket$1 = helpers.findClosingBracket;
    function outputLink(cap, link, raw) {
      var href = link.href;
      var title = link.title ? _escape(link.title) : null;
      var text = cap[1].replace(/\\([\[\]])/g, "$1");
      if (cap[0].charAt(0) !== "!") {
        return {
          type: "link",
          raw,
          href,
          title,
          text
        };
      } else {
        return {
          type: "image",
          raw,
          href,
          title,
          text: _escape(text)
        };
      }
    }
    function indentCodeCompensation(raw, text) {
      var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text;
      }
      var indentToCode = matchIndentToCode[1];
      return text.split("\n").map(function(node) {
        var matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node;
        }
        var indentInNode = matchIndentInNode[0];
        if (indentInNode.length >= indentToCode.length) {
          return node.slice(indentToCode.length);
        }
        return node;
      }).join("\n");
    }
    var Tokenizer_1 = /* @__PURE__ */ function() {
      function Tokenizer(options) {
        this.options = options || defaults$1;
      }
      var _proto = Tokenizer.prototype;
      _proto.space = function space(src) {
        var cap = this.rules.block.newline.exec(src);
        if (cap) {
          if (cap[0].length > 1) {
            return {
              type: "space",
              raw: cap[0]
            };
          }
          return {
            raw: "\n"
          };
        }
      };
      _proto.code = function code3(src, tokens) {
        var cap = this.rules.block.code.exec(src);
        if (cap) {
          var lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "paragraph") {
            return {
              raw: cap[0],
              text: cap[0].trimRight()
            };
          }
          var text = cap[0].replace(/^ {4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim$1(text, "\n") : text
          };
        }
      };
      _proto.fences = function fences(src) {
        var cap = this.rules.block.fences.exec(src);
        if (cap) {
          var raw = cap[0];
          var text = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim() : cap[2],
            text
          };
        }
      };
      _proto.heading = function heading(src) {
        var cap = this.rules.block.heading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text: cap[2]
          };
        }
      };
      _proto.nptable = function nptable(src) {
        var cap = this.rules.block.nptable.exec(src);
        if (cap) {
          var item = {
            type: "table",
            header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, "")),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : [],
            raw: cap[0]
          };
          if (item.header.length === item.align.length) {
            var l = item.align.length;
            var i;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.cells.length;
            for (i = 0; i < l; i++) {
              item.cells[i] = splitCells$1(item.cells[i], item.header.length);
            }
            return item;
          }
        }
      };
      _proto.hr = function hr(src) {
        var cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      };
      _proto.blockquote = function blockquote(src) {
        var cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          var text = cap[0].replace(/^ *> ?/gm, "");
          return {
            type: "blockquote",
            raw: cap[0],
            text
          };
        }
      };
      _proto.list = function list(src) {
        var cap = this.rules.block.list.exec(src);
        if (cap) {
          var raw = cap[0];
          var bull = cap[2];
          var isordered = bull.length > 1;
          var isparen = bull[bull.length - 1] === ")";
          var list2 = {
            type: "list",
            raw,
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          var itemMatch = cap[0].match(this.rules.block.item);
          var next = false, item, space, b, addBack, loose, istask, ischecked;
          var l = itemMatch.length;
          for (var i = 0; i < l; i++) {
            item = itemMatch[i];
            raw = item;
            space = item.length;
            item = item.replace(/^ *([*+-]|\d+[.)]) */, "");
            if (~item.indexOf("\n ")) {
              space -= item.length;
              item = !this.options.pedantic ? item.replace(new RegExp("^ {1," + space + "}", "gm"), "") : item.replace(/^ {1,4}/gm, "");
            }
            if (i !== l - 1) {
              b = this.rules.block.bullet.exec(itemMatch[i + 1])[0];
              if (isordered ? b.length === 1 || !isparen && b[b.length - 1] === ")" : b.length > 1 || this.options.smartLists && b !== bull) {
                addBack = itemMatch.slice(i + 1).join("\n");
                list2.raw = list2.raw.substring(0, list2.raw.length - addBack.length);
                i = l - 1;
              }
            }
            loose = next || /\n\n(?!\s*$)/.test(item);
            if (i !== l - 1) {
              next = item.charAt(item.length - 1) === "\n";
              if (!loose)
                loose = next;
            }
            if (loose) {
              list2.loose = true;
            }
            istask = /^\[[ xX]\] /.test(item);
            ischecked = void 0;
            if (istask) {
              ischecked = item[1] !== " ";
              item = item.replace(/^\[[ xX]\] +/, "");
            }
            list2.items.push({
              type: "list_item",
              raw,
              task: istask,
              checked: ischecked,
              loose,
              text: item
            });
          }
          return list2;
        }
      };
      _proto.html = function html2(src) {
        var cap = this.rules.block.html.exec(src);
        if (cap) {
          return {
            type: this.options.sanitize ? "paragraph" : "html",
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
          };
        }
      };
      _proto.def = function def(src) {
        var cap = this.rules.block.def.exec(src);
        if (cap) {
          if (cap[3])
            cap[3] = cap[3].substring(1, cap[3].length - 1);
          var tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          return {
            tag,
            raw: cap[0],
            href: cap[2],
            title: cap[3]
          };
        }
      };
      _proto.table = function table(src) {
        var cap = this.rules.block.table.exec(src);
        if (cap) {
          var item = {
            type: "table",
            header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, "")),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            var l = item.align.length;
            var i;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.cells.length;
            for (i = 0; i < l; i++) {
              item.cells[i] = splitCells$1(item.cells[i].replace(/^ *\| *| *\| *$/g, ""), item.header.length);
            }
            return item;
          }
        }
      };
      _proto.lheading = function lheading(src) {
        var cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1]
          };
        }
      };
      _proto.paragraph = function paragraph(src) {
        var cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          return {
            type: "paragraph",
            raw: cap[0],
            text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1]
          };
        }
      };
      _proto.text = function text(src, tokens) {
        var cap = this.rules.block.text.exec(src);
        if (cap) {
          var lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            return {
              raw: cap[0],
              text: cap[0]
            };
          }
          return {
            type: "text",
            raw: cap[0],
            text: cap[0]
          };
        }
      };
      _proto.escape = function escape3(src) {
        var cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: _escape(cap[1])
          };
        }
      };
      _proto.tag = function tag(src, inLink, inRawBlock) {
        var cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!inLink && /^<a /i.test(cap[0])) {
            inLink = true;
          } else if (inLink && /^<\/a>/i.test(cap[0])) {
            inLink = false;
          }
          if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            inRawBlock = true;
          } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink,
            inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
          };
        }
      };
      _proto.link = function link(src) {
        var cap = this.rules.inline.link.exec(src);
        if (cap) {
          var lastParenIndex = findClosingBracket$1(cap[2], "()");
          if (lastParenIndex > -1) {
            var start = cap[0].indexOf("!") === 0 ? 5 : 4;
            var linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = "";
          }
          var href = cap[2];
          var title = "";
          if (this.options.pedantic) {
            var link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link2) {
              href = link2[1];
              title = link2[3];
            } else {
              title = "";
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim().replace(/^<([\s\S]*)>$/, "$1");
          var token = outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0]);
          return token;
        }
      };
      _proto.reflink = function reflink(src, links) {
        var cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          var link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links[link.toLowerCase()];
          if (!link || !link.href) {
            var text = cap[0].charAt(0);
            return {
              type: "text",
              raw: text,
              text
            };
          }
          var token = outputLink(cap, link, cap[0]);
          return token;
        }
      };
      _proto.strong = function strong(src, maskedSrc, prevChar) {
        if (prevChar === void 0) {
          prevChar = "";
        }
        var match = this.rules.inline.strong.start.exec(src);
        if (match && (!match[1] || match[1] && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar)))) {
          maskedSrc = maskedSrc.slice(-1 * src.length);
          var endReg = match[0] === "**" ? this.rules.inline.strong.endAst : this.rules.inline.strong.endUnd;
          endReg.lastIndex = 0;
          var cap;
          while ((match = endReg.exec(maskedSrc)) != null) {
            cap = this.rules.inline.strong.middle.exec(maskedSrc.slice(0, match.index + 3));
            if (cap) {
              return {
                type: "strong",
                raw: src.slice(0, cap[0].length),
                text: src.slice(2, cap[0].length - 2)
              };
            }
          }
        }
      };
      _proto.em = function em(src, maskedSrc, prevChar) {
        if (prevChar === void 0) {
          prevChar = "";
        }
        var match = this.rules.inline.em.start.exec(src);
        if (match && (!match[1] || match[1] && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar)))) {
          maskedSrc = maskedSrc.slice(-1 * src.length);
          var endReg = match[0] === "*" ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;
          endReg.lastIndex = 0;
          var cap;
          while ((match = endReg.exec(maskedSrc)) != null) {
            cap = this.rules.inline.em.middle.exec(maskedSrc.slice(0, match.index + 2));
            if (cap) {
              return {
                type: "em",
                raw: src.slice(0, cap[0].length),
                text: src.slice(1, cap[0].length - 1)
              };
            }
          }
        }
      };
      _proto.codespan = function codespan(src) {
        var cap = this.rules.inline.code.exec(src);
        if (cap) {
          var text = cap[2].replace(/\n/g, " ");
          var hasNonSpaceChars = /[^ ]/.test(text);
          var hasSpaceCharsOnBothEnds = text.startsWith(" ") && text.endsWith(" ");
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = _escape(text, true);
          return {
            type: "codespan",
            raw: cap[0],
            text
          };
        }
      };
      _proto.br = function br(src) {
        var cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      };
      _proto.del = function del(src) {
        var cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[1]
          };
        }
      };
      _proto.autolink = function autolink(src, mangle2) {
        var cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          var text, href;
          if (cap[2] === "@") {
            text = _escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
            href = "mailto:" + text;
          } else {
            text = _escape(cap[1]);
            href = text;
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [{
              type: "text",
              raw: text,
              text
            }]
          };
        }
      };
      _proto.url = function url(src, mangle2) {
        var cap;
        if (cap = this.rules.inline.url.exec(src)) {
          var text, href;
          if (cap[2] === "@") {
            text = _escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
            href = "mailto:" + text;
          } else {
            var prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = _escape(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + text;
            } else {
              href = text;
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [{
              type: "text",
              raw: text,
              text
            }]
          };
        }
      };
      _proto.inlineText = function inlineText(src, inRawBlock, smartypants2) {
        var cap = this.rules.inline.text.exec(src);
        if (cap) {
          var text;
          if (inRawBlock) {
            text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];
          } else {
            text = _escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text
          };
        }
      };
      return Tokenizer;
    }();
    var noopTest$1 = helpers.noopTest, edit$1 = helpers.edit, merge$1 = helpers.merge;
    var block = {
      newline: /^\n+/,
      code: /^( {4}[^\n]+\n*)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
      html: "^ {0,3}(?:<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$))",
      def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
      nptable: noopTest$1,
      table: noopTest$1,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit$1(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
    block.item = edit$1(block.item, "gm").replace(/bull/g, block.bullet).getRegex();
    block.list = edit$1(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit$1(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.paragraph = edit$1(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit$1(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = merge$1({}, block);
    block.gfm = merge$1({}, block.normal, {
      nptable: "^ *([^|\\n ].*\\|.*)\\n *([-:]+ *\\|[-| :]*)(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
      table: "^ *\\|(.+)\\n *\\|?( *[-:]+[-| :]*)(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
    });
    block.gfm.nptable = edit$1(block.gfm.nptable).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", block._tag).getRegex();
    block.gfm.table = edit$1(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = merge$1({}, block.normal, {
      html: edit$1(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
      fences: noopTest$1,
      paragraph: edit$1(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    var inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest$1,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
      nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      strong: {
        start: /^(?:(\*\*(?=[*punctuation]))|\*\*)(?![\s])|__/,
        middle: /^\*\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*\*$|^__(?![\s])((?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?)__$/,
        endAst: /[^punctuation\s]\*\*(?!\*)|[punctuation]\*\*(?!\*)(?:(?=[punctuation\s]|$))/,
        endUnd: /[^\s]__(?!_)(?:(?=[punctuation\s])|$)/
      },
      em: {
        start: /^(?:(\*(?=[punctuation]))|\*)(?![*\s])|_/,
        middle: /^\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*$|^_(?![_\s])(?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?_$/,
        endAst: /[^punctuation\s]\*(?!\*)|[punctuation]\*(?!\*)(?:(?=[punctuation\s]|$))/,
        endUnd: /[^\s]_(?!_)(?:(?=[punctuation\s])|$)/
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest$1,
      text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/,
      punctuation: /^([\s*punctuation])/
    };
    inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    inline.punctuation = edit$1(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
    inline._blockSkip = "\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>";
    inline._overlapSkip = "__[^_]*?__|\\*\\*\\[^\\*\\]*?\\*\\*";
    inline._comment = edit$1(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.em.start = edit$1(inline.em.start).replace(/punctuation/g, inline._punctuation).getRegex();
    inline.em.middle = edit$1(inline.em.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();
    inline.em.endAst = edit$1(inline.em.endAst, "g").replace(/punctuation/g, inline._punctuation).getRegex();
    inline.em.endUnd = edit$1(inline.em.endUnd, "g").replace(/punctuation/g, inline._punctuation).getRegex();
    inline.strong.start = edit$1(inline.strong.start).replace(/punctuation/g, inline._punctuation).getRegex();
    inline.strong.middle = edit$1(inline.strong.middle).replace(/punctuation/g, inline._punctuation).replace(/blockSkip/g, inline._blockSkip).getRegex();
    inline.strong.endAst = edit$1(inline.strong.endAst, "g").replace(/punctuation/g, inline._punctuation).getRegex();
    inline.strong.endUnd = edit$1(inline.strong.endUnd, "g").replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = edit$1(inline._blockSkip, "g").getRegex();
    inline.overlapSkip = edit$1(inline._overlapSkip, "g").getRegex();
    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit$1(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit$1(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit$1(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit$1(inline.reflink).replace("label", inline._label).getRegex();
    inline.reflinkSearch = edit$1(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = merge$1({}, inline);
    inline.pedantic = merge$1({}, inline.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit$1(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit$1(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    });
    inline.gfm = merge$1({}, inline.normal, {
      escape: edit$1(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^~+(?=\S)([\s\S]*?\S)~+/,
      text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
    });
    inline.gfm.url = edit$1(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = merge$1({}, inline.gfm, {
      br: edit$1(inline.br).replace("{2,}", "*").getRegex(),
      text: edit$1(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    var rules = {
      block,
      inline
    };
    var defaults$2 = defaults.defaults;
    var block$1 = rules.block, inline$1 = rules.inline;
    function smartypants(text) {
      return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
    }
    function mangle(text) {
      var out = "", i, ch;
      var l = text.length;
      for (i = 0; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = "x" + ch.toString(16);
        }
        out += "&#" + ch + ";";
      }
      return out;
    }
    var Lexer_1 = /* @__PURE__ */ function() {
      function Lexer2(options) {
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || defaults$2;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        var rules2 = {
          block: block$1.normal,
          inline: inline$1.normal
        };
        if (this.options.pedantic) {
          rules2.block = block$1.pedantic;
          rules2.inline = inline$1.pedantic;
        } else if (this.options.gfm) {
          rules2.block = block$1.gfm;
          if (this.options.breaks) {
            rules2.inline = inline$1.breaks;
          } else {
            rules2.inline = inline$1.gfm;
          }
        }
        this.tokenizer.rules = rules2;
      }
      Lexer2.lex = function lex(src, options) {
        var lexer = new Lexer2(options);
        return lexer.lex(src);
      };
      var _proto = Lexer2.prototype;
      _proto.lex = function lex(src) {
        src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
        this.blockTokens(src, this.tokens, true);
        this.inline(this.tokens);
        return this.tokens;
      };
      _proto.blockTokens = function blockTokens(src, tokens, top) {
        if (tokens === void 0) {
          tokens = [];
        }
        if (top === void 0) {
          top = true;
        }
        src = src.replace(/^ +$/gm, "");
        var token, i, l, lastToken;
        while (src) {
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.type) {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src, tokens)) {
            src = src.substring(token.raw.length);
            if (token.type) {
              tokens.push(token);
            } else {
              lastToken = tokens[tokens.length - 1];
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.nptable(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            token.tokens = this.blockTokens(token.text, [], top);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            l = token.items.length;
            for (i = 0; i < l; i++) {
              token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
            }
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (top && (token = this.tokenizer.def(src))) {
            src = src.substring(token.raw.length);
            if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (top && (token = this.tokenizer.paragraph(src))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.text(src, tokens)) {
            src = src.substring(token.raw.length);
            if (token.type) {
              tokens.push(token);
            } else {
              lastToken = tokens[tokens.length - 1];
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
            }
            continue;
          }
          if (src) {
            var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      };
      _proto.inline = function inline2(tokens) {
        var i, j, k, l2, row, token;
        var l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          switch (token.type) {
            case "paragraph":
            case "text":
            case "heading": {
              token.tokens = [];
              this.inlineTokens(token.text, token.tokens);
              break;
            }
            case "table": {
              token.tokens = {
                header: [],
                cells: []
              };
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                token.tokens.header[j] = [];
                this.inlineTokens(token.header[j], token.tokens.header[j]);
              }
              l2 = token.cells.length;
              for (j = 0; j < l2; j++) {
                row = token.cells[j];
                token.tokens.cells[j] = [];
                for (k = 0; k < row.length; k++) {
                  token.tokens.cells[j][k] = [];
                  this.inlineTokens(row[k], token.tokens.cells[j][k]);
                }
              }
              break;
            }
            case "blockquote": {
              this.inline(token.tokens);
              break;
            }
            case "list": {
              l2 = token.items.length;
              for (j = 0; j < l2; j++) {
                this.inline(token.items[j].tokens);
              }
              break;
            }
          }
        }
        return tokens;
      };
      _proto.inlineTokens = function inlineTokens(src, tokens, inLink, inRawBlock, prevChar) {
        if (tokens === void 0) {
          tokens = [];
        }
        if (inLink === void 0) {
          inLink = false;
        }
        if (inRawBlock === void 0) {
          inRawBlock = false;
        }
        if (prevChar === void 0) {
          prevChar = "";
        }
        var token;
        var maskedSrc = src;
        var match;
        if (this.tokens.links) {
          var links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while (src) {
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
            src = src.substring(token.raw.length);
            inLink = token.inLink;
            inRawBlock = token.inRawBlock;
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            if (token.type === "link") {
              token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
            }
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            if (token.type === "link") {
              token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
            }
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.strong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.em(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {
            src = src.substring(token.raw.length);
            prevChar = token.raw.slice(-1);
            tokens.push(token);
            continue;
          }
          if (src) {
            var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      };
      _createClass4(Lexer2, null, [{
        key: "rules",
        get: function get() {
          return {
            block: block$1,
            inline: inline$1
          };
        }
      }]);
      return Lexer2;
    }();
    var defaults$3 = defaults.defaults;
    var cleanUrl$1 = helpers.cleanUrl, escape$1 = helpers.escape;
    var Renderer_1 = /* @__PURE__ */ function() {
      function Renderer2(options) {
        this.options = options || defaults$3;
      }
      var _proto = Renderer2.prototype;
      _proto.code = function code3(_code, infostring, escaped) {
        var lang = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          var out = this.options.highlight(_code, lang);
          if (out != null && out !== _code) {
            escaped = true;
            _code = out;
          }
        }
        if (!lang) {
          return "<pre><code>" + (escaped ? _code : escape$1(_code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape$1(lang, true) + '">' + (escaped ? _code : escape$1(_code, true)) + "</code></pre>\n";
      };
      _proto.blockquote = function blockquote(quote) {
        return "<blockquote>\n" + quote + "</blockquote>\n";
      };
      _proto.html = function html2(_html) {
        return _html;
      };
      _proto.heading = function heading(text, level, raw, slugger) {
        if (this.options.headerIds) {
          return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + "</h" + level + ">\n";
        }
        return "<h" + level + ">" + text + "</h" + level + ">\n";
      };
      _proto.hr = function hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      };
      _proto.list = function list(body3, ordered, start) {
        var type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body3 + "</" + type + ">\n";
      };
      _proto.listitem = function listitem(text) {
        return "<li>" + text + "</li>\n";
      };
      _proto.checkbox = function checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      };
      _proto.paragraph = function paragraph(text) {
        return "<p>" + text + "</p>\n";
      };
      _proto.table = function table(header, body3) {
        if (body3)
          body3 = "<tbody>" + body3 + "</tbody>";
        return "<table>\n<thead>\n" + header + "</thead>\n" + body3 + "</table>\n";
      };
      _proto.tablerow = function tablerow(content) {
        return "<tr>\n" + content + "</tr>\n";
      };
      _proto.tablecell = function tablecell(content, flags) {
        var type = flags.header ? "th" : "td";
        var tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
        return tag + content + "</" + type + ">\n";
      };
      _proto.strong = function strong(text) {
        return "<strong>" + text + "</strong>";
      };
      _proto.em = function em(text) {
        return "<em>" + text + "</em>";
      };
      _proto.codespan = function codespan(text) {
        return "<code>" + text + "</code>";
      };
      _proto.br = function br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      };
      _proto.del = function del(text) {
        return "<del>" + text + "</del>";
      };
      _proto.link = function link(href, title, text) {
        href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        var out = '<a href="' + escape$1(href) + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text + "</a>";
        return out;
      };
      _proto.image = function image(href, title, text) {
        href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        var out = '<img src="' + href + '" alt="' + text + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      };
      _proto.text = function text(_text) {
        return _text;
      };
      return Renderer2;
    }();
    var TextRenderer_1 = /* @__PURE__ */ function() {
      function TextRenderer() {
      }
      var _proto = TextRenderer.prototype;
      _proto.strong = function strong(text) {
        return text;
      };
      _proto.em = function em(text) {
        return text;
      };
      _proto.codespan = function codespan(text) {
        return text;
      };
      _proto.del = function del(text) {
        return text;
      };
      _proto.html = function html2(text) {
        return text;
      };
      _proto.text = function text(_text) {
        return _text;
      };
      _proto.link = function link(href, title, text) {
        return "" + text;
      };
      _proto.image = function image(href, title, text) {
        return "" + text;
      };
      _proto.br = function br() {
        return "";
      };
      return TextRenderer;
    }();
    var Slugger_1 = /* @__PURE__ */ function() {
      function Slugger() {
        this.seen = {};
      }
      var _proto = Slugger.prototype;
      _proto.serialize = function serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      };
      _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
        var slug = originalSlug;
        var occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      };
      _proto.slug = function slug(value, options) {
        if (options === void 0) {
          options = {};
        }
        var slug2 = this.serialize(value);
        return this.getNextSafeSlug(slug2, options.dryrun);
      };
      return Slugger;
    }();
    var defaults$4 = defaults.defaults;
    var unescape$1 = helpers.unescape;
    var Parser_1 = /* @__PURE__ */ function() {
      function Parser(options) {
        this.options = options || defaults$4;
        this.options.renderer = this.options.renderer || new Renderer_1();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer_1();
        this.slugger = new Slugger_1();
      }
      Parser.parse = function parse4(tokens, options) {
        var parser = new Parser(options);
        return parser.parse(tokens);
      };
      var _proto = Parser.prototype;
      _proto.parse = function parse4(tokens, top) {
        if (top === void 0) {
          top = true;
        }
        var out = "", i, j, k, l2, l3, row, cell, header, body3, token, ordered, start, loose, itemBody, item, checked, task2, checkbox;
        var l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape$1(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }
            case "code": {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), {
                  header: true,
                  align: token.align[j]
                });
              }
              header += this.renderer.tablerow(cell);
              body3 = "";
              l2 = token.cells.length;
              for (j = 0; j < l2; j++) {
                row = token.tokens.cells[j];
                cell = "";
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k]), {
                    header: false,
                    align: token.align[k]
                  });
                }
                body3 += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body3);
              continue;
            }
            case "blockquote": {
              body3 = this.parse(token.tokens);
              out += this.renderer.blockquote(body3);
              continue;
            }
            case "list": {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body3 = "";
              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task2 = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "text") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body3 += this.renderer.listitem(itemBody, task2, checked);
              }
              out += this.renderer.list(body3, ordered, start);
              continue;
            }
            case "html": {
              out += this.renderer.html(token.text);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case "text": {
              body3 = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i + 1 < l && tokens[i + 1].type === "text") {
                token = tokens[++i];
                body3 += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body3) : body3;
              continue;
            }
            default: {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      };
      _proto.parseInline = function parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        var out = "", i, token;
        var l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          switch (token.type) {
            case "escape": {
              out += renderer.text(token.text);
              break;
            }
            case "html": {
              out += renderer.html(token.text);
              break;
            }
            case "link": {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token.text);
              break;
            }
            default: {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      };
      return Parser;
    }();
    var merge$2 = helpers.merge, checkSanitizeDeprecation$1 = helpers.checkSanitizeDeprecation, escape$2 = helpers.escape;
    var getDefaults = defaults.getDefaults, changeDefaults = defaults.changeDefaults, defaults$5 = defaults.defaults;
    function marked2(src, opt, callback) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      if (typeof opt === "function") {
        callback = opt;
        opt = null;
      }
      opt = merge$2({}, marked2.defaults, opt || {});
      checkSanitizeDeprecation$1(opt);
      if (callback) {
        var highlight = opt.highlight;
        var tokens;
        try {
          tokens = Lexer_1.lex(src, opt);
        } catch (e) {
          return callback(e);
        }
        var done3 = function done4(err) {
          var out;
          if (!err) {
            try {
              out = Parser_1.parse(tokens, opt);
            } catch (e) {
              err = e;
            }
          }
          opt.highlight = highlight;
          return err ? callback(err) : callback(null, out);
        };
        if (!highlight || highlight.length < 3) {
          return done3();
        }
        delete opt.highlight;
        if (!tokens.length)
          return done3();
        var pending = 0;
        marked2.walkTokens(tokens, function(token) {
          if (token.type === "code") {
            pending++;
            setTimeout(function() {
              highlight(token.text, token.lang, function(err, code3) {
                if (err) {
                  return done3(err);
                }
                if (code3 != null && code3 !== token.text) {
                  token.text = code3;
                  token.escaped = true;
                }
                pending--;
                if (pending === 0) {
                  done3();
                }
              });
            }, 0);
          }
        });
        if (pending === 0) {
          done3();
        }
        return;
      }
      try {
        var _tokens = Lexer_1.lex(src, opt);
        if (opt.walkTokens) {
          marked2.walkTokens(_tokens, opt.walkTokens);
        }
        return Parser_1.parse(_tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape$2(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    }
    marked2.options = marked2.setOptions = function(opt) {
      merge$2(marked2.defaults, opt);
      changeDefaults(marked2.defaults);
      return marked2;
    };
    marked2.getDefaults = getDefaults;
    marked2.defaults = defaults$5;
    marked2.use = function(extension) {
      var opts = merge$2({}, extension);
      if (extension.renderer) {
        (function() {
          var renderer = marked2.defaults.renderer || new Renderer_1();
          var _loop = function _loop2(prop2) {
            var prevRenderer = renderer[prop2];
            renderer[prop2] = function() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              var ret = extension.renderer[prop2].apply(renderer, args);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args);
              }
              return ret;
            };
          };
          for (var prop in extension.renderer) {
            _loop(prop);
          }
          opts.renderer = renderer;
        })();
      }
      if (extension.tokenizer) {
        (function() {
          var tokenizer = marked2.defaults.tokenizer || new Tokenizer_1();
          var _loop2 = function _loop22(prop2) {
            var prevTokenizer = tokenizer[prop2];
            tokenizer[prop2] = function() {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              var ret = extension.tokenizer[prop2].apply(tokenizer, args);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args);
              }
              return ret;
            };
          };
          for (var prop in extension.tokenizer) {
            _loop2(prop);
          }
          opts.tokenizer = tokenizer;
        })();
      }
      if (extension.walkTokens) {
        var walkTokens = marked2.defaults.walkTokens;
        opts.walkTokens = function(token) {
          extension.walkTokens(token);
          if (walkTokens) {
            walkTokens(token);
          }
        };
      }
      marked2.setOptions(opts);
    };
    marked2.walkTokens = function(tokens, callback) {
      for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done; ) {
        var token = _step.value;
        callback(token);
        switch (token.type) {
          case "table": {
            for (var _iterator2 = _createForOfIteratorHelperLoose(token.tokens.header), _step2; !(_step2 = _iterator2()).done; ) {
              var cell = _step2.value;
              marked2.walkTokens(cell, callback);
            }
            for (var _iterator3 = _createForOfIteratorHelperLoose(token.tokens.cells), _step3; !(_step3 = _iterator3()).done; ) {
              var row = _step3.value;
              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done; ) {
                var _cell = _step4.value;
                marked2.walkTokens(_cell, callback);
              }
            }
            break;
          }
          case "list": {
            marked2.walkTokens(token.items, callback);
            break;
          }
          default: {
            if (token.tokens) {
              marked2.walkTokens(token.tokens, callback);
            }
          }
        }
      }
    };
    marked2.Parser = Parser_1;
    marked2.parser = Parser_1.parse;
    marked2.Renderer = Renderer_1;
    marked2.TextRenderer = TextRenderer_1;
    marked2.Lexer = Lexer_1;
    marked2.lexer = Lexer_1.lex;
    marked2.Tokenizer = Tokenizer_1;
    marked2.Slugger = Slugger_1;
    marked2.parse = marked2;
    var marked_1 = marked2;
    return marked_1;
  });
});

// ../../node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS((exports, module) => {
  var __self__ = function(root) {
    function F() {
      this.fetch = false;
      this.DOMException = root.DOMException;
    }
    F.prototype = root;
    return new F();
  }(typeof self !== "undefined" ? self : exports);
  (function(self2) {
    var irrelevant = function(exports2) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob();
            return true;
          } catch (e) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        if (typeof name !== "string") {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator3 = {
          next: function() {
            var value = items.shift();
            return {done: value === void 0, value};
          }
        };
        if (support.iterable) {
          iterator3[Symbol.iterator] = function() {
            return iterator3;
          };
        }
        return iterator3;
      }
      function Headers2(headers2) {
        this.map = {};
        if (headers2 instanceof Headers2) {
          headers2.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (Array.isArray(headers2)) {
          headers2.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers2) {
          Object.getOwnPropertyNames(headers2).forEach(function(name) {
            this.append(name, headers2[name]);
          }, this);
        }
      }
      Headers2.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value : value;
      };
      Headers2.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers2.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers2.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers2.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };
      Headers2.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
      Headers2.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push([name, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
      }
      function consumed(body3) {
        if (body3.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body3.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise3 = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise3;
      }
      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise3 = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise3;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i = 0; i < view.length; i++) {
          chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body3) {
          this._bodyInit = body3;
          if (!body3) {
            this._bodyText = "";
          } else if (typeof body3 === "string") {
            this._bodyText = body3;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body3)) {
            this._bodyBlob = body3;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body3)) {
            this._bodyFormData = body3;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body3)) {
            this._bodyText = body3.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body3)) {
            this._bodyArrayBuffer = bufferClone(body3.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body3) || isArrayBufferView(body3))) {
            this._bodyArrayBuffer = bufferClone(body3);
          } else {
            this._bodyText = body3 = Object.prototype.toString.call(body3);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body3 === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body3)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options) {
        options = options || {};
        var body3 = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers2(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body3 && input._bodyInit != null) {
            body3 = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers2(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body3) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body3);
      }
      Request.prototype.clone = function() {
        return new Request(this, {body: this._bodyInit});
      };
      function decode(body3) {
        var form = new FormData();
        body3.trim().split("&").forEach(function(bytes) {
          if (bytes) {
            var split2 = bytes.split("=");
            var name = split2.shift().replace(/\+/g, " ");
            var value = split2.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers2 = new Headers2();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(":");
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(":").trim();
            headers2.append(key, value);
          }
        });
        return headers2;
      }
      Body.call(Request.prototype);
      function Response(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers2(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response.prototype);
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers2(this.headers),
          url: this.url
        });
      };
      Response.error = function() {
        var response = new Response(null, {status: 0, statusText: ""});
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response.redirect = function(url, status2) {
        if (redirectStatuses.indexOf(status2) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response(null, {status: status2, headers: {location: url}});
      };
      exports2.DOMException = self2.DOMException;
      try {
        new exports2.DOMException();
      } catch (err) {
        exports2.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports2.DOMException.prototype = Object.create(Error.prototype);
        exports2.DOMException.prototype.constructor = exports2.DOMException;
      }
      function fetch2(input, init2) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init2);
          if (request.signal && request.signal.aborted) {
            return reject(new exports2.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body3 = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response(body3, options));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject(new exports2.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value, name) {
            xhr.setRequestHeader(name, value);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch2;
        self2.Headers = Headers2;
        self2.Request = Request;
        self2.Response = Response;
      }
      exports2.Headers = Headers2;
      exports2.Request = Request;
      exports2.Response = Response;
      exports2.fetch = fetch2;
      return exports2;
    }({});
  })(__self__);
  delete __self__.fetch.polyfill;
  exports = __self__.fetch;
  exports.default = __self__.fetch;
  exports.fetch = __self__.fetch;
  exports.Headers = __self__.Headers;
  exports.Request = __self__.Request;
  exports.Response = __self__.Response;
  module.exports = exports;
});

// ../../node_modules/graphql/language/printer.mjs
var require_printer = __commonJS((exports) => {
  __export(exports, {
    print: () => print2
  });
  function print2(ast) {
    return visit(ast, {
      leave: printDocASTReducer
    });
  }
  var MAX_LINE_LENGTH = 80;
  var printDocASTReducer = {
    Name: function Name(node) {
      return node.value;
    },
    Variable: function Variable2(node) {
      return "$" + node.name;
    },
    Document: function Document(node) {
      return join4(node.definitions, "\n\n") + "\n";
    },
    OperationDefinition: function OperationDefinition(node) {
      var op = node.operation;
      var name = node.name;
      var varDefs = wrap2("(", join4(node.variableDefinitions, ", "), ")");
      var directives = join4(node.directives, " ");
      var selectionSet = node.selectionSet;
      return !name && !directives && !varDefs && op === "query" ? selectionSet : join4([op, join4([name, varDefs]), directives, selectionSet], " ");
    },
    VariableDefinition: function VariableDefinition(_ref2) {
      var variable = _ref2.variable, type = _ref2.type, defaultValue = _ref2.defaultValue, directives = _ref2.directives;
      return variable + ": " + type + wrap2(" = ", defaultValue) + wrap2(" ", join4(directives, " "));
    },
    SelectionSet: function SelectionSet(_ref2) {
      var selections = _ref2.selections;
      return block(selections);
    },
    Field: function Field(_ref3) {
      var alias = _ref3.alias, name = _ref3.name, args = _ref3.arguments, directives = _ref3.directives, selectionSet = _ref3.selectionSet;
      var prefix2 = wrap2("", alias, ": ") + name;
      var argsLine = prefix2 + wrap2("(", join4(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix2 + wrap2("(\n", indent(join4(args, "\n")), "\n)");
      }
      return join4([argsLine, join4(directives, " "), selectionSet], " ");
    },
    Argument: function Argument(_ref4) {
      var name = _ref4.name, value = _ref4.value;
      return name + ": " + value;
    },
    FragmentSpread: function FragmentSpread(_ref5) {
      var name = _ref5.name, directives = _ref5.directives;
      return "..." + name + wrap2(" ", join4(directives, " "));
    },
    InlineFragment: function InlineFragment(_ref6) {
      var typeCondition = _ref6.typeCondition, directives = _ref6.directives, selectionSet = _ref6.selectionSet;
      return join4(["...", wrap2("on ", typeCondition), join4(directives, " "), selectionSet], " ");
    },
    FragmentDefinition: function FragmentDefinition(_ref7) {
      var name = _ref7.name, typeCondition = _ref7.typeCondition, variableDefinitions = _ref7.variableDefinitions, directives = _ref7.directives, selectionSet = _ref7.selectionSet;
      return "fragment ".concat(name).concat(wrap2("(", join4(variableDefinitions, ", "), ")"), " ") + "on ".concat(typeCondition, " ").concat(wrap2("", join4(directives, " "), " ")) + selectionSet;
    },
    IntValue: function IntValue(_ref8) {
      var value = _ref8.value;
      return value;
    },
    FloatValue: function FloatValue(_ref9) {
      var value = _ref9.value;
      return value;
    },
    StringValue: function StringValue(_ref10, key) {
      var value = _ref10.value, isBlockString = _ref10.block;
      return isBlockString ? printBlockString(value, key === "description" ? "" : "  ") : JSON.stringify(value);
    },
    BooleanValue: function BooleanValue(_ref11) {
      var value = _ref11.value;
      return value ? "true" : "false";
    },
    NullValue: function NullValue() {
      return "null";
    },
    EnumValue: function EnumValue(_ref12) {
      var value = _ref12.value;
      return value;
    },
    ListValue: function ListValue(_ref13) {
      var values = _ref13.values;
      return "[" + join4(values, ", ") + "]";
    },
    ObjectValue: function ObjectValue(_ref14) {
      var fields = _ref14.fields;
      return "{" + join4(fields, ", ") + "}";
    },
    ObjectField: function ObjectField(_ref15) {
      var name = _ref15.name, value = _ref15.value;
      return name + ": " + value;
    },
    Directive: function Directive(_ref16) {
      var name = _ref16.name, args = _ref16.arguments;
      return "@" + name + wrap2("(", join4(args, ", "), ")");
    },
    NamedType: function NamedType(_ref17) {
      var name = _ref17.name;
      return name;
    },
    ListType: function ListType(_ref18) {
      var type = _ref18.type;
      return "[" + type + "]";
    },
    NonNullType: function NonNullType(_ref19) {
      var type = _ref19.type;
      return type + "!";
    },
    SchemaDefinition: addDescription(function(_ref20) {
      var directives = _ref20.directives, operationTypes = _ref20.operationTypes;
      return join4(["schema", join4(directives, " "), block(operationTypes)], " ");
    }),
    OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
      var operation = _ref21.operation, type = _ref21.type;
      return operation + ": " + type;
    },
    ScalarTypeDefinition: addDescription(function(_ref22) {
      var name = _ref22.name, directives = _ref22.directives;
      return join4(["scalar", name, join4(directives, " ")], " ");
    }),
    ObjectTypeDefinition: addDescription(function(_ref23) {
      var name = _ref23.name, interfaces = _ref23.interfaces, directives = _ref23.directives, fields = _ref23.fields;
      return join4(["type", name, wrap2("implements ", join4(interfaces, " & ")), join4(directives, " "), block(fields)], " ");
    }),
    FieldDefinition: addDescription(function(_ref24) {
      var name = _ref24.name, args = _ref24.arguments, type = _ref24.type, directives = _ref24.directives;
      return name + (hasMultilineItems(args) ? wrap2("(\n", indent(join4(args, "\n")), "\n)") : wrap2("(", join4(args, ", "), ")")) + ": " + type + wrap2(" ", join4(directives, " "));
    }),
    InputValueDefinition: addDescription(function(_ref25) {
      var name = _ref25.name, type = _ref25.type, defaultValue = _ref25.defaultValue, directives = _ref25.directives;
      return join4([name + ": " + type, wrap2("= ", defaultValue), join4(directives, " ")], " ");
    }),
    InterfaceTypeDefinition: addDescription(function(_ref26) {
      var name = _ref26.name, interfaces = _ref26.interfaces, directives = _ref26.directives, fields = _ref26.fields;
      return join4(["interface", name, wrap2("implements ", join4(interfaces, " & ")), join4(directives, " "), block(fields)], " ");
    }),
    UnionTypeDefinition: addDescription(function(_ref27) {
      var name = _ref27.name, directives = _ref27.directives, types4 = _ref27.types;
      return join4(["union", name, join4(directives, " "), types4 && types4.length !== 0 ? "= " + join4(types4, " | ") : ""], " ");
    }),
    EnumTypeDefinition: addDescription(function(_ref28) {
      var name = _ref28.name, directives = _ref28.directives, values = _ref28.values;
      return join4(["enum", name, join4(directives, " "), block(values)], " ");
    }),
    EnumValueDefinition: addDescription(function(_ref29) {
      var name = _ref29.name, directives = _ref29.directives;
      return join4([name, join4(directives, " ")], " ");
    }),
    InputObjectTypeDefinition: addDescription(function(_ref30) {
      var name = _ref30.name, directives = _ref30.directives, fields = _ref30.fields;
      return join4(["input", name, join4(directives, " "), block(fields)], " ");
    }),
    DirectiveDefinition: addDescription(function(_ref31) {
      var name = _ref31.name, args = _ref31.arguments, repeatable = _ref31.repeatable, locations = _ref31.locations;
      return "directive @" + name + (hasMultilineItems(args) ? wrap2("(\n", indent(join4(args, "\n")), "\n)") : wrap2("(", join4(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join4(locations, " | ");
    }),
    SchemaExtension: function SchemaExtension(_ref32) {
      var directives = _ref32.directives, operationTypes = _ref32.operationTypes;
      return join4(["extend schema", join4(directives, " "), block(operationTypes)], " ");
    },
    ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
      var name = _ref33.name, directives = _ref33.directives;
      return join4(["extend scalar", name, join4(directives, " ")], " ");
    },
    ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
      var name = _ref34.name, interfaces = _ref34.interfaces, directives = _ref34.directives, fields = _ref34.fields;
      return join4(["extend type", name, wrap2("implements ", join4(interfaces, " & ")), join4(directives, " "), block(fields)], " ");
    },
    InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
      var name = _ref35.name, interfaces = _ref35.interfaces, directives = _ref35.directives, fields = _ref35.fields;
      return join4(["extend interface", name, wrap2("implements ", join4(interfaces, " & ")), join4(directives, " "), block(fields)], " ");
    },
    UnionTypeExtension: function UnionTypeExtension(_ref36) {
      var name = _ref36.name, directives = _ref36.directives, types4 = _ref36.types;
      return join4(["extend union", name, join4(directives, " "), types4 && types4.length !== 0 ? "= " + join4(types4, " | ") : ""], " ");
    },
    EnumTypeExtension: function EnumTypeExtension(_ref37) {
      var name = _ref37.name, directives = _ref37.directives, values = _ref37.values;
      return join4(["extend enum", name, join4(directives, " "), block(values)], " ");
    },
    InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
      var name = _ref38.name, directives = _ref38.directives, fields = _ref38.fields;
      return join4(["extend input", name, join4(directives, " "), block(fields)], " ");
    }
  };
  function addDescription(cb) {
    return function(node) {
      return join4([node.description, cb(node)], "\n");
    };
  }
  function join4(maybeArray) {
    var _maybeArray$filter$jo;
    var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter(function(x) {
      return x;
    }).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
  }
  function block(array4) {
    return wrap2("{\n", indent(join4(array4, "\n")), "\n}");
  }
  function wrap2(start, maybeString) {
    var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
  }
  function indent(str) {
    return wrap2("  ", str.replace(/\n/g, "\n  "));
  }
  function isMultiline(str) {
    return str.indexOf("\n") !== -1;
  }
  function hasMultilineItems(maybeArray) {
    return maybeArray != null && maybeArray.some(isMultiline);
  }
});

// ../../node_modules/extract-files/public/ReactNativeFile.js
var require_ReactNativeFile = __commonJS((exports, module) => {
  "use strict";
  module.exports = function ReactNativeFile(_ref2) {
    var uri = _ref2.uri, name = _ref2.name, type = _ref2.type;
    this.uri = uri;
    this.name = name;
    this.type = type;
  };
});

// ../../node_modules/extract-files/public/isExtractableFile.js
var require_isExtractableFile = __commonJS((exports, module) => {
  "use strict";
  var ReactNativeFile = require_ReactNativeFile();
  module.exports = function isExtractableFile(value) {
    return typeof File !== "undefined" && value instanceof File || typeof Blob !== "undefined" && value instanceof Blob || value instanceof ReactNativeFile;
  };
});

// ../../node_modules/extract-files/public/extractFiles.js
var require_extractFiles = __commonJS((exports, module) => {
  "use strict";
  var defaultIsExtractableFile = require_isExtractableFile();
  module.exports = function extractFiles(value, path3, isExtractableFile) {
    if (path3 === void 0) {
      path3 = "";
    }
    if (isExtractableFile === void 0) {
      isExtractableFile = defaultIsExtractableFile;
    }
    var clone;
    var files = new Map();
    function addFile(paths, file) {
      var storedPaths = files.get(file);
      if (storedPaths)
        storedPaths.push.apply(storedPaths, paths);
      else
        files.set(file, paths);
    }
    if (isExtractableFile(value)) {
      clone = null;
      addFile([path3], value);
    } else {
      var prefix2 = path3 ? path3 + "." : "";
      if (typeof FileList !== "undefined" && value instanceof FileList)
        clone = Array.prototype.map.call(value, function(file, i2) {
          addFile(["" + prefix2 + i2], file);
          return null;
        });
      else if (Array.isArray(value))
        clone = value.map(function(child, i2) {
          var result2 = extractFiles(child, "" + prefix2 + i2, isExtractableFile);
          result2.files.forEach(addFile);
          return result2.clone;
        });
      else if (value && value.constructor === Object) {
        clone = {};
        for (var i in value) {
          var result = extractFiles(value[i], "" + prefix2 + i, isExtractableFile);
          result.files.forEach(addFile);
          clone[i] = result.clone;
        }
      } else
        clone = value;
    }
    return {
      clone,
      files
    };
  };
});

// ../../node_modules/extract-files/public/index.mjs
var require_public = __commonJS((exports) => {
  __export(exports, {
    ReactNativeFile: () => import_ReactNativeFile.default,
    extractFiles: () => import_extractFiles.default,
    isExtractableFile: () => import_isExtractableFile.default
  });
  var import_ReactNativeFile = __toModule(require_ReactNativeFile());
  var import_extractFiles = __toModule(require_extractFiles());
  var import_isExtractableFile = __toModule(require_isExtractableFile());
});

// ../../node_modules/graphql-request/node_modules/form-data/lib/browser.js
var require_browser3 = __commonJS((exports, module) => {
  module.exports = typeof self == "object" ? self.FormData : window.FormData;
});

// ../../node_modules/graphql-request/dist/createRequestBody.js
var require_createRequestBody = __commonJS((exports) => {
  "use strict";
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  var extract_files_1 = require_public();
  var form_data_1 = __importDefault(require_browser3());
  var isExtractableFileEnhanced = function(value) {
    return extract_files_1.isExtractableFile(value) || value !== null && typeof value === "object" && typeof value.pipe === "function";
  };
  function createRequestBody(query, variables) {
    var _a5 = extract_files_1.extractFiles({query, variables}, "", isExtractableFileEnhanced), clone = _a5.clone, files = _a5.files;
    if (files.size === 0) {
      return JSON.stringify(clone);
    }
    var Form = typeof FormData === "undefined" ? form_data_1.default : FormData;
    var form = new Form();
    form.append("operations", JSON.stringify(clone));
    var map = {};
    var i = 0;
    files.forEach(function(paths) {
      map[++i] = paths;
    });
    form.append("map", JSON.stringify(map));
    i = 0;
    files.forEach(function(paths, file) {
      form.append("" + ++i, file);
    });
    return form;
  }
  exports.default = createRequestBody;
});

// ../../node_modules/graphql-request/dist/types.js
var require_types = __commonJS((exports) => {
  "use strict";
  var __extends2 = exports && exports.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ClientError = void 0;
  var ClientError = function(_super) {
    __extends2(ClientError2, _super);
    function ClientError2(response, request) {
      var _this = this;
      var message = ClientError2.extractMessage(response) + ": " + JSON.stringify({
        response,
        request
      });
      _this = _super.call(this, message) || this;
      Object.setPrototypeOf(_this, ClientError2.prototype);
      _this.response = response;
      _this.request = request;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(_this, ClientError2);
      }
      return _this;
    }
    ClientError2.extractMessage = function(response) {
      try {
        return response.errors[0].message;
      } catch (e) {
        return "GraphQL Error (Code: " + response.status + ")";
      }
    };
    return ClientError2;
  }(Error);
  exports.ClientError = ClientError;
});

// ../../node_modules/graphql-request/dist/index.js
var require_dist2 = __commonJS((exports) => {
  "use strict";
  var __assign2 = exports && exports.__assign || function() {
    __assign2 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign2.apply(this, arguments);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable: true, value: v});
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter37 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator2 = exports && exports.__generator || function(thisArg, body3) {
    var _ = {label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: []}, f, y, t, g;
    return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {value: op[1], done: false};
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body3.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return {value: op[0] ? op[1] : void 0, done: true};
    }
  };
  var __rest2 = exports && exports.__rest || function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.gql = exports.request = exports.rawRequest = exports.GraphQLClient = exports.ClientError = void 0;
  var cross_fetch_1 = __importStar(require_browser_ponyfill());
  var CrossFetch = cross_fetch_1;
  var printer_1 = require_printer();
  var createRequestBody_1 = __importDefault(require_createRequestBody());
  var types_1 = require_types();
  var types_2 = require_types();
  Object.defineProperty(exports, "ClientError", {enumerable: true, get: function() {
    return types_2.ClientError;
  }});
  var resolveHeaders = function(headers2) {
    var oHeaders = {};
    if (headers2) {
      if (typeof Headers !== "undefined" && headers2 instanceof Headers || headers2 instanceof CrossFetch.Headers) {
        oHeaders = HeadersInstanceToPlainObject(headers2);
      } else if (Array.isArray(headers2)) {
        headers2.forEach(function(_a5) {
          var name = _a5[0], value = _a5[1];
          oHeaders[name] = value;
        });
      } else {
        oHeaders = headers2;
      }
    }
    return oHeaders;
  };
  var GraphQLClient2 = function() {
    function GraphQLClient3(url, options) {
      this.url = url;
      this.options = options || {};
    }
    GraphQLClient3.prototype.rawRequest = function(query, variables, requestHeaders) {
      return __awaiter37(this, void 0, void 0, function() {
        var _a5, headers2, _b2, localFetch, others, body3, response, result, headers_1, status_1, errorResult;
        return __generator2(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              _a5 = this.options, headers2 = _a5.headers, _b2 = _a5.fetch, localFetch = _b2 === void 0 ? cross_fetch_1.default : _b2, others = __rest2(_a5, ["headers", "fetch"]);
              body3 = createRequestBody_1.default(query, variables);
              return [4, localFetch(this.url, __assign2({method: "POST", headers: __assign2(__assign2(__assign2({}, typeof body3 === "string" ? {"Content-Type": "application/json"} : {}), resolveHeaders(headers2)), resolveHeaders(requestHeaders)), body: body3}, others))];
            case 1:
              response = _c2.sent();
              return [4, getResult(response)];
            case 2:
              result = _c2.sent();
              if (response.ok && !result.errors && result.data) {
                headers_1 = response.headers, status_1 = response.status;
                return [2, __assign2(__assign2({}, result), {headers: headers_1, status: status_1})];
              } else {
                errorResult = typeof result === "string" ? {error: result} : result;
                throw new types_1.ClientError(__assign2(__assign2({}, errorResult), {status: response.status, headers: response.headers}), {query, variables});
              }
              return [2];
          }
        });
      });
    };
    GraphQLClient3.prototype.request = function(document2, variables, requestHeaders) {
      return __awaiter37(this, void 0, void 0, function() {
        var _a5, headers2, _b2, localFetch, others, resolvedDoc, body3, response, result, errorResult;
        return __generator2(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              _a5 = this.options, headers2 = _a5.headers, _b2 = _a5.fetch, localFetch = _b2 === void 0 ? cross_fetch_1.default : _b2, others = __rest2(_a5, ["headers", "fetch"]);
              resolvedDoc = resolveRequestDocument(document2);
              body3 = createRequestBody_1.default(resolvedDoc, variables);
              return [4, localFetch(this.url, __assign2({method: "POST", headers: __assign2(__assign2(__assign2({}, typeof body3 === "string" ? {"Content-Type": "application/json"} : {}), resolveHeaders(headers2)), resolveHeaders(requestHeaders)), body: body3}, others))];
            case 1:
              response = _c2.sent();
              return [4, getResult(response)];
            case 2:
              result = _c2.sent();
              if (response.ok && !result.errors && result.data) {
                return [2, result.data];
              } else {
                errorResult = typeof result === "string" ? {error: result} : result;
                throw new types_1.ClientError(__assign2(__assign2({}, errorResult), {status: response.status}), {query: resolvedDoc, variables});
              }
              return [2];
          }
        });
      });
    };
    GraphQLClient3.prototype.setHeaders = function(headers2) {
      this.options.headers = headers2;
      return this;
    };
    GraphQLClient3.prototype.setHeader = function(key, value) {
      var _a5;
      var headers2 = this.options.headers;
      if (headers2) {
        headers2[key] = value;
      } else {
        this.options.headers = (_a5 = {}, _a5[key] = value, _a5);
      }
      return this;
    };
    return GraphQLClient3;
  }();
  exports.GraphQLClient = GraphQLClient2;
  function rawRequest(url, query, variables) {
    return __awaiter37(this, void 0, void 0, function() {
      var client2;
      return __generator2(this, function(_a5) {
        client2 = new GraphQLClient2(url);
        return [2, client2.rawRequest(query, variables)];
      });
    });
  }
  exports.rawRequest = rawRequest;
  function request(url, document2, variables) {
    return __awaiter37(this, void 0, void 0, function() {
      var client2;
      return __generator2(this, function(_a5) {
        client2 = new GraphQLClient2(url);
        return [2, client2.request(document2, variables)];
      });
    });
  }
  exports.request = request;
  exports.default = request;
  function getResult(response) {
    var contentType = response.headers.get("Content-Type");
    if (contentType && contentType.startsWith("application/json")) {
      return response.json();
    } else {
      return response.text();
    }
  }
  function resolveRequestDocument(document2) {
    if (typeof document2 === "string")
      return document2;
    return printer_1.print(document2);
  }
  function gql2(chunks) {
    var variables = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      variables[_i - 1] = arguments[_i];
    }
    return chunks.reduce(function(accumulator, chunk, index2) {
      return "" + accumulator + chunk + (index2 in variables ? variables[index2] : "");
    }, "");
  }
  exports.gql = gql2;
  function HeadersInstanceToPlainObject(headers2) {
    var o = {};
    headers2.forEach(function(v, k) {
      o[k] = v;
    });
    return o;
  }
});

// ../../node_modules/graphql/language/parser.mjs
var require_parser = __commonJS((exports) => {
  __export(exports, {
    Parser: () => Parser,
    parse: () => parse4,
    parseType: () => parseType,
    parseValue: () => parseValue
  });
  function parse4(source, options) {
    var parser = new Parser(source, options);
    return parser.parseDocument();
  }
  function parseValue(source, options) {
    var parser = new Parser(source, options);
    parser.expectToken(TokenKind.SOF);
    var value = parser.parseValueLiteral(false);
    parser.expectToken(TokenKind.EOF);
    return value;
  }
  function parseType(source, options) {
    var parser = new Parser(source, options);
    parser.expectToken(TokenKind.SOF);
    var type = parser.parseTypeReference();
    parser.expectToken(TokenKind.EOF);
    return type;
  }
  var Parser = /* @__PURE__ */ function() {
    function Parser2(source, options) {
      var sourceObj = isSource(source) ? source : new Source(source);
      this._lexer = new Lexer(sourceObj);
      this._options = options;
    }
    var _proto = Parser2.prototype;
    _proto.parseName = function parseName() {
      var token = this.expectToken(TokenKind.NAME);
      return {
        kind: Kind.NAME,
        value: token.value,
        loc: this.loc(token)
      };
    };
    _proto.parseDocument = function parseDocument() {
      var start = this._lexer.token;
      return {
        kind: Kind.DOCUMENT,
        definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),
        loc: this.loc(start)
      };
    };
    _proto.parseDefinition = function parseDefinition() {
      if (this.peek(TokenKind.NAME)) {
        switch (this._lexer.token.value) {
          case "query":
          case "mutation":
          case "subscription":
            return this.parseOperationDefinition();
          case "fragment":
            return this.parseFragmentDefinition();
          case "schema":
          case "scalar":
          case "type":
          case "interface":
          case "union":
          case "enum":
          case "input":
          case "directive":
            return this.parseTypeSystemDefinition();
          case "extend":
            return this.parseTypeSystemExtension();
        }
      } else if (this.peek(TokenKind.BRACE_L)) {
        return this.parseOperationDefinition();
      } else if (this.peekDescription()) {
        return this.parseTypeSystemDefinition();
      }
      throw this.unexpected();
    };
    _proto.parseOperationDefinition = function parseOperationDefinition() {
      var start = this._lexer.token;
      if (this.peek(TokenKind.BRACE_L)) {
        return {
          kind: Kind.OPERATION_DEFINITION,
          operation: "query",
          name: void 0,
          variableDefinitions: [],
          directives: [],
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      }
      var operation = this.parseOperationType();
      var name;
      if (this.peek(TokenKind.NAME)) {
        name = this.parseName();
      }
      return {
        kind: Kind.OPERATION_DEFINITION,
        operation,
        name,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    };
    _proto.parseOperationType = function parseOperationType() {
      var operationToken = this.expectToken(TokenKind.NAME);
      switch (operationToken.value) {
        case "query":
          return "query";
        case "mutation":
          return "mutation";
        case "subscription":
          return "subscription";
      }
      throw this.unexpected(operationToken);
    };
    _proto.parseVariableDefinitions = function parseVariableDefinitions() {
      return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
    };
    _proto.parseVariableDefinition = function parseVariableDefinition() {
      var start = this._lexer.token;
      return {
        kind: Kind.VARIABLE_DEFINITION,
        variable: this.parseVariable(),
        type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : void 0,
        directives: this.parseDirectives(true),
        loc: this.loc(start)
      };
    };
    _proto.parseVariable = function parseVariable() {
      var start = this._lexer.token;
      this.expectToken(TokenKind.DOLLAR);
      return {
        kind: Kind.VARIABLE,
        name: this.parseName(),
        loc: this.loc(start)
      };
    };
    _proto.parseSelectionSet = function parseSelectionSet() {
      var start = this._lexer.token;
      return {
        kind: Kind.SELECTION_SET,
        selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),
        loc: this.loc(start)
      };
    };
    _proto.parseSelection = function parseSelection() {
      return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    };
    _proto.parseField = function parseField() {
      var start = this._lexer.token;
      var nameOrAlias = this.parseName();
      var alias;
      var name;
      if (this.expectOptionalToken(TokenKind.COLON)) {
        alias = nameOrAlias;
        name = this.parseName();
      } else {
        name = nameOrAlias;
      }
      return {
        kind: Kind.FIELD,
        alias,
        name,
        arguments: this.parseArguments(false),
        directives: this.parseDirectives(false),
        selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,
        loc: this.loc(start)
      };
    };
    _proto.parseArguments = function parseArguments(isConst) {
      var item = isConst ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
    };
    _proto.parseArgument = function parseArgument() {
      var start = this._lexer.token;
      var name = this.parseName();
      this.expectToken(TokenKind.COLON);
      return {
        kind: Kind.ARGUMENT,
        name,
        value: this.parseValueLiteral(false),
        loc: this.loc(start)
      };
    };
    _proto.parseConstArgument = function parseConstArgument() {
      var start = this._lexer.token;
      return {
        kind: Kind.ARGUMENT,
        name: this.parseName(),
        value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),
        loc: this.loc(start)
      };
    };
    _proto.parseFragment = function parseFragment() {
      var start = this._lexer.token;
      this.expectToken(TokenKind.SPREAD);
      var hasTypeCondition = this.expectOptionalKeyword("on");
      if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
        return {
          kind: Kind.FRAGMENT_SPREAD,
          name: this.parseFragmentName(),
          directives: this.parseDirectives(false),
          loc: this.loc(start)
        };
      }
      return {
        kind: Kind.INLINE_FRAGMENT,
        typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    };
    _proto.parseFragmentDefinition = function parseFragmentDefinition() {
      var _this$_options;
      var start = this._lexer.token;
      this.expectKeyword("fragment");
      if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {
        return {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          variableDefinitions: this.parseVariableDefinitions(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      }
      return {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    };
    _proto.parseFragmentName = function parseFragmentName() {
      if (this._lexer.token.value === "on") {
        throw this.unexpected();
      }
      return this.parseName();
    };
    _proto.parseValueLiteral = function parseValueLiteral(isConst) {
      var token = this._lexer.token;
      switch (token.kind) {
        case TokenKind.BRACKET_L:
          return this.parseList(isConst);
        case TokenKind.BRACE_L:
          return this.parseObject(isConst);
        case TokenKind.INT:
          this._lexer.advance();
          return {
            kind: Kind.INT,
            value: token.value,
            loc: this.loc(token)
          };
        case TokenKind.FLOAT:
          this._lexer.advance();
          return {
            kind: Kind.FLOAT,
            value: token.value,
            loc: this.loc(token)
          };
        case TokenKind.STRING:
        case TokenKind.BLOCK_STRING:
          return this.parseStringLiteral();
        case TokenKind.NAME:
          this._lexer.advance();
          switch (token.value) {
            case "true":
              return {
                kind: Kind.BOOLEAN,
                value: true,
                loc: this.loc(token)
              };
            case "false":
              return {
                kind: Kind.BOOLEAN,
                value: false,
                loc: this.loc(token)
              };
            case "null":
              return {
                kind: Kind.NULL,
                loc: this.loc(token)
              };
            default:
              return {
                kind: Kind.ENUM,
                value: token.value,
                loc: this.loc(token)
              };
          }
        case TokenKind.DOLLAR:
          if (!isConst) {
            return this.parseVariable();
          }
          break;
      }
      throw this.unexpected();
    };
    _proto.parseStringLiteral = function parseStringLiteral() {
      var token = this._lexer.token;
      this._lexer.advance();
      return {
        kind: Kind.STRING,
        value: token.value,
        block: token.kind === TokenKind.BLOCK_STRING,
        loc: this.loc(token)
      };
    };
    _proto.parseList = function parseList(isConst) {
      var _this = this;
      var start = this._lexer.token;
      var item = function item2() {
        return _this.parseValueLiteral(isConst);
      };
      return {
        kind: Kind.LIST,
        values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),
        loc: this.loc(start)
      };
    };
    _proto.parseObject = function parseObject(isConst) {
      var _this2 = this;
      var start = this._lexer.token;
      var item = function item2() {
        return _this2.parseObjectField(isConst);
      };
      return {
        kind: Kind.OBJECT,
        fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),
        loc: this.loc(start)
      };
    };
    _proto.parseObjectField = function parseObjectField(isConst) {
      var start = this._lexer.token;
      var name = this.parseName();
      this.expectToken(TokenKind.COLON);
      return {
        kind: Kind.OBJECT_FIELD,
        name,
        value: this.parseValueLiteral(isConst),
        loc: this.loc(start)
      };
    };
    _proto.parseDirectives = function parseDirectives(isConst) {
      var directives = [];
      while (this.peek(TokenKind.AT)) {
        directives.push(this.parseDirective(isConst));
      }
      return directives;
    };
    _proto.parseDirective = function parseDirective(isConst) {
      var start = this._lexer.token;
      this.expectToken(TokenKind.AT);
      return {
        kind: Kind.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(isConst),
        loc: this.loc(start)
      };
    };
    _proto.parseTypeReference = function parseTypeReference() {
      var start = this._lexer.token;
      var type;
      if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
        type = this.parseTypeReference();
        this.expectToken(TokenKind.BRACKET_R);
        type = {
          kind: Kind.LIST_TYPE,
          type,
          loc: this.loc(start)
        };
      } else {
        type = this.parseNamedType();
      }
      if (this.expectOptionalToken(TokenKind.BANG)) {
        return {
          kind: Kind.NON_NULL_TYPE,
          type,
          loc: this.loc(start)
        };
      }
      return type;
    };
    _proto.parseNamedType = function parseNamedType() {
      var start = this._lexer.token;
      return {
        kind: Kind.NAMED_TYPE,
        name: this.parseName(),
        loc: this.loc(start)
      };
    };
    _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
      var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaDefinition();
          case "scalar":
            return this.parseScalarTypeDefinition();
          case "type":
            return this.parseObjectTypeDefinition();
          case "interface":
            return this.parseInterfaceTypeDefinition();
          case "union":
            return this.parseUnionTypeDefinition();
          case "enum":
            return this.parseEnumTypeDefinition();
          case "input":
            return this.parseInputObjectTypeDefinition();
          case "directive":
            return this.parseDirectiveDefinition();
        }
      }
      throw this.unexpected(keywordToken);
    };
    _proto.peekDescription = function peekDescription() {
      return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
    };
    _proto.parseDescription = function parseDescription() {
      if (this.peekDescription()) {
        return this.parseStringLiteral();
      }
    };
    _proto.parseSchemaDefinition = function parseSchemaDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("schema");
      var directives = this.parseDirectives(true);
      var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
      return {
        kind: Kind.SCHEMA_DEFINITION,
        description,
        directives,
        operationTypes,
        loc: this.loc(start)
      };
    };
    _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
      var start = this._lexer.token;
      var operation = this.parseOperationType();
      this.expectToken(TokenKind.COLON);
      var type = this.parseNamedType();
      return {
        kind: Kind.OPERATION_TYPE_DEFINITION,
        operation,
        type,
        loc: this.loc(start)
      };
    };
    _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("scalar");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      return {
        kind: Kind.SCALAR_TYPE_DEFINITION,
        description,
        name,
        directives,
        loc: this.loc(start)
      };
    };
    _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("type");
      var name = this.parseName();
      var interfaces = this.parseImplementsInterfaces();
      var directives = this.parseDirectives(true);
      var fields = this.parseFieldsDefinition();
      return {
        kind: Kind.OBJECT_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields,
        loc: this.loc(start)
      };
    };
    _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
      var _this$_options2;
      if (!this.expectOptionalKeyword("implements")) {
        return [];
      }
      if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {
        var types4 = [];
        this.expectOptionalToken(TokenKind.AMP);
        do {
          types4.push(this.parseNamedType());
        } while (this.expectOptionalToken(TokenKind.AMP) || this.peek(TokenKind.NAME));
        return types4;
      }
      return this.delimitedMany(TokenKind.AMP, this.parseNamedType);
    };
    _proto.parseFieldsDefinition = function parseFieldsDefinition() {
      var _this$_options3;
      if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {
        this._lexer.advance();
        this._lexer.advance();
        return [];
      }
      return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
    };
    _proto.parseFieldDefinition = function parseFieldDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      var name = this.parseName();
      var args = this.parseArgumentDefs();
      this.expectToken(TokenKind.COLON);
      var type = this.parseTypeReference();
      var directives = this.parseDirectives(true);
      return {
        kind: Kind.FIELD_DEFINITION,
        description,
        name,
        arguments: args,
        type,
        directives,
        loc: this.loc(start)
      };
    };
    _proto.parseArgumentDefs = function parseArgumentDefs() {
      return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
    };
    _proto.parseInputValueDef = function parseInputValueDef() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      var name = this.parseName();
      this.expectToken(TokenKind.COLON);
      var type = this.parseTypeReference();
      var defaultValue;
      if (this.expectOptionalToken(TokenKind.EQUALS)) {
        defaultValue = this.parseValueLiteral(true);
      }
      var directives = this.parseDirectives(true);
      return {
        kind: Kind.INPUT_VALUE_DEFINITION,
        description,
        name,
        type,
        defaultValue,
        directives,
        loc: this.loc(start)
      };
    };
    _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("interface");
      var name = this.parseName();
      var interfaces = this.parseImplementsInterfaces();
      var directives = this.parseDirectives(true);
      var fields = this.parseFieldsDefinition();
      return {
        kind: Kind.INTERFACE_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields,
        loc: this.loc(start)
      };
    };
    _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("union");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      var types4 = this.parseUnionMemberTypes();
      return {
        kind: Kind.UNION_TYPE_DEFINITION,
        description,
        name,
        directives,
        types: types4,
        loc: this.loc(start)
      };
    };
    _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
      return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
    };
    _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("enum");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      var values = this.parseEnumValuesDefinition();
      return {
        kind: Kind.ENUM_TYPE_DEFINITION,
        description,
        name,
        directives,
        values,
        loc: this.loc(start)
      };
    };
    _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
      return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
    };
    _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      return {
        kind: Kind.ENUM_VALUE_DEFINITION,
        description,
        name,
        directives,
        loc: this.loc(start)
      };
    };
    _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("input");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      var fields = this.parseInputFieldsDefinition();
      return {
        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description,
        name,
        directives,
        fields,
        loc: this.loc(start)
      };
    };
    _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
      return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
    };
    _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
      var keywordToken = this._lexer.lookahead();
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaExtension();
          case "scalar":
            return this.parseScalarTypeExtension();
          case "type":
            return this.parseObjectTypeExtension();
          case "interface":
            return this.parseInterfaceTypeExtension();
          case "union":
            return this.parseUnionTypeExtension();
          case "enum":
            return this.parseEnumTypeExtension();
          case "input":
            return this.parseInputObjectTypeExtension();
        }
      }
      throw this.unexpected(keywordToken);
    };
    _proto.parseSchemaExtension = function parseSchemaExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("schema");
      var directives = this.parseDirectives(true);
      var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
      if (directives.length === 0 && operationTypes.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: Kind.SCHEMA_EXTENSION,
        directives,
        operationTypes,
        loc: this.loc(start)
      };
    };
    _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("scalar");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      if (directives.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: Kind.SCALAR_TYPE_EXTENSION,
        name,
        directives,
        loc: this.loc(start)
      };
    };
    _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("type");
      var name = this.parseName();
      var interfaces = this.parseImplementsInterfaces();
      var directives = this.parseDirectives(true);
      var fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: Kind.OBJECT_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields,
        loc: this.loc(start)
      };
    };
    _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("interface");
      var name = this.parseName();
      var interfaces = this.parseImplementsInterfaces();
      var directives = this.parseDirectives(true);
      var fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: Kind.INTERFACE_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields,
        loc: this.loc(start)
      };
    };
    _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("union");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      var types4 = this.parseUnionMemberTypes();
      if (directives.length === 0 && types4.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: Kind.UNION_TYPE_EXTENSION,
        name,
        directives,
        types: types4,
        loc: this.loc(start)
      };
    };
    _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("enum");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      var values = this.parseEnumValuesDefinition();
      if (directives.length === 0 && values.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: Kind.ENUM_TYPE_EXTENSION,
        name,
        directives,
        values,
        loc: this.loc(start)
      };
    };
    _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
      var start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("input");
      var name = this.parseName();
      var directives = this.parseDirectives(true);
      var fields = this.parseInputFieldsDefinition();
      if (directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return {
        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name,
        directives,
        fields,
        loc: this.loc(start)
      };
    };
    _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
      var start = this._lexer.token;
      var description = this.parseDescription();
      this.expectKeyword("directive");
      this.expectToken(TokenKind.AT);
      var name = this.parseName();
      var args = this.parseArgumentDefs();
      var repeatable = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      var locations = this.parseDirectiveLocations();
      return {
        kind: Kind.DIRECTIVE_DEFINITION,
        description,
        name,
        arguments: args,
        repeatable,
        locations,
        loc: this.loc(start)
      };
    };
    _proto.parseDirectiveLocations = function parseDirectiveLocations() {
      return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
    };
    _proto.parseDirectiveLocation = function parseDirectiveLocation() {
      var start = this._lexer.token;
      var name = this.parseName();
      if (DirectiveLocation[name.value] !== void 0) {
        return name;
      }
      throw this.unexpected(start);
    };
    _proto.loc = function loc(startToken) {
      var _this$_options4;
      if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {
        return new Location(startToken, this._lexer.lastToken, this._lexer.source);
      }
    };
    _proto.peek = function peek(kind) {
      return this._lexer.token.kind === kind;
    };
    _proto.expectToken = function expectToken(kind) {
      var token = this._lexer.token;
      if (token.kind === kind) {
        this._lexer.advance();
        return token;
      }
      throw syntaxError(this._lexer.source, token.start, "Expected ".concat(getTokenKindDesc(kind), ", found ").concat(getTokenDesc(token), "."));
    };
    _proto.expectOptionalToken = function expectOptionalToken(kind) {
      var token = this._lexer.token;
      if (token.kind === kind) {
        this._lexer.advance();
        return token;
      }
      return void 0;
    };
    _proto.expectKeyword = function expectKeyword(value) {
      var token = this._lexer.token;
      if (token.kind === TokenKind.NAME && token.value === value) {
        this._lexer.advance();
      } else {
        throw syntaxError(this._lexer.source, token.start, 'Expected "'.concat(value, '", found ').concat(getTokenDesc(token), "."));
      }
    };
    _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
      var token = this._lexer.token;
      if (token.kind === TokenKind.NAME && token.value === value) {
        this._lexer.advance();
        return true;
      }
      return false;
    };
    _proto.unexpected = function unexpected(atToken) {
      var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
      return syntaxError(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token), "."));
    };
    _proto.any = function any(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      var nodes = [];
      while (!this.expectOptionalToken(closeKind)) {
        nodes.push(parseFn.call(this));
      }
      return nodes;
    };
    _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
      if (this.expectOptionalToken(openKind)) {
        var nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      return [];
    };
    _proto.many = function many(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      var nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    };
    _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {
      this.expectOptionalToken(delimiterKind);
      var nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (this.expectOptionalToken(delimiterKind));
      return nodes;
    };
    return Parser2;
  }();
  function getTokenDesc(token) {
    var value = token.value;
    return getTokenKindDesc(token.kind) + (value != null ? ' "'.concat(value, '"') : "");
  }
  function getTokenKindDesc(kind) {
    return isPunctuatorTokenKind(kind) ? '"'.concat(kind, '"') : kind;
  }
});

// ../../node_modules/graphql/utilities/getOperationAST.mjs
var require_getOperationAST = __commonJS((exports) => {
  __export(exports, {
    getOperationAST: () => getOperationAST
  });
  function getOperationAST(documentAST, operationName) {
    var operation = null;
    for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
      var definition = _documentAST$definiti2[_i2];
      if (definition.kind === Kind.OPERATION_DEFINITION) {
        var _definition$name;
        if (operationName == null) {
          if (operation) {
            return null;
          }
          operation = definition;
        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
          return definition;
        }
      }
    }
    return operation;
  }
});

// ../../node_modules/graphql-tag/src/index.js
var require_src = __commonJS((exports, module) => {
  var parser = require_parser();
  var parse4 = parser.parse;
  function normalize2(string5) {
    return string5.replace(/[\s,]+/g, " ").trim();
  }
  var docCache = {};
  var fragmentSourceMap = {};
  function cacheKeyFromLoc(loc) {
    return normalize2(loc.source.body.substring(loc.start, loc.end));
  }
  function resetCaches() {
    docCache = {};
    fragmentSourceMap = {};
  }
  var printFragmentWarnings = true;
  function processFragments(ast) {
    var astFragmentMap = {};
    var definitions = [];
    for (var i = 0; i < ast.definitions.length; i++) {
      var fragmentDefinition = ast.definitions[i];
      if (fragmentDefinition.kind === "FragmentDefinition") {
        var fragmentName = fragmentDefinition.name.value;
        var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
        if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {
          if (printFragmentWarnings) {
            console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
          }
          fragmentSourceMap[fragmentName][sourceKey] = true;
        } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {
          fragmentSourceMap[fragmentName] = {};
          fragmentSourceMap[fragmentName][sourceKey] = true;
        }
        if (!astFragmentMap[sourceKey]) {
          astFragmentMap[sourceKey] = true;
          definitions.push(fragmentDefinition);
        }
      } else {
        definitions.push(fragmentDefinition);
      }
    }
    ast.definitions = definitions;
    return ast;
  }
  function disableFragmentWarnings() {
    printFragmentWarnings = false;
  }
  function stripLoc(doc, removeLocAtThisLevel) {
    var docType = Object.prototype.toString.call(doc);
    if (docType === "[object Array]") {
      return doc.map(function(d) {
        return stripLoc(d, removeLocAtThisLevel);
      });
    }
    if (docType !== "[object Object]") {
      throw new Error("Unexpected input.");
    }
    if (removeLocAtThisLevel && doc.loc) {
      delete doc.loc;
    }
    if (doc.loc) {
      delete doc.loc.startToken;
      delete doc.loc.endToken;
    }
    var keys = Object.keys(doc);
    var key;
    var value;
    var valueType;
    for (key in keys) {
      if (keys.hasOwnProperty(key)) {
        value = doc[keys[key]];
        valueType = Object.prototype.toString.call(value);
        if (valueType === "[object Object]" || valueType === "[object Array]") {
          doc[keys[key]] = stripLoc(value, true);
        }
      }
    }
    return doc;
  }
  var experimentalFragmentVariables = false;
  function parseDocument(doc) {
    var cacheKey = normalize2(doc);
    if (docCache[cacheKey]) {
      return docCache[cacheKey];
    }
    var parsed = parse4(doc, {experimentalFragmentVariables});
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    parsed = processFragments(parsed);
    parsed = stripLoc(parsed, false);
    docCache[cacheKey] = parsed;
    return parsed;
  }
  function enableExperimentalFragmentVariables() {
    experimentalFragmentVariables = true;
  }
  function disableExperimentalFragmentVariables() {
    experimentalFragmentVariables = false;
  }
  function gql2() {
    var args = Array.prototype.slice.call(arguments);
    var literals = args[0];
    var result = typeof literals === "string" ? literals : literals[0];
    for (var i = 1; i < args.length; i++) {
      if (args[i] && args[i].kind && args[i].kind === "Document") {
        result += args[i].loc.source.body;
      } else {
        result += args[i];
      }
      result += literals[i];
    }
    return parseDocument(result);
  }
  gql2.default = gql2;
  gql2.resetCaches = resetCaches;
  gql2.disableFragmentWarnings = disableFragmentWarnings;
  gql2.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
  gql2.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;
  module.exports = gql2;
});

// ../../node_modules/subscriptions-transport-ws/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports, module) => {
  "use strict";
  var has = Object.prototype.hasOwnProperty;
  var prefix2 = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix2 = false;
  }
  function EE(fn, context2, once3) {
    this.fn = fn;
    this.context = context2;
    this.once = once3 || false;
  }
  function addListener(emitter, event, fn, context2, once3) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context2 || emitter, once3), evt = prefix2 ? prefix2 + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix2 ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context2) {
    return addListener(this, event, fn, context2, false);
  };
  EventEmitter.prototype.once = function once3(event, fn, context2) {
    return addListener(this, event, fn, context2, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context2, once3) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once3 || listeners.once) && (!context2 || listeners.context === context2)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once3 && !listeners[i].once || context2 && listeners[i].context !== context2) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix2 ? prefix2 + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix2;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter;
  }
});

// ../../node_modules/subscriptions-transport-ws/dist/utils/is-string.js
var require_is_string = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  function isString2(value) {
    return typeof value === "string";
  }
  exports.default = isString2;
});

// ../../node_modules/subscriptions-transport-ws/dist/utils/is-object.js
var require_is_object = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  function isObject3(value) {
    return value !== null && typeof value === "object";
  }
  exports.default = isObject3;
});

// ../../node_modules/subscriptions-transport-ws/dist/protocol.js
var require_protocol = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.GRAPHQL_SUBSCRIPTIONS = exports.GRAPHQL_WS = void 0;
  var GRAPHQL_WS = "graphql-ws";
  exports.GRAPHQL_WS = GRAPHQL_WS;
  var GRAPHQL_SUBSCRIPTIONS = "graphql-subscriptions";
  exports.GRAPHQL_SUBSCRIPTIONS = GRAPHQL_SUBSCRIPTIONS;
});

// ../../node_modules/subscriptions-transport-ws/dist/defaults.js
var require_defaults2 = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.WS_TIMEOUT = exports.MIN_WS_TIMEOUT = void 0;
  var MIN_WS_TIMEOUT = 1e3;
  exports.MIN_WS_TIMEOUT = MIN_WS_TIMEOUT;
  var WS_TIMEOUT = 3e4;
  exports.WS_TIMEOUT = WS_TIMEOUT;
});

// ../../node_modules/subscriptions-transport-ws/dist/message-types.js
var require_message_types = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  var MessageTypes = function() {
    function MessageTypes2() {
      throw new Error("Static Class");
    }
    MessageTypes2.GQL_CONNECTION_INIT = "connection_init";
    MessageTypes2.GQL_CONNECTION_ACK = "connection_ack";
    MessageTypes2.GQL_CONNECTION_ERROR = "connection_error";
    MessageTypes2.GQL_CONNECTION_KEEP_ALIVE = "ka";
    MessageTypes2.GQL_CONNECTION_TERMINATE = "connection_terminate";
    MessageTypes2.GQL_START = "start";
    MessageTypes2.GQL_DATA = "data";
    MessageTypes2.GQL_ERROR = "error";
    MessageTypes2.GQL_COMPLETE = "complete";
    MessageTypes2.GQL_STOP = "stop";
    MessageTypes2.SUBSCRIPTION_START = "subscription_start";
    MessageTypes2.SUBSCRIPTION_DATA = "subscription_data";
    MessageTypes2.SUBSCRIPTION_SUCCESS = "subscription_success";
    MessageTypes2.SUBSCRIPTION_FAIL = "subscription_fail";
    MessageTypes2.SUBSCRIPTION_END = "subscription_end";
    MessageTypes2.INIT = "init";
    MessageTypes2.INIT_SUCCESS = "init_success";
    MessageTypes2.INIT_FAIL = "init_fail";
    MessageTypes2.KEEP_ALIVE = "keepalive";
    return MessageTypes2;
  }();
  exports.default = MessageTypes;
});

// ../../node_modules/subscriptions-transport-ws/dist/client.js
var require_client = __commonJS((exports) => {
  "use strict";
  var __assign2 = exports && exports.__assign || function() {
    __assign2 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign2.apply(this, arguments);
  };
  var __awaiter37 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator2 = exports && exports.__generator || function(thisArg, body3) {
    var _ = {label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: []}, f, y, t, g;
    return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {value: op[1], done: false};
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body3.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return {value: op[0] ? op[1] : void 0, done: true};
    }
  };
  var __spreadArrays2 = exports && exports.__spreadArrays || function() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++)
      s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r[k] = a[j];
    return r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.SubscriptionClient = void 0;
  var _global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
  var NativeWebSocket = _global.WebSocket || _global.MozWebSocket;
  var Backoff = require_backo2();
  var eventemitter3_1 = require_eventemitter3();
  var is_string_1 = require_is_string();
  var is_object_1 = require_is_object();
  var printer_1 = require_printer();
  var getOperationAST_1 = require_getOperationAST();
  var symbol_observable_1 = require_lib();
  var protocol_1 = require_protocol();
  var defaults_1 = require_defaults2();
  var message_types_1 = require_message_types();
  var SubscriptionClient2 = function() {
    function SubscriptionClient3(url, options, webSocketImpl, webSocketProtocols) {
      var _a5 = options || {}, _b2 = _a5.connectionCallback, connectionCallback = _b2 === void 0 ? void 0 : _b2, _c2 = _a5.connectionParams, connectionParams = _c2 === void 0 ? {} : _c2, _d2 = _a5.minTimeout, minTimeout = _d2 === void 0 ? defaults_1.MIN_WS_TIMEOUT : _d2, _e2 = _a5.timeout, timeout3 = _e2 === void 0 ? defaults_1.WS_TIMEOUT : _e2, _f2 = _a5.reconnect, reconnect = _f2 === void 0 ? false : _f2, _g2 = _a5.reconnectionAttempts, reconnectionAttempts = _g2 === void 0 ? Infinity : _g2, _h2 = _a5.lazy, lazy = _h2 === void 0 ? false : _h2, _j = _a5.inactivityTimeout, inactivityTimeout = _j === void 0 ? 0 : _j, _k = _a5.wsOptionArguments, wsOptionArguments = _k === void 0 ? [] : _k;
      this.wsImpl = webSocketImpl || NativeWebSocket;
      if (!this.wsImpl) {
        throw new Error("Unable to find native implementation, or alternative implementation for WebSocket!");
      }
      this.wsProtocols = webSocketProtocols || protocol_1.GRAPHQL_WS;
      this.connectionCallback = connectionCallback;
      this.url = url;
      this.operations = {};
      this.nextOperationId = 0;
      this.minWsTimeout = minTimeout;
      this.wsTimeout = timeout3;
      this.unsentMessagesQueue = [];
      this.reconnect = reconnect;
      this.reconnecting = false;
      this.reconnectionAttempts = reconnectionAttempts;
      this.lazy = !!lazy;
      this.inactivityTimeout = inactivityTimeout;
      this.closedByUser = false;
      this.backoff = new Backoff({jitter: 0.5});
      this.eventEmitter = new eventemitter3_1.EventEmitter();
      this.middlewares = [];
      this.client = null;
      this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();
      this.connectionParams = this.getConnectionParams(connectionParams);
      this.wsOptionArguments = wsOptionArguments;
      if (!this.lazy) {
        this.connect();
      }
    }
    Object.defineProperty(SubscriptionClient3.prototype, "status", {
      get: function() {
        if (this.client === null) {
          return this.wsImpl.CLOSED;
        }
        return this.client.readyState;
      },
      enumerable: false,
      configurable: true
    });
    SubscriptionClient3.prototype.close = function(isForced, closedByUser) {
      if (isForced === void 0) {
        isForced = true;
      }
      if (closedByUser === void 0) {
        closedByUser = true;
      }
      this.clearInactivityTimeout();
      if (this.client !== null) {
        this.closedByUser = closedByUser;
        if (isForced) {
          this.clearCheckConnectionInterval();
          this.clearMaxConnectTimeout();
          this.clearTryReconnectTimeout();
          this.unsubscribeAll();
          this.sendMessage(void 0, message_types_1.default.GQL_CONNECTION_TERMINATE, null);
        }
        this.client.close();
        this.client.onopen = null;
        this.client.onclose = null;
        this.client.onerror = null;
        this.client.onmessage = null;
        this.client = null;
        this.eventEmitter.emit("disconnected");
        if (!isForced) {
          this.tryReconnect();
        }
      }
    };
    SubscriptionClient3.prototype.request = function(request) {
      var _a5;
      var getObserver = this.getObserver.bind(this);
      var executeOperation = this.executeOperation.bind(this);
      var unsubscribe5 = this.unsubscribe.bind(this);
      var opId;
      this.clearInactivityTimeout();
      return _a5 = {}, _a5[symbol_observable_1.default] = function() {
        return this;
      }, _a5.subscribe = function(observerOrNext, onError2, onComplete) {
        var observer = getObserver(observerOrNext, onError2, onComplete);
        opId = executeOperation(request, function(error, result) {
          if (error === null && result === null) {
            if (observer.complete) {
              observer.complete();
            }
          } else if (error) {
            if (observer.error) {
              observer.error(error[0]);
            }
          } else {
            if (observer.next) {
              observer.next(result);
            }
          }
        });
        return {
          unsubscribe: function() {
            if (opId) {
              unsubscribe5(opId);
              opId = null;
            }
          }
        };
      }, _a5;
    };
    SubscriptionClient3.prototype.on = function(eventName, callback, context2) {
      var handler = this.eventEmitter.on(eventName, callback, context2);
      return function() {
        handler.off(eventName, callback, context2);
      };
    };
    SubscriptionClient3.prototype.onConnected = function(callback, context2) {
      return this.on("connected", callback, context2);
    };
    SubscriptionClient3.prototype.onConnecting = function(callback, context2) {
      return this.on("connecting", callback, context2);
    };
    SubscriptionClient3.prototype.onDisconnected = function(callback, context2) {
      return this.on("disconnected", callback, context2);
    };
    SubscriptionClient3.prototype.onReconnected = function(callback, context2) {
      return this.on("reconnected", callback, context2);
    };
    SubscriptionClient3.prototype.onReconnecting = function(callback, context2) {
      return this.on("reconnecting", callback, context2);
    };
    SubscriptionClient3.prototype.onError = function(callback, context2) {
      return this.on("error", callback, context2);
    };
    SubscriptionClient3.prototype.unsubscribeAll = function() {
      var _this = this;
      Object.keys(this.operations).forEach(function(subId) {
        _this.unsubscribe(subId);
      });
    };
    SubscriptionClient3.prototype.applyMiddlewares = function(options) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var queue2 = function(funcs, scope) {
          var next = function(error) {
            if (error) {
              reject(error);
            } else {
              if (funcs.length > 0) {
                var f = funcs.shift();
                if (f) {
                  f.applyMiddleware.apply(scope, [options, next]);
                }
              } else {
                resolve(options);
              }
            }
          };
          next();
        };
        queue2(__spreadArrays2(_this.middlewares), _this);
      });
    };
    SubscriptionClient3.prototype.use = function(middlewares) {
      var _this = this;
      middlewares.map(function(middleware) {
        if (typeof middleware.applyMiddleware === "function") {
          _this.middlewares.push(middleware);
        } else {
          throw new Error("Middleware must implement the applyMiddleware function.");
        }
      });
      return this;
    };
    SubscriptionClient3.prototype.getConnectionParams = function(connectionParams) {
      return function() {
        return new Promise(function(resolve, reject) {
          if (typeof connectionParams === "function") {
            try {
              return resolve(connectionParams.call(null));
            } catch (error) {
              return reject(error);
            }
          }
          resolve(connectionParams);
        });
      };
    };
    SubscriptionClient3.prototype.executeOperation = function(options, handler) {
      var _this = this;
      if (this.client === null) {
        this.connect();
      }
      var opId = this.generateOperationId();
      this.operations[opId] = {options, handler};
      this.applyMiddlewares(options).then(function(processedOptions) {
        _this.checkOperationOptions(processedOptions, handler);
        if (_this.operations[opId]) {
          _this.operations[opId] = {options: processedOptions, handler};
          _this.sendMessage(opId, message_types_1.default.GQL_START, processedOptions);
        }
      }).catch(function(error) {
        _this.unsubscribe(opId);
        handler(_this.formatErrors(error));
      });
      return opId;
    };
    SubscriptionClient3.prototype.getObserver = function(observerOrNext, error, complete) {
      if (typeof observerOrNext === "function") {
        return {
          next: function(v) {
            return observerOrNext(v);
          },
          error: function(e) {
            return error && error(e);
          },
          complete: function() {
            return complete && complete();
          }
        };
      }
      return observerOrNext;
    };
    SubscriptionClient3.prototype.createMaxConnectTimeGenerator = function() {
      var minValue = this.minWsTimeout;
      var maxValue = this.wsTimeout;
      return new Backoff({
        min: minValue,
        max: maxValue,
        factor: 1.2
      });
    };
    SubscriptionClient3.prototype.clearCheckConnectionInterval = function() {
      if (this.checkConnectionIntervalId) {
        clearInterval(this.checkConnectionIntervalId);
        this.checkConnectionIntervalId = null;
      }
    };
    SubscriptionClient3.prototype.clearMaxConnectTimeout = function() {
      if (this.maxConnectTimeoutId) {
        clearTimeout(this.maxConnectTimeoutId);
        this.maxConnectTimeoutId = null;
      }
    };
    SubscriptionClient3.prototype.clearTryReconnectTimeout = function() {
      if (this.tryReconnectTimeoutId) {
        clearTimeout(this.tryReconnectTimeoutId);
        this.tryReconnectTimeoutId = null;
      }
    };
    SubscriptionClient3.prototype.clearInactivityTimeout = function() {
      if (this.inactivityTimeoutId) {
        clearTimeout(this.inactivityTimeoutId);
        this.inactivityTimeoutId = null;
      }
    };
    SubscriptionClient3.prototype.setInactivityTimeout = function() {
      var _this = this;
      if (this.inactivityTimeout > 0 && Object.keys(this.operations).length === 0) {
        this.inactivityTimeoutId = setTimeout(function() {
          if (Object.keys(_this.operations).length === 0) {
            _this.close();
          }
        }, this.inactivityTimeout);
      }
    };
    SubscriptionClient3.prototype.checkOperationOptions = function(options, handler) {
      var query = options.query, variables = options.variables, operationName = options.operationName;
      if (!query) {
        throw new Error("Must provide a query.");
      }
      if (!handler) {
        throw new Error("Must provide an handler.");
      }
      if (!is_string_1.default(query) && !getOperationAST_1.getOperationAST(query, operationName) || operationName && !is_string_1.default(operationName) || variables && !is_object_1.default(variables)) {
        throw new Error("Incorrect option types. query must be a string or a document,`operationName` must be a string, and `variables` must be an object.");
      }
    };
    SubscriptionClient3.prototype.buildMessage = function(id, type, payload) {
      var payloadToReturn = payload && payload.query ? __assign2(__assign2({}, payload), {query: typeof payload.query === "string" ? payload.query : printer_1.print(payload.query)}) : payload;
      return {
        id,
        type,
        payload: payloadToReturn
      };
    };
    SubscriptionClient3.prototype.formatErrors = function(errors) {
      if (Array.isArray(errors)) {
        return errors;
      }
      if (errors && errors.errors) {
        return this.formatErrors(errors.errors);
      }
      if (errors && errors.message) {
        return [errors];
      }
      return [{
        name: "FormatedError",
        message: "Unknown error",
        originalError: errors
      }];
    };
    SubscriptionClient3.prototype.sendMessage = function(id, type, payload) {
      this.sendMessageRaw(this.buildMessage(id, type, payload));
    };
    SubscriptionClient3.prototype.sendMessageRaw = function(message) {
      switch (this.status) {
        case this.wsImpl.OPEN:
          var serializedMessage = JSON.stringify(message);
          try {
            JSON.parse(serializedMessage);
          } catch (e) {
            this.eventEmitter.emit("error", new Error("Message must be JSON-serializable. Got: " + message));
          }
          this.client.send(serializedMessage);
          break;
        case this.wsImpl.CONNECTING:
          this.unsentMessagesQueue.push(message);
          break;
        default:
          if (!this.reconnecting) {
            this.eventEmitter.emit("error", new Error("A message was not sent because socket is not connected, is closing or is already closed. Message was: " + JSON.stringify(message)));
          }
      }
    };
    SubscriptionClient3.prototype.generateOperationId = function() {
      return String(++this.nextOperationId);
    };
    SubscriptionClient3.prototype.tryReconnect = function() {
      var _this = this;
      if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {
        return;
      }
      if (!this.reconnecting) {
        Object.keys(this.operations).forEach(function(key) {
          _this.unsentMessagesQueue.push(_this.buildMessage(key, message_types_1.default.GQL_START, _this.operations[key].options));
        });
        this.reconnecting = true;
      }
      this.clearTryReconnectTimeout();
      var delay2 = this.backoff.duration();
      this.tryReconnectTimeoutId = setTimeout(function() {
        _this.connect();
      }, delay2);
    };
    SubscriptionClient3.prototype.flushUnsentMessagesQueue = function() {
      var _this = this;
      this.unsentMessagesQueue.forEach(function(message) {
        _this.sendMessageRaw(message);
      });
      this.unsentMessagesQueue = [];
    };
    SubscriptionClient3.prototype.checkConnection = function() {
      if (this.wasKeepAliveReceived) {
        this.wasKeepAliveReceived = false;
        return;
      }
      if (!this.reconnecting) {
        this.close(false, true);
      }
    };
    SubscriptionClient3.prototype.checkMaxConnectTimeout = function() {
      var _this = this;
      this.clearMaxConnectTimeout();
      this.maxConnectTimeoutId = setTimeout(function() {
        if (_this.status !== _this.wsImpl.OPEN) {
          _this.reconnecting = true;
          _this.close(false, true);
        }
      }, this.maxConnectTimeGenerator.duration());
    };
    SubscriptionClient3.prototype.connect = function() {
      var _a5;
      var _this = this;
      this.client = new ((_a5 = this.wsImpl).bind.apply(_a5, __spreadArrays2([void 0, this.url, this.wsProtocols], this.wsOptionArguments)))();
      this.checkMaxConnectTimeout();
      this.client.onopen = function() {
        return __awaiter37(_this, void 0, void 0, function() {
          var connectionParams, error_1;
          return __generator2(this, function(_a6) {
            switch (_a6.label) {
              case 0:
                if (!(this.status === this.wsImpl.OPEN))
                  return [3, 4];
                this.clearMaxConnectTimeout();
                this.closedByUser = false;
                this.eventEmitter.emit(this.reconnecting ? "reconnecting" : "connecting");
                _a6.label = 1;
              case 1:
                _a6.trys.push([1, 3, , 4]);
                return [4, this.connectionParams()];
              case 2:
                connectionParams = _a6.sent();
                this.sendMessage(void 0, message_types_1.default.GQL_CONNECTION_INIT, connectionParams);
                this.flushUnsentMessagesQueue();
                return [3, 4];
              case 3:
                error_1 = _a6.sent();
                this.sendMessage(void 0, message_types_1.default.GQL_CONNECTION_ERROR, error_1);
                this.flushUnsentMessagesQueue();
                return [3, 4];
              case 4:
                return [2];
            }
          });
        });
      };
      this.client.onclose = function() {
        if (!_this.closedByUser) {
          _this.close(false, false);
        }
      };
      this.client.onerror = function(err) {
        _this.eventEmitter.emit("error", err);
      };
      this.client.onmessage = function(_a6) {
        var data = _a6.data;
        _this.processReceivedData(data);
      };
    };
    SubscriptionClient3.prototype.processReceivedData = function(receivedData) {
      var parsedMessage;
      var opId;
      try {
        parsedMessage = JSON.parse(receivedData);
        opId = parsedMessage.id;
      } catch (e) {
        throw new Error("Message must be JSON-parseable. Got: " + receivedData);
      }
      if ([
        message_types_1.default.GQL_DATA,
        message_types_1.default.GQL_COMPLETE,
        message_types_1.default.GQL_ERROR
      ].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]) {
        this.unsubscribe(opId);
        return;
      }
      switch (parsedMessage.type) {
        case message_types_1.default.GQL_CONNECTION_ERROR:
          if (this.connectionCallback) {
            this.connectionCallback(parsedMessage.payload);
          }
          break;
        case message_types_1.default.GQL_CONNECTION_ACK:
          this.eventEmitter.emit(this.reconnecting ? "reconnected" : "connected", parsedMessage.payload);
          this.reconnecting = false;
          this.backoff.reset();
          this.maxConnectTimeGenerator.reset();
          if (this.connectionCallback) {
            this.connectionCallback();
          }
          break;
        case message_types_1.default.GQL_COMPLETE:
          var handler = this.operations[opId].handler;
          delete this.operations[opId];
          handler.call(this, null, null);
          break;
        case message_types_1.default.GQL_ERROR:
          this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);
          delete this.operations[opId];
          break;
        case message_types_1.default.GQL_DATA:
          var parsedPayload = !parsedMessage.payload.errors ? parsedMessage.payload : __assign2(__assign2({}, parsedMessage.payload), {errors: this.formatErrors(parsedMessage.payload.errors)});
          this.operations[opId].handler(null, parsedPayload);
          break;
        case message_types_1.default.GQL_CONNECTION_KEEP_ALIVE:
          var firstKA = typeof this.wasKeepAliveReceived === "undefined";
          this.wasKeepAliveReceived = true;
          if (firstKA) {
            this.checkConnection();
          }
          if (this.checkConnectionIntervalId) {
            clearInterval(this.checkConnectionIntervalId);
            this.checkConnection();
          }
          this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);
          break;
        default:
          throw new Error("Invalid message type!");
      }
    };
    SubscriptionClient3.prototype.unsubscribe = function(opId) {
      if (this.operations[opId]) {
        delete this.operations[opId];
        this.setInactivityTimeout();
        this.sendMessage(opId, message_types_1.default.GQL_STOP, void 0);
      }
    };
    return SubscriptionClient3;
  }();
  exports.SubscriptionClient = SubscriptionClient2;
});

// ../../node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS((exports, module) => {
  "use strict";
  module.exports = function(data, opts) {
    if (!opts)
      opts = {};
    if (typeof opts === "function")
      opts = {cmp: opts};
    var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
    var cmp = opts.cmp && function(f) {
      return function(node) {
        return function(a, b) {
          var aobj = {key: a, value: node[a]};
          var bobj = {key: b, value: node[b]};
          return f(aobj, bobj);
        };
      };
    }(opts.cmp);
    var seen = [];
    return function stringify2(node) {
      if (node && node.toJSON && typeof node.toJSON === "function") {
        node = node.toJSON();
      }
      if (node === void 0)
        return;
      if (typeof node == "number")
        return isFinite(node) ? "" + node : "null";
      if (typeof node !== "object")
        return JSON.stringify(node);
      var i, out;
      if (Array.isArray(node)) {
        out = "[";
        for (i = 0; i < node.length; i++) {
          if (i)
            out += ",";
          out += stringify2(node[i]) || "null";
        }
        return out + "]";
      }
      if (node === null)
        return "null";
      if (seen.indexOf(node) !== -1) {
        if (cycles)
          return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var seenIndex = seen.push(node) - 1;
      var keys = Object.keys(node).sort(cmp && cmp(node));
      out = "";
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = stringify2(node[key]);
        if (!value)
          continue;
        if (out)
          out += ",";
        out += JSON.stringify(key) + ":" + value;
      }
      seen.splice(seenIndex, 1);
      return "{" + out + "}";
    }(data);
  };
});

// ../../node_modules/zen-observable/lib/Observable.js
var require_Observable = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Observable = void 0;
  function _classCallCheck3(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties3(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass4(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties3(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties3(Constructor, staticProps);
    return Constructor;
  }
  var hasSymbols = function() {
    return typeof Symbol === "function";
  };
  var hasSymbol2 = function(name) {
    return hasSymbols() && Boolean(Symbol[name]);
  };
  var getSymbol = function(name) {
    return hasSymbol2(name) ? Symbol[name] : "@@" + name;
  };
  if (hasSymbols() && !hasSymbol2("observable")) {
    Symbol.observable = Symbol("observable");
  }
  var SymbolIterator = getSymbol("iterator");
  var SymbolObservable = getSymbol("observable");
  var SymbolSpecies = getSymbol("species");
  function getMethod(obj, key) {
    var value = obj[key];
    if (value == null)
      return void 0;
    if (typeof value !== "function")
      throw new TypeError(value + " is not a function");
    return value;
  }
  function getSpecies(obj) {
    var ctor = obj.constructor;
    if (ctor !== void 0) {
      ctor = ctor[SymbolSpecies];
      if (ctor === null) {
        ctor = void 0;
      }
    }
    return ctor !== void 0 ? ctor : Observable2;
  }
  function isObservable(x) {
    return x instanceof Observable2;
  }
  function hostReportError(e) {
    if (hostReportError.log) {
      hostReportError.log(e);
    } else {
      setTimeout(function() {
        throw e;
      });
    }
  }
  function enqueue(fn) {
    Promise.resolve().then(function() {
      try {
        fn();
      } catch (e) {
        hostReportError(e);
      }
    });
  }
  function cleanupSubscription(subscription) {
    var cleanup = subscription._cleanup;
    if (cleanup === void 0)
      return;
    subscription._cleanup = void 0;
    if (!cleanup) {
      return;
    }
    try {
      if (typeof cleanup === "function") {
        cleanup();
      } else {
        var unsubscribe5 = getMethod(cleanup, "unsubscribe");
        if (unsubscribe5) {
          unsubscribe5.call(cleanup);
        }
      }
    } catch (e) {
      hostReportError(e);
    }
  }
  function closeSubscription(subscription) {
    subscription._observer = void 0;
    subscription._queue = void 0;
    subscription._state = "closed";
  }
  function flushSubscription(subscription) {
    var queue2 = subscription._queue;
    if (!queue2) {
      return;
    }
    subscription._queue = void 0;
    subscription._state = "ready";
    for (var i = 0; i < queue2.length; ++i) {
      notifySubscription(subscription, queue2[i].type, queue2[i].value);
      if (subscription._state === "closed")
        break;
    }
  }
  function notifySubscription(subscription, type, value) {
    subscription._state = "running";
    var observer = subscription._observer;
    try {
      var m = getMethod(observer, type);
      switch (type) {
        case "next":
          if (m)
            m.call(observer, value);
          break;
        case "error":
          closeSubscription(subscription);
          if (m)
            m.call(observer, value);
          else
            throw value;
          break;
        case "complete":
          closeSubscription(subscription);
          if (m)
            m.call(observer);
          break;
      }
    } catch (e) {
      hostReportError(e);
    }
    if (subscription._state === "closed")
      cleanupSubscription(subscription);
    else if (subscription._state === "running")
      subscription._state = "ready";
  }
  function onNotify(subscription, type, value) {
    if (subscription._state === "closed")
      return;
    if (subscription._state === "buffering") {
      subscription._queue.push({
        type,
        value
      });
      return;
    }
    if (subscription._state !== "ready") {
      subscription._state = "buffering";
      subscription._queue = [{
        type,
        value
      }];
      enqueue(function() {
        return flushSubscription(subscription);
      });
      return;
    }
    notifySubscription(subscription, type, value);
  }
  var Subscription2 = /* @__PURE__ */ function() {
    function Subscription3(observer, subscriber) {
      _classCallCheck3(this, Subscription3);
      this._cleanup = void 0;
      this._observer = observer;
      this._queue = void 0;
      this._state = "initializing";
      var subscriptionObserver = new SubscriptionObserver(this);
      try {
        this._cleanup = subscriber.call(void 0, subscriptionObserver);
      } catch (e) {
        subscriptionObserver.error(e);
      }
      if (this._state === "initializing")
        this._state = "ready";
    }
    _createClass4(Subscription3, [{
      key: "unsubscribe",
      value: function unsubscribe5() {
        if (this._state !== "closed") {
          closeSubscription(this);
          cleanupSubscription(this);
        }
      }
    }, {
      key: "closed",
      get: function() {
        return this._state === "closed";
      }
    }]);
    return Subscription3;
  }();
  var SubscriptionObserver = /* @__PURE__ */ function() {
    function SubscriptionObserver2(subscription) {
      _classCallCheck3(this, SubscriptionObserver2);
      this._subscription = subscription;
    }
    _createClass4(SubscriptionObserver2, [{
      key: "next",
      value: function next(value) {
        onNotify(this._subscription, "next", value);
      }
    }, {
      key: "error",
      value: function error(value) {
        onNotify(this._subscription, "error", value);
      }
    }, {
      key: "complete",
      value: function complete() {
        onNotify(this._subscription, "complete");
      }
    }, {
      key: "closed",
      get: function() {
        return this._subscription._state === "closed";
      }
    }]);
    return SubscriptionObserver2;
  }();
  var Observable2 = /* @__PURE__ */ function() {
    function Observable3(subscriber) {
      _classCallCheck3(this, Observable3);
      if (!(this instanceof Observable3))
        throw new TypeError("Observable cannot be called as a function");
      if (typeof subscriber !== "function")
        throw new TypeError("Observable initializer must be a function");
      this._subscriber = subscriber;
    }
    _createClass4(Observable3, [{
      key: "subscribe",
      value: function subscribe5(observer) {
        if (typeof observer !== "object" || observer === null) {
          observer = {
            next: observer,
            error: arguments[1],
            complete: arguments[2]
          };
        }
        return new Subscription2(observer, this._subscriber);
      }
    }, {
      key: "forEach",
      value: function forEach2(fn) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          if (typeof fn !== "function") {
            reject(new TypeError(fn + " is not a function"));
            return;
          }
          function done3() {
            subscription.unsubscribe();
            resolve();
          }
          var subscription = _this.subscribe({
            next: function(value) {
              try {
                fn(value, done3);
              } catch (e) {
                reject(e);
                subscription.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
        });
      }
    }, {
      key: "map",
      value: function map(fn) {
        var _this2 = this;
        if (typeof fn !== "function")
          throw new TypeError(fn + " is not a function");
        var C2 = getSpecies(this);
        return new C2(function(observer) {
          return _this2.subscribe({
            next: function(value) {
              try {
                value = fn(value);
              } catch (e) {
                return observer.error(e);
              }
              observer.next(value);
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              observer.complete();
            }
          });
        });
      }
    }, {
      key: "filter",
      value: function filter2(fn) {
        var _this3 = this;
        if (typeof fn !== "function")
          throw new TypeError(fn + " is not a function");
        var C2 = getSpecies(this);
        return new C2(function(observer) {
          return _this3.subscribe({
            next: function(value) {
              try {
                if (!fn(value))
                  return;
              } catch (e) {
                return observer.error(e);
              }
              observer.next(value);
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              observer.complete();
            }
          });
        });
      }
    }, {
      key: "reduce",
      value: function reduce(fn) {
        var _this4 = this;
        if (typeof fn !== "function")
          throw new TypeError(fn + " is not a function");
        var C2 = getSpecies(this);
        var hasSeed = arguments.length > 1;
        var hasValue2 = false;
        var seed = arguments[1];
        var acc = seed;
        return new C2(function(observer) {
          return _this4.subscribe({
            next: function(value) {
              var first2 = !hasValue2;
              hasValue2 = true;
              if (!first2 || hasSeed) {
                try {
                  acc = fn(acc, value);
                } catch (e) {
                  return observer.error(e);
                }
              } else {
                acc = value;
              }
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              if (!hasValue2 && !hasSeed)
                return observer.error(new TypeError("Cannot reduce an empty sequence"));
              observer.next(acc);
              observer.complete();
            }
          });
        });
      }
    }, {
      key: "concat",
      value: function concat2() {
        var _this5 = this;
        for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
          sources[_key] = arguments[_key];
        }
        var C2 = getSpecies(this);
        return new C2(function(observer) {
          var subscription;
          var index2 = 0;
          function startNext(next) {
            subscription = next.subscribe({
              next: function(v) {
                observer.next(v);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                if (index2 === sources.length) {
                  subscription = void 0;
                  observer.complete();
                } else {
                  startNext(C2.from(sources[index2++]));
                }
              }
            });
          }
          startNext(_this5);
          return function() {
            if (subscription) {
              subscription.unsubscribe();
              subscription = void 0;
            }
          };
        });
      }
    }, {
      key: "flatMap",
      value: function flatMap3(fn) {
        var _this6 = this;
        if (typeof fn !== "function")
          throw new TypeError(fn + " is not a function");
        var C2 = getSpecies(this);
        return new C2(function(observer) {
          var subscriptions = [];
          var outer = _this6.subscribe({
            next: function(value) {
              if (fn) {
                try {
                  value = fn(value);
                } catch (e) {
                  return observer.error(e);
                }
              }
              var inner = C2.from(value).subscribe({
                next: function(value2) {
                  observer.next(value2);
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  var i = subscriptions.indexOf(inner);
                  if (i >= 0)
                    subscriptions.splice(i, 1);
                  completeIfDone();
                }
              });
              subscriptions.push(inner);
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              completeIfDone();
            }
          });
          function completeIfDone() {
            if (outer.closed && subscriptions.length === 0)
              observer.complete();
          }
          return function() {
            subscriptions.forEach(function(s) {
              return s.unsubscribe();
            });
            outer.unsubscribe();
          };
        });
      }
    }, {
      key: SymbolObservable,
      value: function() {
        return this;
      }
    }], [{
      key: "from",
      value: function from2(x) {
        var C2 = typeof this === "function" ? this : Observable3;
        if (x == null)
          throw new TypeError(x + " is not an object");
        var method = getMethod(x, SymbolObservable);
        if (method) {
          var observable = method.call(x);
          if (Object(observable) !== observable)
            throw new TypeError(observable + " is not an object");
          if (isObservable(observable) && observable.constructor === C2)
            return observable;
          return new C2(function(observer) {
            return observable.subscribe(observer);
          });
        }
        if (hasSymbol2("iterator")) {
          method = getMethod(x, SymbolIterator);
          if (method) {
            return new C2(function(observer) {
              enqueue(function() {
                if (observer.closed)
                  return;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = void 0;
                try {
                  for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _item = _step.value;
                    observer.next(_item);
                    if (observer.closed)
                      return;
                  }
                } catch (err) {
                  _didIteratorError = true;
                  _iteratorError = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                      _iterator.return();
                    }
                  } finally {
                    if (_didIteratorError) {
                      throw _iteratorError;
                    }
                  }
                }
                observer.complete();
              });
            });
          }
        }
        if (Array.isArray(x)) {
          return new C2(function(observer) {
            enqueue(function() {
              if (observer.closed)
                return;
              for (var i = 0; i < x.length; ++i) {
                observer.next(x[i]);
                if (observer.closed)
                  return;
              }
              observer.complete();
            });
          });
        }
        throw new TypeError(x + " is not observable");
      }
    }, {
      key: "of",
      value: function of() {
        for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          items[_key2] = arguments[_key2];
        }
        var C2 = typeof this === "function" ? this : Observable3;
        return new C2(function(observer) {
          enqueue(function() {
            if (observer.closed)
              return;
            for (var i = 0; i < items.length; ++i) {
              observer.next(items[i]);
              if (observer.closed)
                return;
            }
            observer.complete();
          });
        });
      }
    }, {
      key: SymbolSpecies,
      get: function() {
        return this;
      }
    }]);
    return Observable3;
  }();
  exports.Observable = Observable2;
  if (hasSymbols()) {
    Object.defineProperty(Observable2, Symbol("extensions"), {
      value: {
        symbol: SymbolObservable,
        hostReportError
      },
      configurable: true
    });
  }
});

// ../../node_modules/zen-observable/index.js
var require_zen_observable = __commonJS((exports, module) => {
  module.exports = require_Observable().Observable;
});

// ../../node_modules/@apollo/client/node_modules/symbol-observable/es/index.js
var require_es = __commonJS((exports, module) => {
  __export(exports, {
    default: () => es_default
  });
  var root;
  if (typeof self !== "undefined") {
    root = self;
  } else if (typeof window !== "undefined") {
    root = window;
  } else if (typeof self !== "undefined") {
    root = self;
  } else if (typeof module !== "undefined") {
    root = module;
  } else {
    root = Function("return this")();
  }
  var result = symbolObservablePonyfill(root);
  var es_default = result;
});

// src/sdk/_runtime.tsx
import React72, {useEffect as useEffect19, useState as useState7, useMemo as useMemo8} from "https://cdn.skypack.dev/react";
import ReactDOM6 from "https://cdn.skypack.dev/react-dom";

// ../../node_modules/react-router/esm/react-router.js
var import_prop_types2 = __toModule(require_prop_types());
import React3 from "https://cdn.skypack.dev/react";

// ../../node_modules/resolve-pathname/esm/resolve-pathname.js
function isAbsolute(pathname) {
  return pathname.charAt(0) === "/";
}
function spliceOne(list, index2) {
  for (var i = index2, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }
  list.pop();
}
function resolvePathname(to, from2) {
  if (from2 === void 0)
    from2 = "";
  var toParts = to && to.split("/") || [];
  var fromParts = from2 && from2.split("/") || [];
  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from2 && isAbsolute(from2);
  var mustEndAbs = isToAbs || isFromAbs;
  if (to && isAbsolute(to)) {
    fromParts = toParts;
  } else if (toParts.length) {
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }
  if (!fromParts.length)
    return "/";
  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === "." || last === ".." || last === "";
  } else {
    hasTrailingSlash = false;
  }
  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];
    if (part === ".") {
      spliceOne(fromParts, i);
    } else if (part === "..") {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }
  if (!mustEndAbs)
    for (; up--; up)
      fromParts.unshift("..");
  if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0])))
    fromParts.unshift("");
  var result = fromParts.join("/");
  if (hasTrailingSlash && result.substr(-1) !== "/")
    result += "/";
  return result;
}
var resolve_pathname_default = resolvePathname;

// ../../node_modules/tiny-invariant/dist/tiny-invariant.esm.js
var isProduction = true;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  throw new Error(prefix + ": " + (message || ""));
}
var tiny_invariant_esm_default = invariant;

// ../../node_modules/history/esm/history.js
function addLeadingSlash(path3) {
  return path3.charAt(0) === "/" ? path3 : "/" + path3;
}
function stripLeadingSlash(path3) {
  return path3.charAt(0) === "/" ? path3.substr(1) : path3;
}
function hasBasename(path3, prefix2) {
  return path3.toLowerCase().indexOf(prefix2.toLowerCase()) === 0 && "/?#".indexOf(path3.charAt(prefix2.length)) !== -1;
}
function stripBasename(path3, prefix2) {
  return hasBasename(path3, prefix2) ? path3.substr(prefix2.length) : path3;
}
function stripTrailingSlash(path3) {
  return path3.charAt(path3.length - 1) === "/" ? path3.slice(0, -1) : path3;
}
function parsePath(path3) {
  var pathname = path3 || "/";
  var search = "";
  var hash2 = "";
  var hashIndex = pathname.indexOf("#");
  if (hashIndex !== -1) {
    hash2 = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }
  var searchIndex = pathname.indexOf("?");
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }
  return {
    pathname,
    search: search === "?" ? "" : search,
    hash: hash2 === "#" ? "" : hash2
  };
}
function createPath(location2) {
  var pathname = location2.pathname, search = location2.search, hash2 = location2.hash;
  var path3 = pathname || "/";
  if (search && search !== "?")
    path3 += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    path3 += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return path3;
}
function createLocation(path3, state, key, currentLocation) {
  var location2;
  if (typeof path3 === "string") {
    location2 = parsePath(path3);
    location2.state = state;
  } else {
    location2 = _extends({}, path3);
    if (location2.pathname === void 0)
      location2.pathname = "";
    if (location2.search) {
      if (location2.search.charAt(0) !== "?")
        location2.search = "?" + location2.search;
    } else {
      location2.search = "";
    }
    if (location2.hash) {
      if (location2.hash.charAt(0) !== "#")
        location2.hash = "#" + location2.hash;
    } else {
      location2.hash = "";
    }
    if (state !== void 0 && location2.state === void 0)
      location2.state = state;
  }
  try {
    location2.pathname = decodeURI(location2.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location2.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }
  if (key)
    location2.key = key;
  if (currentLocation) {
    if (!location2.pathname) {
      location2.pathname = currentLocation.pathname;
    } else if (location2.pathname.charAt(0) !== "/") {
      location2.pathname = resolve_pathname_default(location2.pathname, currentLocation.pathname);
    }
  } else {
    if (!location2.pathname) {
      location2.pathname = "/";
    }
  }
  return location2;
}
function createTransitionManager() {
  var prompt = null;
  function setPrompt(nextPrompt) {
    false ? tiny_warning_esm_default(prompt == null, "A history supports only one prompt at a time") : void 0;
    prompt = nextPrompt;
    return function() {
      if (prompt === nextPrompt)
        prompt = null;
    };
  }
  function confirmTransitionTo(location2, action, getUserConfirmation, callback) {
    if (prompt != null) {
      var result = typeof prompt === "function" ? prompt(location2, action) : prompt;
      if (typeof result === "string") {
        if (typeof getUserConfirmation === "function") {
          getUserConfirmation(result, callback);
        } else {
          false ? tiny_warning_esm_default(false, "A history needs a getUserConfirmation function in order to use a prompt message") : void 0;
          callback(true);
        }
      } else {
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }
  var listeners = [];
  function appendListener(fn) {
    var isActive = true;
    function listener() {
      if (isActive)
        fn.apply(void 0, arguments);
    }
    listeners.push(listener);
    return function() {
      isActive = false;
      listeners = listeners.filter(function(item) {
        return item !== listener;
      });
    };
  }
  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    listeners.forEach(function(listener) {
      return listener.apply(void 0, args);
    });
  }
  return {
    setPrompt,
    confirmTransitionTo,
    appendListener,
    notifyListeners
  };
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message));
}
function supportsHistory() {
  var ua = window.navigator.userAgent;
  if ((ua.indexOf("Android 2.") !== -1 || ua.indexOf("Android 4.0") !== -1) && ua.indexOf("Mobile Safari") !== -1 && ua.indexOf("Chrome") === -1 && ua.indexOf("Windows Phone") === -1)
    return false;
  return window.history && "pushState" in window.history;
}
function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf("Trident") === -1;
}
function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf("Firefox") === -1;
}
function isExtraneousPopstateEvent(event) {
  return event.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1;
}
var PopStateEvent = "popstate";
var HashChangeEvent = "hashchange";
function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    return {};
  }
}
function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? false ? tiny_invariant_esm_default(false, "Browser history needs a DOM") : tiny_invariant_esm_default(false) : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props, _props$forceRefresh = _props.forceRefresh, forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename3 = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
  function getDOMLocation(historyState) {
    var _ref2 = historyState || {}, key = _ref2.key, state = _ref2.state;
    var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash2 = _window$location.hash;
    var path3 = pathname + search + hash2;
    false ? tiny_warning_esm_default(!basename3 || hasBasename(path3, basename3), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + path3 + '" to begin with "' + basename3 + '".') : void 0;
    if (basename3)
      path3 = stripBasename(path3, basename3);
    return createLocation(path3, state, key);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function handlePopState(event) {
    if (isExtraneousPopstateEvent(event))
      return;
    handlePop(getDOMLocation(event.state));
  }
  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }
  var forceNextPop = false;
  function handlePop(location2) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
        if (ok) {
          setState({
            action,
            location: location2
          });
        } else {
          revertPop(location2);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1)
      toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1)
      fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];
  function createHref(location2) {
    return basename3 + createPath(location2);
  }
  function push(path3, state) {
    false ? tiny_warning_esm_default(!(typeof path3 === "object" && path3.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
    var action = "PUSH";
    var location2 = createLocation(path3, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
      if (!ok)
        return;
      var href = createHref(location2);
      var key = location2.key, state2 = location2.state;
      if (canUseHistory) {
        globalHistory.pushState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location2.key);
          allKeys = nextKeys;
          setState({
            action,
            location: location2
          });
        }
      } else {
        false ? tiny_warning_esm_default(state2 === void 0, "Browser history cannot push state in browsers that do not support HTML5 history") : void 0;
        window.location.href = href;
      }
    });
  }
  function replace(path3, state) {
    false ? tiny_warning_esm_default(!(typeof path3 === "object" && path3.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
    var action = "REPLACE";
    var location2 = createLocation(path3, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
      if (!ok)
        return;
      var href = createHref(location2);
      var key = location2.key, state2 = location2.state;
      if (canUseHistory) {
        globalHistory.replaceState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1)
            allKeys[prevIndex] = location2.key;
          setState({
            action,
            location: location2
          });
        }
      } else {
        false ? tiny_warning_esm_default(state2 === void 0, "Browser history cannot replace state in browsers that do not support HTML5 history") : void 0;
        window.location.replace(href);
      }
    });
  }
  function go(n) {
    globalHistory.go(n);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener)
        window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener)
        window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen2(listener) {
    var unlisten2 = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten2();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    block,
    listen: listen2
  };
  return history;
}
var HashChangeEvent$1 = "hashchange";
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path3) {
      return path3.charAt(0) === "!" ? path3 : "!/" + stripLeadingSlash(path3);
    },
    decodePath: function decodePath(path3) {
      return path3.charAt(0) === "!" ? path3.substr(1) : path3;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
};
function stripHash(url) {
  var hashIndex = url.indexOf("#");
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}
function getHashPath() {
  var href = window.location.href;
  var hashIndex = href.indexOf("#");
  return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
}
function pushHashPath(path3) {
  window.location.hash = path3;
}
function replaceHashPath(path3) {
  window.location.replace(stripHash(window.location.href) + "#" + path3);
}
function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? false ? tiny_invariant_esm_default(false, "Hash history needs a DOM") : tiny_invariant_esm_default(false) : void 0;
  var globalHistory = window.history;
  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
  var _props = props, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
  var basename3 = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
  var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath2 = _HashPathCoders$hashT.encodePath, decodePath2 = _HashPathCoders$hashT.decodePath;
  function getDOMLocation() {
    var path4 = decodePath2(getHashPath());
    false ? tiny_warning_esm_default(!basename3 || hasBasename(path4, basename3), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + path4 + '" to begin with "' + basename3 + '".') : void 0;
    if (basename3)
      path4 = stripBasename(path4, basename3);
    return createLocation(path4);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  var forceNextPop = false;
  var ignorePath = null;
  function locationsAreEqual$$1(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
  }
  function handleHashChange() {
    var path4 = getHashPath();
    var encodedPath2 = encodePath2(path4);
    if (path4 !== encodedPath2) {
      replaceHashPath(encodedPath2);
    } else {
      var location2 = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location2))
        return;
      if (ignorePath === createPath(location2))
        return;
      ignorePath = null;
      handlePop(location2);
    }
  }
  function handlePop(location2) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
        if (ok) {
          setState({
            action,
            location: location2
          });
        } else {
          revertPop(location2);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1)
      toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1)
      fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var path3 = getHashPath();
  var encodedPath = encodePath2(path3);
  if (path3 !== encodedPath)
    replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)];
  function createHref(location2) {
    var baseTag = document.querySelector("base");
    var href = "";
    if (baseTag && baseTag.getAttribute("href")) {
      href = stripHash(window.location.href);
    }
    return href + "#" + encodePath2(basename3 + createPath(location2));
  }
  function push(path4, state) {
    false ? tiny_warning_esm_default(state === void 0, "Hash history cannot push state; it is ignored") : void 0;
    var action = "PUSH";
    var location2 = createLocation(path4, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
      if (!ok)
        return;
      var path5 = createPath(location2);
      var encodedPath2 = encodePath2(basename3 + path5);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path5;
        pushHashPath(encodedPath2);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path5);
        allPaths = nextPaths;
        setState({
          action,
          location: location2
        });
      } else {
        false ? tiny_warning_esm_default(false, "Hash history cannot PUSH the same path; a new entry will not be added to the history stack") : void 0;
        setState();
      }
    });
  }
  function replace(path4, state) {
    false ? tiny_warning_esm_default(state === void 0, "Hash history cannot replace state; it is ignored") : void 0;
    var action = "REPLACE";
    var location2 = createLocation(path4, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
      if (!ok)
        return;
      var path5 = createPath(location2);
      var encodedPath2 = encodePath2(basename3 + path5);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path5;
        replaceHashPath(encodedPath2);
      }
      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1)
        allPaths[prevIndex] = path5;
      setState({
        action,
        location: location2
      });
    });
  }
  function go(n) {
    false ? tiny_warning_esm_default(canGoWithoutReload, "Hash history go(n) causes a full page reload in this browser") : void 0;
    globalHistory.go(n);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen2(listener) {
    var unlisten2 = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten2();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    block,
    listen: listen2
  };
  return history;
}
function clamp2(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}
function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }
  var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? ["/"] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends(history, nextState);
    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var index2 = clamp2(initialIndex, 0, initialEntries.length - 1);
  var entries3 = initialEntries.map(function(entry) {
    return typeof entry === "string" ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
  });
  var createHref = createPath;
  function push(path3, state) {
    false ? tiny_warning_esm_default(!(typeof path3 === "object" && path3.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
    var action = "PUSH";
    var location2 = createLocation(path3, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
      if (!ok)
        return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location2);
      } else {
        nextEntries.push(location2);
      }
      setState({
        action,
        location: location2,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }
  function replace(path3, state) {
    false ? tiny_warning_esm_default(!(typeof path3 === "object" && path3.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
    var action = "REPLACE";
    var location2 = createLocation(path3, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
      if (!ok)
        return;
      history.entries[history.index] = location2;
      setState({
        action,
        location: location2
      });
    });
  }
  function go(n) {
    var nextIndex = clamp2(history.index + n, 0, history.entries.length - 1);
    var action = "POP";
    var location2 = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
      if (ok) {
        setState({
          action,
          location: location2,
          index: nextIndex
        });
      } else {
        setState();
      }
    });
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    return transitionManager.setPrompt(prompt);
  }
  function listen2(listener) {
    return transitionManager.appendListener(listener);
  }
  var history = {
    length: entries3.length,
    action: "POP",
    location: entries3[index2],
    index: index2,
    entries: entries3,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    canGo,
    block,
    listen: listen2
  };
  return history;
}

// ../../node_modules/mini-create-react-context/dist/esm/index.js
import React2, {Component} from "https://cdn.skypack.dev/react";
var import_prop_types = __toModule(require_prop_types());
var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {};
function getUniqueId() {
  var key = "__global_unique_id__";
  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
}
function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function(h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set5(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function(handler) {
        return handler(value, changedBits);
      });
    }
  };
}
function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}
function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;
  var contextProp = "__create-react-context-" + getUniqueId() + "__";
  var Provider2 = /* @__PURE__ */ function(_Component) {
    _inheritsLoose(Provider3, _Component);
    function Provider3() {
      var _this;
      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }
    var _proto = Provider3.prototype;
    _proto.getChildContext = function getChildContext() {
      var _ref2;
      return _ref2 = {}, _ref2[contextProp] = this.emitter, _ref2;
    };
    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;
        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          if (false) {
            tiny_warning_esm_default((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, "calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: " + changedBits);
          }
          changedBits |= 0;
          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };
    _proto.render = function render() {
      return this.props.children;
    };
    return Provider3;
  }(Component);
  Provider2.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = import_prop_types.default.object.isRequired, _Provider$childContex);
  var Consumer = /* @__PURE__ */ function(_Component2) {
    _inheritsLoose(Consumer2, _Component2);
    function Consumer2() {
      var _this2;
      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };
      _this2.onUpdate = function(newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };
      return _this2;
    }
    var _proto2 = Consumer2.prototype;
    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };
    _proto2.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };
    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };
    return Consumer2;
  }(Component);
  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = import_prop_types.default.object, _Consumer$contextType);
  return {
    Provider: Provider2,
    Consumer
  };
}
var index = React2.createContext || createReactContext;
var esm_default = index;

// ../../node_modules/react-router/esm/react-router.js
var import_path_to_regexp = __toModule(require_path_to_regexp());
var import_react_is = __toModule(require_react_is());
var import_hoist_non_react_statics = __toModule(require_hoist_non_react_statics_cjs());
var createNamedContext = function createNamedContext2(name) {
  var context2 = esm_default();
  context2.displayName = name;
  return context2;
};
var historyContext = /* @__PURE__ */ createNamedContext("Router-History");
var createNamedContext$1 = function createNamedContext3(name) {
  var context2 = esm_default();
  context2.displayName = name;
  return context2;
};
var context = /* @__PURE__ */ createNamedContext$1("Router");
var Router = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Router2, _React$Component);
  Router2.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };
  function Router2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    };
    _this._isMounted = false;
    _this._pendingLocation = null;
    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function(location2) {
        if (_this._isMounted) {
          _this.setState({
            location: location2
          });
        } else {
          _this._pendingLocation = location2;
        }
      });
    }
    return _this;
  }
  var _proto = Router2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this._isMounted = true;
    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten)
      this.unlisten();
  };
  _proto.render = function render() {
    return React3.createElement(context.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router2.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, React3.createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };
  return Router2;
}(React3.Component);
if (false) {
  Router.propTypes = {
    children: import_prop_types2.default.node,
    history: import_prop_types2.default.object.isRequired,
    staticContext: import_prop_types2.default.object
  };
  Router.prototype.componentDidUpdate = function(prevProps) {
    false ? tiny_warning_esm_default(prevProps.history === this.props.history, "You cannot change <Router history>") : void 0;
  };
}
var MemoryRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(MemoryRouter2, _React$Component);
  function MemoryRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }
  var _proto = MemoryRouter2.prototype;
  _proto.render = function render() {
    return React3.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return MemoryRouter2;
}(React3.Component);
if (false) {
  MemoryRouter.propTypes = {
    initialEntries: import_prop_types2.default.array,
    initialIndex: import_prop_types2.default.number,
    getUserConfirmation: import_prop_types2.default.func,
    keyLength: import_prop_types2.default.number,
    children: import_prop_types2.default.node
  };
  MemoryRouter.prototype.componentDidMount = function() {
    false ? tiny_warning_esm_default(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { MemoryRouter as Router }`.") : void 0;
  };
}
var Lifecycle = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Lifecycle2, _React$Component);
  function Lifecycle2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Lifecycle2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount)
      this.props.onMount.call(this, this);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate)
      this.props.onUpdate.call(this, this, prevProps);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount)
      this.props.onUnmount.call(this, this);
  };
  _proto.render = function render() {
    return null;
  };
  return Lifecycle2;
}(React3.Component);
if (false) {
  messageType = import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.string]);
  Prompt.propTypes = {
    when: import_prop_types2.default.bool,
    message: messageType.isRequired
  };
}
var messageType;
if (false) {
  Redirect.propTypes = {
    push: import_prop_types2.default.bool,
    from: import_prop_types2.default.string,
    to: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.object]).isRequired
  };
}
var cache$1 = {};
var cacheLimit$1 = 1e4;
var cacheCount$1 = 0;
function compilePath$1(path3, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path3])
    return pathCache[path3];
  var keys = [];
  var regexp = import_path_to_regexp.default(path3, keys, options);
  var result = {
    regexp,
    keys
  };
  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path3] = result;
    cacheCount$1++;
  }
  return result;
}
function matchPath(pathname, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }
  var _options = options, path3 = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path3);
  return paths.reduce(function(matched, path4) {
    if (!path4 && path4 !== "")
      return null;
    if (matched)
      return matched;
    var _compilePath = compilePath$1(path4, {
      end: exact,
      strict,
      sensitive
    }), regexp = _compilePath.regexp, keys = _compilePath.keys;
    var match = regexp.exec(pathname);
    if (!match)
      return null;
    var url = match[0], values = match.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact)
      return null;
    return {
      path: path4,
      url: path4 === "/" && url === "" ? "/" : url,
      isExact,
      params: keys.reduce(function(memo, key, index2) {
        memo[key.name] = values[index2];
        return memo;
      }, {})
    };
  }, null);
}
var Route = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Route2, _React$Component);
  function Route2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Route2.prototype;
  _proto.render = function render() {
    var _this = this;
    return React3.createElement(context.Consumer, null, function(context$1) {
      !context$1 ? false ? tiny_invariant_esm_default(false, "You should not use <Route> outside a <Router>") : tiny_invariant_esm_default(false) : void 0;
      var location2 = _this.props.location || context$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath(location2.pathname, _this.props) : context$1.match;
      var props = _extends({}, context$1, {
        location: location2,
        match
      });
      var _this$props = _this.props, children = _this$props.children, component = _this$props.component, render2 = _this$props.render;
      if (Array.isArray(children) && children.length === 0) {
        children = null;
      }
      return React3.createElement(context.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ? false ? evalChildrenDev(children, props, _this.props.path) : children(props) : children : component ? React3.createElement(component, props) : render2 ? render2(props) : null : typeof children === "function" ? false ? evalChildrenDev(children, props, _this.props.path) : children(props) : null);
    });
  };
  return Route2;
}(React3.Component);
if (false) {
  Route.propTypes = {
    children: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.node]),
    component: function component(props, propName) {
      if (props[propName] && !import_react_is.isValidElementType(props[propName])) {
        return new Error("Invalid prop 'component' supplied to 'Route': the prop is not a valid React component");
      }
    },
    exact: import_prop_types2.default.bool,
    location: import_prop_types2.default.object,
    path: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.arrayOf(import_prop_types2.default.string)]),
    render: import_prop_types2.default.func,
    sensitive: import_prop_types2.default.bool,
    strict: import_prop_types2.default.bool
  };
  Route.prototype.componentDidMount = function() {
    false ? tiny_warning_esm_default(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.component), "You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored") : void 0;
    false ? tiny_warning_esm_default(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.render), "You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored") : void 0;
    false ? tiny_warning_esm_default(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored") : void 0;
  };
  Route.prototype.componentDidUpdate = function(prevProps) {
    false ? tiny_warning_esm_default(!(this.props.location && !prevProps.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;
    false ? tiny_warning_esm_default(!(!this.props.location && prevProps.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
  };
}
function addLeadingSlash2(path3) {
  return path3.charAt(0) === "/" ? path3 : "/" + path3;
}
function addBasename(basename3, location2) {
  if (!basename3)
    return location2;
  return _extends({}, location2, {
    pathname: addLeadingSlash2(basename3) + location2.pathname
  });
}
function stripBasename2(basename3, location2) {
  if (!basename3)
    return location2;
  var base = addLeadingSlash2(basename3);
  if (location2.pathname.indexOf(base) !== 0)
    return location2;
  return _extends({}, location2, {
    pathname: location2.pathname.substr(base.length)
  });
}
function createURL(location2) {
  return typeof location2 === "string" ? location2 : createPath(location2);
}
function staticHandler(methodName) {
  return function() {
    false ? tiny_invariant_esm_default(false, "You cannot %s with <StaticRouter>", methodName) : tiny_invariant_esm_default(false);
  };
}
function noop() {
}
var StaticRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(StaticRouter2, _React$Component);
  function StaticRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handlePush = function(location2) {
      return _this.navigateTo(location2, "PUSH");
    };
    _this.handleReplace = function(location2) {
      return _this.navigateTo(location2, "REPLACE");
    };
    _this.handleListen = function() {
      return noop;
    };
    _this.handleBlock = function() {
      return noop;
    };
    return _this;
  }
  var _proto = StaticRouter2.prototype;
  _proto.navigateTo = function navigateTo(location2, action) {
    var _this$props = this.props, _this$props$basename = _this$props.basename, basename3 = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
    context2.action = action;
    context2.location = addBasename(basename3, createLocation(location2));
    context2.url = createURL(context2.location);
  };
  _proto.render = function render() {
    var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename3 = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location2 = _this$props2$location === void 0 ? "/" : _this$props2$location, rest = _objectWithoutPropertiesLoose(_this$props2, ["basename", "context", "location"]);
    var history = {
      createHref: function createHref(path3) {
        return addLeadingSlash2(basename3 + createURL(path3));
      },
      action: "POP",
      location: stripBasename2(basename3, createLocation(location2)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler("go"),
      goBack: staticHandler("goBack"),
      goForward: staticHandler("goForward"),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return React3.createElement(Router, _extends({}, rest, {
      history,
      staticContext: context2
    }));
  };
  return StaticRouter2;
}(React3.Component);
if (false) {
  StaticRouter.propTypes = {
    basename: import_prop_types2.default.string,
    context: import_prop_types2.default.object,
    location: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.object])
  };
  StaticRouter.prototype.componentDidMount = function() {
    false ? tiny_warning_esm_default(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { StaticRouter as Router }`.") : void 0;
  };
}
var Switch = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Switch2, _React$Component);
  function Switch2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Switch2.prototype;
  _proto.render = function render() {
    var _this = this;
    return React3.createElement(context.Consumer, null, function(context2) {
      !context2 ? false ? tiny_invariant_esm_default(false, "You should not use <Switch> outside a <Router>") : tiny_invariant_esm_default(false) : void 0;
      var location2 = _this.props.location || context2.location;
      var element, match;
      React3.Children.forEach(_this.props.children, function(child) {
        if (match == null && React3.isValidElement(child)) {
          element = child;
          var path3 = child.props.path || child.props.from;
          match = path3 ? matchPath(location2.pathname, _extends({}, child.props, {
            path: path3
          })) : context2.match;
        }
      });
      return match ? React3.cloneElement(element, {
        location: location2,
        computedMatch: match
      }) : null;
    });
  };
  return Switch2;
}(React3.Component);
if (false) {
  Switch.propTypes = {
    children: import_prop_types2.default.node,
    location: import_prop_types2.default.object
  };
  Switch.prototype.componentDidUpdate = function(prevProps) {
    false ? tiny_warning_esm_default(!(this.props.location && !prevProps.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;
    false ? tiny_warning_esm_default(!(!this.props.location && prevProps.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
  };
}
var useContext = React3.useContext;
if (false) {
  if (typeof window !== "undefined") {
    global2 = window;
    key = "__react_router_build__";
    buildNames = {
      cjs: "CommonJS",
      esm: "ES modules",
      umd: "UMD"
    };
    if (global2[key] && global2[key] !== "esm") {
      initialBuildName = buildNames[global2[key]];
      secondaryBuildName = buildNames["esm"];
      throw new Error("You are loading the " + secondaryBuildName + " build of React Router " + ("on a page that is already running the " + initialBuildName + " ") + "build, so things won't work right.");
    }
    global2[key] = "esm";
  }
}
var global2;
var key;
var buildNames;
var initialBuildName;
var secondaryBuildName;

// ../../node_modules/react-router-dom/esm/react-router-dom.js
import React4 from "https://cdn.skypack.dev/react";
var import_prop_types3 = __toModule(require_prop_types());
var BrowserRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(BrowserRouter2, _React$Component);
  function BrowserRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createBrowserHistory(_this.props);
    return _this;
  }
  var _proto = BrowserRouter2.prototype;
  _proto.render = function render() {
    return React4.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return BrowserRouter2;
}(React4.Component);
if (false) {
  BrowserRouter.propTypes = {
    basename: import_prop_types3.default.string,
    children: import_prop_types3.default.node,
    forceRefresh: import_prop_types3.default.bool,
    getUserConfirmation: import_prop_types3.default.func,
    keyLength: import_prop_types3.default.number
  };
  BrowserRouter.prototype.componentDidMount = function() {
    false ? tiny_warning_esm_default(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { BrowserRouter as Router }`.") : void 0;
  };
}
var HashRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(HashRouter2, _React$Component);
  function HashRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createHashHistory(_this.props);
    return _this;
  }
  var _proto = HashRouter2.prototype;
  _proto.render = function render() {
    return React4.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return HashRouter2;
}(React4.Component);
if (false) {
  HashRouter.propTypes = {
    basename: import_prop_types3.default.string,
    children: import_prop_types3.default.node,
    getUserConfirmation: import_prop_types3.default.func,
    hashType: import_prop_types3.default.oneOf(["hashbang", "noslash", "slash"])
  };
  HashRouter.prototype.componentDidMount = function() {
    false ? tiny_warning_esm_default(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { HashRouter as Router }`.") : void 0;
  };
}
var resolveToLocation = function resolveToLocation2(to, currentLocation) {
  return typeof to === "function" ? to(currentLocation) : to;
};
var normalizeToLocation = function normalizeToLocation2(to, currentLocation) {
  return typeof to === "string" ? createLocation(to, null, null, currentLocation) : to;
};
var forwardRefShim = function forwardRefShim2(C2) {
  return C2;
};
var forwardRef = React4.forwardRef;
if (typeof forwardRef === "undefined") {
  forwardRef = forwardRefShim;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
var LinkAnchor = forwardRef(function(_ref2, forwardedRef) {
  var innerRef = _ref2.innerRef, navigate = _ref2.navigate, _onClick = _ref2.onClick, rest = _objectWithoutPropertiesLoose(_ref2, ["innerRef", "navigate", "onClick"]);
  var target = rest.target;
  var props = _extends({}, rest, {
    onClick: function onClick(event) {
      try {
        if (_onClick)
          _onClick(event);
      } catch (ex) {
        event.preventDefault();
        throw ex;
      }
      if (!event.defaultPrevented && event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
        event.preventDefault();
        navigate();
      }
    }
  });
  if (forwardRefShim !== forwardRef) {
    props.ref = forwardedRef || innerRef;
  } else {
    props.ref = innerRef;
  }
  return React4.createElement("a", props);
});
if (false) {
  LinkAnchor.displayName = "LinkAnchor";
}
var Link = forwardRef(function(_ref2, forwardedRef) {
  var _ref2$component = _ref2.component, component = _ref2$component === void 0 ? LinkAnchor : _ref2$component, replace = _ref2.replace, to = _ref2.to, innerRef = _ref2.innerRef, rest = _objectWithoutPropertiesLoose(_ref2, ["component", "replace", "to", "innerRef"]);
  return React4.createElement(context.Consumer, null, function(context2) {
    !context2 ? false ? tiny_invariant_esm_default(false, "You should not use <Link> outside a <Router>") : tiny_invariant_esm_default(false) : void 0;
    var history = context2.history;
    var location2 = normalizeToLocation(resolveToLocation(to, context2.location), context2.location);
    var href = location2 ? history.createHref(location2) : "";
    var props = _extends({}, rest, {
      href,
      navigate: function navigate() {
        var location3 = resolveToLocation(to, context2.location);
        var method = replace ? history.replace : history.push;
        method(location3);
      }
    });
    if (forwardRefShim !== forwardRef) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }
    return React4.createElement(component, props);
  });
});
if (false) {
  toType = import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.object, import_prop_types3.default.func]);
  refType = import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.func, import_prop_types3.default.shape({
    current: import_prop_types3.default.any
  })]);
  Link.displayName = "Link";
  Link.propTypes = {
    innerRef: refType,
    onClick: import_prop_types3.default.func,
    replace: import_prop_types3.default.bool,
    target: import_prop_types3.default.string,
    to: toType.isRequired
  };
}
var toType;
var refType;
var forwardRefShim$1 = function forwardRefShim3(C2) {
  return C2;
};
var forwardRef$1 = React4.forwardRef;
if (typeof forwardRef$1 === "undefined") {
  forwardRef$1 = forwardRefShim$1;
}
function joinClassnames() {
  for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {
    classnames[_key] = arguments[_key];
  }
  return classnames.filter(function(i) {
    return i;
  }).join(" ");
}
var NavLink = forwardRef$1(function(_ref2, forwardedRef) {
  var _ref$ariaCurrent = _ref2["aria-current"], ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent, _ref$activeClassName = _ref2.activeClassName, activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName, activeStyle = _ref2.activeStyle, classNameProp = _ref2.className, exact = _ref2.exact, isActiveProp = _ref2.isActive, locationProp = _ref2.location, sensitive = _ref2.sensitive, strict = _ref2.strict, styleProp = _ref2.style, to = _ref2.to, innerRef = _ref2.innerRef, rest = _objectWithoutPropertiesLoose(_ref2, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);
  return React4.createElement(context.Consumer, null, function(context2) {
    !context2 ? false ? tiny_invariant_esm_default(false, "You should not use <NavLink> outside a <Router>") : tiny_invariant_esm_default(false) : void 0;
    var currentLocation = locationProp || context2.location;
    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
    var path3 = toLocation.pathname;
    var escapedPath = path3 && path3.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    var match = escapedPath ? matchPath(currentLocation.pathname, {
      path: escapedPath,
      exact,
      sensitive,
      strict
    }) : null;
    var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);
    var className = isActive ? joinClassnames(classNameProp, activeClassName) : classNameProp;
    var style = isActive ? _extends({}, styleProp, {}, activeStyle) : styleProp;
    var props = _extends({
      "aria-current": isActive && ariaCurrent || null,
      className,
      style,
      to: toLocation
    }, rest);
    if (forwardRefShim$1 !== forwardRef$1) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }
    return React4.createElement(Link, props);
  });
});
if (false) {
  NavLink.displayName = "NavLink";
  ariaCurrentType = import_prop_types3.default.oneOf(["page", "step", "location", "date", "time", "true"]);
  NavLink.propTypes = _extends({}, Link.propTypes, {
    "aria-current": ariaCurrentType,
    activeClassName: import_prop_types3.default.string,
    activeStyle: import_prop_types3.default.object,
    className: import_prop_types3.default.string,
    exact: import_prop_types3.default.bool,
    isActive: import_prop_types3.default.func,
    location: import_prop_types3.default.object,
    sensitive: import_prop_types3.default.bool,
    strict: import_prop_types3.default.bool,
    style: import_prop_types3.default.object
  });
}
var ariaCurrentType;

// node_modules/@material-ui/lab/esm/Skeleton/Skeleton.js
import {
  createElement as createElement2,
  forwardRef as forwardRef2
} from "https://cdn.skypack.dev/react";
var import_prop_types5 = __toModule(require_prop_types());

// node_modules/@material-ui/core/esm/styles/colorManipulator.js
function emphasize(color) {
  var coefficient = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.15;
  return getLuminance(color) > 0.5 ? darken(color, coefficient) : lighten(color, coefficient);
}

// node_modules/@material-ui/styles/esm/StylesProvider/StylesProvider.js
var injectFirstNode;
function StylesProvider(props) {
  var children = props.children, _props$injectFirst = props.injectFirst, injectFirst = _props$injectFirst === void 0 ? false : _props$injectFirst, _props$disableGenerat = props.disableGeneration, disableGeneration = _props$disableGenerat === void 0 ? false : _props$disableGenerat, localOptions = _objectWithoutProperties(props, ["children", "injectFirst", "disableGeneration"]);
  var outerOptions = React.useContext(StylesContext);
  var context2 = _extends({}, outerOptions, {
    disableGeneration
  }, localOptions);
  if (false) {
    if (typeof window === "undefined" && !context2.sheetsManager) {
      console.error("Material-UI: You need to use the ServerStyleSheets API when rendering on the server.");
    }
  }
  if (false) {
    if (context2.jss.options.insertionPoint && injectFirst) {
      console.error("Material-UI: You cannot use a custom insertionPoint and <StylesContext injectFirst> at the same time.");
    }
  }
  if (false) {
    if (injectFirst && localOptions.jss) {
      console.error("Material-UI: You cannot use the jss and injectFirst props at the same time.");
    }
  }
  if (!context2.jss.options.insertionPoint && injectFirst && typeof window !== "undefined") {
    if (!injectFirstNode) {
      var head = document.head;
      injectFirstNode = document.createComment("mui-inject-first");
      head.insertBefore(injectFirstNode, head.firstChild);
    }
    context2.jss = create({
      plugins: jssPreset().plugins,
      insertionPoint: injectFirstNode
    });
  }
  return /* @__PURE__ */ React.createElement(StylesContext.Provider, {
    value: context2
  }, children);
}

// ../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// node_modules/@material-ui/styles/esm/ThemeProvider/ThemeProvider.js
var import_prop_types4 = __toModule(require_prop_types());
import React5 from "https://cdn.skypack.dev/react";
function mergeOuterLocalTheme(outerTheme, localTheme) {
  if (typeof localTheme === "function") {
    var mergedTheme = localTheme(outerTheme);
    if (false) {
      if (!mergedTheme) {
        console.error(["Material-UI: You should return an object from your theme function, i.e.", "<ThemeProvider theme={() => ({})} />"].join("\n"));
      }
    }
    return mergedTheme;
  }
  return _extends({}, outerTheme, localTheme);
}
function ThemeProvider(props) {
  var children = props.children, localTheme = props.theme;
  var outerTheme = useTheme();
  if (false) {
    if (outerTheme === null && typeof localTheme === "function") {
      console.error(["Material-UI: You are providing a theme function prop to the ThemeProvider component:", "<ThemeProvider theme={outerTheme => outerTheme} />", "", "However, no outer theme is present.", "Make sure a theme is already injected higher in the React tree or provide a theme object."].join("\n"));
    }
  }
  var theme6 = React5.useMemo(function() {
    var output = outerTheme === null ? localTheme : mergeOuterLocalTheme(outerTheme, localTheme);
    if (output != null) {
      output[nested_default] = outerTheme !== null;
    }
    return output;
  }, [localTheme, outerTheme]);
  return /* @__PURE__ */ React5.createElement(ThemeContext_default.Provider, {
    value: theme6
  }, children);
}
false ? ThemeProvider.propTypes = {
  children: import_prop_types4.default.node.isRequired,
  theme: import_prop_types4.default.oneOfType([import_prop_types4.default.object, import_prop_types4.default.func]).isRequired
} : void 0;
if (false) {
  false ? ThemeProvider.propTypes = exactProp(ThemeProvider.propTypes) : void 0;
}
var ThemeProvider_default = ThemeProvider;

// node_modules/@material-ui/core/esm/styles/makeStyles.js
function makeStyles2(stylesOrCreator) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return makeStyles(stylesOrCreator, _extends({
    defaultTheme: defaultTheme_default
  }, options));
}
var makeStyles_default = makeStyles2;

// node_modules/@material-ui/core/esm/styles/useTheme.js
import React6 from "https://cdn.skypack.dev/react";
function useTheme2() {
  var theme6 = useTheme() || defaultTheme_default;
  if (false) {
    React6.useDebugValue(theme6);
  }
  return theme6;
}

// node_modules/@material-ui/lab/esm/Skeleton/Skeleton.js
var styles = function styles2(theme6) {
  return {
    root: {
      display: "block",
      backgroundColor: fade(theme6.palette.text.primary, theme6.palette.type === "light" ? 0.11 : 0.13),
      height: "1.2em"
    },
    text: {
      marginTop: 0,
      marginBottom: 0,
      height: "auto",
      transformOrigin: "0 60%",
      transform: "scale(1, 0.60)",
      borderRadius: theme6.shape.borderRadius,
      "&:empty:before": {
        content: '"\\00a0"'
      }
    },
    rect: {},
    circle: {
      borderRadius: "50%"
    },
    pulse: {
      animation: "$pulse 1.5s ease-in-out 0.5s infinite"
    },
    "@keyframes pulse": {
      "0%": {
        opacity: 1
      },
      "50%": {
        opacity: 0.4
      },
      "100%": {
        opacity: 1
      }
    },
    wave: {
      position: "relative",
      overflow: "hidden",
      "&::after": {
        animation: "$wave 1.6s linear 0.5s infinite",
        background: "linear-gradient(90deg, transparent, ".concat(theme6.palette.action.hover, ", transparent)"),
        content: '""',
        position: "absolute",
        transform: "translateX(-100%)",
        bottom: 0,
        left: 0,
        right: 0,
        top: 0
      }
    },
    "@keyframes wave": {
      "0%": {
        transform: "translateX(-100%)"
      },
      "60%": {
        transform: "translateX(100%)"
      },
      "100%": {
        transform: "translateX(100%)"
      }
    },
    withChildren: {
      "& > *": {
        visibility: "hidden"
      }
    },
    fitContent: {
      maxWidth: "fit-content"
    },
    heightAuto: {
      height: "auto"
    }
  };
};
var Skeleton = /* @__PURE__ */ forwardRef2(function Skeleton2(props, ref) {
  var _props$animation = props.animation, animation = _props$animation === void 0 ? "pulse" : _props$animation, classes = props.classes, className = props.className, _props$component = props.component, Component5 = _props$component === void 0 ? "span" : _props$component, height = props.height, _props$variant = props.variant, variant = _props$variant === void 0 ? "text" : _props$variant, width = props.width, other = _objectWithoutProperties(props, ["animation", "classes", "className", "component", "height", "variant", "width"]);
  var hasChildren = Boolean(other.children);
  return /* @__PURE__ */ createElement2(Component5, _extends({
    ref,
    className: clsx_m_default(classes.root, classes[variant], className, hasChildren && [classes.withChildren, !width && classes.fitContent, !height && classes.heightAuto], animation !== false && classes[animation])
  }, other, {
    style: _extends({
      width,
      height
    }, other.style)
  }));
});
false ? Skeleton.propTypes = {
  animation: import_prop_types5.default.oneOf(["pulse", "wave", false]),
  children: import_prop_types5.default.node,
  classes: import_prop_types5.default.object.isRequired,
  className: import_prop_types5.default.string,
  component: import_prop_types5.default.elementType,
  height: import_prop_types5.default.oneOfType([import_prop_types5.default.number, import_prop_types5.default.string]),
  variant: import_prop_types5.default.oneOf(["text", "rect", "circle"]),
  width: import_prop_types5.default.oneOfType([import_prop_types5.default.number, import_prop_types5.default.string])
} : void 0;
var Skeleton_default = withStyles_default(styles, {
  name: "MuiSkeleton"
})(Skeleton);

// src/client/components/Error/Boundary.tsx
import {
  Component as Component2,
  createElement as createElement11
} from "https://cdn.skypack.dev/react";

// src/client/components/Error/View.tsx
var import_new_github_issue_url = __toModule(require_new_github_issue_url());
import {
  createElement as createElement10
} from "https://cdn.skypack.dev/react";

// src/client/components/Card/CardMedia.tsx
import React9 from "https://cdn.skypack.dev/react";
import styled from "https://cdn.skypack.dev/styled-components";

// node_modules/@material-ui/core/esm/CardMedia/CardMedia.js
var import_prop_types6 = __toModule(require_prop_types());
import {
  createElement as createElement3,
  forwardRef as forwardRef3
} from "https://cdn.skypack.dev/react";
var styles3 = {
  root: {
    display: "block",
    backgroundSize: "cover",
    backgroundRepeat: "no-repeat",
    backgroundPosition: "center"
  },
  media: {
    width: "100%"
  },
  img: {
    objectFit: "cover"
  }
};
var MEDIA_COMPONENTS = ["video", "audio", "picture", "iframe", "img"];
var CardMedia = /* @__PURE__ */ forwardRef3(function CardMedia2(props, ref) {
  var children = props.children, classes = props.classes, className = props.className, _props$component = props.component, Component5 = _props$component === void 0 ? "div" : _props$component, image = props.image, src = props.src, style = props.style, other = _objectWithoutProperties(props, ["children", "classes", "className", "component", "image", "src", "style"]);
  var isMediaComponent = MEDIA_COMPONENTS.indexOf(Component5) !== -1;
  var composedStyle = !isMediaComponent && image ? _extends({
    backgroundImage: 'url("'.concat(image, '")')
  }, style) : style;
  return /* @__PURE__ */ createElement3(Component5, _extends({
    className: clsx_m_default(classes.root, className, isMediaComponent && classes.media, "picture img".indexOf(Component5) !== -1 && classes.img),
    ref,
    style: composedStyle,
    src: isMediaComponent ? image || src : void 0
  }, other), children);
});
false ? CardMedia.propTypes = {
  children: chainPropTypes(import_prop_types6.default.node, function(props) {
    if (!props.children && !props.image && !props.src && !props.component) {
      return new Error("Material-UI: Either `children`, `image`, `src` or `component` prop must be specified.");
    }
    return null;
  }),
  classes: import_prop_types6.default.object,
  className: import_prop_types6.default.string,
  component: import_prop_types6.default.elementType,
  image: import_prop_types6.default.string,
  src: import_prop_types6.default.string,
  style: import_prop_types6.default.object
} : void 0;
var CardMedia_default = withStyles_default(styles3, {
  name: "MuiCardMedia"
})(CardMedia);

// src/client/components/Card/CardMedia.tsx
var BaseCardMedia = (props) => /* @__PURE__ */ React9.createElement(CardMedia_default, {
  ...props
});
var CardMedia3 = styled(BaseCardMedia)``;

// src/client/components/Card/CardHeader.tsx
import React11 from "https://cdn.skypack.dev/react";
import styled2 from "https://cdn.skypack.dev/styled-components";

// node_modules/@material-ui/core/esm/CardHeader/CardHeader.js
var import_prop_types7 = __toModule(require_prop_types());
import {
  createElement as createElement4,
  forwardRef as forwardRef4
} from "https://cdn.skypack.dev/react";
var styles4 = {
  root: {
    display: "flex",
    alignItems: "center",
    padding: 16
  },
  avatar: {
    flex: "0 0 auto",
    marginRight: 16
  },
  action: {
    flex: "0 0 auto",
    alignSelf: "flex-start",
    marginTop: -8,
    marginRight: -8
  },
  content: {
    flex: "1 1 auto"
  },
  title: {},
  subheader: {}
};
var CardHeader = /* @__PURE__ */ forwardRef4(function CardHeader2(props, ref) {
  var action = props.action, avatar = props.avatar, classes = props.classes, className = props.className, _props$component = props.component, Component5 = _props$component === void 0 ? "div" : _props$component, _props$disableTypogra = props.disableTypography, disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra, subheaderProp = props.subheader, subheaderTypographyProps = props.subheaderTypographyProps, titleProp = props.title, titleTypographyProps = props.titleTypographyProps, other = _objectWithoutProperties(props, ["action", "avatar", "classes", "className", "component", "disableTypography", "subheader", "subheaderTypographyProps", "title", "titleTypographyProps"]);
  var title = titleProp;
  if (title != null && title.type !== Typography_default && !disableTypography) {
    title = /* @__PURE__ */ createElement4(Typography_default, _extends({
      variant: avatar ? "body2" : "h5",
      className: classes.title,
      component: "span",
      display: "block"
    }, titleTypographyProps), title);
  }
  var subheader = subheaderProp;
  if (subheader != null && subheader.type !== Typography_default && !disableTypography) {
    subheader = /* @__PURE__ */ createElement4(Typography_default, _extends({
      variant: avatar ? "body2" : "body1",
      className: classes.subheader,
      color: "textSecondary",
      component: "span",
      display: "block"
    }, subheaderTypographyProps), subheader);
  }
  return /* @__PURE__ */ createElement4(Component5, _extends({
    className: clsx_m_default(classes.root, className),
    ref
  }, other), avatar && /* @__PURE__ */ createElement4("div", {
    className: classes.avatar
  }, avatar), /* @__PURE__ */ createElement4("div", {
    className: classes.content
  }, title, subheader), action && /* @__PURE__ */ createElement4("div", {
    className: classes.action
  }, action));
});
false ? CardHeader.propTypes = {
  action: import_prop_types7.default.node,
  avatar: import_prop_types7.default.node,
  children: import_prop_types7.default.node,
  classes: import_prop_types7.default.object,
  className: import_prop_types7.default.string,
  component: import_prop_types7.default.elementType,
  disableTypography: import_prop_types7.default.bool,
  subheader: import_prop_types7.default.node,
  subheaderTypographyProps: import_prop_types7.default.object,
  title: import_prop_types7.default.node,
  titleTypographyProps: import_prop_types7.default.object
} : void 0;
var CardHeader_default = withStyles_default(styles4, {
  name: "MuiCardHeader"
})(CardHeader);

// src/client/components/Card/CardHeader.tsx
var BaseCardHeader = (props) => /* @__PURE__ */ React11.createElement(CardHeader_default, {
  ...props
});
var CardHeader3 = styled2(BaseCardHeader)``;
var CardHeader_default2 = CardHeader3;

// src/client/components/Card/CardContent.tsx
import React13 from "https://cdn.skypack.dev/react";
import styled3 from "https://cdn.skypack.dev/styled-components";

// node_modules/@material-ui/core/esm/CardContent/CardContent.js
var import_prop_types8 = __toModule(require_prop_types());
import {
  createElement as createElement5,
  forwardRef as forwardRef5
} from "https://cdn.skypack.dev/react";
var styles5 = {
  root: {
    padding: 16,
    "&:last-child": {
      paddingBottom: 24
    }
  }
};
var CardContent = /* @__PURE__ */ forwardRef5(function CardContent2(props, ref) {
  var classes = props.classes, className = props.className, _props$component = props.component, Component5 = _props$component === void 0 ? "div" : _props$component, other = _objectWithoutProperties(props, ["classes", "className", "component"]);
  return /* @__PURE__ */ createElement5(Component5, _extends({
    className: clsx_m_default(classes.root, className),
    ref
  }, other));
});
false ? CardContent.propTypes = {
  children: import_prop_types8.default.node,
  classes: import_prop_types8.default.object,
  className: import_prop_types8.default.string,
  component: import_prop_types8.default.elementType
} : void 0;
var CardContent_default = withStyles_default(styles5, {
  name: "MuiCardContent"
})(CardContent);

// src/client/components/Card/CardContent.tsx
var BaseCardContent = (props) => /* @__PURE__ */ React13.createElement(CardContent_default, {
  ...props
});
var CardContent3 = styled3(BaseCardContent)``;
var CardContent_default2 = CardContent3;

// src/client/components/Card/CardActions.tsx
import React15 from "https://cdn.skypack.dev/react";
import styled4 from "https://cdn.skypack.dev/styled-components";

// node_modules/@material-ui/core/esm/CardActions/CardActions.js
var import_prop_types9 = __toModule(require_prop_types());
import {
  createElement as createElement6,
  forwardRef as forwardRef6
} from "https://cdn.skypack.dev/react";
var styles6 = {
  root: {
    display: "flex",
    alignItems: "center",
    padding: 8
  },
  spacing: {
    "& > :not(:first-child)": {
      marginLeft: 8
    }
  }
};
var CardActions = /* @__PURE__ */ forwardRef6(function CardActions2(props, ref) {
  var _props$disableSpacing = props.disableSpacing, disableSpacing = _props$disableSpacing === void 0 ? false : _props$disableSpacing, classes = props.classes, className = props.className, other = _objectWithoutProperties(props, ["disableSpacing", "classes", "className"]);
  return /* @__PURE__ */ createElement6("div", _extends({
    className: clsx_m_default(classes.root, className, !disableSpacing && classes.spacing),
    ref
  }, other));
});
false ? CardActions.propTypes = {
  children: import_prop_types9.default.node,
  classes: import_prop_types9.default.object,
  className: import_prop_types9.default.string,
  disableSpacing: import_prop_types9.default.bool
} : void 0;
var CardActions_default = withStyles_default(styles6, {
  name: "MuiCardActions"
})(CardActions);

// src/client/components/Card/CardActions.tsx
var BaseCardActions = (props) => /* @__PURE__ */ React15.createElement(CardActions_default, {
  ...props
});
var CardActions3 = styled4(BaseCardActions)``;
var CardActions_default2 = CardActions3;

// src/client/components/Card/CardActionArea.tsx
import React18 from "https://cdn.skypack.dev/react";
import styled5 from "https://cdn.skypack.dev/styled-components";

// node_modules/@material-ui/core/esm/CardActionArea/CardActionArea.js
var import_prop_types11 = __toModule(require_prop_types());
import {
  createElement as createElement7,
  forwardRef as forwardRef7
} from "https://cdn.skypack.dev/react";

// ../../node_modules/react-transition-group/esm/Transition.js
var import_prop_types10 = __toModule(require_prop_types());
import React16 from "https://cdn.skypack.dev/react";
import ReactDOM from "https://cdn.skypack.dev/react-dom";

// ../../node_modules/react-transition-group/esm/config.js
var config_default = {
  disabled: false
};

// ../../node_modules/react-transition-group/esm/Transition.js
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context2) {
    var _this;
    _this = _React$Component.call(this, props, context2) || this;
    var parentGroup = context2;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref2, prevState) {
    var nextIn = _ref2.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status2 = this.state.status;
      if (this.props.in) {
        if (status2 !== ENTERING && status2 !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status2 === ENTERING || status2 === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout3 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout3;
    if (timeout3 != null && typeof timeout3 !== "number") {
      exit = timeout3.exit;
      enter = timeout3.enter;
      appear = timeout3.appear !== void 0 ? timeout3.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config_default.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config_default.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout3, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout3 == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout3 != null) {
      setTimeout(this.nextCallback, timeout3);
    }
  };
  _proto.render = function render() {
    var status2 = this.state.status;
    if (status2 === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return /* @__PURE__ */ React16.createElement(TransitionGroupContext_default.Provider, {
      value: null
    }, typeof children === "function" ? children(status2, childProps) : React16.cloneElement(React16.Children.only(children), childProps));
  };
  return Transition2;
}(React16.Component);
Transition.contextType = TransitionGroupContext_default;
Transition.propTypes = false ? {
  nodeRef: import_prop_types10.default.shape({
    current: typeof Element === "undefined" ? import_prop_types10.default.any : import_prop_types10.default.instanceOf(Element)
  }),
  children: import_prop_types10.default.oneOfType([import_prop_types10.default.func.isRequired, import_prop_types10.default.element.isRequired]).isRequired,
  in: import_prop_types10.default.bool,
  mountOnEnter: import_prop_types10.default.bool,
  unmountOnExit: import_prop_types10.default.bool,
  appear: import_prop_types10.default.bool,
  enter: import_prop_types10.default.bool,
  exit: import_prop_types10.default.bool,
  timeout: function timeout2(props) {
    var pt = timeoutsShape;
    if (!props.addEndListener)
      pt = pt.isRequired;
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return pt.apply(void 0, [props].concat(args));
  },
  addEndListener: import_prop_types10.default.func,
  onEnter: import_prop_types10.default.func,
  onEntering: import_prop_types10.default.func,
  onEntered: import_prop_types10.default.func,
  onExit: import_prop_types10.default.func,
  onExiting: import_prop_types10.default.func,
  onExited: import_prop_types10.default.func
} : {};
function noop2() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop2,
  onEntering: noop2,
  onEntered: noop2,
  onExit: noop2,
  onExiting: noop2,
  onExited: noop2
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition_default = Transition;

// node_modules/@material-ui/core/esm/CardActionArea/CardActionArea.js
var styles7 = function styles8(theme6) {
  return {
    root: {
      display: "block",
      textAlign: "inherit",
      width: "100%",
      "&:hover $focusHighlight": {
        opacity: theme6.palette.action.hoverOpacity
      },
      "&$focusVisible $focusHighlight": {
        opacity: 0.12
      }
    },
    focusVisible: {},
    focusHighlight: {
      overflow: "hidden",
      pointerEvents: "none",
      position: "absolute",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      borderRadius: "inherit",
      opacity: 0,
      backgroundColor: "currentcolor",
      transition: theme6.transitions.create("opacity", {
        duration: theme6.transitions.duration.short
      })
    }
  };
};
var CardActionArea = /* @__PURE__ */ forwardRef7(function CardActionArea2(props, ref) {
  var children = props.children, classes = props.classes, className = props.className, focusVisibleClassName = props.focusVisibleClassName, other = _objectWithoutProperties(props, ["children", "classes", "className", "focusVisibleClassName"]);
  return /* @__PURE__ */ createElement7(ButtonBase_default, _extends({
    className: clsx_m_default(classes.root, className),
    focusVisibleClassName: clsx_m_default(focusVisibleClassName, classes.focusVisible),
    ref
  }, other), children, /* @__PURE__ */ createElement7("span", {
    className: classes.focusHighlight
  }));
});
false ? CardActionArea.propTypes = {
  children: import_prop_types11.default.node,
  classes: import_prop_types11.default.object,
  className: import_prop_types11.default.string,
  focusVisibleClassName: import_prop_types11.default.string
} : void 0;
var CardActionArea_default = withStyles_default(styles7, {
  name: "MuiCardActionArea"
})(CardActionArea);

// src/client/components/Card/CardActionArea.tsx
var BaseCardActionArea = (props) => /* @__PURE__ */ React18.createElement(CardActionArea_default, {
  ...props
});
var CardActionArea3 = styled5(BaseCardActionArea)``;

// src/client/components/Card/Card.tsx
import React21 from "https://cdn.skypack.dev/react";
import styled6, {css} from "https://cdn.skypack.dev/styled-components";

// node_modules/@material-ui/core/esm/Card/Card.js
var import_prop_types13 = __toModule(require_prop_types());
import {
  createElement as createElement9,
  forwardRef as forwardRef9
} from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/core/esm/Paper/Paper.js
var import_prop_types12 = __toModule(require_prop_types());
import {
  createElement as createElement8,
  forwardRef as forwardRef8
} from "https://cdn.skypack.dev/react";
var styles9 = function styles10(theme6) {
  var elevations = {};
  theme6.shadows.forEach(function(shadow, index2) {
    elevations["elevation".concat(index2)] = {
      boxShadow: shadow
    };
  });
  return _extends({
    root: {
      backgroundColor: theme6.palette.background.paper,
      color: theme6.palette.text.primary,
      transition: theme6.transitions.create("box-shadow")
    },
    rounded: {
      borderRadius: theme6.shape.borderRadius
    },
    outlined: {
      border: "1px solid ".concat(theme6.palette.divider)
    }
  }, elevations);
};
var Paper = /* @__PURE__ */ forwardRef8(function Paper2(props, ref) {
  var classes = props.classes, className = props.className, _props$component = props.component, Component5 = _props$component === void 0 ? "div" : _props$component, _props$square = props.square, square = _props$square === void 0 ? false : _props$square, _props$elevation = props.elevation, elevation = _props$elevation === void 0 ? 1 : _props$elevation, _props$variant = props.variant, variant = _props$variant === void 0 ? "elevation" : _props$variant, other = _objectWithoutProperties(props, ["classes", "className", "component", "square", "elevation", "variant"]);
  return /* @__PURE__ */ createElement8(Component5, _extends({
    className: clsx_m_default(classes.root, className, variant === "outlined" ? classes.outlined : classes["elevation".concat(elevation)], !square && classes.rounded),
    ref
  }, other));
});
false ? Paper.propTypes = {
  children: import_prop_types12.default.node,
  classes: import_prop_types12.default.object,
  className: import_prop_types12.default.string,
  component: import_prop_types12.default.elementType,
  elevation: chainPropTypes(import_prop_types12.default.number, function(props) {
    var classes = props.classes, elevation = props.elevation;
    if (classes === void 0) {
      return null;
    }
    if (elevation != null && classes["elevation".concat(elevation)] === void 0) {
      return new Error("Material-UI: This elevation `".concat(elevation, "` is not implemented."));
    }
    return null;
  }),
  square: import_prop_types12.default.bool,
  variant: import_prop_types12.default.oneOf(["elevation", "outlined"])
} : void 0;
var Paper_default = withStyles_default(styles9, {
  name: "MuiPaper"
})(Paper);

// node_modules/@material-ui/core/esm/Card/Card.js
var styles11 = {
  root: {
    overflow: "hidden"
  }
};
var Card = /* @__PURE__ */ forwardRef9(function Card2(props, ref) {
  var classes = props.classes, className = props.className, _props$raised = props.raised, raised = _props$raised === void 0 ? false : _props$raised, other = _objectWithoutProperties(props, ["classes", "className", "raised"]);
  return /* @__PURE__ */ createElement9(Paper_default, _extends({
    className: clsx_m_default(classes.root, className),
    elevation: raised ? 8 : 1,
    ref
  }, other));
});
false ? Card.propTypes = {
  children: import_prop_types13.default.node,
  classes: import_prop_types13.default.object,
  className: import_prop_types13.default.string,
  raised: import_prop_types13.default.bool
} : void 0;
var Card_default = withStyles_default(styles11, {
  name: "MuiCard"
})(Card);

// src/client/components/Card/Card.tsx
var BaseCard = (props) => /* @__PURE__ */ React21.createElement(Card_default, {
  ...props
});
function spacing(theme6, value) {
  if (theme6 && typeof theme6.spacing === "function") {
    return theme6.spacing(value);
  }
  return 0;
}
var Card3 = styled6(BaseCard)`
  ${(props) => props.p ? css`
          padding: ${spacing(props.theme, props.p)}px;
        ` : ""}
`;
var Card_default2 = Card3;

// src/client/components/Typography/Typography.tsx
import React22 from "https://cdn.skypack.dev/react";
import styled7 from "https://cdn.skypack.dev/styled-components";
var BaseTypography = (props) => /* @__PURE__ */ React22.createElement(Typography_default, {
  ...props
});
var Typography = styled7(BaseTypography)``;
var Typography_default2 = Typography;

// src/client/components/Emoji/Emoji.tsx
import React23 from "https://cdn.skypack.dev/react";
import styled8 from "https://cdn.skypack.dev/styled-components";
var Wrapper = styled8.span((props) => ({
  fontSize: props.size ? `${props.size}px` : "inherit"
}));
var Emoji = ({emoji, ariaLabel, size}) => /* @__PURE__ */ React23.createElement(Wrapper, {
  "aria-label": ariaLabel,
  role: "img",
  size
}, emoji);
var Emoji_default = Emoji;

// src/client/components/Error/View.tsx
var ErrorView = (props) => {
  const emoji = /* @__PURE__ */ createElement10(Emoji_default, {
    ariaLabel: "cry",
    emoji: props.emoji || "\u{1F62D}",
    size: 40
  });
  const title = props.title !== void 0 ? props.title : "Something unexpected happened";
  const subheader = props.subheader !== void 0 ? props.subheader : "We're sorry about that.";
  const error = props.error;
  const errorInfo = props.errorInfo;
  const maxWidth = props.maxWidth;
  const errorDetail = error ? `${error.stack}` : `No error available`;
  const errorInfoDetail = errorInfo ? `ComponentStack: ${errorInfo.componentStack}` : `No react errorInfo available`;
  const issueUrl = import_new_github_issue_url.default({
    user: "opstrace",
    repo: "opstrace",
    labels: ["bug"],
    body: `


---
${errorDetail}

${errorInfoDetail}`
  });
  const defaultContent = /* @__PURE__ */ createElement10(Typography_default2, null, "Our bug tracker has got it, but if you like, you can also file a Github Issue. We'll include the details of what went wrong for you", " ", /* @__PURE__ */ createElement10(Emoji_default, {
    ariaLabel: "helpful-nerd",
    emoji: "\u{1F913}"
  }));
  const defaultActions = /* @__PURE__ */ createElement10(CardActions_default2, null, /* @__PURE__ */ createElement10(Button_default, {
    variant: "contained",
    onClick: () => {
      const win = window.open(issueUrl, "_blank");
      win && win.focus();
    }
  }, "Open Github Issue"), /* @__PURE__ */ createElement10(Button_default, {
    variant: "outlined",
    onClick: () => window.location.reload(true)
  }, "Refresh"));
  const content = props.message ? /* @__PURE__ */ createElement10(Typography_default2, null, props.message) : props.children ? props.children : defaultContent;
  return /* @__PURE__ */ createElement10(Box_default, {
    maxWidth
  }, /* @__PURE__ */ createElement10(Card_default2, {
    variant: "outlined",
    p: 2
  }, /* @__PURE__ */ createElement10(CardHeader_default2, {
    avatar: emoji,
    title,
    subheader
  }), /* @__PURE__ */ createElement10(CardContent_default2, null, content), /* @__PURE__ */ createElement10(Box_default, {
    p: 1
  }, props.actions !== void 0 ? props.actions : defaultActions)));
};
var View_default = ErrorView;

// src/client/components/Error/Boundary.tsx
var ErrorBoundary = class extends Component2 {
  constructor() {
    super(...arguments);
    this.state = {};
    this.componentDidCatch = (error, errorInfo) => {
      this.setState({
        error,
        errorInfo
      });
    };
  }
  render() {
    let content = this.props.children;
    if (this.state.errorInfo) {
      if (this.props.errorComponent) {
        content = /* @__PURE__ */ createElement11(this.props.errorComponent, {
          error: this.state.error,
          errorInfo: this.state.errorInfo
        });
      } else {
        content = /* @__PURE__ */ createElement11(View_default, {
          maxWidth: 400,
          error: this.state.error,
          errorInfo: this.state.errorInfo
        });
      }
    }
    if (this.props.fullPage) {
      return /* @__PURE__ */ createElement11(Box_default, {
        width: "100vw",
        height: "100vh",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        flexWrap: "wrap",
        p: 0
      }, content);
    }
    return content;
  }
};
var Boundary_default = ErrorBoundary;

// src/client/themes/light.ts
var import_deepmerge = __toModule(require_cjs());

// node_modules/@material-ui/core/esm/colors/purple.js
var purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
var purple_default = purple;

// node_modules/@material-ui/core/esm/colors/lightBlue.js
var lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
var lightBlue_default = lightBlue;

// node_modules/@material-ui/core/esm/colors/teal.js
var teal = {
  50: "#e0f2f1",
  100: "#b2dfdb",
  200: "#80cbc4",
  300: "#4db6ac",
  400: "#26a69a",
  500: "#009688",
  600: "#00897b",
  700: "#00796b",
  800: "#00695c",
  900: "#004d40",
  A100: "#a7ffeb",
  A200: "#64ffda",
  A400: "#1de9b6",
  A700: "#00bfa5"
};
var teal_default = teal;

// node_modules/@material-ui/core/esm/colors/lightGreen.js
var lightGreen = {
  50: "#f1f8e9",
  100: "#dcedc8",
  200: "#c5e1a5",
  300: "#aed581",
  400: "#9ccc65",
  500: "#8bc34a",
  600: "#7cb342",
  700: "#689f38",
  800: "#558b2f",
  900: "#33691e",
  A100: "#ccff90",
  A200: "#b2ff59",
  A400: "#76ff03",
  A700: "#64dd17"
};
var lightGreen_default = lightGreen;

// node_modules/@material-ui/core/esm/colors/amber.js
var amber = {
  50: "#fff8e1",
  100: "#ffecb3",
  200: "#ffe082",
  300: "#ffd54f",
  400: "#ffca28",
  500: "#ffc107",
  600: "#ffb300",
  700: "#ffa000",
  800: "#ff8f00",
  900: "#ff6f00",
  A100: "#ffe57f",
  A200: "#ffd740",
  A400: "#ffc400",
  A700: "#ffab00"
};
var amber_default = amber;

// node_modules/@material-ui/core/esm/colors/deepOrange.js
var deepOrange = {
  50: "#fbe9e7",
  100: "#ffccbc",
  200: "#ffab91",
  300: "#ff8a65",
  400: "#ff7043",
  500: "#ff5722",
  600: "#f4511e",
  700: "#e64a19",
  800: "#d84315",
  900: "#bf360c",
  A100: "#ff9e80",
  A200: "#ff6e40",
  A400: "#ff3d00",
  A700: "#dd2c00"
};
var deepOrange_default = deepOrange;

// node_modules/@material-ui/core/esm/colors/brown.js
var brown = {
  50: "#efebe9",
  100: "#d7ccc8",
  200: "#bcaaa4",
  300: "#a1887f",
  400: "#8d6e63",
  500: "#795548",
  600: "#6d4c41",
  700: "#5d4037",
  800: "#4e342e",
  900: "#3e2723",
  A100: "#d7ccc8",
  A200: "#bcaaa4",
  A400: "#8d6e63",
  A700: "#5d4037"
};
var brown_default = brown;

// node_modules/@material-ui/core/esm/colors/blueGrey.js
var blueGrey = {
  50: "#eceff1",
  100: "#cfd8dc",
  200: "#b0bec5",
  300: "#90a4ae",
  400: "#78909c",
  500: "#607d8b",
  600: "#546e7a",
  700: "#455a64",
  800: "#37474f",
  900: "#263238",
  A100: "#cfd8dc",
  A200: "#b0bec5",
  A400: "#78909c",
  A700: "#455a64"
};
var blueGrey_default = blueGrey;

// src/client/themes/common.ts
var common = {
  overrides: {
    MuiTab: {
      root: {
        minWidth: "48px",
        "@media (min-width: 0px)": {
          minWidth: "48px"
        }
      }
    }
  },
  props: {
    MuiBackdrop: {
      transitionDuration: 0
    },
    MuiDialog: {
      transitionDuration: 0
    }
  },
  palette: {
    primary: {
      main: "#F54773",
      contrastText: common_default.white
    },
    secondary: {
      main: blue_default.A400,
      contrastText: common_default.white
    },
    success: {
      main: green_default.A400,
      contrastText: common_default.black
    },
    warning: {
      main: amber_default.A400,
      contrastText: common_default.black
    },
    error: {
      main: deepOrange_default.A400,
      contrastText: common_default.white
    },
    info: {
      main: blueGrey_default[200],
      contrastText: common_default.black
    },
    contrastThreshold: 3
  },
  typography: {
    fontFamily: [
      "-apple-system",
      "BlinkMacSystemFont",
      '"Segoe UI"',
      "Roboto",
      '"Helvetica Neue"',
      "Arial",
      "sans-serif",
      '"Apple Color Emoji"',
      '"Segoe UI Emoji"',
      '"Segoe UI Symbol"'
    ].join(","),
    button: {
      textTransform: "none"
    },
    body2: {
      fontSize: 13,
      fontWeight: 500,
      lineHeight: 1
    }
  },
  shape: {
    borderRadius: 2
  }
};
var common_default2 = common;

// src/client/themes/light.ts
var theme = {
  name: "light",
  palette: {
    type: "light"
  }
};
var light_default = createMuiTheme_default(import_deepmerge.default(common_default2, theme));

// src/client/themes/dark.ts
var import_deepmerge2 = __toModule(require_cjs());
var theme2 = {
  name: "dark",
  palette: {
    type: "dark",
    background: {
      default: common_default.black,
      paper: common_default.black
    },
    divider: grey_default[800]
  },
  overrides: {
    MuiBackdrop: {
      root: {
        backgroundColor: "rgba(255, 255, 255, 0.1)"
      }
    }
  }
};
var dark_default = createMuiTheme_default(import_deepmerge2.default(common_default2, theme2));

// src/client/themes/Provider.tsx
import React47, {useCallback as useCallback8} from "https://cdn.skypack.dev/react";

// ../../node_modules/monaco-editor/esm/vs/base/common/errors.js
function onUnexpectedExternalError(e) {
  if (!isPromiseCanceledError(e)) {
    errorHandler.onUnexpectedExternalError(e);
  }
  return void 0;
}

// ../../node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
var MutableDisposable = class {
  constructor() {
    this._isDisposed = false;
    trackDisposable(this);
  }
  get value() {
    return this._isDisposed ? void 0 : this._value;
  }
  set value(value) {
    if (this._isDisposed || value === this._value) {
      return;
    }
    if (this._value) {
      this._value.dispose();
    }
    if (value) {
      markTracked(value);
    }
    this._value = value;
  }
  clear() {
    this.value = void 0;
  }
  dispose() {
    this._isDisposed = true;
    markTracked(this);
    if (this._value) {
      this._value.dispose();
    }
    this._value = void 0;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/event.js
function stop(event) {
  return Event.map(event, (e) => {
    e.preventDefault();
    e.stopPropagation();
    return e;
  });
}

// ../../node_modules/monaco-editor/esm/vs/base/common/async.js
function raceCancellation(promise3, token, defaultValue) {
  return Promise.race([promise3, new Promise((resolve) => token.onCancellationRequested(() => resolve(defaultValue)))]);
}
function first(promiseFactories, shouldStop = (t) => !!t, defaultValue = null) {
  let index2 = 0;
  const len = promiseFactories.length;
  const loop = () => {
    if (index2 >= len) {
      return Promise.resolve(defaultValue);
    }
    const factory = promiseFactories[index2++];
    const promise3 = Promise.resolve(factory());
    return promise3.then((result) => {
      if (shouldStop(result)) {
        return Promise.resolve(result);
      }
      return loop();
    });
  };
  return loop();
}

// ../../node_modules/monaco-editor/esm/vs/base/common/arrays.js
function findFirstInSorted(array4, p) {
  let low = 0, high = array4.length;
  if (high === 0) {
    return 0;
  }
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    if (p(array4[mid])) {
      high = mid;
    } else {
      low = mid + 1;
    }
  }
  return low;
}
function groupBy(data, compare2) {
  const result = [];
  let currentGroup = void 0;
  for (const element of mergeSort(data.slice(0), compare2)) {
    if (!currentGroup || compare2(currentGroup[0], element) !== 0) {
      currentGroup = [element];
      result.push(currentGroup);
    } else {
      currentGroup.push(element);
    }
  }
  return result;
}
function flatten(arr) {
  return [].concat(...arr);
}
function pushToStart(arr, value) {
  const index2 = arr.indexOf(value);
  if (index2 > -1) {
    arr.splice(index2, 1);
    arr.unshift(value);
  }
}
function pushToEnd(arr, value) {
  const index2 = arr.indexOf(value);
  if (index2 > -1) {
    arr.splice(index2, 1);
    arr.push(value);
  }
}
function asArray(x) {
  return Array.isArray(x) ? x : [x];
}

// ../../node_modules/monaco-editor/esm/vs/base/browser/dom.js
var addStandardDisposableGenericMouseDownListner = function addStandardDisposableListener2(node, handler, useCapture) {
  let wrapHandler = _wrapAsStandardMouseEvent(handler);
  return addDisposableGenericMouseDownListner(node, wrapHandler, useCapture);
};
function addDisposableGenericMouseDownListner(node, handler, useCapture) {
  return addDisposableListener(node, isIOS && BrowserFeatures.pointerEvents ? EventType2.POINTER_DOWN : EventType2.MOUSE_DOWN, handler, useCapture);
}
function addDisposableGenericMouseUpListner(node, handler, useCapture) {
  return addDisposableListener(node, isIOS && BrowserFeatures.pointerEvents ? EventType2.POINTER_UP : EventType2.MOUSE_UP, handler, useCapture);
}

// ../../node_modules/monaco-editor/esm/vs/base/common/strings.js
function pad(n, l, char = "0") {
  const str = "" + n;
  const r = [str];
  for (let i = str.length; i < l; i++) {
    r.push(char);
  }
  return r.reverse().join("");
}
function trim(haystack, needle = " ") {
  const trimmed = ltrim(haystack, needle);
  return rtrim(trimmed, needle);
}
function stripWildcards(pattern3) {
  return pattern3.replace(/\*/g, "");
}
function compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    let codeA = a.charCodeAt(aStart);
    let codeB = b.charCodeAt(bStart);
    if (codeA < codeB) {
      return -1;
    } else if (codeA > codeB) {
      return 1;
    }
  }
  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;
  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }
  return 0;
}
function compareIgnoreCase(a, b) {
  return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);
}
function compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    let codeA = a.charCodeAt(aStart);
    let codeB = b.charCodeAt(bStart);
    if (codeA === codeB) {
      continue;
    }
    const diff = codeA - codeB;
    if (diff === 32 && isUpperAsciiLetter(codeB)) {
      continue;
    } else if (diff === -32 && isUpperAsciiLetter(codeA)) {
      continue;
    }
    if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {
      return diff;
    } else {
      return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);
    }
  }
  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;
  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }
  return 0;
}
function containsUppercaseCharacter(target, ignoreEscapedChars = false) {
  if (!target) {
    return false;
  }
  if (ignoreEscapedChars) {
    target = target.replace(/\\./g, "");
  }
  return target.toLowerCase() !== target;
}

// ../../node_modules/monaco-editor/esm/vs/base/common/types.js
function isArray(array4) {
  return Array.isArray(array4);
}
function assertType(condition, type) {
  if (!condition) {
    throw new Error(type ? `Unexpected type, expected '${type}'` : "Unexpected type");
  }
}
function assertIsDefined(arg) {
  if (isUndefinedOrNull(arg)) {
    throw new Error("Assertion Failed: argument is undefined or null");
  }
  return arg;
}

// ../../node_modules/monaco-editor/esm/vs/base/common/objects.js
function cloneAndChange(obj, changer) {
  return _cloneAndChange(obj, changer, new Set());
}
function _cloneAndChange(obj, changer, seen) {
  if (isUndefinedOrNull(obj)) {
    return obj;
  }
  const changed = changer(obj);
  if (typeof changed !== "undefined") {
    return changed;
  }
  if (isArray(obj)) {
    const r1 = [];
    for (const e of obj) {
      r1.push(_cloneAndChange(e, changer, seen));
    }
    return r1;
  }
  if (isObject(obj)) {
    if (seen.has(obj)) {
      throw new Error("Cannot clone recursive data-structure");
    }
    seen.add(obj);
    const r2 = {};
    for (let i2 in obj) {
      if (_hasOwnProperty.call(obj, i2)) {
        r2[i2] = _cloneAndChange(obj[i2], changer, seen);
      }
    }
    seen.delete(obj);
    return r2;
  }
  return obj;
}

// ../../node_modules/monaco-editor/esm/vs/base/common/map.js
var StringIterator = class {
  constructor() {
    this._value = "";
    this._pos = 0;
  }
  reset(key) {
    this._value = key;
    this._pos = 0;
    return this;
  }
  next() {
    this._pos += 1;
    return this;
  }
  hasNext() {
    return this._pos < this._value.length - 1;
  }
  cmp(a) {
    const aCode = a.charCodeAt(0);
    const thisCode = this._value.charCodeAt(this._pos);
    return aCode - thisCode;
  }
  value() {
    return this._value[this._pos];
  }
};
var PathIterator = class {
  constructor(_splitOnBackslash = true, _caseSensitive = true) {
    this._splitOnBackslash = _splitOnBackslash;
    this._caseSensitive = _caseSensitive;
  }
  reset(key) {
    this._value = key.replace(/\\$|\/$/, "");
    this._from = 0;
    this._to = 0;
    return this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let justSeps = true;
    for (; this._to < this._value.length; this._to++) {
      const ch = this._value.charCodeAt(this._to);
      if (ch === 47 || this._splitOnBackslash && ch === 92) {
        if (justSeps) {
          this._from++;
        } else {
          break;
        }
      } else {
        justSeps = false;
      }
    }
    return this;
  }
  cmp(a) {
    return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
};
var UriIterator = class {
  constructor() {
    this._states = [];
    this._stateIdx = 0;
  }
  reset(key) {
    this._value = key;
    this._states = [];
    if (this._value.scheme) {
      this._states.push(1);
    }
    if (this._value.authority) {
      this._states.push(2);
    }
    if (this._value.path) {
      const caseSensitive = key.scheme === Schemas.file && isLinux;
      this._pathIterator = new PathIterator(false, caseSensitive);
      this._pathIterator.reset(key.path);
      if (this._pathIterator.value()) {
        this._states.push(3);
      }
    }
    if (this._value.query) {
      this._states.push(4);
    }
    if (this._value.fragment) {
      this._states.push(5);
    }
    this._stateIdx = 0;
    return this;
  }
  next() {
    if (this._states[this._stateIdx] === 3 && this._pathIterator.hasNext()) {
      this._pathIterator.next();
    } else {
      this._stateIdx += 1;
    }
    return this;
  }
  hasNext() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
  }
  cmp(a) {
    if (this._states[this._stateIdx] === 1) {
      return compare(a, this._value.scheme);
    } else if (this._states[this._stateIdx] === 2) {
      return compareSubstringIgnoreCase(a, this._value.authority);
    } else if (this._states[this._stateIdx] === 3) {
      return this._pathIterator.cmp(a);
    } else if (this._states[this._stateIdx] === 4) {
      return compare(a, this._value.query);
    } else if (this._states[this._stateIdx] === 5) {
      return compare(a, this._value.fragment);
    }
    throw new Error();
  }
  value() {
    if (this._states[this._stateIdx] === 1) {
      return this._value.scheme;
    } else if (this._states[this._stateIdx] === 2) {
      return this._value.authority;
    } else if (this._states[this._stateIdx] === 3) {
      return this._pathIterator.value();
    } else if (this._states[this._stateIdx] === 4) {
      return this._value.query;
    } else if (this._states[this._stateIdx] === 5) {
      return this._value.fragment;
    }
    throw new Error();
  }
};
var TernarySearchTreeNode = class {
};
var TernarySearchTree = class {
  constructor(segments) {
    this._iter = segments;
  }
  static forUris() {
    return new TernarySearchTree(new UriIterator());
  }
  static forStrings() {
    return new TernarySearchTree(new StringIterator());
  }
  clear() {
    this._root = void 0;
  }
  set(key, element) {
    const iter = this._iter.reset(key);
    let node;
    if (!this._root) {
      this._root = new TernarySearchTreeNode();
      this._root.segment = iter.value();
    }
    node = this._root;
    while (true) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        if (!node.left) {
          node.left = new TernarySearchTreeNode();
          node.left.segment = iter.value();
        }
        node = node.left;
      } else if (val < 0) {
        if (!node.right) {
          node.right = new TernarySearchTreeNode();
          node.right.segment = iter.value();
        }
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        if (!node.mid) {
          node.mid = new TernarySearchTreeNode();
          node.mid.segment = iter.value();
        }
        node = node.mid;
      } else {
        break;
      }
    }
    const oldElement = node.value;
    node.value = element;
    node.key = key;
    return oldElement;
  }
  get(key) {
    const iter = this._iter.reset(key);
    let node = this._root;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        node = node.left;
      } else if (val < 0) {
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        node = node.mid;
      } else {
        break;
      }
    }
    return node ? node.value : void 0;
  }
  findSubstr(key) {
    const iter = this._iter.reset(key);
    let node = this._root;
    let candidate = void 0;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        node = node.left;
      } else if (val < 0) {
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        candidate = node.value || candidate;
        node = node.mid;
      } else {
        break;
      }
    }
    return node && node.value || candidate;
  }
  forEach(callback) {
    this._forEach(this._root, callback);
  }
  _forEach(node, callback) {
    if (node) {
      this._forEach(node.left, callback);
      if (node.value) {
        callback(node.value, node.key);
      }
      this._forEach(node.mid, callback);
      this._forEach(node.right, callback);
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/filters.js
function isWordSeparator(code3) {
  return isWhitespace(code3) || wordSeparators.has(code3);
}
function charactersMatch(codeA, codeB) {
  return codeA === codeB || isWordSeparator(codeA) && isWordSeparator(codeB);
}
function matchesWords(word, target, contiguous = false) {
  if (!target || target.length === 0) {
    return null;
  }
  let result = null;
  let i = 0;
  word = word.toLowerCase();
  target = target.toLowerCase();
  while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {
    i = nextWord(target, i + 1);
  }
  return result;
}
function _matchesWords(word, target, i, j, contiguous) {
  if (i === word.length) {
    return [];
  } else if (j === target.length) {
    return null;
  } else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {
    return null;
  } else {
    let result = null;
    let nextWordIndex = j + 1;
    result = _matchesWords(word, target, i + 1, j + 1, contiguous);
    if (!contiguous) {
      while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {
        result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);
        nextWordIndex++;
      }
    }
    return result === null ? null : join({start: j, end: j + 1}, result);
  }
}
function nextWord(word, start) {
  for (let i = start; i < word.length; i++) {
    if (isWordSeparator(word.charCodeAt(i)) || i > 0 && isWordSeparator(word.charCodeAt(i - 1))) {
      return i;
    }
  }
  return word.length;
}
function anyScore(pattern3, lowPattern, _patternPos, word, lowWord, _wordPos) {
  const result = fuzzyScore(pattern3, lowPattern, 0, word, lowWord, 0, true);
  if (result) {
    return result;
  }
  let matches = 0;
  let score = 0;
  let idx = _wordPos;
  for (let patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {
    const wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);
    if (wordPos >= 0) {
      score += 1;
      matches += Math.pow(2, wordPos);
      idx = wordPos + 1;
    } else if (matches !== 0) {
      break;
    }
  }
  return [score, matches, _wordPos];
}
function createMatches(score) {
  if (typeof score === "undefined") {
    return [];
  }
  const matches = score[1].toString(2);
  const wordStart = score[2];
  const res = [];
  for (let pos = wordStart; pos < _maxLen; pos++) {
    if (matches[matches.length - (pos + 1)] === "1") {
      const last = res[res.length - 1];
      if (last && last.end === pos) {
        last.end = pos + 1;
      } else {
        res.push({start: pos, end: pos + 1});
      }
    }
  }
  return res;
}
function fuzzyScoreGracefulAggressive(pattern3, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {
  return fuzzyScoreWithPermutations(pattern3, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);
}
function fuzzyScoreWithPermutations(pattern3, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {
  let top = fuzzyScore(pattern3, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);
  if (top && !aggressive) {
    return top;
  }
  if (pattern3.length >= 3) {
    const tries = Math.min(7, pattern3.length - 1);
    for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {
      const newPattern = nextTypoPermutation(pattern3, movingPatternPos);
      if (newPattern) {
        const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);
        if (candidate) {
          candidate[0] -= 3;
          if (!top || candidate[0] > top[0]) {
            top = candidate;
          }
        }
      }
    }
  }
  return top;
}
function nextTypoPermutation(pattern3, patternPos) {
  if (patternPos + 1 >= pattern3.length) {
    return void 0;
  }
  const swap1 = pattern3[patternPos];
  const swap2 = pattern3[patternPos + 1];
  if (swap1 === swap2) {
    return void 0;
  }
  return pattern3.slice(0, patternPos) + swap2 + swap1 + pattern3.slice(patternPos + 2);
}

// ../../node_modules/monaco-editor/esm/vs/base/common/codicons.js
var escapeCodiconsRegex = /(\\)?\$\([a-z0-9\-]+?(?:~[a-z0-9\-]*?)?\)/gi;
function escapeCodicons(text) {
  return text.replace(escapeCodiconsRegex, (match, escaped) => escaped ? match : `\\${match}`);
}
var markdownEscapedCodiconsRegex = /\\\$\([a-z0-9\-]+?(?:~[a-z0-9\-]*?)?\)/gi;
function markdownEscapeEscapedCodicons(text) {
  return text.replace(markdownEscapedCodiconsRegex, (match) => `\\${match}`);
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes.js
function isLocationLink(thing) {
  return thing && URI.isUri(thing.uri) && Range2.isIRange(thing.range) && (Range2.isIRange(thing.originSelectionRange) || Range2.isIRange(thing.targetSelectionRange));
}

// ../../node_modules/monaco-editor/esm/vs/base/common/hash.js
function hash(obj) {
  return doHash(obj, 0);
}
function doHash(obj, hashVal) {
  switch (typeof obj) {
    case "object":
      if (obj === null) {
        return numberHash(349, hashVal);
      } else if (Array.isArray(obj)) {
        return arrayHash(obj, hashVal);
      }
      return objectHash(obj, hashVal);
    case "string":
      return stringHash(obj, hashVal);
    case "boolean":
      return booleanHash(obj, hashVal);
    case "number":
      return numberHash(obj, hashVal);
    case "undefined":
      return numberHash(937, hashVal);
    default:
      return numberHash(617, hashVal);
  }
}
function booleanHash(b, initialHashVal) {
  return numberHash(b ? 433 : 863, initialHashVal);
}
function arrayHash(arr, initialHashVal) {
  initialHashVal = numberHash(104579, initialHashVal);
  return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);
}
function objectHash(obj, initialHashVal) {
  initialHashVal = numberHash(181387, initialHashVal);
  return Object.keys(obj).sort().reduce((hashVal, key) => {
    hashVal = stringHash(key, hashVal);
    return doHash(obj[key], hashVal);
  }, initialHashVal);
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js
var CharacterSet = class {
  constructor() {
    this._actual = new CharacterClassifier(0);
  }
  add(charCode) {
    this._actual.set(charCode, 1);
  }
  has(charCode) {
    return this._actual.get(charCode) === 1;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/editorBrowser.js
function isDiffEditor(thing) {
  if (thing && typeof thing.getEditorType === "function") {
    return thing.getEditorType() === EditorType.IDiffEditor;
  } else {
    return false;
  }
}
function getCodeEditor(thing) {
  if (isCodeEditor(thing)) {
    return thing;
  }
  if (isDiffEditor(thing)) {
    return thing.getModifiedEditor();
  }
  return null;
}

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/aria/aria.js
function status(msg) {
  if (!ariaContainer) {
    return;
  }
  if (isMacintosh) {
    alert(msg);
  } else {
    if (statusContainer.textContent !== msg) {
      clearNode(statusContainer2);
      insertMessage(statusContainer, msg);
    } else {
      clearNode(statusContainer);
      insertMessage(statusContainer2, msg);
    }
  }
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/editorExtensions.js
var MultiEditorAction = class extends EditorAction {
  constructor(opts) {
    super(opts);
    this._implementations = [];
  }
  runEditorCommand(accessor, editor3, args) {
    this.reportTelemetry(accessor, editor3);
    for (const impl of this._implementations) {
      if (impl[1](accessor, args)) {
        return;
      }
    }
    return this.run(accessor, editor3, args || {});
  }
};
function registerLanguageCommand(id, handler) {
  CommandsRegistry.registerCommand(id, (accessor, args) => handler(accessor, args || {}));
}
function registerDefaultLanguageCommand(id, handler) {
  registerLanguageCommand(id, function(accessor, args) {
    const {resource, position} = args;
    if (!(resource instanceof URI)) {
      throw illegalArgument("resource");
    }
    if (!Position.isIPosition(position)) {
      throw illegalArgument("position");
    }
    const model = accessor.get(IModelService).getModel(resource);
    if (model) {
      const editorPosition = Position.lift(position);
      return handler(model, editorPosition, args);
    }
    return accessor.get(ITextModelService).createModelReference(resource).then((reference) => {
      return new Promise((resolve, reject) => {
        try {
          const result = handler(reference.object.textEditorModel, Position.lift(position), args);
          resolve(result);
        } catch (err) {
          reject(err);
        }
      }).finally(() => {
        reference.dispose();
      });
    });
  });
}
function registerModelAndPositionCommand(id, handler) {
  CommandsRegistry.registerCommand(id, function(accessor, ...args) {
    const [resource, position] = args;
    assertType(URI.isUri(resource));
    assertType(Position.isIPosition(position));
    const model = accessor.get(IModelService).getModel(resource);
    if (model) {
      const editorPosition = Position.lift(position);
      return handler(model, editorPosition, ...args.slice(2));
    }
    return accessor.get(ITextModelService).createModelReference(resource).then((reference) => {
      return new Promise((resolve, reject) => {
        try {
          const result = handler(reference.object.textEditorModel, Position.lift(position), args.slice(2));
          resolve(result);
        } catch (err) {
          reject(err);
        }
      }).finally(() => {
        reference.dispose();
      });
    });
  });
}
function registerModelCommand(id, handler) {
  CommandsRegistry.registerCommand(id, function(accessor, ...args) {
    const [resource] = args;
    assertType(URI.isUri(resource));
    const model = accessor.get(IModelService).getModel(resource);
    if (model) {
      return handler(model, ...args.slice(1));
    }
    return accessor.get(ITextModelService).createModelReference(resource).then((reference) => {
      return new Promise((resolve, reject) => {
        try {
          const result = handler(reference.object.textEditorModel, args.slice(1));
          resolve(result);
        } catch (err) {
          reject(err);
        }
      }).finally(() => {
        reference.dispose();
      });
    });
  });
}
function registerMultiEditorAction(action) {
  EditorContributionRegistry.INSTANCE.registerEditorAction(action);
  return action;
}
function registerInstantiatedEditorAction(editorAction) {
  EditorContributionRegistry.INSTANCE.registerEditorAction(editorAction);
}

// ../../node_modules/monaco-editor/esm/vs/platform/theme/common/colorRegistry.js
function oneOf(...colorValues) {
  return (theme6) => {
    for (let colorValue of colorValues) {
      let color = resolveColorValue(colorValue, theme6);
      if (color) {
        return color;
      }
    }
    return void 0;
  };
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/commands/replaceCommand.js
var ReplaceCommandThatSelectsText = class {
  constructor(range2, text) {
    this._range = range2;
    this._text = text;
  }
  getEditOperations(model, builder) {
    builder.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(model, helper) {
    const inverseEditOperations = helper.getInverseEditOperations();
    const srcRange = inverseEditOperations[0].range;
    return new Selection(srcRange.startLineNumber, srcRange.startColumn, srcRange.endLineNumber, srcRange.endColumn);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorWordOperations.js
var WordPartOperations = class extends WordOperations {
  static deleteWordPartLeft(wordSeparators2, model, selection, whitespaceHeuristics) {
    const candidates = enforceDefined([
      WordOperations.deleteWordLeft(wordSeparators2, model, selection, whitespaceHeuristics, 0),
      WordOperations.deleteWordLeft(wordSeparators2, model, selection, whitespaceHeuristics, 2),
      WordOperations._deleteWordPartLeft(model, selection)
    ]);
    candidates.sort(Range2.compareRangesUsingEnds);
    return candidates[2];
  }
  static deleteWordPartRight(wordSeparators2, model, selection, whitespaceHeuristics) {
    const candidates = enforceDefined([
      WordOperations.deleteWordRight(wordSeparators2, model, selection, whitespaceHeuristics, 0),
      WordOperations.deleteWordRight(wordSeparators2, model, selection, whitespaceHeuristics, 2),
      WordOperations._deleteWordPartRight(model, selection)
    ]);
    candidates.sort(Range2.compareRangesUsingStarts);
    return candidates[0];
  }
  static moveWordPartLeft(wordSeparators2, model, position) {
    const candidates = enforceDefined([
      WordOperations.moveWordLeft(wordSeparators2, model, position, 0),
      WordOperations.moveWordLeft(wordSeparators2, model, position, 2),
      WordOperations._moveWordPartLeft(model, position)
    ]);
    candidates.sort(Position.compare);
    return candidates[2];
  }
  static moveWordPartRight(wordSeparators2, model, position) {
    const candidates = enforceDefined([
      WordOperations.moveWordRight(wordSeparators2, model, position, 0),
      WordOperations.moveWordRight(wordSeparators2, model, position, 2),
      WordOperations._moveWordPartRight(model, position)
    ]);
    candidates.sort(Position.compare);
    return candidates[0];
  }
};
function enforceDefined(arr) {
  return arr.filter((el) => Boolean(el));
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/textToHtmlTokenizer.js
var fallback = {
  getInitialState: () => NULL_STATE,
  tokenize2: (buffer2, state, deltaOffset) => nullTokenize2(0, buffer2, state, deltaOffset)
};
function tokenizeToString(text, tokenizationSupport = fallback) {
  return _tokenizeToString(text, tokenizationSupport || fallback);
}
function _tokenizeToString(text, tokenizationSupport) {
  let result = `<div class="monaco-tokenized-source">`;
  let lines = text.split(/\r\n|\r|\n/);
  let currentState = tokenizationSupport.getInitialState();
  for (let i = 0, len = lines.length; i < len; i++) {
    let line = lines[i];
    if (i > 0) {
      result += `<br/>`;
    }
    let tokenizationResult = tokenizationSupport.tokenize2(line, currentState, 0);
    LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);
    let lineTokens = new LineTokens(tokenizationResult.tokens, line);
    let viewLineTokens = lineTokens.inflate();
    let startOffset = 0;
    for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {
      const type = viewLineTokens.getClassName(j);
      const endIndex = viewLineTokens.getEndOffset(j);
      result += `<span class="${type}">${escape(line.substring(startOffset, endIndex))}</span>`;
      startOffset = endIndex;
    }
    currentState = tokenizationResult.endState;
  }
  result += `</div>`;
  return result;
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/core/keybindingCancellation.js
var EditorKeybindingCancellationTokenSource = class extends CancellationTokenSource {
  constructor(editor3, parent2) {
    super(parent2);
    this.editor = editor3;
    this._unregister = editor3.invokeWithinContext((accessor) => accessor.get(IEditorCancellationTokens).add(editor3, this));
  }
  dispose() {
    this._unregister();
    super.dispose();
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/core/editorState.js
var EditorState = class {
  constructor(editor3, flags) {
    this.flags = flags;
    if ((this.flags & 1) !== 0) {
      const model = editor3.getModel();
      this.modelVersionId = model ? format("{0}#{1}", model.uri.toString(), model.getVersionId()) : null;
    } else {
      this.modelVersionId = null;
    }
    if ((this.flags & 4) !== 0) {
      this.position = editor3.getPosition();
    } else {
      this.position = null;
    }
    if ((this.flags & 2) !== 0) {
      this.selection = editor3.getSelection();
    } else {
      this.selection = null;
    }
    if ((this.flags & 8) !== 0) {
      this.scrollLeft = editor3.getScrollLeft();
      this.scrollTop = editor3.getScrollTop();
    } else {
      this.scrollLeft = -1;
      this.scrollTop = -1;
    }
  }
  _equals(other) {
    if (!(other instanceof EditorState)) {
      return false;
    }
    const state = other;
    if (this.modelVersionId !== state.modelVersionId) {
      return false;
    }
    if (this.scrollLeft !== state.scrollLeft || this.scrollTop !== state.scrollTop) {
      return false;
    }
    if (!this.position && state.position || this.position && !state.position || this.position && state.position && !this.position.equals(state.position)) {
      return false;
    }
    if (!this.selection && state.selection || this.selection && !state.selection || this.selection && state.selection && !this.selection.equalsRange(state.selection)) {
      return false;
    }
    return true;
  }
  validate(editor3) {
    return this._equals(new EditorState(editor3, this.flags));
  }
};
var EditorStateCancellationTokenSource = class extends EditorKeybindingCancellationTokenSource {
  constructor(editor3, flags, range2, parent2) {
    super(editor3, parent2);
    this.editor = editor3;
    this._listener = new DisposableStore();
    if (flags & 4) {
      this._listener.add(editor3.onDidChangeCursorPosition((e) => {
        if (!range2 || !Range2.containsPosition(range2, e.position)) {
          this.cancel();
        }
      }));
    }
    if (flags & 2) {
      this._listener.add(editor3.onDidChangeCursorSelection((e) => {
        if (!range2 || !Range2.containsRange(range2, e.selection)) {
          this.cancel();
        }
      }));
    }
    if (flags & 8) {
      this._listener.add(editor3.onDidScrollChange((_) => this.cancel()));
    }
    if (flags & 1) {
      this._listener.add(editor3.onDidChangeModel((_) => this.cancel()));
      this._listener.add(editor3.onDidChangeModelContent((_) => this.cancel()));
    }
  }
  dispose() {
    this._listener.dispose();
    super.dispose();
  }
};
var TextModelCancellationTokenSource = class extends CancellationTokenSource {
  constructor(model, parent2) {
    super(parent2);
    this._listener = model.onDidChangeContent(() => this.cancel());
  }
  dispose() {
    this._listener.dispose();
    super.dispose();
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/theme/common/styler.js
function attachBadgeStyler(widget, themeService, style) {
  return attachStyler(themeService, {
    badgeBackground: style && style.badgeBackground || badgeBackground,
    badgeForeground: style && style.badgeForeground || badgeForeground,
    badgeBorder: contrastBorder
  }, widget);
}

// ../../node_modules/monaco-editor/esm/vs/base/common/numbers.js
var MovingAverage = class {
  constructor() {
    this._n = 1;
    this._val = 0;
  }
  update(value) {
    this._val = this._val + (value - this._val) / this._n;
    this._n += 1;
    return this;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/navigator.js
var ArrayNavigator = class {
  constructor(items, start = 0, end = items.length, index2 = start - 1) {
    this.items = items;
    this.start = start;
    this.end = end;
    this.index = index2;
  }
  current() {
    if (this.index === this.start - 1 || this.index === this.end) {
      return null;
    }
    return this.items[this.index];
  }
  next() {
    this.index = Math.min(this.index + 1, this.end);
    return this.current();
  }
  previous() {
    this.index = Math.max(this.index - 1, this.start - 1);
    return this.current();
  }
  first() {
    this.index = this.start;
    return this.current();
  }
  last() {
    this.index = this.end - 1;
    return this.current();
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/history.js
var HistoryNavigator = class {
  constructor(history = [], limit = 10) {
    this._initialize(history);
    this._limit = limit;
    this._onChange();
  }
  add(t) {
    this._history.delete(t);
    this._history.add(t);
    this._onChange();
  }
  next() {
    if (this._currentPosition() !== this._elements.length - 1) {
      return this._navigator.next();
    }
    return null;
  }
  previous() {
    if (this._currentPosition() !== 0) {
      return this._navigator.previous();
    }
    return null;
  }
  current() {
    return this._navigator.current();
  }
  first() {
    return this._navigator.first();
  }
  last() {
    return this._navigator.last();
  }
  has(t) {
    return this._history.has(t);
  }
  _onChange() {
    this._reduceToLimit();
    const elements = this._elements;
    this._navigator = new ArrayNavigator(elements, 0, elements.length, elements.length);
  }
  _reduceToLimit() {
    const data = this._elements;
    if (data.length > this._limit) {
      this._initialize(data.slice(data.length - this._limit));
    }
  }
  _currentPosition() {
    const currentElement = this._navigator.current();
    if (!currentElement) {
      return -1;
    }
    return this._elements.indexOf(currentElement);
  }
  _initialize(history) {
    this._history = new Set();
    for (const entry of history) {
      this._history.add(entry);
    }
  }
  get _elements() {
    const elements = [];
    this._history.forEach((e) => elements.push(e));
    return elements;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.js
var HistoryInputBox = class extends InputBox {
  constructor(container, contextViewProvider, options) {
    super(container, contextViewProvider, options);
    this.history = new HistoryNavigator(options.history, 100);
  }
  addToHistory() {
    if (this.value && this.value !== this.getCurrentValue()) {
      this.history.add(this.value);
    }
  }
  showNextValue() {
    if (!this.history.has(this.value)) {
      this.addToHistory();
    }
    let next = this.getNextValue();
    if (next) {
      next = next === this.value ? this.getNextValue() : next;
    }
    if (next) {
      this.value = next;
      status(this.value);
    }
  }
  showPreviousValue() {
    if (!this.history.has(this.value)) {
      this.addToHistory();
    }
    let previous = this.getPreviousValue();
    if (previous) {
      previous = previous === this.value ? this.getPreviousValue() : previous;
    }
    if (previous) {
      this.value = previous;
      status(this.value);
    }
  }
  getCurrentValue() {
    let currentValue = this.history.current();
    if (!currentValue) {
      currentValue = this.history.last();
      this.history.next();
    }
    return currentValue;
  }
  getPreviousValue() {
    return this.history.previous() || this.history.first();
  }
  getNextValue() {
    return this.history.next() || this.history.last();
  }
};

// node_modules/@material-ui/core/esm/CssBaseline/CssBaseline.js
var import_prop_types14 = __toModule(require_prop_types());
import {
  Fragment,
  createElement as createElement12
} from "https://cdn.skypack.dev/react";
var html = {
  WebkitFontSmoothing: "antialiased",
  MozOsxFontSmoothing: "grayscale",
  boxSizing: "border-box"
};
var body = function body2(theme6) {
  return _extends({
    color: theme6.palette.text.primary
  }, theme6.typography.body2, {
    backgroundColor: theme6.palette.background.default,
    "@media print": {
      backgroundColor: theme6.palette.common.white
    }
  });
};
var styles12 = function styles13(theme6) {
  return {
    "@global": {
      html,
      "*, *::before, *::after": {
        boxSizing: "inherit"
      },
      "strong, b": {
        fontWeight: theme6.typography.fontWeightBold
      },
      body: _extends({
        margin: 0
      }, body(theme6), {
        "&::backdrop": {
          backgroundColor: theme6.palette.background.default
        }
      })
    }
  };
};
function CssBaseline(props) {
  var _props$children = props.children, children = _props$children === void 0 ? null : _props$children, classes = props.classes;
  return /* @__PURE__ */ createElement12(Fragment, null, children);
}
false ? CssBaseline.propTypes = {
  children: import_prop_types14.default.node,
  classes: import_prop_types14.default.object
} : void 0;
if (false) {
  CssBaseline["propTypes"] = exactProp(CssBaseline.propTypes);
}
var CssBaseline_default = withStyles_default(styles12, {
  name: "MuiCssBaseline"
})(CssBaseline);

// src/client/themes/Provider.tsx
import {
  ThemeProvider as StyledThemeProvider,
  createGlobalStyle as createGlobalStyle3
} from "https://cdn.skypack.dev/styled-components";

// src/client/components/Editor/lib/themes/index.tsx
import React27 from "https://cdn.skypack.dev/react";
import {withTheme} from "https://cdn.skypack.dev/styled-components";

// src/client/components/Editor/lib/themes/dark.ts
var import_dot_object = __toModule(require_dot_object());
import {createGlobalStyle, css as css2} from "https://cdn.skypack.dev/styled-components";
var entries = Object.entries;
var white = "#ffffff";
var black = "#18181a";
var variableColor = "#f2b472";
var syntaxClasses = {
  variable: variableColor,
  type: teal_default.A400,
  scope: amber_default.A100,
  function: lightBlue_default.A200,
  number: orange_default[200],
  string: lightGreen_default[300],
  comment: blueGrey_default[600],
  constant: variableColor,
  directive: grey_default[200],
  control: grey_default[200],
  operator: teal_default.A400,
  modifier: red_default[300],
  punctuation: grey_default[200]
};
var globalEditorCSS = createGlobalStyle`
  ${entries(syntaxClasses).map(([name, color]) => css2`
        span.${name} {
          color: ${color} !important;
        }
      `)}
`;
var editorColors = {
  contrastBorder: grey_default[800],
  errorForeground: red_default[500],
  focusBorder: grey_default[800],
  foreground: grey_default[300],
  activityBar: {
    background: black,
    border: grey_default[800]
  },
  activityBarBadge: {
    background: red_default[500]
  },
  button: {
    background: blue_default[600],
    foreground: white,
    border: blue_default[600],
    hoverBackground: blue_default[600]
  },
  dropdown: {
    background: black,
    border: grey_default[800],
    foreground: white
  },
  editor: {
    background: black,
    foreground: grey_default[300],
    hoverHighlightBackground: grey_default[800],
    inactiveSelectionBackground: grey_default[800],
    lineHighlightBackground: grey_default[900],
    lineHighlightBorder: grey_default[800],
    rangeHighlightBackground: grey_default[900],
    selectionBackground: grey_default[800],
    selectionHighlightBackground: grey_default[800],
    wordHighlightStrongBackground: grey_default[900],
    wordHighlightBackground: grey_default[900]
  },
  editorBracketMatch: {
    background: grey_default[900],
    border: grey_default[800]
  },
  editorCodeLens: {
    foreground: grey_default[900]
  },
  editorCursor: {
    background: black,
    foreground: white
  },
  editorError: {
    border: grey_default[800],
    foreground: red_default[500]
  },
  editorGroup: {
    background: black,
    border: grey_default[800],
    dropBackground: black
  },
  editorGroupHeader: {
    tabsBackground: black,
    tabsBorder: grey_default[900]
  },
  editorGutter: {
    background: black,
    deletedBackground: red_default[500],
    modifiedBackground: black
  },
  editorHoverWidget: {
    background: black,
    border: grey_default[800]
  },
  editorIndentGuide: {
    background: black
  },
  editorLink: {
    activeForeground: grey_default[300]
  },
  editorLineNumber: {
    foreground: grey_default[600],
    activeForeground: grey_default[200]
  },
  editorRuler: {
    foreground: white
  },
  editorMarkerNavigation: {
    background: black
  },
  editorMarkerNavigationWarning: {
    background: grey_default[900]
  },
  editorMarkerNavigationError: {
    background: black
  },
  editorOverviewRuler: {
    border: grey_default[800],
    commonContentForeground: grey_default[900],
    currentContentForeground: red_default[500],
    incomingContentForeground: green_default[500]
  },
  editorSuggestWidget: {
    background: black,
    border: grey_default[800],
    foreground: grey_default[300],
    selectedBackground: grey_default[900]
  },
  editorWarning: {
    border: grey_default[800],
    foreground: red_default[300]
  },
  editorWhitespace: {
    foreground: grey_default[800]
  },
  editorWidget: {
    background: black,
    border: grey_default[800]
  },
  extensionButton: {
    prominentBackground: grey_default[900],
    prominentForeground: white,
    prominentHoverBackground: grey_default[900]
  },
  input: {
    background: grey_default[900],
    foreground: white,
    border: grey_default[800],
    placeholderForeground: grey_default[400]
  },
  inputOption: {
    activeBorder: lightBlue_default[500]
  },
  inputValidation: {
    infoBorder: purple_default[500],
    warningBorder: amber_default[500],
    errorBorder: red_default[500]
  },
  list: {
    dropBackground: black,
    highlightForeground: lightBlue_default[500],
    hoverBackground: grey_default[900],
    focusBackground: grey_default[900],
    activeSelectionBackground: grey_default[900],
    activeSelectionForeground: white,
    inactiveSelectionBackground: grey_default[900],
    inactiveSelectionForeground: white,
    warningForeground: amber_default[500],
    errorForeground: red_default[500]
  },
  menu: {
    background: black,
    selectionBackground: grey_default[900]
  },
  peekView: {
    border: grey_default[800]
  },
  peekViewEditor: {
    background: grey_default[900],
    matchHighlightBackground: lightBlue_default[500]
  },
  peekViewResult: {
    background: grey_default[900],
    fileForeground: white,
    lineForeground: white,
    matchHighlightBackground: lightBlue_default[500],
    selectionBackground: grey_default[900],
    selectionForeground: white
  },
  peekViewTitle: {
    background: grey_default[900]
  },
  peekViewTitleDescription: {
    foreground: blue_default[700]
  },
  peekViewTitleLabel: {
    foreground: white
  },
  scrollbarSlider: {
    activeBackground: white,
    border: grey_default[800]
  },
  selection: {
    background: blue_default[700]
  },
  separator: {
    background: grey_default[800],
    foreground: white
  },
  sideBar: {
    background: black,
    border: grey_default[800],
    foreground: grey_default[200]
  },
  sideBarSectionHeader: {
    background: black,
    foreground: white,
    border: grey_default[800]
  },
  sideBarTitle: {
    foreground: white
  },
  statusBar: {
    background: grey_default[900],
    foreground: white,
    debuggingBackground: red_default[500],
    debuggingForeground: grey_default[900],
    noFolderBackground: grey_default[900],
    noFolderForeground: white,
    border: grey_default[800]
  },
  statusBarItem: {
    prominentBackground: red_default[500],
    prominentHoverBackground: amber_default[500],
    remoteForeground: grey_default[100],
    remoteBackground: purple_default[500]
  },
  tab: {
    activeBackground: black,
    activeForeground: white,
    border: grey_default[800],
    activeBorder: lightBlue_default[500],
    inactiveBackground: black,
    inactiveForeground: grey_default[400],
    unfocusedActiveForeground: white,
    unfocusedInactiveForeground: grey_default[400]
  },
  titleBar: {
    background: black,
    activeBackground: black,
    activeForeground: white,
    border: grey_default[800],
    inactiveBackground: black,
    inactiveForeground: grey_default[300]
  }
};
var vscodeTokens = [
  {
    name: "Delimeter Bracket",
    scope: ["backtick.bracket"],
    settings: {
      foreground: syntaxClasses.modifier
    }
  },
  {
    name: "Operator",
    scope: ["operator"],
    settings: {
      foreground: syntaxClasses.operator
    }
  },
  {
    name: "Comment",
    scope: ["comment"],
    settings: {
      foreground: blueGrey_default[600],
      fontStyle: "italic"
    }
  },
  {
    name: "Keyword",
    scope: ["keyword"],
    settings: {
      foreground: purple_default.A100
    }
  },
  {
    name: "Storage",
    scope: ["storage"],
    settings: {
      foreground: purple_default.A100
    }
  },
  {
    name: "Constant",
    scope: ["constant"],
    settings: {
      foreground: deepOrange_default.A100
    }
  },
  {
    name: "Variable",
    scope: ["variable"],
    settings: {
      foreground: pink_default.A200
    }
  },
  {
    name: "String",
    scope: ["string"],
    settings: {
      foreground: lightGreen_default[300]
    }
  },
  {
    name: "String",
    scope: ["number"],
    settings: {
      foreground: deepOrange_default.A100
    }
  },
  {
    name: "None",
    scope: ["none"],
    settings: {
      foreground: blueGrey_default[300]
    }
  },
  {
    name: "Invalid Deprecated",
    scope: ["invalid.deprecated"],
    settings: {
      foreground: brown_default[800],
      background: amber_default[300]
    }
  },
  {
    name: "Invalid Illegal",
    scope: ["invalid.illegal"],
    settings: {
      foreground: white,
      background: red_default[400]
    }
  },
  {
    name: "Markup Bold",
    scope: ["markup.bold"],
    settings: {
      foreground: deepOrange_default.A100,
      fontStyle: "bold"
    }
  },
  {
    name: "Markup Changed",
    scope: ["markup.changed"],
    settings: {
      foreground: purple_default.A100
    }
  },
  {
    name: "Markup Deleted",
    scope: ["markup.deleted"],
    settings: {
      foreground: pink_default.A200
    }
  },
  {
    name: "Markup Italic",
    scope: ["markup.italic"],
    settings: {
      foreground: purple_default.A100,
      fontStyle: "italic"
    }
  },
  {
    name: "Markup Heading",
    scope: ["markup.heading"],
    settings: {
      foreground: pink_default.A200
    }
  },
  {
    name: "Markup Heading Punctuation Definition Heading",
    scope: ["markup.heading punctuation.definition.heading"],
    settings: {
      foreground: lightBlue_default.A400
    }
  },
  {
    name: "Markup Link",
    scope: ["markup.link"],
    settings: {
      foreground: purple_default.A100
    }
  },
  {
    name: "Markup Inserted",
    scope: ["markup.inserted"],
    settings: {
      foreground: green_default.A200
    }
  },
  {
    name: "Markup Quote",
    scope: ["markup.quote"],
    settings: {
      foreground: deepOrange_default.A100
    }
  },
  {
    name: "Markup Raw",
    scope: ["markup.raw"],
    settings: {
      foreground: green_default.A200
    }
  },
  {
    scope: "token.info-token",
    settings: {
      foreground: lightBlue_default[600]
    }
  },
  {
    scope: "token.warn-token",
    settings: {
      foreground: lightBlue_default[700]
    }
  },
  {
    scope: "token.error-token",
    settings: {
      foreground: red_default[700]
    }
  },
  {
    scope: "token.debug-token",
    settings: {
      foreground: purple_default[400]
    }
  }
];
function removeUndefined(rule) {
  return entries(rule).reduce((acc, [key, value]) => {
    if (value) {
      acc[key] = value;
    }
    return acc;
  }, {token: rule.token});
}
function transformVscodeTokens() {
  const rules = [];
  vscodeTokens.forEach((token) => {
    if (Array.isArray(token.scope)) {
      token.scope.forEach((scope) => {
        rules.push(removeUndefined({
          token: scope,
          foreground: token.settings.foreground,
          background: token.settings.background,
          fontStyle: token.settings.fontStyle
        }));
      });
    } else {
      rules.push(removeUndefined({
        token: token.scope,
        foreground: token.settings.foreground,
        background: token.settings.background,
        fontStyle: token.settings.fontStyle
      }));
    }
  });
  return rules;
}
var theme3 = {
  inherit: true,
  base: "vs-dark",
  colors: import_dot_object.default.dot(editorColors),
  rules: transformVscodeTokens()
};
var dark_default2 = theme3;

// src/client/components/Editor/lib/themes/light.ts
var import_dot_object2 = __toModule(require_dot_object());
import {createGlobalStyle as createGlobalStyle2, css as css3} from "https://cdn.skypack.dev/styled-components";
var entries2 = Object.entries;
var white2 = "#ffffff";
var black2 = "#161616";
var variableColor2 = "#c97c2a";
var syntaxClasses2 = {
  variable: variableColor2,
  type: teal_default.A700,
  scope: "#db9504",
  function: lightBlue_default.A700,
  number: orange_default[400],
  string: lightGreen_default[800],
  comment: blueGrey_default[600],
  constant: variableColor2,
  directive: grey_default[900],
  control: grey_default[900],
  operator: teal_default.A700,
  modifier: pink_default[600],
  punctuation: grey_default[900]
};
var globalEditorCSS2 = createGlobalStyle2`
  ${entries2(syntaxClasses2).map(([name, color]) => css3`
        span.${name} {
          color: ${color} !important;
        }
      `)}
`;
var editorColors2 = {
  contrastBorder: grey_default[200],
  errorForeground: red_default[500],
  focusBorder: grey_default[200],
  foreground: grey_default[800],
  activityBar: {
    background: white2,
    border: grey_default[200]
  },
  activityBarBadge: {
    background: red_default[500]
  },
  button: {
    background: blue_default[600],
    foreground: black2,
    border: blue_default[600],
    hoverBackground: blue_default[600]
  },
  dropdown: {
    background: white2,
    border: grey_default[300],
    foreground: black2
  },
  editor: {
    background: white2,
    foreground: grey_default[800],
    hoverHighlightBackground: grey_default[300],
    inactiveSelectionBackground: grey_default[300],
    lineHighlightBackground: grey_default[200],
    lineHighlightBorder: grey_default[200],
    rangeHighlightBackground: grey_default[200],
    selectionBackground: grey_default[300],
    selectionHighlightBackground: grey_default[200],
    wordHighlightStrongBackground: grey_default[200],
    wordHighlightBackground: grey_default[200]
  },
  editorBracketMatch: {
    background: grey_default[200],
    border: grey_default[200]
  },
  editorCodeLens: {
    foreground: grey_default[800]
  },
  editorCursor: {
    background: white2,
    foreground: black2
  },
  editorError: {
    border: grey_default[200],
    foreground: red_default[500]
  },
  editorGroup: {
    background: white2,
    border: grey_default[200],
    dropBackground: white2
  },
  editorGroupHeader: {
    tabsBackground: white2,
    tabsBorder: grey_default[200]
  },
  editorGutter: {
    background: white2,
    deletedBackground: red_default[500],
    modifiedBackground: white2
  },
  editorHoverWidget: {
    background: white2,
    border: grey_default[200]
  },
  editorIndentGuide: {
    background: white2
  },
  editorLink: {
    activeForeground: grey_default[300]
  },
  editorLineNumber: {
    foreground: grey_default[600],
    activeForeground: grey_default[900]
  },
  editorRuler: {
    foreground: black2
  },
  editorMarkerNavigation: {
    background: white2
  },
  editorMarkerNavigationWarning: {
    background: grey_default[200]
  },
  editorMarkerNavigationError: {
    background: white2
  },
  editorOverviewRuler: {
    border: grey_default[200],
    commonContentForeground: grey_default[200],
    currentContentForeground: red_default[500],
    incomingContentForeground: green_default[500]
  },
  editorSuggestWidget: {
    background: white2,
    border: grey_default[200],
    foreground: grey_default[800],
    selectedBackground: grey_default[200]
  },
  editorWarning: {
    border: grey_default[200],
    foreground: red_default[300]
  },
  editorWhitespace: {
    foreground: grey_default[800]
  },
  editorWidget: {
    background: white2,
    border: grey_default[200]
  },
  extensionButton: {
    prominentBackground: grey_default[200],
    prominentForeground: white2,
    prominentHoverBackground: grey_default[200]
  },
  input: {
    background: grey_default[200],
    foreground: black2,
    border: grey_default[200],
    placeholderForeground: grey_default[400]
  },
  inputOption: {
    activeBorder: lightBlue_default[500]
  },
  inputValidation: {
    infoBorder: purple_default[500],
    warningBorder: amber_default[500],
    errorBorder: red_default[500]
  },
  list: {
    dropBackground: white2,
    highlightForeground: lightBlue_default[500],
    hoverBackground: grey_default[200],
    focusBackground: grey_default[200],
    activeSelectionBackground: grey_default[200],
    activeSelectionForeground: black2,
    inactiveSelectionBackground: grey_default[200],
    inactiveSelectionForeground: white2,
    warningForeground: amber_default[500],
    errorForeground: red_default[500]
  },
  menu: {
    background: white2,
    selectionBackground: grey_default[200]
  },
  peekView: {
    border: grey_default[300]
  },
  peekViewEditor: {
    background: grey_default[200],
    matchHighlightBackground: lightBlue_default[500]
  },
  peekViewResult: {
    background: grey_default[200],
    fileForeground: white2,
    lineForeground: white2,
    matchHighlightBackground: lightBlue_default[500],
    selectionBackground: grey_default[200],
    selectionForeground: white2
  },
  peekViewTitle: {
    background: grey_default[200]
  },
  peekViewTitleDescription: {
    foreground: blue_default[700]
  },
  peekViewTitleLabel: {
    foreground: black2
  },
  scrollbarSlider: {
    activeBackground: white2,
    border: grey_default[200]
  },
  selection: {
    background: blue_default[700]
  },
  separator: {
    background: grey_default[300],
    foreground: black2
  },
  sideBar: {
    background: white2,
    border: grey_default[200],
    foreground: grey_default[800]
  },
  sideBarSectionHeader: {
    background: white2,
    foreground: black2,
    border: grey_default[200]
  },
  sideBarTitle: {
    foreground: black2
  },
  statusBar: {
    background: grey_default[200],
    foreground: black2,
    debuggingBackground: red_default[500],
    debuggingForeground: grey_default[200],
    noFolderBackground: grey_default[200],
    noFolderForeground: white2,
    border: grey_default[200]
  },
  statusBarItem: {
    prominentBackground: red_default[500],
    prominentHoverBackground: amber_default[500],
    remoteForeground: grey_default[100],
    remoteBackground: purple_default[500]
  },
  tab: {
    activeBackground: white2,
    activeForeground: white2,
    border: grey_default[200],
    activeBorder: lightBlue_default[500],
    inactiveBackground: white2,
    inactiveForeground: grey_default[400],
    unfocusedActiveForeground: white2,
    unfocusedInactiveForeground: grey_default[400]
  },
  titleBar: {
    background: white2,
    activeBackground: white2,
    activeForeground: white2,
    border: grey_default[200],
    inactiveBackground: white2,
    inactiveForeground: grey_default[300]
  }
};
var vscodeTokens2 = [
  {
    name: "Delimeter Bracket",
    scope: ["backtick.bracket"],
    settings: {
      foreground: syntaxClasses2.modifier
    }
  },
  {
    name: "Operator",
    scope: ["operator"],
    settings: {
      foreground: syntaxClasses2.operator
    }
  },
  {
    name: "Comment",
    scope: ["comment"],
    settings: {
      foreground: blueGrey_default[600],
      fontStyle: "italic"
    }
  },
  {
    name: "Keyword",
    scope: ["keyword"],
    settings: {
      foreground: purple_default.A700
    }
  },
  {
    name: "Storage",
    scope: ["storage"],
    settings: {
      foreground: purple_default.A700
    }
  },
  {
    name: "Constant",
    scope: ["constant"],
    settings: {
      foreground: syntaxClasses2.constant
    }
  },
  {
    name: "Variable",
    scope: ["variable"],
    settings: {
      foreground: syntaxClasses2.variable
    }
  },
  {
    name: "String",
    scope: ["string"],
    settings: {
      foreground: syntaxClasses2.string
    }
  },
  {
    name: "String",
    scope: ["number"],
    settings: {
      foreground: deepOrange_default.A200
    }
  },
  {
    name: "None",
    scope: ["none"],
    settings: {
      foreground: blueGrey_default[300]
    }
  },
  {
    name: "Invalid Deprecated",
    scope: ["invalid.deprecated"],
    settings: {
      foreground: brown_default[800],
      background: amber_default[300]
    }
  },
  {
    name: "Invalid Illegal",
    scope: ["invalid.illegal"],
    settings: {
      foreground: black2,
      background: red_default[400]
    }
  },
  {
    name: "Markup Bold",
    scope: ["markup.bold"],
    settings: {
      foreground: deepOrange_default.A200,
      fontStyle: "bold"
    }
  },
  {
    name: "Markup Changed",
    scope: ["markup.changed"],
    settings: {
      foreground: purple_default.A700
    }
  },
  {
    name: "Markup Deleted",
    scope: ["markup.deleted"],
    settings: {
      foreground: pink_default.A200
    }
  },
  {
    name: "Markup Italic",
    scope: ["markup.italic"],
    settings: {
      foreground: purple_default.A700,
      fontStyle: "italic"
    }
  },
  {
    name: "Markup Heading",
    scope: ["markup.heading"],
    settings: {
      foreground: pink_default.A200
    }
  },
  {
    name: "Markup Heading Punctuation Definition Heading",
    scope: ["markup.heading punctuation.definition.heading"],
    settings: {
      foreground: lightBlue_default.A400
    }
  },
  {
    name: "Markup Link",
    scope: ["markup.link"],
    settings: {
      foreground: purple_default.A700
    }
  },
  {
    name: "Markup Inserted",
    scope: ["markup.inserted"],
    settings: {
      foreground: green_default.A200
    }
  },
  {
    name: "Markup Quote",
    scope: ["markup.quote"],
    settings: {
      foreground: deepOrange_default.A200
    }
  },
  {
    name: "Markup Raw",
    scope: ["markup.raw"],
    settings: {
      foreground: green_default.A200
    }
  },
  {
    scope: "token.info-token",
    settings: {
      foreground: lightBlue_default[600]
    }
  },
  {
    scope: "token.warn-token",
    settings: {
      foreground: lightBlue_default[700]
    }
  },
  {
    scope: "token.error-token",
    settings: {
      foreground: red_default[700]
    }
  },
  {
    scope: "token.debug-token",
    settings: {
      foreground: purple_default[400]
    }
  }
];
function removeUndefined2(rule) {
  return entries2(rule).reduce((acc, [key, value]) => {
    if (value) {
      acc[key] = value;
    }
    return acc;
  }, {token: rule.token});
}
function transformVscodeTokens2() {
  const rules = [];
  vscodeTokens2.forEach((token) => {
    if (Array.isArray(token.scope)) {
      token.scope.forEach((scope) => {
        rules.push(removeUndefined2({
          token: scope,
          foreground: token.settings.foreground,
          background: token.settings.background,
          fontStyle: token.settings.fontStyle
        }));
      });
    } else {
      rules.push(removeUndefined2({
        token: token.scope,
        foreground: token.settings.foreground,
        background: token.settings.background,
        fontStyle: token.settings.fontStyle
      }));
    }
  });
  return rules;
}
var theme4 = {
  inherit: true,
  base: "vs",
  colors: import_dot_object2.default.dot(editorColors2),
  rules: transformVscodeTokens2()
};
var light_default2 = theme4;

// src/client/components/Editor/lib/themes/index.tsx
var MONACO_LIGHT_THEME = "opstrace-light";
var MONACO_DARK_THEME = "opstrace-dark";
editor.defineTheme(MONACO_LIGHT_THEME, light_default2);
editor.defineTheme(MONACO_DARK_THEME, dark_default2);
var GlobalEditorCSS = withTheme((props) => {
  if (props.theme.palette.type === "dark") {
    return /* @__PURE__ */ React27.createElement(globalEditorCSS, null);
  }
  return /* @__PURE__ */ React27.createElement(globalEditorCSS2, null);
});

// src/client/services/Command/CommandService.tsx
import React42, {useCallback as useCallback7, useEffect as useEffect7, useContext as useContext3, useMemo as useMemo3} from "https://cdn.skypack.dev/react";

// ../../node_modules/hotkeys-js/dist/hotkeys.esm.js
/*!
 * hotkeys-js v3.8.1
 * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
 * 
 * Copyright (c) 2020 kenny wong <wowohoo@qq.com>
 * http://jaywcjlove.github.io/hotkeys
 * 
 * Licensed under the MIT license.
 */
var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function addEvent(object2, event, method) {
  if (object2.addEventListener) {
    object2.addEventListener(event, method, false);
  } else if (object2.attachEvent) {
    object2.attachEvent("on".concat(event), function() {
      method(window.event);
    });
  }
}
function getMods(modifier, key) {
  var mods = key.slice(0, key.length - 1);
  for (var i = 0; i < mods.length; i++) {
    mods[i] = modifier[mods[i].toLowerCase()];
  }
  return mods;
}
function getKeys(key) {
  if (typeof key !== "string")
    key = "";
  key = key.replace(/\s/g, "");
  var keys = key.split(",");
  var index2 = keys.lastIndexOf("");
  for (; index2 >= 0; ) {
    keys[index2 - 1] += ",";
    keys.splice(index2, 1);
    index2 = keys.lastIndexOf("");
  }
  return keys;
}
function compareArray(a1, a2) {
  var arr1 = a1.length >= a2.length ? a1 : a2;
  var arr2 = a1.length >= a2.length ? a2 : a1;
  var isIndex = true;
  for (var i = 0; i < arr1.length; i++) {
    if (arr2.indexOf(arr1[i]) === -1)
      isIndex = false;
  }
  return isIndex;
}
var _keyMap = {
  backspace: 8,
  tab: 9,
  clear: 12,
  enter: 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  "\u21EA": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff ? 173 : 189,
  "=": isff ? 61 : 187,
  ";": isff ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
};
var _modifier = {
  "\u21E7": 16,
  shift: 16,
  "\u2325": 18,
  alt: 18,
  option: 18,
  "\u2303": 17,
  ctrl: 17,
  control: 17,
  "\u2318": 91,
  cmd: 91,
  command: 91
};
var modifierMap = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
var _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
var _handlers = {};
for (var k = 1; k < 20; k++) {
  _keyMap["f".concat(k)] = 111 + k;
}
var _downKeys = [];
var _scope = "all";
var elementHasBindEvent = [];
var code = function code2(x) {
  return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
};
function setScope(scope) {
  _scope = scope || "all";
}
function getScope() {
  return _scope || "all";
}
function getPressedKeyCodes() {
  return _downKeys.slice(0);
}
function filter(event) {
  var target = event.target || event.srcElement;
  var tagName = target.tagName;
  var flag = true;
  if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
    flag = false;
  }
  return flag;
}
function isPressed(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code(keyCode);
  }
  return _downKeys.indexOf(keyCode) !== -1;
}
function deleteScope(scope, newScope) {
  var handlers;
  var i;
  if (!scope)
    scope = getScope();
  for (var key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers = _handlers[key];
      for (i = 0; i < handlers.length; ) {
        if (handlers[i].scope === scope)
          handlers.splice(i, 1);
        else
          i++;
      }
    }
  }
  if (getScope() === scope)
    setScope(newScope || "all");
}
function clearModifier(event) {
  var key = event.keyCode || event.which || event.charCode;
  var i = _downKeys.indexOf(key);
  if (i >= 0) {
    _downKeys.splice(i, 1);
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys.splice(0, _downKeys.length);
  }
  if (key === 93 || key === 224)
    key = 91;
  if (key in _mods) {
    _mods[key] = false;
    for (var k in _modifier) {
      if (_modifier[k] === key)
        hotkeys[k] = false;
    }
  }
}
function unbind(keysInfo) {
  if (!keysInfo) {
    Object.keys(_handlers).forEach(function(key) {
      return delete _handlers[key];
    });
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach(function(info) {
      if (info.key)
        eachUnbind(info);
    });
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key)
      eachUnbind(keysInfo);
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var scope = args[0], method = args[1];
    if (typeof scope === "function") {
      method = scope;
      scope = "";
    }
    eachUnbind({
      key: keysInfo,
      scope,
      method,
      splitKey: "+"
    });
  }
}
var eachUnbind = function eachUnbind2(_ref2) {
  var key = _ref2.key, scope = _ref2.scope, method = _ref2.method, _ref$splitKey = _ref2.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
  var multipleKeys = getKeys(key);
  multipleKeys.forEach(function(originKey) {
    var unbindKeys = originKey.split(splitKey);
    var len = unbindKeys.length;
    var lastKey = unbindKeys[len - 1];
    var keyCode = lastKey === "*" ? "*" : code(lastKey);
    if (!_handlers[keyCode])
      return;
    if (!scope)
      scope = getScope();
    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
    _handlers[keyCode] = _handlers[keyCode].map(function(record) {
      var isMatchingMethod = method ? record.method === method : true;
      if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {
        return {};
      }
      return record;
    });
  });
};
function eventHandler(event, handler, scope) {
  var modifiersMatch;
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0;
    for (var y in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y)) {
        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {
          modifiersMatch = false;
        }
      }
    }
    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
      if (handler.method(event, handler) === false) {
        if (event.preventDefault)
          event.preventDefault();
        else
          event.returnValue = false;
        if (event.stopPropagation)
          event.stopPropagation();
        if (event.cancelBubble)
          event.cancelBubble = true;
      }
    }
  }
}
function dispatch(event) {
  var asterisk = _handlers["*"];
  var key = event.keyCode || event.which || event.charCode;
  if (!hotkeys.filter.call(this, event))
    return;
  if (key === 93 || key === 224)
    key = 91;
  if (_downKeys.indexOf(key) === -1 && key !== 229)
    _downKeys.push(key);
  ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
    var keyNum = modifierMap[keyName];
    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
      }
    }
  });
  if (key in _mods) {
    _mods[key] = true;
    for (var k in _modifier) {
      if (_modifier[k] === key)
        hotkeys[k] = true;
    }
    if (!asterisk)
      return;
  }
  for (var e in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e)) {
      _mods[e] = event[modifierMap[e]];
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17);
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18);
    }
    _mods[17] = true;
    _mods[18] = true;
  }
  var scope = getScope();
  if (asterisk) {
    for (var i = 0; i < asterisk.length; i++) {
      if (asterisk[i].scope === scope && (event.type === "keydown" && asterisk[i].keydown || event.type === "keyup" && asterisk[i].keyup)) {
        eventHandler(event, asterisk[i], scope);
      }
    }
  }
  if (!(key in _handlers))
    return;
  for (var _i = 0; _i < _handlers[key].length; _i++) {
    if (event.type === "keydown" && _handlers[key][_i].keydown || event.type === "keyup" && _handlers[key][_i].keyup) {
      if (_handlers[key][_i].key) {
        var record = _handlers[key][_i];
        var splitKey = record.splitKey;
        var keyShortcut = record.key.split(splitKey);
        var _downKeysCurrent = [];
        for (var a = 0; a < keyShortcut.length; a++) {
          _downKeysCurrent.push(code(keyShortcut[a]));
        }
        if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
          eventHandler(event, record, scope);
        }
      }
    }
  }
}
function isElementBind(element) {
  return elementHasBindEvent.indexOf(element) > -1;
}
function hotkeys(key, option, method) {
  _downKeys = [];
  var keys = getKeys(key);
  var mods = [];
  var scope = "all";
  var element = document;
  var i = 0;
  var keyup = false;
  var keydown = true;
  var splitKey = "+";
  if (method === void 0 && typeof option === "function") {
    method = option;
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope)
      scope = option.scope;
    if (option.element)
      element = option.element;
    if (option.keyup)
      keyup = option.keyup;
    if (option.keydown !== void 0)
      keydown = option.keydown;
    if (typeof option.splitKey === "string")
      splitKey = option.splitKey;
  }
  if (typeof option === "string")
    scope = option;
  for (; i < keys.length; i++) {
    key = keys[i].split(splitKey);
    mods = [];
    if (key.length > 1)
      mods = getMods(_modifier, key);
    key = key[key.length - 1];
    key = key === "*" ? "*" : code(key);
    if (!(key in _handlers))
      _handlers[key] = [];
    _handlers[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys[i],
      method,
      key: keys[i],
      splitKey
    });
  }
  if (typeof element !== "undefined" && !isElementBind(element) && window) {
    elementHasBindEvent.push(element);
    addEvent(element, "keydown", function(e) {
      dispatch(e);
    });
    addEvent(window, "focus", function() {
      _downKeys = [];
    });
    addEvent(element, "keyup", function(e) {
      dispatch(e);
      clearModifier(e);
    });
  }
}
var _api = {
  setScope,
  getScope,
  deleteScope,
  getPressedKeyCodes,
  isPressed,
  filter,
  unbind
};
for (var a in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a)) {
    hotkeys[a] = _api[a];
  }
}
if (typeof window !== "undefined") {
  _hotkeys = window.hotkeys;
  hotkeys.noConflict = function(deep) {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }
    return hotkeys;
  };
  window.hotkeys = hotkeys;
}
var _hotkeys;
var hotkeys_esm_default = hotkeys;

// src/client/hooks/useTypesafeReducer.ts
import {useReducer, useMemo} from "https://cdn.skypack.dev/react";
function useTypesafeReducer(reducer8, initialState5, actions25) {
  const [state, dispatch2] = useReducer(reducer8, initialState5);
  const boundActions = useMemo(() => {
    function bindActionCreator(actionCreator, dispatcher) {
      return function() {
        return dispatcher(actionCreator.apply(this, arguments));
      };
    }
    const newActions = Object.keys(actions25).reduce((ba, actionName) => {
      ba[actionName] = bindActionCreator(actions25[actionName], dispatch2);
      return ba;
    }, {});
    return newActions;
  }, [dispatch2, actions25]);
  return [state, boundActions];
}

// src/client/services/Command/reducer.ts
var import_typesafe_actions = __toModule(require_typesafe_actions_umd_production());

// src/client/services/Command/util.ts
var modifiers = {
  shift: "\u21E7",
  alt: "\u2325",
  option: "\u2325",
  ctrl: "\u2303",
  control: "\u2303",
  cmd: "\u2318",
  command: "\u2318"
};
var getPlatformMetaKey = () => /Mac|iPod|iPhone|iPad/.test(typeof navigator !== "undefined" ? navigator.platform : "") ? "cmd" : "ctrl";
function replaceModKeyWithPlatformMetaKey(key) {
  return key.replace(/mod/g, getPlatformMetaKey());
}
function getModifierSymbol(modifier) {
  return modifier in modifiers ? modifiers[modifier] : modifier;
}
function getKeysFromKeybinding(keybinding) {
  const keysArray = replaceModKeyWithPlatformMetaKey(keybinding).split("+");
  return keysArray.map((key) => getModifierSymbol(key));
}

// src/client/services/Command/reducer.ts
var actions = {
  register: import_typesafe_actions.createAction("REGISTER_COMMAND")(),
  unregister: import_typesafe_actions.createAction("UNREGISTER_COMMAND")()
};
function removeCommand(commands, command) {
  return commands.filter((c) => c.id !== command.id);
}
var initialState = {
  commands: [],
  keyBindings: {}
};
function getKeybindings(command) {
  if (!command.keybindings || command.keybindings.length === 0) {
    return null;
  }
  return command.keybindings.map(replaceModKeyWithPlatformMetaKey);
}
function addKeyBindingsForCommand(state, command) {
  const keybindings = getKeybindings(command);
  if (!keybindings) {
    return state;
  }
  return keybindings.reduce((state2, keybinding) => {
    const existingCmds = state2[keybinding] || [];
    return {
      ...state2,
      [keybinding]: [command].concat(existingCmds.filter((cmd) => cmd.id !== command.id))
    };
  }, state);
}
function removeKeyBindingsForCommand(state, command) {
  const keybindings = getKeybindings(command);
  if (!keybindings) {
    return state;
  }
  return keybindings.reduce((state2, keybinding) => {
    return {
      ...state2,
      [keybinding]: (state2[keybinding] || []).filter((cmd) => cmd.id !== command.id)
    };
  }, state);
}
var commandServiceReducer = import_typesafe_actions.createReducer(initialState).handleAction(actions.register, (state, action) => {
  const commands = [action.payload].concat(removeCommand(state.commands, action.payload));
  const keyBindings = addKeyBindingsForCommand(state.keyBindings, action.payload);
  return {
    ...state,
    commands,
    keyBindings
  };
}).handleAction(actions.unregister, (state, action) => {
  const commands = removeCommand(state.commands, action.payload);
  const keyBindings = removeKeyBindingsForCommand(state.keyBindings, action.payload);
  return {
    ...state,
    commands,
    keyBindings
  };
});

// src/client/services/Command/CommandPicker.tsx
import React41, {useCallback as useCallback6} from "https://cdn.skypack.dev/react";

// src/client/services/Picker/PickerService.tsx
import React40, {useEffect as useEffect6, useCallback as useCallback5, useMemo as useMemo2, useState as useState5} from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/core/esm/InputBase/InputBase.js
var import_prop_types16 = __toModule(require_prop_types());
import {
  createElement as createElement14,
  forwardRef as forwardRef11,
  useCallback as useCallback2,
  useEffect as useEffect2,
  useLayoutEffect as useLayoutEffect2,
  useRef as useRef2,
  useState as useState2
} from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/core/esm/FormControl/formControlState.js
function formControlState(_ref2) {
  var props = _ref2.props, states = _ref2.states, muiFormControl = _ref2.muiFormControl;
  return states.reduce(function(acc, state) {
    acc[state] = props[state];
    if (muiFormControl) {
      if (typeof props[state] === "undefined") {
        acc[state] = muiFormControl[state];
      }
    }
    return acc;
  }, {});
}

// node_modules/@material-ui/core/esm/FormControl/FormControlContext.js
import {
  createContext,
  useContext as useContext2
} from "https://cdn.skypack.dev/react";
var FormControlContext = createContext();
if (false) {
  FormControlContext.displayName = "FormControlContext";
}
function useFormControl() {
  return useContext2(FormControlContext);
}
var FormControlContext_default = FormControlContext;

// node_modules/@material-ui/core/esm/TextareaAutosize/TextareaAutosize.js
var import_prop_types15 = __toModule(require_prop_types());
import {
  Fragment as Fragment2,
  createElement as createElement13,
  forwardRef as forwardRef10,
  useCallback,
  useEffect,
  useLayoutEffect,
  useRef,
  useState
} from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/core/esm/utils/debounce.js
function debounce(func3) {
  var wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 166;
  var timeout3;
  function debounced() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var that = this;
    var later = function later2() {
      func3.apply(that, args);
    };
    clearTimeout(timeout3);
    timeout3 = setTimeout(later, wait);
  }
  debounced.clear = function() {
    clearTimeout(timeout3);
  };
  return debounced;
}

// node_modules/@material-ui/core/esm/TextareaAutosize/TextareaAutosize.js
function getStyleValue(computedStyle, property) {
  return parseInt(computedStyle[property], 10) || 0;
}
var useEnhancedEffect = typeof window !== "undefined" ? useLayoutEffect : useEffect;
var styles14 = {
  shadow: {
    visibility: "hidden",
    position: "absolute",
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    transform: "translateZ(0)"
  }
};
var TextareaAutosize = /* @__PURE__ */ forwardRef10(function TextareaAutosize2(props, ref) {
  var onChange = props.onChange, rows = props.rows, rowsMax = props.rowsMax, _props$rowsMin = props.rowsMin, rowsMinProp = _props$rowsMin === void 0 ? 1 : _props$rowsMin, style = props.style, value = props.value, other = _objectWithoutProperties(props, ["onChange", "rows", "rowsMax", "rowsMin", "style", "value"]);
  var rowsMin = rows || rowsMinProp;
  var _React$useRef = useRef(value != null), isControlled = _React$useRef.current;
  var inputRef = useRef(null);
  var handleRef = useForkRef(ref, inputRef);
  var shadowRef = useRef(null);
  var renders = useRef(0);
  var _React$useState = useState({}), state = _React$useState[0], setState = _React$useState[1];
  var syncHeight = useCallback(function() {
    var input = inputRef.current;
    var computedStyle = window.getComputedStyle(input);
    var inputShallow = shadowRef.current;
    inputShallow.style.width = computedStyle.width;
    inputShallow.value = input.value || props.placeholder || "x";
    if (inputShallow.value.slice(-1) === "\n") {
      inputShallow.value += " ";
    }
    var boxSizing = computedStyle["box-sizing"];
    var padding = getStyleValue(computedStyle, "padding-bottom") + getStyleValue(computedStyle, "padding-top");
    var border = getStyleValue(computedStyle, "border-bottom-width") + getStyleValue(computedStyle, "border-top-width");
    var innerHeight = inputShallow.scrollHeight - padding;
    inputShallow.value = "x";
    var singleRowHeight = inputShallow.scrollHeight - padding;
    var outerHeight = innerHeight;
    if (rowsMin) {
      outerHeight = Math.max(Number(rowsMin) * singleRowHeight, outerHeight);
    }
    if (rowsMax) {
      outerHeight = Math.min(Number(rowsMax) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight);
    var outerHeightStyle = outerHeight + (boxSizing === "border-box" ? padding + border : 0);
    var overflow = Math.abs(outerHeight - innerHeight) <= 1;
    setState(function(prevState) {
      if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
        renders.current += 1;
        return {
          overflow,
          outerHeightStyle
        };
      }
      if (false) {
        if (renders.current === 20) {
          console.error(["Material-UI: Too many re-renders. The layout is unstable.", "TextareaAutosize limits the number of renders to prevent an infinite loop."].join("\n"));
        }
      }
      return prevState;
    });
  }, [rowsMax, rowsMin, props.placeholder]);
  useEffect(function() {
    var handleResize = debounce(function() {
      renders.current = 0;
      syncHeight();
    });
    window.addEventListener("resize", handleResize);
    return function() {
      handleResize.clear();
      window.removeEventListener("resize", handleResize);
    };
  }, [syncHeight]);
  useEnhancedEffect(function() {
    syncHeight();
  });
  useEffect(function() {
    renders.current = 0;
  }, [value]);
  var handleChange = function handleChange2(event) {
    renders.current = 0;
    if (!isControlled) {
      syncHeight();
    }
    if (onChange) {
      onChange(event);
    }
  };
  return /* @__PURE__ */ createElement13(Fragment2, null, /* @__PURE__ */ createElement13("textarea", _extends({
    value,
    onChange: handleChange,
    ref: handleRef,
    rows: rowsMin,
    style: _extends({
      height: state.outerHeightStyle,
      overflow: state.overflow ? "hidden" : null
    }, style)
  }, other)), /* @__PURE__ */ createElement13("textarea", {
    "aria-hidden": true,
    className: props.className,
    readOnly: true,
    ref: shadowRef,
    tabIndex: -1,
    style: _extends({}, styles14.shadow, style)
  }));
});
false ? TextareaAutosize.propTypes = {
  className: import_prop_types15.default.string,
  onChange: import_prop_types15.default.func,
  placeholder: import_prop_types15.default.string,
  rows: import_prop_types15.default.oneOfType([import_prop_types15.default.number, import_prop_types15.default.string]),
  rowsMax: import_prop_types15.default.oneOfType([import_prop_types15.default.number, import_prop_types15.default.string]),
  rowsMin: import_prop_types15.default.oneOfType([import_prop_types15.default.number, import_prop_types15.default.string]),
  style: import_prop_types15.default.object,
  value: import_prop_types15.default.oneOfType([import_prop_types15.default.arrayOf(import_prop_types15.default.string), import_prop_types15.default.number, import_prop_types15.default.string])
} : void 0;
var TextareaAutosize_default = TextareaAutosize;

// node_modules/@material-ui/core/esm/InputBase/utils.js
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
}
function isFilled(obj) {
  var SSR = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
}

// node_modules/@material-ui/core/esm/InputBase/InputBase.js
var styles15 = function styles16(theme6) {
  var light = theme6.palette.type === "light";
  var placeholder = {
    color: "currentColor",
    opacity: light ? 0.42 : 0.5,
    transition: theme6.transitions.create("opacity", {
      duration: theme6.transitions.duration.shorter
    })
  };
  var placeholderHidden = {
    opacity: "0 !important"
  };
  var placeholderVisible = {
    opacity: light ? 0.42 : 0.5
  };
  return {
    "@global": {
      "@keyframes mui-auto-fill": {},
      "@keyframes mui-auto-fill-cancel": {}
    },
    root: _extends({}, theme6.typography.body1, {
      color: theme6.palette.text.primary,
      lineHeight: "1.1876em",
      boxSizing: "border-box",
      position: "relative",
      cursor: "text",
      display: "inline-flex",
      alignItems: "center",
      "&$disabled": {
        color: theme6.palette.text.disabled,
        cursor: "default"
      }
    }),
    formControl: {},
    focused: {},
    disabled: {},
    adornedStart: {},
    adornedEnd: {},
    error: {},
    marginDense: {},
    multiline: {
      padding: "".concat(8 - 2, "px 0 ").concat(8 - 1, "px"),
      "&$marginDense": {
        paddingTop: 4 - 1
      }
    },
    colorSecondary: {},
    fullWidth: {
      width: "100%"
    },
    input: {
      font: "inherit",
      letterSpacing: "inherit",
      color: "currentColor",
      padding: "".concat(8 - 2, "px 0 ").concat(8 - 1, "px"),
      border: 0,
      boxSizing: "content-box",
      background: "none",
      height: "1.1876em",
      margin: 0,
      WebkitTapHighlightColor: "transparent",
      display: "block",
      minWidth: 0,
      width: "100%",
      animationName: "mui-auto-fill-cancel",
      animationDuration: "10ms",
      "&::-webkit-input-placeholder": placeholder,
      "&::-moz-placeholder": placeholder,
      "&:-ms-input-placeholder": placeholder,
      "&::-ms-input-placeholder": placeholder,
      "&:focus": {
        outline: 0
      },
      "&:invalid": {
        boxShadow: "none"
      },
      "&::-webkit-search-decoration": {
        "-webkit-appearance": "none"
      },
      "label[data-shrink=false] + $formControl &": {
        "&::-webkit-input-placeholder": placeholderHidden,
        "&::-moz-placeholder": placeholderHidden,
        "&:-ms-input-placeholder": placeholderHidden,
        "&::-ms-input-placeholder": placeholderHidden,
        "&:focus::-webkit-input-placeholder": placeholderVisible,
        "&:focus::-moz-placeholder": placeholderVisible,
        "&:focus:-ms-input-placeholder": placeholderVisible,
        "&:focus::-ms-input-placeholder": placeholderVisible
      },
      "&$disabled": {
        opacity: 1
      },
      "&:-webkit-autofill": {
        animationDuration: "5000s",
        animationName: "mui-auto-fill"
      }
    },
    inputMarginDense: {
      paddingTop: 4 - 1
    },
    inputMultiline: {
      height: "auto",
      resize: "none",
      padding: 0
    },
    inputTypeSearch: {
      "-moz-appearance": "textfield",
      "-webkit-appearance": "textfield"
    },
    inputAdornedStart: {},
    inputAdornedEnd: {},
    inputHiddenLabel: {}
  };
};
var useEnhancedEffect2 = typeof window === "undefined" ? useEffect2 : useLayoutEffect2;
var InputBase = /* @__PURE__ */ forwardRef11(function InputBase2(props, ref) {
  var ariaDescribedby = props["aria-describedby"], autoComplete = props.autoComplete, autoFocus = props.autoFocus, classes = props.classes, className = props.className, color = props.color, defaultValue = props.defaultValue, disabled = props.disabled, endAdornment = props.endAdornment, error = props.error, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, id = props.id, _props$inputComponent = props.inputComponent, inputComponent = _props$inputComponent === void 0 ? "input" : _props$inputComponent, _props$inputProps = props.inputProps, inputPropsProp = _props$inputProps === void 0 ? {} : _props$inputProps, inputRefProp = props.inputRef, margin = props.margin, _props$multiline = props.multiline, multiline = _props$multiline === void 0 ? false : _props$multiline, name = props.name, onBlur = props.onBlur, onChange = props.onChange, onClick = props.onClick, onFocus = props.onFocus, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp, placeholder = props.placeholder, readOnly = props.readOnly, renderSuffix = props.renderSuffix, rows = props.rows, rowsMax = props.rowsMax, rowsMin = props.rowsMin, startAdornment = props.startAdornment, _props$type = props.type, type = _props$type === void 0 ? "text" : _props$type, valueProp = props.value, other = _objectWithoutProperties(props, ["aria-describedby", "autoComplete", "autoFocus", "classes", "className", "color", "defaultValue", "disabled", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "rowsMax", "rowsMin", "startAdornment", "type", "value"]);
  var value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
  var _React$useRef = useRef2(value != null), isControlled = _React$useRef.current;
  var inputRef = useRef2();
  var handleInputRefWarning = useCallback2(function(instance) {
    if (false) {
      if (instance && instance.nodeName !== "INPUT" && !instance.focus) {
        console.error(["Material-UI: You have provided a `inputComponent` to the input component", "that does not correctly handle the `inputRef` prop.", "Make sure the `inputRef` prop is called with a HTMLInputElement."].join("\n"));
      }
    }
  }, []);
  var handleInputPropsRefProp = useForkRef(inputPropsProp.ref, handleInputRefWarning);
  var handleInputRefProp = useForkRef(inputRefProp, handleInputPropsRefProp);
  var handleInputRef = useForkRef(inputRef, handleInputRefProp);
  var _React$useState = useState2(false), focused = _React$useState[0], setFocused = _React$useState[1];
  var muiFormControl = useFormControl();
  if (false) {
    useEffect2(function() {
      if (muiFormControl) {
        return muiFormControl.registerEffect();
      }
      return void 0;
    }, [muiFormControl]);
  }
  var fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "hiddenLabel", "margin", "required", "filled"]
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused;
  useEffect2(function() {
    if (!muiFormControl && disabled && focused) {
      setFocused(false);
      if (onBlur) {
        onBlur();
      }
    }
  }, [muiFormControl, disabled, focused, onBlur]);
  var onFilled = muiFormControl && muiFormControl.onFilled;
  var onEmpty = muiFormControl && muiFormControl.onEmpty;
  var checkDirty = useCallback2(function(obj) {
    if (isFilled(obj)) {
      if (onFilled) {
        onFilled();
      }
    } else if (onEmpty) {
      onEmpty();
    }
  }, [onFilled, onEmpty]);
  useEnhancedEffect2(function() {
    if (isControlled) {
      checkDirty({
        value
      });
    }
  }, [value, checkDirty, isControlled]);
  var handleFocus = function handleFocus2(event) {
    if (fcs.disabled) {
      event.stopPropagation();
      return;
    }
    if (onFocus) {
      onFocus(event);
    }
    if (inputPropsProp.onFocus) {
      inputPropsProp.onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    } else {
      setFocused(true);
    }
  };
  var handleBlur = function handleBlur2(event) {
    if (onBlur) {
      onBlur(event);
    }
    if (inputPropsProp.onBlur) {
      inputPropsProp.onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    } else {
      setFocused(false);
    }
  };
  var handleChange = function handleChange2(event) {
    if (!isControlled) {
      var element = event.target || inputRef.current;
      if (element == null) {
        throw new Error(false ? "Material-UI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://material-ui.com/r/input-component-ref-interface for more info." : formatMuiErrorMessage(1));
      }
      checkDirty({
        value: element.value
      });
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (inputPropsProp.onChange) {
      inputPropsProp.onChange.apply(inputPropsProp, [event].concat(args));
    }
    if (onChange) {
      onChange.apply(void 0, [event].concat(args));
    }
  };
  useEffect2(function() {
    checkDirty(inputRef.current);
  }, []);
  var handleClick = function handleClick2(event) {
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  var InputComponent = inputComponent;
  var inputProps = _extends({}, inputPropsProp, {
    ref: handleInputRef
  });
  if (typeof InputComponent !== "string") {
    inputProps = _extends({
      inputRef: handleInputRef,
      type
    }, inputProps, {
      ref: null
    });
  } else if (multiline) {
    if (rows && !rowsMax && !rowsMin) {
      InputComponent = "textarea";
    } else {
      inputProps = _extends({
        rows,
        rowsMax
      }, inputProps);
      InputComponent = TextareaAutosize_default;
    }
  } else {
    inputProps = _extends({
      type
    }, inputProps);
  }
  var handleAutoFill = function handleAutoFill2(event) {
    checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
      value: "x"
    });
  };
  useEffect2(function() {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  return /* @__PURE__ */ createElement14("div", _extends({
    className: clsx_m_default(classes.root, classes["color".concat(capitalize(fcs.color || "primary"))], className, fcs.disabled && classes.disabled, fcs.error && classes.error, fullWidth && classes.fullWidth, fcs.focused && classes.focused, muiFormControl && classes.formControl, multiline && classes.multiline, startAdornment && classes.adornedStart, endAdornment && classes.adornedEnd, fcs.margin === "dense" && classes.marginDense),
    onClick: handleClick,
    ref
  }, other), startAdornment, /* @__PURE__ */ createElement14(FormControlContext_default.Provider, {
    value: null
  }, /* @__PURE__ */ createElement14(InputComponent, _extends({
    "aria-invalid": fcs.error,
    "aria-describedby": ariaDescribedby,
    autoComplete,
    autoFocus,
    defaultValue,
    disabled: fcs.disabled,
    id,
    onAnimationStart: handleAutoFill,
    name,
    placeholder,
    readOnly,
    required: fcs.required,
    rows,
    value,
    onKeyDown,
    onKeyUp
  }, inputProps, {
    className: clsx_m_default(classes.input, inputPropsProp.className, fcs.disabled && classes.disabled, multiline && classes.inputMultiline, fcs.hiddenLabel && classes.inputHiddenLabel, startAdornment && classes.inputAdornedStart, endAdornment && classes.inputAdornedEnd, type === "search" && classes.inputTypeSearch, fcs.margin === "dense" && classes.inputMarginDense),
    onBlur: handleBlur,
    onChange: handleChange,
    onFocus: handleFocus
  }))), endAdornment, renderSuffix ? renderSuffix(_extends({}, fcs, {
    startAdornment
  })) : null);
});
false ? InputBase.propTypes = {
  "aria-describedby": import_prop_types16.default.string,
  autoComplete: import_prop_types16.default.string,
  autoFocus: import_prop_types16.default.bool,
  classes: import_prop_types16.default.object,
  className: import_prop_types16.default.string,
  color: import_prop_types16.default.oneOf(["primary", "secondary"]),
  defaultValue: import_prop_types16.default.any,
  disabled: import_prop_types16.default.bool,
  endAdornment: import_prop_types16.default.node,
  error: import_prop_types16.default.bool,
  fullWidth: import_prop_types16.default.bool,
  id: import_prop_types16.default.string,
  inputComponent: import_prop_types16.default.elementType,
  inputProps: import_prop_types16.default.object,
  inputRef: refType_default,
  margin: import_prop_types16.default.oneOf(["dense", "none"]),
  multiline: import_prop_types16.default.bool,
  name: import_prop_types16.default.string,
  onBlur: import_prop_types16.default.func,
  onChange: import_prop_types16.default.func,
  onClick: import_prop_types16.default.func,
  onFocus: import_prop_types16.default.func,
  onKeyDown: import_prop_types16.default.func,
  onKeyUp: import_prop_types16.default.func,
  placeholder: import_prop_types16.default.string,
  readOnly: import_prop_types16.default.bool,
  renderSuffix: import_prop_types16.default.func,
  required: import_prop_types16.default.bool,
  rows: import_prop_types16.default.oneOfType([import_prop_types16.default.number, import_prop_types16.default.string]),
  rowsMax: import_prop_types16.default.oneOfType([import_prop_types16.default.number, import_prop_types16.default.string]),
  rowsMin: import_prop_types16.default.oneOfType([import_prop_types16.default.number, import_prop_types16.default.string]),
  startAdornment: import_prop_types16.default.node,
  type: import_prop_types16.default.string,
  value: import_prop_types16.default.any
} : void 0;
var InputBase_default = withStyles_default(styles15, {
  name: "MuiInputBase"
})(InputBase);

// src/client/components/Dialog/Dialog.tsx
import React38 from "https://cdn.skypack.dev/react";
import styled9 from "https://cdn.skypack.dev/styled-components";

// node_modules/@material-ui/core/esm/Dialog/Dialog.js
var import_prop_types23 = __toModule(require_prop_types());
import {
  createElement as createElement20,
  forwardRef as forwardRef17,
  useRef as useRef6
} from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/core/esm/Modal/Modal.js
var import_prop_types20 = __toModule(require_prop_types());
import {
  Component as Component4,
  cloneElement as cloneElement3,
  createElement as createElement17,
  forwardRef as forwardRef14,
  useCallback as useCallback4,
  useEffect as useEffect5,
  useRef as useRef4,
  useState as useState4
} from "https://cdn.skypack.dev/react";
import {
  findDOMNode as findDOMNode3
} from "https://cdn.skypack.dev/react-dom";

// node_modules/@material-ui/core/esm/utils/ownerDocument.js
function ownerDocument(node) {
  return node && node.ownerDocument || document;
}

// node_modules/@material-ui/core/esm/Portal/Portal.js
var import_prop_types17 = __toModule(require_prop_types());
import {
  Component as Component3,
  cloneElement,
  forwardRef as forwardRef12,
  isValidElement,
  useEffect as useEffect3,
  useLayoutEffect as useLayoutEffect3,
  useState as useState3
} from "https://cdn.skypack.dev/react";
import {
  createPortal,
  findDOMNode
} from "https://cdn.skypack.dev/react-dom";
function getContainer(container) {
  container = typeof container === "function" ? container() : container;
  return findDOMNode(container);
}
var useEnhancedEffect3 = typeof window !== "undefined" ? useLayoutEffect3 : useEffect3;
var Portal = /* @__PURE__ */ forwardRef12(function Portal2(props, ref) {
  var children = props.children, container = props.container, _props$disablePortal = props.disablePortal, disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal, onRendered = props.onRendered;
  var _React$useState = useState3(null), mountNode = _React$useState[0], setMountNode = _React$useState[1];
  var handleRef = useForkRef(/* @__PURE__ */ isValidElement(children) ? children.ref : null, ref);
  useEnhancedEffect3(function() {
    if (!disablePortal) {
      setMountNode(getContainer(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect3(function() {
    if (mountNode && !disablePortal) {
      setRef(ref, mountNode);
      return function() {
        setRef(ref, null);
      };
    }
    return void 0;
  }, [ref, mountNode, disablePortal]);
  useEnhancedEffect3(function() {
    if (onRendered && (mountNode || disablePortal)) {
      onRendered();
    }
  }, [onRendered, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ isValidElement(children)) {
      return /* @__PURE__ */ cloneElement(children, {
        ref: handleRef
      });
    }
    return children;
  }
  return mountNode ? /* @__PURE__ */ createPortal(children, mountNode) : mountNode;
});
false ? Portal.propTypes = {
  children: import_prop_types17.default.node,
  container: import_prop_types17.default.oneOfType([HTMLElementType, import_prop_types17.default.instanceOf(Component3), import_prop_types17.default.func]),
  disablePortal: import_prop_types17.default.bool,
  onRendered: import_prop_types17.default.func
} : void 0;
if (false) {
  Portal["propTypes"] = exactProp(Portal.propTypes);
}
var Portal_default = Portal;

// node_modules/@material-ui/core/esm/utils/createChainedFunction.js
function createChainedFunction() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  return funcs.reduce(function(acc, func3) {
    if (func3 == null) {
      return acc;
    }
    if (false) {
      if (typeof func3 !== "function") {
        console.error("Material-UI: Invalid Argument Type, must only provide functions, undefined, or null.");
      }
    }
    return function chainedFunction() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      acc.apply(this, args);
      func3.apply(this, args);
    };
  }, function() {
  });
}

// node_modules/@material-ui/core/esm/utils/getScrollbarSize.js
function getScrollbarSize() {
  var scrollDiv = document.createElement("div");
  scrollDiv.style.width = "99px";
  scrollDiv.style.height = "99px";
  scrollDiv.style.position = "absolute";
  scrollDiv.style.top = "-9999px";
  scrollDiv.style.overflow = "scroll";
  document.body.appendChild(scrollDiv);
  var scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarSize;
}

// node_modules/@material-ui/core/esm/utils/ownerWindow.js
function ownerWindow(node) {
  var doc = ownerDocument(node);
  return doc.defaultView || window;
}

// node_modules/@material-ui/core/esm/Modal/ModalManager.js
function isOverflowing(container) {
  var doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(doc).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(node, show2) {
  if (show2) {
    node.setAttribute("aria-hidden", "true");
  } else {
    node.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(node) {
  return parseInt(window.getComputedStyle(node)["padding-right"], 10) || 0;
}
function ariaHiddenSiblings(container, mountNode, currentNode) {
  var nodesToExclude = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  var show2 = arguments.length > 4 ? arguments[4] : void 0;
  var blacklist = [mountNode, currentNode].concat(_toConsumableArray(nodesToExclude));
  var blacklistTagNames = ["TEMPLATE", "SCRIPT", "STYLE"];
  [].forEach.call(container.children, function(node) {
    if (node.nodeType === 1 && blacklist.indexOf(node) === -1 && blacklistTagNames.indexOf(node.tagName) === -1) {
      ariaHidden(node, show2);
    }
  });
}
function findIndexOf(containerInfo, callback) {
  var idx = -1;
  containerInfo.some(function(item, index2) {
    if (callback(item)) {
      idx = index2;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  var restoreStyle = [];
  var restorePaddings = [];
  var container = containerInfo.container;
  var fixedNodes;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      var scrollbarSize = getScrollbarSize();
      restoreStyle.push({
        value: container.style.paddingRight,
        key: "padding-right",
        el: container
      });
      container.style["padding-right"] = "".concat(getPaddingRight(container) + scrollbarSize, "px");
      fixedNodes = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedNodes, function(node) {
        restorePaddings.push(node.style.paddingRight);
        node.style.paddingRight = "".concat(getPaddingRight(node) + scrollbarSize, "px");
      });
    }
    var parent2 = container.parentElement;
    var scrollContainer = parent2.nodeName === "HTML" && window.getComputedStyle(parent2)["overflow-y"] === "scroll" ? parent2 : container;
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      key: "overflow",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  var restore = function restore2() {
    if (fixedNodes) {
      [].forEach.call(fixedNodes, function(node, i) {
        if (restorePaddings[i]) {
          node.style.paddingRight = restorePaddings[i];
        } else {
          node.style.removeProperty("padding-right");
        }
      });
    }
    restoreStyle.forEach(function(_ref2) {
      var value = _ref2.value, el = _ref2.el, key = _ref2.key;
      if (value) {
        el.style.setProperty(key, value);
      } else {
        el.style.removeProperty(key);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  var hiddenSiblings = [];
  [].forEach.call(container.children, function(node) {
    if (node.getAttribute && node.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(node);
    }
  });
  return hiddenSiblings;
}
var ModalManager = /* @__PURE__ */ function() {
  function ModalManager2() {
    _classCallCheck(this, ModalManager2);
    this.modals = [];
    this.containers = [];
  }
  _createClass(ModalManager2, [{
    key: "add",
    value: function add(modal, container) {
      var modalIndex = this.modals.indexOf(modal);
      if (modalIndex !== -1) {
        return modalIndex;
      }
      modalIndex = this.modals.length;
      this.modals.push(modal);
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, false);
      }
      var hiddenSiblingNodes = getHiddenSiblings(container);
      ariaHiddenSiblings(container, modal.mountNode, modal.modalRef, hiddenSiblingNodes, true);
      var containerIndex = findIndexOf(this.containers, function(item) {
        return item.container === container;
      });
      if (containerIndex !== -1) {
        this.containers[containerIndex].modals.push(modal);
        return modalIndex;
      }
      this.containers.push({
        modals: [modal],
        container,
        restore: null,
        hiddenSiblingNodes
      });
      return modalIndex;
    }
  }, {
    key: "mount",
    value: function mount(modal, props) {
      var containerIndex = findIndexOf(this.containers, function(item) {
        return item.modals.indexOf(modal) !== -1;
      });
      var containerInfo = this.containers[containerIndex];
      if (!containerInfo.restore) {
        containerInfo.restore = handleContainer(containerInfo, props);
      }
    }
  }, {
    key: "remove",
    value: function remove2(modal) {
      var modalIndex = this.modals.indexOf(modal);
      if (modalIndex === -1) {
        return modalIndex;
      }
      var containerIndex = findIndexOf(this.containers, function(item) {
        return item.modals.indexOf(modal) !== -1;
      });
      var containerInfo = this.containers[containerIndex];
      containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
      this.modals.splice(modalIndex, 1);
      if (containerInfo.modals.length === 0) {
        if (containerInfo.restore) {
          containerInfo.restore();
        }
        if (modal.modalRef) {
          ariaHidden(modal.modalRef, true);
        }
        ariaHiddenSiblings(containerInfo.container, modal.mountNode, modal.modalRef, containerInfo.hiddenSiblingNodes, false);
        this.containers.splice(containerIndex, 1);
      } else {
        var nextTop = containerInfo.modals[containerInfo.modals.length - 1];
        if (nextTop.modalRef) {
          ariaHidden(nextTop.modalRef, false);
        }
      }
      return modalIndex;
    }
  }, {
    key: "isTopModal",
    value: function isTopModal(modal) {
      return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
    }
  }]);
  return ModalManager2;
}();

// node_modules/@material-ui/core/esm/Unstable_TrapFocus/Unstable_TrapFocus.js
var import_prop_types18 = __toModule(require_prop_types());
import {
  Fragment as Fragment3,
  cloneElement as cloneElement2,
  createElement as createElement15,
  useCallback as useCallback3,
  useEffect as useEffect4,
  useRef as useRef3
} from "https://cdn.skypack.dev/react";
import {
  findDOMNode as findDOMNode2
} from "https://cdn.skypack.dev/react-dom";
function Unstable_TrapFocus(props) {
  var children = props.children, _props$disableAutoFoc = props.disableAutoFocus, disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc, _props$disableEnforce = props.disableEnforceFocus, disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce, _props$disableRestore = props.disableRestoreFocus, disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore, getDoc = props.getDoc, isEnabled = props.isEnabled, open = props.open;
  var ignoreNextEnforceFocus = useRef3();
  var sentinelStart = useRef3(null);
  var sentinelEnd = useRef3(null);
  var nodeToRestore = useRef3();
  var rootRef = useRef3(null);
  var handleOwnRef = useCallback3(function(instance) {
    rootRef.current = findDOMNode2(instance);
  }, []);
  var handleRef = useForkRef(children.ref, handleOwnRef);
  var prevOpenRef = useRef3();
  useEffect4(function() {
    prevOpenRef.current = open;
  }, [open]);
  if (!prevOpenRef.current && open && typeof window !== "undefined") {
    nodeToRestore.current = getDoc().activeElement;
  }
  useEffect4(function() {
    if (!open) {
      return;
    }
    var doc = ownerDocument(rootRef.current);
    if (!disableAutoFocus && rootRef.current && !rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        if (false) {
          console.error(["Material-UI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join("\n"));
        }
        rootRef.current.setAttribute("tabIndex", -1);
      }
      rootRef.current.focus();
    }
    var contain = function contain2() {
      var rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootRef.current && !rootRef.current.contains(doc.activeElement)) {
        rootRef.current.focus();
      }
    };
    var loopFocus = function loopFocus2(event) {
      if (disableEnforceFocus || !isEnabled() || event.keyCode !== 9) {
        return;
      }
      if (doc.activeElement === rootRef.current) {
        ignoreNextEnforceFocus.current = true;
        if (event.shiftKey) {
          sentinelEnd.current.focus();
        } else {
          sentinelStart.current.focus();
        }
      }
    };
    doc.addEventListener("focus", contain, true);
    doc.addEventListener("keydown", loopFocus, true);
    var interval = setInterval(function() {
      contain();
    }, 50);
    return function() {
      clearInterval(interval);
      doc.removeEventListener("focus", contain, true);
      doc.removeEventListener("keydown", loopFocus, true);
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open]);
  return /* @__PURE__ */ createElement15(Fragment3, null, /* @__PURE__ */ createElement15("div", {
    tabIndex: 0,
    ref: sentinelStart,
    "data-test": "sentinelStart"
  }), /* @__PURE__ */ cloneElement2(children, {
    ref: handleRef
  }), /* @__PURE__ */ createElement15("div", {
    tabIndex: 0,
    ref: sentinelEnd,
    "data-test": "sentinelEnd"
  }));
}
false ? Unstable_TrapFocus.propTypes = {
  children: import_prop_types18.default.node,
  disableAutoFocus: import_prop_types18.default.bool,
  disableEnforceFocus: import_prop_types18.default.bool,
  disableRestoreFocus: import_prop_types18.default.bool,
  getDoc: import_prop_types18.default.func.isRequired,
  isEnabled: import_prop_types18.default.func.isRequired,
  open: import_prop_types18.default.bool.isRequired
} : void 0;
if (false) {
  Unstable_TrapFocus["propTypes"] = exactProp(Unstable_TrapFocus.propTypes);
}
var Unstable_TrapFocus_default = Unstable_TrapFocus;

// node_modules/@material-ui/core/esm/Modal/SimpleBackdrop.js
var import_prop_types19 = __toModule(require_prop_types());
import {
  createElement as createElement16,
  forwardRef as forwardRef13
} from "https://cdn.skypack.dev/react";
var styles17 = {
  root: {
    zIndex: -1,
    position: "fixed",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent"
  },
  invisible: {
    backgroundColor: "transparent"
  }
};
var SimpleBackdrop = /* @__PURE__ */ forwardRef13(function SimpleBackdrop2(props, ref) {
  var _props$invisible = props.invisible, invisible = _props$invisible === void 0 ? false : _props$invisible, open = props.open, other = _objectWithoutProperties(props, ["invisible", "open"]);
  return open ? /* @__PURE__ */ createElement16("div", _extends({
    "aria-hidden": true,
    ref
  }, other, {
    style: _extends({}, styles17.root, invisible ? styles17.invisible : {}, other.style)
  })) : null;
});
false ? SimpleBackdrop.propTypes = {
  invisible: import_prop_types19.default.bool,
  open: import_prop_types19.default.bool.isRequired
} : void 0;
var SimpleBackdrop_default = SimpleBackdrop;

// node_modules/@material-ui/core/esm/Modal/Modal.js
function getContainer2(container) {
  container = typeof container === "function" ? container() : container;
  return findDOMNode3(container);
}
function getHasTransition(props) {
  return props.children ? props.children.props.hasOwnProperty("in") : false;
}
var defaultManager = new ModalManager();
var styles18 = function styles19(theme6) {
  return {
    root: {
      position: "fixed",
      zIndex: theme6.zIndex.modal,
      right: 0,
      bottom: 0,
      top: 0,
      left: 0
    },
    hidden: {
      visibility: "hidden"
    }
  };
};
var Modal = /* @__PURE__ */ forwardRef14(function Modal2(inProps, ref) {
  var theme6 = useTheme();
  var props = getThemeProps({
    name: "MuiModal",
    props: _extends({}, inProps),
    theme: theme6
  });
  var _props$BackdropCompon = props.BackdropComponent, BackdropComponent = _props$BackdropCompon === void 0 ? SimpleBackdrop_default : _props$BackdropCompon, BackdropProps = props.BackdropProps, children = props.children, _props$closeAfterTran = props.closeAfterTransition, closeAfterTransition = _props$closeAfterTran === void 0 ? false : _props$closeAfterTran, container = props.container, _props$disableAutoFoc = props.disableAutoFocus, disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc, _props$disableBackdro = props.disableBackdropClick, disableBackdropClick = _props$disableBackdro === void 0 ? false : _props$disableBackdro, _props$disableEnforce = props.disableEnforceFocus, disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce, _props$disableEscapeK = props.disableEscapeKeyDown, disableEscapeKeyDown = _props$disableEscapeK === void 0 ? false : _props$disableEscapeK, _props$disablePortal = props.disablePortal, disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal, _props$disableRestore = props.disableRestoreFocus, disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore, _props$disableScrollL = props.disableScrollLock, disableScrollLock = _props$disableScrollL === void 0 ? false : _props$disableScrollL, _props$hideBackdrop = props.hideBackdrop, hideBackdrop = _props$hideBackdrop === void 0 ? false : _props$hideBackdrop, _props$keepMounted = props.keepMounted, keepMounted = _props$keepMounted === void 0 ? false : _props$keepMounted, _props$manager = props.manager, manager = _props$manager === void 0 ? defaultManager : _props$manager, onBackdropClick = props.onBackdropClick, onClose = props.onClose, onEscapeKeyDown = props.onEscapeKeyDown, onRendered = props.onRendered, open = props.open, other = _objectWithoutProperties(props, ["BackdropComponent", "BackdropProps", "children", "closeAfterTransition", "container", "disableAutoFocus", "disableBackdropClick", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onEscapeKeyDown", "onRendered", "open"]);
  var _React$useState = useState4(true), exited = _React$useState[0], setExited = _React$useState[1];
  var modal = useRef4({});
  var mountNodeRef = useRef4(null);
  var modalRef = useRef4(null);
  var handleRef = useForkRef(modalRef, ref);
  var hasTransition = getHasTransition(props);
  var getDoc = function getDoc2() {
    return ownerDocument(mountNodeRef.current);
  };
  var getModal = function getModal2() {
    modal.current.modalRef = modalRef.current;
    modal.current.mountNode = mountNodeRef.current;
    return modal.current;
  };
  var handleMounted = function handleMounted2() {
    manager.mount(getModal(), {
      disableScrollLock
    });
    modalRef.current.scrollTop = 0;
  };
  var handleOpen = useEventCallback(function() {
    var resolvedContainer = getContainer2(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  var isTopModal = useCallback4(function() {
    return manager.isTopModal(getModal());
  }, [manager]);
  var handlePortalRef = useEventCallback(function(node) {
    mountNodeRef.current = node;
    if (!node) {
      return;
    }
    if (onRendered) {
      onRendered();
    }
    if (open && isTopModal()) {
      handleMounted();
    } else {
      ariaHidden(modalRef.current, true);
    }
  });
  var handleClose = useCallback4(function() {
    manager.remove(getModal());
  }, [manager]);
  useEffect5(function() {
    return function() {
      handleClose();
    };
  }, [handleClose]);
  useEffect5(function() {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  var handleEnter = function handleEnter2() {
    setExited(false);
  };
  var handleExited = function handleExited2() {
    setExited(true);
    if (closeAfterTransition) {
      handleClose();
    }
  };
  var handleBackdropClick = function handleBackdropClick2(event) {
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (!disableBackdropClick && onClose) {
      onClose(event, "backdropClick");
    }
  };
  var handleKeyDown = function handleKeyDown2(event) {
    if (event.key !== "Escape" || !isTopModal()) {
      return;
    }
    if (onEscapeKeyDown) {
      onEscapeKeyDown(event);
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  };
  var inlineStyle = styles18(theme6 || {
    zIndex: zIndex_default
  });
  var childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = children.props.tabIndex || "-1";
  }
  if (hasTransition) {
    childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
    childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
  }
  return /* @__PURE__ */ createElement17(Portal_default, {
    ref: handlePortalRef,
    container,
    disablePortal
  }, /* @__PURE__ */ createElement17("div", _extends({
    ref: handleRef,
    onKeyDown: handleKeyDown,
    role: "presentation"
  }, other, {
    style: _extends({}, inlineStyle.root, !open && exited ? inlineStyle.hidden : {}, other.style)
  }), hideBackdrop ? null : /* @__PURE__ */ createElement17(BackdropComponent, _extends({
    open,
    onClick: handleBackdropClick
  }, BackdropProps)), /* @__PURE__ */ createElement17(Unstable_TrapFocus_default, {
    disableEnforceFocus,
    disableAutoFocus,
    disableRestoreFocus,
    getDoc,
    isEnabled: isTopModal,
    open
  }, /* @__PURE__ */ cloneElement3(children, childProps))));
});
false ? Modal.propTypes = {
  BackdropComponent: import_prop_types20.default.elementType,
  BackdropProps: import_prop_types20.default.object,
  children: elementAcceptingRef_default.isRequired,
  closeAfterTransition: import_prop_types20.default.bool,
  container: import_prop_types20.default.oneOfType([HTMLElementType, import_prop_types20.default.instanceOf(Component4), import_prop_types20.default.func]),
  disableAutoFocus: import_prop_types20.default.bool,
  disableBackdropClick: import_prop_types20.default.bool,
  disableEnforceFocus: import_prop_types20.default.bool,
  disableEscapeKeyDown: import_prop_types20.default.bool,
  disablePortal: import_prop_types20.default.bool,
  disableRestoreFocus: import_prop_types20.default.bool,
  disableScrollLock: import_prop_types20.default.bool,
  hideBackdrop: import_prop_types20.default.bool,
  keepMounted: import_prop_types20.default.bool,
  manager: import_prop_types20.default.object,
  onBackdropClick: import_prop_types20.default.func,
  onClose: import_prop_types20.default.func,
  onEscapeKeyDown: import_prop_types20.default.func,
  onRendered: import_prop_types20.default.func,
  open: import_prop_types20.default.bool.isRequired
} : void 0;
var Modal_default = Modal;

// node_modules/@material-ui/core/esm/Backdrop/Backdrop.js
var import_prop_types22 = __toModule(require_prop_types());
import {
  createElement as createElement19,
  forwardRef as forwardRef16
} from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/core/esm/Fade/Fade.js
var import_prop_types21 = __toModule(require_prop_types());
import {
  cloneElement as cloneElement4,
  createElement as createElement18,
  forwardRef as forwardRef15,
  useRef as useRef5
} from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/core/esm/transitions/utils.js
var reflow = function reflow2(node) {
  return node.scrollTop;
};
function getTransitionProps(props, options) {
  var timeout3 = props.timeout, _props$style = props.style, style = _props$style === void 0 ? {} : _props$style;
  return {
    duration: style.transitionDuration || typeof timeout3 === "number" ? timeout3 : timeout3[options.mode] || 0,
    delay: style.transitionDelay
  };
}

// node_modules/@material-ui/core/esm/Fade/Fade.js
var styles20 = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
var defaultTimeout = {
  enter: duration.enteringScreen,
  exit: duration.leavingScreen
};
var Fade = /* @__PURE__ */ forwardRef15(function Fade2(props, ref) {
  var children = props.children, _props$disableStrictM = props.disableStrictModeCompat, disableStrictModeCompat = _props$disableStrictM === void 0 ? false : _props$disableStrictM, inProp = props.in, onEnter = props.onEnter, onEntered = props.onEntered, onEntering = props.onEntering, onExit = props.onExit, onExited = props.onExited, onExiting = props.onExiting, style = props.style, _props$TransitionComp = props.TransitionComponent, TransitionComponent = _props$TransitionComp === void 0 ? Transition_default : _props$TransitionComp, _props$timeout = props.timeout, timeout3 = _props$timeout === void 0 ? defaultTimeout : _props$timeout, other = _objectWithoutProperties(props, ["children", "disableStrictModeCompat", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "TransitionComponent", "timeout"]);
  var theme6 = useTheme2();
  var enableStrictModeCompat = theme6.unstable_strictMode && !disableStrictModeCompat;
  var nodeRef = useRef5(null);
  var foreignRef = useForkRef(children.ref, ref);
  var handleRef = useForkRef(enableStrictModeCompat ? nodeRef : void 0, foreignRef);
  var normalizedTransitionCallback = function normalizedTransitionCallback2(callback) {
    return function(nodeOrAppearing, maybeAppearing) {
      if (callback) {
        var _ref2 = enableStrictModeCompat ? [nodeRef.current, nodeOrAppearing] : [nodeOrAppearing, maybeAppearing], _ref22 = _slicedToArray(_ref2, 2), node = _ref22[0], isAppearing = _ref22[1];
        if (isAppearing === void 0) {
          callback(node);
        } else {
          callback(node, isAppearing);
        }
      }
    };
  };
  var handleEntering = normalizedTransitionCallback(onEntering);
  var handleEnter = normalizedTransitionCallback(function(node, isAppearing) {
    reflow(node);
    var transitionProps = getTransitionProps({
      style,
      timeout: timeout3
    }, {
      mode: "enter"
    });
    node.style.webkitTransition = theme6.transitions.create("opacity", transitionProps);
    node.style.transition = theme6.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node, isAppearing);
    }
  });
  var handleEntered = normalizedTransitionCallback(onEntered);
  var handleExiting = normalizedTransitionCallback(onExiting);
  var handleExit = normalizedTransitionCallback(function(node) {
    var transitionProps = getTransitionProps({
      style,
      timeout: timeout3
    }, {
      mode: "exit"
    });
    node.style.webkitTransition = theme6.transitions.create("opacity", transitionProps);
    node.style.transition = theme6.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node);
    }
  });
  var handleExited = normalizedTransitionCallback(onExited);
  return /* @__PURE__ */ createElement18(TransitionComponent, _extends({
    appear: true,
    in: inProp,
    nodeRef: enableStrictModeCompat ? nodeRef : void 0,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    timeout: timeout3
  }, other), function(state, childProps) {
    return /* @__PURE__ */ cloneElement4(children, _extends({
      style: _extends({
        opacity: 0,
        visibility: state === "exited" && !inProp ? "hidden" : void 0
      }, styles20[state], style, children.props.style),
      ref: handleRef
    }, childProps));
  });
});
false ? Fade.propTypes = {
  children: import_prop_types21.default.element,
  disableStrictModeCompat: import_prop_types21.default.bool,
  in: import_prop_types21.default.bool,
  onEnter: import_prop_types21.default.func,
  onEntered: import_prop_types21.default.func,
  onEntering: import_prop_types21.default.func,
  onExit: import_prop_types21.default.func,
  onExited: import_prop_types21.default.func,
  onExiting: import_prop_types21.default.func,
  style: import_prop_types21.default.object,
  timeout: import_prop_types21.default.oneOfType([import_prop_types21.default.number, import_prop_types21.default.shape({
    appear: import_prop_types21.default.number,
    enter: import_prop_types21.default.number,
    exit: import_prop_types21.default.number
  })])
} : void 0;
var Fade_default = Fade;

// node_modules/@material-ui/core/esm/Backdrop/Backdrop.js
var styles21 = {
  root: {
    zIndex: -1,
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent"
  },
  invisible: {
    backgroundColor: "transparent"
  }
};
var Backdrop = /* @__PURE__ */ forwardRef16(function Backdrop2(props, ref) {
  var children = props.children, classes = props.classes, className = props.className, _props$invisible = props.invisible, invisible = _props$invisible === void 0 ? false : _props$invisible, open = props.open, transitionDuration = props.transitionDuration, _props$TransitionComp = props.TransitionComponent, TransitionComponent = _props$TransitionComp === void 0 ? Fade_default : _props$TransitionComp, other = _objectWithoutProperties(props, ["children", "classes", "className", "invisible", "open", "transitionDuration", "TransitionComponent"]);
  return /* @__PURE__ */ createElement19(TransitionComponent, _extends({
    in: open,
    timeout: transitionDuration
  }, other), /* @__PURE__ */ createElement19("div", {
    className: clsx_m_default(classes.root, className, invisible && classes.invisible),
    "aria-hidden": true,
    ref
  }, children));
});
false ? Backdrop.propTypes = {
  children: import_prop_types22.default.node,
  classes: import_prop_types22.default.object,
  className: import_prop_types22.default.string,
  invisible: import_prop_types22.default.bool,
  open: import_prop_types22.default.bool.isRequired,
  transitionDuration: import_prop_types22.default.oneOfType([import_prop_types22.default.number, import_prop_types22.default.shape({
    appear: import_prop_types22.default.number,
    enter: import_prop_types22.default.number,
    exit: import_prop_types22.default.number
  })])
} : void 0;
var Backdrop_default = withStyles_default(styles21, {
  name: "MuiBackdrop"
})(Backdrop);

// node_modules/@material-ui/core/esm/Dialog/Dialog.js
var styles22 = function styles23(theme6) {
  return {
    root: {
      "@media print": {
        position: "absolute !important"
      }
    },
    scrollPaper: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    },
    scrollBody: {
      overflowY: "auto",
      overflowX: "hidden",
      textAlign: "center",
      "&:after": {
        content: '""',
        display: "inline-block",
        verticalAlign: "middle",
        height: "100%",
        width: "0"
      }
    },
    container: {
      height: "100%",
      "@media print": {
        height: "auto"
      },
      outline: 0
    },
    paper: {
      margin: 32,
      position: "relative",
      overflowY: "auto",
      "@media print": {
        overflowY: "visible",
        boxShadow: "none"
      }
    },
    paperScrollPaper: {
      display: "flex",
      flexDirection: "column",
      maxHeight: "calc(100% - 64px)"
    },
    paperScrollBody: {
      display: "inline-block",
      verticalAlign: "middle",
      textAlign: "left"
    },
    paperWidthFalse: {
      maxWidth: "calc(100% - 64px)"
    },
    paperWidthXs: {
      maxWidth: Math.max(theme6.breakpoints.values.xs, 444),
      "&$paperScrollBody": _defineProperty({}, theme6.breakpoints.down(Math.max(theme6.breakpoints.values.xs, 444) + 32 * 2), {
        maxWidth: "calc(100% - 64px)"
      })
    },
    paperWidthSm: {
      maxWidth: theme6.breakpoints.values.sm,
      "&$paperScrollBody": _defineProperty({}, theme6.breakpoints.down(theme6.breakpoints.values.sm + 32 * 2), {
        maxWidth: "calc(100% - 64px)"
      })
    },
    paperWidthMd: {
      maxWidth: theme6.breakpoints.values.md,
      "&$paperScrollBody": _defineProperty({}, theme6.breakpoints.down(theme6.breakpoints.values.md + 32 * 2), {
        maxWidth: "calc(100% - 64px)"
      })
    },
    paperWidthLg: {
      maxWidth: theme6.breakpoints.values.lg,
      "&$paperScrollBody": _defineProperty({}, theme6.breakpoints.down(theme6.breakpoints.values.lg + 32 * 2), {
        maxWidth: "calc(100% - 64px)"
      })
    },
    paperWidthXl: {
      maxWidth: theme6.breakpoints.values.xl,
      "&$paperScrollBody": _defineProperty({}, theme6.breakpoints.down(theme6.breakpoints.values.xl + 32 * 2), {
        maxWidth: "calc(100% - 64px)"
      })
    },
    paperFullWidth: {
      width: "calc(100% - 64px)"
    },
    paperFullScreen: {
      margin: 0,
      width: "100%",
      maxWidth: "100%",
      height: "100%",
      maxHeight: "none",
      borderRadius: 0,
      "&$paperScrollBody": {
        margin: 0,
        maxWidth: "100%"
      }
    }
  };
};
var defaultTransitionDuration = {
  enter: duration.enteringScreen,
  exit: duration.leavingScreen
};
var Dialog = /* @__PURE__ */ forwardRef17(function Dialog2(props, ref) {
  var BackdropProps = props.BackdropProps, children = props.children, classes = props.classes, className = props.className, _props$disableBackdro = props.disableBackdropClick, disableBackdropClick = _props$disableBackdro === void 0 ? false : _props$disableBackdro, _props$disableEscapeK = props.disableEscapeKeyDown, disableEscapeKeyDown = _props$disableEscapeK === void 0 ? false : _props$disableEscapeK, _props$fullScreen = props.fullScreen, fullScreen = _props$fullScreen === void 0 ? false : _props$fullScreen, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, _props$maxWidth = props.maxWidth, maxWidth = _props$maxWidth === void 0 ? "sm" : _props$maxWidth, onBackdropClick = props.onBackdropClick, onClose = props.onClose, onEnter = props.onEnter, onEntered = props.onEntered, onEntering = props.onEntering, onEscapeKeyDown = props.onEscapeKeyDown, onExit = props.onExit, onExited = props.onExited, onExiting = props.onExiting, open = props.open, _props$PaperComponent = props.PaperComponent, PaperComponent = _props$PaperComponent === void 0 ? Paper_default : _props$PaperComponent, _props$PaperProps = props.PaperProps, PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps, _props$scroll = props.scroll, scroll = _props$scroll === void 0 ? "paper" : _props$scroll, _props$TransitionComp = props.TransitionComponent, TransitionComponent = _props$TransitionComp === void 0 ? Fade_default : _props$TransitionComp, _props$transitionDura = props.transitionDuration, transitionDuration = _props$transitionDura === void 0 ? defaultTransitionDuration : _props$transitionDura, TransitionProps = props.TransitionProps, ariaDescribedby = props["aria-describedby"], ariaLabelledby = props["aria-labelledby"], other = _objectWithoutProperties(props, ["BackdropProps", "children", "classes", "className", "disableBackdropClick", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "onEnter", "onEntered", "onEntering", "onEscapeKeyDown", "onExit", "onExited", "onExiting", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps", "aria-describedby", "aria-labelledby"]);
  var mouseDownTarget = useRef6();
  var handleMouseDown = function handleMouseDown2(event) {
    mouseDownTarget.current = event.target;
  };
  var handleBackdropClick = function handleBackdropClick2(event) {
    if (event.target !== event.currentTarget) {
      return;
    }
    if (event.target !== mouseDownTarget.current) {
      return;
    }
    mouseDownTarget.current = null;
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (!disableBackdropClick && onClose) {
      onClose(event, "backdropClick");
    }
  };
  return /* @__PURE__ */ createElement20(Modal_default, _extends({
    className: clsx_m_default(classes.root, className),
    BackdropComponent: Backdrop_default,
    BackdropProps: _extends({
      transitionDuration
    }, BackdropProps),
    closeAfterTransition: true,
    disableBackdropClick,
    disableEscapeKeyDown,
    onEscapeKeyDown,
    onClose,
    open,
    ref
  }, other), /* @__PURE__ */ createElement20(TransitionComponent, _extends({
    appear: true,
    in: open,
    timeout: transitionDuration,
    onEnter,
    onEntering,
    onEntered,
    onExit,
    onExiting,
    onExited,
    role: "none presentation"
  }, TransitionProps), /* @__PURE__ */ createElement20("div", {
    className: clsx_m_default(classes.container, classes["scroll".concat(capitalize(scroll))]),
    onMouseUp: handleBackdropClick,
    onMouseDown: handleMouseDown
  }, /* @__PURE__ */ createElement20(PaperComponent, _extends({
    elevation: 24,
    role: "dialog",
    "aria-describedby": ariaDescribedby,
    "aria-labelledby": ariaLabelledby
  }, PaperProps, {
    className: clsx_m_default(classes.paper, classes["paperScroll".concat(capitalize(scroll))], classes["paperWidth".concat(capitalize(String(maxWidth)))], PaperProps.className, fullScreen && classes.paperFullScreen, fullWidth && classes.paperFullWidth)
  }), children))));
});
false ? Dialog.propTypes = {
  "aria-describedby": import_prop_types23.default.string,
  "aria-labelledby": import_prop_types23.default.string,
  BackdropProps: import_prop_types23.default.object,
  children: import_prop_types23.default.node,
  classes: import_prop_types23.default.object,
  className: import_prop_types23.default.string,
  disableBackdropClick: import_prop_types23.default.bool,
  disableEscapeKeyDown: import_prop_types23.default.bool,
  fullScreen: import_prop_types23.default.bool,
  fullWidth: import_prop_types23.default.bool,
  maxWidth: import_prop_types23.default.oneOf(["lg", "md", "sm", "xl", "xs", false]),
  onBackdropClick: import_prop_types23.default.func,
  onClose: import_prop_types23.default.func,
  onEnter: import_prop_types23.default.func,
  onEntered: import_prop_types23.default.func,
  onEntering: import_prop_types23.default.func,
  onEscapeKeyDown: import_prop_types23.default.func,
  onExit: import_prop_types23.default.func,
  onExited: import_prop_types23.default.func,
  onExiting: import_prop_types23.default.func,
  open: import_prop_types23.default.bool.isRequired,
  PaperComponent: import_prop_types23.default.elementType,
  PaperProps: import_prop_types23.default.object,
  scroll: import_prop_types23.default.oneOf(["body", "paper"]),
  TransitionComponent: import_prop_types23.default.elementType,
  transitionDuration: import_prop_types23.default.oneOfType([import_prop_types23.default.number, import_prop_types23.default.shape({
    appear: import_prop_types23.default.number,
    enter: import_prop_types23.default.number,
    exit: import_prop_types23.default.number
  })]),
  TransitionProps: import_prop_types23.default.object
} : void 0;
var Dialog_default = withStyles_default(styles22, {
  name: "MuiDialog"
})(Dialog);

// src/client/components/Dialog/Dialog.tsx
var BaseDialog = styled9(Dialog_default)`
  .MuiDialog-paper {
    border: 1px solid ${(props) => props.theme.palette.grey[800]};
  }
`;
var Dialog3 = (props) => /* @__PURE__ */ React38.createElement(BaseDialog, {
  ...props
});
var Dialog_default2 = Dialog3;

// src/client/services/Picker/reducer.ts
var import_typesafe_actions2 = __toModule(require_typesafe_actions_umd_production());
var actions2 = {
  register: import_typesafe_actions2.createAction("REGISTER_PICKER_PROVIDER")(),
  unregister: import_typesafe_actions2.createAction("UNREGISTER_PICKER_PROVIDER")(),
  close: import_typesafe_actions2.createAction("CLOSE_PICKER_PROVIDER")(),
  setText: import_typesafe_actions2.createAction("SET_TEXT_PICKER_PROVIDER")()
};
function removeProvider(providers, provider) {
  return providers.filter((p) => p.activationPrefix !== provider.activationPrefix);
}
function findActiveProviderIndex(text, providers) {
  if (text === null) {
    return -1;
  }
  return providers.sort((a, b) => b.activationPrefix.length - a.activationPrefix.length).findIndex((provider) => text.replace(/^\s+/, "").startsWith(provider.activationPrefix));
}
var initialState2 = {
  activeProviderIndex: -1,
  text: null,
  providers: []
};
var pickerReducer = import_typesafe_actions2.createReducer(initialState2).handleAction(actions2.register, (state, action) => {
  const providers = removeProvider(state.providers, action.payload).concat(action.payload);
  const activeProviderIndex = findActiveProviderIndex(state.text, providers);
  return {
    ...state,
    providers,
    activeProviderIndex
  };
}).handleAction(actions2.unregister, (state, action) => {
  const providers = removeProvider(state.providers, action.payload);
  const activeProviderIndex = findActiveProviderIndex(state.text, providers);
  return {
    ...state,
    providers,
    activeProviderIndex
  };
}).handleAction(actions2.close, (state, _) => {
  return {
    ...state,
    activeProviderIndex: -1,
    text: null
  };
}).handleAction(actions2.setText, (state, action) => {
  const activeProviderIndex = findActiveProviderIndex(action.payload, state.providers);
  return {
    ...state,
    text: action.payload,
    activeProviderIndex
  };
});

// node_modules/@material-ui/core/esm/Divider/Divider.js
var import_prop_types24 = __toModule(require_prop_types());
import {
  createElement as createElement21,
  forwardRef as forwardRef18
} from "https://cdn.skypack.dev/react";
var styles24 = function styles25(theme6) {
  return {
    root: {
      height: 1,
      margin: 0,
      border: "none",
      flexShrink: 0,
      backgroundColor: theme6.palette.divider
    },
    absolute: {
      position: "absolute",
      bottom: 0,
      left: 0,
      width: "100%"
    },
    inset: {
      marginLeft: 72
    },
    light: {
      backgroundColor: fade(theme6.palette.divider, 0.08)
    },
    middle: {
      marginLeft: theme6.spacing(2),
      marginRight: theme6.spacing(2)
    },
    vertical: {
      height: "100%",
      width: 1
    },
    flexItem: {
      alignSelf: "stretch",
      height: "auto"
    }
  };
};
var Divider = /* @__PURE__ */ forwardRef18(function Divider2(props, ref) {
  var _props$absolute = props.absolute, absolute = _props$absolute === void 0 ? false : _props$absolute, classes = props.classes, className = props.className, _props$component = props.component, Component5 = _props$component === void 0 ? "hr" : _props$component, _props$flexItem = props.flexItem, flexItem = _props$flexItem === void 0 ? false : _props$flexItem, _props$light = props.light, light = _props$light === void 0 ? false : _props$light, _props$orientation = props.orientation, orientation = _props$orientation === void 0 ? "horizontal" : _props$orientation, _props$role = props.role, role = _props$role === void 0 ? Component5 !== "hr" ? "separator" : void 0 : _props$role, _props$variant = props.variant, variant = _props$variant === void 0 ? "fullWidth" : _props$variant, other = _objectWithoutProperties(props, ["absolute", "classes", "className", "component", "flexItem", "light", "orientation", "role", "variant"]);
  return /* @__PURE__ */ createElement21(Component5, _extends({
    className: clsx_m_default(classes.root, className, variant !== "fullWidth" && classes[variant], absolute && classes.absolute, flexItem && classes.flexItem, light && classes.light, orientation === "vertical" && classes.vertical),
    role,
    ref
  }, other));
});
false ? Divider.propTypes = {
  absolute: import_prop_types24.default.bool,
  children: import_prop_types24.default.node,
  classes: import_prop_types24.default.object,
  className: import_prop_types24.default.string,
  component: import_prop_types24.default.elementType,
  flexItem: import_prop_types24.default.bool,
  light: import_prop_types24.default.bool,
  orientation: import_prop_types24.default.oneOf(["horizontal", "vertical"]),
  role: import_prop_types24.default.string,
  variant: import_prop_types24.default.oneOf(["fullWidth", "inset", "middle"])
} : void 0;
var Divider_default = withStyles_default(styles24, {
  name: "MuiDivider"
})(Divider);

// ../../node_modules/match-sorter/dist/match-sorter.esm.js
var import_remove_accents = __toModule(require_remove_accents());
var rankings = {
  CASE_SENSITIVE_EQUAL: 9,
  EQUAL: 8,
  STARTS_WITH: 7,
  WORD_STARTS_WITH: 6,
  STRING_CASE: 5,
  STRING_CASE_ACRONYM: 4,
  CONTAINS: 3,
  ACRONYM: 2,
  MATCHES: 1,
  NO_MATCH: 0
};
var caseRankings = {
  CAMEL: 0.8,
  PASCAL: 0.6,
  KEBAB: 0.4,
  SNAKE: 0.2,
  NO_CASE: 0
};
matchSorter.rankings = rankings;
matchSorter.caseRankings = caseRankings;
var defaultBaseSortFn = function(a, b) {
  return String(a.rankedItem).localeCompare(b.rankedItem);
};
function matchSorter(items, value, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, keys = _options.keys, _options$threshold = _options.threshold, threshold = _options$threshold === void 0 ? rankings.MATCHES : _options$threshold, _options$baseSort = _options.baseSort, baseSort = _options$baseSort === void 0 ? defaultBaseSortFn : _options$baseSort;
  var matchedItems = items.reduce(reduceItemsToRanked, []);
  return matchedItems.sort(function(a, b) {
    return sortRankedItems(a, b, baseSort);
  }).map(function(_ref2) {
    var item = _ref2.item;
    return item;
  });
  function reduceItemsToRanked(matches, item, index2) {
    var _getHighestRanking = getHighestRanking(item, keys, value, options), rankedItem = _getHighestRanking.rankedItem, rank = _getHighestRanking.rank, keyIndex = _getHighestRanking.keyIndex, _getHighestRanking$ke = _getHighestRanking.keyThreshold, keyThreshold = _getHighestRanking$ke === void 0 ? threshold : _getHighestRanking$ke;
    if (rank >= keyThreshold) {
      matches.push({
        rankedItem,
        item,
        rank,
        index: index2,
        keyIndex
      });
    }
    return matches;
  }
}
function getHighestRanking(item, keys, value, options) {
  if (!keys) {
    return {
      rankedItem: item,
      rank: getMatchRanking(item, value, options),
      keyIndex: -1,
      keyThreshold: options.threshold
    };
  }
  var valuesToRank = getAllValuesToRank(item, keys);
  return valuesToRank.reduce(function(_ref2, _ref3, i) {
    var rank = _ref2.rank, rankedItem = _ref2.rankedItem, keyIndex = _ref2.keyIndex, keyThreshold = _ref2.keyThreshold;
    var itemValue = _ref3.itemValue, attributes = _ref3.attributes;
    var newRank = getMatchRanking(itemValue, value, options);
    var newRankedItem = rankedItem;
    var minRanking = attributes.minRanking, maxRanking = attributes.maxRanking, threshold = attributes.threshold;
    if (newRank < minRanking && newRank >= rankings.MATCHES) {
      newRank = minRanking;
    } else if (newRank > maxRanking) {
      newRank = maxRanking;
    }
    if (newRank > rank) {
      rank = newRank;
      keyIndex = i;
      keyThreshold = threshold;
      newRankedItem = itemValue;
    }
    return {
      rankedItem: newRankedItem,
      rank,
      keyIndex,
      keyThreshold
    };
  }, {
    rank: rankings.NO_MATCH,
    keyIndex: -1,
    keyThreshold: options.threshold
  });
}
function getMatchRanking(testString, stringToRank, options) {
  testString = prepareValueForComparison(testString, options);
  stringToRank = prepareValueForComparison(stringToRank, options);
  if (stringToRank.length > testString.length) {
    return rankings.NO_MATCH;
  }
  if (testString === stringToRank) {
    return rankings.CASE_SENSITIVE_EQUAL;
  }
  var caseRank = getCaseRanking(testString);
  var isPartial = isPartialOfCase(testString, stringToRank, caseRank);
  var isCasedAcronym = isCaseAcronym(testString, stringToRank, caseRank);
  testString = testString.toLowerCase();
  stringToRank = stringToRank.toLowerCase();
  if (testString === stringToRank) {
    return rankings.EQUAL + caseRank;
  }
  if (testString.indexOf(stringToRank) === 0) {
    return rankings.STARTS_WITH + caseRank;
  }
  if (testString.indexOf(" " + stringToRank) !== -1) {
    return rankings.WORD_STARTS_WITH + caseRank;
  }
  if (isPartial) {
    return rankings.STRING_CASE + caseRank;
  }
  if (caseRank > 0 && isCasedAcronym) {
    return rankings.STRING_CASE_ACRONYM + caseRank;
  }
  if (testString.indexOf(stringToRank) !== -1) {
    return rankings.CONTAINS + caseRank;
  } else if (stringToRank.length === 1) {
    return rankings.NO_MATCH;
  }
  if (getAcronym(testString).indexOf(stringToRank) !== -1) {
    return rankings.ACRONYM + caseRank;
  }
  return getClosenessRanking(testString, stringToRank);
}
function getAcronym(string5) {
  var acronym = "";
  var wordsInString = string5.split(" ");
  wordsInString.forEach(function(wordInString) {
    var splitByHyphenWords = wordInString.split("-");
    splitByHyphenWords.forEach(function(splitByHyphenWord) {
      acronym += splitByHyphenWord.substr(0, 1);
    });
  });
  return acronym;
}
function getCaseRanking(testString) {
  var containsUpperCase = testString.toLowerCase() !== testString;
  var containsDash = testString.indexOf("-") >= 0;
  var containsUnderscore = testString.indexOf("_") >= 0;
  if (!containsUpperCase && !containsUnderscore && containsDash) {
    return caseRankings.KEBAB;
  }
  if (!containsUpperCase && containsUnderscore && !containsDash) {
    return caseRankings.SNAKE;
  }
  if (containsUpperCase && !containsDash && !containsUnderscore) {
    var startsWithUpperCase = testString[0].toUpperCase() === testString[0];
    if (startsWithUpperCase) {
      return caseRankings.PASCAL;
    }
    return caseRankings.CAMEL;
  }
  return caseRankings.NO_CASE;
}
function isPartialOfCase(testString, stringToRank, caseRanking) {
  var testIndex = testString.toLowerCase().indexOf(stringToRank.toLowerCase());
  switch (caseRanking) {
    case caseRankings.SNAKE:
      return testString[testIndex - 1] === "_";
    case caseRankings.KEBAB:
      return testString[testIndex - 1] === "-";
    case caseRankings.PASCAL:
    case caseRankings.CAMEL:
      return testIndex !== -1 && testString[testIndex] === testString[testIndex].toUpperCase();
    default:
      return false;
  }
}
function isCaseAcronym(testString, stringToRank, caseRank) {
  var splitValue = null;
  switch (caseRank) {
    case caseRankings.SNAKE:
      splitValue = "_";
      break;
    case caseRankings.KEBAB:
      splitValue = "-";
      break;
    case caseRankings.PASCAL:
    case caseRankings.CAMEL:
      splitValue = /(?=[A-Z])/;
      break;
    default:
      splitValue = null;
  }
  var splitTestString = testString.split(splitValue);
  return stringToRank.toLowerCase().split("").reduce(function(correct, char, charIndex) {
    var splitItem = splitTestString[charIndex];
    return correct && splitItem && splitItem[0].toLowerCase() === char;
  }, true);
}
function getClosenessRanking(testString, stringToRank) {
  var matchingInOrderCharCount = 0;
  var charNumber = 0;
  function findMatchingCharacter(matchChar2, string5, index2) {
    for (var j = index2; j < string5.length; j++) {
      var stringChar = string5[j];
      if (stringChar === matchChar2) {
        matchingInOrderCharCount += 1;
        return j + 1;
      }
    }
    return -1;
  }
  function getRanking(spread2) {
    var inOrderPercentage = matchingInOrderCharCount / stringToRank.length;
    var ranking = rankings.MATCHES + inOrderPercentage * (1 / spread2);
    return ranking;
  }
  var firstIndex2 = findMatchingCharacter(stringToRank[0], testString, 0);
  if (firstIndex2 < 0) {
    return rankings.NO_MATCH;
  }
  charNumber = firstIndex2;
  for (var i = 1; i < stringToRank.length; i++) {
    var matchChar = stringToRank[i];
    charNumber = findMatchingCharacter(matchChar, testString, charNumber);
    var found = charNumber > -1;
    if (!found) {
      return rankings.NO_MATCH;
    }
  }
  var spread = charNumber - firstIndex2;
  return getRanking(spread);
}
function sortRankedItems(a, b, baseSort) {
  var aFirst = -1;
  var bFirst = 1;
  var aRank = a.rank, aKeyIndex = a.keyIndex;
  var bRank = b.rank, bKeyIndex = b.keyIndex;
  if (aRank === bRank) {
    if (aKeyIndex === bKeyIndex) {
      return baseSort(a, b);
    } else {
      return aKeyIndex < bKeyIndex ? aFirst : bFirst;
    }
  } else {
    return aRank > bRank ? aFirst : bFirst;
  }
}
function prepareValueForComparison(value, _ref4) {
  var keepDiacritics = _ref4.keepDiacritics;
  value = "" + value;
  if (!keepDiacritics) {
    value = import_remove_accents.default(value);
  }
  return value;
}
function getItemValues(item, key) {
  if (typeof key === "object") {
    key = key.key;
  }
  var value;
  if (typeof key === "function") {
    value = key(item);
  } else if (key.indexOf(".") !== -1) {
    value = key.split(".").reduce(function(itemObj, nestedKey) {
      return itemObj ? itemObj[nestedKey] : null;
    }, item);
  } else {
    value = item[key];
  }
  return value != null ? [].concat(value) : null;
}
function getAllValuesToRank(item, keys) {
  return keys.reduce(function(allVals, key) {
    var values = getItemValues(item, key);
    if (values) {
      values.forEach(function(itemValue) {
        allVals.push({
          itemValue,
          attributes: getKeyAttributes(key)
        });
      });
    }
    return allVals;
  }, []);
}
function getKeyAttributes(key) {
  if (typeof key === "string") {
    key = {
      key
    };
  }
  return _extends({
    maxRanking: Infinity,
    minRanking: -Infinity
  }, key);
}
var match_sorter_esm_default = matchSorter;

// src/client/services/Picker/PickerService.tsx
var boundedIndex = (value, max) => {
  if (value < 0)
    return max;
  if (value > max)
    return 0;
  return value;
};
var PICKER_WIDTH = 400;
var PICKER_HEIGHT = 500;
function PickerList(props) {
  const {selectedIndex, onSelect, secondaryAction} = props;
  const renderItem = useCallback5(({data, index: index2}) => /* @__PURE__ */ React40.createElement(ButtonListItem, {
    selected: index2 === selectedIndex,
    onClick: () => onSelect(data),
    key: data.id
  }, /* @__PURE__ */ React40.createElement(ListItemText, {
    primary: data.text
  }), secondaryAction && /* @__PURE__ */ React40.createElement(ListItemSecondaryAction, null, secondaryAction(data))), [selectedIndex, onSelect, secondaryAction]);
  return /* @__PURE__ */ React40.createElement(Box_default, {
    width: PICKER_WIDTH,
    height: PICKER_HEIGHT
  }, /* @__PURE__ */ React40.createElement(List_default, {
    renderItem,
    items: props.options,
    itemSize: () => 30
  }));
}
var PickerProviderChildren = class extends React40.PureComponent {
  render() {
    return this.props.children;
  }
};
var pickerContext = React40.createContext(null);
function getActiveProvider(activeProviderIndex, providers) {
  return activeProviderIndex > -1 ? providers[activeProviderIndex] : null;
}
function PickerService({children}) {
  const [state, {register, unregister, close, setText}] = useTypesafeReducer(pickerReducer, initialState2, actions2);
  const [selectedIndex, setSelectedIndex] = useState5(0);
  const inputRef = React40.useRef();
  const activePicker = getActiveProvider(state.activeProviderIndex, state.providers);
  const filterValue = state.text?.replace(activePicker?.activationPrefix || "", "").replace(/^\s+/, "");
  const hasValidationError = activePicker?.textValidator ? !activePicker?.textValidator.test(filterValue || "") : false;
  const onSelect = useCallback5((selected) => {
    close();
    if (activePicker && selected) {
      activePicker.onSelected(selected, filterValue);
    }
  }, [activePicker, close, filterValue]);
  const options = useMemo2(() => {
    if (!activePicker) {
      return [];
    }
    return activePicker.options;
  }, [activePicker]);
  const picker = useMemo2(() => ({
    register,
    unregister,
    setText
  }), [register, unregister, setText]);
  useEffect6(() => {
    setSelectedIndex(0);
  }, [activePicker?.activationPrefix]);
  const filteredOptions = activePicker?.disableFilter ? options : match_sorter_esm_default(options, filterValue || "", {
    keys: ["text"]
  });
  return /* @__PURE__ */ React40.createElement(React40.Fragment, null, /* @__PURE__ */ React40.createElement(pickerContext.Provider, {
    value: picker
  }, /* @__PURE__ */ React40.createElement(PickerProviderChildren, null, children)), /* @__PURE__ */ React40.createElement(Dialog_default2, {
    "data-testid": "dialog",
    open: state.activeProviderIndex > -1,
    onClose: close,
    maxWidth: "md"
  }, /* @__PURE__ */ React40.createElement(Box_default, {
    pr: 2,
    pl: 2,
    pt: 1,
    pb: 1
  }, activePicker?.title ? /* @__PURE__ */ React40.createElement(Box_default, {
    width: "100%",
    pb: 1
  }, /* @__PURE__ */ React40.createElement(Typography_default2, {
    color: "textSecondary",
    variant: "h6"
  }, activePicker.title)) : null, /* @__PURE__ */ React40.createElement(Box_default, {
    height: activePicker?.disableInput ? "0px" : "auto",
    width: "100%",
    overflow: "hidden"
  }, /* @__PURE__ */ React40.createElement(InputBase_default, {
    inputRef,
    onKeyDown: (e) => {
      if (e.key === "ArrowUp") {
        e.preventDefault();
        setSelectedIndex(boundedIndex(selectedIndex - 1, filteredOptions.length - 1));
      }
      if (e.key === "ArrowDown") {
        e.preventDefault();
        setSelectedIndex(boundedIndex(selectedIndex + 1, filteredOptions.length - 1));
      }
      if (e.key === "Enter") {
        if (!hasValidationError) {
          onSelect(filteredOptions[selectedIndex]);
        }
      }
    },
    onBlur: () => {
      inputRef.current?.focus();
    },
    fullWidth: true,
    autoFocus: true,
    value: state.text || "",
    inputProps: {"aria-label": "picker filter"},
    onChange: (e) => {
      setText(e.target.value);
    }
  })), /* @__PURE__ */ React40.createElement(Divider_default, null)), hasValidationError ? /* @__PURE__ */ React40.createElement(Box_default, {
    width: PICKER_WIDTH,
    height: PICKER_HEIGHT,
    textAlign: "center"
  }, /* @__PURE__ */ React40.createElement(Typography_default2, {
    variant: "caption",
    color: "textSecondary"
  }, activePicker?.textValidationFailedMessage || `Input must satisfy ${activePicker?.textValidator?.toString()}`)) : /* @__PURE__ */ React40.createElement(PickerList, {
    selectedIndex,
    onSelect,
    options: filteredOptions,
    secondaryAction: activePicker?.secondaryAction
  })));
}
function usePickerService(provider, dependencies) {
  const picker = React40.useContext(pickerContext);
  if (!picker) {
    throw new Error("usePickerService must be used within a PickerService.");
  }
  useEffect6(() => {
    if (provider) {
      picker.register(provider);
    }
    return () => {
      if (provider) {
        picker.unregister(provider);
      }
    };
  }, dependencies || []);
  return useMemo2(() => ({
    activatePickerWithText: picker.setText
  }), [picker.setText]);
}
var PickerService_default = React40.memo(PickerService);

// src/client/services/Command/CommandPicker.tsx
var cmdID = "open-command-picker";
function commandToPickerOption(cmd) {
  return {
    id: cmd.id,
    text: cmd.description
  };
}
function filterCommands(cmds) {
  return cmds.filter((cmd) => cmd.id !== cmdID && cmd.category !== "Hidden" && !cmd.disabled).map(commandToPickerOption);
}
function renderKeybindings(data) {
  if (!data?.keybindings?.length) {
    return null;
  }
  const keybindings = data.keybindings.map((keys) => getKeysFromKeybinding(keys));
  return /* @__PURE__ */ React41.createElement(Box_default, {
    display: "flex"
  }, keybindings.map((keys, idx) => /* @__PURE__ */ React41.createElement(Box_default, {
    display: "flex",
    ml: 1,
    key: `keybinding-${idx}`
  }, keys.map((keyCode, partIdx) => /* @__PURE__ */ React41.createElement(Box_default, {
    bgcolor: "grey.500",
    p: 0.3,
    ml: 0.3,
    key: `keybinding-key-${partIdx}`
  }, keyCode)))));
}
function CommandPicker({commands}) {
  const cmdService = useCommandService({
    id: cmdID,
    description: "Show and Run Commands",
    handler: (e) => {
      e.keyboardEvent?.preventDefault();
      activatePickerWithText("");
    },
    keybindings: ["mod+p"]
  });
  const getCommand = useCallback6((id) => commands.find((command) => command.id === id), [commands]);
  const {activatePickerWithText} = usePickerService({
    activationPrefix: "",
    options: filterCommands(commands),
    onSelected: (option) => {
      cmdService.executeCommand(option.id);
    },
    secondaryAction: (option) => renderKeybindings(getCommand(option.id))
  }, [commands]);
  return null;
}
var CommandPicker_default = React41.memo(CommandPicker);

// src/client/services/Command/CommandService.tsx
var CommandServiceChildren = class extends React42.PureComponent {
  render() {
    return this.props.children;
  }
};
var commandServiceContext = React42.createContext(null);
function CommandContextProvider({children}) {
  const [state, {register, unregister}] = useTypesafeReducer(commandServiceReducer, initialState, actions);
  const executeCommand = useCallback7((id, args, e) => {
    const cmd = state.commands.find((cmd2) => cmd2.id === id);
    if (cmd) {
      cmd.handler(e || {preventNext: () => {
      }}, args);
    }
  }, [state.commands]);
  useEffect7(() => {
    function handleKeyboardEvent(e, {key}) {
      if (key in state.keyBindings) {
        const cmds = state.keyBindings[key];
        let abort = false;
        const event = {
          keyboardEvent: e,
          preventNext: () => abort = true
        };
        let idx = 0;
        while (!abort && idx < cmds.length) {
          cmds[idx++].handler(event);
        }
      }
    }
    const keybindings = Object.keys(state.keyBindings);
    keybindings.forEach((kb) => hotkeys_esm_default(kb, handleKeyboardEvent));
    return () => keybindings.forEach((kb) => hotkeys_esm_default.unbind(kb, handleKeyboardEvent));
  }, [state.keyBindings]);
  const commandService = {
    register,
    unregister,
    executeCommand
  };
  return /* @__PURE__ */ React42.createElement(commandServiceContext.Provider, {
    value: commandService
  }, /* @__PURE__ */ React42.createElement(CommandServiceChildren, null, children), /* @__PURE__ */ React42.createElement(CommandPicker_default, {
    commands: state.commands
  }));
}
function useCommandService(command, dependencies) {
  const commandService = useContext3(commandServiceContext);
  if (!commandService) {
    throw new Error("useCommandService must be used within a CommandService.");
  }
  useEffect7(() => {
    if (command) {
      commandService.register(command);
    }
    return () => {
      if (command)
        commandService.unregister(command);
    };
  }, dependencies || []);
  return useMemo3(() => ({executeCommand: commandService.executeCommand}), [
    commandService.executeCommand
  ]);
}
var CommandService_default = React42.memo(CommandContextProvider);

// src/state/provider.tsx
import React46, {useRef as useRef9} from "https://cdn.skypack.dev/react";

// ../../node_modules/react-redux/es/components/Provider.js
var import_prop_types25 = __toModule(require_prop_types());
import React44, {useMemo as useMemo4, useEffect as useEffect8} from "https://cdn.skypack.dev/react";

// ../../node_modules/react-redux/es/components/Context.js
import React43 from "https://cdn.skypack.dev/react";
var ReactReduxContext = /* @__PURE__ */ React43.createContext(null);
if (false) {
  ReactReduxContext.displayName = "ReactRedux";
}

// ../../node_modules/react-redux/es/utils/batch.js
function defaultNoopBatch(callback) {
  callback();
}
var batch = defaultNoopBatch;
var setBatch = function setBatch2(newBatch) {
  return batch = newBatch;
};
var getBatch = function getBatch2() {
  return batch;
};

// ../../node_modules/react-redux/es/utils/Subscription.js
var nullListeners = {
  notify: function notify() {
  }
};
function createListenerCollection() {
  var batch2 = getBatch();
  var first2 = null;
  var last = null;
  return {
    clear: function clear3() {
      first2 = null;
      last = null;
    },
    notify: function notify2() {
      batch2(function() {
        var listener = first2;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get: function get() {
      var listeners = [];
      var listener = first2;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe: function subscribe5(callback) {
      var isSubscribed = true;
      var listener = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first2 = listener;
      }
      return function unsubscribe5() {
        if (!isSubscribed || first2 === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first2 = listener.next;
        }
      };
    }
  };
}
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(store, parentSub) {
    this.store = store;
    this.parentSub = parentSub;
    this.unsubscribe = null;
    this.listeners = nullListeners;
    this.handleChangeWrapper = this.handleChangeWrapper.bind(this);
  }
  var _proto = Subscription2.prototype;
  _proto.addNestedSub = function addNestedSub(listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
  };
  _proto.notifyNestedSubs = function notifyNestedSubs() {
    this.listeners.notify();
  };
  _proto.handleChangeWrapper = function handleChangeWrapper() {
    if (this.onStateChange) {
      this.onStateChange();
    }
  };
  _proto.isSubscribed = function isSubscribed() {
    return Boolean(this.unsubscribe);
  };
  _proto.trySubscribe = function trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.handleChangeWrapper) : this.store.subscribe(this.handleChangeWrapper);
      this.listeners = createListenerCollection();
    }
  };
  _proto.tryUnsubscribe = function tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
      this.listeners.clear();
      this.listeners = nullListeners;
    }
  };
  return Subscription2;
}();

// ../../node_modules/react-redux/es/components/Provider.js
function Provider(_ref2) {
  var store = _ref2.store, context2 = _ref2.context, children = _ref2.children;
  var contextValue = useMemo4(function() {
    var subscription = new Subscription(store);
    subscription.onStateChange = subscription.notifyNestedSubs;
    return {
      store,
      subscription
    };
  }, [store]);
  var previousState = useMemo4(function() {
    return store.getState();
  }, [store]);
  useEffect8(function() {
    var subscription = contextValue.subscription;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return function() {
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
    };
  }, [contextValue, previousState]);
  var Context3 = context2 || ReactReduxContext;
  return /* @__PURE__ */ React44.createElement(Context3.Provider, {
    value: contextValue
  }, children);
}
if (false) {
  Provider.propTypes = {
    store: import_prop_types25.default.shape({
      subscribe: import_prop_types25.default.func.isRequired,
      dispatch: import_prop_types25.default.func.isRequired,
      getState: import_prop_types25.default.func.isRequired
    }),
    context: import_prop_types25.default.object,
    children: import_prop_types25.default.any
  };
}
var Provider_default = Provider;

// ../../node_modules/react-redux/es/components/connectAdvanced.js
var import_hoist_non_react_statics2 = __toModule(require_hoist_non_react_statics_cjs());
var import_react_is2 = __toModule(require_react_is2());
import React45, {useContext as useContext4, useMemo as useMemo5, useRef as useRef7, useReducer as useReducer2} from "https://cdn.skypack.dev/react";

// ../../node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js
import {useEffect as useEffect9, useLayoutEffect as useLayoutEffect4} from "https://cdn.skypack.dev/react";
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? useLayoutEffect4 : useEffect9;

// ../../node_modules/react-redux/es/hooks/useStore.js
import {useContext as useContext6} from "https://cdn.skypack.dev/react";

// ../../node_modules/react-redux/es/hooks/useReduxContext.js
import {useContext as useContext5} from "https://cdn.skypack.dev/react";
function useReduxContext() {
  var contextValue = useContext5(ReactReduxContext);
  if (false) {
    throw new Error("could not find react-redux context value; please ensure the component is wrapped in a <Provider>");
  }
  return contextValue;
}

// ../../node_modules/react-redux/es/hooks/useStore.js
function createStoreHook(context2) {
  if (context2 === void 0) {
    context2 = ReactReduxContext;
  }
  var useReduxContext2 = context2 === ReactReduxContext ? useReduxContext : function() {
    return useContext6(context2);
  };
  return function useStore2() {
    var _useReduxContext = useReduxContext2(), store = _useReduxContext.store;
    return store;
  };
}
var useStore = /* @__PURE__ */ createStoreHook();

// ../../node_modules/react-redux/es/hooks/useDispatch.js
function createDispatchHook(context2) {
  if (context2 === void 0) {
    context2 = ReactReduxContext;
  }
  var useStore2 = context2 === ReactReduxContext ? useStore : createStoreHook(context2);
  return function useDispatch2() {
    var store = useStore2();
    return store.dispatch;
  };
}
var useDispatch = /* @__PURE__ */ createDispatchHook();

// ../../node_modules/react-redux/es/hooks/useSelector.js
import {useReducer as useReducer3, useRef as useRef8, useMemo as useMemo6, useContext as useContext7, useDebugValue} from "https://cdn.skypack.dev/react";
var refEquality = function refEquality2(a, b) {
  return a === b;
};
function useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {
  var _useReducer = useReducer3(function(s) {
    return s + 1;
  }, 0), forceRender = _useReducer[1];
  var subscription = useMemo6(function() {
    return new Subscription(store, contextSub);
  }, [store, contextSub]);
  var latestSubscriptionCallbackError = useRef8();
  var latestSelector = useRef8();
  var latestStoreState = useRef8();
  var latestSelectedState = useRef8();
  var storeState = store.getState();
  var selectedState;
  try {
    if (selector !== latestSelector.current || storeState !== latestStoreState.current || latestSubscriptionCallbackError.current) {
      selectedState = selector(storeState);
    } else {
      selectedState = latestSelectedState.current;
    }
  } catch (err) {
    if (latestSubscriptionCallbackError.current) {
      err.message += "\nThe error may be correlated with this previous error:\n" + latestSubscriptionCallbackError.current.stack + "\n\n";
    }
    throw err;
  }
  useIsomorphicLayoutEffect(function() {
    latestSelector.current = selector;
    latestStoreState.current = storeState;
    latestSelectedState.current = selectedState;
    latestSubscriptionCallbackError.current = void 0;
  });
  useIsomorphicLayoutEffect(function() {
    function checkForUpdates() {
      try {
        var newSelectedState = latestSelector.current(store.getState());
        if (equalityFn(newSelectedState, latestSelectedState.current)) {
          return;
        }
        latestSelectedState.current = newSelectedState;
      } catch (err) {
        latestSubscriptionCallbackError.current = err;
      }
      forceRender();
    }
    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();
    checkForUpdates();
    return function() {
      return subscription.tryUnsubscribe();
    };
  }, [store, subscription]);
  return selectedState;
}
function createSelectorHook(context2) {
  if (context2 === void 0) {
    context2 = ReactReduxContext;
  }
  var useReduxContext2 = context2 === ReactReduxContext ? useReduxContext : function() {
    return useContext7(context2);
  };
  return function useSelector2(selector, equalityFn) {
    if (equalityFn === void 0) {
      equalityFn = refEquality;
    }
    if (false) {
      throw new Error("You must pass a selector to useSelector");
    }
    var _useReduxContext = useReduxContext2(), store = _useReduxContext.store, contextSub = _useReduxContext.subscription;
    var selectedState = useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub);
    useDebugValue(selectedState);
    return selectedState;
  };
}
var useSelector = /* @__PURE__ */ createSelectorHook();

// ../../node_modules/react-redux/es/utils/reactBatchedUpdates.js
import {unstable_batchedUpdates} from "https://cdn.skypack.dev/react-dom";

// ../../node_modules/react-redux/es/index.js
setBatch(unstable_batchedUpdates);

// src/state/store.ts
var import_redux3 = __toModule(require_redux());

// ../../node_modules/@redux-saga/symbols/dist/redux-saga-symbols.esm.js
var createSymbol = function createSymbol2(name) {
  return "@@redux-saga/" + name;
};
var CANCEL = /* @__PURE__ */ createSymbol("CANCEL_PROMISE");
var CHANNEL_END_TYPE = /* @__PURE__ */ createSymbol("CHANNEL_END");
var IO = /* @__PURE__ */ createSymbol("IO");
var MATCH = /* @__PURE__ */ createSymbol("MATCH");
var MULTICAST = /* @__PURE__ */ createSymbol("MULTICAST");
var SAGA_ACTION = /* @__PURE__ */ createSymbol("SAGA_ACTION");
var SELF_CANCELLATION = /* @__PURE__ */ createSymbol("SELF_CANCELLATION");
var TASK = /* @__PURE__ */ createSymbol("TASK");
var TASK_CANCEL = /* @__PURE__ */ createSymbol("TASK_CANCEL");
var TERMINATE = /* @__PURE__ */ createSymbol("TERMINATE");
var SAGA_LOCATION = /* @__PURE__ */ createSymbol("LOCATION");

// ../../node_modules/@redux-saga/is/dist/redux-saga-is.esm.js
var undef = function undef2(v) {
  return v === null || v === void 0;
};
var notUndef = function notUndef2(v) {
  return v !== null && v !== void 0;
};
var func = function func2(f) {
  return typeof f === "function";
};
var string = function string2(s) {
  return typeof s === "string";
};
var array = Array.isArray;
var promise = function promise2(p) {
  return p && func(p.then);
};
var iterator = function iterator2(it) {
  return it && func(it.next) && func(it.throw);
};
var pattern = function pattern2(pat) {
  return pat && (string(pat) || symbol(pat) || func(pat) || array(pat) && pat.every(pattern2));
};
var channel = function channel2(ch) {
  return ch && func(ch.take) && func(ch.close);
};
var stringableFunc = function stringableFunc2(f) {
  return func(f) && f.hasOwnProperty("toString");
};
var symbol = function symbol2(sym) {
  return Boolean(sym) && typeof Symbol === "function" && sym.constructor === Symbol && sym !== Symbol.prototype;
};
var multicast = function multicast2(ch) {
  return channel(ch) && ch[MULTICAST];
};

// ../../node_modules/@redux-saga/delay-p/dist/redux-saga-delay-p.esm.js
function delayP(ms, val) {
  if (val === void 0) {
    val = true;
  }
  var timeoutId;
  var promise3 = new Promise(function(resolve) {
    timeoutId = setTimeout(resolve, ms, val);
  });
  promise3[CANCEL] = function() {
    clearTimeout(timeoutId);
  };
  return promise3;
}
var redux_saga_delay_p_esm_default = delayP;

// ../../node_modules/@redux-saga/core/dist/io-6de156f3.js
var konst = function konst2(v) {
  return function() {
    return v;
  };
};
var kTrue = /* @__PURE__ */ konst(true);
var noop3 = function noop4() {
};
if (false) {
  noop3 = /* @__PURE__ */ new Proxy(noop3, {
    set: function set5() {
      throw internalErr("There was an attempt to assign a property to internal `noop` function.");
    }
  });
}
var identity = function identity2(v) {
  return v;
};
var hasSymbol = typeof Symbol === "function";
var asyncIteratorSymbol = hasSymbol && Symbol.asyncIterator ? Symbol.asyncIterator : "@@asyncIterator";
var assignWithSymbols = function assignWithSymbols2(target, source) {
  _extends(target, source);
  if (Object.getOwnPropertySymbols) {
    Object.getOwnPropertySymbols(source).forEach(function(s) {
      target[s] = source[s];
    });
  }
};
var flatMap = function flatMap2(mapper, arr) {
  var _ref2;
  return (_ref2 = []).concat.apply(_ref2, arr.map(mapper));
};
function remove(array4, item) {
  var index2 = array4.indexOf(item);
  if (index2 >= 0) {
    array4.splice(index2, 1);
  }
}
function once2(fn) {
  var called = false;
  return function() {
    if (called) {
      return;
    }
    called = true;
    fn();
  };
}
var kThrow = function kThrow2(err) {
  throw err;
};
var kReturn = function kReturn2(value) {
  return {
    value,
    done: true
  };
};
function makeIterator(next, thro, name) {
  if (thro === void 0) {
    thro = kThrow;
  }
  if (name === void 0) {
    name = "iterator";
  }
  var iterator3 = {
    meta: {
      name
    },
    next,
    throw: thro,
    return: kReturn,
    isSagaIterator: true
  };
  if (typeof Symbol !== "undefined") {
    iterator3[Symbol.iterator] = function() {
      return iterator3;
    };
  }
  return iterator3;
}
function logError(error, _ref2) {
  var sagaStack2 = _ref2.sagaStack;
  console.error(error);
  console.error(sagaStack2);
}
var internalErr = function internalErr2(err) {
  return new Error("\n  redux-saga: Error checking hooks detected an inconsistent state. This is likely a bug\n  in redux-saga code and not yours. Thanks for reporting this in the project's github repo.\n  Error: " + err + "\n");
};
var createEmptyArray = function createEmptyArray2(n) {
  return Array.apply(null, new Array(n));
};
var wrapSagaDispatch = function wrapSagaDispatch2(dispatch2) {
  return function(action) {
    if (false) {
      check(action, function(ac) {
        return !Object.isFrozen(ac);
      }, FROZEN_ACTION_ERROR);
    }
    return dispatch2(Object.defineProperty(action, SAGA_ACTION, {
      value: true
    }));
  };
};
var shouldTerminate = function shouldTerminate2(res) {
  return res === TERMINATE;
};
var shouldCancel = function shouldCancel2(res) {
  return res === TASK_CANCEL;
};
var shouldComplete = function shouldComplete2(res) {
  return shouldTerminate(res) || shouldCancel(res);
};
function createAllStyleChildCallbacks(shape, parentCallback) {
  var keys = Object.keys(shape);
  var totalCount = keys.length;
  if (false) {
    check(totalCount, function(c) {
      return c > 0;
    }, "createAllStyleChildCallbacks: get an empty array or object");
  }
  var completedCount = 0;
  var completed;
  var results = array(shape) ? createEmptyArray(totalCount) : {};
  var childCallbacks = {};
  function checkEnd() {
    if (completedCount === totalCount) {
      completed = true;
      parentCallback(results);
    }
  }
  keys.forEach(function(key) {
    var chCbAtKey = function chCbAtKey2(res, isErr) {
      if (completed) {
        return;
      }
      if (isErr || shouldComplete(res)) {
        parentCallback.cancel();
        parentCallback(res, isErr);
      } else {
        results[key] = res;
        completedCount++;
        checkEnd();
      }
    };
    chCbAtKey.cancel = noop3;
    childCallbacks[key] = chCbAtKey;
  });
  parentCallback.cancel = function() {
    if (!completed) {
      completed = true;
      keys.forEach(function(key) {
        return childCallbacks[key].cancel();
      });
    }
  };
  return childCallbacks;
}
function getMetaInfo(fn) {
  return {
    name: fn.name || "anonymous",
    location: getLocation(fn)
  };
}
function getLocation(instrumented) {
  return instrumented[SAGA_LOCATION];
}
var BUFFER_OVERFLOW = "Channel's Buffer overflow!";
var ON_OVERFLOW_THROW = 1;
var ON_OVERFLOW_SLIDE = 3;
var ON_OVERFLOW_EXPAND = 4;
var zeroBuffer = {
  isEmpty: kTrue,
  put: noop3,
  take: noop3
};
function ringBuffer(limit, overflowAction) {
  if (limit === void 0) {
    limit = 10;
  }
  var arr = new Array(limit);
  var length = 0;
  var pushIndex = 0;
  var popIndex = 0;
  var push = function push2(it) {
    arr[pushIndex] = it;
    pushIndex = (pushIndex + 1) % limit;
    length++;
  };
  var take2 = function take3() {
    if (length != 0) {
      var it = arr[popIndex];
      arr[popIndex] = null;
      length--;
      popIndex = (popIndex + 1) % limit;
      return it;
    }
  };
  var flush3 = function flush4() {
    var items = [];
    while (length) {
      items.push(take2());
    }
    return items;
  };
  return {
    isEmpty: function isEmpty2() {
      return length == 0;
    },
    put: function put2(it) {
      if (length < limit) {
        push(it);
      } else {
        var doubledLimit;
        switch (overflowAction) {
          case ON_OVERFLOW_THROW:
            throw new Error(BUFFER_OVERFLOW);
          case ON_OVERFLOW_SLIDE:
            arr[pushIndex] = it;
            pushIndex = (pushIndex + 1) % limit;
            popIndex = pushIndex;
            break;
          case ON_OVERFLOW_EXPAND:
            doubledLimit = 2 * limit;
            arr = flush3();
            length = arr.length;
            pushIndex = arr.length;
            popIndex = 0;
            arr.length = doubledLimit;
            limit = doubledLimit;
            push(it);
            break;
          default:
        }
      }
    },
    take: take2,
    flush: flush3
  };
}
var none = function none2() {
  return zeroBuffer;
};
var expanding = function expanding2(initialSize) {
  return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);
};
var TAKE = "TAKE";
var PUT = "PUT";
var ALL = "ALL";
var RACE = "RACE";
var CALL = "CALL";
var CPS = "CPS";
var FORK = "FORK";
var JOIN = "JOIN";
var CANCEL2 = "CANCEL";
var SELECT = "SELECT";
var ACTION_CHANNEL = "ACTION_CHANNEL";
var CANCELLED = "CANCELLED";
var FLUSH = "FLUSH";
var GET_CONTEXT = "GET_CONTEXT";
var SET_CONTEXT = "SET_CONTEXT";
var makeEffect = function makeEffect2(type, payload) {
  var _ref2;
  return _ref2 = {}, _ref2[IO] = true, _ref2.combinator = false, _ref2.type = type, _ref2.payload = payload, _ref2;
};
var detach = function detach2(eff) {
  if (false) {
    check(eff, isForkEffect, "detach(eff): argument must be a fork effect");
  }
  return makeEffect(FORK, _extends({}, eff.payload, {
    detached: true
  }));
};
function take(patternOrChannel, multicastPattern) {
  if (patternOrChannel === void 0) {
    patternOrChannel = "*";
  }
  if (false) {
    check(arguments[0], notUndef, "take(patternOrChannel): patternOrChannel is undefined");
  }
  if (pattern(patternOrChannel)) {
    return makeEffect(TAKE, {
      pattern: patternOrChannel
    });
  }
  if (multicast(patternOrChannel) && notUndef(multicastPattern) && pattern(multicastPattern)) {
    return makeEffect(TAKE, {
      channel: patternOrChannel,
      pattern: multicastPattern
    });
  }
  if (channel(patternOrChannel)) {
    return makeEffect(TAKE, {
      channel: patternOrChannel
    });
  }
  if (false) {
    throw new Error("take(patternOrChannel): argument " + patternOrChannel + " is not valid channel or a valid pattern");
  }
}
function put(channel$1, action) {
  if (false) {
    if (arguments.length > 1) {
      check(channel$1, notUndef, "put(channel, action): argument channel is undefined");
      check(channel$1, channel, "put(channel, action): argument " + channel$1 + " is not a valid channel");
      check(action, notUndef, "put(channel, action): argument action is undefined");
    } else {
      check(channel$1, notUndef, "put(action): argument action is undefined");
    }
  }
  if (undef(action)) {
    action = channel$1;
    channel$1 = void 0;
  }
  return makeEffect(PUT, {
    channel: channel$1,
    action
  });
}
var putResolve = function putResolve2() {
  var eff = put.apply(void 0, arguments);
  eff.payload.resolve = true;
  return eff;
};
function all(effects) {
  var eff = makeEffect(ALL, effects);
  eff.combinator = true;
  return eff;
}
function getFnCallDescriptor(fnDescriptor, args) {
  var context2 = null;
  var fn;
  if (func(fnDescriptor)) {
    fn = fnDescriptor;
  } else {
    if (array(fnDescriptor)) {
      context2 = fnDescriptor[0];
      fn = fnDescriptor[1];
    } else {
      context2 = fnDescriptor.context;
      fn = fnDescriptor.fn;
    }
    if (context2 && string(fn) && func(context2[fn])) {
      fn = context2[fn];
    }
  }
  return {
    context: context2,
    fn,
    args
  };
}
function call(fnDescriptor) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (false) {
    var arg0 = typeof args[0] === "number" ? args[0] : "ms";
    check(fnDescriptor, isNotDelayEffect, "instead of writing `yield call(delay, " + arg0 + ")` where delay is an effect from `redux-saga/effects` you should write `yield delay(" + arg0 + ")`");
    validateFnDescriptor("call", fnDescriptor);
  }
  return makeEffect(CALL, getFnCallDescriptor(fnDescriptor, args));
}
function fork(fnDescriptor) {
  if (false) {
    validateFnDescriptor("fork", fnDescriptor);
    check(fnDescriptor, function(arg) {
      return !effect(arg);
    }, "fork: argument must not be an effect");
  }
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return makeEffect(FORK, getFnCallDescriptor(fnDescriptor, args));
}
function spawn(fnDescriptor) {
  if (false) {
    validateFnDescriptor("spawn", fnDescriptor);
  }
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  return detach(fork.apply(void 0, [fnDescriptor].concat(args)));
}
function cancel(taskOrTasks) {
  if (taskOrTasks === void 0) {
    taskOrTasks = SELF_CANCELLATION;
  }
  if (false) {
    if (arguments.length > 1) {
      throw new Error("cancel(...tasks) is not supported any more. Please use cancel([...tasks]) to cancel multiple tasks.");
    }
    if (array(taskOrTasks)) {
      taskOrTasks.forEach(function(t) {
        check(t, task, "cancel([...tasks]): argument " + t + " is not a valid Task object " + TEST_HINT);
      });
    } else if (taskOrTasks !== SELF_CANCELLATION && notUndef(taskOrTasks)) {
      check(taskOrTasks, task, "cancel(task): argument " + taskOrTasks + " is not a valid Task object " + TEST_HINT);
    }
  }
  return makeEffect(CANCEL2, taskOrTasks);
}
function select(selector) {
  if (selector === void 0) {
    selector = identity;
  }
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  if (false) {
    check(arguments[0], notUndef, "select(selector, [...]): argument selector is undefined");
    check(selector, func, "select(selector, [...]): argument " + selector + " is not a function");
  }
  return makeEffect(SELECT, {
    selector,
    args
  });
}
function actionChannel(pattern$1, buffer$1) {
  if (false) {
    check(pattern$1, pattern, "actionChannel(pattern,...): argument pattern is not valid");
    if (arguments.length > 1) {
      check(buffer$1, notUndef, "actionChannel(pattern, buffer): argument buffer is undefined");
      check(buffer$1, buffer, "actionChannel(pattern, buffer): argument " + buffer$1 + " is not a valid buffer");
    }
  }
  return makeEffect(ACTION_CHANNEL, {
    pattern: pattern$1,
    buffer: buffer$1
  });
}
function cancelled() {
  return makeEffect(CANCELLED, {});
}
var delay = /* @__PURE__ */ call.bind(null, redux_saga_delay_p_esm_default);

// ../../node_modules/@redux-saga/core/dist/redux-saga-core.esm.js
var import_redux = __toModule(require_redux());

// ../../node_modules/@redux-saga/deferred/dist/redux-saga-deferred.esm.js
function deferred() {
  var def = {};
  def.promise = new Promise(function(resolve, reject) {
    def.resolve = resolve;
    def.reject = reject;
  });
  return def;
}
var redux_saga_deferred_esm_default = deferred;

// ../../node_modules/@redux-saga/core/dist/redux-saga-core.esm.js
var queue = [];
var semaphore = 0;
function exec(task2) {
  try {
    suspend();
    task2();
  } finally {
    release();
  }
}
function asap(task2) {
  queue.push(task2);
  if (!semaphore) {
    suspend();
    flush();
  }
}
function immediately(task2) {
  try {
    suspend();
    return task2();
  } finally {
    flush();
  }
}
function suspend() {
  semaphore++;
}
function release() {
  semaphore--;
}
function flush() {
  release();
  var task2;
  while (!semaphore && (task2 = queue.shift()) !== void 0) {
    exec(task2);
  }
}
var array2 = function array3(patterns) {
  return function(input) {
    return patterns.some(function(p) {
      return matcher(p)(input);
    });
  };
};
var predicate = function predicate2(_predicate) {
  return function(input) {
    return _predicate(input);
  };
};
var string3 = function string4(pattern3) {
  return function(input) {
    return input.type === String(pattern3);
  };
};
var symbol3 = function symbol4(pattern3) {
  return function(input) {
    return input.type === pattern3;
  };
};
var wildcard = function wildcard2() {
  return kTrue;
};
function matcher(pattern3) {
  var matcherCreator = pattern3 === "*" ? wildcard : string(pattern3) ? string3 : array(pattern3) ? array2 : stringableFunc(pattern3) ? string3 : func(pattern3) ? predicate : symbol(pattern3) ? symbol3 : null;
  if (matcherCreator === null) {
    throw new Error("invalid pattern: " + pattern3);
  }
  return matcherCreator(pattern3);
}
var END = {
  type: CHANNEL_END_TYPE
};
var isEnd = function isEnd2(a) {
  return a && a.type === CHANNEL_END_TYPE;
};
var CLOSED_CHANNEL_WITH_TAKERS = "Cannot have a closed channel with pending takers";
function channel3(buffer$1) {
  if (buffer$1 === void 0) {
    buffer$1 = expanding();
  }
  var closed = false;
  var takers = [];
  if (false) {
    check(buffer$1, buffer, INVALID_BUFFER);
  }
  function checkForbiddenStates() {
    if (closed && takers.length) {
      throw internalErr(CLOSED_CHANNEL_WITH_TAKERS);
    }
    if (takers.length && !buffer$1.isEmpty()) {
      throw internalErr("Cannot have pending takers with non empty buffer");
    }
  }
  function put2(input) {
    if (false) {
      checkForbiddenStates();
      check(input, notUndef, UNDEFINED_INPUT_ERROR);
    }
    if (closed) {
      return;
    }
    if (takers.length === 0) {
      return buffer$1.put(input);
    }
    var cb = takers.shift();
    cb(input);
  }
  function take2(cb) {
    if (false) {
      checkForbiddenStates();
      check(cb, func, "channel.take's callback must be a function");
    }
    if (closed && buffer$1.isEmpty()) {
      cb(END);
    } else if (!buffer$1.isEmpty()) {
      cb(buffer$1.take());
    } else {
      takers.push(cb);
      cb.cancel = function() {
        remove(takers, cb);
      };
    }
  }
  function flush3(cb) {
    if (false) {
      checkForbiddenStates();
      check(cb, func, "channel.flush' callback must be a function");
    }
    if (closed && buffer$1.isEmpty()) {
      cb(END);
      return;
    }
    cb(buffer$1.flush());
  }
  function close() {
    if (false) {
      checkForbiddenStates();
    }
    if (closed) {
      return;
    }
    closed = true;
    var arr = takers;
    takers = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      var taker = arr[i];
      taker(END);
    }
  }
  return {
    take: take2,
    put: put2,
    flush: flush3,
    close
  };
}
function eventChannel(subscribe5, buffer2) {
  if (buffer2 === void 0) {
    buffer2 = none();
  }
  var closed = false;
  var unsubscribe5;
  var chan = channel3(buffer2);
  var close = function close2() {
    if (closed) {
      return;
    }
    closed = true;
    if (func(unsubscribe5)) {
      unsubscribe5();
    }
    chan.close();
  };
  unsubscribe5 = subscribe5(function(input) {
    if (isEnd(input)) {
      close();
      return;
    }
    chan.put(input);
  });
  if (false) {
    check(unsubscribe5, func, "in eventChannel: subscribe should return a function to unsubscribe");
  }
  unsubscribe5 = once2(unsubscribe5);
  if (closed) {
    unsubscribe5();
  }
  return {
    take: chan.take,
    flush: chan.flush,
    close
  };
}
function multicastChannel() {
  var _ref2;
  var closed = false;
  var currentTakers = [];
  var nextTakers = currentTakers;
  function checkForbiddenStates() {
    if (closed && nextTakers.length) {
      throw internalErr(CLOSED_CHANNEL_WITH_TAKERS);
    }
  }
  var ensureCanMutateNextTakers = function ensureCanMutateNextTakers2() {
    if (nextTakers !== currentTakers) {
      return;
    }
    nextTakers = currentTakers.slice();
  };
  var close = function close2() {
    if (false) {
      checkForbiddenStates();
    }
    closed = true;
    var takers = currentTakers = nextTakers;
    nextTakers = [];
    takers.forEach(function(taker) {
      taker(END);
    });
  };
  return _ref2 = {}, _ref2[MULTICAST] = true, _ref2.put = function put2(input) {
    if (false) {
      checkForbiddenStates();
      check(input, notUndef, UNDEFINED_INPUT_ERROR);
    }
    if (closed) {
      return;
    }
    if (isEnd(input)) {
      close();
      return;
    }
    var takers = currentTakers = nextTakers;
    for (var i = 0, len = takers.length; i < len; i++) {
      var taker = takers[i];
      if (taker[MATCH](input)) {
        taker.cancel();
        taker(input);
      }
    }
  }, _ref2.take = function take2(cb, matcher2) {
    if (matcher2 === void 0) {
      matcher2 = wildcard;
    }
    if (false) {
      checkForbiddenStates();
    }
    if (closed) {
      cb(END);
      return;
    }
    cb[MATCH] = matcher2;
    ensureCanMutateNextTakers();
    nextTakers.push(cb);
    cb.cancel = once2(function() {
      ensureCanMutateNextTakers();
      remove(nextTakers, cb);
    });
  }, _ref2.close = close, _ref2;
}
function stdChannel() {
  var chan = multicastChannel();
  var put2 = chan.put;
  chan.put = function(input) {
    if (input[SAGA_ACTION]) {
      put2(input);
      return;
    }
    asap(function() {
      put2(input);
    });
  };
  return chan;
}
var RUNNING = 0;
var CANCELLED2 = 1;
var ABORTED = 2;
var DONE = 3;
function resolvePromise(promise3, cb) {
  var cancelPromise = promise3[CANCEL];
  if (func(cancelPromise)) {
    cb.cancel = cancelPromise;
  }
  promise3.then(cb, function(error) {
    cb(error, true);
  });
}
var current = 0;
var nextSagaId = function() {
  return ++current;
};
var _effectRunnerMap;
function getIteratorMetaInfo(iterator3, fn) {
  if (iterator3.isSagaIterator) {
    return {
      name: iterator3.meta.name
    };
  }
  return getMetaInfo(fn);
}
function createTaskIterator(_ref2) {
  var context2 = _ref2.context, fn = _ref2.fn, args = _ref2.args;
  try {
    var result = fn.apply(context2, args);
    if (iterator(result)) {
      return result;
    }
    var resolved = false;
    var next = function next2(arg) {
      if (!resolved) {
        resolved = true;
        return {
          value: result,
          done: !promise(result)
        };
      } else {
        return {
          value: arg,
          done: true
        };
      }
    };
    return makeIterator(next);
  } catch (err) {
    return makeIterator(function() {
      throw err;
    });
  }
}
function runPutEffect(env, _ref2, cb) {
  var channel4 = _ref2.channel, action = _ref2.action, resolve = _ref2.resolve;
  asap(function() {
    var result;
    try {
      result = (channel4 ? channel4.put : env.dispatch)(action);
    } catch (error) {
      cb(error, true);
      return;
    }
    if (resolve && promise(result)) {
      resolvePromise(result, cb);
    } else {
      cb(result);
    }
  });
}
function runTakeEffect(env, _ref3, cb) {
  var _ref3$channel = _ref3.channel, channel4 = _ref3$channel === void 0 ? env.channel : _ref3$channel, pattern3 = _ref3.pattern, maybe = _ref3.maybe;
  var takeCb = function takeCb2(input) {
    if (input instanceof Error) {
      cb(input, true);
      return;
    }
    if (isEnd(input) && !maybe) {
      cb(TERMINATE);
      return;
    }
    cb(input);
  };
  try {
    channel4.take(takeCb, notUndef(pattern3) ? matcher(pattern3) : null);
  } catch (err) {
    cb(err, true);
    return;
  }
  cb.cancel = takeCb.cancel;
}
function runCallEffect(env, _ref4, cb, _ref5) {
  var context2 = _ref4.context, fn = _ref4.fn, args = _ref4.args;
  var task2 = _ref5.task;
  try {
    var result = fn.apply(context2, args);
    if (promise(result)) {
      resolvePromise(result, cb);
      return;
    }
    if (iterator(result)) {
      proc(env, result, task2.context, current, getMetaInfo(fn), false, cb);
      return;
    }
    cb(result);
  } catch (error) {
    cb(error, true);
  }
}
function runCPSEffect(env, _ref6, cb) {
  var context2 = _ref6.context, fn = _ref6.fn, args = _ref6.args;
  try {
    var cpsCb = function cpsCb2(err, res) {
      if (undef(err)) {
        cb(res);
      } else {
        cb(err, true);
      }
    };
    fn.apply(context2, args.concat(cpsCb));
    if (cpsCb.cancel) {
      cb.cancel = cpsCb.cancel;
    }
  } catch (error) {
    cb(error, true);
  }
}
function runForkEffect(env, _ref7, cb, _ref8) {
  var context2 = _ref7.context, fn = _ref7.fn, args = _ref7.args, detached = _ref7.detached;
  var parent2 = _ref8.task;
  var taskIterator = createTaskIterator({
    context: context2,
    fn,
    args
  });
  var meta = getIteratorMetaInfo(taskIterator, fn);
  immediately(function() {
    var child = proc(env, taskIterator, parent2.context, current, meta, detached, void 0);
    if (detached) {
      cb(child);
    } else {
      if (child.isRunning()) {
        parent2.queue.addTask(child);
        cb(child);
      } else if (child.isAborted()) {
        parent2.queue.abort(child.error());
      } else {
        cb(child);
      }
    }
  });
}
function runJoinEffect(env, taskOrTasks, cb, _ref9) {
  var task2 = _ref9.task;
  var joinSingleTask = function joinSingleTask2(taskToJoin, cb2) {
    if (taskToJoin.isRunning()) {
      var joiner = {
        task: task2,
        cb: cb2
      };
      cb2.cancel = function() {
        if (taskToJoin.isRunning())
          remove(taskToJoin.joiners, joiner);
      };
      taskToJoin.joiners.push(joiner);
    } else {
      if (taskToJoin.isAborted()) {
        cb2(taskToJoin.error(), true);
      } else {
        cb2(taskToJoin.result());
      }
    }
  };
  if (array(taskOrTasks)) {
    if (taskOrTasks.length === 0) {
      cb([]);
      return;
    }
    var childCallbacks = createAllStyleChildCallbacks(taskOrTasks, cb);
    taskOrTasks.forEach(function(t, i) {
      joinSingleTask(t, childCallbacks[i]);
    });
  } else {
    joinSingleTask(taskOrTasks, cb);
  }
}
function cancelSingleTask(taskToCancel) {
  if (taskToCancel.isRunning()) {
    taskToCancel.cancel();
  }
}
function runCancelEffect(env, taskOrTasks, cb, _ref10) {
  var task2 = _ref10.task;
  if (taskOrTasks === SELF_CANCELLATION) {
    cancelSingleTask(task2);
  } else if (array(taskOrTasks)) {
    taskOrTasks.forEach(cancelSingleTask);
  } else {
    cancelSingleTask(taskOrTasks);
  }
  cb();
}
function runAllEffect(env, effects, cb, _ref11) {
  var digestEffect = _ref11.digestEffect;
  var effectId = current;
  var keys = Object.keys(effects);
  if (keys.length === 0) {
    cb(array(effects) ? [] : {});
    return;
  }
  var childCallbacks = createAllStyleChildCallbacks(effects, cb);
  keys.forEach(function(key) {
    digestEffect(effects[key], effectId, childCallbacks[key], key);
  });
}
function runRaceEffect(env, effects, cb, _ref12) {
  var digestEffect = _ref12.digestEffect;
  var effectId = current;
  var keys = Object.keys(effects);
  var response = array(effects) ? createEmptyArray(keys.length) : {};
  var childCbs = {};
  var completed = false;
  keys.forEach(function(key) {
    var chCbAtKey = function chCbAtKey2(res, isErr) {
      if (completed) {
        return;
      }
      if (isErr || shouldComplete(res)) {
        cb.cancel();
        cb(res, isErr);
      } else {
        cb.cancel();
        completed = true;
        response[key] = res;
        cb(response);
      }
    };
    chCbAtKey.cancel = noop3;
    childCbs[key] = chCbAtKey;
  });
  cb.cancel = function() {
    if (!completed) {
      completed = true;
      keys.forEach(function(key) {
        return childCbs[key].cancel();
      });
    }
  };
  keys.forEach(function(key) {
    if (completed) {
      return;
    }
    digestEffect(effects[key], effectId, childCbs[key], key);
  });
}
function runSelectEffect(env, _ref13, cb) {
  var selector = _ref13.selector, args = _ref13.args;
  try {
    var state = selector.apply(void 0, [env.getState()].concat(args));
    cb(state);
  } catch (error) {
    cb(error, true);
  }
}
function runChannelEffect(env, _ref14, cb) {
  var pattern3 = _ref14.pattern, buffer2 = _ref14.buffer;
  var chan = channel3(buffer2);
  var match = matcher(pattern3);
  var taker = function taker2(action) {
    if (!isEnd(action)) {
      env.channel.take(taker2, match);
    }
    chan.put(action);
  };
  var close = chan.close;
  chan.close = function() {
    taker.cancel();
    close();
  };
  env.channel.take(taker, match);
  cb(chan);
}
function runCancelledEffect(env, data, cb, _ref15) {
  var task2 = _ref15.task;
  cb(task2.isCancelled());
}
function runFlushEffect(env, channel4, cb) {
  channel4.flush(cb);
}
function runGetContextEffect(env, prop, cb, _ref16) {
  var task2 = _ref16.task;
  cb(task2.context[prop]);
}
function runSetContextEffect(env, props, cb, _ref17) {
  var task2 = _ref17.task;
  assignWithSymbols(task2.context, props);
  cb();
}
var effectRunnerMap = (_effectRunnerMap = {}, _effectRunnerMap[TAKE] = runTakeEffect, _effectRunnerMap[PUT] = runPutEffect, _effectRunnerMap[ALL] = runAllEffect, _effectRunnerMap[RACE] = runRaceEffect, _effectRunnerMap[CALL] = runCallEffect, _effectRunnerMap[CPS] = runCPSEffect, _effectRunnerMap[FORK] = runForkEffect, _effectRunnerMap[JOIN] = runJoinEffect, _effectRunnerMap[CANCEL2] = runCancelEffect, _effectRunnerMap[SELECT] = runSelectEffect, _effectRunnerMap[ACTION_CHANNEL] = runChannelEffect, _effectRunnerMap[CANCELLED] = runCancelledEffect, _effectRunnerMap[FLUSH] = runFlushEffect, _effectRunnerMap[GET_CONTEXT] = runGetContextEffect, _effectRunnerMap[SET_CONTEXT] = runSetContextEffect, _effectRunnerMap);
function forkQueue(mainTask, onAbort, cont) {
  var tasks = [];
  var result;
  var completed = false;
  addTask(mainTask);
  var getTasks = function getTasks2() {
    return tasks;
  };
  function abort(err) {
    onAbort();
    cancelAll();
    cont(err, true);
  }
  function addTask(task2) {
    tasks.push(task2);
    task2.cont = function(res, isErr) {
      if (completed) {
        return;
      }
      remove(tasks, task2);
      task2.cont = noop3;
      if (isErr) {
        abort(res);
      } else {
        if (task2 === mainTask) {
          result = res;
        }
        if (!tasks.length) {
          completed = true;
          cont(result);
        }
      }
    };
  }
  function cancelAll() {
    if (completed) {
      return;
    }
    completed = true;
    tasks.forEach(function(t) {
      t.cont = noop3;
      t.cancel();
    });
    tasks = [];
  }
  return {
    addTask,
    cancelAll,
    abort,
    getTasks
  };
}
function formatLocation(fileName, lineNumber) {
  return fileName + "?" + lineNumber;
}
function effectLocationAsString(effect2) {
  var location2 = getLocation(effect2);
  if (location2) {
    var code3 = location2.code, fileName = location2.fileName, lineNumber = location2.lineNumber;
    var source = code3 + "  " + formatLocation(fileName, lineNumber);
    return source;
  }
  return "";
}
function sagaLocationAsString(sagaMeta) {
  var name = sagaMeta.name, location2 = sagaMeta.location;
  if (location2) {
    return name + "  " + formatLocation(location2.fileName, location2.lineNumber);
  }
  return name;
}
function cancelledTasksAsString(sagaStack2) {
  var cancelledTasks = flatMap(function(i) {
    return i.cancelledTasks;
  }, sagaStack2);
  if (!cancelledTasks.length) {
    return "";
  }
  return ["Tasks cancelled due to error:"].concat(cancelledTasks).join("\n");
}
var crashedEffect = null;
var sagaStack = [];
var addSagaFrame = function addSagaFrame2(frame) {
  frame.crashedEffect = crashedEffect;
  sagaStack.push(frame);
};
var clear = function clear2() {
  crashedEffect = null;
  sagaStack.length = 0;
};
var setCrashedEffect = function setCrashedEffect2(effect2) {
  crashedEffect = effect2;
};
var toString = function toString2() {
  var firstSaga = sagaStack[0], otherSagas = sagaStack.slice(1);
  var crashedEffectLocation = firstSaga.crashedEffect ? effectLocationAsString(firstSaga.crashedEffect) : null;
  var errorMessage = "The above error occurred in task " + sagaLocationAsString(firstSaga.meta) + (crashedEffectLocation ? " \n when executing effect " + crashedEffectLocation : "");
  return [errorMessage].concat(otherSagas.map(function(s) {
    return "    created by " + sagaLocationAsString(s.meta);
  }), [cancelledTasksAsString(sagaStack)]).join("\n");
};
function newTask(env, mainTask, parentContext, parentEffectId, meta, isRoot, cont) {
  var _task;
  if (cont === void 0) {
    cont = noop3;
  }
  var status2 = RUNNING;
  var taskResult;
  var taskError;
  var deferredEnd = null;
  var cancelledDueToErrorTasks = [];
  var context2 = Object.create(parentContext);
  var queue2 = forkQueue(mainTask, function onAbort() {
    cancelledDueToErrorTasks.push.apply(cancelledDueToErrorTasks, queue2.getTasks().map(function(t) {
      return t.meta.name;
    }));
  }, end);
  function cancel2() {
    if (status2 === RUNNING) {
      status2 = CANCELLED2;
      queue2.cancelAll();
      end(TASK_CANCEL, false);
    }
  }
  function end(result, isErr) {
    if (!isErr) {
      if (result === TASK_CANCEL) {
        status2 = CANCELLED2;
      } else if (status2 !== CANCELLED2) {
        status2 = DONE;
      }
      taskResult = result;
      deferredEnd && deferredEnd.resolve(result);
    } else {
      status2 = ABORTED;
      addSagaFrame({
        meta,
        cancelledTasks: cancelledDueToErrorTasks
      });
      if (task2.isRoot) {
        var sagaStack2 = toString();
        clear();
        env.onError(result, {
          sagaStack: sagaStack2
        });
      }
      taskError = result;
      deferredEnd && deferredEnd.reject(result);
    }
    task2.cont(result, isErr);
    task2.joiners.forEach(function(joiner) {
      joiner.cb(result, isErr);
    });
    task2.joiners = null;
  }
  function setContext2(props) {
    if (false) {
      check(props, object, createSetContextWarning("task", props));
    }
    assignWithSymbols(context2, props);
  }
  function toPromise2() {
    if (deferredEnd) {
      return deferredEnd.promise;
    }
    deferredEnd = redux_saga_deferred_esm_default();
    if (status2 === ABORTED) {
      deferredEnd.reject(taskError);
    } else if (status2 !== RUNNING) {
      deferredEnd.resolve(taskResult);
    }
    return deferredEnd.promise;
  }
  var task2 = (_task = {}, _task[TASK] = true, _task.id = parentEffectId, _task.meta = meta, _task.isRoot = isRoot, _task.context = context2, _task.joiners = [], _task.queue = queue2, _task.cancel = cancel2, _task.cont = cont, _task.end = end, _task.setContext = setContext2, _task.toPromise = toPromise2, _task.isRunning = function isRunning() {
    return status2 === RUNNING;
  }, _task.isCancelled = function isCancelled() {
    return status2 === CANCELLED2 || status2 === RUNNING && mainTask.status === CANCELLED2;
  }, _task.isAborted = function isAborted() {
    return status2 === ABORTED;
  }, _task.result = function result() {
    return taskResult;
  }, _task.error = function error() {
    return taskError;
  }, _task);
  return task2;
}
function proc(env, iterator$1, parentContext, parentEffectId, meta, isRoot, cont) {
  if (false) {
    throw new Error("redux-saga doesn't support async generators, please use only regular ones");
  }
  var finalRunEffect = env.finalizeRunEffect(runEffect);
  next.cancel = noop3;
  var mainTask = {
    meta,
    cancel: cancelMain,
    status: RUNNING
  };
  var task2 = newTask(env, mainTask, parentContext, parentEffectId, meta, isRoot, cont);
  var executingContext = {
    task: task2,
    digestEffect
  };
  function cancelMain() {
    if (mainTask.status === RUNNING) {
      mainTask.status = CANCELLED2;
      next(TASK_CANCEL);
    }
  }
  if (cont) {
    cont.cancel = task2.cancel;
  }
  next();
  return task2;
  function next(arg, isErr) {
    try {
      var result;
      if (isErr) {
        result = iterator$1.throw(arg);
        clear();
      } else if (shouldCancel(arg)) {
        mainTask.status = CANCELLED2;
        next.cancel();
        result = func(iterator$1.return) ? iterator$1.return(TASK_CANCEL) : {
          done: true,
          value: TASK_CANCEL
        };
      } else if (shouldTerminate(arg)) {
        result = func(iterator$1.return) ? iterator$1.return() : {
          done: true
        };
      } else {
        result = iterator$1.next(arg);
      }
      if (!result.done) {
        digestEffect(result.value, parentEffectId, next);
      } else {
        if (mainTask.status !== CANCELLED2) {
          mainTask.status = DONE;
        }
        mainTask.cont(result.value);
      }
    } catch (error) {
      if (mainTask.status === CANCELLED2) {
        throw error;
      }
      mainTask.status = ABORTED;
      mainTask.cont(error, true);
    }
  }
  function runEffect(effect2, effectId, currCb) {
    if (promise(effect2)) {
      resolvePromise(effect2, currCb);
    } else if (iterator(effect2)) {
      proc(env, effect2, task2.context, effectId, meta, false, currCb);
    } else if (effect2 && effect2[IO]) {
      var effectRunner = effectRunnerMap[effect2.type];
      effectRunner(env, effect2.payload, currCb, executingContext);
    } else {
      currCb(effect2);
    }
  }
  function digestEffect(effect2, parentEffectId2, cb, label) {
    if (label === void 0) {
      label = "";
    }
    var effectId = nextSagaId();
    env.sagaMonitor && env.sagaMonitor.effectTriggered({
      effectId,
      parentEffectId: parentEffectId2,
      label,
      effect: effect2
    });
    var effectSettled;
    function currCb(res, isErr) {
      if (effectSettled) {
        return;
      }
      effectSettled = true;
      cb.cancel = noop3;
      if (env.sagaMonitor) {
        if (isErr) {
          env.sagaMonitor.effectRejected(effectId, res);
        } else {
          env.sagaMonitor.effectResolved(effectId, res);
        }
      }
      if (isErr) {
        setCrashedEffect(effect2);
      }
      cb(res, isErr);
    }
    currCb.cancel = noop3;
    cb.cancel = function() {
      if (effectSettled) {
        return;
      }
      effectSettled = true;
      currCb.cancel();
      currCb.cancel = noop3;
      env.sagaMonitor && env.sagaMonitor.effectCancelled(effectId);
    };
    finalRunEffect(effect2, effectId, currCb);
  }
}
var RUN_SAGA_SIGNATURE = "runSaga(options, saga, ...args)";
var NON_GENERATOR_ERR = RUN_SAGA_SIGNATURE + ": saga argument must be a Generator function!";
function runSaga(_ref2, saga) {
  var _ref$channel = _ref2.channel, channel4 = _ref$channel === void 0 ? stdChannel() : _ref$channel, dispatch2 = _ref2.dispatch, getState = _ref2.getState, _ref$context = _ref2.context, context2 = _ref$context === void 0 ? {} : _ref$context, sagaMonitor = _ref2.sagaMonitor, effectMiddlewares = _ref2.effectMiddlewares, _ref$onError = _ref2.onError, onError2 = _ref$onError === void 0 ? logError : _ref$onError;
  if (false) {
    check(saga, func, NON_GENERATOR_ERR);
  }
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  var iterator$1 = saga.apply(void 0, args);
  if (false) {
    check(iterator$1, iterator, NON_GENERATOR_ERR);
  }
  var effectId = nextSagaId();
  if (sagaMonitor) {
    sagaMonitor.rootSagaStarted = sagaMonitor.rootSagaStarted || noop3;
    sagaMonitor.effectTriggered = sagaMonitor.effectTriggered || noop3;
    sagaMonitor.effectResolved = sagaMonitor.effectResolved || noop3;
    sagaMonitor.effectRejected = sagaMonitor.effectRejected || noop3;
    sagaMonitor.effectCancelled = sagaMonitor.effectCancelled || noop3;
    sagaMonitor.actionDispatched = sagaMonitor.actionDispatched || noop3;
    sagaMonitor.rootSagaStarted({
      effectId,
      saga,
      args
    });
  }
  if (false) {
    if (notUndef(dispatch2)) {
      check(dispatch2, func, "dispatch must be a function");
    }
    if (notUndef(getState)) {
      check(getState, func, "getState must be a function");
    }
    if (notUndef(effectMiddlewares)) {
      var MIDDLEWARE_TYPE_ERROR = "effectMiddlewares must be an array of functions";
      check(effectMiddlewares, array, MIDDLEWARE_TYPE_ERROR);
      effectMiddlewares.forEach(function(effectMiddleware) {
        return check(effectMiddleware, func, MIDDLEWARE_TYPE_ERROR);
      });
    }
    check(onError2, func, "onError passed to the redux-saga is not a function!");
  }
  var finalizeRunEffect;
  if (effectMiddlewares) {
    var middleware = import_redux.compose.apply(void 0, effectMiddlewares);
    finalizeRunEffect = function finalizeRunEffect2(runEffect) {
      return function(effect2, effectId2, currCb) {
        var plainRunEffect = function plainRunEffect2(eff) {
          return runEffect(eff, effectId2, currCb);
        };
        return middleware(plainRunEffect)(effect2);
      };
    };
  } else {
    finalizeRunEffect = identity;
  }
  var env = {
    channel: channel4,
    dispatch: wrapSagaDispatch(dispatch2),
    getState,
    sagaMonitor,
    onError: onError2,
    finalizeRunEffect
  };
  return immediately(function() {
    var task2 = proc(env, iterator$1, context2, effectId, getMetaInfo(saga), true, void 0);
    if (sagaMonitor) {
      sagaMonitor.effectResolved(effectId, task2);
    }
    return task2;
  });
}
function sagaMiddlewareFactory(_temp) {
  var _ref2 = _temp === void 0 ? {} : _temp, _ref$context = _ref2.context, context2 = _ref$context === void 0 ? {} : _ref$context, _ref$channel = _ref2.channel, channel4 = _ref$channel === void 0 ? stdChannel() : _ref$channel, sagaMonitor = _ref2.sagaMonitor, options = _objectWithoutPropertiesLoose(_ref2, ["context", "channel", "sagaMonitor"]);
  var boundRunSaga;
  if (false) {
    check(channel4, channel, "options.channel passed to the Saga middleware is not a channel");
  }
  function sagaMiddleware(_ref22) {
    var getState = _ref22.getState, dispatch2 = _ref22.dispatch;
    boundRunSaga = runSaga.bind(null, _extends({}, options, {
      context: context2,
      channel: channel4,
      dispatch: dispatch2,
      getState,
      sagaMonitor
    }));
    return function(next) {
      return function(action) {
        if (sagaMonitor && sagaMonitor.actionDispatched) {
          sagaMonitor.actionDispatched(action);
        }
        var result = next(action);
        channel4.put(action);
        return result;
      };
    };
  }
  sagaMiddleware.run = function() {
    if (false) {
      throw new Error("Before running a Saga, you must mount the Saga middleware on the Store using applyMiddleware");
    }
    return boundRunSaga.apply(void 0, arguments);
  };
  sagaMiddleware.setContext = function(props) {
    if (false) {
      check(props, object, createSetContextWarning("sagaMiddleware", props));
    }
    assignWithSymbols(context2, props);
  };
  return sagaMiddleware;
}
var redux_saga_core_esm_default = sagaMiddlewareFactory;

// ../../node_modules/redux-saga/dist/redux-saga-core-npm-proxy.esm.js
var redux_saga_core_npm_proxy_esm_default = redux_saga_core_esm_default;

// src/state/store.ts
var import_redux_devtools_extension = __toModule(require_redux_devtools_extension());

// src/state/reducer.ts
var import_redux2 = __toModule(require_redux());

// src/state/branch/reducer.ts
var import_typesafe_actions4 = __toModule(require_typesafe_actions_umd_production());

// src/state/branch/actions.ts
var import_typesafe_actions3 = __toModule(require_typesafe_actions_umd_production());
var set = import_typesafe_actions3.createAction("SET_BRANCHES")();
var setCurrentBranch = import_typesafe_actions3.createAction("SET_CURRENT_BRANCH")();
var subscribe = import_typesafe_actions3.createAction("SUBSCRIBE_BRANCHES")();
var unsubscribe = import_typesafe_actions3.createAction("UNSUBSCRIBE_BRANCHES")();
var createBranch = import_typesafe_actions3.createAction("CREATE_BRANCH")();
var deleteBranch = import_typesafe_actions3.createAction("DELETE_BRANCH")();

// src/state/branch/reducer.ts
var BranchesInitialState = {
  currentBranchName: "main",
  branches: [],
  loading: true
};
var reducer = import_typesafe_actions4.createReducer(BranchesInitialState).handleAction(set, (state, action) => ({
  ...state,
  branches: action.payload,
  loading: false
})).handleAction(setCurrentBranch, (state, action) => ({
  ...state,
  currentBranchName: action.payload.name
}));

// src/state/module/reducer.ts
var import_typesafe_actions6 = __toModule(require_typesafe_actions_umd_production());

// src/state/module/actions.ts
var import_typesafe_actions5 = __toModule(require_typesafe_actions_umd_production());
var set2 = import_typesafe_actions5.createAction("SET_MODULES")();
var subscribe2 = import_typesafe_actions5.createAction("SUBSCRIBE_MODULES")();
var unsubscribe2 = import_typesafe_actions5.createAction("UNSUBSCRIBE_MODULES")();
var createModule = import_typesafe_actions5.createAction("CREATE_MODULE")();
var deleteModule = import_typesafe_actions5.createAction("DELETE_MODULE")();

// src/state/module/reducer.ts
var ModulesInitialState = {
  modules: [],
  loading: true
};
var reducer2 = import_typesafe_actions6.createReducer(ModulesInitialState).handleAction(set2, (state, action) => ({
  ...state,
  modules: action.payload,
  loading: false
}));

// src/state/moduleVersion/reducer.ts
var import_typesafe_actions8 = __toModule(require_typesafe_actions_umd_production());

// src/state/moduleVersion/actions.ts
var import_typesafe_actions7 = __toModule(require_typesafe_actions_umd_production());
var set3 = import_typesafe_actions7.createAction("SET_MODULE_VERSIONS")();
var subscribe3 = import_typesafe_actions7.createAction("SUBSCRIBE_MODULE_VERSIONS")();
var unsubscribe3 = import_typesafe_actions7.createAction("UNSUBSCRIBE_MODULE_VERSIONS")();

// src/state/moduleVersion/reducer.ts
var ModuleVersionsInitialState = {
  versions: [],
  loading: true
};
var reducer3 = import_typesafe_actions8.createReducer(ModuleVersionsInitialState).handleAction(set3, (state, action) => ({
  ...state,
  versions: action.payload,
  loading: false
}));

// src/state/file/reducer.ts
var import_typesafe_actions13 = __toModule(require_typesafe_actions_umd_production());

// src/state/file/actions.ts
var import_typesafe_actions9 = __toModule(require_typesafe_actions_umd_production());
var set4 = import_typesafe_actions9.createAction("SET_FILES")();
var subscribe4 = import_typesafe_actions9.createAction("SUBSCRIBE_FILES")();
var unsubscribe4 = import_typesafe_actions9.createAction("UNSUBSCRIBE_FILES")();
var openFile = import_typesafe_actions9.createAction("OPEN_FILE")();
var closeFile = import_typesafe_actions9.createAction("CLOSE_FILE")();
var requestOpenFileWithParams = import_typesafe_actions9.createAction("REQUEST_FILE_OPEN")();

// src/state/file/TextFileModel.ts
var import_axios = __toModule(require_axios2());

// src/state/clients/websocket/index.ts
var import_socket = __toModule(require_build());
var socket = import_socket.io({
  path: "/_/socket",
  transports: ["websocket"],
  autoConnect: false
});
var subscribers = new Set();
function listen(callback) {
  subscribers.add(callback);
}
function unlisten(callback) {
  subscribers.delete(callback);
}
socket.on("message", (action) => {
  for (const sub of subscribers.values()) {
    sub(action);
  }
});
var websocket = {
  emit: (event) => {
    socket.emit("message", event);
  },
  listen,
  unlisten
};
var websocket_default = websocket;

// src/state/utils/sanitize.ts
function sanitizeScope(scope) {
  return scope.replace(/^@/, "");
}
function sanitizeFilePath(path3) {
  return path3?.replace(/^\//, "");
}

// src/state/file/utils/uri.ts
function getModuleNameFromFile(file) {
  return file.module_scope ? `@${sanitizeScope(file.module_scope)}/${file.module_name}` : file.module_name;
}
function getFileUri(file, options) {
  const versionToUse = options?.useLatest ? "latest" : file.module_version;
  let filePath = `${getModuleNameFromFile(file)}${options?.encodeAtSymbol ? "%40" : "@"}${options?.version ? options.version : versionToUse}/${file.path.replace(/^\//, "")}`;
  if (options?.external) {
    filePath = `x/${filePath}`;
  } else if (options?.branch) {
    filePath = `${options.branch}/${filePath}`;
  }
  if (!options?.external && filePath.endsWith("/")) {
    filePath += "main";
  }
  if (options?.external && filePath.endsWith("/")) {
    filePath += "index";
  }
  return options?.ext ? `${filePath}.tsx` : filePath;
}
function getMonacoFileUri(file) {
  return monaco.Uri.file(getFileUri(file, {
    ext: true,
    branch: file.branch_name
  }));
}

// src/state/clients/websocket/actions.ts
var import_typesafe_actions10 = __toModule(require_typesafe_actions_umd_production());
var subscribeFile = import_typesafe_actions10.createAction("SUBSCRIBE_FILE")();
var unsubscribeFile = import_typesafe_actions10.createAction("UNSUBSCRIBE_FILE")();
var fileContent = import_typesafe_actions10.createAction("FILE_CONTENT")();
var viewers = import_typesafe_actions10.createAction("FILE_VIEWERS")();
var edit = import_typesafe_actions10.createAction("FILE_EDIT")();
var claimEditor = import_typesafe_actions10.createAction("FILE_CLAIM_EDITOR")();
var viewerSelectionChange = import_typesafe_actions10.createAction("FILE_USER_SELECTION")();
var compilerOutput = import_typesafe_actions10.createAction("FILE_COMPILER_OUTPUT")();
var compilerUpdated = import_typesafe_actions10.createAction("FILE_COMPILER_UPDATE")();

// src/state/file/LiveClient.ts
var import_lodash = __toModule(require_lodash());
var import_glamor = __toModule(require_lib4());
var import_typesafe_actions12 = __toModule(require_typesafe_actions_umd_production());

// src/state/user/hooks/useCurrentUser.ts
import {useEffect as useEffect10} from "https://cdn.skypack.dev/react";

// ../../node_modules/reselect/es/index.js
function defaultEqualityCheck(a, b) {
  return a === b;
}
function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
  if (prev === null || next === null || prev.length !== next.length) {
    return false;
  }
  var length = prev.length;
  for (var i = 0; i < length; i++) {
    if (!equalityCheck(prev[i], next[i])) {
      return false;
    }
  }
  return true;
}
function defaultMemoize(func3) {
  var equalityCheck = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultEqualityCheck;
  var lastArgs = null;
  var lastResult = null;
  return function() {
    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
      lastResult = func3.apply(null, arguments);
    }
    lastArgs = arguments;
    return lastResult;
  };
}
function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
  if (!dependencies.every(function(dep2) {
    return typeof dep2 === "function";
  })) {
    var dependencyTypes = dependencies.map(function(dep2) {
      return typeof dep2;
    }).join(", ");
    throw new Error("Selector creators expect all input-selectors to be functions, " + ("instead received the following types: [" + dependencyTypes + "]"));
  }
  return dependencies;
}
function createSelectorCreator(memoize) {
  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptions[_key - 1] = arguments[_key];
  }
  return function() {
    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }
    var recomputations = 0;
    var resultFunc = funcs.pop();
    var dependencies = getDependencies(funcs);
    var memoizedResultFunc = memoize.apply(void 0, [function() {
      recomputations++;
      return resultFunc.apply(null, arguments);
    }].concat(memoizeOptions));
    var selector = memoize(function() {
      var params = [];
      var length = dependencies.length;
      for (var i = 0; i < length; i++) {
        params.push(dependencies[i].apply(null, arguments));
      }
      return memoizedResultFunc.apply(null, params);
    });
    selector.resultFunc = resultFunc;
    selector.dependencies = dependencies;
    selector.recomputations = function() {
      return recomputations;
    };
    selector.resetRecomputations = function() {
      return recomputations = 0;
    };
    return selector;
  };
}
var createSelector = createSelectorCreator(defaultMemoize);

// src/state/user/actions.ts
var import_typesafe_actions11 = __toModule(require_typesafe_actions_umd_production());
var setCurrentUser = import_typesafe_actions11.createAction("SET_CURRENT_USER")();
var setDarkMode = import_typesafe_actions11.createAction("SET_DARK_MODE")();
var subscribeToUserList = import_typesafe_actions11.createAction("SUBSCRIBE_USER_LIST")();
var unsubscribeFromUserList = import_typesafe_actions11.createAction("UNSUBSCRIBE_USER_LIST")();
var setUserList = import_typesafe_actions11.createAction("SET_USER_LIST")();
var deleteUser = import_typesafe_actions11.createAction("DELETE_USER")();
var addUser = import_typesafe_actions11.createAction("ADD_USER")();

// src/state/utils/getSubscriptionID.ts
function getSubscriptionID() {
  return Math.floor(Math.random() * Math.floor(1e6));
}

// src/state/user/hooks/useCurrentUser.ts
var getCurrentUserId = (state) => state.users.currentUserId;
var getUsers = (state) => state.users.users;
var getCurrentUserIdLoaded = (state) => state.users.currentUserIdLoaded;
var getUsersLoading = (state) => state.users.loading;
var getCurrentUser = createSelector(getUsers, getCurrentUserId, (users, currentUserId) => users.find((u) => u.opaque_id === currentUserId));
var getCurrentUserLoaded = createSelector(getCurrentUserIdLoaded, getUsersLoading, (currentUserLoaded, usersLoading) => currentUserLoaded && !usersLoading);
function useCurrentUser() {
  const currentUser = useSelector(getCurrentUser);
  const dispatch2 = useDispatch();
  useEffect10(() => {
    const subId = getSubscriptionID();
    dispatch2(subscribeToUserList(subId));
    return () => {
      dispatch2(unsubscribeFromUserList(subId));
    };
  }, [dispatch2, currentUser?.email]);
  return currentUser;
}

// src/state/user/hooks/useUserList.ts
import {useEffect as useEffect11} from "https://cdn.skypack.dev/react";
var getUserList = (state) => state.users.activeUsers;

// ../../node_modules/monaco-editor/esm/vs/base/common/htmlContent.js
var MarkdownString = class {
  constructor(_value = "", isTrustedOrOptions = false) {
    var _a5, _b2;
    this._value = _value;
    if (typeof this._value !== "string") {
      throw illegalArgument("value");
    }
    if (typeof isTrustedOrOptions === "boolean") {
      this._isTrusted = isTrustedOrOptions;
      this._supportThemeIcons = false;
    } else {
      this._isTrusted = (_a5 = isTrustedOrOptions.isTrusted) !== null && _a5 !== void 0 ? _a5 : false;
      this._supportThemeIcons = (_b2 = isTrustedOrOptions.supportThemeIcons) !== null && _b2 !== void 0 ? _b2 : false;
    }
  }
  get value() {
    return this._value;
  }
  get isTrusted() {
    return this._isTrusted;
  }
  get supportThemeIcons() {
    return this._supportThemeIcons;
  }
  appendText(value) {
    this._value += (this._supportThemeIcons ? escapeCodicons(value) : value).replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&").replace(/\n/g, "\n\n");
    return this;
  }
  appendMarkdown(value) {
    this._value += value;
    return this;
  }
  appendCodeblock(langId, code3) {
    this._value += "\n```";
    this._value += langId;
    this._value += "\n";
    this._value += code3;
    this._value += "\n```\n";
    return this;
  }
};
function isEmptyMarkdownString(oneOrMany) {
  if (isMarkdownString(oneOrMany)) {
    return !oneOrMany.value;
  } else if (Array.isArray(oneOrMany)) {
    return oneOrMany.every(isEmptyMarkdownString);
  } else {
    return true;
  }
}
function isMarkdownString(thing) {
  if (thing instanceof MarkdownString) {
    return true;
  } else if (thing && typeof thing === "object") {
    return typeof thing.value === "string" && (typeof thing.isTrusted === "boolean" || thing.isTrusted === void 0) && (typeof thing.supportThemeIcons === "boolean" || thing.supportThemeIcons === void 0);
  }
  return false;
}
function markedStringsEquals(a, b) {
  if (!a && !b) {
    return true;
  } else if (!a || !b) {
    return false;
  } else if (Array.isArray(a) && Array.isArray(b)) {
    return equals(a, b, markdownStringEqual);
  } else if (isMarkdownString(a) && isMarkdownString(b)) {
    return markdownStringEqual(a, b);
  } else {
    return false;
  }
}
function markdownStringEqual(a, b) {
  if (a === b) {
    return true;
  } else if (!a || !b) {
    return false;
  } else {
    return a.value === b.value && a.isTrusted === b.isTrusted && a.supportThemeIcons === b.supportThemeIcons;
  }
}
function removeMarkdownEscapes(text) {
  if (!text) {
    return text;
  }
  return text.replace(/\\([\\`*_{}[\]()#+\-.!])/g, "$1");
}
function parseHrefAndDimensions(href) {
  const dimensions = [];
  const splitted = href.split("|").map((s) => s.trim());
  href = splitted[0];
  const parameters = splitted[1];
  if (parameters) {
    const heightFromParams = /height=(\d+)/.exec(parameters);
    const widthFromParams = /width=(\d+)/.exec(parameters);
    const height = heightFromParams ? heightFromParams[1] : "";
    const width = widthFromParams ? widthFromParams[1] : "";
    const widthIsFinite = isFinite(parseInt(width));
    const heightIsFinite = isFinite(parseInt(height));
    if (widthIsFinite) {
      dimensions.push(`width="${width}"`);
    }
    if (heightIsFinite) {
      dimensions.push(`height="${height}"`);
    }
  }
  return {href, dimensions};
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/anchorSelect/anchorSelect.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SelectionAnchorSet = new RawContextKey("selectionAnchorSet", false);
var SelectionAnchorController = class SelectionAnchorController2 {
  constructor(editor3, contextKeyService) {
    this.editor = editor3;
    this.selectionAnchorSetContextKey = SelectionAnchorSet.bindTo(contextKeyService);
    this.modelChangeListener = editor3.onDidChangeModel(() => this.selectionAnchorSetContextKey.reset());
  }
  static get(editor3) {
    return editor3.getContribution(SelectionAnchorController2.ID);
  }
  setSelectionAnchor() {
    if (this.editor.hasModel()) {
      const position = this.editor.getPosition();
      const previousDecorations = this.decorationId ? [this.decorationId] : [];
      const newDecorationId = this.editor.deltaDecorations(previousDecorations, [{
        range: Selection.fromPositions(position, position),
        options: {
          stickiness: 1,
          hoverMessage: new MarkdownString().appendText(localize("selectionAnchor", "Selection Anchor")),
          className: "selection-anchor"
        }
      }]);
      this.decorationId = newDecorationId[0];
      this.selectionAnchorSetContextKey.set(!!this.decorationId);
      alert(localize("anchorSet", "Anchor set at {0}:{1}", position.lineNumber, position.column));
    }
  }
  goToSelectionAnchor() {
    if (this.editor.hasModel() && this.decorationId) {
      const anchorPosition = this.editor.getModel().getDecorationRange(this.decorationId);
      if (anchorPosition) {
        this.editor.setPosition(anchorPosition.getStartPosition());
      }
    }
  }
  selectFromAnchorToCursor() {
    if (this.editor.hasModel() && this.decorationId) {
      const start = this.editor.getModel().getDecorationRange(this.decorationId);
      if (start) {
        const end = this.editor.getPosition();
        this.editor.setSelection(Selection.fromPositions(start.getStartPosition(), end));
        this.cancelSelectionAnchor();
      }
    }
  }
  cancelSelectionAnchor() {
    if (this.decorationId) {
      this.editor.deltaDecorations([this.decorationId], []);
      this.decorationId = void 0;
      this.selectionAnchorSetContextKey.set(false);
    }
  }
  dispose() {
    this.cancelSelectionAnchor();
    this.modelChangeListener.dispose();
  }
};
SelectionAnchorController.ID = "editor.contrib.selectionAnchorController";
SelectionAnchorController = __decorate([
  __param(1, IContextKeyService)
], SelectionAnchorController);
var SetSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.setSelectionAnchor",
      label: localize("setSelectionAnchor", "Set Selection Anchor"),
      alias: "Set Selection Anchor",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 32),
        weight: 100
      }
    });
  }
  run(_accessor, editor3) {
    return __awaiter(this, void 0, void 0, function* () {
      const controller = SelectionAnchorController.get(editor3);
      controller.setSelectionAnchor();
    });
  }
};
var GoToSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.goToSelectionAnchor",
      label: localize("goToSelectionAnchor", "Go to Selection Anchor"),
      alias: "Go to Selection Anchor",
      precondition: SelectionAnchorSet
    });
  }
  run(_accessor, editor3) {
    return __awaiter(this, void 0, void 0, function* () {
      const controller = SelectionAnchorController.get(editor3);
      controller.goToSelectionAnchor();
    });
  }
};
var SelectFromAnchorToCursor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.selectFromAnchorToCursor",
      label: localize("selectFromAnchorToCursor", "Select from Anchor to Cursor"),
      alias: "Select from Anchor to Cursor",
      precondition: SelectionAnchorSet,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 41),
        weight: 100
      }
    });
  }
  run(_accessor, editor3) {
    return __awaiter(this, void 0, void 0, function* () {
      const controller = SelectionAnchorController.get(editor3);
      controller.selectFromAnchorToCursor();
    });
  }
};
var CancelSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.cancelSelectionAnchor",
      label: localize("cancelSelectionAnchor", "Cancel Selection Anchor"),
      alias: "Cancel Selection Anchor",
      precondition: SelectionAnchorSet,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 9,
        weight: 100
      }
    });
  }
  run(_accessor, editor3) {
    return __awaiter(this, void 0, void 0, function* () {
      const controller = SelectionAnchorController.get(editor3);
      controller.cancelSelectionAnchor();
    });
  }
};
registerEditorContribution(SelectionAnchorController.ID, SelectionAnchorController);
registerEditorAction(SetSelectionAnchor);
registerEditorAction(GoToSelectionAnchor);
registerEditorAction(SelectFromAnchorToCursor);
registerEditorAction(CancelSelectionAnchor);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/bracketMatching/bracketMatching.js
var overviewRulerBracketMatchForeground = registerColor("editorOverviewRuler.bracketMatchForeground", {dark: "#A0A0A0", light: "#A0A0A0", hc: "#A0A0A0"}, localize("overviewRulerBracketMatchForeground", "Overview ruler marker color for matching brackets."));
var JumpToBracketAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.jumpToBracket",
      label: localize("smartSelect.jumpBracket", "Go to Bracket"),
      alias: "Go to Bracket",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 88,
        weight: 100
      }
    });
  }
  run(accessor, editor3) {
    let controller = BracketMatchingController.get(editor3);
    if (!controller) {
      return;
    }
    controller.jumpToBracket();
  }
};
var SelectToBracketAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.selectToBracket",
      label: localize("smartSelect.selectToBracket", "Select to Bracket"),
      alias: "Select to Bracket",
      precondition: void 0,
      description: {
        description: `Select to Bracket`,
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              selectBrackets: {
                type: "boolean",
                default: true
              }
            }
          }
        }]
      }
    });
  }
  run(accessor, editor3, args) {
    const controller = BracketMatchingController.get(editor3);
    if (!controller) {
      return;
    }
    let selectBrackets = true;
    if (args && args.selectBrackets === false) {
      selectBrackets = false;
    }
    controller.selectToBracket(selectBrackets);
  }
};
var BracketsData = class {
  constructor(position, brackets, options) {
    this.position = position;
    this.brackets = brackets;
    this.options = options;
  }
};
var BracketMatchingController = class extends Disposable {
  constructor(editor3) {
    super();
    this._editor = editor3;
    this._lastBracketsData = [];
    this._lastVersionId = 0;
    this._decorations = [];
    this._updateBracketsSoon = this._register(new RunOnceScheduler(() => this._updateBrackets(), 50));
    this._matchBrackets = this._editor.getOption(55);
    this._updateBracketsSoon.schedule();
    this._register(editor3.onDidChangeCursorPosition((e) => {
      if (this._matchBrackets === "never") {
        return;
      }
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor3.onDidChangeModelContent((e) => {
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor3.onDidChangeModel((e) => {
      this._lastBracketsData = [];
      this._decorations = [];
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor3.onDidChangeModelLanguageConfiguration((e) => {
      this._lastBracketsData = [];
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor3.onDidChangeConfiguration((e) => {
      if (e.hasChanged(55)) {
        this._matchBrackets = this._editor.getOption(55);
        this._decorations = this._editor.deltaDecorations(this._decorations, []);
        this._lastBracketsData = [];
        this._lastVersionId = 0;
        this._updateBracketsSoon.schedule();
      }
    }));
  }
  static get(editor3) {
    return editor3.getContribution(BracketMatchingController.ID);
  }
  jumpToBracket() {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const newSelections = this._editor.getSelections().map((selection) => {
      const position = selection.getStartPosition();
      const brackets = model.matchBracket(position);
      let newCursorPosition = null;
      if (brackets) {
        if (brackets[0].containsPosition(position)) {
          newCursorPosition = brackets[1].getStartPosition();
        } else if (brackets[1].containsPosition(position)) {
          newCursorPosition = brackets[0].getStartPosition();
        }
      } else {
        const enclosingBrackets = model.findEnclosingBrackets(position);
        if (enclosingBrackets) {
          newCursorPosition = enclosingBrackets[0].getStartPosition();
        } else {
          const nextBracket = model.findNextBracket(position);
          if (nextBracket && nextBracket.range) {
            newCursorPosition = nextBracket.range.getStartPosition();
          }
        }
      }
      if (newCursorPosition) {
        return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
      }
      return new Selection(position.lineNumber, position.column, position.lineNumber, position.column);
    });
    this._editor.setSelections(newSelections);
    this._editor.revealRange(newSelections[0]);
  }
  selectToBracket(selectBrackets) {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const newSelections = [];
    this._editor.getSelections().forEach((selection) => {
      const position = selection.getStartPosition();
      let brackets = model.matchBracket(position);
      if (!brackets) {
        brackets = model.findEnclosingBrackets(position);
        if (!brackets) {
          const nextBracket = model.findNextBracket(position);
          if (nextBracket && nextBracket.range) {
            brackets = model.matchBracket(nextBracket.range.getStartPosition());
          }
        }
      }
      let selectFrom = null;
      let selectTo = null;
      if (brackets) {
        brackets.sort(Range2.compareRangesUsingStarts);
        const [open, close] = brackets;
        selectFrom = selectBrackets ? open.getStartPosition() : open.getEndPosition();
        selectTo = selectBrackets ? close.getEndPosition() : close.getStartPosition();
      }
      if (selectFrom && selectTo) {
        newSelections.push(new Selection(selectFrom.lineNumber, selectFrom.column, selectTo.lineNumber, selectTo.column));
      }
    });
    if (newSelections.length > 0) {
      this._editor.setSelections(newSelections);
      this._editor.revealRange(newSelections[0]);
    }
  }
  _updateBrackets() {
    if (this._matchBrackets === "never") {
      return;
    }
    this._recomputeBrackets();
    let newDecorations = [], newDecorationsLen = 0;
    for (const bracketData of this._lastBracketsData) {
      let brackets = bracketData.brackets;
      if (brackets) {
        newDecorations[newDecorationsLen++] = {range: brackets[0], options: bracketData.options};
        newDecorations[newDecorationsLen++] = {range: brackets[1], options: bracketData.options};
      }
    }
    this._decorations = this._editor.deltaDecorations(this._decorations, newDecorations);
  }
  _recomputeBrackets() {
    if (!this._editor.hasModel()) {
      this._lastBracketsData = [];
      this._lastVersionId = 0;
      return;
    }
    const selections = this._editor.getSelections();
    if (selections.length > 100) {
      this._lastBracketsData = [];
      this._lastVersionId = 0;
      return;
    }
    const model = this._editor.getModel();
    const versionId = model.getVersionId();
    let previousData = [];
    if (this._lastVersionId === versionId) {
      previousData = this._lastBracketsData;
    }
    let positions = [], positionsLen = 0;
    for (let i = 0, len = selections.length; i < len; i++) {
      let selection = selections[i];
      if (selection.isEmpty()) {
        positions[positionsLen++] = selection.getStartPosition();
      }
    }
    if (positions.length > 1) {
      positions.sort(Position.compare);
    }
    let newData = [], newDataLen = 0;
    let previousIndex = 0, previousLen = previousData.length;
    for (let i = 0, len = positions.length; i < len; i++) {
      let position = positions[i];
      while (previousIndex < previousLen && previousData[previousIndex].position.isBefore(position)) {
        previousIndex++;
      }
      if (previousIndex < previousLen && previousData[previousIndex].position.equals(position)) {
        newData[newDataLen++] = previousData[previousIndex];
      } else {
        let brackets = model.matchBracket(position);
        let options = BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER;
        if (!brackets && this._matchBrackets === "always") {
          brackets = model.findEnclosingBrackets(position, 20);
          options = BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER;
        }
        newData[newDataLen++] = new BracketsData(position, brackets, options);
      }
    }
    this._lastBracketsData = newData;
    this._lastVersionId = versionId;
  }
};
BracketMatchingController.ID = "editor.contrib.bracketMatchingController";
BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER = ModelDecorationOptions.register({
  stickiness: 1,
  className: "bracket-match",
  overviewRuler: {
    color: themeColorFromId(overviewRulerBracketMatchForeground),
    position: OverviewRulerLane.Center
  }
});
BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER = ModelDecorationOptions.register({
  stickiness: 1,
  className: "bracket-match"
});
registerEditorContribution(BracketMatchingController.ID, BracketMatchingController);
registerEditorAction(SelectToBracketAction);
registerEditorAction(JumpToBracketAction);
registerThemingParticipant((theme6, collector) => {
  const bracketMatchBackground = theme6.getColor(editorBracketMatchBackground);
  if (bracketMatchBackground) {
    collector.addRule(`.monaco-editor .bracket-match { background-color: ${bracketMatchBackground}; }`);
  }
  const bracketMatchBorder = theme6.getColor(editorBracketMatchBorder);
  if (bracketMatchBorder) {
    collector.addRule(`.monaco-editor .bracket-match { border: 1px solid ${bracketMatchBorder}; }`);
  }
});
MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
  group: "5_infile_nav",
  command: {
    id: "editor.action.jumpToBracket",
    title: localize({key: "miGoToBracket", comment: ["&& denotes a mnemonic"]}, "Go to &&Bracket")
  },
  order: 2
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/moveCaretCommand.js
var MoveCaretCommand = class {
  constructor(selection, isMovingLeft) {
    this._selection = selection;
    this._isMovingLeft = isMovingLeft;
  }
  getEditOperations(model, builder) {
    if (this._selection.startLineNumber !== this._selection.endLineNumber || this._selection.isEmpty()) {
      return;
    }
    const lineNumber = this._selection.startLineNumber;
    const startColumn = this._selection.startColumn;
    const endColumn = this._selection.endColumn;
    if (this._isMovingLeft && startColumn === 1) {
      return;
    }
    if (!this._isMovingLeft && endColumn === model.getLineMaxColumn(lineNumber)) {
      return;
    }
    if (this._isMovingLeft) {
      const rangeBefore = new Range2(lineNumber, startColumn - 1, lineNumber, startColumn);
      const charBefore = model.getValueInRange(rangeBefore);
      builder.addEditOperation(rangeBefore, null);
      builder.addEditOperation(new Range2(lineNumber, endColumn, lineNumber, endColumn), charBefore);
    } else {
      const rangeAfter = new Range2(lineNumber, endColumn, lineNumber, endColumn + 1);
      const charAfter = model.getValueInRange(rangeAfter);
      builder.addEditOperation(rangeAfter, null);
      builder.addEditOperation(new Range2(lineNumber, startColumn, lineNumber, startColumn), charAfter);
    }
  }
  computeCursorState(model, helper) {
    if (this._isMovingLeft) {
      return new Selection(this._selection.startLineNumber, this._selection.startColumn - 1, this._selection.endLineNumber, this._selection.endColumn - 1);
    } else {
      return new Selection(this._selection.startLineNumber, this._selection.startColumn + 1, this._selection.endLineNumber, this._selection.endColumn + 1);
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/caretOperations.js
var MoveCaretAction = class extends EditorAction {
  constructor(left, opts) {
    super(opts);
    this.left = left;
  }
  run(accessor, editor3) {
    if (!editor3.hasModel()) {
      return;
    }
    let commands = [];
    let selections = editor3.getSelections();
    for (const selection of selections) {
      commands.push(new MoveCaretCommand(selection, this.left));
    }
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, commands);
    editor3.pushUndoStop();
  }
};
var MoveCaretLeftAction = class extends MoveCaretAction {
  constructor() {
    super(true, {
      id: "editor.action.moveCarretLeftAction",
      label: localize("caret.moveLeft", "Move Selected Text Left"),
      alias: "Move Selected Text Left",
      precondition: EditorContextKeys.writable
    });
  }
};
var MoveCaretRightAction = class extends MoveCaretAction {
  constructor() {
    super(false, {
      id: "editor.action.moveCarretRightAction",
      label: localize("caret.moveRight", "Move Selected Text Right"),
      alias: "Move Selected Text Right",
      precondition: EditorContextKeys.writable
    });
  }
};
registerEditorAction(MoveCaretLeftAction);
registerEditorAction(MoveCaretRightAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/transpose.js
var TransposeLettersAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.transposeLetters",
      label: localize("transposeLetters.label", "Transpose Letters"),
      alias: "Transpose Letters",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 50
        },
        weight: 100
      }
    });
  }
  run(accessor, editor3) {
    if (!editor3.hasModel()) {
      return;
    }
    let model = editor3.getModel();
    let commands = [];
    let selections = editor3.getSelections();
    for (let selection of selections) {
      if (!selection.isEmpty()) {
        continue;
      }
      let lineNumber = selection.startLineNumber;
      let column = selection.startColumn;
      let lastColumn = model.getLineMaxColumn(lineNumber);
      if (lineNumber === 1 && (column === 1 || column === 2 && lastColumn === 2)) {
        continue;
      }
      let endPosition = column === lastColumn ? selection.getPosition() : MoveOperations.rightPosition(model, selection.getPosition().lineNumber, selection.getPosition().column);
      let middlePosition = MoveOperations.leftPosition(model, endPosition.lineNumber, endPosition.column);
      let beginPosition = MoveOperations.leftPosition(model, middlePosition.lineNumber, middlePosition.column);
      let leftChar = model.getValueInRange(Range2.fromPositions(beginPosition, middlePosition));
      let rightChar = model.getValueInRange(Range2.fromPositions(middlePosition, endPosition));
      let replaceRange = Range2.fromPositions(beginPosition, endPosition);
      commands.push(new ReplaceCommand(replaceRange, rightChar + leftChar));
    }
    if (commands.length > 0) {
      editor3.pushUndoStop();
      editor3.executeCommands(this.id, commands);
      editor3.pushUndoStop();
    }
  }
};
registerEditorAction(TransposeLettersAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/clipboard/clipboard.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CLIPBOARD_CONTEXT_MENU_GROUP = "9_cutcopypaste";
var supportsCut = isNative || document.queryCommandSupported("cut");
var supportsCopy = isNative || document.queryCommandSupported("copy");
var supportsCopyWithSyntaxHighlighting = supportsCopy && !isEdge;
var supportsPaste = isFirefox ? document.queryCommandSupported("paste") : true;
function registerCommand(command) {
  command.register();
  return command;
}
var CutAction = supportsCut ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardCutAction",
  precondition: void 0,
  kbOpts: isNative ? {
    primary: 2048 | 54,
    win: {primary: 2048 | 54, secondary: [1024 | 20]},
    weight: 100
  } : void 0,
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({key: "miCut", comment: ["&& denotes a mnemonic"]}, "Cu&&t"),
    order: 1
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.cutLabel", "Cut"),
    when: EditorContextKeys.writable,
    order: 1
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.cutLabel", "Cut"),
    order: 1
  }]
})) : void 0;
var CopyAction = supportsCopy ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardCopyAction",
  precondition: void 0,
  kbOpts: isNative ? {
    primary: 2048 | 33,
    win: {primary: 2048 | 33, secondary: [2048 | 19]},
    weight: 100
  } : void 0,
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({key: "miCopy", comment: ["&& denotes a mnemonic"]}, "&&Copy"),
    order: 2
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 2
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 1
  }]
})) : void 0;
var PasteAction = supportsPaste ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardPasteAction",
  precondition: void 0,
  kbOpts: isNative ? {
    primary: 2048 | 52,
    win: {primary: 2048 | 52, secondary: [1024 | 19]},
    linux: {primary: 2048 | 52, secondary: [1024 | 19]},
    weight: 100
  } : void 0,
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({key: "miPaste", comment: ["&& denotes a mnemonic"]}, "&&Paste"),
    order: 3
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    when: EditorContextKeys.writable,
    order: 3
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    order: 1
  }]
})) : void 0;
var ExecCommandCopyWithSyntaxHighlightingAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.clipboardCopyWithSyntaxHighlightingAction",
      label: localize("actions.clipboard.copyWithSyntaxHighlightingLabel", "Copy With Syntax Highlighting"),
      alias: "Copy With Syntax Highlighting",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        weight: 100
      }
    });
  }
  run(accessor, editor3) {
    if (!editor3.hasModel()) {
      return;
    }
    const emptySelectionClipboard = editor3.getOption(26);
    if (!emptySelectionClipboard && editor3.getSelection().isEmpty()) {
      return;
    }
    CopyOptions.forceCopyWithSyntaxHighlighting = true;
    editor3.focus();
    document.execCommand("copy");
    CopyOptions.forceCopyWithSyntaxHighlighting = false;
  }
};
function registerExecCommandImpl(target, browserCommand) {
  if (!target) {
    return;
  }
  target.addImplementation(1e4, (accessor, args) => {
    const focusedEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
    if (focusedEditor && focusedEditor.hasTextFocus()) {
      const emptySelectionClipboard = focusedEditor.getOption(26);
      const selection = focusedEditor.getSelection();
      if (selection && selection.isEmpty() && !emptySelectionClipboard) {
        return true;
      }
      document.execCommand(browserCommand);
      return true;
    }
    return false;
  });
  target.addImplementation(0, (accessor, args) => {
    document.execCommand(browserCommand);
    return true;
  });
}
registerExecCommandImpl(CutAction, "cut");
registerExecCommandImpl(CopyAction, "copy");
if (PasteAction) {
  PasteAction.addImplementation(1e4, (accessor, args) => {
    const codeEditorService = accessor.get(ICodeEditorService);
    const clipboardService = accessor.get(IClipboardService);
    const focusedEditor = codeEditorService.getFocusedCodeEditor();
    if (focusedEditor && focusedEditor.hasTextFocus()) {
      const result = document.execCommand("paste");
      if (!result && isWeb) {
        (() => __awaiter2(void 0, void 0, void 0, function* () {
          const clipboardText = yield clipboardService.readText();
          if (clipboardText !== "") {
            const metadata = InMemoryClipboardMetadataManager.INSTANCE.get(clipboardText);
            let pasteOnNewLine = false;
            let multicursorText = null;
            let mode = null;
            if (metadata) {
              pasteOnNewLine = focusedEditor.getOption(26) && !!metadata.isFromEmptySelection;
              multicursorText = typeof metadata.multicursorText !== "undefined" ? metadata.multicursorText : null;
              mode = metadata.mode;
            }
            focusedEditor.trigger("keyboard", "paste", {
              text: clipboardText,
              pasteOnNewLine,
              multicursorText,
              mode
            });
          }
        }))();
        return true;
      }
      return true;
    }
    return false;
  });
  PasteAction.addImplementation(0, (accessor, args) => {
    document.execCommand("paste");
    return true;
  });
}
if (supportsCopyWithSyntaxHighlighting) {
  registerEditorAction(ExecCommandCopyWithSyntaxHighlightingAction);
}

// ../../node_modules/monaco-editor/esm/vs/base/common/lazy.js
var Lazy = class {
  constructor(executor) {
    this.executor = executor;
    this._didRun = false;
  }
  getValue() {
    if (!this._didRun) {
      try {
        this._value = this.executor();
      } catch (err) {
        this._error = err;
      } finally {
        this._didRun = true;
      }
    }
    if (this._error) {
      throw this._error;
    }
    return this._value;
  }
  get rawValue() {
    return this._value;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/types.js
var CodeActionKind = class {
  constructor(value) {
    this.value = value;
  }
  equals(other) {
    return this.value === other.value;
  }
  contains(other) {
    return this.equals(other) || this.value === "" || startsWith(other.value, this.value + CodeActionKind.sep);
  }
  intersects(other) {
    return this.contains(other) || other.contains(this);
  }
  append(part) {
    return new CodeActionKind(this.value + CodeActionKind.sep + part);
  }
};
CodeActionKind.sep = ".";
CodeActionKind.None = new CodeActionKind("@@none@@");
CodeActionKind.Empty = new CodeActionKind("");
CodeActionKind.QuickFix = new CodeActionKind("quickfix");
CodeActionKind.Refactor = new CodeActionKind("refactor");
CodeActionKind.Source = new CodeActionKind("source");
CodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append("organizeImports");
CodeActionKind.SourceFixAll = CodeActionKind.Source.append("fixAll");
function mayIncludeActionsOfKind(filter2, providedKind) {
  if (filter2.include && !filter2.include.intersects(providedKind)) {
    return false;
  }
  if (filter2.excludes) {
    if (filter2.excludes.some((exclude) => excludesAction(providedKind, exclude, filter2.include))) {
      return false;
    }
  }
  if (!filter2.includeSourceActions && CodeActionKind.Source.contains(providedKind)) {
    return false;
  }
  return true;
}
function filtersAction(filter2, action) {
  const actionKind = action.kind ? new CodeActionKind(action.kind) : void 0;
  if (filter2.include) {
    if (!actionKind || !filter2.include.contains(actionKind)) {
      return false;
    }
  }
  if (filter2.excludes) {
    if (actionKind && filter2.excludes.some((exclude) => excludesAction(actionKind, exclude, filter2.include))) {
      return false;
    }
  }
  if (!filter2.includeSourceActions) {
    if (actionKind && CodeActionKind.Source.contains(actionKind)) {
      return false;
    }
  }
  if (filter2.onlyIncludePreferredActions) {
    if (!action.isPreferred) {
      return false;
    }
  }
  return true;
}
function excludesAction(providedKind, exclude, include) {
  if (!exclude.contains(providedKind)) {
    return false;
  }
  if (include && exclude.contains(include)) {
    return false;
  }
  return true;
}
var CodeActionCommandArgs = class {
  constructor(kind, apply2, preferred) {
    this.kind = kind;
    this.apply = apply2;
    this.preferred = preferred;
  }
  static fromUser(arg, defaults) {
    if (!arg || typeof arg !== "object") {
      return new CodeActionCommandArgs(defaults.kind, defaults.apply, false);
    }
    return new CodeActionCommandArgs(CodeActionCommandArgs.getKindFromUser(arg, defaults.kind), CodeActionCommandArgs.getApplyFromUser(arg, defaults.apply), CodeActionCommandArgs.getPreferredUser(arg));
  }
  static getApplyFromUser(arg, defaultAutoApply) {
    switch (typeof arg.apply === "string" ? arg.apply.toLowerCase() : "") {
      case "first":
        return "first";
      case "never":
        return "never";
      case "ifsingle":
        return "ifSingle";
      default:
        return defaultAutoApply;
    }
  }
  static getKindFromUser(arg, defaultKind) {
    return typeof arg.kind === "string" ? new CodeActionKind(arg.kind) : defaultKind;
  }
  static getPreferredUser(arg) {
    return typeof arg.preferred === "boolean" ? arg.preferred : false;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeAction.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var codeActionCommandId = "editor.action.codeAction";
var refactorCommandId = "editor.action.refactor";
var sourceActionCommandId = "editor.action.sourceAction";
var organizeImportsCommandId = "editor.action.organizeImports";
var fixAllCommandId = "editor.action.fixAll";
var ManagedCodeActionSet = class extends Disposable {
  constructor(actions25, documentation, disposables) {
    super();
    this.documentation = documentation;
    this._register(disposables);
    this.allActions = mergeSort([...actions25], ManagedCodeActionSet.codeActionsComparator);
    this.validActions = this.allActions.filter((action) => !action.disabled);
  }
  static codeActionsComparator(a, b) {
    if (a.isPreferred && !b.isPreferred) {
      return -1;
    } else if (!a.isPreferred && b.isPreferred) {
      return 1;
    }
    if (isNonEmptyArray(a.diagnostics)) {
      if (isNonEmptyArray(b.diagnostics)) {
        return a.diagnostics[0].message.localeCompare(b.diagnostics[0].message);
      } else {
        return -1;
      }
    } else if (isNonEmptyArray(b.diagnostics)) {
      return 1;
    } else {
      return 0;
    }
  }
  get hasAutoFix() {
    return this.validActions.some((fix) => !!fix.kind && CodeActionKind.QuickFix.contains(new CodeActionKind(fix.kind)) && !!fix.isPreferred);
  }
};
var emptyCodeActionsResponse = {actions: [], documentation: void 0};
function getCodeActions(model, rangeOrSelection, trigger, progress, token) {
  var _a5;
  const filter2 = trigger.filter || {};
  const codeActionContext = {
    only: (_a5 = filter2.include) === null || _a5 === void 0 ? void 0 : _a5.value,
    trigger: trigger.type
  };
  const cts = new TextModelCancellationTokenSource(model, token);
  const providers = getCodeActionProviders(model, filter2);
  const disposables = new DisposableStore();
  const promises = providers.map((provider) => __awaiter3(this, void 0, void 0, function* () {
    try {
      progress.report(provider);
      const providedCodeActions = yield provider.provideCodeActions(model, rangeOrSelection, codeActionContext, cts.token);
      if (providedCodeActions) {
        disposables.add(providedCodeActions);
      }
      if (cts.token.isCancellationRequested) {
        return emptyCodeActionsResponse;
      }
      const filteredActions = ((providedCodeActions === null || providedCodeActions === void 0 ? void 0 : providedCodeActions.actions) || []).filter((action) => action && filtersAction(filter2, action));
      const documentation = getDocumentation(provider, filteredActions, filter2.include);
      return {actions: filteredActions, documentation};
    } catch (err) {
      if (isPromiseCanceledError(err)) {
        throw err;
      }
      onUnexpectedExternalError(err);
      return emptyCodeActionsResponse;
    }
  }));
  const listener = CodeActionProviderRegistry.onDidChange(() => {
    const newProviders = CodeActionProviderRegistry.all(model);
    if (!equals(newProviders, providers)) {
      cts.cancel();
    }
  });
  return Promise.all(promises).then((actions25) => {
    const allActions = flatten(actions25.map((x) => x.actions));
    const allDocumentation = coalesce(actions25.map((x) => x.documentation));
    return new ManagedCodeActionSet(allActions, allDocumentation, disposables);
  }).finally(() => {
    listener.dispose();
    cts.dispose();
  });
}
function getCodeActionProviders(model, filter2) {
  return CodeActionProviderRegistry.all(model).filter((provider) => {
    if (!provider.providedCodeActionKinds) {
      return true;
    }
    return provider.providedCodeActionKinds.some((kind) => mayIncludeActionsOfKind(filter2, new CodeActionKind(kind)));
  });
}
function getDocumentation(provider, providedCodeActions, only) {
  if (!provider.documentation) {
    return void 0;
  }
  const documentation = provider.documentation.map((entry) => ({kind: new CodeActionKind(entry.kind), command: entry.command}));
  if (only) {
    let currentBest;
    for (const entry of documentation) {
      if (entry.kind.contains(only)) {
        if (!currentBest) {
          currentBest = entry;
        } else {
          if (currentBest.kind.contains(entry.kind)) {
            currentBest = entry;
          }
        }
      }
    }
    if (currentBest) {
      return currentBest === null || currentBest === void 0 ? void 0 : currentBest.command;
    }
  }
  for (const action of providedCodeActions) {
    if (!action.kind) {
      continue;
    }
    for (const entry of documentation) {
      if (entry.kind.contains(new CodeActionKind(action.kind))) {
        return entry.command;
      }
    }
  }
  return void 0;
}
registerLanguageCommand("_executeCodeActionProvider", function(accessor, args) {
  return __awaiter3(this, void 0, void 0, function* () {
    const {resource, rangeOrSelection, kind} = args;
    if (!(resource instanceof URI)) {
      throw illegalArgument();
    }
    const model = accessor.get(IModelService).getModel(resource);
    if (!model) {
      throw illegalArgument();
    }
    const validatedRangeOrSelection = Selection.isISelection(rangeOrSelection) ? Selection.liftSelection(rangeOrSelection) : Range2.isIRange(rangeOrSelection) ? model.validateRange(rangeOrSelection) : void 0;
    if (!validatedRangeOrSelection) {
      throw illegalArgument();
    }
    const codeActionSet = yield getCodeActions(model, validatedRangeOrSelection, {type: 2, filter: {includeSourceActions: true, include: kind && kind.value ? new CodeActionKind(kind.value) : void 0}}, Progress.None, CancellationToken.None);
    setTimeout(() => codeActionSet.dispose(), 100);
    return codeActionSet.validActions;
  });
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MessageController = class MessageController2 extends Disposable {
  constructor(editor3, contextKeyService) {
    super();
    this._messageWidget = this._register(new MutableDisposable());
    this._messageListeners = this._register(new DisposableStore());
    this._editor = editor3;
    this._visible = MessageController2.MESSAGE_VISIBLE.bindTo(contextKeyService);
    this._register(this._editor.onDidAttemptReadOnlyEdit(() => this._onDidAttemptReadOnlyEdit()));
  }
  static get(editor3) {
    return editor3.getContribution(MessageController2.ID);
  }
  dispose() {
    super.dispose();
    this._visible.reset();
  }
  showMessage(message, position) {
    alert(message);
    this._visible.set(true);
    this._messageWidget.clear();
    this._messageListeners.clear();
    this._messageWidget.value = new MessageWidget(this._editor, position, message);
    this._messageListeners.add(this._editor.onDidBlurEditorText(() => this.closeMessage()));
    this._messageListeners.add(this._editor.onDidChangeCursorPosition(() => this.closeMessage()));
    this._messageListeners.add(this._editor.onDidDispose(() => this.closeMessage()));
    this._messageListeners.add(this._editor.onDidChangeModel(() => this.closeMessage()));
    this._messageListeners.add(new TimeoutTimer(() => this.closeMessage(), 3e3));
    let bounds;
    this._messageListeners.add(this._editor.onMouseMove((e) => {
      if (!e.target.position) {
        return;
      }
      if (!bounds) {
        bounds = new Range2(position.lineNumber - 3, 1, e.target.position.lineNumber + 3, 1);
      } else if (!bounds.containsPosition(e.target.position)) {
        this.closeMessage();
      }
    }));
  }
  closeMessage() {
    this._visible.reset();
    this._messageListeners.clear();
    if (this._messageWidget.value) {
      this._messageListeners.add(MessageWidget.fadeOut(this._messageWidget.value));
    }
  }
  _onDidAttemptReadOnlyEdit() {
    if (this._editor.hasModel()) {
      this.showMessage(localize("editor.readonly", "Cannot edit in read-only editor"), this._editor.getPosition());
    }
  }
};
MessageController.ID = "editor.contrib.messageController";
MessageController.MESSAGE_VISIBLE = new RawContextKey("messageVisible", false);
MessageController = __decorate2([
  __param2(1, IContextKeyService)
], MessageController);
var MessageCommand = EditorCommand.bindToContribution(MessageController.get);
registerEditorCommand(new MessageCommand({
  id: "leaveEditorMessage",
  precondition: MessageController.MESSAGE_VISIBLE,
  handler: (c) => c.closeMessage(),
  kbOpts: {
    weight: 100 + 30,
    primary: 9
  }
}));
var MessageWidget = class {
  constructor(editor3, {lineNumber, column}, text) {
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this._editor = editor3;
    this._editor.revealLinesInCenterIfOutsideViewport(lineNumber, lineNumber, 0);
    this._position = {lineNumber, column: column - 1};
    this._domNode = document.createElement("div");
    this._domNode.classList.add("monaco-editor-overlaymessage");
    const message = document.createElement("div");
    message.classList.add("message");
    message.textContent = text;
    this._domNode.appendChild(message);
    const anchor = document.createElement("div");
    anchor.classList.add("anchor");
    this._domNode.appendChild(anchor);
    this._editor.addContentWidget(this);
    this._domNode.classList.add("fadeIn");
  }
  static fadeOut(messageWidget) {
    let handle;
    const dispose2 = () => {
      messageWidget.dispose();
      clearTimeout(handle);
      messageWidget.getDomNode().removeEventListener("animationend", dispose2);
    };
    handle = setTimeout(dispose2, 110);
    messageWidget.getDomNode().addEventListener("animationend", dispose2);
    messageWidget.getDomNode().classList.add("fadeOut");
    return {dispose: dispose2};
  }
  dispose() {
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "messageoverlay";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {position: this._position, preference: [1, 2]};
  }
};
registerEditorContribution(MessageController.ID, MessageController);
registerThemingParticipant((theme6, collector) => {
  const border = theme6.getColor(inputValidationInfoBorder);
  if (border) {
    let borderWidth = theme6.type === HIGH_CONTRAST ? 2 : 1;
    collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .anchor { border-top-color: ${border}; }`);
    collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .message { border: ${borderWidth}px solid ${border}; }`);
  }
  const background = theme6.getColor(inputValidationInfoBackground);
  if (background) {
    collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .message { background-color: ${background}; }`);
  }
  const foreground2 = theme6.getColor(inputValidationInfoForeground);
  if (foreground2) {
    collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .message { color: ${foreground2}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionMenu.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CodeActionAction = class extends Action {
  constructor(action, callback) {
    super(action.command ? action.command.id : action.title, action.title, void 0, !action.disabled, callback);
    this.action = action;
  }
};
var CodeActionMenu = class CodeActionMenu2 extends Disposable {
  constructor(_editor, _delegate, _contextMenuService, keybindingService) {
    super();
    this._editor = _editor;
    this._delegate = _delegate;
    this._contextMenuService = _contextMenuService;
    this._visible = false;
    this._showingActions = this._register(new MutableDisposable());
    this._keybindingResolver = new CodeActionKeybindingResolver({
      getKeybindings: () => keybindingService.getKeybindings()
    });
  }
  get isVisible() {
    return this._visible;
  }
  show(trigger, codeActions, at, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const actionsToShow = options.includeDisabledActions ? codeActions.allActions : codeActions.validActions;
      if (!actionsToShow.length) {
        this._visible = false;
        return;
      }
      if (!this._editor.getDomNode()) {
        this._visible = false;
        throw canceled();
      }
      this._visible = true;
      this._showingActions.value = codeActions;
      const menuActions = this.getMenuActions(trigger, actionsToShow, codeActions.documentation);
      const anchor = Position.isIPosition(at) ? this._toCoords(at) : at || {x: 0, y: 0};
      const resolver = this._keybindingResolver.getResolver();
      this._contextMenuService.showContextMenu({
        domForShadowRoot: this._editor.getDomNode(),
        getAnchor: () => anchor,
        getActions: () => menuActions,
        onHide: () => {
          this._visible = false;
          this._editor.focus();
        },
        autoSelectFirstItem: true,
        getKeyBinding: (action) => action instanceof CodeActionAction ? resolver(action.action) : void 0
      });
    });
  }
  getMenuActions(trigger, actionsToShow, documentation) {
    var _a5, _b2;
    const toCodeActionAction = (action) => new CodeActionAction(action, () => this._delegate.onSelectCodeAction(action));
    const result = actionsToShow.map(toCodeActionAction);
    const allDocumentation = [...documentation];
    const model = this._editor.getModel();
    if (model && result.length) {
      for (const provider of CodeActionProviderRegistry.all(model)) {
        if (provider._getAdditionalMenuItems) {
          allDocumentation.push(...provider._getAdditionalMenuItems({trigger: trigger.type, only: (_b2 = (_a5 = trigger.filter) === null || _a5 === void 0 ? void 0 : _a5.include) === null || _b2 === void 0 ? void 0 : _b2.value}, actionsToShow));
        }
      }
    }
    if (allDocumentation.length) {
      result.push(new Separator(), ...allDocumentation.map((command) => toCodeActionAction({
        title: command.title,
        command
      })));
    }
    return result;
  }
  _toCoords(position) {
    if (!this._editor.hasModel()) {
      return {x: 0, y: 0};
    }
    this._editor.revealPosition(position, 1);
    this._editor.render();
    const cursorCoords = this._editor.getScrolledVisiblePosition(position);
    const editorCoords = getDomNodePagePosition(this._editor.getDomNode());
    const x = editorCoords.left + cursorCoords.left;
    const y = editorCoords.top + cursorCoords.top + cursorCoords.height;
    return {x, y};
  }
};
CodeActionMenu = __decorate3([
  __param3(2, IContextMenuService),
  __param3(3, IKeybindingService)
], CodeActionMenu);
var CodeActionKeybindingResolver = class {
  constructor(_keybindingProvider) {
    this._keybindingProvider = _keybindingProvider;
  }
  getResolver() {
    const allCodeActionBindings = new Lazy(() => this._keybindingProvider.getKeybindings().filter((item) => CodeActionKeybindingResolver.codeActionCommands.indexOf(item.command) >= 0).filter((item) => item.resolvedKeybinding).map((item) => {
      let commandArgs = item.commandArgs;
      if (item.command === organizeImportsCommandId) {
        commandArgs = {kind: CodeActionKind.SourceOrganizeImports.value};
      } else if (item.command === fixAllCommandId) {
        commandArgs = {kind: CodeActionKind.SourceFixAll.value};
      }
      return Object.assign({resolvedKeybinding: item.resolvedKeybinding}, CodeActionCommandArgs.fromUser(commandArgs, {
        kind: CodeActionKind.None,
        apply: "never"
      }));
    }));
    return (action) => {
      if (action.kind) {
        const binding = this.bestKeybindingForCodeAction(action, allCodeActionBindings.getValue());
        return binding === null || binding === void 0 ? void 0 : binding.resolvedKeybinding;
      }
      return void 0;
    };
  }
  bestKeybindingForCodeAction(action, candidates) {
    if (!action.kind) {
      return void 0;
    }
    const kind = new CodeActionKind(action.kind);
    return candidates.filter((candidate) => candidate.kind.contains(kind)).filter((candidate) => {
      if (candidate.preferred) {
        return action.isPreferred;
      }
      return true;
    }).reduceRight((currentBest, candidate) => {
      if (!currentBest) {
        return candidate;
      }
      return currentBest.kind.contains(candidate.kind) ? candidate : currentBest;
    }, void 0);
  }
};
CodeActionKeybindingResolver.codeActionCommands = [
  refactorCommandId,
  codeActionCommandId,
  sourceActionCommandId,
  organizeImportsCommandId,
  fixAllCommandId
];

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.js
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var LightBulbState;
(function(LightBulbState2) {
  LightBulbState2.Hidden = {type: 0};
  class Showing {
    constructor(actions25, trigger, editorPosition, widgetPosition) {
      this.actions = actions25;
      this.trigger = trigger;
      this.editorPosition = editorPosition;
      this.widgetPosition = widgetPosition;
      this.type = 1;
    }
  }
  LightBulbState2.Showing = Showing;
})(LightBulbState || (LightBulbState = {}));
var LightBulbWidget = class LightBulbWidget2 extends Disposable {
  constructor(_editor, _quickFixActionId, _preferredFixActionId, _keybindingService) {
    super();
    this._editor = _editor;
    this._quickFixActionId = _quickFixActionId;
    this._preferredFixActionId = _preferredFixActionId;
    this._keybindingService = _keybindingService;
    this._onClick = this._register(new Emitter2());
    this.onClick = this._onClick.event;
    this._state = LightBulbState.Hidden;
    this._domNode = document.createElement("div");
    this._domNode.className = Codicon.lightBulb.classNames;
    this._editor.addContentWidget(this);
    this._register(this._editor.onDidChangeModelContent((_) => {
      const editorModel = this._editor.getModel();
      if (this.state.type !== 1 || !editorModel || this.state.editorPosition.lineNumber >= editorModel.getLineCount()) {
        this.hide();
      }
    }));
    Gesture.ignoreTarget(this._domNode);
    this._register(addStandardDisposableGenericMouseDownListner(this._domNode, (e) => {
      if (this.state.type !== 1) {
        return;
      }
      this._editor.focus();
      e.preventDefault();
      const {top, height} = getDomNodePagePosition(this._domNode);
      const lineHeight = this._editor.getOption(51);
      let pad2 = Math.floor(lineHeight / 3);
      if (this.state.widgetPosition.position !== null && this.state.widgetPosition.position.lineNumber < this.state.editorPosition.lineNumber) {
        pad2 += lineHeight;
      }
      this._onClick.fire({
        x: e.posx,
        y: top + height + pad2,
        actions: this.state.actions,
        trigger: this.state.trigger
      });
    }));
    this._register(addDisposableListener(this._domNode, "mouseenter", (e) => {
      if ((e.buttons & 1) !== 1) {
        return;
      }
      this.hide();
      const monitor = new GlobalMouseMoveMonitor();
      monitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, () => {
      }, () => {
        monitor.dispose();
      });
    }));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(49) && !this._editor.getOption(49).enabled) {
        this.hide();
      }
    }));
    this._updateLightBulbTitleAndIcon();
    this._register(this._keybindingService.onDidUpdateKeybindings(this._updateLightBulbTitleAndIcon, this));
  }
  dispose() {
    super.dispose();
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "LightBulbWidget";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._state.type === 1 ? this._state.widgetPosition : null;
  }
  update(actions25, trigger, atPosition) {
    if (actions25.validActions.length <= 0) {
      return this.hide();
    }
    const options = this._editor.getOptions();
    if (!options.get(49).enabled) {
      return this.hide();
    }
    const model = this._editor.getModel();
    if (!model) {
      return this.hide();
    }
    const {lineNumber, column} = model.validatePosition(atPosition);
    const tabSize = model.getOptions().tabSize;
    const fontInfo = options.get(36);
    const lineContent = model.getLineContent(lineNumber);
    const indent = TextModel.computeIndentLevel(lineContent, tabSize);
    const lineHasSpace = fontInfo.spaceWidth * indent > 22;
    const isFolded = (lineNumber2) => {
      return lineNumber2 > 2 && this._editor.getTopForLineNumber(lineNumber2) === this._editor.getTopForLineNumber(lineNumber2 - 1);
    };
    let effectiveLineNumber = lineNumber;
    if (!lineHasSpace) {
      if (lineNumber > 1 && !isFolded(lineNumber - 1)) {
        effectiveLineNumber -= 1;
      } else if (!isFolded(lineNumber + 1)) {
        effectiveLineNumber += 1;
      } else if (column * fontInfo.spaceWidth < 22) {
        return this.hide();
      }
    }
    this.state = new LightBulbState.Showing(actions25, trigger, atPosition, {
      position: {lineNumber: effectiveLineNumber, column: 1},
      preference: LightBulbWidget2._posPref
    });
    this._editor.layoutContentWidget(this);
  }
  hide() {
    this.state = LightBulbState.Hidden;
    this._editor.layoutContentWidget(this);
  }
  get state() {
    return this._state;
  }
  set state(value) {
    this._state = value;
    this._updateLightBulbTitleAndIcon();
  }
  _updateLightBulbTitleAndIcon() {
    if (this.state.type === 1 && this.state.actions.hasAutoFix) {
      removeClasses(this._domNode, Codicon.lightBulb.classNames);
      addClasses(this._domNode, Codicon.lightbulbAutofix.classNames);
      const preferredKb = this._keybindingService.lookupKeybinding(this._preferredFixActionId);
      if (preferredKb) {
        this.title = localize("prefferedQuickFixWithKb", "Show Fixes. Preferred Fix Available ({0})", preferredKb.getLabel());
        return;
      }
    }
    removeClasses(this._domNode, Codicon.lightbulbAutofix.classNames);
    addClasses(this._domNode, Codicon.lightBulb.classNames);
    const kb = this._keybindingService.lookupKeybinding(this._quickFixActionId);
    if (kb) {
      this.title = localize("quickFixWithKb", "Show Fixes ({0})", kb.getLabel());
    } else {
      this.title = localize("quickFix", "Show Fixes");
    }
  }
  set title(value) {
    this._domNode.title = value;
  }
};
LightBulbWidget._posPref = [0];
LightBulbWidget = __decorate4([
  __param4(3, IKeybindingService)
], LightBulbWidget);
registerThemingParticipant((theme6, collector) => {
  const editorLightBulbForegroundColor = theme6.getColor(editorLightBulbForeground);
  if (editorLightBulbForegroundColor) {
    collector.addRule(`
		.monaco-editor .contentWidgets ${Codicon.lightBulb.cssSelector} {
			color: ${editorLightBulbForegroundColor};
		}`);
  }
  const editorLightBulbAutoFixForegroundColor = theme6.getColor(editorLightBulbAutoFixForeground);
  if (editorLightBulbAutoFixForegroundColor) {
    collector.addRule(`
		.monaco-editor .contentWidgets ${Codicon.lightbulbAutofix.cssSelector} {
			color: ${editorLightBulbAutoFixForegroundColor};
		}`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionUi.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CodeActionUi = class CodeActionUi2 extends Disposable {
  constructor(_editor, quickFixActionId, preferredFixActionId, delegate, instantiationService) {
    super();
    this._editor = _editor;
    this.delegate = delegate;
    this._activeCodeActions = this._register(new MutableDisposable());
    this._codeActionWidget = new Lazy(() => {
      return this._register(instantiationService.createInstance(CodeActionMenu, this._editor, {
        onSelectCodeAction: (action) => __awaiter5(this, void 0, void 0, function* () {
          this.delegate.applyCodeAction(action, true);
        })
      }));
    });
    this._lightBulbWidget = new Lazy(() => {
      const widget = this._register(instantiationService.createInstance(LightBulbWidget, this._editor, quickFixActionId, preferredFixActionId));
      this._register(widget.onClick((e) => this.showCodeActionList(e.trigger, e.actions, e, {includeDisabledActions: false})));
      return widget;
    });
  }
  update(newState) {
    var _a5, _b2, _c2;
    return __awaiter5(this, void 0, void 0, function* () {
      if (newState.type !== 1) {
        (_a5 = this._lightBulbWidget.rawValue) === null || _a5 === void 0 ? void 0 : _a5.hide();
        return;
      }
      let actions25;
      try {
        actions25 = yield newState.actions;
      } catch (e) {
        onUnexpectedError(e);
        return;
      }
      this._lightBulbWidget.getValue().update(actions25, newState.trigger, newState.position);
      if (newState.trigger.type === 2) {
        if ((_b2 = newState.trigger.filter) === null || _b2 === void 0 ? void 0 : _b2.include) {
          const validActionToApply = this.tryGetValidActionToApply(newState.trigger, actions25);
          if (validActionToApply) {
            try {
              yield this.delegate.applyCodeAction(validActionToApply, false);
            } finally {
              actions25.dispose();
            }
            return;
          }
          if (newState.trigger.context) {
            const invalidAction = this.getInvalidActionThatWouldHaveBeenApplied(newState.trigger, actions25);
            if (invalidAction && invalidAction.disabled) {
              MessageController.get(this._editor).showMessage(invalidAction.disabled, newState.trigger.context.position);
              actions25.dispose();
              return;
            }
          }
        }
        const includeDisabledActions = !!((_c2 = newState.trigger.filter) === null || _c2 === void 0 ? void 0 : _c2.include);
        if (newState.trigger.context) {
          if (!actions25.allActions.length || !includeDisabledActions && !actions25.validActions.length) {
            MessageController.get(this._editor).showMessage(newState.trigger.context.notAvailableMessage, newState.trigger.context.position);
            this._activeCodeActions.value = actions25;
            actions25.dispose();
            return;
          }
        }
        this._activeCodeActions.value = actions25;
        this._codeActionWidget.getValue().show(newState.trigger, actions25, newState.position, {includeDisabledActions});
      } else {
        if (this._codeActionWidget.getValue().isVisible) {
          actions25.dispose();
        } else {
          this._activeCodeActions.value = actions25;
        }
      }
    });
  }
  getInvalidActionThatWouldHaveBeenApplied(trigger, actions25) {
    if (!actions25.allActions.length) {
      return void 0;
    }
    if (trigger.autoApply === "first" && actions25.validActions.length === 0 || trigger.autoApply === "ifSingle" && actions25.allActions.length === 1) {
      return actions25.allActions.find((action) => action.disabled);
    }
    return void 0;
  }
  tryGetValidActionToApply(trigger, actions25) {
    if (!actions25.validActions.length) {
      return void 0;
    }
    if (trigger.autoApply === "first" && actions25.validActions.length > 0 || trigger.autoApply === "ifSingle" && actions25.validActions.length === 1) {
      return actions25.validActions[0];
    }
    return void 0;
  }
  showCodeActionList(trigger, actions25, at, options) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._codeActionWidget.getValue().show(trigger, actions25, at, options);
    });
  }
};
CodeActionUi = __decorate5([
  __param5(4, IInstantiationService)
], CodeActionUi);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionModel.js
var SUPPORTED_CODE_ACTIONS = new RawContextKey("supportedCodeAction", "");
var CodeActionOracle = class extends Disposable {
  constructor(_editor, _markerService, _signalChange, _delay = 250) {
    super();
    this._editor = _editor;
    this._markerService = _markerService;
    this._signalChange = _signalChange;
    this._delay = _delay;
    this._autoTriggerTimer = this._register(new TimeoutTimer());
    this._register(this._markerService.onMarkerChanged((e) => this._onMarkerChanges(e)));
    this._register(this._editor.onDidChangeCursorPosition(() => this._onCursorChange()));
  }
  trigger(trigger) {
    const selection = this._getRangeOfSelectionUnlessWhitespaceEnclosed(trigger);
    return this._createEventAndSignalChange(trigger, selection);
  }
  _onMarkerChanges(resources2) {
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    if (resources2.some((resource) => isEqual(resource, model.uri))) {
      this._autoTriggerTimer.cancelAndSet(() => {
        this.trigger({type: 1});
      }, this._delay);
    }
  }
  _onCursorChange() {
    this._autoTriggerTimer.cancelAndSet(() => {
      this.trigger({type: 1});
    }, this._delay);
  }
  _getRangeOfMarker(selection) {
    const model = this._editor.getModel();
    if (!model) {
      return void 0;
    }
    for (const marker of this._markerService.read({resource: model.uri})) {
      const markerRange = model.validateRange(marker);
      if (Range2.intersectRanges(markerRange, selection)) {
        return Range2.lift(markerRange);
      }
    }
    return void 0;
  }
  _getRangeOfSelectionUnlessWhitespaceEnclosed(trigger) {
    if (!this._editor.hasModel()) {
      return void 0;
    }
    const model = this._editor.getModel();
    const selection = this._editor.getSelection();
    if (selection.isEmpty() && trigger.type === 1) {
      const {lineNumber, column} = selection.getPosition();
      const line = model.getLineContent(lineNumber);
      if (line.length === 0) {
        return void 0;
      } else if (column === 1) {
        if (/\s/.test(line[0])) {
          return void 0;
        }
      } else if (column === model.getLineMaxColumn(lineNumber)) {
        if (/\s/.test(line[line.length - 1])) {
          return void 0;
        }
      } else {
        if (/\s/.test(line[column - 2]) && /\s/.test(line[column - 1])) {
          return void 0;
        }
      }
    }
    return selection;
  }
  _createEventAndSignalChange(trigger, selection) {
    const model = this._editor.getModel();
    if (!selection || !model) {
      this._signalChange(void 0);
      return void 0;
    }
    const markerRange = this._getRangeOfMarker(selection);
    const position = markerRange ? markerRange.getStartPosition() : selection.getStartPosition();
    const e = {
      trigger,
      selection,
      position
    };
    this._signalChange(e);
    return e;
  }
};
var CodeActionsState;
(function(CodeActionsState2) {
  CodeActionsState2.Empty = {type: 0};
  class Triggered {
    constructor(trigger, rangeOrSelection, position, actions25) {
      this.trigger = trigger;
      this.rangeOrSelection = rangeOrSelection;
      this.position = position;
      this.actions = actions25;
      this.type = 1;
    }
  }
  CodeActionsState2.Triggered = Triggered;
})(CodeActionsState || (CodeActionsState = {}));
var CodeActionModel = class extends Disposable {
  constructor(_editor, _markerService, contextKeyService, _progressService) {
    super();
    this._editor = _editor;
    this._markerService = _markerService;
    this._progressService = _progressService;
    this._codeActionOracle = this._register(new MutableDisposable());
    this._state = CodeActionsState.Empty;
    this._onDidChangeState = this._register(new Emitter2());
    this.onDidChangeState = this._onDidChangeState.event;
    this._supportedCodeActions = SUPPORTED_CODE_ACTIONS.bindTo(contextKeyService);
    this._register(this._editor.onDidChangeModel(() => this._update()));
    this._register(this._editor.onDidChangeModelLanguage(() => this._update()));
    this._register(CodeActionProviderRegistry.onDidChange(() => this._update()));
    this._update();
  }
  dispose() {
    super.dispose();
    this.setState(CodeActionsState.Empty, true);
  }
  _update() {
    this._codeActionOracle.value = void 0;
    this.setState(CodeActionsState.Empty);
    const model = this._editor.getModel();
    if (model && CodeActionProviderRegistry.has(model) && !this._editor.getOption(72)) {
      const supportedActions = [];
      for (const provider of CodeActionProviderRegistry.all(model)) {
        if (Array.isArray(provider.providedCodeActionKinds)) {
          supportedActions.push(...provider.providedCodeActionKinds);
        }
      }
      this._supportedCodeActions.set(supportedActions.join(" "));
      this._codeActionOracle.value = new CodeActionOracle(this._editor, this._markerService, (trigger) => {
        var _a5;
        if (!trigger) {
          this.setState(CodeActionsState.Empty);
          return;
        }
        const actions25 = createCancelablePromise((token) => getCodeActions(model, trigger.selection, trigger.trigger, Progress.None, token));
        if (trigger.trigger.type === 2) {
          (_a5 = this._progressService) === null || _a5 === void 0 ? void 0 : _a5.showWhile(actions25, 250);
        }
        this.setState(new CodeActionsState.Triggered(trigger.trigger, trigger.selection, trigger.position, actions25));
      }, void 0);
      this._codeActionOracle.value.trigger({type: 1});
    } else {
      this._supportedCodeActions.reset();
    }
  }
  trigger(trigger) {
    if (this._codeActionOracle.value) {
      this._codeActionOracle.value.trigger(trigger);
    }
  }
  setState(newState, skipNotify) {
    if (newState === this._state) {
      return;
    }
    if (this._state.type === 1) {
      this._state.actions.cancel();
    }
    this._state = newState;
    if (!skipNotify) {
      this._onDidChangeState.fire(newState);
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionCommands.js
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param6 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function contextKeyForSupportedActions(kind) {
  return ContextKeyExpr.regex(SUPPORTED_CODE_ACTIONS.keys()[0], new RegExp("(\\s|^)" + escapeRegExpCharacters(kind.value) + "\\b"));
}
var argsSchema = {
  type: "object",
  defaultSnippets: [{body: {kind: ""}}],
  properties: {
    kind: {
      type: "string",
      description: localize("args.schema.kind", "Kind of the code action to run.")
    },
    apply: {
      type: "string",
      description: localize("args.schema.apply", "Controls when the returned actions are applied."),
      default: "ifSingle",
      enum: ["first", "ifSingle", "never"],
      enumDescriptions: [
        localize("args.schema.apply.first", "Always apply the first returned code action."),
        localize("args.schema.apply.ifSingle", "Apply the first returned code action if it is the only one."),
        localize("args.schema.apply.never", "Do not apply the returned code actions.")
      ]
    },
    preferred: {
      type: "boolean",
      default: false,
      description: localize("args.schema.preferred", "Controls if only preferred code actions should be returned.")
    }
  }
};
var QuickFixController = class QuickFixController2 extends Disposable {
  constructor(editor3, markerService, contextKeyService, progressService, _instantiationService) {
    super();
    this._instantiationService = _instantiationService;
    this._editor = editor3;
    this._model = this._register(new CodeActionModel(this._editor, markerService, contextKeyService, progressService));
    this._register(this._model.onDidChangeState((newState) => this.update(newState)));
    this._ui = new Lazy(() => this._register(new CodeActionUi(editor3, QuickFixAction.Id, AutoFixAction.Id, {
      applyCodeAction: (action, retrigger) => __awaiter6(this, void 0, void 0, function* () {
        try {
          yield this._applyCodeAction(action);
        } finally {
          if (retrigger) {
            this._trigger({type: 1, filter: {}});
          }
        }
      })
    }, this._instantiationService)));
  }
  static get(editor3) {
    return editor3.getContribution(QuickFixController2.ID);
  }
  update(newState) {
    this._ui.getValue().update(newState);
  }
  showCodeActions(trigger, actions25, at) {
    return this._ui.getValue().showCodeActionList(trigger, actions25, at, {includeDisabledActions: false});
  }
  manualTriggerAtCurrentPosition(notAvailableMessage, filter2, autoApply) {
    if (!this._editor.hasModel()) {
      return;
    }
    MessageController.get(this._editor).closeMessage();
    const triggerPosition = this._editor.getPosition();
    this._trigger({type: 2, filter: filter2, autoApply, context: {notAvailableMessage, position: triggerPosition}});
  }
  _trigger(trigger) {
    return this._model.trigger(trigger);
  }
  _applyCodeAction(action) {
    return this._instantiationService.invokeFunction(applyCodeAction, action, this._editor);
  }
};
QuickFixController.ID = "editor.contrib.quickFixController";
QuickFixController = __decorate6([
  __param6(1, IMarkerService),
  __param6(2, IContextKeyService),
  __param6(3, IEditorProgressService),
  __param6(4, IInstantiationService)
], QuickFixController);
function applyCodeAction(accessor, action, editor3) {
  return __awaiter6(this, void 0, void 0, function* () {
    const bulkEditService = accessor.get(IBulkEditService);
    const commandService = accessor.get(ICommandService);
    const telemetryService = accessor.get(ITelemetryService);
    const notificationService = accessor.get(INotificationService);
    telemetryService.publicLog2("codeAction.applyCodeAction", {
      codeActionTitle: action.title,
      codeActionKind: action.kind,
      codeActionIsPreferred: !!action.isPreferred
    });
    if (action.edit) {
      yield bulkEditService.apply(ResourceEdit.convert(action.edit), {editor: editor3, label: action.title});
    }
    if (action.command) {
      try {
        yield commandService.executeCommand(action.command.id, ...action.command.arguments || []);
      } catch (err) {
        const message = asMessage(err);
        notificationService.error(typeof message === "string" ? message : localize("applyCodeActionFailed", "An unknown error occurred while applying the code action"));
      }
    }
  });
}
function asMessage(err) {
  if (typeof err === "string") {
    return err;
  } else if (err instanceof Error && typeof err.message === "string") {
    return err.message;
  } else {
    return void 0;
  }
}
function triggerCodeActionsForEditorSelection(editor3, notAvailableMessage, filter2, autoApply) {
  if (editor3.hasModel()) {
    const controller = QuickFixController.get(editor3);
    if (controller) {
      controller.manualTriggerAtCurrentPosition(notAvailableMessage, filter2, autoApply);
    }
  }
}
var QuickFixAction = class extends EditorAction {
  constructor() {
    super({
      id: QuickFixAction.Id,
      label: localize("quickfix.trigger.label", "Quick Fix..."),
      alias: "Quick Fix...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 84,
        weight: 100
      }
    });
  }
  run(_accessor, editor3) {
    return triggerCodeActionsForEditorSelection(editor3, localize("editor.action.quickFix.noneMessage", "No code actions available"), void 0, void 0);
  }
};
QuickFixAction.Id = "editor.action.quickFix";
var CodeActionCommand = class extends EditorCommand {
  constructor() {
    super({
      id: codeActionCommandId,
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      description: {
        description: "Trigger a code action",
        args: [{name: "args", schema: argsSchema}]
      }
    });
  }
  runEditorCommand(_accessor, editor3, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind.Empty,
      apply: "ifSingle"
    });
    return triggerCodeActionsForEditorSelection(editor3, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.codeAction.noneMessage.preferred.kind", "No preferred code actions for '{0}' available", userArgs.kind) : localize("editor.action.codeAction.noneMessage.kind", "No code actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.codeAction.noneMessage.preferred", "No preferred code actions available") : localize("editor.action.codeAction.noneMessage", "No code actions available"), {
      include: args.kind,
      includeSourceActions: true,
      onlyIncludePreferredActions: args.preferred
    }, args.apply);
  }
};
var RefactorAction = class extends EditorAction {
  constructor() {
    super({
      id: refactorCommandId,
      label: localize("refactor.label", "Refactor..."),
      alias: "Refactor...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 48,
        mac: {
          primary: 256 | 1024 | 48
        },
        weight: 100
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 2,
        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Refactor))
      },
      description: {
        description: "Refactor...",
        args: [{name: "args", schema: argsSchema}]
      }
    });
  }
  run(_accessor, editor3, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind.Refactor,
      apply: "never"
    });
    return triggerCodeActionsForEditorSelection(editor3, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.refactor.noneMessage.preferred.kind", "No preferred refactorings for '{0}' available", userArgs.kind) : localize("editor.action.refactor.noneMessage.kind", "No refactorings for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.refactor.noneMessage.preferred", "No preferred refactorings available") : localize("editor.action.refactor.noneMessage", "No refactorings available"), {
      include: CodeActionKind.Refactor.contains(args.kind) ? args.kind : CodeActionKind.None,
      onlyIncludePreferredActions: args.preferred
    }, args.apply);
  }
};
var SourceAction = class extends EditorAction {
  constructor() {
    super({
      id: sourceActionCommandId,
      label: localize("source.label", "Source Action..."),
      alias: "Source Action...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      contextMenuOpts: {
        group: "1_modification",
        order: 2.1,
        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Source))
      },
      description: {
        description: "Source Action...",
        args: [{name: "args", schema: argsSchema}]
      }
    });
  }
  run(_accessor, editor3, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind.Source,
      apply: "never"
    });
    return triggerCodeActionsForEditorSelection(editor3, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.source.noneMessage.preferred.kind", "No preferred source actions for '{0}' available", userArgs.kind) : localize("editor.action.source.noneMessage.kind", "No source actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.source.noneMessage.preferred", "No preferred source actions available") : localize("editor.action.source.noneMessage", "No source actions available"), {
      include: CodeActionKind.Source.contains(args.kind) ? args.kind : CodeActionKind.None,
      includeSourceActions: true,
      onlyIncludePreferredActions: args.preferred
    }, args.apply);
  }
};
var OrganizeImportsAction = class extends EditorAction {
  constructor() {
    super({
      id: organizeImportsCommandId,
      label: localize("organizeImports.label", "Organize Imports"),
      alias: "Organize Imports",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceOrganizeImports)),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 45,
        weight: 100
      }
    });
  }
  run(_accessor, editor3) {
    return triggerCodeActionsForEditorSelection(editor3, localize("editor.action.organize.noneMessage", "No organize imports action available"), {include: CodeActionKind.SourceOrganizeImports, includeSourceActions: true}, "ifSingle");
  }
};
var FixAllAction = class extends EditorAction {
  constructor() {
    super({
      id: fixAllCommandId,
      label: localize("fixAll.label", "Fix All"),
      alias: "Fix All",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceFixAll))
    });
  }
  run(_accessor, editor3) {
    return triggerCodeActionsForEditorSelection(editor3, localize("fixAll.noneMessage", "No fix all action available"), {include: CodeActionKind.SourceFixAll, includeSourceActions: true}, "ifSingle");
  }
};
var AutoFixAction = class extends EditorAction {
  constructor() {
    super({
      id: AutoFixAction.Id,
      label: localize("autoFix.label", "Auto Fix..."),
      alias: "Auto Fix...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.QuickFix)),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 84,
        mac: {
          primary: 2048 | 512 | 84
        },
        weight: 100
      }
    });
  }
  run(_accessor, editor3) {
    return triggerCodeActionsForEditorSelection(editor3, localize("editor.action.autoFix.noneMessage", "No auto fixes available"), {
      include: CodeActionKind.QuickFix,
      onlyIncludePreferredActions: true
    }, "ifSingle");
  }
};
AutoFixAction.Id = "editor.action.autoFix";

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionContributions.js
registerEditorContribution(QuickFixController.ID, QuickFixController);
registerEditorAction(QuickFixAction);
registerEditorAction(RefactorAction);
registerEditorAction(SourceAction);
registerEditorAction(OrganizeImportsAction);
registerEditorAction(AutoFixAction);
registerEditorAction(FixAllAction);
registerEditorCommand(new CodeActionCommand());

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelens.js
var CodeLensModel = class {
  constructor() {
    this.lenses = [];
    this._disposables = new DisposableStore();
  }
  dispose() {
    this._disposables.dispose();
  }
  add(list, provider) {
    this._disposables.add(list);
    for (const symbol5 of list.lenses) {
      this.lenses.push({symbol: symbol5, provider});
    }
  }
};
function getCodeLensData(model, token) {
  const provider = CodeLensProviderRegistry.ordered(model);
  const providerRanks = new Map();
  const result = new CodeLensModel();
  const promises = provider.map((provider2, i) => {
    providerRanks.set(provider2, i);
    return Promise.resolve(provider2.provideCodeLenses(model, token)).then((list) => list && result.add(list, provider2)).catch(onUnexpectedExternalError);
  });
  return Promise.all(promises).then(() => {
    result.lenses = mergeSort(result.lenses, (a, b) => {
      if (a.symbol.range.startLineNumber < b.symbol.range.startLineNumber) {
        return -1;
      } else if (a.symbol.range.startLineNumber > b.symbol.range.startLineNumber) {
        return 1;
      } else if (providerRanks.get(a.provider) < providerRanks.get(b.provider)) {
        return -1;
      } else if (providerRanks.get(a.provider) > providerRanks.get(b.provider)) {
        return 1;
      } else if (a.symbol.range.startColumn < b.symbol.range.startColumn) {
        return -1;
      } else if (a.symbol.range.startColumn > b.symbol.range.startColumn) {
        return 1;
      } else {
        return 0;
      }
    });
    return result;
  });
}
registerLanguageCommand("_executeCodeLensProvider", function(accessor, args) {
  let {resource, itemResolveCount} = args;
  if (!(resource instanceof URI)) {
    throw illegalArgument();
  }
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument();
  }
  const result = [];
  const disposables = new DisposableStore();
  return getCodeLensData(model, CancellationToken.None).then((value) => {
    disposables.add(value);
    let resolve = [];
    for (const item of value.lenses) {
      if (typeof itemResolveCount === "undefined" || Boolean(item.symbol.command)) {
        result.push(item.symbol);
      } else if (itemResolveCount-- > 0 && item.provider.resolveCodeLens) {
        resolve.push(Promise.resolve(item.provider.resolveCodeLens(model, item.symbol, CancellationToken.None)).then((symbol5) => result.push(symbol5 || item.symbol)));
      }
    }
    return Promise.all(resolve);
  }).then(() => {
    return result;
  }).finally(() => {
    setTimeout(() => disposables.dispose(), 100);
  });
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelensWidget.js
var CodeLensViewZone = class {
  constructor(afterLineNumber, onHeight) {
    this.afterLineNumber = afterLineNumber;
    this._onHeight = onHeight;
    this.heightInLines = 1;
    this.suppressMouseDown = true;
    this.domNode = document.createElement("div");
  }
  onComputedHeight(height) {
    if (this._lastHeight === void 0) {
      this._lastHeight = height;
    } else if (this._lastHeight !== height) {
      this._lastHeight = height;
      this._onHeight();
    }
  }
};
var CodeLensContentWidget = class {
  constructor(editor3, className, line) {
    this.allowEditorOverflow = false;
    this.suppressMouseDown = true;
    this._commands = new Map();
    this._isEmpty = true;
    this._editor = editor3;
    this._id = `codelens.widget-${CodeLensContentWidget._idPool++}`;
    this.updatePosition(line);
    this._domNode = document.createElement("span");
    this._domNode.className = `codelens-decoration ${className}`;
  }
  withCommands(lenses, animate) {
    this._commands.clear();
    let innerHtml = "";
    let hasSymbol2 = false;
    for (let i = 0; i < lenses.length; i++) {
      const lens = lenses[i];
      if (!lens) {
        continue;
      }
      hasSymbol2 = true;
      if (lens.command) {
        const title = renderCodicons(escape(lens.command.title));
        if (lens.command.id) {
          innerHtml += `<a id=${i}>${title}</a>`;
          this._commands.set(String(i), lens.command);
        } else {
          innerHtml += `<span>${title}</span>`;
        }
        if (i + 1 < lenses.length) {
          innerHtml += "<span>&#160;|&#160;</span>";
        }
      }
    }
    if (!hasSymbol2) {
      this._domNode.innerHTML = "<span>no commands</span>";
    } else {
      if (!innerHtml) {
        innerHtml = "\xA0";
      }
      this._domNode.innerHTML = innerHtml;
      if (this._isEmpty && animate) {
        this._domNode.classList.add("fadein");
      }
      this._isEmpty = false;
    }
  }
  getCommand(link) {
    return link.parentElement === this._domNode ? this._commands.get(link.id) : void 0;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  updatePosition(line) {
    const column = this._editor.getModel().getLineFirstNonWhitespaceColumn(line);
    this._widgetPosition = {
      position: {lineNumber: line, column},
      preference: [1]
    };
  }
  getPosition() {
    return this._widgetPosition || null;
  }
};
CodeLensContentWidget._idPool = 0;
var CodeLensHelper = class {
  constructor() {
    this._removeDecorations = [];
    this._addDecorations = [];
    this._addDecorationsCallbacks = [];
  }
  addDecoration(decoration2, callback) {
    this._addDecorations.push(decoration2);
    this._addDecorationsCallbacks.push(callback);
  }
  removeDecoration(decorationId) {
    this._removeDecorations.push(decorationId);
  }
  commit(changeAccessor) {
    let resultingDecorations = changeAccessor.deltaDecorations(this._removeDecorations, this._addDecorations);
    for (let i = 0, len = resultingDecorations.length; i < len; i++) {
      this._addDecorationsCallbacks[i](resultingDecorations[i]);
    }
  }
};
var CodeLensWidget = class {
  constructor(data, editor3, className, helper, viewZoneChangeAccessor, updateCallback) {
    this._isDisposed = false;
    this._editor = editor3;
    this._className = className;
    this._data = data;
    this._decorationIds = [];
    let range2;
    let lenses = [];
    this._data.forEach((codeLensData, i) => {
      if (codeLensData.symbol.command) {
        lenses.push(codeLensData.symbol);
      }
      helper.addDecoration({
        range: codeLensData.symbol.range,
        options: ModelDecorationOptions.EMPTY
      }, (id) => this._decorationIds[i] = id);
      if (!range2) {
        range2 = Range2.lift(codeLensData.symbol.range);
      } else {
        range2 = Range2.plusRange(range2, codeLensData.symbol.range);
      }
    });
    this._viewZone = new CodeLensViewZone(range2.startLineNumber - 1, updateCallback);
    this._viewZoneId = viewZoneChangeAccessor.addZone(this._viewZone);
    if (lenses.length > 0) {
      this._createContentWidgetIfNecessary();
      this._contentWidget.withCommands(lenses, false);
    }
  }
  _createContentWidgetIfNecessary() {
    if (!this._contentWidget) {
      this._contentWidget = new CodeLensContentWidget(this._editor, this._className, this._viewZone.afterLineNumber + 1);
      this._editor.addContentWidget(this._contentWidget);
    }
  }
  dispose(helper, viewZoneChangeAccessor) {
    this._decorationIds.forEach(helper.removeDecoration, helper);
    this._decorationIds = [];
    if (viewZoneChangeAccessor) {
      viewZoneChangeAccessor.removeZone(this._viewZoneId);
    }
    if (this._contentWidget) {
      this._editor.removeContentWidget(this._contentWidget);
      this._contentWidget = void 0;
    }
    this._isDisposed = true;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isValid() {
    return this._decorationIds.some((id, i) => {
      const range2 = this._editor.getModel().getDecorationRange(id);
      const symbol5 = this._data[i].symbol;
      return !!(range2 && Range2.isEmpty(symbol5.range) === range2.isEmpty());
    });
  }
  updateCodeLensSymbols(data, helper) {
    this._decorationIds.forEach(helper.removeDecoration, helper);
    this._decorationIds = [];
    this._data = data;
    this._data.forEach((codeLensData, i) => {
      helper.addDecoration({
        range: codeLensData.symbol.range,
        options: ModelDecorationOptions.EMPTY
      }, (id) => this._decorationIds[i] = id);
    });
  }
  computeIfNecessary(model) {
    if (!this._viewZone.domNode.hasAttribute("monaco-visible-view-zone")) {
      return null;
    }
    for (let i = 0; i < this._decorationIds.length; i++) {
      const range2 = model.getDecorationRange(this._decorationIds[i]);
      if (range2) {
        this._data[i].symbol.range = range2;
      }
    }
    return this._data;
  }
  updateCommands(symbols) {
    this._createContentWidgetIfNecessary();
    this._contentWidget.withCommands(symbols, true);
    for (let i = 0; i < this._data.length; i++) {
      const resolved = symbols[i];
      if (resolved) {
        const {symbol: symbol5} = this._data[i];
        symbol5.command = resolved.command || symbol5.command;
      }
    }
  }
  getCommand(link) {
    var _a5;
    return (_a5 = this._contentWidget) === null || _a5 === void 0 ? void 0 : _a5.getCommand(link);
  }
  getLineNumber() {
    const range2 = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
    if (range2) {
      return range2.startLineNumber;
    }
    return -1;
  }
  update(viewZoneChangeAccessor) {
    if (this.isValid()) {
      const range2 = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
      if (range2) {
        this._viewZone.afterLineNumber = range2.startLineNumber - 1;
        viewZoneChangeAccessor.layoutZone(this._viewZoneId);
        if (this._contentWidget) {
          this._contentWidget.updatePosition(range2.startLineNumber);
          this._editor.layoutContentWidget(this._contentWidget);
        }
      }
    }
  }
  getItems() {
    return this._data;
  }
};
registerThemingParticipant((theme6, collector) => {
  const codeLensForeground = theme6.getColor(editorCodeLensForeground);
  if (codeLensForeground) {
    collector.addRule(`.monaco-editor .codelens-decoration { color: ${codeLensForeground}; }`);
    collector.addRule(`.monaco-editor .codelens-decoration .codicon { color: ${codeLensForeground}; }`);
  }
  const activeLinkForeground = theme6.getColor(editorActiveLinkForeground);
  if (activeLinkForeground) {
    collector.addRule(`.monaco-editor .codelens-decoration > a:hover { color: ${activeLinkForeground} !important; }`);
    collector.addRule(`.monaco-editor .codelens-decoration > a:hover .codicon { color: ${activeLinkForeground} !important; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codeLensCache.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ICodeLensCache = createDecorator("ICodeLensCache");
var CacheItem = class {
  constructor(lineCount, data) {
    this.lineCount = lineCount;
    this.data = data;
  }
};
var CodeLensCache = class CodeLensCache2 {
  constructor(storageService) {
    this._fakeProvider = new class {
      provideCodeLenses() {
        throw new Error("not supported");
      }
    }();
    this._cache = new LRUCache(20, 0.75);
    const oldkey = "codelens/cache";
    runWhenIdle(() => storageService.remove(oldkey, 1));
    const key = "codelens/cache2";
    const raw = storageService.get(key, 1, "{}");
    this._deserialize(raw);
    once(storageService.onWillSaveState)((e) => {
      if (e.reason === WillSaveStateReason.SHUTDOWN) {
        storageService.store(key, this._serialize(), 1);
      }
    });
  }
  put(model, data) {
    const copyItems = data.lenses.map((item2) => {
      var _a5;
      return {
        range: item2.symbol.range,
        command: item2.symbol.command && {id: "", title: (_a5 = item2.symbol.command) === null || _a5 === void 0 ? void 0 : _a5.title}
      };
    });
    const copyModel = new CodeLensModel();
    copyModel.add({lenses: copyItems, dispose: () => {
    }}, this._fakeProvider);
    const item = new CacheItem(model.getLineCount(), copyModel);
    this._cache.set(model.uri.toString(), item);
  }
  get(model) {
    const item = this._cache.get(model.uri.toString());
    return item && item.lineCount === model.getLineCount() ? item.data : void 0;
  }
  delete(model) {
    this._cache.delete(model.uri.toString());
  }
  _serialize() {
    const data = Object.create(null);
    for (const [key, value] of this._cache) {
      const lines = new Set();
      for (const d of value.data.lenses) {
        lines.add(d.symbol.range.startLineNumber);
      }
      data[key] = {
        lineCount: value.lineCount,
        lines: [...lines.values()]
      };
    }
    return JSON.stringify(data);
  }
  _deserialize(raw) {
    try {
      const data = JSON.parse(raw);
      for (const key in data) {
        const element = data[key];
        const lenses = [];
        for (const line of element.lines) {
          lenses.push({range: new Range2(line, 1, line, 11)});
        }
        const model = new CodeLensModel();
        model.add({lenses, dispose() {
        }}, this._fakeProvider);
        this._cache.set(key, new CacheItem(element.lineCount, model));
      }
    } catch (_a5) {
    }
  }
};
CodeLensCache = __decorate7([
  __param7(0, IStorageService)
], CodeLensCache);
registerSingleton(ICodeLensCache, CodeLensCache);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelensController.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CodeLensContribution = class CodeLensContribution2 {
  constructor(_editor, _commandService, _notificationService, _codeLensCache) {
    this._editor = _editor;
    this._commandService = _commandService;
    this._notificationService = _notificationService;
    this._codeLensCache = _codeLensCache;
    this._globalToDispose = new DisposableStore();
    this._localToDispose = new DisposableStore();
    this._lenses = [];
    this._oldCodeLensModels = new DisposableStore();
    this._modelChangeCounter = 0;
    this._isEnabled = this._editor.getOption(11);
    this._globalToDispose.add(this._editor.onDidChangeModel(() => this._onModelChange()));
    this._globalToDispose.add(this._editor.onDidChangeModelLanguage(() => this._onModelChange()));
    this._globalToDispose.add(this._editor.onDidChangeConfiguration(() => {
      const prevIsEnabled = this._isEnabled;
      this._isEnabled = this._editor.getOption(11);
      if (prevIsEnabled !== this._isEnabled) {
        this._onModelChange();
      }
    }));
    this._globalToDispose.add(CodeLensProviderRegistry.onDidChange(this._onModelChange, this));
    this._globalToDispose.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(36)) {
        this._updateLensStyle();
      }
    }));
    this._onModelChange();
    this._styleClassName = "_" + hash(this._editor.getId()).toString(16);
    this._styleElement = createStyleSheet(isInShadowDOM(this._editor.getContainerDomNode()) ? this._editor.getContainerDomNode() : void 0);
    this._updateLensStyle();
  }
  dispose() {
    this._localDispose();
    this._globalToDispose.dispose();
    this._oldCodeLensModels.dispose();
    dispose(this._currentCodeLensModel);
  }
  _updateLensStyle() {
    const options = this._editor.getOptions();
    const fontInfo = options.get(36);
    const lineHeight = options.get(51);
    const height = Math.round(lineHeight * 1.1);
    const fontSize = Math.round(fontInfo.fontSize * 0.9);
    const newStyle = `
		.monaco-editor .codelens-decoration.${this._styleClassName} { height: ${height}px; line-height: ${lineHeight}px; font-size: ${fontSize}px; padding-right: ${Math.round(fontInfo.fontSize * 0.45)}px;}
		.monaco-editor .codelens-decoration.${this._styleClassName} > a > .codicon { line-height: ${lineHeight}px; font-size: ${fontSize}px; }
		`;
    this._styleElement.textContent = newStyle;
  }
  _localDispose() {
    if (this._currentFindCodeLensSymbolsPromise) {
      this._currentFindCodeLensSymbolsPromise.cancel();
      this._currentFindCodeLensSymbolsPromise = void 0;
      this._modelChangeCounter++;
    }
    if (this._currentResolveCodeLensSymbolsPromise) {
      this._currentResolveCodeLensSymbolsPromise.cancel();
      this._currentResolveCodeLensSymbolsPromise = void 0;
    }
    this._localToDispose.clear();
    this._oldCodeLensModels.clear();
    dispose(this._currentCodeLensModel);
  }
  _onModelChange() {
    this._localDispose();
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    if (!this._isEnabled) {
      return;
    }
    const cachedLenses = this._codeLensCache.get(model);
    if (cachedLenses) {
      this._renderCodeLensSymbols(cachedLenses);
    }
    if (!CodeLensProviderRegistry.has(model)) {
      if (cachedLenses) {
        this._localToDispose.add(disposableTimeout(() => {
          const cachedLensesNow = this._codeLensCache.get(model);
          if (cachedLenses === cachedLensesNow) {
            this._codeLensCache.delete(model);
            this._onModelChange();
          }
        }, 30 * 1e3));
      }
      return;
    }
    for (const provider of CodeLensProviderRegistry.all(model)) {
      if (typeof provider.onDidChange === "function") {
        let registration = provider.onDidChange(() => scheduler.schedule());
        this._localToDispose.add(registration);
      }
    }
    const detectVisibleLenses = this._detectVisibleLenses = new RunOnceScheduler(() => this._onViewportChanged(), 250);
    const scheduler = new RunOnceScheduler(() => {
      const counterValue = ++this._modelChangeCounter;
      if (this._currentFindCodeLensSymbolsPromise) {
        this._currentFindCodeLensSymbolsPromise.cancel();
      }
      this._currentFindCodeLensSymbolsPromise = createCancelablePromise((token) => getCodeLensData(model, token));
      this._currentFindCodeLensSymbolsPromise.then((result) => {
        if (counterValue === this._modelChangeCounter) {
          if (this._currentCodeLensModel) {
            this._oldCodeLensModels.add(this._currentCodeLensModel);
          }
          this._currentCodeLensModel = result;
          this._codeLensCache.put(model, result);
          this._renderCodeLensSymbols(result);
          detectVisibleLenses.schedule();
        }
      }, onUnexpectedError);
    }, 250);
    this._localToDispose.add(scheduler);
    this._localToDispose.add(detectVisibleLenses);
    this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      this._editor.changeDecorations((decorationsAccessor) => {
        this._editor.changeViewZones((viewZonesAccessor) => {
          let toDispose = [];
          let lastLensLineNumber = -1;
          this._lenses.forEach((lens) => {
            if (!lens.isValid() || lastLensLineNumber === lens.getLineNumber()) {
              toDispose.push(lens);
            } else {
              lens.update(viewZonesAccessor);
              lastLensLineNumber = lens.getLineNumber();
            }
          });
          let helper = new CodeLensHelper();
          toDispose.forEach((l) => {
            l.dispose(helper, viewZonesAccessor);
            this._lenses.splice(this._lenses.indexOf(l), 1);
          });
          helper.commit(decorationsAccessor);
        });
      });
      detectVisibleLenses.schedule();
      scheduler.schedule();
    }));
    this._localToDispose.add(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged && this._lenses.length > 0) {
        detectVisibleLenses.schedule();
      }
    }));
    this._localToDispose.add(this._editor.onDidLayoutChange(() => {
      detectVisibleLenses.schedule();
    }));
    this._localToDispose.add(toDisposable(() => {
      if (this._editor.getModel()) {
        const scrollState = StableEditorScrollState.capture(this._editor);
        this._editor.changeDecorations((decorationsAccessor) => {
          this._editor.changeViewZones((viewZonesAccessor) => {
            this._disposeAllLenses(decorationsAccessor, viewZonesAccessor);
          });
        });
        scrollState.restore(this._editor);
      } else {
        this._disposeAllLenses(void 0, void 0);
      }
    }));
    this._localToDispose.add(this._editor.onMouseUp((e) => {
      if (e.target.type !== 9) {
        return;
      }
      let target = e.target.element;
      if ((target === null || target === void 0 ? void 0 : target.tagName) === "SPAN") {
        target = target.parentElement;
      }
      if ((target === null || target === void 0 ? void 0 : target.tagName) === "A") {
        for (const lens of this._lenses) {
          let command = lens.getCommand(target);
          if (command) {
            this._commandService.executeCommand(command.id, ...command.arguments || []).catch((err) => this._notificationService.error(err));
            break;
          }
        }
      }
    }));
    scheduler.schedule();
  }
  _disposeAllLenses(decChangeAccessor, viewZoneChangeAccessor) {
    const helper = new CodeLensHelper();
    for (const lens of this._lenses) {
      lens.dispose(helper, viewZoneChangeAccessor);
    }
    if (decChangeAccessor) {
      helper.commit(decChangeAccessor);
    }
    this._lenses = [];
  }
  _renderCodeLensSymbols(symbols) {
    if (!this._editor.hasModel()) {
      return;
    }
    let maxLineNumber = this._editor.getModel().getLineCount();
    let groups = [];
    let lastGroup;
    for (let symbol5 of symbols.lenses) {
      let line = symbol5.symbol.range.startLineNumber;
      if (line < 1 || line > maxLineNumber) {
        continue;
      } else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {
        lastGroup.push(symbol5);
      } else {
        lastGroup = [symbol5];
        groups.push(lastGroup);
      }
    }
    const scrollState = StableEditorScrollState.capture(this._editor);
    this._editor.changeDecorations((decorationsAccessor) => {
      this._editor.changeViewZones((viewZoneAccessor) => {
        const helper = new CodeLensHelper();
        let codeLensIndex = 0;
        let groupsIndex = 0;
        while (groupsIndex < groups.length && codeLensIndex < this._lenses.length) {
          let symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;
          let codeLensLineNumber = this._lenses[codeLensIndex].getLineNumber();
          if (codeLensLineNumber < symbolsLineNumber) {
            this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
            this._lenses.splice(codeLensIndex, 1);
          } else if (codeLensLineNumber === symbolsLineNumber) {
            this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);
            groupsIndex++;
            codeLensIndex++;
          } else {
            this._lenses.splice(codeLensIndex, 0, new CodeLensWidget(groups[groupsIndex], this._editor, this._styleClassName, helper, viewZoneAccessor, () => this._detectVisibleLenses && this._detectVisibleLenses.schedule()));
            codeLensIndex++;
            groupsIndex++;
          }
        }
        while (codeLensIndex < this._lenses.length) {
          this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
          this._lenses.splice(codeLensIndex, 1);
        }
        while (groupsIndex < groups.length) {
          this._lenses.push(new CodeLensWidget(groups[groupsIndex], this._editor, this._styleClassName, helper, viewZoneAccessor, () => this._detectVisibleLenses && this._detectVisibleLenses.schedule()));
          groupsIndex++;
        }
        helper.commit(decorationsAccessor);
      });
    });
    scrollState.restore(this._editor);
  }
  _onViewportChanged() {
    if (this._currentResolveCodeLensSymbolsPromise) {
      this._currentResolveCodeLensSymbolsPromise.cancel();
      this._currentResolveCodeLensSymbolsPromise = void 0;
    }
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    const toResolve = [];
    const lenses = [];
    this._lenses.forEach((lens) => {
      const request = lens.computeIfNecessary(model);
      if (request) {
        toResolve.push(request);
        lenses.push(lens);
      }
    });
    if (toResolve.length === 0) {
      return;
    }
    const resolvePromise2 = createCancelablePromise((token) => {
      const promises = toResolve.map((request, i) => {
        const resolvedSymbols = new Array(request.length);
        const promises2 = request.map((request2, i2) => {
          if (!request2.symbol.command && typeof request2.provider.resolveCodeLens === "function") {
            return Promise.resolve(request2.provider.resolveCodeLens(model, request2.symbol, token)).then((symbol5) => {
              resolvedSymbols[i2] = symbol5;
            }, onUnexpectedExternalError);
          } else {
            resolvedSymbols[i2] = request2.symbol;
            return Promise.resolve(void 0);
          }
        });
        return Promise.all(promises2).then(() => {
          if (!token.isCancellationRequested && !lenses[i].isDisposed()) {
            lenses[i].updateCommands(resolvedSymbols);
          }
        });
      });
      return Promise.all(promises);
    });
    this._currentResolveCodeLensSymbolsPromise = resolvePromise2;
    this._currentResolveCodeLensSymbolsPromise.then(() => {
      if (this._currentCodeLensModel) {
        this._codeLensCache.put(model, this._currentCodeLensModel);
      }
      this._oldCodeLensModels.clear();
      if (resolvePromise2 === this._currentResolveCodeLensSymbolsPromise) {
        this._currentResolveCodeLensSymbolsPromise = void 0;
      }
    }, (err) => {
      onUnexpectedError(err);
      if (resolvePromise2 === this._currentResolveCodeLensSymbolsPromise) {
        this._currentResolveCodeLensSymbolsPromise = void 0;
      }
    });
  }
  getLenses() {
    return this._lenses;
  }
};
CodeLensContribution.ID = "css.editor.codeLens";
CodeLensContribution = __decorate8([
  __param8(1, ICommandService),
  __param8(2, INotificationService),
  __param8(3, ICodeLensCache)
], CodeLensContribution);
registerEditorContribution(CodeLensContribution.ID, CodeLensContribution);
registerEditorAction(class ShowLensesInCurrentLine extends EditorAction {
  constructor() {
    super({
      id: "codelens.showLensesInCurrentLine",
      precondition: EditorContextKeys.hasCodeLensProvider,
      label: localize("showLensOnLine", "Show CodeLens Commands For Current Line"),
      alias: "Show CodeLens Commands For Current Line"
    });
  }
  run(accessor, editor3) {
    return __awaiter7(this, void 0, void 0, function* () {
      if (!editor3.hasModel()) {
        return;
      }
      const quickInputService = accessor.get(IQuickInputService);
      const commandService = accessor.get(ICommandService);
      const notificationService = accessor.get(INotificationService);
      const lineNumber = editor3.getSelection().positionLineNumber;
      const codelensController = editor3.getContribution(CodeLensContribution.ID);
      const items = [];
      for (let lens of codelensController.getLenses()) {
        if (lens.getLineNumber() === lineNumber) {
          for (let item2 of lens.getItems()) {
            const {command} = item2.symbol;
            if (command) {
              items.push({
                label: command.title,
                command
              });
            }
          }
        }
      }
      if (items.length === 0) {
        return;
      }
      const item = yield quickInputService.pick(items, {canPickMany: false});
      if (!item) {
        return;
      }
      try {
        yield commandService.executeCommand(item.command.id, ...item.command.arguments || []);
      } catch (err) {
        notificationService.error(err);
      }
    });
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/color.js
function getColors(model, token) {
  const colors6 = [];
  const providers = ColorProviderRegistry.ordered(model).reverse();
  const promises = providers.map((provider) => Promise.resolve(provider.provideDocumentColors(model, token)).then((result) => {
    if (Array.isArray(result)) {
      for (let colorInfo of result) {
        colors6.push({colorInfo, provider});
      }
    }
  }));
  return Promise.all(promises).then(() => colors6);
}
function getColorPresentations(model, colorInfo, provider, token) {
  return Promise.resolve(provider.provideColorPresentations(model, colorInfo, token));
}
registerLanguageCommand("_executeDocumentColorProvider", function(accessor, args) {
  const {resource} = args;
  if (!(resource instanceof URI)) {
    throw illegalArgument();
  }
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument();
  }
  const rawCIs = [];
  const providers = ColorProviderRegistry.ordered(model).reverse();
  const promises = providers.map((provider) => Promise.resolve(provider.provideDocumentColors(model, CancellationToken.None)).then((result) => {
    if (Array.isArray(result)) {
      for (let ci of result) {
        rawCIs.push({range: ci.range, color: [ci.color.red, ci.color.green, ci.color.blue, ci.color.alpha]});
      }
    }
  }));
  return Promise.all(promises).then(() => rawCIs);
});
registerLanguageCommand("_executeColorPresentationProvider", function(accessor, args) {
  const {resource, color, range: range2} = args;
  if (!(resource instanceof URI) || !Array.isArray(color) || color.length !== 4 || !Range2.isIRange(range2)) {
    throw illegalArgument();
  }
  const [red, green, blue, alpha] = color;
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument();
  }
  const colorInfo = {
    range: range2,
    color: {red, green, blue, alpha}
  };
  const presentations = [];
  const providers = ColorProviderRegistry.ordered(model).reverse();
  const promises = providers.map((provider) => Promise.resolve(provider.provideColorPresentations(model, colorInfo, CancellationToken.None)).then((result) => {
    if (Array.isArray(result)) {
      presentations.push(...result);
    }
  }));
  return Promise.all(promises).then(() => presentations);
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorDetector.js
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MAX_DECORATORS = 500;
var ColorDetector = class ColorDetector2 extends Disposable {
  constructor(_editor, _codeEditorService, _configurationService) {
    super();
    this._editor = _editor;
    this._codeEditorService = _codeEditorService;
    this._configurationService = _configurationService;
    this._localToDispose = this._register(new DisposableStore());
    this._decorationsIds = [];
    this._colorDatas = new Map();
    this._colorDecoratorIds = [];
    this._decorationsTypes = new Set();
    this._register(_editor.onDidChangeModel((e) => {
      this._isEnabled = this.isEnabled();
      this.onModelChanged();
    }));
    this._register(_editor.onDidChangeModelLanguage((e) => this.onModelChanged()));
    this._register(ColorProviderRegistry.onDidChange((e) => this.onModelChanged()));
    this._register(_editor.onDidChangeConfiguration((e) => {
      let prevIsEnabled = this._isEnabled;
      this._isEnabled = this.isEnabled();
      if (prevIsEnabled !== this._isEnabled) {
        if (this._isEnabled) {
          this.onModelChanged();
        } else {
          this.removeAllDecorations();
        }
      }
    }));
    this._timeoutTimer = null;
    this._computePromise = null;
    this._isEnabled = this.isEnabled();
    this.onModelChanged();
  }
  isEnabled() {
    const model = this._editor.getModel();
    if (!model) {
      return false;
    }
    const languageId = model.getLanguageIdentifier();
    const deprecatedConfig = this._configurationService.getValue(languageId.language);
    if (deprecatedConfig) {
      const colorDecorators = deprecatedConfig["colorDecorators"];
      if (colorDecorators && colorDecorators["enable"] !== void 0 && !colorDecorators["enable"]) {
        return colorDecorators["enable"];
      }
    }
    return this._editor.getOption(12);
  }
  static get(editor3) {
    return editor3.getContribution(this.ID);
  }
  dispose() {
    this.stop();
    this.removeAllDecorations();
    super.dispose();
  }
  onModelChanged() {
    this.stop();
    if (!this._isEnabled) {
      return;
    }
    const model = this._editor.getModel();
    if (!model || !ColorProviderRegistry.has(model)) {
      return;
    }
    this._localToDispose.add(this._editor.onDidChangeModelContent((e) => {
      if (!this._timeoutTimer) {
        this._timeoutTimer = new TimeoutTimer();
        this._timeoutTimer.cancelAndSet(() => {
          this._timeoutTimer = null;
          this.beginCompute();
        }, ColorDetector2.RECOMPUTE_TIME);
      }
    }));
    this.beginCompute();
  }
  beginCompute() {
    this._computePromise = createCancelablePromise((token) => {
      const model = this._editor.getModel();
      if (!model) {
        return Promise.resolve([]);
      }
      return getColors(model, token);
    });
    this._computePromise.then((colorInfos) => {
      this.updateDecorations(colorInfos);
      this.updateColorDecorators(colorInfos);
      this._computePromise = null;
    }, onUnexpectedError);
  }
  stop() {
    if (this._timeoutTimer) {
      this._timeoutTimer.cancel();
      this._timeoutTimer = null;
    }
    if (this._computePromise) {
      this._computePromise.cancel();
      this._computePromise = null;
    }
    this._localToDispose.clear();
  }
  updateDecorations(colorDatas) {
    const decorations = colorDatas.map((c) => ({
      range: {
        startLineNumber: c.colorInfo.range.startLineNumber,
        startColumn: c.colorInfo.range.startColumn,
        endLineNumber: c.colorInfo.range.endLineNumber,
        endColumn: c.colorInfo.range.endColumn
      },
      options: ModelDecorationOptions.EMPTY
    }));
    this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, decorations);
    this._colorDatas = new Map();
    this._decorationsIds.forEach((id, i) => this._colorDatas.set(id, colorDatas[i]));
  }
  updateColorDecorators(colorData) {
    let decorations = [];
    let newDecorationsTypes = {};
    for (let i = 0; i < colorData.length && decorations.length < MAX_DECORATORS; i++) {
      const {red, green, blue, alpha} = colorData[i].colorInfo.color;
      const rgba2 = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
      let subKey = hash(`rgba(${rgba2.r},${rgba2.g},${rgba2.b},${rgba2.a})`).toString(16);
      let color = `rgba(${rgba2.r}, ${rgba2.g}, ${rgba2.b}, ${rgba2.a})`;
      let key = "colorBox-" + subKey;
      if (!this._decorationsTypes.has(key) && !newDecorationsTypes[key]) {
        this._codeEditorService.registerDecorationType(key, {
          before: {
            contentText: " ",
            border: "solid 0.1em #000",
            margin: "0.1em 0.2em 0 0.2em",
            width: "0.8em",
            height: "0.8em",
            backgroundColor: color
          },
          dark: {
            before: {
              border: "solid 0.1em #eee"
            }
          }
        }, void 0, this._editor);
      }
      newDecorationsTypes[key] = true;
      decorations.push({
        range: {
          startLineNumber: colorData[i].colorInfo.range.startLineNumber,
          startColumn: colorData[i].colorInfo.range.startColumn,
          endLineNumber: colorData[i].colorInfo.range.endLineNumber,
          endColumn: colorData[i].colorInfo.range.endColumn
        },
        options: this._codeEditorService.resolveDecorationOptions(key, true)
      });
    }
    this._decorationsTypes.forEach((subType) => {
      if (!newDecorationsTypes[subType]) {
        this._codeEditorService.removeDecorationType(subType);
      }
    });
    this._colorDecoratorIds = this._editor.deltaDecorations(this._colorDecoratorIds, decorations);
  }
  removeAllDecorations() {
    this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, []);
    this._colorDecoratorIds = this._editor.deltaDecorations(this._colorDecoratorIds, []);
    this._decorationsTypes.forEach((subType) => {
      this._codeEditorService.removeDecorationType(subType);
    });
  }
  getColorData(position) {
    const model = this._editor.getModel();
    if (!model) {
      return null;
    }
    const decorations = model.getDecorationsInRange(Range2.fromPositions(position, position)).filter((d) => this._colorDatas.has(d.id));
    if (decorations.length === 0) {
      return null;
    }
    return this._colorDatas.get(decorations[0].id);
  }
};
ColorDetector.ID = "editor.contrib.colorDetector";
ColorDetector.RECOMPUTE_TIME = 1e3;
ColorDetector = __decorate9([
  __param9(1, ICodeEditorService),
  __param9(2, IConfigurationService)
], ColorDetector);
registerEditorContribution(ColorDetector.ID, ColorDetector);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/comment/blockCommentCommand.js
var BlockCommentCommand = class {
  constructor(selection, insertSpace) {
    this._selection = selection;
    this._insertSpace = insertSpace;
    this._usedEndToken = null;
  }
  static _haystackHasNeedleAtOffset(haystack, needle, offset) {
    if (offset < 0) {
      return false;
    }
    const needleLength = needle.length;
    const haystackLength = haystack.length;
    if (offset + needleLength > haystackLength) {
      return false;
    }
    for (let i = 0; i < needleLength; i++) {
      const codeA = haystack.charCodeAt(offset + i);
      const codeB = needle.charCodeAt(i);
      if (codeA === codeB) {
        continue;
      }
      if (codeA >= 65 && codeA <= 90 && codeA + 32 === codeB) {
        continue;
      }
      if (codeB >= 65 && codeB <= 90 && codeB + 32 === codeA) {
        continue;
      }
      return false;
    }
    return true;
  }
  _createOperationsForBlockComment(selection, startToken, endToken, insertSpace, model, builder) {
    const startLineNumber = selection.startLineNumber;
    const startColumn = selection.startColumn;
    const endLineNumber = selection.endLineNumber;
    const endColumn = selection.endColumn;
    const startLineText = model.getLineContent(startLineNumber);
    const endLineText = model.getLineContent(endLineNumber);
    let startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);
    let endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      if (startLineNumber === endLineNumber) {
        const lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);
        if (lineBetweenTokens.indexOf(endToken) >= 0) {
          startTokenIndex = -1;
          endTokenIndex = -1;
        }
      } else {
        const startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);
        const endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);
        if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {
          startTokenIndex = -1;
          endTokenIndex = -1;
        }
      }
    }
    let ops;
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      if (insertSpace && startTokenIndex + startToken.length < startLineText.length && startLineText.charCodeAt(startTokenIndex + startToken.length) === 32) {
        startToken = startToken + " ";
      }
      if (insertSpace && endTokenIndex > 0 && endLineText.charCodeAt(endTokenIndex - 1) === 32) {
        endToken = " " + endToken;
        endTokenIndex -= 1;
      }
      ops = BlockCommentCommand._createRemoveBlockCommentOperations(new Range2(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
    } else {
      ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken, this._insertSpace);
      this._usedEndToken = ops.length === 1 ? endToken : null;
    }
    for (const op of ops) {
      builder.addTrackedEditOperation(op.range, op.text);
    }
  }
  static _createRemoveBlockCommentOperations(r, startToken, endToken) {
    let res = [];
    if (!Range2.isEmpty(r)) {
      res.push(EditOperation.delete(new Range2(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));
      res.push(EditOperation.delete(new Range2(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));
    } else {
      res.push(EditOperation.delete(new Range2(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));
    }
    return res;
  }
  static _createAddBlockCommentOperations(r, startToken, endToken, insertSpace) {
    let res = [];
    if (!Range2.isEmpty(r)) {
      res.push(EditOperation.insert(new Position(r.startLineNumber, r.startColumn), startToken + (insertSpace ? " " : "")));
      res.push(EditOperation.insert(new Position(r.endLineNumber, r.endColumn), (insertSpace ? " " : "") + endToken));
    } else {
      res.push(EditOperation.replace(new Range2(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + "  " + endToken));
    }
    return res;
  }
  getEditOperations(model, builder) {
    const startLineNumber = this._selection.startLineNumber;
    const startColumn = this._selection.startColumn;
    model.tokenizeIfCheap(startLineNumber);
    const languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);
    const config = LanguageConfigurationRegistry.getComments(languageId);
    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
      return;
    }
    this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, this._insertSpace, model, builder);
  }
  computeCursorState(model, helper) {
    const inverseEditOperations = helper.getInverseEditOperations();
    if (inverseEditOperations.length === 2) {
      const startTokenEditOperation = inverseEditOperations[0];
      const endTokenEditOperation = inverseEditOperations[1];
      return new Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);
    } else {
      const srcRange = inverseEditOperations[0].range;
      const deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0;
      return new Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/comment/lineCommentCommand.js
var LineCommentCommand = class {
  constructor(selection, tabSize, type, insertSpace, ignoreEmptyLines) {
    this._selection = selection;
    this._tabSize = tabSize;
    this._type = type;
    this._insertSpace = insertSpace;
    this._selectionId = null;
    this._deltaColumn = 0;
    this._moveEndPositionDown = false;
    this._ignoreEmptyLines = ignoreEmptyLines;
  }
  static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber) {
    model.tokenizeIfCheap(startLineNumber);
    const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);
    const config = LanguageConfigurationRegistry.getComments(languageId);
    const commentStr = config ? config.lineCommentToken : null;
    if (!commentStr) {
      return null;
    }
    let lines = [];
    for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {
      lines[i] = {
        ignore: false,
        commentStr,
        commentStrOffset: 0,
        commentStrLength: commentStr.length
      };
    }
    return lines;
  }
  static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines) {
    let onlyWhitespaceLines = true;
    let shouldRemoveComments;
    if (type === 0) {
      shouldRemoveComments = true;
    } else if (type === 1) {
      shouldRemoveComments = false;
    } else {
      shouldRemoveComments = true;
    }
    for (let i = 0, lineCount = lines.length; i < lineCount; i++) {
      const lineData = lines[i];
      const lineNumber = startLineNumber + i;
      const lineContent = model.getLineContent(lineNumber);
      const lineContentStartOffset = firstNonWhitespaceIndex(lineContent);
      if (lineContentStartOffset === -1) {
        lineData.ignore = ignoreEmptyLines;
        lineData.commentStrOffset = lineContent.length;
        continue;
      }
      onlyWhitespaceLines = false;
      lineData.ignore = false;
      lineData.commentStrOffset = lineContentStartOffset;
      if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {
        if (type === 0) {
          shouldRemoveComments = false;
        } else if (type === 1) {
        } else {
          lineData.ignore = true;
        }
      }
      if (shouldRemoveComments && insertSpace) {
        const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;
        if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32) {
          lineData.commentStrLength += 1;
        }
      }
    }
    if (type === 0 && onlyWhitespaceLines) {
      shouldRemoveComments = false;
      for (let i = 0, lineCount = lines.length; i < lineCount; i++) {
        lines[i].ignore = false;
      }
    }
    return {
      supported: true,
      shouldRemoveComments,
      lines
    };
  }
  static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines) {
    const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);
    if (lines === null) {
      return {
        supported: false
      };
    }
    return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines);
  }
  _executeLineComments(model, builder, data, s) {
    let ops;
    if (data.shouldRemoveComments) {
      ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);
    } else {
      LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);
      ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);
    }
    const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);
    for (let i = 0, len = ops.length; i < len; i++) {
      builder.addEditOperation(ops[i].range, ops[i].text);
      if (Range2.isEmpty(ops[i].range) && Range2.getStartPosition(ops[i].range).equals(cursorPosition)) {
        const lineContent = model.getLineContent(cursorPosition.lineNumber);
        if (lineContent.length + 1 === cursorPosition.column) {
          this._deltaColumn = (ops[i].text || "").length;
        }
      }
    }
    this._selectionId = builder.trackSelection(s);
  }
  _attemptRemoveBlockComment(model, s, startToken, endToken) {
    let startLineNumber = s.startLineNumber;
    let endLineNumber = s.endLineNumber;
    let startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);
    let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);
    let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);
    if (startTokenIndex !== -1 && endTokenIndex === -1) {
      endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
      endLineNumber = startLineNumber;
    }
    if (startTokenIndex === -1 && endTokenIndex !== -1) {
      startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);
      startLineNumber = endLineNumber;
    }
    if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {
      startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);
      if (startTokenIndex !== -1) {
        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
      }
    }
    if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32) {
      startToken += " ";
    }
    if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32) {
      endToken = " " + endToken;
      endTokenIndex -= 1;
    }
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      return BlockCommentCommand._createRemoveBlockCommentOperations(new Range2(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
    }
    return null;
  }
  _executeBlockComment(model, builder, s) {
    model.tokenizeIfCheap(s.startLineNumber);
    let languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);
    let config = LanguageConfigurationRegistry.getComments(languageId);
    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
      return;
    }
    const startToken = config.blockCommentStartToken;
    const endToken = config.blockCommentEndToken;
    let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);
    if (!ops) {
      if (s.isEmpty()) {
        const lineContent = model.getLineContent(s.startLineNumber);
        let firstNonWhitespaceIndex2 = firstNonWhitespaceIndex(lineContent);
        if (firstNonWhitespaceIndex2 === -1) {
          firstNonWhitespaceIndex2 = lineContent.length;
        }
        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range2(s.startLineNumber, firstNonWhitespaceIndex2 + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);
      } else {
        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range2(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);
      }
      if (ops.length === 1) {
        this._deltaColumn = startToken.length + 1;
      }
    }
    this._selectionId = builder.trackSelection(s);
    for (const op of ops) {
      builder.addEditOperation(op.range, op.text);
    }
  }
  getEditOperations(model, builder) {
    let s = this._selection;
    this._moveEndPositionDown = false;
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._moveEndPositionDown = true;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines);
    if (data.supported) {
      return this._executeLineComments(model, builder, data, s);
    }
    return this._executeBlockComment(model, builder, s);
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._moveEndPositionDown) {
      result = result.setEndPosition(result.endLineNumber + 1, 1);
    }
    return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);
  }
  static _createRemoveLineCommentsOperations(lines, startLineNumber) {
    let res = [];
    for (let i = 0, len = lines.length; i < len; i++) {
      const lineData = lines[i];
      if (lineData.ignore) {
        continue;
      }
      res.push(EditOperation.delete(new Range2(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));
    }
    return res;
  }
  _createAddLineCommentsOperations(lines, startLineNumber) {
    let res = [];
    const afterCommentStr = this._insertSpace ? " " : "";
    for (let i = 0, len = lines.length; i < len; i++) {
      const lineData = lines[i];
      if (lineData.ignore) {
        continue;
      }
      res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));
    }
    return res;
  }
  static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {
    if (isTab) {
      return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);
    }
    return currentVisibleColumn + columnSize;
  }
  static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {
    let minVisibleColumn = 1073741824;
    let j;
    let lenJ;
    for (let i = 0, len = lines.length; i < len; i++) {
      if (lines[i].ignore) {
        continue;
      }
      const lineContent = model.getLineContent(startLineNumber + i);
      let currentVisibleColumn = 0;
      for (let j2 = 0, lenJ2 = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j2 < lenJ2; j2++) {
        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j2) === 9, 1);
      }
      if (currentVisibleColumn < minVisibleColumn) {
        minVisibleColumn = currentVisibleColumn;
      }
    }
    minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;
    for (let i = 0, len = lines.length; i < len; i++) {
      if (lines[i].ignore) {
        continue;
      }
      const lineContent = model.getLineContent(startLineNumber + i);
      let currentVisibleColumn = 0;
      for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {
        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9, 1);
      }
      if (currentVisibleColumn > minVisibleColumn) {
        lines[i].commentStrOffset = j - 1;
      } else {
        lines[i].commentStrOffset = j;
      }
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/comment/comment.js
var CommentLineAction = class extends EditorAction {
  constructor(type, opts) {
    super(opts);
    this._type = type;
  }
  run(accessor, editor3) {
    if (!editor3.hasModel()) {
      return;
    }
    const model = editor3.getModel();
    const commands = [];
    const selections = editor3.getSelections();
    const modelOptions = model.getOptions();
    const commentsOptions = editor3.getOption(14);
    for (const selection of selections) {
      commands.push(new LineCommentCommand(selection, modelOptions.tabSize, this._type, commentsOptions.insertSpace, commentsOptions.ignoreEmptyLines));
    }
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, commands);
    editor3.pushUndoStop();
  }
};
var ToggleCommentLineAction = class extends CommentLineAction {
  constructor() {
    super(0, {
      id: "editor.action.commentLine",
      label: localize("comment.line", "Toggle Line Comment"),
      alias: "Toggle Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 85,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "5_insert",
        title: localize({key: "miToggleLineComment", comment: ["&& denotes a mnemonic"]}, "&&Toggle Line Comment"),
        order: 1
      }
    });
  }
};
var AddLineCommentAction = class extends CommentLineAction {
  constructor() {
    super(1, {
      id: "editor.action.addCommentLine",
      label: localize("comment.line.add", "Add Line Comment"),
      alias: "Add Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 33),
        weight: 100
      }
    });
  }
};
var RemoveLineCommentAction = class extends CommentLineAction {
  constructor() {
    super(2, {
      id: "editor.action.removeCommentLine",
      label: localize("comment.line.remove", "Remove Line Comment"),
      alias: "Remove Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 51),
        weight: 100
      }
    });
  }
};
var BlockCommentAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.blockComment",
      label: localize("comment.block", "Toggle Block Comment"),
      alias: "Toggle Block Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 31,
        linux: {primary: 2048 | 1024 | 31},
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "5_insert",
        title: localize({key: "miToggleBlockComment", comment: ["&& denotes a mnemonic"]}, "Toggle &&Block Comment"),
        order: 2
      }
    });
  }
  run(accessor, editor3) {
    if (!editor3.hasModel()) {
      return;
    }
    const commentsOptions = editor3.getOption(14);
    const commands = [];
    const selections = editor3.getSelections();
    for (const selection of selections) {
      commands.push(new BlockCommentCommand(selection, commentsOptions.insertSpace));
    }
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, commands);
    editor3.pushUndoStop();
  }
};
registerEditorAction(ToggleCommentLineAction);
registerEditorAction(AddLineCommentAction);
registerEditorAction(RemoveLineCommentAction);
registerEditorAction(BlockCommentAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/contextmenu/contextmenu.js
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param10 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContextMenuController = class ContextMenuController2 {
  constructor(editor3, _contextMenuService, _contextViewService, _contextKeyService, _keybindingService, _menuService) {
    this._contextMenuService = _contextMenuService;
    this._contextViewService = _contextViewService;
    this._contextKeyService = _contextKeyService;
    this._keybindingService = _keybindingService;
    this._menuService = _menuService;
    this._toDispose = new DisposableStore();
    this._contextMenuIsBeingShownCount = 0;
    this._editor = editor3;
    this._toDispose.add(this._editor.onContextMenu((e) => this._onContextMenu(e)));
    this._toDispose.add(this._editor.onMouseWheel((e) => {
      if (this._contextMenuIsBeingShownCount > 0) {
        const view = this._contextViewService.getContextViewElement();
        const target = e.srcElement;
        if (!(target.shadowRoot && getShadowRoot(view) === target.shadowRoot)) {
          this._contextViewService.hideContextView();
        }
      }
    }));
    this._toDispose.add(this._editor.onKeyDown((e) => {
      if (e.keyCode === 58) {
        e.preventDefault();
        e.stopPropagation();
        this.showContextMenu();
      }
    }));
  }
  static get(editor3) {
    return editor3.getContribution(ContextMenuController2.ID);
  }
  _onContextMenu(e) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._editor.getOption(15)) {
      this._editor.focus();
      if (e.target.position && !this._editor.getSelection().containsPosition(e.target.position)) {
        this._editor.setPosition(e.target.position);
      }
      return;
    }
    if (e.target.type === 12) {
      return;
    }
    e.event.preventDefault();
    if (e.target.type !== 6 && e.target.type !== 7 && e.target.type !== 1) {
      return;
    }
    this._editor.focus();
    if (e.target.position) {
      let hasSelectionAtPosition = false;
      for (const selection of this._editor.getSelections()) {
        if (selection.containsPosition(e.target.position)) {
          hasSelectionAtPosition = true;
          break;
        }
      }
      if (!hasSelectionAtPosition) {
        this._editor.setPosition(e.target.position);
      }
    }
    let anchor = null;
    if (e.target.type !== 1) {
      anchor = {x: e.event.posx - 1, width: 2, y: e.event.posy - 1, height: 2};
    }
    this.showContextMenu(anchor);
  }
  showContextMenu(anchor) {
    if (!this._editor.getOption(15)) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._contextMenuService) {
      this._editor.focus();
      return;
    }
    const menuActions = this._getMenuActions(this._editor.getModel(), MenuId.EditorContext);
    if (menuActions.length > 0) {
      this._doShowContextMenu(menuActions, anchor);
    }
  }
  _getMenuActions(model, menuId) {
    const result = [];
    const menu = this._menuService.createMenu(menuId, this._contextKeyService);
    const groups = menu.getActions({arg: model.uri});
    menu.dispose();
    for (let group of groups) {
      const [, actions25] = group;
      let addedItems = 0;
      for (const action of actions25) {
        if (action instanceof SubmenuItemAction) {
          const subActions = this._getMenuActions(model, action.item.submenu);
          if (subActions.length > 0) {
            result.push(new SubmenuAction(action.id, action.label, subActions));
            addedItems++;
          }
        } else {
          result.push(action);
          addedItems++;
        }
      }
      if (addedItems) {
        result.push(new Separator());
      }
    }
    if (result.length) {
      result.pop();
    }
    return result;
  }
  _doShowContextMenu(actions25, anchor = null) {
    if (!this._editor.hasModel()) {
      return;
    }
    const oldHoverSetting = this._editor.getOption(46);
    this._editor.updateOptions({
      hover: {
        enabled: false
      }
    });
    if (!anchor) {
      this._editor.revealPosition(this._editor.getPosition(), 1);
      this._editor.render();
      const cursorCoords = this._editor.getScrolledVisiblePosition(this._editor.getPosition());
      const editorCoords = getDomNodePagePosition(this._editor.getDomNode());
      const posx = editorCoords.left + cursorCoords.left;
      const posy = editorCoords.top + cursorCoords.top + cursorCoords.height;
      anchor = {x: posx, y: posy};
    }
    this._contextMenuIsBeingShownCount++;
    this._contextMenuService.showContextMenu({
      domForShadowRoot: this._editor.getDomNode(),
      getAnchor: () => anchor,
      getActions: () => actions25,
      getActionViewItem: (action) => {
        const keybinding = this._keybindingFor(action);
        if (keybinding) {
          return new ActionViewItem(action, action, {label: true, keybinding: keybinding.getLabel(), isMenu: true});
        }
        const customActionViewItem = action;
        if (typeof customActionViewItem.getActionViewItem === "function") {
          return customActionViewItem.getActionViewItem();
        }
        return new ActionViewItem(action, action, {icon: true, label: true, isMenu: true});
      },
      getKeyBinding: (action) => {
        return this._keybindingFor(action);
      },
      onHide: (wasCancelled) => {
        this._contextMenuIsBeingShownCount--;
        this._editor.focus();
        this._editor.updateOptions({
          hover: oldHoverSetting
        });
      }
    });
  }
  _keybindingFor(action) {
    return this._keybindingService.lookupKeybinding(action.id);
  }
  dispose() {
    if (this._contextMenuIsBeingShownCount > 0) {
      this._contextViewService.hideContextView();
    }
    this._toDispose.dispose();
  }
};
ContextMenuController.ID = "editor.contrib.contextmenu";
ContextMenuController = __decorate10([
  __param10(1, IContextMenuService),
  __param10(2, IContextViewService),
  __param10(3, IContextKeyService),
  __param10(4, IKeybindingService),
  __param10(5, IMenuService)
], ContextMenuController);
var ShowContextMenu = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showContextMenu",
      label: localize("action.showContextMenu.label", "Show Editor Context Menu"),
      alias: "Show Editor Context Menu",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 1024 | 68,
        weight: 100
      }
    });
  }
  run(accessor, editor3) {
    let contribution = ContextMenuController.get(editor3);
    contribution.showContextMenu();
  }
};
registerEditorContribution(ContextMenuController.ID, ContextMenuController);
registerEditorAction(ShowContextMenu);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/cursorUndo/cursorUndo.js
var CursorState2 = class {
  constructor(selections) {
    this.selections = selections;
  }
  equals(other) {
    const thisLen = this.selections.length;
    const otherLen = other.selections.length;
    if (thisLen !== otherLen) {
      return false;
    }
    for (let i = 0; i < thisLen; i++) {
      if (!this.selections[i].equalsSelection(other.selections[i])) {
        return false;
      }
    }
    return true;
  }
};
var StackElement = class {
  constructor(cursorState, scrollTop, scrollLeft) {
    this.cursorState = cursorState;
    this.scrollTop = scrollTop;
    this.scrollLeft = scrollLeft;
  }
};
var CursorUndoRedoController = class extends Disposable {
  constructor(editor3) {
    super();
    this._editor = editor3;
    this._isCursorUndoRedo = false;
    this._undoStack = [];
    this._redoStack = [];
    this._register(editor3.onDidChangeModel((e) => {
      this._undoStack = [];
      this._redoStack = [];
    }));
    this._register(editor3.onDidChangeModelContent((e) => {
      this._undoStack = [];
      this._redoStack = [];
    }));
    this._register(editor3.onDidChangeCursorSelection((e) => {
      if (this._isCursorUndoRedo) {
        return;
      }
      if (!e.oldSelections) {
        return;
      }
      if (e.oldModelVersionId !== e.modelVersionId) {
        return;
      }
      const prevState = new CursorState2(e.oldSelections);
      const isEqualToLastUndoStack = this._undoStack.length > 0 && this._undoStack[this._undoStack.length - 1].cursorState.equals(prevState);
      if (!isEqualToLastUndoStack) {
        this._undoStack.push(new StackElement(prevState, editor3.getScrollTop(), editor3.getScrollLeft()));
        this._redoStack = [];
        if (this._undoStack.length > 50) {
          this._undoStack.shift();
        }
      }
    }));
  }
  static get(editor3) {
    return editor3.getContribution(CursorUndoRedoController.ID);
  }
  cursorUndo() {
    if (!this._editor.hasModel() || this._undoStack.length === 0) {
      return;
    }
    this._redoStack.push(new StackElement(new CursorState2(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
    this._applyState(this._undoStack.pop());
  }
  cursorRedo() {
    if (!this._editor.hasModel() || this._redoStack.length === 0) {
      return;
    }
    this._undoStack.push(new StackElement(new CursorState2(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
    this._applyState(this._redoStack.pop());
  }
  _applyState(stackElement) {
    this._isCursorUndoRedo = true;
    this._editor.setSelections(stackElement.cursorState.selections);
    this._editor.setScrollPosition({
      scrollTop: stackElement.scrollTop,
      scrollLeft: stackElement.scrollLeft
    });
    this._isCursorUndoRedo = false;
  }
};
CursorUndoRedoController.ID = "editor.contrib.cursorUndoRedoController";
var CursorUndo = class extends EditorAction {
  constructor() {
    super({
      id: "cursorUndo",
      label: localize("cursor.undo", "Cursor Undo"),
      alias: "Cursor Undo",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 51,
        weight: 100
      }
    });
  }
  run(accessor, editor3, args) {
    CursorUndoRedoController.get(editor3).cursorUndo();
  }
};
var CursorRedo = class extends EditorAction {
  constructor() {
    super({
      id: "cursorRedo",
      label: localize("cursor.redo", "Cursor Redo"),
      alias: "Cursor Redo",
      precondition: void 0
    });
  }
  run(accessor, editor3, args) {
    CursorUndoRedoController.get(editor3).cursorRedo();
  }
};
registerEditorContribution(CursorUndoRedoController.ID, CursorUndoRedoController);
registerEditorAction(CursorUndo);
registerEditorAction(CursorRedo);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/dnd/dragAndDropCommand.js
var DragAndDropCommand = class {
  constructor(selection, targetPosition, copy) {
    this.selection = selection;
    this.targetPosition = targetPosition;
    this.copy = copy;
    this.targetSelection = null;
  }
  getEditOperations(model, builder) {
    let text = model.getValueInRange(this.selection);
    if (!this.copy) {
      builder.addEditOperation(this.selection, null);
    }
    builder.addEditOperation(new Range2(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column), text);
    if (this.selection.containsPosition(this.targetPosition) && !(this.copy && (this.selection.getEndPosition().equals(this.targetPosition) || this.selection.getStartPosition().equals(this.targetPosition)))) {
      this.targetSelection = this.selection;
      return;
    }
    if (this.copy) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.selection.endLineNumber - this.selection.startLineNumber + this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber > this.selection.endLineNumber) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber < this.selection.endLineNumber) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber + this.selection.endLineNumber - this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.selection.endColumn <= this.targetPosition.column) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column - this.selection.endColumn + this.selection.startColumn : this.targetPosition.column - this.selection.endColumn + this.selection.startColumn, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column : this.selection.endColumn);
    } else {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column + this.selection.endColumn - this.selection.startColumn);
    }
  }
  computeCursorState(model, helper) {
    return this.targetSelection;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/dnd/dnd.js
function hasTriggerModifier(e) {
  if (isMacintosh) {
    return e.altKey;
  } else {
    return e.ctrlKey;
  }
}
var DragAndDropController = class extends Disposable {
  constructor(editor3) {
    super();
    this._editor = editor3;
    this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
    this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
    this._register(this._editor.onMouseDrag((e) => this._onEditorMouseDrag(e)));
    this._register(this._editor.onMouseDrop((e) => this._onEditorMouseDrop(e)));
    this._register(this._editor.onKeyDown((e) => this.onEditorKeyDown(e)));
    this._register(this._editor.onKeyUp((e) => this.onEditorKeyUp(e)));
    this._register(this._editor.onDidBlurEditorWidget(() => this.onEditorBlur()));
    this._register(this._editor.onDidBlurEditorText(() => this.onEditorBlur()));
    this._dndDecorationIds = [];
    this._mouseDown = false;
    this._modifierPressed = false;
    this._dragSelection = null;
  }
  onEditorBlur() {
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
    this._modifierPressed = false;
  }
  onEditorKeyDown(e) {
    if (!this._editor.getOption(25) || this._editor.getOption(13)) {
      return;
    }
    if (hasTriggerModifier(e)) {
      this._modifierPressed = true;
    }
    if (this._mouseDown && hasTriggerModifier(e)) {
      this._editor.updateOptions({
        mouseStyle: "copy"
      });
    }
  }
  onEditorKeyUp(e) {
    if (!this._editor.getOption(25) || this._editor.getOption(13)) {
      return;
    }
    if (hasTriggerModifier(e)) {
      this._modifierPressed = false;
    }
    if (this._mouseDown && e.keyCode === DragAndDropController.TRIGGER_KEY_VALUE) {
      this._editor.updateOptions({
        mouseStyle: "default"
      });
    }
  }
  _onEditorMouseDown(mouseEvent) {
    this._mouseDown = true;
  }
  _onEditorMouseUp(mouseEvent) {
    this._mouseDown = false;
    this._editor.updateOptions({
      mouseStyle: "text"
    });
  }
  _onEditorMouseDrag(mouseEvent) {
    let target = mouseEvent.target;
    if (this._dragSelection === null) {
      const selections = this._editor.getSelections() || [];
      let possibleSelections = selections.filter((selection) => target.position && selection.containsPosition(target.position));
      if (possibleSelections.length === 1) {
        this._dragSelection = possibleSelections[0];
      } else {
        return;
      }
    }
    if (hasTriggerModifier(mouseEvent.event)) {
      this._editor.updateOptions({
        mouseStyle: "copy"
      });
    } else {
      this._editor.updateOptions({
        mouseStyle: "default"
      });
    }
    if (target.position) {
      if (this._dragSelection.containsPosition(target.position)) {
        this._removeDecoration();
      } else {
        this.showAt(target.position);
      }
    }
  }
  _onEditorMouseDrop(mouseEvent) {
    if (mouseEvent.target && (this._hitContent(mouseEvent.target) || this._hitMargin(mouseEvent.target)) && mouseEvent.target.position) {
      let newCursorPosition = new Position(mouseEvent.target.position.lineNumber, mouseEvent.target.position.column);
      if (this._dragSelection === null) {
        let newSelections = null;
        if (mouseEvent.event.shiftKey) {
          let primarySelection = this._editor.getSelection();
          if (primarySelection) {
            const {selectionStartLineNumber, selectionStartColumn} = primarySelection;
            newSelections = [new Selection(selectionStartLineNumber, selectionStartColumn, newCursorPosition.lineNumber, newCursorPosition.column)];
          }
        } else {
          newSelections = (this._editor.getSelections() || []).map((selection) => {
            if (selection.containsPosition(newCursorPosition)) {
              return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
            } else {
              return selection;
            }
          });
        }
        this._editor.setSelections(newSelections || [], "mouse");
      } else if (!this._dragSelection.containsPosition(newCursorPosition) || (hasTriggerModifier(mouseEvent.event) || this._modifierPressed) && (this._dragSelection.getEndPosition().equals(newCursorPosition) || this._dragSelection.getStartPosition().equals(newCursorPosition))) {
        this._editor.pushUndoStop();
        this._editor.executeCommand(DragAndDropController.ID, new DragAndDropCommand(this._dragSelection, newCursorPosition, hasTriggerModifier(mouseEvent.event) || this._modifierPressed));
        this._editor.pushUndoStop();
      }
    }
    this._editor.updateOptions({
      mouseStyle: "text"
    });
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
  }
  showAt(position) {
    let newDecorations = [{
      range: new Range2(position.lineNumber, position.column, position.lineNumber, position.column),
      options: DragAndDropController._DECORATION_OPTIONS
    }];
    this._dndDecorationIds = this._editor.deltaDecorations(this._dndDecorationIds, newDecorations);
    this._editor.revealPosition(position, 1);
  }
  _removeDecoration() {
    this._dndDecorationIds = this._editor.deltaDecorations(this._dndDecorationIds, []);
  }
  _hitContent(target) {
    return target.type === 6 || target.type === 7;
  }
  _hitMargin(target) {
    return target.type === 2 || target.type === 3 || target.type === 4;
  }
  dispose() {
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
    this._modifierPressed = false;
    super.dispose();
  }
};
DragAndDropController.ID = "editor.contrib.dragAndDrop";
DragAndDropController.TRIGGER_KEY_VALUE = isMacintosh ? 6 : 5;
DragAndDropController._DECORATION_OPTIONS = ModelDecorationOptions.register({
  className: "dnd-target"
});
registerEditorContribution(DragAndDropController.ID, DragAndDropController);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/findDecorations.js
var FindDecorations = class {
  constructor(editor3) {
    this._editor = editor3;
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
    this._startPosition = this._editor.getPosition();
  }
  dispose() {
    this._editor.deltaDecorations(this._allDecorations(), []);
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
  }
  reset() {
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
  }
  getCount() {
    return this._decorations.length;
  }
  getFindScope() {
    if (this._findScopeDecorationIds[0]) {
      return this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]);
    }
    return null;
  }
  getFindScopes() {
    if (this._findScopeDecorationIds.length) {
      const scopes = this._findScopeDecorationIds.map((findScopeDecorationId) => this._editor.getModel().getDecorationRange(findScopeDecorationId)).filter((element) => !!element);
      if (scopes.length) {
        return scopes;
      }
    }
    return null;
  }
  getStartPosition() {
    return this._startPosition;
  }
  setStartPosition(newStartPosition) {
    this._startPosition = newStartPosition;
    this.setCurrentFindMatch(null);
  }
  _getDecorationIndex(decorationId) {
    const index2 = this._decorations.indexOf(decorationId);
    if (index2 >= 0) {
      return index2 + 1;
    }
    return 1;
  }
  getCurrentMatchesPosition(desiredRange) {
    let candidates = this._editor.getModel().getDecorationsInRange(desiredRange);
    for (const candidate of candidates) {
      const candidateOpts = candidate.options;
      if (candidateOpts === FindDecorations._FIND_MATCH_DECORATION || candidateOpts === FindDecorations._CURRENT_FIND_MATCH_DECORATION) {
        return this._getDecorationIndex(candidate.id);
      }
    }
    return 0;
  }
  setCurrentFindMatch(nextMatch) {
    let newCurrentDecorationId = null;
    let matchPosition = 0;
    if (nextMatch) {
      for (let i = 0, len = this._decorations.length; i < len; i++) {
        let range2 = this._editor.getModel().getDecorationRange(this._decorations[i]);
        if (nextMatch.equalsRange(range2)) {
          newCurrentDecorationId = this._decorations[i];
          matchPosition = i + 1;
          break;
        }
      }
    }
    if (this._highlightedDecorationId !== null || newCurrentDecorationId !== null) {
      this._editor.changeDecorations((changeAccessor) => {
        if (this._highlightedDecorationId !== null) {
          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._FIND_MATCH_DECORATION);
          this._highlightedDecorationId = null;
        }
        if (newCurrentDecorationId !== null) {
          this._highlightedDecorationId = newCurrentDecorationId;
          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._CURRENT_FIND_MATCH_DECORATION);
        }
        if (this._rangeHighlightDecorationId !== null) {
          changeAccessor.removeDecoration(this._rangeHighlightDecorationId);
          this._rangeHighlightDecorationId = null;
        }
        if (newCurrentDecorationId !== null) {
          let rng = this._editor.getModel().getDecorationRange(newCurrentDecorationId);
          if (rng.startLineNumber !== rng.endLineNumber && rng.endColumn === 1) {
            let lineBeforeEnd = rng.endLineNumber - 1;
            let lineBeforeEndMaxColumn = this._editor.getModel().getLineMaxColumn(lineBeforeEnd);
            rng = new Range2(rng.startLineNumber, rng.startColumn, lineBeforeEnd, lineBeforeEndMaxColumn);
          }
          this._rangeHighlightDecorationId = changeAccessor.addDecoration(rng, FindDecorations._RANGE_HIGHLIGHT_DECORATION);
        }
      });
    }
    return matchPosition;
  }
  set(findMatches, findScopes) {
    this._editor.changeDecorations((accessor) => {
      let findMatchesOptions = FindDecorations._FIND_MATCH_DECORATION;
      let newOverviewRulerApproximateDecorations = [];
      if (findMatches.length > 1e3) {
        findMatchesOptions = FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION;
        const lineCount = this._editor.getModel().getLineCount();
        const height = this._editor.getLayoutInfo().height;
        const approxPixelsPerLine = height / lineCount;
        const mergeLinesDelta = Math.max(2, Math.ceil(3 / approxPixelsPerLine));
        let prevStartLineNumber = findMatches[0].range.startLineNumber;
        let prevEndLineNumber = findMatches[0].range.endLineNumber;
        for (let i = 1, len = findMatches.length; i < len; i++) {
          const range2 = findMatches[i].range;
          if (prevEndLineNumber + mergeLinesDelta >= range2.startLineNumber) {
            if (range2.endLineNumber > prevEndLineNumber) {
              prevEndLineNumber = range2.endLineNumber;
            }
          } else {
            newOverviewRulerApproximateDecorations.push({
              range: new Range2(prevStartLineNumber, 1, prevEndLineNumber, 1),
              options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
            });
            prevStartLineNumber = range2.startLineNumber;
            prevEndLineNumber = range2.endLineNumber;
          }
        }
        newOverviewRulerApproximateDecorations.push({
          range: new Range2(prevStartLineNumber, 1, prevEndLineNumber, 1),
          options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
        });
      }
      let newFindMatchesDecorations = new Array(findMatches.length);
      for (let i = 0, len = findMatches.length; i < len; i++) {
        newFindMatchesDecorations[i] = {
          range: findMatches[i].range,
          options: findMatchesOptions
        };
      }
      this._decorations = accessor.deltaDecorations(this._decorations, newFindMatchesDecorations);
      this._overviewRulerApproximateDecorations = accessor.deltaDecorations(this._overviewRulerApproximateDecorations, newOverviewRulerApproximateDecorations);
      if (this._rangeHighlightDecorationId) {
        accessor.removeDecoration(this._rangeHighlightDecorationId);
        this._rangeHighlightDecorationId = null;
      }
      if (this._findScopeDecorationIds.length) {
        this._findScopeDecorationIds.forEach((findScopeDecorationId) => accessor.removeDecoration(findScopeDecorationId));
        this._findScopeDecorationIds = [];
      }
      if (findScopes === null || findScopes === void 0 ? void 0 : findScopes.length) {
        this._findScopeDecorationIds = findScopes.map((findScope) => accessor.addDecoration(findScope, FindDecorations._FIND_SCOPE_DECORATION));
      }
    });
  }
  matchBeforePosition(position) {
    if (this._decorations.length === 0) {
      return null;
    }
    for (let i = this._decorations.length - 1; i >= 0; i--) {
      let decorationId = this._decorations[i];
      let r = this._editor.getModel().getDecorationRange(decorationId);
      if (!r || r.endLineNumber > position.lineNumber) {
        continue;
      }
      if (r.endLineNumber < position.lineNumber) {
        return r;
      }
      if (r.endColumn > position.column) {
        continue;
      }
      return r;
    }
    return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);
  }
  matchAfterPosition(position) {
    if (this._decorations.length === 0) {
      return null;
    }
    for (let i = 0, len = this._decorations.length; i < len; i++) {
      let decorationId = this._decorations[i];
      let r = this._editor.getModel().getDecorationRange(decorationId);
      if (!r || r.startLineNumber < position.lineNumber) {
        continue;
      }
      if (r.startLineNumber > position.lineNumber) {
        return r;
      }
      if (r.startColumn < position.column) {
        continue;
      }
      return r;
    }
    return this._editor.getModel().getDecorationRange(this._decorations[0]);
  }
  _allDecorations() {
    let result = [];
    result = result.concat(this._decorations);
    result = result.concat(this._overviewRulerApproximateDecorations);
    if (this._findScopeDecorationIds.length) {
      result.push(...this._findScopeDecorationIds);
    }
    if (this._rangeHighlightDecorationId) {
      result.push(this._rangeHighlightDecorationId);
    }
    return result;
  }
};
FindDecorations._CURRENT_FIND_MATCH_DECORATION = ModelDecorationOptions.register({
  stickiness: 1,
  zIndex: 13,
  className: "currentFindMatch",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: MinimapPosition.Inline
  }
});
FindDecorations._FIND_MATCH_DECORATION = ModelDecorationOptions.register({
  stickiness: 1,
  className: "findMatch",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: MinimapPosition.Inline
  }
});
FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION = ModelDecorationOptions.register({
  stickiness: 1,
  className: "findMatch",
  showIfCollapsed: true
});
FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION = ModelDecorationOptions.register({
  stickiness: 1,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  }
});
FindDecorations._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({
  stickiness: 1,
  className: "rangeHighlight",
  isWholeLine: true
});
FindDecorations._FIND_SCOPE_DECORATION = ModelDecorationOptions.register({
  className: "findScope",
  isWholeLine: true
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/replaceAllCommand.js
var ReplaceAllCommand = class {
  constructor(editorSelection, ranges, replaceStrings) {
    this._editorSelection = editorSelection;
    this._ranges = ranges;
    this._replaceStrings = replaceStrings;
    this._trackedEditorSelectionId = null;
  }
  getEditOperations(model, builder) {
    if (this._ranges.length > 0) {
      let ops = [];
      for (let i = 0; i < this._ranges.length; i++) {
        ops.push({
          range: this._ranges[i],
          text: this._replaceStrings[i]
        });
      }
      ops.sort((o1, o2) => {
        return Range2.compareRangesUsingStarts(o1.range, o2.range);
      });
      let resultOps = [];
      let previousOp = ops[0];
      for (let i = 1; i < ops.length; i++) {
        if (previousOp.range.endLineNumber === ops[i].range.startLineNumber && previousOp.range.endColumn === ops[i].range.startColumn) {
          previousOp.range = previousOp.range.plusRange(ops[i].range);
          previousOp.text = previousOp.text + ops[i].text;
        } else {
          resultOps.push(previousOp);
          previousOp = ops[i];
        }
      }
      resultOps.push(previousOp);
      for (const op of resultOps) {
        builder.addEditOperation(op.range, op.text);
      }
    }
    this._trackedEditorSelectionId = builder.trackSelection(this._editorSelection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._trackedEditorSelectionId);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/search.js
function buildReplaceStringWithCasePreserved(matches, pattern3) {
  if (matches && matches[0] !== "") {
    const containsHyphens = validateSpecificSpecialCharacter(matches, pattern3, "-");
    const containsUnderscores = validateSpecificSpecialCharacter(matches, pattern3, "_");
    if (containsHyphens && !containsUnderscores) {
      return buildReplaceStringForSpecificSpecialCharacter(matches, pattern3, "-");
    } else if (!containsHyphens && containsUnderscores) {
      return buildReplaceStringForSpecificSpecialCharacter(matches, pattern3, "_");
    }
    if (matches[0].toUpperCase() === matches[0]) {
      return pattern3.toUpperCase();
    } else if (matches[0].toLowerCase() === matches[0]) {
      return pattern3.toLowerCase();
    } else if (containsUppercaseCharacter(matches[0][0]) && pattern3.length > 0) {
      return pattern3[0].toUpperCase() + pattern3.substr(1);
    } else {
      return pattern3;
    }
  } else {
    return pattern3;
  }
}
function validateSpecificSpecialCharacter(matches, pattern3, specialCharacter) {
  const doesContainSpecialCharacter = matches[0].indexOf(specialCharacter) !== -1 && pattern3.indexOf(specialCharacter) !== -1;
  return doesContainSpecialCharacter && matches[0].split(specialCharacter).length === pattern3.split(specialCharacter).length;
}
function buildReplaceStringForSpecificSpecialCharacter(matches, pattern3, specialCharacter) {
  const splitPatternAtSpecialCharacter = pattern3.split(specialCharacter);
  const splitMatchAtSpecialCharacter = matches[0].split(specialCharacter);
  let replaceString = "";
  splitPatternAtSpecialCharacter.forEach((splitValue, index2) => {
    replaceString += buildReplaceStringWithCasePreserved([splitMatchAtSpecialCharacter[index2]], splitValue) + specialCharacter;
  });
  return replaceString.slice(0, -1);
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/replacePattern.js
var StaticValueReplacePattern = class {
  constructor(staticValue) {
    this.staticValue = staticValue;
    this.kind = 0;
  }
};
var DynamicPiecesReplacePattern = class {
  constructor(pieces) {
    this.pieces = pieces;
    this.kind = 1;
  }
};
var ReplacePattern = class {
  constructor(pieces) {
    if (!pieces || pieces.length === 0) {
      this._state = new StaticValueReplacePattern("");
    } else if (pieces.length === 1 && pieces[0].staticValue !== null) {
      this._state = new StaticValueReplacePattern(pieces[0].staticValue);
    } else {
      this._state = new DynamicPiecesReplacePattern(pieces);
    }
  }
  static fromStaticValue(value) {
    return new ReplacePattern([ReplacePiece.staticValue(value)]);
  }
  get hasReplacementPatterns() {
    return this._state.kind === 1;
  }
  buildReplaceString(matches, preserveCase) {
    if (this._state.kind === 0) {
      if (preserveCase) {
        return buildReplaceStringWithCasePreserved(matches, this._state.staticValue);
      } else {
        return this._state.staticValue;
      }
    }
    let result = "";
    for (let i = 0, len = this._state.pieces.length; i < len; i++) {
      let piece = this._state.pieces[i];
      if (piece.staticValue !== null) {
        result += piece.staticValue;
        continue;
      }
      let match = ReplacePattern._substitute(piece.matchIndex, matches);
      if (piece.caseOps !== null && piece.caseOps.length > 0) {
        let repl = [];
        let lenOps = piece.caseOps.length;
        let opIdx = 0;
        for (let idx = 0, len2 = match.length; idx < len2; idx++) {
          if (opIdx >= lenOps) {
            repl.push(match.slice(idx));
            break;
          }
          switch (piece.caseOps[opIdx]) {
            case "U":
              repl.push(match[idx].toUpperCase());
              break;
            case "u":
              repl.push(match[idx].toUpperCase());
              opIdx++;
              break;
            case "L":
              repl.push(match[idx].toLowerCase());
              break;
            case "l":
              repl.push(match[idx].toLowerCase());
              opIdx++;
              break;
            default:
              repl.push(match[idx]);
          }
        }
        match = repl.join("");
      }
      result += match;
    }
    return result;
  }
  static _substitute(matchIndex, matches) {
    if (matches === null) {
      return "";
    }
    if (matchIndex === 0) {
      return matches[0];
    }
    let remainder = "";
    while (matchIndex > 0) {
      if (matchIndex < matches.length) {
        let match = matches[matchIndex] || "";
        return match + remainder;
      }
      remainder = String(matchIndex % 10) + remainder;
      matchIndex = Math.floor(matchIndex / 10);
    }
    return "$" + remainder;
  }
};
var ReplacePiece = class {
  constructor(staticValue, matchIndex, caseOps) {
    this.staticValue = staticValue;
    this.matchIndex = matchIndex;
    if (!caseOps || caseOps.length === 0) {
      this.caseOps = null;
    } else {
      this.caseOps = caseOps.slice(0);
    }
  }
  static staticValue(value) {
    return new ReplacePiece(value, -1, null);
  }
  static caseOps(index2, caseOps) {
    return new ReplacePiece(null, index2, caseOps);
  }
};
var ReplacePieceBuilder = class {
  constructor(source) {
    this._source = source;
    this._lastCharIndex = 0;
    this._result = [];
    this._resultLen = 0;
    this._currentStaticPiece = "";
  }
  emitUnchanged(toCharIndex) {
    this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));
    this._lastCharIndex = toCharIndex;
  }
  emitStatic(value, toCharIndex) {
    this._emitStatic(value);
    this._lastCharIndex = toCharIndex;
  }
  _emitStatic(value) {
    if (value.length === 0) {
      return;
    }
    this._currentStaticPiece += value;
  }
  emitMatchIndex(index2, toCharIndex, caseOps) {
    if (this._currentStaticPiece.length !== 0) {
      this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
      this._currentStaticPiece = "";
    }
    this._result[this._resultLen++] = ReplacePiece.caseOps(index2, caseOps);
    this._lastCharIndex = toCharIndex;
  }
  finalize() {
    this.emitUnchanged(this._source.length);
    if (this._currentStaticPiece.length !== 0) {
      this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
      this._currentStaticPiece = "";
    }
    return new ReplacePattern(this._result);
  }
};
function parseReplaceString(replaceString) {
  if (!replaceString || replaceString.length === 0) {
    return new ReplacePattern(null);
  }
  let caseOps = [];
  let result = new ReplacePieceBuilder(replaceString);
  for (let i = 0, len = replaceString.length; i < len; i++) {
    let chCode = replaceString.charCodeAt(i);
    if (chCode === 92) {
      i++;
      if (i >= len) {
        break;
      }
      let nextChCode = replaceString.charCodeAt(i);
      switch (nextChCode) {
        case 92:
          result.emitUnchanged(i - 1);
          result.emitStatic("\\", i + 1);
          break;
        case 110:
          result.emitUnchanged(i - 1);
          result.emitStatic("\n", i + 1);
          break;
        case 116:
          result.emitUnchanged(i - 1);
          result.emitStatic("	", i + 1);
          break;
        case 117:
        case 85:
        case 108:
        case 76:
          result.emitUnchanged(i - 1);
          result.emitStatic("", i + 1);
          caseOps.push(String.fromCharCode(nextChCode));
          break;
      }
      continue;
    }
    if (chCode === 36) {
      i++;
      if (i >= len) {
        break;
      }
      let nextChCode = replaceString.charCodeAt(i);
      if (nextChCode === 36) {
        result.emitUnchanged(i - 1);
        result.emitStatic("$", i + 1);
        continue;
      }
      if (nextChCode === 48 || nextChCode === 38) {
        result.emitUnchanged(i - 1);
        result.emitMatchIndex(0, i + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
      if (49 <= nextChCode && nextChCode <= 57) {
        let matchIndex = nextChCode - 48;
        if (i + 1 < len) {
          let nextNextChCode = replaceString.charCodeAt(i + 1);
          if (48 <= nextNextChCode && nextNextChCode <= 57) {
            i++;
            matchIndex = matchIndex * 10 + (nextNextChCode - 48);
            result.emitUnchanged(i - 2);
            result.emitMatchIndex(matchIndex, i + 1, caseOps);
            caseOps.length = 0;
            continue;
          }
        }
        result.emitUnchanged(i - 1);
        result.emitMatchIndex(matchIndex, i + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
    }
  }
  return result.finalize();
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/findModel.js
var CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey("findWidgetVisible", false);
var CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey("findInputFocussed", false);
var CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey("replaceInputFocussed", false);
var ToggleCaseSensitiveKeybinding = {
  primary: 512 | 33,
  mac: {primary: 2048 | 512 | 33}
};
var ToggleWholeWordKeybinding = {
  primary: 512 | 53,
  mac: {primary: 2048 | 512 | 53}
};
var ToggleRegexKeybinding = {
  primary: 512 | 48,
  mac: {primary: 2048 | 512 | 48}
};
var ToggleSearchScopeKeybinding = {
  primary: 512 | 42,
  mac: {primary: 2048 | 512 | 42}
};
var FIND_IDS = {
  StartFindAction: "actions.find",
  StartFindWithSelection: "actions.findWithSelection",
  NextMatchFindAction: "editor.action.nextMatchFindAction",
  PreviousMatchFindAction: "editor.action.previousMatchFindAction",
  NextSelectionMatchFindAction: "editor.action.nextSelectionMatchFindAction",
  PreviousSelectionMatchFindAction: "editor.action.previousSelectionMatchFindAction",
  StartFindReplaceAction: "editor.action.startFindReplaceAction",
  CloseFindWidgetCommand: "closeFindWidget",
  ToggleCaseSensitiveCommand: "toggleFindCaseSensitive",
  ToggleWholeWordCommand: "toggleFindWholeWord",
  ToggleRegexCommand: "toggleFindRegex",
  ToggleSearchScopeCommand: "toggleFindInSelection",
  TogglePreserveCaseCommand: "togglePreserveCase",
  ReplaceOneAction: "editor.action.replaceOne",
  ReplaceAllAction: "editor.action.replaceAll",
  SelectAllMatchesAction: "editor.action.selectAllMatches"
};
var MATCHES_LIMIT = 19999;
var RESEARCH_DELAY = 240;
var FindModelBoundToEditorModel = class {
  constructor(editor3, state) {
    this._toDispose = new DisposableStore();
    this._editor = editor3;
    this._state = state;
    this._isDisposed = false;
    this._startSearchingTimer = new TimeoutTimer();
    this._decorations = new FindDecorations(editor3);
    this._toDispose.add(this._decorations);
    this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);
    this._toDispose.add(this._updateDecorationsScheduler);
    this._toDispose.add(this._editor.onDidChangeCursorPosition((e) => {
      if (e.reason === 3 || e.reason === 5 || e.reason === 6) {
        this._decorations.setStartPosition(this._editor.getPosition());
      }
    }));
    this._ignoreModelContentChanged = false;
    this._toDispose.add(this._editor.onDidChangeModelContent((e) => {
      if (this._ignoreModelContentChanged) {
        return;
      }
      if (e.isFlush) {
        this._decorations.reset();
      }
      this._decorations.setStartPosition(this._editor.getPosition());
      this._updateDecorationsScheduler.schedule();
    }));
    this._toDispose.add(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this.research(false, this._state.searchScope);
  }
  dispose() {
    this._isDisposed = true;
    dispose(this._startSearchingTimer);
    this._toDispose.dispose();
  }
  _onStateChanged(e) {
    if (this._isDisposed) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {
      let model = this._editor.getModel();
      if (model.isTooLargeForSyncing()) {
        this._startSearchingTimer.cancel();
        this._startSearchingTimer.setIfNotSet(() => {
          if (e.searchScope) {
            this.research(e.moveCursor, this._state.searchScope);
          } else {
            this.research(e.moveCursor);
          }
        }, RESEARCH_DELAY);
      } else {
        if (e.searchScope) {
          this.research(e.moveCursor, this._state.searchScope);
        } else {
          this.research(e.moveCursor);
        }
      }
    }
  }
  static _getSearchRange(model, findScope) {
    if (findScope) {
      return findScope;
    }
    return model.getFullModelRange();
  }
  research(moveCursor, newFindScope) {
    let findScopes = null;
    if (typeof newFindScope !== "undefined") {
      if (newFindScope !== null) {
        if (!Array.isArray(newFindScope)) {
          findScopes = [newFindScope];
        } else {
          findScopes = newFindScope;
        }
      }
    } else {
      findScopes = this._decorations.getFindScopes();
    }
    if (findScopes !== null) {
      findScopes = findScopes.map((findScope) => {
        if (findScope.startLineNumber !== findScope.endLineNumber) {
          let endLineNumber = findScope.endLineNumber;
          if (findScope.endColumn === 1) {
            endLineNumber = endLineNumber - 1;
          }
          return new Range2(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));
        }
        return findScope;
      });
    }
    let findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);
    this._decorations.set(findMatches, findScopes);
    const editorSelection = this._editor.getSelection();
    let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);
    if (currentMatchesPosition === 0 && findMatches.length > 0) {
      const matchAfterSelection = findFirstInSorted(findMatches.map((match) => match.range), (range2) => Range2.compareRangesUsingStarts(range2, editorSelection) >= 0);
      currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 : currentMatchesPosition;
    }
    this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), void 0);
    if (moveCursor && this._editor.getOption(29).cursorMoveOnType) {
      this._moveToNextMatch(this._decorations.getStartPosition());
    }
  }
  _hasMatches() {
    return this._state.matchesCount > 0;
  }
  _cannotFind() {
    if (!this._hasMatches()) {
      let findScope = this._decorations.getFindScope();
      if (findScope) {
        this._editor.revealRangeInCenterIfOutsideViewport(findScope, 0);
      }
      return true;
    }
    return false;
  }
  _setCurrentFindMatch(match) {
    let matchesPosition = this._decorations.setCurrentFindMatch(match);
    this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);
    this._editor.setSelection(match);
    this._editor.revealRangeInCenterIfOutsideViewport(match, 0);
  }
  _prevSearchPosition(before) {
    let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let {lineNumber, column} = before;
    let model = this._editor.getModel();
    if (isUsingLineStops || column === 1) {
      if (lineNumber === 1) {
        lineNumber = model.getLineCount();
      } else {
        lineNumber--;
      }
      column = model.getLineMaxColumn(lineNumber);
    } else {
      column--;
    }
    return new Position(lineNumber, column);
  }
  _moveToPrevMatch(before, isRecursed = false) {
    if (!this._state.canNavigateBack()) {
      const nextMatchRange = this._decorations.matchAfterPosition(before);
      if (nextMatchRange) {
        this._setCurrentFindMatch(nextMatchRange);
      }
      return;
    }
    if (this._decorations.getCount() < MATCHES_LIMIT) {
      let prevMatchRange = this._decorations.matchBeforePosition(before);
      if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {
        before = this._prevSearchPosition(before);
        prevMatchRange = this._decorations.matchBeforePosition(before);
      }
      if (prevMatchRange) {
        this._setCurrentFindMatch(prevMatchRange);
      }
      return;
    }
    if (this._cannotFind()) {
      return;
    }
    let findScope = this._decorations.getFindScope();
    let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
    if (searchRange.getEndPosition().isBefore(before)) {
      before = searchRange.getEndPosition();
    }
    if (before.isBefore(searchRange.getStartPosition())) {
      before = searchRange.getEndPosition();
    }
    let {lineNumber, column} = before;
    let model = this._editor.getModel();
    let position = new Position(lineNumber, column);
    let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(105) : null, false);
    if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {
      position = this._prevSearchPosition(position);
      prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(105) : null, false);
    }
    if (!prevMatch) {
      return;
    }
    if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {
      return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);
    }
    this._setCurrentFindMatch(prevMatch.range);
  }
  moveToPrevMatch() {
    this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
  }
  _nextSearchPosition(after) {
    let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let {lineNumber, column} = after;
    let model = this._editor.getModel();
    if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {
      if (lineNumber === model.getLineCount()) {
        lineNumber = 1;
      } else {
        lineNumber++;
      }
      column = 1;
    } else {
      column++;
    }
    return new Position(lineNumber, column);
  }
  _moveToNextMatch(after) {
    if (!this._state.canNavigateForward()) {
      const prevMatchRange = this._decorations.matchBeforePosition(after);
      if (prevMatchRange) {
        this._setCurrentFindMatch(prevMatchRange);
      }
      return;
    }
    if (this._decorations.getCount() < MATCHES_LIMIT) {
      let nextMatchRange = this._decorations.matchAfterPosition(after);
      if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {
        after = this._nextSearchPosition(after);
        nextMatchRange = this._decorations.matchAfterPosition(after);
      }
      if (nextMatchRange) {
        this._setCurrentFindMatch(nextMatchRange);
      }
      return;
    }
    let nextMatch = this._getNextMatch(after, false, true);
    if (nextMatch) {
      this._setCurrentFindMatch(nextMatch.range);
    }
  }
  _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {
    if (this._cannotFind()) {
      return null;
    }
    let findScope = this._decorations.getFindScope();
    let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
    if (searchRange.getEndPosition().isBefore(after)) {
      after = searchRange.getStartPosition();
    }
    if (after.isBefore(searchRange.getStartPosition())) {
      after = searchRange.getStartPosition();
    }
    let {lineNumber, column} = after;
    let model = this._editor.getModel();
    let position = new Position(lineNumber, column);
    let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(105) : null, captureMatches);
    if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {
      position = this._nextSearchPosition(position);
      nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(105) : null, captureMatches);
    }
    if (!nextMatch) {
      return null;
    }
    if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {
      return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);
    }
    return nextMatch;
  }
  moveToNextMatch() {
    this._moveToNextMatch(this._editor.getSelection().getEndPosition());
  }
  _getReplacePattern() {
    if (this._state.isRegex) {
      return parseReplaceString(this._state.replaceString);
    }
    return ReplacePattern.fromStaticValue(this._state.replaceString);
  }
  replace() {
    if (!this._hasMatches()) {
      return;
    }
    let replacePattern = this._getReplacePattern();
    let selection = this._editor.getSelection();
    let nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);
    if (nextMatch) {
      if (selection.equalsRange(nextMatch.range)) {
        let replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);
        let command = new ReplaceCommand(selection, replaceString);
        this._executeEditorCommand("replace", command);
        this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));
        this.research(true);
      } else {
        this._decorations.setStartPosition(this._editor.getPosition());
        this._setCurrentFindMatch(nextMatch.range);
      }
    }
  }
  _findMatches(findScopes, captureMatches, limitResultCount) {
    const searchRanges = (findScopes || [null]).map((scope) => FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));
    return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(105) : null, captureMatches, limitResultCount);
  }
  replaceAll() {
    if (!this._hasMatches()) {
      return;
    }
    const findScopes = this._decorations.getFindScopes();
    if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {
      this._largeReplaceAll();
    } else {
      this._regularReplaceAll(findScopes);
    }
    this.research(false);
  }
  _largeReplaceAll() {
    const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(105) : null);
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return;
    }
    let searchRegex = searchData.regex;
    if (!searchRegex.multiline) {
      let mod = "mu";
      if (searchRegex.ignoreCase) {
        mod += "i";
      }
      if (searchRegex.global) {
        mod += "g";
      }
      searchRegex = new RegExp(searchRegex.source, mod);
    }
    const model = this._editor.getModel();
    const modelText = model.getValue(1);
    const fullModelRange = model.getFullModelRange();
    const replacePattern = this._getReplacePattern();
    let resultText;
    const preserveCase = this._state.preserveCase;
    if (replacePattern.hasReplacementPatterns || preserveCase) {
      resultText = modelText.replace(searchRegex, function() {
        return replacePattern.buildReplaceString(arguments, preserveCase);
      });
    } else {
      resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));
    }
    let command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());
    this._executeEditorCommand("replaceAll", command);
  }
  _regularReplaceAll(findScopes) {
    const replacePattern = this._getReplacePattern();
    let matches = this._findMatches(findScopes, replacePattern.hasReplacementPatterns || this._state.preserveCase, 1073741824);
    let replaceStrings = [];
    for (let i = 0, len = matches.length; i < len; i++) {
      replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);
    }
    let command = new ReplaceAllCommand(this._editor.getSelection(), matches.map((m) => m.range), replaceStrings);
    this._executeEditorCommand("replaceAll", command);
  }
  selectAllMatches() {
    if (!this._hasMatches()) {
      return;
    }
    let findScopes = this._decorations.getFindScopes();
    let matches = this._findMatches(findScopes, false, 1073741824);
    let selections = matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));
    let editorSelection = this._editor.getSelection();
    for (let i = 0, len = selections.length; i < len; i++) {
      let sel = selections[i];
      if (sel.equalsRange(editorSelection)) {
        selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));
        break;
      }
    }
    this._editor.setSelections(selections);
  }
  _executeEditorCommand(source, command) {
    try {
      this._ignoreModelContentChanged = true;
      this._editor.pushUndoStop();
      this._editor.executeCommand(source, command);
      this._editor.pushUndoStop();
    } finally {
      this._ignoreModelContentChanged = false;
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/checkbox/checkbox.js
var defaultOpts = {
  inputActiveOptionBorder: Color.fromHex("#007ACC00"),
  inputActiveOptionForeground: Color.fromHex("#FFFFFF"),
  inputActiveOptionBackground: Color.fromHex("#0E639C50")
};
var Checkbox = class extends Widget {
  constructor(opts) {
    super();
    this._onChange = this._register(new Emitter2());
    this.onChange = this._onChange.event;
    this._onKeyDown = this._register(new Emitter2());
    this.onKeyDown = this._onKeyDown.event;
    this._opts = Object.assign(Object.assign({}, defaultOpts), opts);
    this._checked = this._opts.isChecked;
    const classes = ["monaco-custom-checkbox"];
    if (this._opts.icon) {
      classes.push(this._opts.icon.classNames);
    } else {
      classes.push("codicon");
    }
    if (this._opts.actionClassName) {
      classes.push(this._opts.actionClassName);
    }
    classes.push(this._checked ? "checked" : "unchecked");
    this.domNode = document.createElement("div");
    this.domNode.title = this._opts.title;
    this.domNode.className = classes.join(" ");
    this.domNode.tabIndex = 0;
    this.domNode.setAttribute("role", "checkbox");
    this.domNode.setAttribute("aria-checked", String(this._checked));
    this.domNode.setAttribute("aria-label", this._opts.title);
    this.applyStyles();
    this.onclick(this.domNode, (ev) => {
      this.checked = !this._checked;
      this._onChange.fire(false);
      ev.preventDefault();
    });
    this.ignoreGesture(this.domNode);
    this.onkeydown(this.domNode, (keyboardEvent) => {
      if (keyboardEvent.keyCode === 10 || keyboardEvent.keyCode === 3) {
        this.checked = !this._checked;
        this._onChange.fire(true);
        keyboardEvent.preventDefault();
        return;
      }
      this._onKeyDown.fire(keyboardEvent);
    });
  }
  get enabled() {
    return this.domNode.getAttribute("aria-disabled") !== "true";
  }
  focus() {
    this.domNode.focus();
  }
  get checked() {
    return this._checked;
  }
  set checked(newIsChecked) {
    this._checked = newIsChecked;
    this.domNode.setAttribute("aria-checked", String(this._checked));
    if (this._checked) {
      this.domNode.classList.add("checked");
    } else {
      this.domNode.classList.remove("checked");
    }
    this.applyStyles();
  }
  width() {
    return 2 + 2 + 2 + 16;
  }
  style(styles40) {
    if (styles40.inputActiveOptionBorder) {
      this._opts.inputActiveOptionBorder = styles40.inputActiveOptionBorder;
    }
    if (styles40.inputActiveOptionForeground) {
      this._opts.inputActiveOptionForeground = styles40.inputActiveOptionForeground;
    }
    if (styles40.inputActiveOptionBackground) {
      this._opts.inputActiveOptionBackground = styles40.inputActiveOptionBackground;
    }
    this.applyStyles();
  }
  applyStyles() {
    if (this.domNode) {
      this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder ? this._opts.inputActiveOptionBorder.toString() : "transparent";
      this.domNode.style.color = this._checked && this._opts.inputActiveOptionForeground ? this._opts.inputActiveOptionForeground.toString() : "inherit";
      this.domNode.style.backgroundColor = this._checked && this._opts.inputActiveOptionBackground ? this._opts.inputActiveOptionBackground.toString() : "transparent";
    }
  }
  enable() {
    this.domNode.tabIndex = 0;
    this.domNode.setAttribute("aria-disabled", String(false));
  }
  disable() {
    removeTabIndexAndUpdateFocus(this.domNode);
    this.domNode.setAttribute("aria-disabled", String(true));
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInputCheckboxes.js
var NLS_CASE_SENSITIVE_CHECKBOX_LABEL = localize("caseDescription", "Match Case");
var NLS_WHOLE_WORD_CHECKBOX_LABEL = localize("wordsDescription", "Match Whole Word");
var NLS_REGEX_CHECKBOX_LABEL = localize("regexDescription", "Use Regular Expression");
var CaseSensitiveCheckbox = class extends Checkbox {
  constructor(opts) {
    super({
      icon: Codicon.caseSensitive,
      title: NLS_CASE_SENSITIVE_CHECKBOX_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }
};
var WholeWordsCheckbox = class extends Checkbox {
  constructor(opts) {
    super({
      icon: Codicon.wholeWord,
      title: NLS_WHOLE_WORD_CHECKBOX_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }
};
var RegexCheckbox = class extends Checkbox {
  constructor(opts) {
    super({
      icon: Codicon.regex,
      title: NLS_REGEX_CHECKBOX_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/findOptionsWidget.js
var FindOptionsWidget = class extends Widget {
  constructor(editor3, state, keybindingService, themeService) {
    super();
    this._hideSoon = this._register(new RunOnceScheduler(() => this._hide(), 2e3));
    this._isVisible = false;
    this._editor = editor3;
    this._state = state;
    this._keybindingService = keybindingService;
    this._domNode = document.createElement("div");
    this._domNode.className = "findOptionsWidget";
    this._domNode.style.display = "none";
    this._domNode.style.top = "10px";
    this._domNode.setAttribute("role", "presentation");
    this._domNode.setAttribute("aria-hidden", "true");
    const inputActiveOptionBorderColor = themeService.getColorTheme().getColor(inputActiveOptionBorder);
    const inputActiveOptionForegroundColor = themeService.getColorTheme().getColor(inputActiveOptionForeground);
    const inputActiveOptionBackgroundColor = themeService.getColorTheme().getColor(inputActiveOptionBackground);
    this.caseSensitive = this._register(new CaseSensitiveCheckbox({
      appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
      isChecked: this._state.matchCase,
      inputActiveOptionBorder: inputActiveOptionBorderColor,
      inputActiveOptionForeground: inputActiveOptionForegroundColor,
      inputActiveOptionBackground: inputActiveOptionBackgroundColor
    }));
    this._domNode.appendChild(this.caseSensitive.domNode);
    this._register(this.caseSensitive.onChange(() => {
      this._state.change({
        matchCase: this.caseSensitive.checked
      }, false);
    }));
    this.wholeWords = this._register(new WholeWordsCheckbox({
      appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
      isChecked: this._state.wholeWord,
      inputActiveOptionBorder: inputActiveOptionBorderColor,
      inputActiveOptionForeground: inputActiveOptionForegroundColor,
      inputActiveOptionBackground: inputActiveOptionBackgroundColor
    }));
    this._domNode.appendChild(this.wholeWords.domNode);
    this._register(this.wholeWords.onChange(() => {
      this._state.change({
        wholeWord: this.wholeWords.checked
      }, false);
    }));
    this.regex = this._register(new RegexCheckbox({
      appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
      isChecked: this._state.isRegex,
      inputActiveOptionBorder: inputActiveOptionBorderColor,
      inputActiveOptionForeground: inputActiveOptionForegroundColor,
      inputActiveOptionBackground: inputActiveOptionBackgroundColor
    }));
    this._domNode.appendChild(this.regex.domNode);
    this._register(this.regex.onChange(() => {
      this._state.change({
        isRegex: this.regex.checked
      }, false);
    }));
    this._editor.addOverlayWidget(this);
    this._register(this._state.onFindReplaceStateChange((e) => {
      let somethingChanged = false;
      if (e.isRegex) {
        this.regex.checked = this._state.isRegex;
        somethingChanged = true;
      }
      if (e.wholeWord) {
        this.wholeWords.checked = this._state.wholeWord;
        somethingChanged = true;
      }
      if (e.matchCase) {
        this.caseSensitive.checked = this._state.matchCase;
        somethingChanged = true;
      }
      if (!this._state.isRevealed && somethingChanged) {
        this._revealTemporarily();
      }
    }));
    this._register(addDisposableNonBubblingMouseOutListener(this._domNode, (e) => this._onMouseOut()));
    this._register(addDisposableListener(this._domNode, "mouseover", (e) => this._onMouseOver()));
    this._applyTheme(themeService.getColorTheme());
    this._register(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
  }
  _keybindingLabelFor(actionId) {
    let kb = this._keybindingService.lookupKeybinding(actionId);
    if (!kb) {
      return "";
    }
    return ` (${kb.getLabel()})`;
  }
  dispose() {
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  getId() {
    return FindOptionsWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 0
    };
  }
  highlightFindOptions() {
    this._revealTemporarily();
  }
  _revealTemporarily() {
    this._show();
    this._hideSoon.schedule();
  }
  _onMouseOut() {
    this._hideSoon.schedule();
  }
  _onMouseOver() {
    this._hideSoon.cancel();
  }
  _show() {
    if (this._isVisible) {
      return;
    }
    this._isVisible = true;
    this._domNode.style.display = "block";
  }
  _hide() {
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    this._domNode.style.display = "none";
  }
  _applyTheme(theme6) {
    let inputStyles = {
      inputActiveOptionBorder: theme6.getColor(inputActiveOptionBorder),
      inputActiveOptionForeground: theme6.getColor(inputActiveOptionForeground),
      inputActiveOptionBackground: theme6.getColor(inputActiveOptionBackground)
    };
    this.caseSensitive.style(inputStyles);
    this.wholeWords.style(inputStyles);
    this.regex.style(inputStyles);
  }
};
FindOptionsWidget.ID = "editor.contrib.findOptionsWidget";
registerThemingParticipant((theme6, collector) => {
  const widgetBackground = theme6.getColor(editorWidgetBackground);
  if (widgetBackground) {
    collector.addRule(`.monaco-editor .findOptionsWidget { background-color: ${widgetBackground}; }`);
  }
  const widgetForeground = theme6.getColor(editorWidgetForeground);
  if (widgetForeground) {
    collector.addRule(`.monaco-editor .findOptionsWidget { color: ${widgetForeground}; }`);
  }
  const widgetShadowColor = theme6.getColor(widgetShadow);
  if (widgetShadowColor) {
    collector.addRule(`.monaco-editor .findOptionsWidget { box-shadow: 0 2px 8px ${widgetShadowColor}; }`);
  }
  const hcBorder = theme6.getColor(contrastBorder);
  if (hcBorder) {
    collector.addRule(`.monaco-editor .findOptionsWidget { border: 2px solid ${hcBorder}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/findState.js
function effectiveOptionValue(override, value) {
  if (override === 1) {
    return true;
  }
  if (override === 2) {
    return false;
  }
  return value;
}
var FindReplaceState = class extends Disposable {
  constructor() {
    super();
    this._onFindReplaceStateChange = this._register(new Emitter2());
    this.onFindReplaceStateChange = this._onFindReplaceStateChange.event;
    this._searchString = "";
    this._replaceString = "";
    this._isRevealed = false;
    this._isReplaceRevealed = false;
    this._isRegex = false;
    this._isRegexOverride = 0;
    this._wholeWord = false;
    this._wholeWordOverride = 0;
    this._matchCase = false;
    this._matchCaseOverride = 0;
    this._preserveCase = false;
    this._preserveCaseOverride = 0;
    this._searchScope = null;
    this._matchesPosition = 0;
    this._matchesCount = 0;
    this._currentMatch = null;
    this._loop = true;
  }
  get searchString() {
    return this._searchString;
  }
  get replaceString() {
    return this._replaceString;
  }
  get isRevealed() {
    return this._isRevealed;
  }
  get isReplaceRevealed() {
    return this._isReplaceRevealed;
  }
  get isRegex() {
    return effectiveOptionValue(this._isRegexOverride, this._isRegex);
  }
  get wholeWord() {
    return effectiveOptionValue(this._wholeWordOverride, this._wholeWord);
  }
  get matchCase() {
    return effectiveOptionValue(this._matchCaseOverride, this._matchCase);
  }
  get preserveCase() {
    return effectiveOptionValue(this._preserveCaseOverride, this._preserveCase);
  }
  get actualIsRegex() {
    return this._isRegex;
  }
  get actualWholeWord() {
    return this._wholeWord;
  }
  get actualMatchCase() {
    return this._matchCase;
  }
  get actualPreserveCase() {
    return this._preserveCase;
  }
  get searchScope() {
    return this._searchScope;
  }
  get matchesPosition() {
    return this._matchesPosition;
  }
  get matchesCount() {
    return this._matchesCount;
  }
  get currentMatch() {
    return this._currentMatch;
  }
  changeMatchInfo(matchesPosition, matchesCount, currentMatch) {
    let changeEvent = {
      moveCursor: false,
      updateHistory: false,
      searchString: false,
      replaceString: false,
      isRevealed: false,
      isReplaceRevealed: false,
      isRegex: false,
      wholeWord: false,
      matchCase: false,
      preserveCase: false,
      searchScope: false,
      matchesPosition: false,
      matchesCount: false,
      currentMatch: false,
      loop: false
    };
    let somethingChanged = false;
    if (matchesCount === 0) {
      matchesPosition = 0;
    }
    if (matchesPosition > matchesCount) {
      matchesPosition = matchesCount;
    }
    if (this._matchesPosition !== matchesPosition) {
      this._matchesPosition = matchesPosition;
      changeEvent.matchesPosition = true;
      somethingChanged = true;
    }
    if (this._matchesCount !== matchesCount) {
      this._matchesCount = matchesCount;
      changeEvent.matchesCount = true;
      somethingChanged = true;
    }
    if (typeof currentMatch !== "undefined") {
      if (!Range2.equalsRange(this._currentMatch, currentMatch)) {
        this._currentMatch = currentMatch;
        changeEvent.currentMatch = true;
        somethingChanged = true;
      }
    }
    if (somethingChanged) {
      this._onFindReplaceStateChange.fire(changeEvent);
    }
  }
  change(newState, moveCursor, updateHistory = true) {
    var _a5;
    let changeEvent = {
      moveCursor,
      updateHistory,
      searchString: false,
      replaceString: false,
      isRevealed: false,
      isReplaceRevealed: false,
      isRegex: false,
      wholeWord: false,
      matchCase: false,
      preserveCase: false,
      searchScope: false,
      matchesPosition: false,
      matchesCount: false,
      currentMatch: false,
      loop: false
    };
    let somethingChanged = false;
    const oldEffectiveIsRegex = this.isRegex;
    const oldEffectiveWholeWords = this.wholeWord;
    const oldEffectiveMatchCase = this.matchCase;
    const oldEffectivePreserveCase = this.preserveCase;
    if (typeof newState.searchString !== "undefined") {
      if (this._searchString !== newState.searchString) {
        this._searchString = newState.searchString;
        changeEvent.searchString = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.replaceString !== "undefined") {
      if (this._replaceString !== newState.replaceString) {
        this._replaceString = newState.replaceString;
        changeEvent.replaceString = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isRevealed !== "undefined") {
      if (this._isRevealed !== newState.isRevealed) {
        this._isRevealed = newState.isRevealed;
        changeEvent.isRevealed = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isReplaceRevealed !== "undefined") {
      if (this._isReplaceRevealed !== newState.isReplaceRevealed) {
        this._isReplaceRevealed = newState.isReplaceRevealed;
        changeEvent.isReplaceRevealed = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isRegex !== "undefined") {
      this._isRegex = newState.isRegex;
    }
    if (typeof newState.wholeWord !== "undefined") {
      this._wholeWord = newState.wholeWord;
    }
    if (typeof newState.matchCase !== "undefined") {
      this._matchCase = newState.matchCase;
    }
    if (typeof newState.preserveCase !== "undefined") {
      this._preserveCase = newState.preserveCase;
    }
    if (typeof newState.searchScope !== "undefined") {
      if (!((_a5 = newState.searchScope) === null || _a5 === void 0 ? void 0 : _a5.every((newSearchScope) => {
        var _a6;
        return (_a6 = this._searchScope) === null || _a6 === void 0 ? void 0 : _a6.some((existingSearchScope) => {
          return !Range2.equalsRange(existingSearchScope, newSearchScope);
        });
      }))) {
        this._searchScope = newState.searchScope;
        changeEvent.searchScope = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.loop !== "undefined") {
      if (this._loop !== newState.loop) {
        this._loop = newState.loop;
        changeEvent.loop = true;
        somethingChanged = true;
      }
    }
    this._isRegexOverride = typeof newState.isRegexOverride !== "undefined" ? newState.isRegexOverride : 0;
    this._wholeWordOverride = typeof newState.wholeWordOverride !== "undefined" ? newState.wholeWordOverride : 0;
    this._matchCaseOverride = typeof newState.matchCaseOverride !== "undefined" ? newState.matchCaseOverride : 0;
    this._preserveCaseOverride = typeof newState.preserveCaseOverride !== "undefined" ? newState.preserveCaseOverride : 0;
    if (oldEffectiveIsRegex !== this.isRegex) {
      somethingChanged = true;
      changeEvent.isRegex = true;
    }
    if (oldEffectiveWholeWords !== this.wholeWord) {
      somethingChanged = true;
      changeEvent.wholeWord = true;
    }
    if (oldEffectiveMatchCase !== this.matchCase) {
      somethingChanged = true;
      changeEvent.matchCase = true;
    }
    if (oldEffectivePreserveCase !== this.preserveCase) {
      somethingChanged = true;
      changeEvent.preserveCase = true;
    }
    if (somethingChanged) {
      this._onFindReplaceStateChange.fire(changeEvent);
    }
  }
  canNavigateBack() {
    return this.canNavigateInLoop() || this.matchesPosition !== 1;
  }
  canNavigateForward() {
    return this.canNavigateInLoop() || this.matchesPosition < this.matchesCount;
  }
  canNavigateInLoop() {
    return this._loop || this.matchesCount >= MATCHES_LIMIT;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInput.js
var NLS_DEFAULT_LABEL = localize("defaultLabel", "input");
var FindInput = class extends Widget {
  constructor(parent2, contextViewProvider, _showOptionButtons, options) {
    super();
    this._showOptionButtons = _showOptionButtons;
    this.fixFocusOnOptionClickEnabled = true;
    this._onDidOptionChange = this._register(new Emitter2());
    this.onDidOptionChange = this._onDidOptionChange.event;
    this._onKeyDown = this._register(new Emitter2());
    this.onKeyDown = this._onKeyDown.event;
    this._onMouseDown = this._register(new Emitter2());
    this.onMouseDown = this._onMouseDown.event;
    this._onInput = this._register(new Emitter2());
    this._onKeyUp = this._register(new Emitter2());
    this._onCaseSensitiveKeyDown = this._register(new Emitter2());
    this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event;
    this._onRegexKeyDown = this._register(new Emitter2());
    this.onRegexKeyDown = this._onRegexKeyDown.event;
    this._lastHighlightFindOptions = 0;
    this.contextViewProvider = contextViewProvider;
    this.placeholder = options.placeholder || "";
    this.validation = options.validation;
    this.label = options.label || NLS_DEFAULT_LABEL;
    this.inputActiveOptionBorder = options.inputActiveOptionBorder;
    this.inputActiveOptionForeground = options.inputActiveOptionForeground;
    this.inputActiveOptionBackground = options.inputActiveOptionBackground;
    this.inputBackground = options.inputBackground;
    this.inputForeground = options.inputForeground;
    this.inputBorder = options.inputBorder;
    this.inputValidationInfoBorder = options.inputValidationInfoBorder;
    this.inputValidationInfoBackground = options.inputValidationInfoBackground;
    this.inputValidationInfoForeground = options.inputValidationInfoForeground;
    this.inputValidationWarningBorder = options.inputValidationWarningBorder;
    this.inputValidationWarningBackground = options.inputValidationWarningBackground;
    this.inputValidationWarningForeground = options.inputValidationWarningForeground;
    this.inputValidationErrorBorder = options.inputValidationErrorBorder;
    this.inputValidationErrorBackground = options.inputValidationErrorBackground;
    this.inputValidationErrorForeground = options.inputValidationErrorForeground;
    const appendCaseSensitiveLabel = options.appendCaseSensitiveLabel || "";
    const appendWholeWordsLabel = options.appendWholeWordsLabel || "";
    const appendRegexLabel = options.appendRegexLabel || "";
    const history = options.history || [];
    const flexibleHeight = !!options.flexibleHeight;
    const flexibleWidth = !!options.flexibleWidth;
    const flexibleMaxHeight = options.flexibleMaxHeight;
    this.domNode = document.createElement("div");
    addClass(this.domNode, "monaco-findInput");
    this.inputBox = this._register(new HistoryInputBox(this.domNode, this.contextViewProvider, {
      placeholder: this.placeholder || "",
      ariaLabel: this.label || "",
      validationOptions: {
        validation: this.validation
      },
      inputBackground: this.inputBackground,
      inputForeground: this.inputForeground,
      inputBorder: this.inputBorder,
      inputValidationInfoBackground: this.inputValidationInfoBackground,
      inputValidationInfoForeground: this.inputValidationInfoForeground,
      inputValidationInfoBorder: this.inputValidationInfoBorder,
      inputValidationWarningBackground: this.inputValidationWarningBackground,
      inputValidationWarningForeground: this.inputValidationWarningForeground,
      inputValidationWarningBorder: this.inputValidationWarningBorder,
      inputValidationErrorBackground: this.inputValidationErrorBackground,
      inputValidationErrorForeground: this.inputValidationErrorForeground,
      inputValidationErrorBorder: this.inputValidationErrorBorder,
      history,
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight
    }));
    this.regex = this._register(new RegexCheckbox({
      appendTitle: appendRegexLabel,
      isChecked: false,
      inputActiveOptionBorder: this.inputActiveOptionBorder,
      inputActiveOptionForeground: this.inputActiveOptionForeground,
      inputActiveOptionBackground: this.inputActiveOptionBackground
    }));
    this._register(this.regex.onChange((viaKeyboard) => {
      this._onDidOptionChange.fire(viaKeyboard);
      if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
        this.inputBox.focus();
      }
      this.validate();
    }));
    this._register(this.regex.onKeyDown((e) => {
      this._onRegexKeyDown.fire(e);
    }));
    this.wholeWords = this._register(new WholeWordsCheckbox({
      appendTitle: appendWholeWordsLabel,
      isChecked: false,
      inputActiveOptionBorder: this.inputActiveOptionBorder,
      inputActiveOptionForeground: this.inputActiveOptionForeground,
      inputActiveOptionBackground: this.inputActiveOptionBackground
    }));
    this._register(this.wholeWords.onChange((viaKeyboard) => {
      this._onDidOptionChange.fire(viaKeyboard);
      if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
        this.inputBox.focus();
      }
      this.validate();
    }));
    this.caseSensitive = this._register(new CaseSensitiveCheckbox({
      appendTitle: appendCaseSensitiveLabel,
      isChecked: false,
      inputActiveOptionBorder: this.inputActiveOptionBorder,
      inputActiveOptionForeground: this.inputActiveOptionForeground,
      inputActiveOptionBackground: this.inputActiveOptionBackground
    }));
    this._register(this.caseSensitive.onChange((viaKeyboard) => {
      this._onDidOptionChange.fire(viaKeyboard);
      if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
        this.inputBox.focus();
      }
      this.validate();
    }));
    this._register(this.caseSensitive.onKeyDown((e) => {
      this._onCaseSensitiveKeyDown.fire(e);
    }));
    if (this._showOptionButtons) {
      this.inputBox.paddingRight = this.caseSensitive.width() + this.wholeWords.width() + this.regex.width();
    }
    let indexes = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];
    this.onkeydown(this.domNode, (event) => {
      if (event.equals(15) || event.equals(17) || event.equals(9)) {
        let index2 = indexes.indexOf(document.activeElement);
        if (index2 >= 0) {
          let newIndex = -1;
          if (event.equals(17)) {
            newIndex = (index2 + 1) % indexes.length;
          } else if (event.equals(15)) {
            if (index2 === 0) {
              newIndex = indexes.length - 1;
            } else {
              newIndex = index2 - 1;
            }
          }
          if (event.equals(9)) {
            indexes[index2].blur();
          } else if (newIndex >= 0) {
            indexes[newIndex].focus();
          }
          EventHelper.stop(event, true);
        }
      }
    });
    let controls = document.createElement("div");
    controls.className = "controls";
    controls.style.display = this._showOptionButtons ? "block" : "none";
    controls.appendChild(this.caseSensitive.domNode);
    controls.appendChild(this.wholeWords.domNode);
    controls.appendChild(this.regex.domNode);
    this.domNode.appendChild(controls);
    if (parent2) {
      parent2.appendChild(this.domNode);
    }
    this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));
    this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));
    this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());
    this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));
  }
  enable() {
    removeClass(this.domNode, "disabled");
    this.inputBox.enable();
    this.regex.enable();
    this.wholeWords.enable();
    this.caseSensitive.enable();
  }
  disable() {
    addClass(this.domNode, "disabled");
    this.inputBox.disable();
    this.regex.disable();
    this.wholeWords.disable();
    this.caseSensitive.disable();
  }
  setFocusInputOnOptionClick(value) {
    this.fixFocusOnOptionClickEnabled = value;
  }
  setEnabled(enabled) {
    if (enabled) {
      this.enable();
    } else {
      this.disable();
    }
  }
  getValue() {
    return this.inputBox.value;
  }
  setValue(value) {
    if (this.inputBox.value !== value) {
      this.inputBox.value = value;
    }
  }
  style(styles40) {
    this.inputActiveOptionBorder = styles40.inputActiveOptionBorder;
    this.inputActiveOptionForeground = styles40.inputActiveOptionForeground;
    this.inputActiveOptionBackground = styles40.inputActiveOptionBackground;
    this.inputBackground = styles40.inputBackground;
    this.inputForeground = styles40.inputForeground;
    this.inputBorder = styles40.inputBorder;
    this.inputValidationInfoBackground = styles40.inputValidationInfoBackground;
    this.inputValidationInfoForeground = styles40.inputValidationInfoForeground;
    this.inputValidationInfoBorder = styles40.inputValidationInfoBorder;
    this.inputValidationWarningBackground = styles40.inputValidationWarningBackground;
    this.inputValidationWarningForeground = styles40.inputValidationWarningForeground;
    this.inputValidationWarningBorder = styles40.inputValidationWarningBorder;
    this.inputValidationErrorBackground = styles40.inputValidationErrorBackground;
    this.inputValidationErrorForeground = styles40.inputValidationErrorForeground;
    this.inputValidationErrorBorder = styles40.inputValidationErrorBorder;
    this.applyStyles();
  }
  applyStyles() {
    if (this.domNode) {
      const checkBoxStyles = {
        inputActiveOptionBorder: this.inputActiveOptionBorder,
        inputActiveOptionForeground: this.inputActiveOptionForeground,
        inputActiveOptionBackground: this.inputActiveOptionBackground
      };
      this.regex.style(checkBoxStyles);
      this.wholeWords.style(checkBoxStyles);
      this.caseSensitive.style(checkBoxStyles);
      const inputBoxStyles = {
        inputBackground: this.inputBackground,
        inputForeground: this.inputForeground,
        inputBorder: this.inputBorder,
        inputValidationInfoBackground: this.inputValidationInfoBackground,
        inputValidationInfoForeground: this.inputValidationInfoForeground,
        inputValidationInfoBorder: this.inputValidationInfoBorder,
        inputValidationWarningBackground: this.inputValidationWarningBackground,
        inputValidationWarningForeground: this.inputValidationWarningForeground,
        inputValidationWarningBorder: this.inputValidationWarningBorder,
        inputValidationErrorBackground: this.inputValidationErrorBackground,
        inputValidationErrorForeground: this.inputValidationErrorForeground,
        inputValidationErrorBorder: this.inputValidationErrorBorder
      };
      this.inputBox.style(inputBoxStyles);
    }
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getCaseSensitive() {
    return this.caseSensitive.checked;
  }
  setCaseSensitive(value) {
    this.caseSensitive.checked = value;
  }
  getWholeWords() {
    return this.wholeWords.checked;
  }
  setWholeWords(value) {
    this.wholeWords.checked = value;
  }
  getRegex() {
    return this.regex.checked;
  }
  setRegex(value) {
    this.regex.checked = value;
    this.validate();
  }
  focusOnCaseSensitive() {
    this.caseSensitive.focus();
  }
  highlightFindOptions() {
    removeClass(this.domNode, "highlight-" + this._lastHighlightFindOptions);
    this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions;
    addClass(this.domNode, "highlight-" + this._lastHighlightFindOptions);
  }
  validate() {
    this.inputBox.validate();
  }
  clearMessage() {
    this.inputBox.hideMessage();
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/replaceInput.js
var NLS_DEFAULT_LABEL2 = localize("defaultLabel", "input");
var NLS_PRESERVE_CASE_LABEL = localize("label.preserveCaseCheckbox", "Preserve Case");
var PreserveCaseCheckbox = class extends Checkbox {
  constructor(opts) {
    super({
      icon: Codicon.preserveCase,
      title: NLS_PRESERVE_CASE_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }
};
var ReplaceInput = class extends Widget {
  constructor(parent2, contextViewProvider, _showOptionButtons, options) {
    super();
    this._showOptionButtons = _showOptionButtons;
    this.fixFocusOnOptionClickEnabled = true;
    this.cachedOptionsWidth = 0;
    this._onDidOptionChange = this._register(new Emitter2());
    this.onDidOptionChange = this._onDidOptionChange.event;
    this._onKeyDown = this._register(new Emitter2());
    this.onKeyDown = this._onKeyDown.event;
    this._onMouseDown = this._register(new Emitter2());
    this._onInput = this._register(new Emitter2());
    this._onKeyUp = this._register(new Emitter2());
    this._onPreserveCaseKeyDown = this._register(new Emitter2());
    this.onPreserveCaseKeyDown = this._onPreserveCaseKeyDown.event;
    this.contextViewProvider = contextViewProvider;
    this.placeholder = options.placeholder || "";
    this.validation = options.validation;
    this.label = options.label || NLS_DEFAULT_LABEL2;
    this.inputActiveOptionBorder = options.inputActiveOptionBorder;
    this.inputActiveOptionForeground = options.inputActiveOptionForeground;
    this.inputActiveOptionBackground = options.inputActiveOptionBackground;
    this.inputBackground = options.inputBackground;
    this.inputForeground = options.inputForeground;
    this.inputBorder = options.inputBorder;
    this.inputValidationInfoBorder = options.inputValidationInfoBorder;
    this.inputValidationInfoBackground = options.inputValidationInfoBackground;
    this.inputValidationInfoForeground = options.inputValidationInfoForeground;
    this.inputValidationWarningBorder = options.inputValidationWarningBorder;
    this.inputValidationWarningBackground = options.inputValidationWarningBackground;
    this.inputValidationWarningForeground = options.inputValidationWarningForeground;
    this.inputValidationErrorBorder = options.inputValidationErrorBorder;
    this.inputValidationErrorBackground = options.inputValidationErrorBackground;
    this.inputValidationErrorForeground = options.inputValidationErrorForeground;
    const history = options.history || [];
    const flexibleHeight = !!options.flexibleHeight;
    const flexibleWidth = !!options.flexibleWidth;
    const flexibleMaxHeight = options.flexibleMaxHeight;
    this.domNode = document.createElement("div");
    addClass(this.domNode, "monaco-findInput");
    this.inputBox = this._register(new HistoryInputBox(this.domNode, this.contextViewProvider, {
      ariaLabel: this.label || "",
      placeholder: this.placeholder || "",
      validationOptions: {
        validation: this.validation
      },
      inputBackground: this.inputBackground,
      inputForeground: this.inputForeground,
      inputBorder: this.inputBorder,
      inputValidationInfoBackground: this.inputValidationInfoBackground,
      inputValidationInfoForeground: this.inputValidationInfoForeground,
      inputValidationInfoBorder: this.inputValidationInfoBorder,
      inputValidationWarningBackground: this.inputValidationWarningBackground,
      inputValidationWarningForeground: this.inputValidationWarningForeground,
      inputValidationWarningBorder: this.inputValidationWarningBorder,
      inputValidationErrorBackground: this.inputValidationErrorBackground,
      inputValidationErrorForeground: this.inputValidationErrorForeground,
      inputValidationErrorBorder: this.inputValidationErrorBorder,
      history,
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight
    }));
    this.preserveCase = this._register(new PreserveCaseCheckbox({
      appendTitle: "",
      isChecked: false,
      inputActiveOptionBorder: this.inputActiveOptionBorder,
      inputActiveOptionForeground: this.inputActiveOptionForeground,
      inputActiveOptionBackground: this.inputActiveOptionBackground
    }));
    this._register(this.preserveCase.onChange((viaKeyboard) => {
      this._onDidOptionChange.fire(viaKeyboard);
      if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
        this.inputBox.focus();
      }
      this.validate();
    }));
    this._register(this.preserveCase.onKeyDown((e) => {
      this._onPreserveCaseKeyDown.fire(e);
    }));
    if (this._showOptionButtons) {
      this.cachedOptionsWidth = this.preserveCase.width();
    } else {
      this.cachedOptionsWidth = 0;
    }
    let indexes = [this.preserveCase.domNode];
    this.onkeydown(this.domNode, (event) => {
      if (event.equals(15) || event.equals(17) || event.equals(9)) {
        let index2 = indexes.indexOf(document.activeElement);
        if (index2 >= 0) {
          let newIndex = -1;
          if (event.equals(17)) {
            newIndex = (index2 + 1) % indexes.length;
          } else if (event.equals(15)) {
            if (index2 === 0) {
              newIndex = indexes.length - 1;
            } else {
              newIndex = index2 - 1;
            }
          }
          if (event.equals(9)) {
            indexes[index2].blur();
          } else if (newIndex >= 0) {
            indexes[newIndex].focus();
          }
          EventHelper.stop(event, true);
        }
      }
    });
    let controls = document.createElement("div");
    controls.className = "controls";
    controls.style.display = this._showOptionButtons ? "block" : "none";
    controls.appendChild(this.preserveCase.domNode);
    this.domNode.appendChild(controls);
    if (parent2) {
      parent2.appendChild(this.domNode);
    }
    this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));
    this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));
    this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());
    this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));
  }
  enable() {
    removeClass(this.domNode, "disabled");
    this.inputBox.enable();
    this.preserveCase.enable();
  }
  disable() {
    addClass(this.domNode, "disabled");
    this.inputBox.disable();
    this.preserveCase.disable();
  }
  setEnabled(enabled) {
    if (enabled) {
      this.enable();
    } else {
      this.disable();
    }
  }
  style(styles40) {
    this.inputActiveOptionBorder = styles40.inputActiveOptionBorder;
    this.inputActiveOptionForeground = styles40.inputActiveOptionForeground;
    this.inputActiveOptionBackground = styles40.inputActiveOptionBackground;
    this.inputBackground = styles40.inputBackground;
    this.inputForeground = styles40.inputForeground;
    this.inputBorder = styles40.inputBorder;
    this.inputValidationInfoBackground = styles40.inputValidationInfoBackground;
    this.inputValidationInfoForeground = styles40.inputValidationInfoForeground;
    this.inputValidationInfoBorder = styles40.inputValidationInfoBorder;
    this.inputValidationWarningBackground = styles40.inputValidationWarningBackground;
    this.inputValidationWarningForeground = styles40.inputValidationWarningForeground;
    this.inputValidationWarningBorder = styles40.inputValidationWarningBorder;
    this.inputValidationErrorBackground = styles40.inputValidationErrorBackground;
    this.inputValidationErrorForeground = styles40.inputValidationErrorForeground;
    this.inputValidationErrorBorder = styles40.inputValidationErrorBorder;
    this.applyStyles();
  }
  applyStyles() {
    if (this.domNode) {
      const checkBoxStyles = {
        inputActiveOptionBorder: this.inputActiveOptionBorder,
        inputActiveOptionForeground: this.inputActiveOptionForeground,
        inputActiveOptionBackground: this.inputActiveOptionBackground
      };
      this.preserveCase.style(checkBoxStyles);
      const inputBoxStyles = {
        inputBackground: this.inputBackground,
        inputForeground: this.inputForeground,
        inputBorder: this.inputBorder,
        inputValidationInfoBackground: this.inputValidationInfoBackground,
        inputValidationInfoForeground: this.inputValidationInfoForeground,
        inputValidationInfoBorder: this.inputValidationInfoBorder,
        inputValidationWarningBackground: this.inputValidationWarningBackground,
        inputValidationWarningForeground: this.inputValidationWarningForeground,
        inputValidationWarningBorder: this.inputValidationWarningBorder,
        inputValidationErrorBackground: this.inputValidationErrorBackground,
        inputValidationErrorForeground: this.inputValidationErrorForeground,
        inputValidationErrorBorder: this.inputValidationErrorBorder
      };
      this.inputBox.style(inputBoxStyles);
    }
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getPreserveCase() {
    return this.preserveCase.checked;
  }
  setPreserveCase(value) {
    this.preserveCase.checked = value;
  }
  focusOnPreserve() {
    this.preserveCase.focus();
  }
  validate() {
    if (this.inputBox) {
      this.inputBox.validate();
    }
  }
  set width(newWidth) {
    this.inputBox.paddingRight = this.cachedOptionsWidth;
    this.inputBox.width = newWidth;
    this.domNode.style.width = newWidth + "px";
  }
  dispose() {
    super.dispose();
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/browser/contextScopedHistoryWidget.js
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param11 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var HistoryNavigationWidgetContext = "historyNavigationWidget";
var HistoryNavigationEnablementContext = "historyNavigationEnabled";
function bindContextScopedWidget(contextKeyService, widget, contextKey) {
  new RawContextKey(contextKey, widget).bindTo(contextKeyService);
}
function createWidgetScopedContextKeyService(contextKeyService, widget) {
  return contextKeyService.createScoped(widget.target);
}
function getContextScopedWidget(contextKeyService, contextKey) {
  return contextKeyService.getContext(document.activeElement).getValue(contextKey);
}
function createAndBindHistoryNavigationWidgetScopedContextKeyService(contextKeyService, widget) {
  const scopedContextKeyService = createWidgetScopedContextKeyService(contextKeyService, widget);
  bindContextScopedWidget(scopedContextKeyService, widget, HistoryNavigationWidgetContext);
  const historyNavigationEnablement = new RawContextKey(HistoryNavigationEnablementContext, true).bindTo(scopedContextKeyService);
  return {scopedContextKeyService, historyNavigationEnablement};
}
var ContextScopedFindInput = class ContextScopedFindInput2 extends FindInput {
  constructor(container, contextViewProvider, options, contextKeyService, showFindOptions = false) {
    super(container, contextViewProvider, showFindOptions, options);
    this._register(createAndBindHistoryNavigationWidgetScopedContextKeyService(contextKeyService, {target: this.inputBox.element, historyNavigator: this.inputBox}).scopedContextKeyService);
  }
};
ContextScopedFindInput = __decorate11([
  __param11(3, IContextKeyService)
], ContextScopedFindInput);
var ContextScopedReplaceInput = class ContextScopedReplaceInput2 extends ReplaceInput {
  constructor(container, contextViewProvider, options, contextKeyService, showReplaceOptions = false) {
    super(container, contextViewProvider, showReplaceOptions, options);
    this._register(createAndBindHistoryNavigationWidgetScopedContextKeyService(contextKeyService, {target: this.inputBox.element, historyNavigator: this.inputBox}).scopedContextKeyService);
  }
};
ContextScopedReplaceInput = __decorate11([
  __param11(3, IContextKeyService)
], ContextScopedReplaceInput);
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "history.showPrevious",
  weight: 200,
  when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetContext), ContextKeyExpr.equals(HistoryNavigationEnablementContext, true)),
  primary: 16,
  secondary: [512 | 16],
  handler: (accessor, arg2) => {
    const widget = getContextScopedWidget(accessor.get(IContextKeyService), HistoryNavigationWidgetContext);
    if (widget) {
      const historyInputBox = widget.historyNavigator;
      historyInputBox.showPreviousValue();
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "history.showNext",
  weight: 200,
  when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetContext), ContextKeyExpr.equals(HistoryNavigationEnablementContext, true)),
  primary: 18,
  secondary: [512 | 18],
  handler: (accessor, arg2) => {
    const widget = getContextScopedWidget(accessor.get(IContextKeyService), HistoryNavigationWidgetContext);
    if (widget) {
      const historyInputBox = widget.historyNavigator;
      historyInputBox.showNextValue();
    }
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/findWidget.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var findSelectionIcon = registerIcon("find-selection", Codicon.selection);
var findCollapsedIcon = registerIcon("find-collapsed", Codicon.chevronRight);
var findExpandedIcon = registerIcon("find-expanded", Codicon.chevronDown);
var findCloseIcon = registerIcon("find-close", Codicon.close);
var findReplaceIcon = registerIcon("find-replace", Codicon.replace);
var findReplaceAllIcon = registerIcon("find-replace-all", Codicon.replaceAll);
var findPreviousMatchIcon = registerIcon("find-previous-match", Codicon.arrowUp);
var findNextMatchIcon = registerIcon("find-next-match", Codicon.arrowDown);
var NLS_FIND_INPUT_LABEL = localize("label.find", "Find");
var NLS_FIND_INPUT_PLACEHOLDER = localize("placeholder.find", "Find");
var NLS_PREVIOUS_MATCH_BTN_LABEL = localize("label.previousMatchButton", "Previous match");
var NLS_NEXT_MATCH_BTN_LABEL = localize("label.nextMatchButton", "Next match");
var NLS_TOGGLE_SELECTION_FIND_TITLE = localize("label.toggleSelectionFind", "Find in selection");
var NLS_CLOSE_BTN_LABEL = localize("label.closeButton", "Close");
var NLS_REPLACE_INPUT_LABEL = localize("label.replace", "Replace");
var NLS_REPLACE_INPUT_PLACEHOLDER = localize("placeholder.replace", "Replace");
var NLS_REPLACE_BTN_LABEL = localize("label.replaceButton", "Replace");
var NLS_REPLACE_ALL_BTN_LABEL = localize("label.replaceAllButton", "Replace All");
var NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = localize("label.toggleReplaceButton", "Toggle Replace mode");
var NLS_MATCHES_COUNT_LIMIT_TITLE = localize("title.matchesCountLimit", "Only the first {0} results are highlighted, but all find operations work on the entire text.", MATCHES_LIMIT);
var NLS_MATCHES_LOCATION = localize("label.matchesLocation", "{0} of {1}");
var NLS_NO_RESULTS = localize("label.noResults", "No results");
var FIND_WIDGET_INITIAL_WIDTH = 419;
var PART_WIDTH = 275;
var FIND_INPUT_AREA_WIDTH = PART_WIDTH - 54;
var MAX_MATCHES_COUNT_WIDTH = 69;
var FIND_INPUT_AREA_HEIGHT = 33;
var ctrlEnterReplaceAllWarningPromptedKey = "ctrlEnterReplaceAll.windows.donotask";
var ctrlKeyMod = isMacintosh ? 256 : 2048;
var FindWidgetViewZone = class {
  constructor(afterLineNumber) {
    this.afterLineNumber = afterLineNumber;
    this.heightInPx = FIND_INPUT_AREA_HEIGHT;
    this.suppressMouseDown = false;
    this.domNode = document.createElement("div");
    this.domNode.className = "dock-find-viewzone";
  }
};
function stopPropagationForMultiLineUpwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionStart > 0) {
    event.stopPropagation();
    return;
  }
}
function stopPropagationForMultiLineDownwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionEnd < textarea.value.length) {
    event.stopPropagation();
    return;
  }
}
var FindWidget = class extends Widget {
  constructor(codeEditor, controller, state, contextViewProvider, keybindingService, contextKeyService, themeService, storageService, notificationService, storageKeysSyncRegistryService) {
    super();
    this._cachedHeight = null;
    this._codeEditor = codeEditor;
    this._controller = controller;
    this._state = state;
    this._contextViewProvider = contextViewProvider;
    this._keybindingService = keybindingService;
    this._contextKeyService = contextKeyService;
    this._storageService = storageService;
    this._notificationService = notificationService;
    storageKeysSyncRegistryService.registerStorageKey({key: ctrlEnterReplaceAllWarningPromptedKey, version: 1});
    this._ctrlEnterReplaceAllWarningPrompted = !!storageService.getBoolean(ctrlEnterReplaceAllWarningPromptedKey, 0);
    this._isVisible = false;
    this._isReplaceVisible = false;
    this._ignoreChangeEvent = false;
    this._updateHistoryDelayer = new Delayer(500);
    this._register(toDisposable(() => this._updateHistoryDelayer.cancel()));
    this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this._buildDomNode();
    this._updateButtons();
    this._tryUpdateWidgetWidth();
    this._findInput.inputBox.layout();
    this._register(this._codeEditor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(72)) {
        if (this._codeEditor.getOption(72)) {
          this._state.change({isReplaceRevealed: false}, false);
        }
        this._updateButtons();
      }
      if (e.hasChanged(117)) {
        this._tryUpdateWidgetWidth();
      }
      if (e.hasChanged(2)) {
        this.updateAccessibilitySupport();
      }
      if (e.hasChanged(29)) {
        const addExtraSpaceOnTop = this._codeEditor.getOption(29).addExtraSpaceOnTop;
        if (addExtraSpaceOnTop && !this._viewZone) {
          this._viewZone = new FindWidgetViewZone(0);
          this._showViewZone();
        }
        if (!addExtraSpaceOnTop && this._viewZone) {
          this._removeViewZone();
        }
      }
    }));
    this.updateAccessibilitySupport();
    this._register(this._codeEditor.onDidChangeCursorSelection(() => {
      if (this._isVisible) {
        this._updateToggleSelectionFindButton();
      }
    }));
    this._register(this._codeEditor.onDidFocusEditorWidget(() => __awaiter8(this, void 0, void 0, function* () {
      if (this._isVisible) {
        let globalBufferTerm = yield this._controller.getGlobalBufferTerm();
        if (globalBufferTerm && globalBufferTerm !== this._state.searchString) {
          this._state.change({searchString: globalBufferTerm}, true);
          this._findInput.select();
        }
      }
    })));
    this._findInputFocused = CONTEXT_FIND_INPUT_FOCUSED.bindTo(contextKeyService);
    this._findFocusTracker = this._register(trackFocus(this._findInput.inputBox.inputElement));
    this._register(this._findFocusTracker.onDidFocus(() => {
      this._findInputFocused.set(true);
      this._updateSearchScope();
    }));
    this._register(this._findFocusTracker.onDidBlur(() => {
      this._findInputFocused.set(false);
    }));
    this._replaceInputFocused = CONTEXT_REPLACE_INPUT_FOCUSED.bindTo(contextKeyService);
    this._replaceFocusTracker = this._register(trackFocus(this._replaceInput.inputBox.inputElement));
    this._register(this._replaceFocusTracker.onDidFocus(() => {
      this._replaceInputFocused.set(true);
      this._updateSearchScope();
    }));
    this._register(this._replaceFocusTracker.onDidBlur(() => {
      this._replaceInputFocused.set(false);
    }));
    this._codeEditor.addOverlayWidget(this);
    if (this._codeEditor.getOption(29).addExtraSpaceOnTop) {
      this._viewZone = new FindWidgetViewZone(0);
    }
    this._applyTheme(themeService.getColorTheme());
    this._register(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
    this._register(this._codeEditor.onDidChangeModel(() => {
      if (!this._isVisible) {
        return;
      }
      this._viewZoneId = void 0;
    }));
    this._register(this._codeEditor.onDidScrollChange((e) => {
      if (e.scrollTopChanged) {
        this._layoutViewZone();
        return;
      }
      setTimeout(() => {
        this._layoutViewZone();
      }, 0);
    }));
  }
  getId() {
    return FindWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    if (this._isVisible) {
      return {
        preference: 0
      };
    }
    return null;
  }
  _onStateChanged(e) {
    if (e.searchString) {
      try {
        this._ignoreChangeEvent = true;
        this._findInput.setValue(this._state.searchString);
      } finally {
        this._ignoreChangeEvent = false;
      }
      this._updateButtons();
    }
    if (e.replaceString) {
      this._replaceInput.inputBox.value = this._state.replaceString;
    }
    if (e.isRevealed) {
      if (this._state.isRevealed) {
        this._reveal();
      } else {
        this._hide(true);
      }
    }
    if (e.isReplaceRevealed) {
      if (this._state.isReplaceRevealed) {
        if (!this._codeEditor.getOption(72) && !this._isReplaceVisible) {
          this._isReplaceVisible = true;
          this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          this._updateButtons();
          this._replaceInput.inputBox.layout();
        }
      } else {
        if (this._isReplaceVisible) {
          this._isReplaceVisible = false;
          this._updateButtons();
        }
      }
    }
    if ((e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed)) {
      if (this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }
    if (e.isRegex) {
      this._findInput.setRegex(this._state.isRegex);
    }
    if (e.wholeWord) {
      this._findInput.setWholeWords(this._state.wholeWord);
    }
    if (e.matchCase) {
      this._findInput.setCaseSensitive(this._state.matchCase);
    }
    if (e.searchScope) {
      if (this._state.searchScope) {
        this._toggleSelectionFind.checked = true;
      } else {
        this._toggleSelectionFind.checked = false;
      }
      this._updateToggleSelectionFindButton();
    }
    if (e.searchString || e.matchesCount || e.matchesPosition) {
      let showRedOutline = this._state.searchString.length > 0 && this._state.matchesCount === 0;
      toggleClass(this._domNode, "no-results", showRedOutline);
      this._updateMatchesCount();
      this._updateButtons();
    }
    if (e.searchString || e.currentMatch) {
      this._layoutViewZone();
    }
    if (e.updateHistory) {
      this._delayedUpdateHistory();
    }
    if (e.loop) {
      this._updateButtons();
    }
  }
  _delayedUpdateHistory() {
    this._updateHistoryDelayer.trigger(this._updateHistory.bind(this));
  }
  _updateHistory() {
    if (this._state.searchString) {
      this._findInput.inputBox.addToHistory();
    }
    if (this._state.replaceString) {
      this._replaceInput.inputBox.addToHistory();
    }
  }
  _updateMatchesCount() {
    this._matchesCount.style.minWidth = MAX_MATCHES_COUNT_WIDTH + "px";
    if (this._state.matchesCount >= MATCHES_LIMIT) {
      this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;
    } else {
      this._matchesCount.title = "";
    }
    if (this._matchesCount.firstChild) {
      this._matchesCount.removeChild(this._matchesCount.firstChild);
    }
    let label;
    if (this._state.matchesCount > 0) {
      let matchesCount = String(this._state.matchesCount);
      if (this._state.matchesCount >= MATCHES_LIMIT) {
        matchesCount += "+";
      }
      let matchesPosition = String(this._state.matchesPosition);
      if (matchesPosition === "0") {
        matchesPosition = "?";
      }
      label = format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);
    } else {
      label = NLS_NO_RESULTS;
    }
    this._matchesCount.appendChild(document.createTextNode(label));
    alert(this._getAriaLabel(label, this._state.currentMatch, this._state.searchString));
    MAX_MATCHES_COUNT_WIDTH = Math.max(MAX_MATCHES_COUNT_WIDTH, this._matchesCount.clientWidth);
  }
  _getAriaLabel(label, currentMatch, searchString) {
    if (label === NLS_NO_RESULTS) {
      return searchString === "" ? localize("ariaSearchNoResultEmpty", "{0} found", label) : localize("ariaSearchNoResult", "{0} found for '{1}'", label, searchString);
    }
    if (currentMatch) {
      const ariaLabel = localize("ariaSearchNoResultWithLineNum", "{0} found for '{1}', at {2}", label, searchString, currentMatch.startLineNumber + ":" + currentMatch.startColumn);
      const model = this._codeEditor.getModel();
      if (model && currentMatch.startLineNumber <= model.getLineCount() && currentMatch.startLineNumber >= 1) {
        const lineContent = model.getLineContent(currentMatch.startLineNumber);
        return `${lineContent}, ${ariaLabel}`;
      }
      return ariaLabel;
    }
    return localize("ariaSearchNoResultWithLineNumNoCurrentMatch", "{0} found for '{1}'", label, searchString);
  }
  _updateToggleSelectionFindButton() {
    let selection = this._codeEditor.getSelection();
    let isSelection = selection ? selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn : false;
    let isChecked = this._toggleSelectionFind.checked;
    if (this._isVisible && (isChecked || isSelection)) {
      this._toggleSelectionFind.enable();
    } else {
      this._toggleSelectionFind.disable();
    }
  }
  _updateButtons() {
    this._findInput.setEnabled(this._isVisible);
    this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible);
    this._updateToggleSelectionFindButton();
    this._closeBtn.setEnabled(this._isVisible);
    let findInputIsNonEmpty = this._state.searchString.length > 0;
    let matchesCount = this._state.matchesCount ? true : false;
    this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateBack());
    this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateForward());
    this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
    this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
    toggleClass(this._domNode, "replaceToggled", this._isReplaceVisible);
    this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    let canReplace = !this._codeEditor.getOption(72);
    this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);
  }
  _reveal() {
    if (!this._isVisible) {
      this._isVisible = true;
      const selection = this._codeEditor.getSelection();
      switch (this._codeEditor.getOption(29).autoFindInSelection) {
        case "always":
          this._toggleSelectionFind.checked = true;
          break;
        case "never":
          this._toggleSelectionFind.checked = false;
          break;
        case "multiline":
          const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
          this._toggleSelectionFind.checked = isSelectionMultipleLine;
          break;
        default:
          break;
      }
      this._tryUpdateWidgetWidth();
      this._updateButtons();
      setTimeout(() => {
        addClass(this._domNode, "visible");
        this._domNode.setAttribute("aria-hidden", "false");
      }, 0);
      setTimeout(() => {
        this._findInput.validate();
      }, 200);
      this._codeEditor.layoutOverlayWidget(this);
      let adjustEditorScrollTop = true;
      if (this._codeEditor.getOption(29).seedSearchStringFromSelection && selection) {
        const domNode = this._codeEditor.getDomNode();
        if (domNode) {
          const editorCoords = getDomNodePagePosition(domNode);
          const startCoords = this._codeEditor.getScrolledVisiblePosition(selection.getStartPosition());
          const startLeft = editorCoords.left + (startCoords ? startCoords.left : 0);
          const startTop = startCoords ? startCoords.top : 0;
          if (this._viewZone && startTop < this._viewZone.heightInPx) {
            if (selection.endLineNumber > selection.startLineNumber) {
              adjustEditorScrollTop = false;
            }
            const leftOfFindWidget = getTopLeftOffset(this._domNode).left;
            if (startLeft > leftOfFindWidget) {
              adjustEditorScrollTop = false;
            }
            const endCoords = this._codeEditor.getScrolledVisiblePosition(selection.getEndPosition());
            const endLeft = editorCoords.left + (endCoords ? endCoords.left : 0);
            if (endLeft > leftOfFindWidget) {
              adjustEditorScrollTop = false;
            }
          }
        }
      }
      this._showViewZone(adjustEditorScrollTop);
    }
  }
  _hide(focusTheEditor) {
    if (this._isVisible) {
      this._isVisible = false;
      this._updateButtons();
      removeClass(this._domNode, "visible");
      this._domNode.setAttribute("aria-hidden", "true");
      this._findInput.clearMessage();
      if (focusTheEditor) {
        this._codeEditor.focus();
      }
      this._codeEditor.layoutOverlayWidget(this);
      this._removeViewZone();
    }
  }
  _layoutViewZone() {
    const addExtraSpaceOnTop = this._codeEditor.getOption(29).addExtraSpaceOnTop;
    if (!addExtraSpaceOnTop) {
      this._removeViewZone();
      return;
    }
    if (!this._isVisible) {
      return;
    }
    const viewZone = this._viewZone;
    if (this._viewZoneId !== void 0 || !viewZone) {
      return;
    }
    this._codeEditor.changeViewZones((accessor) => {
      viewZone.heightInPx = this._getHeight();
      this._viewZoneId = accessor.addZone(viewZone);
      this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + viewZone.heightInPx);
    });
  }
  _showViewZone(adjustScroll = true) {
    if (!this._isVisible) {
      return;
    }
    const addExtraSpaceOnTop = this._codeEditor.getOption(29).addExtraSpaceOnTop;
    if (!addExtraSpaceOnTop) {
      return;
    }
    if (this._viewZone === void 0) {
      this._viewZone = new FindWidgetViewZone(0);
    }
    const viewZone = this._viewZone;
    this._codeEditor.changeViewZones((accessor) => {
      if (this._viewZoneId !== void 0) {
        const newHeight = this._getHeight();
        if (newHeight === viewZone.heightInPx) {
          return;
        }
        let scrollAdjustment = newHeight - viewZone.heightInPx;
        viewZone.heightInPx = newHeight;
        accessor.layoutZone(this._viewZoneId);
        if (adjustScroll) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
        }
        return;
      } else {
        let scrollAdjustment = this._getHeight();
        scrollAdjustment -= this._codeEditor.getOption(66).top;
        if (scrollAdjustment <= 0) {
          return;
        }
        viewZone.heightInPx = scrollAdjustment;
        this._viewZoneId = accessor.addZone(viewZone);
        if (adjustScroll) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
        }
      }
    });
  }
  _removeViewZone() {
    this._codeEditor.changeViewZones((accessor) => {
      if (this._viewZoneId !== void 0) {
        accessor.removeZone(this._viewZoneId);
        this._viewZoneId = void 0;
        if (this._viewZone) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx);
          this._viewZone = void 0;
        }
      }
    });
  }
  _applyTheme(theme6) {
    let inputStyles = {
      inputActiveOptionBorder: theme6.getColor(inputActiveOptionBorder),
      inputActiveOptionBackground: theme6.getColor(inputActiveOptionBackground),
      inputActiveOptionForeground: theme6.getColor(inputActiveOptionForeground),
      inputBackground: theme6.getColor(inputBackground),
      inputForeground: theme6.getColor(inputForeground),
      inputBorder: theme6.getColor(inputBorder),
      inputValidationInfoBackground: theme6.getColor(inputValidationInfoBackground),
      inputValidationInfoForeground: theme6.getColor(inputValidationInfoForeground),
      inputValidationInfoBorder: theme6.getColor(inputValidationInfoBorder),
      inputValidationWarningBackground: theme6.getColor(inputValidationWarningBackground),
      inputValidationWarningForeground: theme6.getColor(inputValidationWarningForeground),
      inputValidationWarningBorder: theme6.getColor(inputValidationWarningBorder),
      inputValidationErrorBackground: theme6.getColor(inputValidationErrorBackground),
      inputValidationErrorForeground: theme6.getColor(inputValidationErrorForeground),
      inputValidationErrorBorder: theme6.getColor(inputValidationErrorBorder)
    };
    this._findInput.style(inputStyles);
    this._replaceInput.style(inputStyles);
    this._toggleSelectionFind.style(inputStyles);
  }
  _tryUpdateWidgetWidth() {
    if (!this._isVisible) {
      return;
    }
    if (!isInDOM(this._domNode)) {
      return;
    }
    const layoutInfo = this._codeEditor.getLayoutInfo();
    const editorContentWidth = layoutInfo.contentWidth;
    if (editorContentWidth <= 0) {
      addClass(this._domNode, "hiddenEditor");
      return;
    } else if (hasClass(this._domNode, "hiddenEditor")) {
      removeClass(this._domNode, "hiddenEditor");
    }
    const editorWidth = layoutInfo.width;
    const minimapWidth = layoutInfo.minimap.minimapWidth;
    let collapsedFindWidget = false;
    let reducedFindWidget = false;
    let narrowFindWidget = false;
    if (this._resized) {
      let widgetWidth = getTotalWidth(this._domNode);
      if (widgetWidth > FIND_WIDGET_INITIAL_WIDTH) {
        this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
        return;
      }
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth >= editorWidth) {
      reducedFindWidget = true;
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth) {
      narrowFindWidget = true;
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth + 50) {
      collapsedFindWidget = true;
    }
    toggleClass(this._domNode, "collapsed-find-widget", collapsedFindWidget);
    toggleClass(this._domNode, "narrow-find-widget", narrowFindWidget);
    toggleClass(this._domNode, "reduced-find-widget", reducedFindWidget);
    if (!narrowFindWidget && !collapsedFindWidget) {
      this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
    }
    if (this._resized) {
      this._findInput.inputBox.layout();
      let findInputWidth = this._findInput.inputBox.element.clientWidth;
      if (findInputWidth > 0) {
        this._replaceInput.width = findInputWidth;
      }
    } else if (this._isReplaceVisible) {
      this._replaceInput.width = getTotalWidth(this._findInput.domNode);
    }
  }
  _getHeight() {
    let totalheight = 0;
    totalheight += 4;
    totalheight += this._findInput.inputBox.height + 2;
    if (this._isReplaceVisible) {
      totalheight += 4;
      totalheight += this._replaceInput.inputBox.height + 2;
    }
    totalheight += 4;
    return totalheight;
  }
  _tryUpdateHeight() {
    const totalHeight = this._getHeight();
    if (this._cachedHeight !== null && this._cachedHeight === totalHeight) {
      return false;
    }
    this._cachedHeight = totalHeight;
    this._domNode.style.height = `${totalHeight}px`;
    return true;
  }
  focusFindInput() {
    this._findInput.select();
    this._findInput.focus();
  }
  focusReplaceInput() {
    this._replaceInput.select();
    this._replaceInput.focus();
  }
  highlightFindOptions() {
    this._findInput.highlightFindOptions();
  }
  _updateSearchScope() {
    if (!this._codeEditor.hasModel()) {
      return;
    }
    if (this._toggleSelectionFind.checked) {
      let selections = this._codeEditor.getSelections();
      selections.map((selection) => {
        if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
          selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
        }
        const currentMatch = this._state.currentMatch;
        if (selection.startLineNumber !== selection.endLineNumber) {
          if (!Range2.equalsRange(selection, currentMatch)) {
            return selection;
          }
        }
        return null;
      }).filter((element) => !!element);
      if (selections.length) {
        this._state.change({searchScope: selections}, true);
      }
    }
  }
  _onFindInputMouseDown(e) {
    if (e.middleButton) {
      e.stopPropagation();
    }
  }
  _onFindInputKeyDown(e) {
    if (e.equals(ctrlKeyMod | 3)) {
      this._findInput.inputBox.insertAtCursor("\n");
      e.preventDefault();
      return;
    }
    if (e.equals(2)) {
      if (this._isReplaceVisible) {
        this._replaceInput.focus();
      } else {
        this._findInput.focusOnCaseSensitive();
      }
      e.preventDefault();
      return;
    }
    if (e.equals(2048 | 18)) {
      this._codeEditor.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(16)) {
      return stopPropagationForMultiLineUpwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    }
    if (e.equals(18)) {
      return stopPropagationForMultiLineDownwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    }
  }
  _onReplaceInputKeyDown(e) {
    if (e.equals(ctrlKeyMod | 3)) {
      if (isWindows && isNative && !this._ctrlEnterReplaceAllWarningPrompted) {
        this._notificationService.info(localize("ctrlEnter.keybindingChanged", "Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior."));
        this._ctrlEnterReplaceAllWarningPrompted = true;
        this._storageService.store(ctrlEnterReplaceAllWarningPromptedKey, true, 0);
      }
      this._replaceInput.inputBox.insertAtCursor("\n");
      e.preventDefault();
      return;
    }
    if (e.equals(2)) {
      this._findInput.focusOnCaseSensitive();
      e.preventDefault();
      return;
    }
    if (e.equals(1024 | 2)) {
      this._findInput.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(2048 | 18)) {
      this._codeEditor.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(16)) {
      return stopPropagationForMultiLineUpwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    }
    if (e.equals(18)) {
      return stopPropagationForMultiLineDownwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    }
  }
  getVerticalSashLeft(_sash) {
    return 0;
  }
  _keybindingLabelFor(actionId) {
    let kb = this._keybindingService.lookupKeybinding(actionId);
    if (!kb) {
      return "";
    }
    return ` (${kb.getLabel()})`;
  }
  _buildDomNode() {
    const flexibleHeight = true;
    const flexibleWidth = true;
    this._findInput = this._register(new ContextScopedFindInput(null, this._contextViewProvider, {
      width: FIND_INPUT_AREA_WIDTH,
      label: NLS_FIND_INPUT_LABEL,
      placeholder: NLS_FIND_INPUT_PLACEHOLDER,
      appendCaseSensitiveLabel: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
      appendWholeWordsLabel: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
      appendRegexLabel: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
      validation: (value) => {
        if (value.length === 0 || !this._findInput.getRegex()) {
          return null;
        }
        try {
          new RegExp(value, "gu");
          return null;
        } catch (e) {
          return {content: e.message};
        }
      },
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight: 118
    }, this._contextKeyService, true));
    this._findInput.setRegex(!!this._state.isRegex);
    this._findInput.setCaseSensitive(!!this._state.matchCase);
    this._findInput.setWholeWords(!!this._state.wholeWord);
    this._register(this._findInput.onKeyDown((e) => this._onFindInputKeyDown(e)));
    this._register(this._findInput.inputBox.onDidChange(() => {
      if (this._ignoreChangeEvent) {
        return;
      }
      this._state.change({searchString: this._findInput.getValue()}, true);
    }));
    this._register(this._findInput.onDidOptionChange(() => {
      this._state.change({
        isRegex: this._findInput.getRegex(),
        wholeWord: this._findInput.getWholeWords(),
        matchCase: this._findInput.getCaseSensitive()
      }, true);
    }));
    this._register(this._findInput.onCaseSensitiveKeyDown((e) => {
      if (e.equals(1024 | 2)) {
        if (this._isReplaceVisible) {
          this._replaceInput.focus();
          e.preventDefault();
        }
      }
    }));
    this._register(this._findInput.onRegexKeyDown((e) => {
      if (e.equals(2)) {
        if (this._isReplaceVisible) {
          this._replaceInput.focusOnPreserve();
          e.preventDefault();
        }
      }
    }));
    this._register(this._findInput.inputBox.onDidHeightChange((e) => {
      if (this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }));
    if (isLinux) {
      this._register(this._findInput.onMouseDown((e) => this._onFindInputMouseDown(e)));
    }
    this._matchesCount = document.createElement("div");
    this._matchesCount.className = "matchesCount";
    this._updateMatchesCount();
    this._prevBtn = this._register(new SimpleButton({
      label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.PreviousMatchFindAction),
      className: findPreviousMatchIcon.classNames,
      onTrigger: () => {
        this._codeEditor.getAction(FIND_IDS.PreviousMatchFindAction).run().then(void 0, onUnexpectedError);
      }
    }));
    this._nextBtn = this._register(new SimpleButton({
      label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.NextMatchFindAction),
      className: findNextMatchIcon.classNames,
      onTrigger: () => {
        this._codeEditor.getAction(FIND_IDS.NextMatchFindAction).run().then(void 0, onUnexpectedError);
      }
    }));
    let findPart = document.createElement("div");
    findPart.className = "find-part";
    findPart.appendChild(this._findInput.domNode);
    const actionsContainer = document.createElement("div");
    actionsContainer.className = "find-actions";
    findPart.appendChild(actionsContainer);
    actionsContainer.appendChild(this._matchesCount);
    actionsContainer.appendChild(this._prevBtn.domNode);
    actionsContainer.appendChild(this._nextBtn.domNode);
    this._toggleSelectionFind = this._register(new Checkbox({
      icon: findSelectionIcon,
      title: NLS_TOGGLE_SELECTION_FIND_TITLE + this._keybindingLabelFor(FIND_IDS.ToggleSearchScopeCommand),
      isChecked: false
    }));
    this._register(this._toggleSelectionFind.onChange(() => {
      if (this._toggleSelectionFind.checked) {
        if (this._codeEditor.hasModel()) {
          let selections = this._codeEditor.getSelections();
          selections.map((selection) => {
            if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
              selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
            }
            if (!selection.isEmpty()) {
              return selection;
            }
            return null;
          }).filter((element) => !!element);
          if (selections.length) {
            this._state.change({searchScope: selections}, true);
          }
        }
      } else {
        this._state.change({searchScope: null}, true);
      }
    }));
    actionsContainer.appendChild(this._toggleSelectionFind.domNode);
    this._closeBtn = this._register(new SimpleButton({
      label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.CloseFindWidgetCommand),
      className: findCloseIcon.classNames,
      onTrigger: () => {
        this._state.change({isRevealed: false, searchScope: null}, false);
      },
      onKeyDown: (e) => {
        if (e.equals(2)) {
          if (this._isReplaceVisible) {
            if (this._replaceBtn.isEnabled()) {
              this._replaceBtn.focus();
            } else {
              this._codeEditor.focus();
            }
            e.preventDefault();
          }
        }
      }
    }));
    actionsContainer.appendChild(this._closeBtn.domNode);
    this._replaceInput = this._register(new ContextScopedReplaceInput(null, void 0, {
      label: NLS_REPLACE_INPUT_LABEL,
      placeholder: NLS_REPLACE_INPUT_PLACEHOLDER,
      history: [],
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight: 118
    }, this._contextKeyService, true));
    this._replaceInput.setPreserveCase(!!this._state.preserveCase);
    this._register(this._replaceInput.onKeyDown((e) => this._onReplaceInputKeyDown(e)));
    this._register(this._replaceInput.inputBox.onDidChange(() => {
      this._state.change({replaceString: this._replaceInput.inputBox.value}, false);
    }));
    this._register(this._replaceInput.inputBox.onDidHeightChange((e) => {
      if (this._isReplaceVisible && this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }));
    this._register(this._replaceInput.onDidOptionChange(() => {
      this._state.change({
        preserveCase: this._replaceInput.getPreserveCase()
      }, true);
    }));
    this._register(this._replaceInput.onPreserveCaseKeyDown((e) => {
      if (e.equals(2)) {
        if (this._prevBtn.isEnabled()) {
          this._prevBtn.focus();
        } else if (this._nextBtn.isEnabled()) {
          this._nextBtn.focus();
        } else if (this._toggleSelectionFind.enabled) {
          this._toggleSelectionFind.focus();
        } else if (this._closeBtn.isEnabled()) {
          this._closeBtn.focus();
        }
        e.preventDefault();
      }
    }));
    this._replaceBtn = this._register(new SimpleButton({
      label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceOneAction),
      className: findReplaceIcon.classNames,
      onTrigger: () => {
        this._controller.replace();
      },
      onKeyDown: (e) => {
        if (e.equals(1024 | 2)) {
          this._closeBtn.focus();
          e.preventDefault();
        }
      }
    }));
    this._replaceAllBtn = this._register(new SimpleButton({
      label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceAllAction),
      className: findReplaceAllIcon.classNames,
      onTrigger: () => {
        this._controller.replaceAll();
      }
    }));
    let replacePart = document.createElement("div");
    replacePart.className = "replace-part";
    replacePart.appendChild(this._replaceInput.domNode);
    const replaceActionsContainer = document.createElement("div");
    replaceActionsContainer.className = "replace-actions";
    replacePart.appendChild(replaceActionsContainer);
    replaceActionsContainer.appendChild(this._replaceBtn.domNode);
    replaceActionsContainer.appendChild(this._replaceAllBtn.domNode);
    this._toggleReplaceBtn = this._register(new SimpleButton({
      label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,
      className: "codicon toggle left",
      onTrigger: () => {
        this._state.change({isReplaceRevealed: !this._isReplaceVisible}, false);
        if (this._isReplaceVisible) {
          this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          this._replaceInput.inputBox.layout();
        }
        this._showViewZone();
      }
    }));
    this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    this._domNode = document.createElement("div");
    this._domNode.className = "editor-widget find-widget";
    this._domNode.setAttribute("aria-hidden", "true");
    this._domNode.style.width = `${FIND_WIDGET_INITIAL_WIDTH}px`;
    this._domNode.appendChild(this._toggleReplaceBtn.domNode);
    this._domNode.appendChild(findPart);
    this._domNode.appendChild(replacePart);
    this._resizeSash = new Sash(this._domNode, this, {orientation: 0, size: 2});
    this._resized = false;
    let originalWidth = FIND_WIDGET_INITIAL_WIDTH;
    this._register(this._resizeSash.onDidStart(() => {
      originalWidth = getTotalWidth(this._domNode);
    }));
    this._register(this._resizeSash.onDidChange((evt) => {
      this._resized = true;
      let width = originalWidth + evt.startX - evt.currentX;
      if (width < FIND_WIDGET_INITIAL_WIDTH) {
        return;
      }
      const maxWidth = parseFloat(getComputedStyle(this._domNode).maxWidth) || 0;
      if (width > maxWidth) {
        return;
      }
      this._domNode.style.width = `${width}px`;
      if (this._isReplaceVisible) {
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
      }
      this._findInput.inputBox.layout();
      this._tryUpdateHeight();
    }));
    this._register(this._resizeSash.onDidReset(() => {
      const currentWidth = getTotalWidth(this._domNode);
      if (currentWidth < FIND_WIDGET_INITIAL_WIDTH) {
        return;
      }
      let width = FIND_WIDGET_INITIAL_WIDTH;
      if (!this._resized || currentWidth === FIND_WIDGET_INITIAL_WIDTH) {
        const layoutInfo = this._codeEditor.getLayoutInfo();
        width = layoutInfo.width - 28 - layoutInfo.minimap.minimapWidth - 15;
        this._resized = true;
      } else {
      }
      this._domNode.style.width = `${width}px`;
      if (this._isReplaceVisible) {
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
      }
      this._findInput.inputBox.layout();
    }));
  }
  updateAccessibilitySupport() {
    const value = this._codeEditor.getOption(2);
    this._findInput.setFocusInputOnOptionClick(value !== 2);
  }
};
FindWidget.ID = "editor.contrib.findWidget";
var SimpleButton = class extends Widget {
  constructor(opts) {
    super();
    this._opts = opts;
    this._domNode = document.createElement("div");
    this._domNode.title = this._opts.label;
    this._domNode.tabIndex = 0;
    this._domNode.className = "button " + this._opts.className;
    this._domNode.setAttribute("role", "button");
    this._domNode.setAttribute("aria-label", this._opts.label);
    this.onclick(this._domNode, (e) => {
      this._opts.onTrigger();
      e.preventDefault();
    });
    this.onkeydown(this._domNode, (e) => {
      if (e.equals(10) || e.equals(3)) {
        this._opts.onTrigger();
        e.preventDefault();
        return;
      }
      if (this._opts.onKeyDown) {
        this._opts.onKeyDown(e);
      }
    });
  }
  get domNode() {
    return this._domNode;
  }
  isEnabled() {
    return this._domNode.tabIndex >= 0;
  }
  focus() {
    this._domNode.focus();
  }
  setEnabled(enabled) {
    toggleClass(this._domNode, "disabled", !enabled);
    this._domNode.setAttribute("aria-disabled", String(!enabled));
    this._domNode.tabIndex = enabled ? 0 : -1;
  }
  setExpanded(expanded) {
    this._domNode.setAttribute("aria-expanded", String(!!expanded));
    if (expanded) {
      removeClasses(this._domNode, findCollapsedIcon.classNames);
      addClasses(this._domNode, findExpandedIcon.classNames);
    } else {
      removeClasses(this._domNode, findExpandedIcon.classNames);
      addClasses(this._domNode, findCollapsedIcon.classNames);
    }
  }
};
registerThemingParticipant((theme6, collector) => {
  const addBackgroundColorRule = (selector, color) => {
    if (color) {
      collector.addRule(`.monaco-editor ${selector} { background-color: ${color}; }`);
    }
  };
  addBackgroundColorRule(".findMatch", theme6.getColor(editorFindMatchHighlight));
  addBackgroundColorRule(".currentFindMatch", theme6.getColor(editorFindMatch));
  addBackgroundColorRule(".findScope", theme6.getColor(editorFindRangeHighlight));
  const widgetBackground = theme6.getColor(editorWidgetBackground);
  addBackgroundColorRule(".find-widget", widgetBackground);
  const widgetShadowColor = theme6.getColor(widgetShadow);
  if (widgetShadowColor) {
    collector.addRule(`.monaco-editor .find-widget { box-shadow: 0 2px 8px ${widgetShadowColor}; }`);
  }
  const findMatchHighlightBorder = theme6.getColor(editorFindMatchHighlightBorder);
  if (findMatchHighlightBorder) {
    collector.addRule(`.monaco-editor .findMatch { border: 1px ${theme6.type === "hc" ? "dotted" : "solid"} ${findMatchHighlightBorder}; box-sizing: border-box; }`);
  }
  const findMatchBorder = theme6.getColor(editorFindMatchBorder);
  if (findMatchBorder) {
    collector.addRule(`.monaco-editor .currentFindMatch { border: 2px solid ${findMatchBorder}; padding: 1px; box-sizing: border-box; }`);
  }
  const findRangeHighlightBorder = theme6.getColor(editorFindRangeHighlightBorder);
  if (findRangeHighlightBorder) {
    collector.addRule(`.monaco-editor .findScope { border: 1px ${theme6.type === "hc" ? "dashed" : "solid"} ${findRangeHighlightBorder}; }`);
  }
  const hcBorder = theme6.getColor(contrastBorder);
  if (hcBorder) {
    collector.addRule(`.monaco-editor .find-widget { border: 1px solid ${hcBorder}; }`);
  }
  const foreground2 = theme6.getColor(editorWidgetForeground);
  if (foreground2) {
    collector.addRule(`.monaco-editor .find-widget { color: ${foreground2}; }`);
  }
  const error = theme6.getColor(errorForeground);
  if (error) {
    collector.addRule(`.monaco-editor .find-widget.no-results .matchesCount { color: ${error}; }`);
  }
  const resizeBorderBackground = theme6.getColor(editorWidgetResizeBorder);
  if (resizeBorderBackground) {
    collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${resizeBorderBackground}; }`);
  } else {
    const border = theme6.getColor(editorWidgetBorder);
    if (border) {
      collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${border}; }`);
    }
  }
  const focusOutline = theme6.getColor(focusBorder);
  if (focusOutline) {
    collector.addRule(`.monaco-editor .find-widget .monaco-inputbox.synthetic-focus { outline-color: ${focusOutline}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/findController.js
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param12 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SEARCH_STRING_MAX_LENGTH = 524288;
function getSelectionSearchString(editor3) {
  if (!editor3.hasModel()) {
    return null;
  }
  const selection = editor3.getSelection();
  if (selection.startLineNumber === selection.endLineNumber) {
    if (selection.isEmpty()) {
      const wordAtPosition = editor3.getConfiguredWordAtPosition(selection.getStartPosition());
      if (wordAtPosition) {
        return wordAtPosition.word;
      }
    } else {
      if (editor3.getModel().getValueLengthInRange(selection) < SEARCH_STRING_MAX_LENGTH) {
        return editor3.getModel().getValueInRange(selection);
      }
    }
  }
  return null;
}
var CommonFindController = class CommonFindController2 extends Disposable {
  constructor(editor3, contextKeyService, storageService, clipboardService) {
    super();
    this._editor = editor3;
    this._findWidgetVisible = CONTEXT_FIND_WIDGET_VISIBLE.bindTo(contextKeyService);
    this._contextKeyService = contextKeyService;
    this._storageService = storageService;
    this._clipboardService = clipboardService;
    this._updateHistoryDelayer = new Delayer(500);
    this._state = this._register(new FindReplaceState());
    this.loadQueryState();
    this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this._model = null;
    this._register(this._editor.onDidChangeModel(() => {
      let shouldRestartFind = this._editor.getModel() && this._state.isRevealed;
      this.disposeModel();
      this._state.change({
        searchScope: null,
        matchCase: this._storageService.getBoolean("editor.matchCase", 1, false),
        wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, false),
        isRegex: this._storageService.getBoolean("editor.isRegex", 1, false),
        preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, false)
      }, false);
      if (shouldRestartFind) {
        this._start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: false,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: false,
          updateSearchScope: false,
          loop: this._editor.getOption(29).loop
        });
      }
    }));
  }
  static get(editor3) {
    return editor3.getContribution(CommonFindController2.ID);
  }
  dispose() {
    this.disposeModel();
    super.dispose();
  }
  disposeModel() {
    if (this._model) {
      this._model.dispose();
      this._model = null;
    }
  }
  _onStateChanged(e) {
    this.saveQueryState(e);
    if (e.isRevealed) {
      if (this._state.isRevealed) {
        this._findWidgetVisible.set(true);
      } else {
        this._findWidgetVisible.reset();
        this.disposeModel();
      }
    }
    if (e.searchString) {
      this.setGlobalBufferTerm(this._state.searchString);
    }
  }
  saveQueryState(e) {
    if (e.isRegex) {
      this._storageService.store("editor.isRegex", this._state.actualIsRegex, 1);
    }
    if (e.wholeWord) {
      this._storageService.store("editor.wholeWord", this._state.actualWholeWord, 1);
    }
    if (e.matchCase) {
      this._storageService.store("editor.matchCase", this._state.actualMatchCase, 1);
    }
    if (e.preserveCase) {
      this._storageService.store("editor.preserveCase", this._state.actualPreserveCase, 1);
    }
  }
  loadQueryState() {
    this._state.change({
      matchCase: this._storageService.getBoolean("editor.matchCase", 1, this._state.matchCase),
      wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, this._state.wholeWord),
      isRegex: this._storageService.getBoolean("editor.isRegex", 1, this._state.isRegex),
      preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, this._state.preserveCase)
    }, false);
  }
  isFindInputFocused() {
    return !!CONTEXT_FIND_INPUT_FOCUSED.getValue(this._contextKeyService);
  }
  getState() {
    return this._state;
  }
  closeFindWidget() {
    this._state.change({
      isRevealed: false,
      searchScope: null
    }, false);
    this._editor.focus();
  }
  toggleCaseSensitive() {
    this._state.change({matchCase: !this._state.matchCase}, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleWholeWords() {
    this._state.change({wholeWord: !this._state.wholeWord}, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleRegex() {
    this._state.change({isRegex: !this._state.isRegex}, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleSearchScope() {
    if (this._state.searchScope) {
      this._state.change({searchScope: null}, true);
    } else {
      if (this._editor.hasModel()) {
        let selections = this._editor.getSelections();
        selections.map((selection) => {
          if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
            selection = selection.setEndPosition(selection.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
          }
          if (!selection.isEmpty()) {
            return selection;
          }
          return null;
        }).filter((element) => !!element);
        if (selections.length) {
          this._state.change({searchScope: selections}, true);
        }
      }
    }
  }
  setSearchString(searchString) {
    if (this._state.isRegex) {
      searchString = escapeRegExpCharacters(searchString);
    }
    this._state.change({searchString}, false);
  }
  highlightFindOptions() {
  }
  _start(opts) {
    return __awaiter9(this, void 0, void 0, function* () {
      this.disposeModel();
      if (!this._editor.hasModel()) {
        return;
      }
      let stateChanges = {
        isRevealed: true
      };
      if (opts.seedSearchStringFromSelection) {
        let selectionSearchString = getSelectionSearchString(this._editor);
        if (selectionSearchString) {
          if (this._state.isRegex) {
            stateChanges.searchString = escapeRegExpCharacters(selectionSearchString);
          } else {
            stateChanges.searchString = selectionSearchString;
          }
        }
      }
      if (!stateChanges.searchString && opts.seedSearchStringFromGlobalClipboard) {
        let selectionSearchString = yield this.getGlobalBufferTerm();
        if (!this._editor.hasModel()) {
          return;
        }
        if (selectionSearchString) {
          stateChanges.searchString = selectionSearchString;
        }
      }
      if (opts.forceRevealReplace) {
        stateChanges.isReplaceRevealed = true;
      } else if (!this._findWidgetVisible.get()) {
        stateChanges.isReplaceRevealed = false;
      }
      if (opts.updateSearchScope) {
        let currentSelections = this._editor.getSelections();
        if (currentSelections.some((selection) => !selection.isEmpty())) {
          stateChanges.searchScope = currentSelections;
        }
      }
      stateChanges.loop = opts.loop;
      this._state.change(stateChanges, false);
      if (!this._model) {
        this._model = new FindModelBoundToEditorModel(this._editor, this._state);
      }
    });
  }
  start(opts) {
    return this._start(opts);
  }
  moveToNextMatch() {
    if (this._model) {
      this._model.moveToNextMatch();
      return true;
    }
    return false;
  }
  moveToPrevMatch() {
    if (this._model) {
      this._model.moveToPrevMatch();
      return true;
    }
    return false;
  }
  replace() {
    if (this._model) {
      this._model.replace();
      return true;
    }
    return false;
  }
  replaceAll() {
    if (this._model) {
      this._model.replaceAll();
      return true;
    }
    return false;
  }
  selectAllMatches() {
    if (this._model) {
      this._model.selectAllMatches();
      this._editor.focus();
      return true;
    }
    return false;
  }
  getGlobalBufferTerm() {
    return __awaiter9(this, void 0, void 0, function* () {
      if (this._editor.getOption(29).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
        return this._clipboardService.readFindText();
      }
      return "";
    });
  }
  setGlobalBufferTerm(text) {
    if (this._editor.getOption(29).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
      this._clipboardService.writeFindText(text);
    }
  }
};
CommonFindController.ID = "editor.contrib.findController";
CommonFindController = __decorate12([
  __param12(1, IContextKeyService),
  __param12(2, IStorageService),
  __param12(3, IClipboardService)
], CommonFindController);
var FindController = class FindController2 extends CommonFindController {
  constructor(editor3, _contextViewService, _contextKeyService, _keybindingService, _themeService, _notificationService, _storageService, _storageKeysSyncRegistryService, clipboardService) {
    super(editor3, _contextKeyService, _storageService, clipboardService);
    this._contextViewService = _contextViewService;
    this._keybindingService = _keybindingService;
    this._themeService = _themeService;
    this._notificationService = _notificationService;
    this._storageKeysSyncRegistryService = _storageKeysSyncRegistryService;
    this._widget = null;
    this._findOptionsWidget = null;
  }
  _start(opts) {
    const _super = Object.create(null, {
      _start: {get: () => super._start}
    });
    return __awaiter9(this, void 0, void 0, function* () {
      if (!this._widget) {
        this._createFindWidget();
      }
      const selection = this._editor.getSelection();
      let updateSearchScope = false;
      switch (this._editor.getOption(29).autoFindInSelection) {
        case "always":
          updateSearchScope = true;
          break;
        case "never":
          updateSearchScope = false;
          break;
        case "multiline":
          const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
          updateSearchScope = isSelectionMultipleLine;
          break;
        default:
          break;
      }
      opts.updateSearchScope = updateSearchScope;
      yield _super._start.call(this, opts);
      if (this._widget) {
        if (opts.shouldFocus === 2) {
          this._widget.focusReplaceInput();
        } else if (opts.shouldFocus === 1) {
          this._widget.focusFindInput();
        }
      }
    });
  }
  highlightFindOptions() {
    if (!this._widget) {
      this._createFindWidget();
    }
    if (this._state.isRevealed) {
      this._widget.highlightFindOptions();
    } else {
      this._findOptionsWidget.highlightFindOptions();
    }
  }
  _createFindWidget() {
    this._widget = this._register(new FindWidget(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService, this._storageKeysSyncRegistryService));
    this._findOptionsWidget = this._register(new FindOptionsWidget(this._editor, this._state, this._keybindingService, this._themeService));
  }
};
FindController = __decorate12([
  __param12(1, IContextViewService),
  __param12(2, IContextKeyService),
  __param12(3, IKeybindingService),
  __param12(4, IThemeService),
  __param12(5, INotificationService),
  __param12(6, IStorageService),
  __param12(7, IStorageKeysSyncRegistryService),
  __param12(8, IClipboardService)
], FindController);
var StartFindAction = class extends MultiEditorAction {
  constructor() {
    super({
      id: FIND_IDS.StartFindAction,
      label: localize("startFindAction", "Find"),
      alias: "Find",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 2048 | 36,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "3_find",
        title: localize({key: "miFind", comment: ["&& denotes a mnemonic"]}, "&&Find"),
        order: 1
      }
    });
  }
  run(accessor, editor3) {
    return __awaiter9(this, void 0, void 0, function* () {
      let controller = CommonFindController.get(editor3);
      if (controller) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: editor3.getOption(29).seedSearchStringFromSelection,
          seedSearchStringFromGlobalClipboard: editor3.getOption(29).globalFindClipboard,
          shouldFocus: 1,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor3.getOption(29).loop
        });
      }
    });
  }
};
var StartFindWithSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.StartFindWithSelection,
      label: localize("startFindWithSelectionAction", "Find With Selection"),
      alias: "Find With Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        mac: {
          primary: 2048 | 35
        },
        weight: 100
      }
    });
  }
  run(accessor, editor3) {
    return __awaiter9(this, void 0, void 0, function* () {
      let controller = CommonFindController.get(editor3);
      if (controller) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: true,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor3.getOption(29).loop
        });
        controller.setGlobalBufferTerm(controller.getState().searchString);
      }
    });
  }
};
var MatchFindAction = class extends EditorAction {
  run(accessor, editor3) {
    return __awaiter9(this, void 0, void 0, function* () {
      let controller = CommonFindController.get(editor3);
      if (controller && !this._run(controller)) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor3.getOption(29).seedSearchStringFromSelection,
          seedSearchStringFromGlobalClipboard: true,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor3.getOption(29).loop
        });
        this._run(controller);
      }
    });
  }
};
var NextMatchFindAction = class extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.NextMatchFindAction,
      label: localize("findNextMatchAction", "Find Next"),
      alias: "Find Next",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 61,
        mac: {primary: 2048 | 37, secondary: [61]},
        weight: 100
      }
    });
  }
  _run(controller) {
    return controller.moveToNextMatch();
  }
};
var NextMatchFindAction2 = class extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.NextMatchFindAction,
      label: localize("findNextMatchAction", "Find Next"),
      alias: "Find Next",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
        primary: 3,
        weight: 100
      }
    });
  }
  _run(controller) {
    return controller.moveToNextMatch();
  }
};
var PreviousMatchFindAction = class extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.PreviousMatchFindAction,
      label: localize("findPreviousMatchAction", "Find Previous"),
      alias: "Find Previous",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 1024 | 61,
        mac: {primary: 2048 | 1024 | 37, secondary: [1024 | 61]},
        weight: 100
      }
    });
  }
  _run(controller) {
    return controller.moveToPrevMatch();
  }
};
var PreviousMatchFindAction2 = class extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.PreviousMatchFindAction,
      label: localize("findPreviousMatchAction", "Find Previous"),
      alias: "Find Previous",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
        primary: 1024 | 3,
        weight: 100
      }
    });
  }
  _run(controller) {
    return controller.moveToPrevMatch();
  }
};
var SelectionMatchFindAction = class extends EditorAction {
  run(accessor, editor3) {
    return __awaiter9(this, void 0, void 0, function* () {
      let controller = CommonFindController.get(editor3);
      if (!controller) {
        return;
      }
      let selectionSearchString = getSelectionSearchString(editor3);
      if (selectionSearchString) {
        controller.setSearchString(selectionSearchString);
      }
      if (!this._run(controller)) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: editor3.getOption(29).seedSearchStringFromSelection,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor3.getOption(29).loop
        });
        this._run(controller);
      }
    });
  }
};
var NextSelectionMatchFindAction = class extends SelectionMatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.NextSelectionMatchFindAction,
      label: localize("nextSelectionMatchFindAction", "Find Next Selection"),
      alias: "Find Next Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 61,
        weight: 100
      }
    });
  }
  _run(controller) {
    return controller.moveToNextMatch();
  }
};
var PreviousSelectionMatchFindAction = class extends SelectionMatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.PreviousSelectionMatchFindAction,
      label: localize("previousSelectionMatchFindAction", "Find Previous Selection"),
      alias: "Find Previous Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 61,
        weight: 100
      }
    });
  }
  _run(controller) {
    return controller.moveToPrevMatch();
  }
};
var StartFindReplaceAction = class extends MultiEditorAction {
  constructor() {
    super({
      id: FIND_IDS.StartFindReplaceAction,
      label: localize("startReplace", "Replace"),
      alias: "Replace",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 2048 | 38,
        mac: {primary: 2048 | 512 | 36},
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "3_find",
        title: localize({key: "miReplace", comment: ["&& denotes a mnemonic"]}, "&&Replace"),
        order: 2
      }
    });
  }
  run(accessor, editor3) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (!editor3.hasModel() || editor3.getOption(72)) {
        return;
      }
      let controller = CommonFindController.get(editor3);
      let currentSelection = editor3.getSelection();
      let findInputFocused = controller.isFindInputFocused();
      let seedSearchStringFromSelection = !currentSelection.isEmpty() && currentSelection.startLineNumber === currentSelection.endLineNumber && editor3.getOption(29).seedSearchStringFromSelection && !findInputFocused;
      let shouldFocus = findInputFocused || seedSearchStringFromSelection ? 2 : 1;
      if (controller) {
        yield controller.start({
          forceRevealReplace: true,
          seedSearchStringFromSelection,
          seedSearchStringFromGlobalClipboard: editor3.getOption(29).seedSearchStringFromSelection,
          shouldFocus,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor3.getOption(29).loop
        });
      }
    });
  }
};
registerEditorContribution(CommonFindController.ID, FindController);
var EditorStartFindAction = new StartFindAction();
registerMultiEditorAction(EditorStartFindAction);
registerEditorAction(StartFindWithSelectionAction);
registerEditorAction(NextMatchFindAction);
registerEditorAction(NextMatchFindAction2);
registerEditorAction(PreviousMatchFindAction);
registerEditorAction(PreviousMatchFindAction2);
registerEditorAction(NextSelectionMatchFindAction);
registerEditorAction(PreviousSelectionMatchFindAction);
var EditorStartFindReplaceAction = new StartFindReplaceAction();
registerMultiEditorAction(EditorStartFindReplaceAction);
var FindCommand = EditorCommand.bindToContribution(CommonFindController.get);
registerEditorCommand(new FindCommand({
  id: FIND_IDS.CloseFindWidgetCommand,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.closeFindWidget(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleCaseSensitiveCommand,
  precondition: void 0,
  handler: (x) => x.toggleCaseSensitive(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleCaseSensitiveKeybinding.primary,
    mac: ToggleCaseSensitiveKeybinding.mac,
    win: ToggleCaseSensitiveKeybinding.win,
    linux: ToggleCaseSensitiveKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleWholeWordCommand,
  precondition: void 0,
  handler: (x) => x.toggleWholeWords(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleWholeWordKeybinding.primary,
    mac: ToggleWholeWordKeybinding.mac,
    win: ToggleWholeWordKeybinding.win,
    linux: ToggleWholeWordKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleRegexCommand,
  precondition: void 0,
  handler: (x) => x.toggleRegex(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleRegexKeybinding.primary,
    mac: ToggleRegexKeybinding.mac,
    win: ToggleRegexKeybinding.win,
    linux: ToggleRegexKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleSearchScopeCommand,
  precondition: void 0,
  handler: (x) => x.toggleSearchScope(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleSearchScopeKeybinding.primary,
    mac: ToggleSearchScopeKeybinding.mac,
    win: ToggleSearchScopeKeybinding.win,
    linux: ToggleSearchScopeKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceOneAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replace(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 2048 | 1024 | 22
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceOneAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replace(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
    primary: 3
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceAllAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replaceAll(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 2048 | 512 | 3
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceAllAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replaceAll(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
    primary: void 0,
    mac: {
      primary: 2048 | 3
    }
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.SelectAllMatchesAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.selectAllMatches(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 512 | 3
  }
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingRanges.js
var MAX_FOLDING_REGIONS = 65535;
var MAX_LINE_NUMBER = 16777215;
var MASK_INDENT = 4278190080;
var FoldingRegions = class {
  constructor(startIndexes, endIndexes, types4) {
    if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {
      throw new Error("invalid startIndexes or endIndexes size");
    }
    this._startIndexes = startIndexes;
    this._endIndexes = endIndexes;
    this._collapseStates = new Uint32Array(Math.ceil(startIndexes.length / 32));
    this._types = types4;
    this._parentsComputed = false;
  }
  ensureParentIndices() {
    if (!this._parentsComputed) {
      this._parentsComputed = true;
      let parentIndexes = [];
      let isInsideLast = (startLineNumber, endLineNumber) => {
        let index2 = parentIndexes[parentIndexes.length - 1];
        return this.getStartLineNumber(index2) <= startLineNumber && this.getEndLineNumber(index2) >= endLineNumber;
      };
      for (let i = 0, len = this._startIndexes.length; i < len; i++) {
        let startLineNumber = this._startIndexes[i];
        let endLineNumber = this._endIndexes[i];
        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
          throw new Error("startLineNumber or endLineNumber must not exceed " + MAX_LINE_NUMBER);
        }
        while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {
          parentIndexes.pop();
        }
        let parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;
        parentIndexes.push(i);
        this._startIndexes[i] = startLineNumber + ((parentIndex & 255) << 24);
        this._endIndexes[i] = endLineNumber + ((parentIndex & 65280) << 16);
      }
    }
  }
  get length() {
    return this._startIndexes.length;
  }
  getStartLineNumber(index2) {
    return this._startIndexes[index2] & MAX_LINE_NUMBER;
  }
  getEndLineNumber(index2) {
    return this._endIndexes[index2] & MAX_LINE_NUMBER;
  }
  getType(index2) {
    return this._types ? this._types[index2] : void 0;
  }
  hasTypes() {
    return !!this._types;
  }
  isCollapsed(index2) {
    let arrayIndex = index2 / 32 | 0;
    let bit = index2 % 32;
    return (this._collapseStates[arrayIndex] & 1 << bit) !== 0;
  }
  setCollapsed(index2, newState) {
    let arrayIndex = index2 / 32 | 0;
    let bit = index2 % 32;
    let value = this._collapseStates[arrayIndex];
    if (newState) {
      this._collapseStates[arrayIndex] = value | 1 << bit;
    } else {
      this._collapseStates[arrayIndex] = value & ~(1 << bit);
    }
  }
  toRegion(index2) {
    return new FoldingRegion(this, index2);
  }
  getParentIndex(index2) {
    this.ensureParentIndices();
    let parent2 = ((this._startIndexes[index2] & MASK_INDENT) >>> 24) + ((this._endIndexes[index2] & MASK_INDENT) >>> 16);
    if (parent2 === MAX_FOLDING_REGIONS) {
      return -1;
    }
    return parent2;
  }
  contains(index2, line) {
    return this.getStartLineNumber(index2) <= line && this.getEndLineNumber(index2) >= line;
  }
  findIndex(line) {
    let low = 0, high = this._startIndexes.length;
    if (high === 0) {
      return -1;
    }
    while (low < high) {
      let mid = Math.floor((low + high) / 2);
      if (line < this.getStartLineNumber(mid)) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    return low - 1;
  }
  findRange(line) {
    let index2 = this.findIndex(line);
    if (index2 >= 0) {
      let endLineNumber = this.getEndLineNumber(index2);
      if (endLineNumber >= line) {
        return index2;
      }
      index2 = this.getParentIndex(index2);
      while (index2 !== -1) {
        if (this.contains(index2, line)) {
          return index2;
        }
        index2 = this.getParentIndex(index2);
      }
    }
    return -1;
  }
  toString() {
    let res = [];
    for (let i = 0; i < this.length; i++) {
      res[i] = `[${this.isCollapsed(i) ? "+" : "-"}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;
    }
    return res.join(", ");
  }
};
var FoldingRegion = class {
  constructor(ranges, index2) {
    this.ranges = ranges;
    this.index = index2;
  }
  get startLineNumber() {
    return this.ranges.getStartLineNumber(this.index);
  }
  get endLineNumber() {
    return this.ranges.getEndLineNumber(this.index);
  }
  get regionIndex() {
    return this.index;
  }
  get parentIndex() {
    return this.ranges.getParentIndex(this.index);
  }
  get isCollapsed() {
    return this.ranges.isCollapsed(this.index);
  }
  containedBy(range2) {
    return range2.startLineNumber <= this.startLineNumber && range2.endLineNumber >= this.endLineNumber;
  }
  containsLine(lineNumber) {
    return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingModel.js
var FoldingModel = class {
  constructor(textModel, decorationProvider) {
    this._updateEventEmitter = new Emitter2();
    this.onDidChange = this._updateEventEmitter.event;
    this._textModel = textModel;
    this._decorationProvider = decorationProvider;
    this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));
    this._editorDecorationIds = [];
    this._isInitialized = false;
  }
  get regions() {
    return this._regions;
  }
  get textModel() {
    return this._textModel;
  }
  get isInitialized() {
    return this._isInitialized;
  }
  toggleCollapseState(toggledRegions) {
    if (!toggledRegions.length) {
      return;
    }
    toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);
    const processed = {};
    this._decorationProvider.changeDecorations((accessor) => {
      let k = 0;
      let dirtyRegionEndLine = -1;
      let lastHiddenLine = -1;
      const updateDecorationsUntil = (index2) => {
        while (k < index2) {
          const endLineNumber = this._regions.getEndLineNumber(k);
          const isCollapsed = this._regions.isCollapsed(k);
          if (endLineNumber <= dirtyRegionEndLine) {
            accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine));
          }
          if (isCollapsed && endLineNumber > lastHiddenLine) {
            lastHiddenLine = endLineNumber;
          }
          k++;
        }
      };
      for (let region of toggledRegions) {
        let index2 = region.regionIndex;
        let editorDecorationId = this._editorDecorationIds[index2];
        if (editorDecorationId && !processed[editorDecorationId]) {
          processed[editorDecorationId] = true;
          updateDecorationsUntil(index2);
          let newCollapseState = !this._regions.isCollapsed(index2);
          this._regions.setCollapsed(index2, newCollapseState);
          dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index2));
        }
      }
      updateDecorationsUntil(this._regions.length);
    });
    this._updateEventEmitter.fire({model: this, collapseStateChanged: toggledRegions});
  }
  update(newRegions, blockedLineNumers = []) {
    let newEditorDecorations = [];
    let isBlocked = (startLineNumber, endLineNumber) => {
      for (let blockedLineNumber of blockedLineNumers) {
        if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) {
          return true;
        }
      }
      return false;
    };
    let lastHiddenLine = -1;
    let initRange = (index2, isCollapsed) => {
      const startLineNumber = newRegions.getStartLineNumber(index2);
      const endLineNumber = newRegions.getEndLineNumber(index2);
      if (isCollapsed && isBlocked(startLineNumber, endLineNumber)) {
        isCollapsed = false;
      }
      newRegions.setCollapsed(index2, isCollapsed);
      const maxColumn = this._textModel.getLineMaxColumn(startLineNumber);
      const decorationRange = {
        startLineNumber,
        startColumn: maxColumn,
        endLineNumber: startLineNumber,
        endColumn: maxColumn
      };
      newEditorDecorations.push({range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine)});
      if (isCollapsed && endLineNumber > lastHiddenLine) {
        lastHiddenLine = endLineNumber;
      }
    };
    let i = 0;
    let nextCollapsed = () => {
      while (i < this._regions.length) {
        let isCollapsed = this._regions.isCollapsed(i);
        i++;
        if (isCollapsed) {
          return i - 1;
        }
      }
      return -1;
    };
    let k = 0;
    let collapsedIndex = nextCollapsed();
    while (collapsedIndex !== -1 && k < newRegions.length) {
      let decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);
      if (decRange) {
        let collapsedStartLineNumber = decRange.startLineNumber;
        if (this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.startColumn) {
          while (k < newRegions.length) {
            let startLineNumber = newRegions.getStartLineNumber(k);
            if (collapsedStartLineNumber >= startLineNumber) {
              initRange(k, collapsedStartLineNumber === startLineNumber);
              k++;
            } else {
              break;
            }
          }
        }
      }
      collapsedIndex = nextCollapsed();
    }
    while (k < newRegions.length) {
      initRange(k, false);
      k++;
    }
    this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);
    this._regions = newRegions;
    this._isInitialized = true;
    this._updateEventEmitter.fire({model: this});
  }
  getMemento() {
    let collapsedRanges = [];
    for (let i = 0; i < this._regions.length; i++) {
      if (this._regions.isCollapsed(i)) {
        let range2 = this._textModel.getDecorationRange(this._editorDecorationIds[i]);
        if (range2) {
          let startLineNumber = range2.startLineNumber;
          let endLineNumber = range2.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);
          collapsedRanges.push({startLineNumber, endLineNumber});
        }
      }
    }
    if (collapsedRanges.length > 0) {
      return collapsedRanges;
    }
    return void 0;
  }
  applyMemento(state) {
    if (!Array.isArray(state)) {
      return;
    }
    let toToogle = [];
    for (let range2 of state) {
      let region = this.getRegionAtLine(range2.startLineNumber);
      if (region && !region.isCollapsed) {
        toToogle.push(region);
      }
    }
    this.toggleCollapseState(toToogle);
  }
  dispose() {
    this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);
  }
  getAllRegionsAtLine(lineNumber, filter2) {
    let result = [];
    if (this._regions) {
      let index2 = this._regions.findRange(lineNumber);
      let level = 1;
      while (index2 >= 0) {
        let current2 = this._regions.toRegion(index2);
        if (!filter2 || filter2(current2, level)) {
          result.push(current2);
        }
        level++;
        index2 = current2.parentIndex;
      }
    }
    return result;
  }
  getRegionAtLine(lineNumber) {
    if (this._regions) {
      let index2 = this._regions.findRange(lineNumber);
      if (index2 >= 0) {
        return this._regions.toRegion(index2);
      }
    }
    return null;
  }
  getRegionsInside(region, filter2) {
    let result = [];
    let index2 = region ? region.regionIndex + 1 : 0;
    let endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;
    if (filter2 && filter2.length === 2) {
      const levelStack = [];
      for (let i = index2, len = this._regions.length; i < len; i++) {
        let current2 = this._regions.toRegion(i);
        if (this._regions.getStartLineNumber(i) < endLineNumber) {
          while (levelStack.length > 0 && !current2.containedBy(levelStack[levelStack.length - 1])) {
            levelStack.pop();
          }
          levelStack.push(current2);
          if (filter2(current2, levelStack.length)) {
            result.push(current2);
          }
        } else {
          break;
        }
      }
    } else {
      for (let i = index2, len = this._regions.length; i < len; i++) {
        let current2 = this._regions.toRegion(i);
        if (this._regions.getStartLineNumber(i) < endLineNumber) {
          if (!filter2 || filter2(current2)) {
            result.push(current2);
          }
        } else {
          break;
        }
      }
    }
    return result;
  }
};
function toggleCollapseState(foldingModel, levels, lineNumbers) {
  let toToggle = [];
  for (let lineNumber of lineNumbers) {
    let region = foldingModel.getRegionAtLine(lineNumber);
    if (region) {
      const doCollapse = !region.isCollapsed;
      toToggle.push(region);
      if (levels > 1) {
        let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
        toToggle.push(...regionsInside);
      }
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {
  let toToggle = [];
  if (lineNumbers && lineNumbers.length > 0) {
    for (let lineNumber of lineNumbers) {
      let region = foldingModel.getRegionAtLine(lineNumber);
      if (region) {
        if (region.isCollapsed !== doCollapse) {
          toToggle.push(region);
        }
        if (levels > 1) {
          let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
          toToggle.push(...regionsInside);
        }
      }
    }
  } else {
    let regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);
    toToggle.push(...regionsInside);
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {
  let toToggle = [];
  for (let lineNumber of lineNumbers) {
    let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);
    toToggle.push(...regions);
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {
  let toToggle = [];
  for (let lineNumber of lineNumbers) {
    let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region) => region.isCollapsed !== doCollapse);
    if (regions.length > 0) {
      toToggle.push(regions[0]);
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {
  let filter2 = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some((line) => region.containsLine(line));
  let toToggle = foldingModel.getRegionsInside(null, filter2);
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {
  let editorModel = foldingModel.textModel;
  let regions = foldingModel.regions;
  let toToggle = [];
  for (let i = regions.length - 1; i >= 0; i--) {
    if (doCollapse !== regions.isCollapsed(i)) {
      let startLineNumber = regions.getStartLineNumber(i);
      if (regExp.test(editorModel.getLineContent(startLineNumber))) {
        toToggle.push(regions.toRegion(i));
      }
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForType(foldingModel, type, doCollapse) {
  let regions = foldingModel.regions;
  let toToggle = [];
  for (let i = regions.length - 1; i >= 0; i--) {
    if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {
      toToggle.push(regions.toRegion(i));
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingDecorations.js
var foldingExpandedIcon = registerIcon("folding-expanded", Codicon.chevronDown);
var foldingCollapsedIcon = registerIcon("folding-collapsed", Codicon.chevronRight);
var FoldingDecorationProvider = class {
  constructor(editor3) {
    this.editor = editor3;
    this.autoHideFoldingControls = true;
    this.showFoldingHighlights = true;
  }
  getDecorationOption(isCollapsed, isHidden) {
    if (isHidden) {
      return FoldingDecorationProvider.HIDDEN_RANGE_DECORATION;
    }
    if (isCollapsed) {
      return this.showFoldingHighlights ? FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION;
    } else if (this.autoHideFoldingControls) {
      return FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION;
    } else {
      return FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION;
    }
  }
  deltaDecorations(oldDecorations, newDecorations) {
    return this.editor.deltaDecorations(oldDecorations, newDecorations);
  }
  changeDecorations(callback) {
    return this.editor.changeDecorations(callback);
  }
};
FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({
  stickiness: 1,
  afterContentClassName: "inline-folded",
  isWholeLine: true,
  firstLineDecorationClassName: foldingCollapsedIcon.classNames
});
FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({
  stickiness: 1,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  isWholeLine: true,
  firstLineDecorationClassName: foldingCollapsedIcon.classNames
});
FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({
  stickiness: 1,
  isWholeLine: true,
  firstLineDecorationClassName: foldingExpandedIcon.classNames
});
FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({
  stickiness: 1,
  isWholeLine: true,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + foldingExpandedIcon.classNames
});
FoldingDecorationProvider.HIDDEN_RANGE_DECORATION = ModelDecorationOptions.register({
  stickiness: 1
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/hiddenRangeModel.js
var HiddenRangeModel = class {
  constructor(model) {
    this._updateEventEmitter = new Emitter2();
    this._foldingModel = model;
    this._foldingModelListener = model.onDidChange((_) => this.updateHiddenRanges());
    this._hiddenRanges = [];
    if (model.regions.length) {
      this.updateHiddenRanges();
    }
  }
  get onDidChange() {
    return this._updateEventEmitter.event;
  }
  get hiddenRanges() {
    return this._hiddenRanges;
  }
  updateHiddenRanges() {
    let updateHiddenAreas = false;
    let newHiddenAreas = [];
    let i = 0;
    let k = 0;
    let lastCollapsedStart = Number.MAX_VALUE;
    let lastCollapsedEnd = -1;
    let ranges = this._foldingModel.regions;
    for (; i < ranges.length; i++) {
      if (!ranges.isCollapsed(i)) {
        continue;
      }
      let startLineNumber = ranges.getStartLineNumber(i) + 1;
      let endLineNumber = ranges.getEndLineNumber(i);
      if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {
        continue;
      }
      if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {
        newHiddenAreas.push(this._hiddenRanges[k]);
        k++;
      } else {
        updateHiddenAreas = true;
        newHiddenAreas.push(new Range2(startLineNumber, 1, endLineNumber, 1));
      }
      lastCollapsedStart = startLineNumber;
      lastCollapsedEnd = endLineNumber;
    }
    if (updateHiddenAreas || k < this._hiddenRanges.length) {
      this.applyHiddenRanges(newHiddenAreas);
    }
  }
  applyMemento(state) {
    if (!Array.isArray(state) || state.length === 0) {
      return false;
    }
    let hiddenRanges = [];
    for (let r of state) {
      if (!r.startLineNumber || !r.endLineNumber) {
        return false;
      }
      hiddenRanges.push(new Range2(r.startLineNumber + 1, 1, r.endLineNumber, 1));
    }
    this.applyHiddenRanges(hiddenRanges);
    return true;
  }
  getMemento() {
    return this._hiddenRanges.map((r) => ({startLineNumber: r.startLineNumber - 1, endLineNumber: r.endLineNumber}));
  }
  applyHiddenRanges(newHiddenAreas) {
    this._hiddenRanges = newHiddenAreas;
    this._updateEventEmitter.fire(newHiddenAreas);
  }
  hasRanges() {
    return this._hiddenRanges.length > 0;
  }
  isHidden(line) {
    return findRange(this._hiddenRanges, line) !== null;
  }
  adjustSelections(selections) {
    let hasChanges = false;
    let editorModel = this._foldingModel.textModel;
    let lastRange = null;
    let adjustLine = (line) => {
      if (!lastRange || !isInside(line, lastRange)) {
        lastRange = findRange(this._hiddenRanges, line);
      }
      if (lastRange) {
        return lastRange.startLineNumber - 1;
      }
      return null;
    };
    for (let i = 0, len = selections.length; i < len; i++) {
      let selection = selections[i];
      let adjustedStartLine = adjustLine(selection.startLineNumber);
      if (adjustedStartLine) {
        selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));
        hasChanges = true;
      }
      let adjustedEndLine = adjustLine(selection.endLineNumber);
      if (adjustedEndLine) {
        selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));
        hasChanges = true;
      }
      selections[i] = selection;
    }
    return hasChanges;
  }
  dispose() {
    if (this.hiddenRanges.length > 0) {
      this._hiddenRanges = [];
      this._updateEventEmitter.fire(this._hiddenRanges);
    }
    if (this._foldingModelListener) {
      this._foldingModelListener.dispose();
      this._foldingModelListener = null;
    }
  }
};
function isInside(line, range2) {
  return line >= range2.startLineNumber && line <= range2.endLineNumber;
}
function findRange(ranges, line) {
  let i = findFirstInSorted(ranges, (r) => line < r.startLineNumber) - 1;
  if (i >= 0 && ranges[i].endLineNumber >= line) {
    return ranges[i];
  }
  return null;
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/indentRangeProvider.js
var MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT = 5e3;
var ID_INDENT_PROVIDER = "indent";
var IndentRangeProvider = class {
  constructor(editorModel) {
    this.editorModel = editorModel;
    this.id = ID_INDENT_PROVIDER;
  }
  dispose() {
  }
  compute(cancelationToken) {
    let foldingRules = LanguageConfigurationRegistry.getFoldingRules(this.editorModel.getLanguageIdentifier().id);
    let offSide = foldingRules && !!foldingRules.offSide;
    let markers = foldingRules && foldingRules.markers;
    return Promise.resolve(computeRanges(this.editorModel, offSide, markers));
  }
};
var RangesCollector = class {
  constructor(foldingRangesLimit) {
    this._startIndexes = [];
    this._endIndexes = [];
    this._indentOccurrences = [];
    this._length = 0;
    this._foldingRangesLimit = foldingRangesLimit;
  }
  insertFirst(startLineNumber, endLineNumber, indent) {
    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
      return;
    }
    let index2 = this._length;
    this._startIndexes[index2] = startLineNumber;
    this._endIndexes[index2] = endLineNumber;
    this._length++;
    if (indent < 1e3) {
      this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;
    }
  }
  toIndentRanges(model) {
    if (this._length <= this._foldingRangesLimit) {
      let startIndexes = new Uint32Array(this._length);
      let endIndexes = new Uint32Array(this._length);
      for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {
        startIndexes[k] = this._startIndexes[i];
        endIndexes[k] = this._endIndexes[i];
      }
      return new FoldingRegions(startIndexes, endIndexes);
    } else {
      let entries3 = 0;
      let maxIndent = this._indentOccurrences.length;
      for (let i = 0; i < this._indentOccurrences.length; i++) {
        let n = this._indentOccurrences[i];
        if (n) {
          if (n + entries3 > this._foldingRangesLimit) {
            maxIndent = i;
            break;
          }
          entries3 += n;
        }
      }
      const tabSize = model.getOptions().tabSize;
      let startIndexes = new Uint32Array(this._foldingRangesLimit);
      let endIndexes = new Uint32Array(this._foldingRangesLimit);
      for (let i = this._length - 1, k = 0; i >= 0; i--) {
        let startIndex = this._startIndexes[i];
        let lineContent = model.getLineContent(startIndex);
        let indent = TextModel.computeIndentLevel(lineContent, tabSize);
        if (indent < maxIndent || indent === maxIndent && entries3++ < this._foldingRangesLimit) {
          startIndexes[k] = startIndex;
          endIndexes[k] = this._endIndexes[i];
          k++;
        }
      }
      return new FoldingRegions(startIndexes, endIndexes);
    }
  }
};
function computeRanges(model, offSide, markers, foldingRangesLimit = MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT) {
  const tabSize = model.getOptions().tabSize;
  let result = new RangesCollector(foldingRangesLimit);
  let pattern3 = void 0;
  if (markers) {
    pattern3 = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);
  }
  let previousRegions = [];
  let line = model.getLineCount() + 1;
  previousRegions.push({indent: -1, endAbove: line, line});
  for (let line2 = model.getLineCount(); line2 > 0; line2--) {
    let lineContent = model.getLineContent(line2);
    let indent = TextModel.computeIndentLevel(lineContent, tabSize);
    let previous = previousRegions[previousRegions.length - 1];
    if (indent === -1) {
      if (offSide) {
        previous.endAbove = line2;
      }
      continue;
    }
    let m;
    if (pattern3 && (m = lineContent.match(pattern3))) {
      if (m[1]) {
        let i = previousRegions.length - 1;
        while (i > 0 && previousRegions[i].indent !== -2) {
          i--;
        }
        if (i > 0) {
          previousRegions.length = i + 1;
          previous = previousRegions[i];
          result.insertFirst(line2, previous.line, indent);
          previous.line = line2;
          previous.indent = indent;
          previous.endAbove = line2;
          continue;
        } else {
        }
      } else {
        previousRegions.push({indent: -2, endAbove: line2, line: line2});
        continue;
      }
    }
    if (previous.indent > indent) {
      do {
        previousRegions.pop();
        previous = previousRegions[previousRegions.length - 1];
      } while (previous.indent > indent);
      let endLineNumber = previous.endAbove - 1;
      if (endLineNumber - line2 >= 1) {
        result.insertFirst(line2, endLineNumber, indent);
      }
    }
    if (previous.indent === indent) {
      previous.endAbove = line2;
    } else {
      previousRegions.push({indent, endAbove: line2, line: line2});
    }
  }
  return result.toIndentRanges(model);
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/syntaxRangeProvider.js
var MAX_FOLDING_REGIONS2 = 5e3;
var foldingContext = {};
var ID_SYNTAX_PROVIDER = "syntax";
var SyntaxRangeProvider = class {
  constructor(editorModel, providers, limit = MAX_FOLDING_REGIONS2) {
    this.editorModel = editorModel;
    this.providers = providers;
    this.limit = limit;
    this.id = ID_SYNTAX_PROVIDER;
  }
  compute(cancellationToken) {
    return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then((ranges) => {
      if (ranges) {
        let res = sanitizeRanges(ranges, this.limit);
        return res;
      }
      return null;
    });
  }
  dispose() {
  }
};
function collectSyntaxRanges(providers, model, cancellationToken) {
  let rangeData = null;
  let promises = providers.map((provider, i) => {
    return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then((ranges) => {
      if (cancellationToken.isCancellationRequested) {
        return;
      }
      if (Array.isArray(ranges)) {
        if (!Array.isArray(rangeData)) {
          rangeData = [];
        }
        let nLines = model.getLineCount();
        for (let r of ranges) {
          if (r.start > 0 && r.end > r.start && r.end <= nLines) {
            rangeData.push({start: r.start, end: r.end, rank: i, kind: r.kind});
          }
        }
      }
    }, onUnexpectedExternalError);
  });
  return Promise.all(promises).then((_) => {
    return rangeData;
  });
}
var RangesCollector2 = class {
  constructor(foldingRangesLimit) {
    this._startIndexes = [];
    this._endIndexes = [];
    this._nestingLevels = [];
    this._nestingLevelCounts = [];
    this._types = [];
    this._length = 0;
    this._foldingRangesLimit = foldingRangesLimit;
  }
  add(startLineNumber, endLineNumber, type, nestingLevel) {
    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
      return;
    }
    let index2 = this._length;
    this._startIndexes[index2] = startLineNumber;
    this._endIndexes[index2] = endLineNumber;
    this._nestingLevels[index2] = nestingLevel;
    this._types[index2] = type;
    this._length++;
    if (nestingLevel < 30) {
      this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;
    }
  }
  toIndentRanges() {
    if (this._length <= this._foldingRangesLimit) {
      let startIndexes = new Uint32Array(this._length);
      let endIndexes = new Uint32Array(this._length);
      for (let i = 0; i < this._length; i++) {
        startIndexes[i] = this._startIndexes[i];
        endIndexes[i] = this._endIndexes[i];
      }
      return new FoldingRegions(startIndexes, endIndexes, this._types);
    } else {
      let entries3 = 0;
      let maxLevel = this._nestingLevelCounts.length;
      for (let i = 0; i < this._nestingLevelCounts.length; i++) {
        let n = this._nestingLevelCounts[i];
        if (n) {
          if (n + entries3 > this._foldingRangesLimit) {
            maxLevel = i;
            break;
          }
          entries3 += n;
        }
      }
      let startIndexes = new Uint32Array(this._foldingRangesLimit);
      let endIndexes = new Uint32Array(this._foldingRangesLimit);
      let types4 = [];
      for (let i = 0, k = 0; i < this._length; i++) {
        let level = this._nestingLevels[i];
        if (level < maxLevel || level === maxLevel && entries3++ < this._foldingRangesLimit) {
          startIndexes[k] = this._startIndexes[i];
          endIndexes[k] = this._endIndexes[i];
          types4[k] = this._types[i];
          k++;
        }
      }
      return new FoldingRegions(startIndexes, endIndexes, types4);
    }
  }
};
function sanitizeRanges(rangeData, limit) {
  let sorted = rangeData.sort((d1, d2) => {
    let diff = d1.start - d2.start;
    if (diff === 0) {
      diff = d1.rank - d2.rank;
    }
    return diff;
  });
  let collector = new RangesCollector2(limit);
  let top = void 0;
  let previous = [];
  for (let entry of sorted) {
    if (!top) {
      top = entry;
      collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
    } else {
      if (entry.start > top.start) {
        if (entry.end <= top.end) {
          previous.push(top);
          top = entry;
          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
        } else {
          if (entry.start > top.end) {
            do {
              top = previous.pop();
            } while (top && entry.start > top.end);
            if (top) {
              previous.push(top);
            }
            top = entry;
          }
          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
        }
      }
    }
  }
  return collector.toIndentRanges();
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/intializingRangeProvider.js
var ID_INIT_PROVIDER = "init";
var InitializingRangeProvider = class {
  constructor(editorModel, initialRanges, onTimeout, timeoutTime) {
    this.editorModel = editorModel;
    this.id = ID_INIT_PROVIDER;
    if (initialRanges.length) {
      let toDecorationRange = (range2) => {
        return {
          range: {
            startLineNumber: range2.startLineNumber,
            startColumn: 0,
            endLineNumber: range2.endLineNumber,
            endColumn: editorModel.getLineLength(range2.endLineNumber)
          },
          options: {
            stickiness: 1
          }
        };
      };
      this.decorationIds = editorModel.deltaDecorations([], initialRanges.map(toDecorationRange));
      this.timeout = setTimeout(onTimeout, timeoutTime);
    }
  }
  dispose() {
    if (this.decorationIds) {
      this.editorModel.deltaDecorations(this.decorationIds, []);
      this.decorationIds = void 0;
    }
    if (typeof this.timeout === "number") {
      clearTimeout(this.timeout);
      this.timeout = void 0;
    }
  }
  compute(cancelationToken) {
    let foldingRangeData = [];
    if (this.decorationIds) {
      for (let id of this.decorationIds) {
        let range2 = this.editorModel.getDecorationRange(id);
        if (range2) {
          foldingRangeData.push({start: range2.startLineNumber, end: range2.endLineNumber, rank: 1});
        }
      }
    }
    return Promise.resolve(sanitizeRanges(foldingRangeData, Number.MAX_VALUE));
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/folding.js
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param13 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CONTEXT_FOLDING_ENABLED = new RawContextKey("foldingEnabled", false);
var FoldingController = class FoldingController2 extends Disposable {
  constructor(editor3, contextKeyService) {
    super();
    this.contextKeyService = contextKeyService;
    this.localToDispose = this._register(new DisposableStore());
    this.editor = editor3;
    const options = this.editor.getOptions();
    this._isEnabled = options.get(31);
    this._useFoldingProviders = options.get(32) !== "indentation";
    this._unfoldOnClickAfterEndOfLine = options.get(34);
    this.foldingModel = null;
    this.hiddenRangeModel = null;
    this.rangeProvider = null;
    this.foldingRegionPromise = null;
    this.foldingStateMemento = null;
    this.foldingModelPromise = null;
    this.updateScheduler = null;
    this.cursorChangedScheduler = null;
    this.mouseDownInfo = null;
    this.foldingDecorationProvider = new FoldingDecorationProvider(editor3);
    this.foldingDecorationProvider.autoHideFoldingControls = options.get(91) === "mouseover";
    this.foldingDecorationProvider.showFoldingHighlights = options.get(33);
    this.foldingEnabled = CONTEXT_FOLDING_ENABLED.bindTo(this.contextKeyService);
    this.foldingEnabled.set(this._isEnabled);
    this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));
    this._register(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(31)) {
        this._isEnabled = this.editor.getOptions().get(31);
        this.foldingEnabled.set(this._isEnabled);
        this.onModelChanged();
      }
      if (e.hasChanged(91) || e.hasChanged(33)) {
        const options2 = this.editor.getOptions();
        this.foldingDecorationProvider.autoHideFoldingControls = options2.get(91) === "mouseover";
        this.foldingDecorationProvider.showFoldingHighlights = options2.get(33);
        this.onModelContentChanged();
      }
      if (e.hasChanged(32)) {
        this._useFoldingProviders = this.editor.getOptions().get(32) !== "indentation";
        this.onFoldingStrategyChanged();
      }
      if (e.hasChanged(34)) {
        this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(34);
      }
    }));
    this.onModelChanged();
  }
  static get(editor3) {
    return editor3.getContribution(FoldingController2.ID);
  }
  saveViewState() {
    let model = this.editor.getModel();
    if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {
      return {};
    }
    if (this.foldingModel) {
      let collapsedRegions = this.foldingModel.isInitialized ? this.foldingModel.getMemento() : this.hiddenRangeModel.getMemento();
      let provider = this.rangeProvider ? this.rangeProvider.id : void 0;
      return {collapsedRegions, lineCount: model.getLineCount(), provider};
    }
    return void 0;
  }
  restoreViewState(state) {
    let model = this.editor.getModel();
    if (!model || !this._isEnabled || model.isTooLargeForTokenization() || !this.hiddenRangeModel) {
      return;
    }
    if (!state || !state.collapsedRegions || state.lineCount !== model.getLineCount()) {
      return;
    }
    if (state.provider === ID_SYNTAX_PROVIDER || state.provider === ID_INIT_PROVIDER) {
      this.foldingStateMemento = state;
    }
    const collapsedRegions = state.collapsedRegions;
    if (this.hiddenRangeModel.applyMemento(collapsedRegions)) {
      const foldingModel = this.getFoldingModel();
      if (foldingModel) {
        foldingModel.then((foldingModel2) => {
          if (foldingModel2) {
            foldingModel2.applyMemento(collapsedRegions);
          }
        }).then(void 0, onUnexpectedError);
      }
    }
  }
  onModelChanged() {
    this.localToDispose.clear();
    let model = this.editor.getModel();
    if (!this._isEnabled || !model || model.isTooLargeForTokenization()) {
      return;
    }
    this.foldingModel = new FoldingModel(model, this.foldingDecorationProvider);
    this.localToDispose.add(this.foldingModel);
    this.hiddenRangeModel = new HiddenRangeModel(this.foldingModel);
    this.localToDispose.add(this.hiddenRangeModel);
    this.localToDispose.add(this.hiddenRangeModel.onDidChange((hr) => this.onHiddenRangesChanges(hr)));
    this.updateScheduler = new Delayer(200);
    this.cursorChangedScheduler = new RunOnceScheduler(() => this.revealCursor(), 200);
    this.localToDispose.add(this.cursorChangedScheduler);
    this.localToDispose.add(FoldingRangeProviderRegistry.onDidChange(() => this.onFoldingStrategyChanged()));
    this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged()));
    this.localToDispose.add(this.editor.onDidChangeModelContent(() => this.onModelContentChanged()));
    this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged()));
    this.localToDispose.add(this.editor.onMouseDown((e) => this.onEditorMouseDown(e)));
    this.localToDispose.add(this.editor.onMouseUp((e) => this.onEditorMouseUp(e)));
    this.localToDispose.add({
      dispose: () => {
        if (this.foldingRegionPromise) {
          this.foldingRegionPromise.cancel();
          this.foldingRegionPromise = null;
        }
        if (this.updateScheduler) {
          this.updateScheduler.cancel();
        }
        this.updateScheduler = null;
        this.foldingModel = null;
        this.foldingModelPromise = null;
        this.hiddenRangeModel = null;
        this.cursorChangedScheduler = null;
        this.foldingStateMemento = null;
        if (this.rangeProvider) {
          this.rangeProvider.dispose();
        }
        this.rangeProvider = null;
      }
    });
    this.onModelContentChanged();
  }
  onFoldingStrategyChanged() {
    if (this.rangeProvider) {
      this.rangeProvider.dispose();
    }
    this.rangeProvider = null;
    this.onModelContentChanged();
  }
  getRangeProvider(editorModel) {
    if (this.rangeProvider) {
      return this.rangeProvider;
    }
    this.rangeProvider = new IndentRangeProvider(editorModel);
    if (this._useFoldingProviders && this.foldingModel) {
      let foldingProviders = FoldingRangeProviderRegistry.ordered(this.foldingModel.textModel);
      if (foldingProviders.length === 0 && this.foldingStateMemento && this.foldingStateMemento.collapsedRegions) {
        const rangeProvider = this.rangeProvider = new InitializingRangeProvider(editorModel, this.foldingStateMemento.collapsedRegions, () => {
          this.foldingStateMemento = null;
          this.onFoldingStrategyChanged();
        }, 3e4);
        return rangeProvider;
      } else if (foldingProviders.length > 0) {
        this.rangeProvider = new SyntaxRangeProvider(editorModel, foldingProviders);
      }
    }
    this.foldingStateMemento = null;
    return this.rangeProvider;
  }
  getFoldingModel() {
    return this.foldingModelPromise;
  }
  onModelContentChanged() {
    if (this.updateScheduler) {
      if (this.foldingRegionPromise) {
        this.foldingRegionPromise.cancel();
        this.foldingRegionPromise = null;
      }
      this.foldingModelPromise = this.updateScheduler.trigger(() => {
        const foldingModel = this.foldingModel;
        if (!foldingModel) {
          return null;
        }
        let foldingRegionPromise = this.foldingRegionPromise = createCancelablePromise((token) => this.getRangeProvider(foldingModel.textModel).compute(token));
        return foldingRegionPromise.then((foldingRanges) => {
          if (foldingRanges && foldingRegionPromise === this.foldingRegionPromise) {
            let selections = this.editor.getSelections();
            let selectionLineNumbers = selections ? selections.map((s) => s.startLineNumber) : [];
            foldingModel.update(foldingRanges, selectionLineNumbers);
          }
          return foldingModel;
        });
      }).then(void 0, (err) => {
        onUnexpectedError(err);
        return null;
      });
    }
  }
  onHiddenRangesChanges(hiddenRanges) {
    if (this.hiddenRangeModel && hiddenRanges.length) {
      let selections = this.editor.getSelections();
      if (selections) {
        if (this.hiddenRangeModel.adjustSelections(selections)) {
          this.editor.setSelections(selections);
        }
      }
    }
    this.editor.setHiddenAreas(hiddenRanges);
  }
  onCursorPositionChanged() {
    if (this.hiddenRangeModel && this.hiddenRangeModel.hasRanges()) {
      this.cursorChangedScheduler.schedule();
    }
  }
  revealCursor() {
    const foldingModel = this.getFoldingModel();
    if (!foldingModel) {
      return;
    }
    foldingModel.then((foldingModel2) => {
      if (foldingModel2) {
        let selections = this.editor.getSelections();
        if (selections && selections.length > 0) {
          let toToggle = [];
          for (let selection of selections) {
            let lineNumber = selection.selectionStartLineNumber;
            if (this.hiddenRangeModel && this.hiddenRangeModel.isHidden(lineNumber)) {
              toToggle.push(...foldingModel2.getAllRegionsAtLine(lineNumber, (r) => r.isCollapsed && lineNumber > r.startLineNumber));
            }
          }
          if (toToggle.length) {
            foldingModel2.toggleCollapseState(toToggle);
            this.reveal(selections[0].getPosition());
          }
        }
      }
    }).then(void 0, onUnexpectedError);
  }
  onEditorMouseDown(e) {
    this.mouseDownInfo = null;
    if (!this.hiddenRangeModel || !e.target || !e.target.range) {
      return;
    }
    if (!e.event.leftButton && !e.event.middleButton) {
      return;
    }
    const range2 = e.target.range;
    let iconClicked = false;
    switch (e.target.type) {
      case 4:
        const data = e.target.detail;
        const offsetLeftInGutter = e.target.element.offsetLeft;
        const gutterOffsetX = data.offsetX - offsetLeftInGutter;
        if (gutterOffsetX < 5) {
          return;
        }
        iconClicked = true;
        break;
      case 7: {
        if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges()) {
          const data2 = e.target.detail;
          if (!data2.isAfterLines) {
            break;
          }
        }
        return;
      }
      case 6: {
        if (this.hiddenRangeModel.hasRanges()) {
          let model = this.editor.getModel();
          if (model && range2.startColumn === model.getLineMaxColumn(range2.startLineNumber)) {
            break;
          }
        }
        return;
      }
      default:
        return;
    }
    this.mouseDownInfo = {lineNumber: range2.startLineNumber, iconClicked};
  }
  onEditorMouseUp(e) {
    const foldingModel = this.getFoldingModel();
    if (!foldingModel || !this.mouseDownInfo || !e.target) {
      return;
    }
    let lineNumber = this.mouseDownInfo.lineNumber;
    let iconClicked = this.mouseDownInfo.iconClicked;
    let range2 = e.target.range;
    if (!range2 || range2.startLineNumber !== lineNumber) {
      return;
    }
    if (iconClicked) {
      if (e.target.type !== 4) {
        return;
      }
    } else {
      let model = this.editor.getModel();
      if (!model || range2.startColumn !== model.getLineMaxColumn(lineNumber)) {
        return;
      }
    }
    foldingModel.then((foldingModel2) => {
      if (foldingModel2) {
        let region = foldingModel2.getRegionAtLine(lineNumber);
        if (region && region.startLineNumber === lineNumber) {
          let isCollapsed = region.isCollapsed;
          if (iconClicked || isCollapsed) {
            let toToggle = [];
            let recursive = e.event.middleButton || e.event.shiftKey;
            if (recursive) {
              for (const r of foldingModel2.getRegionsInside(region)) {
                if (r.isCollapsed === isCollapsed) {
                  toToggle.push(r);
                }
              }
            }
            if (isCollapsed || !recursive || toToggle.length === 0) {
              toToggle.push(region);
            }
            foldingModel2.toggleCollapseState(toToggle);
            this.reveal({lineNumber, column: 1});
          }
        }
      }
    }).then(void 0, onUnexpectedError);
  }
  reveal(position) {
    this.editor.revealPositionInCenterIfOutsideViewport(position, 0);
  }
};
FoldingController.ID = "editor.contrib.folding";
FoldingController = __decorate13([
  __param13(1, IContextKeyService)
], FoldingController);
var FoldingAction = class extends EditorAction {
  runEditorCommand(accessor, editor3, args) {
    let foldingController = FoldingController.get(editor3);
    if (!foldingController) {
      return;
    }
    let foldingModelPromise = foldingController.getFoldingModel();
    if (foldingModelPromise) {
      this.reportTelemetry(accessor, editor3);
      return foldingModelPromise.then((foldingModel) => {
        if (foldingModel) {
          this.invoke(foldingController, foldingModel, editor3, args);
          const selection = editor3.getSelection();
          if (selection) {
            foldingController.reveal(selection.getStartPosition());
          }
        }
      });
    }
  }
  getSelectedLines(editor3) {
    let selections = editor3.getSelections();
    return selections ? selections.map((s) => s.startLineNumber) : [];
  }
  getLineNumbers(args, editor3) {
    if (args && args.selectionLines) {
      return args.selectionLines.map((l) => l + 1);
    }
    return this.getSelectedLines(editor3);
  }
  run(_accessor, _editor) {
  }
};
function foldingArgumentsConstraint(args) {
  if (!isUndefined(args)) {
    if (!isObject(args)) {
      return false;
    }
    const foldingArgs = args;
    if (!isUndefined(foldingArgs.levels) && !isNumber(foldingArgs.levels)) {
      return false;
    }
    if (!isUndefined(foldingArgs.direction) && !isString(foldingArgs.direction)) {
      return false;
    }
    if (!isUndefined(foldingArgs.selectionLines) && (!isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(isNumber))) {
      return false;
    }
  }
  return true;
}
var UnfoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfold",
      label: localize("unfoldAction.label", "Unfold"),
      alias: "Unfold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 89,
        mac: {
          primary: 2048 | 512 | 89
        },
        weight: 100
      },
      description: {
        description: "Unfold the content in the editor",
        args: [
          {
            name: "Unfold editor argument",
            description: `Property-value pairs that can be passed through this argument:
						* 'levels': Number of levels to unfold. If not set, defaults to 1.
						* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.
						* 'selectionLines': The start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.
						`,
            constraint: foldingArgumentsConstraint,
            schema: {
              type: "object",
              properties: {
                levels: {
                  type: "number",
                  default: 1
                },
                direction: {
                  type: "string",
                  enum: ["up", "down"],
                  default: "down"
                },
                selectionLines: {
                  type: "array",
                  items: {
                    type: "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(_foldingController, foldingModel, editor3, args) {
    let levels = args && args.levels || 1;
    let lineNumbers = this.getLineNumbers(args, editor3);
    if (args && args.direction === "up") {
      setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);
    } else {
      setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);
    }
  }
};
var UnFoldRecursivelyAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldRecursively",
      label: localize("unFoldRecursivelyAction.label", "Unfold Recursively"),
      alias: "Unfold Recursively",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 89),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor3, _args) {
    setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor3));
  }
};
var FoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.fold",
      label: localize("foldAction.label", "Fold"),
      alias: "Fold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 87,
        mac: {
          primary: 2048 | 512 | 87
        },
        weight: 100
      },
      description: {
        description: "Fold the content in the editor",
        args: [
          {
            name: "Fold editor argument",
            description: `Property-value pairs that can be passed through this argument:
							* 'levels': Number of levels to fold.
							* 'direction': If 'up', folds given number of levels up otherwise folds down.
							* 'selectionLines': The start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.
							If no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.
						`,
            constraint: foldingArgumentsConstraint,
            schema: {
              type: "object",
              properties: {
                levels: {
                  type: "number"
                },
                direction: {
                  type: "string",
                  enum: ["up", "down"]
                },
                selectionLines: {
                  type: "array",
                  items: {
                    type: "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(_foldingController, foldingModel, editor3, args) {
    let lineNumbers = this.getLineNumbers(args, editor3);
    const levels = args && args.levels;
    const direction = args && args.direction;
    if (typeof levels !== "number" && typeof direction !== "string") {
      setCollapseStateUp(foldingModel, true, lineNumbers);
    } else {
      if (direction === "up") {
        setCollapseStateLevelsUp(foldingModel, true, levels || 1, lineNumbers);
      } else {
        setCollapseStateLevelsDown(foldingModel, true, levels || 1, lineNumbers);
      }
    }
  }
};
var ToggleFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.toggleFold",
      label: localize("toggleFoldAction.label", "Toggle Fold"),
      alias: "Toggle Fold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 42),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor3) {
    let selectedLines = this.getSelectedLines(editor3);
    toggleCollapseState(foldingModel, 1, selectedLines);
  }
};
var FoldRecursivelyAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldRecursively",
      label: localize("foldRecursivelyAction.label", "Fold Recursively"),
      alias: "Fold Recursively",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 87),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor3) {
    let selectedLines = this.getSelectedLines(editor3);
    setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);
  }
};
var FoldAllBlockCommentsAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllBlockComments",
      label: localize("foldAllBlockComments.label", "Fold All Block Comments"),
      alias: "Fold All Block Comments",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 85),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor3) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind.Comment.value, true);
    } else {
      const editorModel = editor3.getModel();
      if (!editorModel) {
        return;
      }
      let comments = LanguageConfigurationRegistry.getComments(editorModel.getLanguageIdentifier().id);
      if (comments && comments.blockCommentStartToken) {
        let regExp = new RegExp("^\\s*" + escapeRegExpCharacters(comments.blockCommentStartToken));
        setCollapseStateForMatchingLines(foldingModel, regExp, true);
      }
    }
  }
};
var FoldAllRegionsAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllMarkerRegions",
      label: localize("foldAllMarkerRegions.label", "Fold All Regions"),
      alias: "Fold All Regions",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 29),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor3) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, true);
    } else {
      const editorModel = editor3.getModel();
      if (!editorModel) {
        return;
      }
      let foldingRules = LanguageConfigurationRegistry.getFoldingRules(editorModel.getLanguageIdentifier().id);
      if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
        let regExp = new RegExp(foldingRules.markers.start);
        setCollapseStateForMatchingLines(foldingModel, regExp, true);
      }
    }
  }
};
var UnfoldAllRegionsAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAllMarkerRegions",
      label: localize("unfoldAllMarkerRegions.label", "Unfold All Regions"),
      alias: "Unfold All Regions",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 30),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor3) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, false);
    } else {
      const editorModel = editor3.getModel();
      if (!editorModel) {
        return;
      }
      let foldingRules = LanguageConfigurationRegistry.getFoldingRules(editorModel.getLanguageIdentifier().id);
      if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
        let regExp = new RegExp(foldingRules.markers.start);
        setCollapseStateForMatchingLines(foldingModel, regExp, false);
      }
    }
  }
};
var FoldAllAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAll",
      label: localize("foldAllAction.label", "Fold All"),
      alias: "Fold All",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 21),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, _editor) {
    setCollapseStateLevelsDown(foldingModel, true);
  }
};
var UnfoldAllAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAll",
      label: localize("unfoldAllAction.label", "Unfold All"),
      alias: "Unfold All",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 40),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, _editor) {
    setCollapseStateLevelsDown(foldingModel, false);
  }
};
var FoldLevelAction = class extends FoldingAction {
  getFoldingLevel() {
    return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));
  }
  invoke(_foldingController, foldingModel, editor3) {
    setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor3));
  }
};
FoldLevelAction.ID_PREFIX = "editor.foldLevel";
FoldLevelAction.ID = (level) => FoldLevelAction.ID_PREFIX + level;
registerEditorContribution(FoldingController.ID, FoldingController);
registerEditorAction(UnfoldAction);
registerEditorAction(UnFoldRecursivelyAction);
registerEditorAction(FoldAction);
registerEditorAction(FoldRecursivelyAction);
registerEditorAction(FoldAllAction);
registerEditorAction(UnfoldAllAction);
registerEditorAction(FoldAllBlockCommentsAction);
registerEditorAction(FoldAllRegionsAction);
registerEditorAction(UnfoldAllRegionsAction);
registerEditorAction(ToggleFoldAction);
for (let i = 1; i <= 7; i++) {
  registerInstantiatedEditorAction(new FoldLevelAction({
    id: FoldLevelAction.ID(i),
    label: localize("foldLevelAction.label", "Fold Level {0}", i),
    alias: `Fold Level ${i}`,
    precondition: CONTEXT_FOLDING_ENABLED,
    kbOpts: {
      kbExpr: EditorContextKeys.editorTextFocus,
      primary: KeyChord(2048 | 41, 2048 | 21 + i),
      weight: 100
    }
  }));
}
var foldBackgroundBackground = registerColor("editor.foldBackground", {light: transparent(editorSelectionBackground, 0.3), dark: transparent(editorSelectionBackground, 0.3), hc: null}, localize("foldBackgroundBackground", "Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations."), true);
var editorFoldForeground = registerColor("editorGutter.foldingControlForeground", {dark: iconForeground, light: iconForeground, hc: iconForeground}, localize("editorGutter.foldingControlForeground", "Color of the folding control in the editor gutter."));
registerThemingParticipant((theme6, collector) => {
  const foldBackground = theme6.getColor(foldBackgroundBackground);
  if (foldBackground) {
    collector.addRule(`.monaco-editor .folded-background { background-color: ${foldBackground}; }`);
  }
  const editorFoldColor = theme6.getColor(editorFoldForeground);
  if (editorFoldColor) {
    collector.addRule(`
		.monaco-editor .cldr${foldingExpandedIcon.cssSelector},
		.monaco-editor .cldr${foldingCollapsedIcon.cssSelector} {
			color: ${editorFoldColor} !important;
		}
		`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/fontZoom/fontZoom.js
var EditorFontZoomIn = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomIn",
      label: localize("EditorFontZoomIn.label", "Editor Font Zoom In"),
      alias: "Editor Font Zoom In",
      precondition: void 0
    });
  }
  run(accessor, editor3) {
    EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() + 1);
  }
};
var EditorFontZoomOut = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomOut",
      label: localize("EditorFontZoomOut.label", "Editor Font Zoom Out"),
      alias: "Editor Font Zoom Out",
      precondition: void 0
    });
  }
  run(accessor, editor3) {
    EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() - 1);
  }
};
var EditorFontZoomReset = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomReset",
      label: localize("EditorFontZoomReset.label", "Editor Font Zoom Reset"),
      alias: "Editor Font Zoom Reset",
      precondition: void 0
    });
  }
  run(accessor, editor3) {
    EditorZoom.setZoomLevel(0);
  }
};
registerEditorAction(EditorFontZoomIn);
registerEditorAction(EditorFontZoomOut);
registerEditorAction(EditorFontZoomReset);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/format/formattingEdit.js
var FormattingEdit = class {
  static _handleEolEdits(editor3, edits) {
    let newEol = void 0;
    let singleEdits = [];
    for (let edit2 of edits) {
      if (typeof edit2.eol === "number") {
        newEol = edit2.eol;
      }
      if (edit2.range && typeof edit2.text === "string") {
        singleEdits.push(edit2);
      }
    }
    if (typeof newEol === "number") {
      if (editor3.hasModel()) {
        editor3.getModel().pushEOL(newEol);
      }
    }
    return singleEdits;
  }
  static _isFullModelReplaceEdit(editor3, edit2) {
    if (!editor3.hasModel()) {
      return false;
    }
    const model = editor3.getModel();
    const editRange = model.validateRange(edit2.range);
    const fullModelRange = model.getFullModelRange();
    return fullModelRange.equalsRange(editRange);
  }
  static execute(editor3, _edits, addUndoStops) {
    if (addUndoStops) {
      editor3.pushUndoStop();
    }
    const edits = FormattingEdit._handleEolEdits(editor3, _edits);
    if (edits.length === 1 && FormattingEdit._isFullModelReplaceEdit(editor3, edits[0])) {
      editor3.executeEdits("formatEditsCommand", edits.map((edit2) => EditOperation.replace(Range2.lift(edit2.range), edit2.text)));
    } else {
      editor3.executeEdits("formatEditsCommand", edits.map((edit2) => EditOperation.replaceMove(Range2.lift(edit2.range), edit2.text)));
    }
    if (addUndoStops) {
      editor3.pushUndoStop();
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/extensions/common/extensions.js
var ExtensionIdentifier = class {
  constructor(value) {
    this.value = value;
    this._lower = value.toLowerCase();
  }
  static toKey(id) {
    if (typeof id === "string") {
      return id.toLowerCase();
    }
    return id._lower;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/format/format.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function alertFormattingEdits(edits) {
  edits = edits.filter((edit2) => edit2.range);
  if (!edits.length) {
    return;
  }
  let {range: range2} = edits[0];
  for (let i = 1; i < edits.length; i++) {
    range2 = Range2.plusRange(range2, edits[i].range);
  }
  const {startLineNumber, endLineNumber} = range2;
  if (startLineNumber === endLineNumber) {
    if (edits.length === 1) {
      alert(localize("hint11", "Made 1 formatting edit on line {0}", startLineNumber));
    } else {
      alert(localize("hintn1", "Made {0} formatting edits on line {1}", edits.length, startLineNumber));
    }
  } else {
    if (edits.length === 1) {
      alert(localize("hint1n", "Made 1 formatting edit between lines {0} and {1}", startLineNumber, endLineNumber));
    } else {
      alert(localize("hintnn", "Made {0} formatting edits between lines {1} and {2}", edits.length, startLineNumber, endLineNumber));
    }
  }
}
function getRealAndSyntheticDocumentFormattersOrdered(model) {
  const result = [];
  const seen = new Set();
  const docFormatter = DocumentFormattingEditProviderRegistry.ordered(model);
  for (const formatter of docFormatter) {
    result.push(formatter);
    if (formatter.extensionId) {
      seen.add(ExtensionIdentifier.toKey(formatter.extensionId));
    }
  }
  const rangeFormatter = DocumentRangeFormattingEditProviderRegistry.ordered(model);
  for (const formatter of rangeFormatter) {
    if (formatter.extensionId) {
      if (seen.has(ExtensionIdentifier.toKey(formatter.extensionId))) {
        continue;
      }
      seen.add(ExtensionIdentifier.toKey(formatter.extensionId));
    }
    result.push({
      displayName: formatter.displayName,
      extensionId: formatter.extensionId,
      provideDocumentFormattingEdits(model2, options, token) {
        return formatter.provideDocumentRangeFormattingEdits(model2, model2.getFullModelRange(), options, token);
      }
    });
  }
  return result;
}
var FormattingConflicts = class {
  static select(formatter, document2, mode) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (formatter.length === 0) {
        return void 0;
      }
      const selector = Iterable.first(FormattingConflicts._selectors);
      if (selector) {
        return yield selector(formatter, document2, mode);
      }
      return formatter[0];
    });
  }
};
FormattingConflicts._selectors = new LinkedList();
function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token) {
  return __awaiter10(this, void 0, void 0, function* () {
    const instaService = accessor.get(IInstantiationService);
    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;
    const provider = DocumentRangeFormattingEditProviderRegistry.ordered(model);
    const selected = yield FormattingConflicts.select(provider, model, mode);
    if (selected) {
      progress.report(selected);
      yield instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token);
    }
  });
}
function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token) {
  return __awaiter10(this, void 0, void 0, function* () {
    const workerService = accessor.get(IEditorWorkerService);
    let model;
    let cts;
    if (isCodeEditor(editorOrModel)) {
      model = editorOrModel.getModel();
      cts = new EditorStateCancellationTokenSource(editorOrModel, 1 | 4, void 0, token);
    } else {
      model = editorOrModel;
      cts = new TextModelCancellationTokenSource(editorOrModel, token);
    }
    let ranges = [];
    let len = 0;
    for (let range2 of asArray(rangeOrRanges).sort(Range2.compareRangesUsingStarts)) {
      if (len > 0 && Range2.areIntersectingOrTouching(ranges[len - 1], range2)) {
        ranges[len - 1] = Range2.fromPositions(ranges[len - 1].getStartPosition(), range2.getEndPosition());
      } else {
        len = ranges.push(range2);
      }
    }
    const allEdits = [];
    for (let range2 of ranges) {
      try {
        const rawEdits = yield provider.provideDocumentRangeFormattingEdits(model, range2, model.getFormattingOptions(), cts.token);
        const minEdits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);
        if (minEdits) {
          allEdits.push(...minEdits);
        }
        if (cts.token.isCancellationRequested) {
          return true;
        }
      } finally {
        cts.dispose();
      }
    }
    if (allEdits.length === 0) {
      return false;
    }
    if (isCodeEditor(editorOrModel)) {
      FormattingEdit.execute(editorOrModel, allEdits, true);
      alertFormattingEdits(allEdits);
      editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1);
    } else {
      const [{range: range2}] = allEdits;
      const initialSelection = new Selection(range2.startLineNumber, range2.startColumn, range2.endLineNumber, range2.endColumn);
      model.pushEditOperations([initialSelection], allEdits.map((edit2) => {
        return {
          text: edit2.text,
          range: Range2.lift(edit2.range),
          forceMoveMarkers: true
        };
      }), (undoEdits) => {
        for (const {range: range3} of undoEdits) {
          if (Range2.areIntersectingOrTouching(range3, initialSelection)) {
            return [new Selection(range3.startLineNumber, range3.startColumn, range3.endLineNumber, range3.endColumn)];
          }
        }
        return null;
      });
    }
    return true;
  });
}
function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token) {
  return __awaiter10(this, void 0, void 0, function* () {
    const instaService = accessor.get(IInstantiationService);
    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;
    const provider = getRealAndSyntheticDocumentFormattersOrdered(model);
    const selected = yield FormattingConflicts.select(provider, model, mode);
    if (selected) {
      progress.report(selected);
      yield instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token);
    }
  });
}
function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token) {
  return __awaiter10(this, void 0, void 0, function* () {
    const workerService = accessor.get(IEditorWorkerService);
    let model;
    let cts;
    if (isCodeEditor(editorOrModel)) {
      model = editorOrModel.getModel();
      cts = new EditorStateCancellationTokenSource(editorOrModel, 1 | 4, void 0, token);
    } else {
      model = editorOrModel;
      cts = new TextModelCancellationTokenSource(editorOrModel, token);
    }
    let edits;
    try {
      const rawEdits = yield provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);
      edits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);
      if (cts.token.isCancellationRequested) {
        return true;
      }
    } finally {
      cts.dispose();
    }
    if (!edits || edits.length === 0) {
      return false;
    }
    if (isCodeEditor(editorOrModel)) {
      FormattingEdit.execute(editorOrModel, edits, mode !== 2);
      if (mode !== 2) {
        alertFormattingEdits(edits);
        editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1);
      }
    } else {
      const [{range: range2}] = edits;
      const initialSelection = new Selection(range2.startLineNumber, range2.startColumn, range2.endLineNumber, range2.endColumn);
      model.pushEditOperations([initialSelection], edits.map((edit2) => {
        return {
          text: edit2.text,
          range: Range2.lift(edit2.range),
          forceMoveMarkers: true
        };
      }), (undoEdits) => {
        for (const {range: range3} of undoEdits) {
          if (Range2.areIntersectingOrTouching(range3, initialSelection)) {
            return [new Selection(range3.startLineNumber, range3.startColumn, range3.endLineNumber, range3.endColumn)];
          }
        }
        return null;
      });
    }
    return true;
  });
}
function getDocumentRangeFormattingEditsUntilResult(workerService, model, range2, options, token) {
  return __awaiter10(this, void 0, void 0, function* () {
    const providers = DocumentRangeFormattingEditProviderRegistry.ordered(model);
    for (const provider of providers) {
      let rawEdits = yield Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range2, options, token)).catch(onUnexpectedExternalError);
      if (isNonEmptyArray(rawEdits)) {
        return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);
      }
    }
    return void 0;
  });
}
function getDocumentFormattingEditsUntilResult(workerService, model, options, token) {
  return __awaiter10(this, void 0, void 0, function* () {
    const providers = getRealAndSyntheticDocumentFormattersOrdered(model);
    for (const provider of providers) {
      let rawEdits = yield Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);
      if (isNonEmptyArray(rawEdits)) {
        return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);
      }
    }
    return void 0;
  });
}
function getOnTypeFormattingEdits(workerService, model, position, ch, options) {
  const providers = OnTypeFormattingEditProviderRegistry.ordered(model);
  if (providers.length === 0) {
    return Promise.resolve(void 0);
  }
  if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {
    return Promise.resolve(void 0);
  }
  return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, CancellationToken.None)).catch(onUnexpectedExternalError).then((edits) => {
    return workerService.computeMoreMinimalEdits(model.uri, edits);
  });
}
CommandsRegistry.registerCommand("_executeFormatRangeProvider", function(accessor, ...args) {
  const [resource, range2, options] = args;
  assertType(URI.isUri(resource));
  assertType(Range2.isIRange(range2));
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument("resource");
  }
  return getDocumentRangeFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, Range2.lift(range2), options, CancellationToken.None);
});
CommandsRegistry.registerCommand("_executeFormatDocumentProvider", function(accessor, ...args) {
  const [resource, options] = args;
  assertType(URI.isUri(resource));
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument("resource");
  }
  return getDocumentFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, options, CancellationToken.None);
});
CommandsRegistry.registerCommand("_executeFormatOnTypeProvider", function(accessor, ...args) {
  const [resource, position, ch, options] = args;
  assertType(URI.isUri(resource));
  assertType(Position.isIPosition(position));
  assertType(typeof ch === "string");
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument("resource");
  }
  return getOnTypeFormattingEdits(accessor.get(IEditorWorkerService), model, Position.lift(position), ch, options);
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/format/formatActions.js
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param14 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FormatOnType = class FormatOnType2 {
  constructor(editor3, _workerService) {
    this._workerService = _workerService;
    this._callOnDispose = new DisposableStore();
    this._callOnModel = new DisposableStore();
    this._editor = editor3;
    this._callOnDispose.add(editor3.onDidChangeConfiguration(() => this._update()));
    this._callOnDispose.add(editor3.onDidChangeModel(() => this._update()));
    this._callOnDispose.add(editor3.onDidChangeModelLanguage(() => this._update()));
    this._callOnDispose.add(OnTypeFormattingEditProviderRegistry.onDidChange(this._update, this));
  }
  dispose() {
    this._callOnDispose.dispose();
    this._callOnModel.dispose();
  }
  _update() {
    this._callOnModel.clear();
    if (!this._editor.getOption(41)) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const [support] = OnTypeFormattingEditProviderRegistry.ordered(model);
    if (!support || !support.autoFormatTriggerCharacters) {
      return;
    }
    let triggerChars = new CharacterSet();
    for (let ch of support.autoFormatTriggerCharacters) {
      triggerChars.add(ch.charCodeAt(0));
    }
    this._callOnModel.add(this._editor.onDidType((text) => {
      let lastCharCode = text.charCodeAt(text.length - 1);
      if (triggerChars.has(lastCharCode)) {
        this._trigger(String.fromCharCode(lastCharCode));
      }
    }));
  }
  _trigger(ch) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (this._editor.getSelections().length > 1) {
      return;
    }
    const model = this._editor.getModel();
    const position = this._editor.getPosition();
    let canceled2 = false;
    const unbind2 = this._editor.onDidChangeModelContent((e) => {
      if (e.isFlush) {
        canceled2 = true;
        unbind2.dispose();
        return;
      }
      for (let i = 0, len = e.changes.length; i < len; i++) {
        const change = e.changes[i];
        if (change.range.endLineNumber <= position.lineNumber) {
          canceled2 = true;
          unbind2.dispose();
          return;
        }
      }
    });
    getOnTypeFormattingEdits(this._workerService, model, position, ch, model.getFormattingOptions()).then((edits) => {
      unbind2.dispose();
      if (canceled2) {
        return;
      }
      if (isNonEmptyArray(edits)) {
        FormattingEdit.execute(this._editor, edits, true);
        alertFormattingEdits(edits);
      }
    }, (err) => {
      unbind2.dispose();
      throw err;
    });
  }
};
FormatOnType.ID = "editor.contrib.autoFormat";
FormatOnType = __decorate14([
  __param14(1, IEditorWorkerService)
], FormatOnType);
var FormatOnPaste = class FormatOnPaste2 {
  constructor(editor3, _instantiationService) {
    this.editor = editor3;
    this._instantiationService = _instantiationService;
    this._callOnDispose = new DisposableStore();
    this._callOnModel = new DisposableStore();
    this._callOnDispose.add(editor3.onDidChangeConfiguration(() => this._update()));
    this._callOnDispose.add(editor3.onDidChangeModel(() => this._update()));
    this._callOnDispose.add(editor3.onDidChangeModelLanguage(() => this._update()));
    this._callOnDispose.add(DocumentRangeFormattingEditProviderRegistry.onDidChange(this._update, this));
  }
  dispose() {
    this._callOnDispose.dispose();
    this._callOnModel.dispose();
  }
  _update() {
    this._callOnModel.clear();
    if (!this.editor.getOption(40)) {
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    if (!DocumentRangeFormattingEditProviderRegistry.has(this.editor.getModel())) {
      return;
    }
    this._callOnModel.add(this.editor.onDidPaste(({range: range2}) => this._trigger(range2)));
  }
  _trigger(range2) {
    if (!this.editor.hasModel()) {
      return;
    }
    if (this.editor.getSelections().length > 1) {
      return;
    }
    this._instantiationService.invokeFunction(formatDocumentRangesWithSelectedProvider, this.editor, range2, 2, Progress.None, CancellationToken.None).catch(onUnexpectedError);
  }
};
FormatOnPaste.ID = "editor.contrib.formatOnPaste";
FormatOnPaste = __decorate14([
  __param14(1, IInstantiationService)
], FormatOnPaste);
var FormatDocumentAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.formatDocument",
      label: localize("formatDocument.label", "Format Document"),
      alias: "Format Document",
      precondition: ContextKeyExpr.and(EditorContextKeys.notInCompositeEditor, EditorContextKeys.writable, EditorContextKeys.hasDocumentFormattingProvider),
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, EditorContextKeys.hasDocumentFormattingProvider),
        primary: 1024 | 512 | 36,
        linux: {primary: 2048 | 1024 | 39},
        weight: 100
      },
      contextMenuOpts: {
        when: EditorContextKeys.hasDocumentFormattingProvider,
        group: "1_modification",
        order: 1.3
      }
    });
  }
  run(accessor, editor3) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (editor3.hasModel()) {
        const instaService = accessor.get(IInstantiationService);
        const progressService = accessor.get(IEditorProgressService);
        yield progressService.showWhile(instaService.invokeFunction(formatDocumentWithSelectedProvider, editor3, 1, Progress.None, CancellationToken.None), 250);
      }
    });
  }
};
var FormatSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.formatSelection",
      label: localize("formatSelection.label", "Format Selection"),
      alias: "Format Selection",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasDocumentSelectionFormattingProvider),
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, EditorContextKeys.hasDocumentSelectionFormattingProvider),
        primary: KeyChord(2048 | 41, 2048 | 36),
        weight: 100
      },
      contextMenuOpts: {
        when: ContextKeyExpr.and(EditorContextKeys.hasDocumentSelectionFormattingProvider, EditorContextKeys.hasNonEmptySelection),
        group: "1_modification",
        order: 1.31
      }
    });
  }
  run(accessor, editor3) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (!editor3.hasModel()) {
        return;
      }
      const instaService = accessor.get(IInstantiationService);
      const model = editor3.getModel();
      const ranges = editor3.getSelections().map((range2) => {
        return range2.isEmpty() ? new Range2(range2.startLineNumber, 1, range2.startLineNumber, model.getLineMaxColumn(range2.startLineNumber)) : range2;
      });
      const progressService = accessor.get(IEditorProgressService);
      yield progressService.showWhile(instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor3, ranges, 1, Progress.None, CancellationToken.None), 250);
    });
  }
};
registerEditorContribution(FormatOnType.ID, FormatOnType);
registerEditorContribution(FormatOnPaste.ID, FormatOnPaste);
registerEditorAction(FormatDocumentAction);
registerEditorAction(FormatSelectionAction);
CommandsRegistry.registerCommand("editor.action.format", (accessor) => __awaiter11(void 0, void 0, void 0, function* () {
  const editor3 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
  if (!editor3 || !editor3.hasModel()) {
    return;
  }
  const commandService = accessor.get(ICommandService);
  if (editor3.getSelection().isEmpty()) {
    yield commandService.executeCommand("editor.action.formatDocument");
  } else {
    yield commandService.executeCommand("editor.action.formatSelection");
  }
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/outlineModel.js
var TreeElement = class {
  remove() {
    if (this.parent) {
      this.parent.children.delete(this.id);
    }
  }
  static findId(candidate, container) {
    let candidateId;
    if (typeof candidate === "string") {
      candidateId = `${container.id}/${candidate}`;
    } else {
      candidateId = `${container.id}/${candidate.name}`;
      if (container.children.get(candidateId) !== void 0) {
        candidateId = `${container.id}/${candidate.name}_${candidate.range.startLineNumber}_${candidate.range.startColumn}`;
      }
    }
    let id = candidateId;
    for (let i = 0; container.children.get(id) !== void 0; i++) {
      id = `${candidateId}_${i}`;
    }
    return id;
  }
  static empty(element) {
    return element.children.size === 0;
  }
};
var OutlineElement = class extends TreeElement {
  constructor(id, parent2, symbol5) {
    super();
    this.id = id;
    this.parent = parent2;
    this.symbol = symbol5;
    this.children = new Map();
  }
};
var OutlineGroup = class extends TreeElement {
  constructor(id, parent2, label, order) {
    super();
    this.id = id;
    this.parent = parent2;
    this.label = label;
    this.order = order;
    this.children = new Map();
  }
};
var OutlineModel = class extends TreeElement {
  constructor(uri) {
    super();
    this.uri = uri;
    this.id = "root";
    this.parent = void 0;
    this._groups = new Map();
    this.children = new Map();
    this.id = "root";
    this.parent = void 0;
  }
  static create(textModel, token) {
    let key = this._keys.for(textModel, true);
    let data = OutlineModel._requests.get(key);
    if (!data) {
      let source = new CancellationTokenSource();
      data = {
        promiseCnt: 0,
        source,
        promise: OutlineModel._create(textModel, source.token),
        model: void 0
      };
      OutlineModel._requests.set(key, data);
      const now = Date.now();
      data.promise.then(() => {
        let key2 = this._keys.for(textModel, false);
        let avg = this._requestDurations.get(key2);
        if (!avg) {
          avg = new MovingAverage();
          this._requestDurations.set(key2, avg);
        }
        avg.update(Date.now() - now);
      });
    }
    if (data.model) {
      return Promise.resolve(data.model);
    }
    data.promiseCnt += 1;
    token.onCancellationRequested(() => {
      if (--data.promiseCnt === 0) {
        data.source.cancel();
        OutlineModel._requests.delete(key);
      }
    });
    return new Promise((resolve, reject) => {
      data.promise.then((model) => {
        data.model = model;
        resolve(model);
      }, (err) => {
        OutlineModel._requests.delete(key);
        reject(err);
      });
    });
  }
  static _create(textModel, token) {
    const cts = new CancellationTokenSource(token);
    const result = new OutlineModel(textModel.uri);
    const provider = DocumentSymbolProviderRegistry.ordered(textModel);
    const promises = provider.map((provider2, index2) => {
      var _a5;
      let id = TreeElement.findId(`provider_${index2}`, result);
      let group = new OutlineGroup(id, result, (_a5 = provider2.displayName) !== null && _a5 !== void 0 ? _a5 : "Unknown Outline Provider", index2);
      return Promise.resolve(provider2.provideDocumentSymbols(textModel, cts.token)).then((result2) => {
        for (const info of result2 || []) {
          OutlineModel._makeOutlineElement(info, group);
        }
        return group;
      }, (err) => {
        onUnexpectedExternalError(err);
        return group;
      }).then((group2) => {
        if (!TreeElement.empty(group2)) {
          result._groups.set(id, group2);
        } else {
          group2.remove();
        }
      });
    });
    const listener = DocumentSymbolProviderRegistry.onDidChange(() => {
      const newProvider = DocumentSymbolProviderRegistry.ordered(textModel);
      if (!equals(newProvider, provider)) {
        cts.cancel();
      }
    });
    return Promise.all(promises).then(() => {
      if (cts.token.isCancellationRequested && !token.isCancellationRequested) {
        return OutlineModel._create(textModel, token);
      } else {
        return result._compact();
      }
    }).finally(() => {
      listener.dispose();
    });
  }
  static _makeOutlineElement(info, container) {
    let id = TreeElement.findId(info, container);
    let res = new OutlineElement(id, container, info);
    if (info.children) {
      for (const childInfo of info.children) {
        OutlineModel._makeOutlineElement(childInfo, res);
      }
    }
    container.children.set(res.id, res);
  }
  _compact() {
    let count = 0;
    for (const [key, group] of this._groups) {
      if (group.children.size === 0) {
        this._groups.delete(key);
      } else {
        count += 1;
      }
    }
    if (count !== 1) {
      this.children = this._groups;
    } else {
      let group = Iterable.first(this._groups.values());
      for (let [, child] of group.children) {
        child.parent = this;
        this.children.set(child.id, child);
      }
    }
    return this;
  }
};
OutlineModel._requestDurations = new LRUCache(50, 0.7);
OutlineModel._requests = new LRUCache(9, 0.75);
OutlineModel._keys = new class {
  constructor() {
    this._counter = 1;
    this._data = new WeakMap();
  }
  for(textModel, version2) {
    return `${textModel.id}/${version2 ? textModel.getVersionId() : ""}/${this._hash(DocumentSymbolProviderRegistry.all(textModel))}`;
  }
  _hash(providers) {
    let result = "";
    for (const provider of providers) {
      let n = this._data.get(provider);
      if (typeof n === "undefined") {
        n = this._counter++;
        this._data.set(provider, n);
      }
      result += n;
    }
    return result;
  }
}();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/documentSymbols.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getDocumentSymbols(document2, flat, token) {
  return __awaiter12(this, void 0, void 0, function* () {
    const model = yield OutlineModel.create(document2, token);
    const roots = [];
    for (const child of model.children.values()) {
      if (child instanceof OutlineElement) {
        roots.push(child.symbol);
      } else {
        roots.push(...Iterable.map(child.children.values(), (child2) => child2.symbol));
      }
    }
    let flatEntries = [];
    if (token.isCancellationRequested) {
      return flatEntries;
    }
    if (flat) {
      flatten2(flatEntries, roots, "");
    } else {
      flatEntries = roots;
    }
    return flatEntries.sort(compareEntriesUsingStart);
  });
}
function compareEntriesUsingStart(a, b) {
  return Range2.compareRangesUsingStarts(a.range, b.range);
}
function flatten2(bucket, entries3, overrideContainerLabel) {
  for (let entry of entries3) {
    bucket.push({
      kind: entry.kind,
      tags: entry.tags,
      name: entry.name,
      detail: entry.detail,
      containerName: entry.containerName || overrideContainerLabel,
      range: entry.range,
      selectionRange: entry.selectionRange,
      children: void 0
    });
    if (entry.children) {
      flatten2(bucket, entry.children, entry.name);
    }
  }
}
CommandsRegistry.registerCommand("_executeDocumentSymbolProvider", function(accessor, ...args) {
  return __awaiter12(this, void 0, void 0, function* () {
    const [resource] = args;
    assertType(URI.isUri(resource));
    const model = accessor.get(IModelService).getModel(resource);
    if (model) {
      return getDocumentSymbols(model, false, CancellationToken.None);
    }
    const reference = yield accessor.get(ITextModelService).createModelReference(resource);
    try {
      return yield getDocumentSymbols(reference.object.textEditorModel, false, CancellationToken.None);
    } finally {
      reference.dispose();
    }
  });
});

// ../../node_modules/monaco-editor/esm/vs/editor/browser/widget/embeddedCodeEditorWidget.js
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param15 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var EmbeddedCodeEditorWidget = class EmbeddedCodeEditorWidget2 extends CodeEditorWidget {
  constructor(domElement, options, parentEditor, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService) {
    super(domElement, Object.assign(Object.assign({}, parentEditor.getRawOptions()), {overflowWidgetsDomNode: parentEditor.getOverflowWidgetsDomNode()}), {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService);
    this._parentEditor = parentEditor;
    this._overwriteOptions = options;
    super.updateOptions(this._overwriteOptions);
    this._register(parentEditor.onDidChangeConfiguration((e) => this._onParentConfigurationChanged(e)));
  }
  getParentEditor() {
    return this._parentEditor;
  }
  _onParentConfigurationChanged(e) {
    super.updateOptions(this._parentEditor.getRawOptions());
    super.updateOptions(this._overwriteOptions);
  }
  updateOptions(newOptions) {
    mixin(this._overwriteOptions, newOptions, true);
    super.updateOptions(this._overwriteOptions);
  }
};
EmbeddedCodeEditorWidget = __decorate15([
  __param15(3, IInstantiationService),
  __param15(4, ICodeEditorService),
  __param15(5, ICommandService),
  __param15(6, IContextKeyService),
  __param15(7, IThemeService),
  __param15(8, INotificationService),
  __param15(9, IAccessibilityService)
], EmbeddedCodeEditorWidget);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.js
var defaultColor = new Color(new RGBA(0, 122, 204));
var defaultOptions = {
  showArrow: true,
  showFrame: true,
  className: "",
  frameColor: defaultColor,
  arrowColor: defaultColor,
  keepEditorSelection: false
};
var WIDGET_ID = "vs.editor.contrib.zoneWidget";
var ViewZoneDelegate = class {
  constructor(domNode, afterLineNumber, afterColumn, heightInLines, onDomNodeTop, onComputedHeight) {
    this.id = "";
    this.domNode = domNode;
    this.afterLineNumber = afterLineNumber;
    this.afterColumn = afterColumn;
    this.heightInLines = heightInLines;
    this._onDomNodeTop = onDomNodeTop;
    this._onComputedHeight = onComputedHeight;
  }
  onDomNodeTop(top) {
    this._onDomNodeTop(top);
  }
  onComputedHeight(height) {
    this._onComputedHeight(height);
  }
};
var OverlayWidgetDelegate = class {
  constructor(id, domNode) {
    this._id = id;
    this._domNode = domNode;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return null;
  }
};
var Arrow = class {
  constructor(_editor) {
    this._editor = _editor;
    this._ruleName = Arrow._IdGenerator.nextId();
    this._decorations = [];
    this._color = null;
    this._height = -1;
  }
  dispose() {
    this.hide();
    removeCSSRulesContainingSelector(this._ruleName);
  }
  set color(value) {
    if (this._color !== value) {
      this._color = value;
      this._updateStyle();
    }
  }
  set height(value) {
    if (this._height !== value) {
      this._height = value;
      this._updateStyle();
    }
  }
  _updateStyle() {
    removeCSSRulesContainingSelector(this._ruleName);
    createCSSRule(`.monaco-editor ${this._ruleName}`, `border-style: solid; border-color: transparent; border-bottom-color: ${this._color}; border-width: ${this._height}px; bottom: -${this._height}px; margin-left: -${this._height}px; `);
  }
  show(where) {
    this._decorations = this._editor.deltaDecorations(this._decorations, [{range: Range2.fromPositions(where), options: {className: this._ruleName, stickiness: 1}}]);
  }
  hide() {
    this._editor.deltaDecorations(this._decorations, []);
  }
};
Arrow._IdGenerator = new IdGenerator(".arrow-decoration-");
var ZoneWidget = class {
  constructor(editor3, options = {}) {
    this._arrow = null;
    this._overlayWidget = null;
    this._resizeSash = null;
    this._positionMarkerId = [];
    this._viewZone = null;
    this._disposables = new DisposableStore();
    this.container = null;
    this._isShowing = false;
    this.editor = editor3;
    this.options = deepClone(options);
    mixin(this.options, defaultOptions, false);
    this.domNode = document.createElement("div");
    if (!this.options.isAccessible) {
      this.domNode.setAttribute("aria-hidden", "true");
      this.domNode.setAttribute("role", "presentation");
    }
    this._disposables.add(this.editor.onDidLayoutChange((info) => {
      const width = this._getWidth(info);
      this.domNode.style.width = width + "px";
      this.domNode.style.left = this._getLeft(info) + "px";
      this._onWidth(width);
    }));
  }
  dispose() {
    if (this._overlayWidget) {
      this.editor.removeOverlayWidget(this._overlayWidget);
      this._overlayWidget = null;
    }
    if (this._viewZone) {
      this.editor.changeViewZones((accessor) => {
        if (this._viewZone) {
          accessor.removeZone(this._viewZone.id);
        }
        this._viewZone = null;
      });
    }
    this.editor.deltaDecorations(this._positionMarkerId, []);
    this._positionMarkerId = [];
    this._disposables.dispose();
  }
  create() {
    this.domNode.classList.add("zone-widget");
    if (this.options.className) {
      this.domNode.classList.add(this.options.className);
    }
    this.container = document.createElement("div");
    this.container.classList.add("zone-widget-container");
    this.domNode.appendChild(this.container);
    if (this.options.showArrow) {
      this._arrow = new Arrow(this.editor);
      this._disposables.add(this._arrow);
    }
    this._fillContainer(this.container);
    this._initSash();
    this._applyStyles();
  }
  style(styles40) {
    if (styles40.frameColor) {
      this.options.frameColor = styles40.frameColor;
    }
    if (styles40.arrowColor) {
      this.options.arrowColor = styles40.arrowColor;
    }
    this._applyStyles();
  }
  _applyStyles() {
    if (this.container && this.options.frameColor) {
      let frameColor = this.options.frameColor.toString();
      this.container.style.borderTopColor = frameColor;
      this.container.style.borderBottomColor = frameColor;
    }
    if (this._arrow && this.options.arrowColor) {
      let arrowColor = this.options.arrowColor.toString();
      this._arrow.color = arrowColor;
    }
  }
  _getWidth(info) {
    return info.width - info.minimap.minimapWidth - info.verticalScrollbarWidth;
  }
  _getLeft(info) {
    if (info.minimap.minimapWidth > 0 && info.minimap.minimapLeft === 0) {
      return info.minimap.minimapWidth;
    }
    return 0;
  }
  _onViewZoneTop(top) {
    this.domNode.style.top = top + "px";
  }
  _onViewZoneHeight(height) {
    this.domNode.style.height = `${height}px`;
    if (this.container) {
      let containerHeight = height - this._decoratingElementsHeight();
      this.container.style.height = `${containerHeight}px`;
      const layoutInfo = this.editor.getLayoutInfo();
      this._doLayout(containerHeight, this._getWidth(layoutInfo));
    }
    if (this._resizeSash) {
      this._resizeSash.layout();
    }
  }
  get position() {
    const [id] = this._positionMarkerId;
    if (!id) {
      return void 0;
    }
    const model = this.editor.getModel();
    if (!model) {
      return void 0;
    }
    const range2 = model.getDecorationRange(id);
    if (!range2) {
      return void 0;
    }
    return range2.getStartPosition();
  }
  show(rangeOrPos, heightInLines) {
    const range2 = Range2.isIRange(rangeOrPos) ? Range2.lift(rangeOrPos) : Range2.fromPositions(rangeOrPos);
    this._isShowing = true;
    this._showImpl(range2, heightInLines);
    this._isShowing = false;
    this._positionMarkerId = this.editor.deltaDecorations(this._positionMarkerId, [{range: range2, options: ModelDecorationOptions.EMPTY}]);
  }
  hide() {
    if (this._viewZone) {
      this.editor.changeViewZones((accessor) => {
        if (this._viewZone) {
          accessor.removeZone(this._viewZone.id);
        }
      });
      this._viewZone = null;
    }
    if (this._overlayWidget) {
      this.editor.removeOverlayWidget(this._overlayWidget);
      this._overlayWidget = null;
    }
    if (this._arrow) {
      this._arrow.hide();
    }
  }
  _decoratingElementsHeight() {
    let lineHeight = this.editor.getOption(51);
    let result = 0;
    if (this.options.showArrow) {
      let arrowHeight = Math.round(lineHeight / 3);
      result += 2 * arrowHeight;
    }
    if (this.options.showFrame) {
      let frameThickness = Math.round(lineHeight / 9);
      result += 2 * frameThickness;
    }
    return result;
  }
  _showImpl(where, heightInLines) {
    const position = where.getStartPosition();
    const layoutInfo = this.editor.getLayoutInfo();
    const width = this._getWidth(layoutInfo);
    this.domNode.style.width = `${width}px`;
    this.domNode.style.left = this._getLeft(layoutInfo) + "px";
    const viewZoneDomNode = document.createElement("div");
    viewZoneDomNode.style.overflow = "hidden";
    const lineHeight = this.editor.getOption(51);
    const maxHeightInLines = Math.max(12, this.editor.getLayoutInfo().height / lineHeight * 0.8);
    heightInLines = Math.min(heightInLines, maxHeightInLines);
    let arrowHeight = 0;
    let frameThickness = 0;
    if (this._arrow && this.options.showArrow) {
      arrowHeight = Math.round(lineHeight / 3);
      this._arrow.height = arrowHeight;
      this._arrow.show(position);
    }
    if (this.options.showFrame) {
      frameThickness = Math.round(lineHeight / 9);
    }
    this.editor.changeViewZones((accessor) => {
      if (this._viewZone) {
        accessor.removeZone(this._viewZone.id);
      }
      if (this._overlayWidget) {
        this.editor.removeOverlayWidget(this._overlayWidget);
        this._overlayWidget = null;
      }
      this.domNode.style.top = "-1000px";
      this._viewZone = new ViewZoneDelegate(viewZoneDomNode, position.lineNumber, position.column, heightInLines, (top) => this._onViewZoneTop(top), (height) => this._onViewZoneHeight(height));
      this._viewZone.id = accessor.addZone(this._viewZone);
      this._overlayWidget = new OverlayWidgetDelegate(WIDGET_ID + this._viewZone.id, this.domNode);
      this.editor.addOverlayWidget(this._overlayWidget);
    });
    if (this.container && this.options.showFrame) {
      const width2 = this.options.frameWidth ? this.options.frameWidth : frameThickness;
      this.container.style.borderTopWidth = width2 + "px";
      this.container.style.borderBottomWidth = width2 + "px";
    }
    let containerHeight = heightInLines * lineHeight - this._decoratingElementsHeight();
    if (this.container) {
      this.container.style.top = arrowHeight + "px";
      this.container.style.height = containerHeight + "px";
      this.container.style.overflow = "hidden";
    }
    this._doLayout(containerHeight, width);
    if (!this.options.keepEditorSelection) {
      this.editor.setSelection(where);
    }
    const model = this.editor.getModel();
    if (model) {
      const revealLine = where.endLineNumber + 1;
      if (revealLine <= model.getLineCount()) {
        this.revealLine(revealLine, false);
      } else {
        this.revealLine(model.getLineCount(), true);
      }
    }
  }
  revealLine(lineNumber, isLastLine) {
    if (isLastLine) {
      this.editor.revealLineInCenter(lineNumber, 0);
    } else {
      this.editor.revealLine(lineNumber, 0);
    }
  }
  setCssClass(className, classToReplace) {
    if (!this.container) {
      return;
    }
    if (classToReplace) {
      this.container.classList.remove(classToReplace);
    }
    addClass(this.container, className);
  }
  _onWidth(widthInPixel) {
  }
  _doLayout(heightInPixel, widthInPixel) {
  }
  _relayout(newHeightInLines) {
    if (this._viewZone && this._viewZone.heightInLines !== newHeightInLines) {
      this.editor.changeViewZones((accessor) => {
        if (this._viewZone) {
          this._viewZone.heightInLines = newHeightInLines;
          accessor.layoutZone(this._viewZone.id);
        }
      });
    }
  }
  _initSash() {
    if (this._resizeSash) {
      return;
    }
    this._resizeSash = this._disposables.add(new Sash(this.domNode, this, {orientation: 1}));
    if (!this.options.isResizeable) {
      this._resizeSash.hide();
      this._resizeSash.state = 0;
    }
    let data;
    this._disposables.add(this._resizeSash.onDidStart((e) => {
      if (this._viewZone) {
        data = {
          startY: e.startY,
          heightInLines: this._viewZone.heightInLines
        };
      }
    }));
    this._disposables.add(this._resizeSash.onDidEnd(() => {
      data = void 0;
    }));
    this._disposables.add(this._resizeSash.onDidChange((evt) => {
      if (data) {
        let lineDelta = (evt.currentY - data.startY) / this.editor.getOption(51);
        let roundedLineDelta = lineDelta < 0 ? Math.ceil(lineDelta) : Math.floor(lineDelta);
        let newHeightInLines = data.heightInLines + roundedLineDelta;
        if (newHeightInLines > 5 && newHeightInLines < 35) {
          this._relayout(newHeightInLines);
        }
      }
    }));
  }
  getHorizontalSashLeft() {
    return 0;
  }
  getHorizontalSashTop() {
    return (this.domNode.style.height === null ? 0 : parseInt(this.domNode.style.height)) - this._decoratingElementsHeight() / 2;
  }
  getHorizontalSashWidth() {
    const layoutInfo = this.editor.getLayoutInfo();
    return layoutInfo.width - layoutInfo.minimap.minimapWidth;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.js
var BaseDropdown = class extends ActionRunner {
  constructor(container, options) {
    super();
    this._onDidChangeVisibility = new Emitter2();
    this.onDidChangeVisibility = this._onDidChangeVisibility.event;
    this._element = append(container, $(".monaco-dropdown"));
    this._label = append(this._element, $(".dropdown-label"));
    let labelRenderer = options.labelRenderer;
    if (!labelRenderer) {
      labelRenderer = (container2) => {
        container2.textContent = options.label || "";
        return null;
      };
    }
    for (const event of [EventType2.CLICK, EventType2.MOUSE_DOWN, EventType.Tap]) {
      this._register(addDisposableListener(this.element, event, (e) => EventHelper.stop(e, true)));
    }
    for (const event of [EventType2.MOUSE_DOWN, EventType.Tap]) {
      this._register(addDisposableListener(this._label, event, (e) => {
        if (e instanceof MouseEvent && e.detail > 1) {
          return;
        }
        if (this.visible) {
          this.hide();
        } else {
          this.show();
        }
      }));
    }
    this._register(addDisposableListener(this._label, EventType2.KEY_UP, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(3) || event.equals(10)) {
        EventHelper.stop(e, true);
        if (this.visible) {
          this.hide();
        } else {
          this.show();
        }
      }
    }));
    const cleanupFn = labelRenderer(this._label);
    if (cleanupFn) {
      this._register(cleanupFn);
    }
    this._register(Gesture.addTarget(this._label));
  }
  get element() {
    return this._element;
  }
  show() {
    if (!this.visible) {
      this.visible = true;
      this._onDidChangeVisibility.fire(true);
    }
  }
  hide() {
    if (this.visible) {
      this.visible = false;
      this._onDidChangeVisibility.fire(false);
    }
  }
  dispose() {
    super.dispose();
    this.hide();
    if (this.boxContainer) {
      this.boxContainer.remove();
      this.boxContainer = void 0;
    }
    if (this.contents) {
      this.contents.remove();
      this.contents = void 0;
    }
    if (this._label) {
      this._label.remove();
      this._label = void 0;
    }
  }
};
var DropdownMenu = class extends BaseDropdown {
  constructor(container, options) {
    super(container, options);
    this._actions = [];
    this._contextMenuProvider = options.contextMenuProvider;
    this.actions = options.actions || [];
    this.actionProvider = options.actionProvider;
    this.menuClassName = options.menuClassName || "";
    this.menuAsChild = !!options.menuAsChild;
  }
  set menuOptions(options) {
    this._menuOptions = options;
  }
  get menuOptions() {
    return this._menuOptions;
  }
  get actions() {
    if (this.actionProvider) {
      return this.actionProvider.getActions();
    }
    return this._actions;
  }
  set actions(actions25) {
    this._actions = actions25;
  }
  show() {
    super.show();
    addClass(this.element, "active");
    this._contextMenuProvider.showContextMenu({
      getAnchor: () => this.element,
      getActions: () => this.actions,
      getActionsContext: () => this.menuOptions ? this.menuOptions.context : null,
      getActionViewItem: (action) => this.menuOptions && this.menuOptions.actionViewItemProvider ? this.menuOptions.actionViewItemProvider(action) : void 0,
      getKeyBinding: (action) => this.menuOptions && this.menuOptions.getKeyBinding ? this.menuOptions.getKeyBinding(action) : void 0,
      getMenuClassName: () => this.menuClassName,
      onHide: () => this.onHide(),
      actionRunner: this.menuOptions ? this.menuOptions.actionRunner : void 0,
      anchorAlignment: this.menuOptions ? this.menuOptions.anchorAlignment : 0,
      domForShadowRoot: this.menuAsChild ? this.element : void 0
    });
  }
  hide() {
    super.hide();
  }
  onHide() {
    this.hide();
    removeClass(this.element, "active");
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdownActionViewItem.js
var DropdownMenuActionViewItem = class extends BaseActionViewItem {
  constructor(action, menuActionsOrProvider, contextMenuProvider, options = {}) {
    super(null, action, options);
    this.options = options;
    this._onDidChangeVisibility = this._register(new Emitter2());
    this.menuActionsOrProvider = menuActionsOrProvider;
    this.contextMenuProvider = contextMenuProvider;
    if (this.options.actionRunner) {
      this.actionRunner = this.options.actionRunner;
    }
  }
  render(container) {
    const labelRenderer = (el) => {
      this.element = append(el, $("a.action-label"));
      const classNames = this.options.classNames ? asArray(this.options.classNames) : [];
      if (!classNames.find((c) => c === "icon")) {
        classNames.push("codicon");
      }
      addClasses(this.element, ...classNames);
      this.element.tabIndex = 0;
      this.element.setAttribute("role", "button");
      this.element.setAttribute("aria-haspopup", "true");
      this.element.setAttribute("aria-expanded", "false");
      this.element.title = this._action.label || "";
      return null;
    };
    const options = {
      contextMenuProvider: this.contextMenuProvider,
      labelRenderer,
      menuAsChild: this.options.menuAsChild
    };
    if (Array.isArray(this.menuActionsOrProvider)) {
      options.actions = this.menuActionsOrProvider;
    } else {
      options.actionProvider = this.menuActionsOrProvider;
    }
    this.dropdownMenu = this._register(new DropdownMenu(container, options));
    this._register(this.dropdownMenu.onDidChangeVisibility((visible) => {
      var _a5;
      (_a5 = this.element) === null || _a5 === void 0 ? void 0 : _a5.setAttribute("aria-expanded", `${visible}`);
      this._onDidChangeVisibility.fire(visible);
    }));
    this.dropdownMenu.menuOptions = {
      actionViewItemProvider: this.options.actionViewItemProvider,
      actionRunner: this.actionRunner,
      getKeyBinding: this.options.keybindingProvider,
      context: this._context
    };
    if (this.options.anchorAlignmentProvider) {
      const that = this;
      this.dropdownMenu.menuOptions = Object.assign(Object.assign({}, this.dropdownMenu.menuOptions), {get anchorAlignment() {
        return that.options.anchorAlignmentProvider();
      }});
    }
  }
  setActionContext(newContext) {
    super.setActionContext(newContext);
    if (this.dropdownMenu) {
      if (this.dropdownMenu.menuOptions) {
        this.dropdownMenu.menuOptions.context = newContext;
      } else {
        this.dropdownMenu.menuOptions = {context: newContext};
      }
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param16 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var AlternativeKeyEmitter = class extends Emitter2 {
  constructor(contextMenuService) {
    super();
    this._subscriptions = new DisposableStore();
    this._isPressed = false;
    this._suppressAltKeyUp = false;
    this._subscriptions.add(domEvent(document.body, "keydown")((e) => {
      this.isPressed = e.altKey || (isWindows || isLinux) && e.shiftKey;
    }));
    this._subscriptions.add(domEvent(document.body, "keyup")((e) => {
      if (this.isPressed) {
        if (this._suppressAltKeyUp) {
          e.preventDefault();
        }
      }
      this._suppressAltKeyUp = false;
      this.isPressed = false;
    }));
    this._subscriptions.add(domEvent(document.body, "mouseleave")((e) => this.isPressed = false));
    this._subscriptions.add(domEvent(document.body, "blur")((e) => this.isPressed = false));
    this._subscriptions.add(contextMenuService.onDidContextMenu(() => this.isPressed = false));
  }
  get isPressed() {
    return this._isPressed;
  }
  set isPressed(value) {
    this._isPressed = value;
    this.fire(this._isPressed);
  }
  suppressAltKeyUp() {
    this._suppressAltKeyUp = true;
  }
  static getInstance(contextMenuService) {
    if (!AlternativeKeyEmitter.instance) {
      AlternativeKeyEmitter.instance = new AlternativeKeyEmitter(contextMenuService);
    }
    return AlternativeKeyEmitter.instance;
  }
  dispose() {
    super.dispose();
    this._subscriptions.dispose();
  }
};
function createAndFillInActionBarActions(menu, options, target, isPrimaryGroup) {
  const groups = menu.getActions(options);
  fillInActions(groups, target, false, isPrimaryGroup);
  return asDisposable(groups);
}
function asDisposable(groups) {
  const disposables = new DisposableStore();
  for (const [, actions25] of groups) {
    for (const action of actions25) {
      disposables.add(action);
    }
  }
  return disposables;
}
function fillInActions(groups, target, useAlternativeActions, isPrimaryGroup = (group) => group === "navigation") {
  for (let tuple of groups) {
    let [group, actions25] = tuple;
    if (useAlternativeActions) {
      actions25 = actions25.map((a) => a instanceof MenuItemAction && !!a.alt ? a.alt : a);
    }
    if (isPrimaryGroup(group)) {
      const to = Array.isArray(target) ? target : target.primary;
      to.unshift(...actions25);
    } else {
      const to = Array.isArray(target) ? target : target.secondary;
      if (to.length > 0) {
        to.push(new Separator());
      }
      to.push(...actions25);
    }
  }
}
var ids = new IdGenerator("menu-item-action-item-icon-");
var ICON_PATH_TO_CSS_RULES = new Map();
var MenuEntryActionViewItem = class MenuEntryActionViewItem2 extends ActionViewItem {
  constructor(_action, _keybindingService, _notificationService, _contextMenuService) {
    super(void 0, _action, {icon: !!(_action.class || _action.item.icon), label: !_action.class && !_action.item.icon});
    this._action = _action;
    this._keybindingService = _keybindingService;
    this._notificationService = _notificationService;
    this._wantsAltCommand = false;
    this._itemClassDispose = this._register(new MutableDisposable());
    this._altKey = AlternativeKeyEmitter.getInstance(_contextMenuService);
  }
  get _commandAction() {
    return this._wantsAltCommand && this._action.alt || this._action;
  }
  onClick(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this._altKey.isPressed) {
      this._altKey.suppressAltKeyUp();
    }
    this.actionRunner.run(this._commandAction, this._context).then(void 0, (err) => this._notificationService.error(err));
  }
  render(container) {
    super.render(container);
    this._updateItemClass(this._action.item);
    let mouseOver = false;
    let alternativeKeyDown = this._altKey.isPressed;
    const updateAltState = () => {
      const wantsAltCommand = mouseOver && alternativeKeyDown;
      if (wantsAltCommand !== this._wantsAltCommand) {
        this._wantsAltCommand = wantsAltCommand;
        this.updateLabel();
        this.updateTooltip();
        this.updateClass();
      }
    };
    if (this._action.alt) {
      this._register(this._altKey.event((value) => {
        alternativeKeyDown = value;
        updateAltState();
      }));
    }
    this._register(domEvent(container, "mouseleave")((_) => {
      mouseOver = false;
      updateAltState();
    }));
    this._register(domEvent(container, "mouseenter")((e) => {
      mouseOver = true;
      updateAltState();
    }));
  }
  updateLabel() {
    if (this.options.label && this.label) {
      this.label.textContent = this._commandAction.label;
    }
  }
  updateTooltip() {
    if (this.label) {
      const keybinding = this._keybindingService.lookupKeybinding(this._commandAction.id);
      const keybindingLabel = keybinding && keybinding.getLabel();
      const tooltip = this._commandAction.tooltip || this._commandAction.label;
      this.label.title = keybindingLabel ? localize("titleAndKb", "{0} ({1})", tooltip, keybindingLabel) : tooltip;
    }
  }
  updateClass() {
    if (this.options.icon) {
      if (this._commandAction !== this._action) {
        if (this._action.alt) {
          this._updateItemClass(this._action.alt.item);
        }
      } else if (this._action.alt) {
        this._updateItemClass(this._action.item);
      }
    }
  }
  _updateItemClass(item) {
    var _a5, _b2;
    this._itemClassDispose.value = void 0;
    const icon = this._commandAction.checked && ((_a5 = item.toggled) === null || _a5 === void 0 ? void 0 : _a5.icon) ? item.toggled.icon : item.icon;
    if (ThemeIcon.isThemeIcon(icon)) {
      const iconClass = ThemeIcon.asClassName(icon);
      if (this.label && iconClass) {
        addClasses(this.label, iconClass);
        this._itemClassDispose.value = toDisposable(() => {
          if (this.label) {
            removeClasses(this.label, iconClass);
          }
        });
      }
    } else if (icon) {
      let iconClass;
      if ((_b2 = icon.dark) === null || _b2 === void 0 ? void 0 : _b2.scheme) {
        const iconPathMapKey = icon.dark.toString();
        if (ICON_PATH_TO_CSS_RULES.has(iconPathMapKey)) {
          iconClass = ICON_PATH_TO_CSS_RULES.get(iconPathMapKey);
        } else {
          iconClass = ids.nextId();
          createCSSRule(`.icon.${iconClass}`, `background-image: ${asCSSUrl(icon.light || icon.dark)}`);
          createCSSRule(`.vs-dark .icon.${iconClass}, .hc-black .icon.${iconClass}`, `background-image: ${asCSSUrl(icon.dark)}`);
          ICON_PATH_TO_CSS_RULES.set(iconPathMapKey, iconClass);
        }
        if (this.label) {
          addClasses(this.label, "icon", iconClass);
          this._itemClassDispose.value = toDisposable(() => {
            if (this.label) {
              removeClasses(this.label, "icon", iconClass);
            }
          });
        }
      }
    }
  }
};
MenuEntryActionViewItem = __decorate16([
  __param16(1, IKeybindingService),
  __param16(2, INotificationService),
  __param16(3, IContextMenuService)
], MenuEntryActionViewItem);
var SubmenuEntryActionViewItem = class SubmenuEntryActionViewItem2 extends DropdownMenuActionViewItem {
  constructor(action, _notificationService, _contextMenuService) {
    var _a5;
    const classNames = [];
    if (action.item.icon) {
      if (ThemeIcon.isThemeIcon(action.item.icon)) {
        classNames.push(ThemeIcon.asClassName(action.item.icon));
      } else if ((_a5 = action.item.icon.dark) === null || _a5 === void 0 ? void 0 : _a5.scheme) {
        const iconPathMapKey = action.item.icon.dark.toString();
        if (ICON_PATH_TO_CSS_RULES.has(iconPathMapKey)) {
          classNames.push("icon", ICON_PATH_TO_CSS_RULES.get(iconPathMapKey));
        } else {
          const className = ids.nextId();
          classNames.push("icon", className);
          createCSSRule(`.icon.${className}`, `background-image: ${asCSSUrl(action.item.icon.light || action.item.icon.dark)}`);
          createCSSRule(`.vs-dark .icon.${className}, .hc-black .icon.${className}`, `background-image: ${asCSSUrl(action.item.icon.dark)}`);
          ICON_PATH_TO_CSS_RULES.set(iconPathMapKey, className);
        }
      }
    }
    super(action, action.actions, _contextMenuService, {classNames});
  }
};
SubmenuEntryActionViewItem = __decorate16([
  __param16(1, INotificationService),
  __param16(2, IContextMenuService)
], SubmenuEntryActionViewItem);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/peekView/peekView.js
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param17 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var IPeekViewService = createDecorator("IPeekViewService");
registerSingleton(IPeekViewService, class {
  constructor() {
    this._widgets = new Map();
  }
  addExclusiveWidget(editor3, widget) {
    const existing = this._widgets.get(editor3);
    if (existing) {
      existing.listener.dispose();
      existing.widget.dispose();
    }
    const remove2 = () => {
      const data = this._widgets.get(editor3);
      if (data && data.widget === widget) {
        data.listener.dispose();
        this._widgets.delete(editor3);
      }
    };
    this._widgets.set(editor3, {widget, listener: widget.onDidClose(remove2)});
  }
});
var PeekContext;
(function(PeekContext2) {
  PeekContext2.inPeekEditor = new RawContextKey("inReferenceSearchEditor", true);
  PeekContext2.notInPeekEditor = PeekContext2.inPeekEditor.toNegated();
})(PeekContext || (PeekContext = {}));
var PeekContextController = class PeekContextController2 {
  constructor(editor3, contextKeyService) {
    if (editor3 instanceof EmbeddedCodeEditorWidget) {
      PeekContext.inPeekEditor.bindTo(contextKeyService);
    }
  }
  dispose() {
  }
};
PeekContextController.ID = "editor.contrib.referenceController";
PeekContextController = __decorate17([
  __param17(1, IContextKeyService)
], PeekContextController);
registerEditorContribution(PeekContextController.ID, PeekContextController);
function getOuterEditor(accessor) {
  let editor3 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
  if (editor3 instanceof EmbeddedCodeEditorWidget) {
    return editor3.getParentEditor();
  }
  return editor3;
}
var defaultOptions2 = {
  headerBackgroundColor: Color.white,
  primaryHeadingColor: Color.fromHex("#333333"),
  secondaryHeadingColor: Color.fromHex("#6c6c6cb3")
};
var PeekViewWidget = class PeekViewWidget2 extends ZoneWidget {
  constructor(editor3, options, instantiationService) {
    super(editor3, options);
    this.instantiationService = instantiationService;
    this._onDidClose = new Emitter2();
    this.onDidClose = this._onDidClose.event;
    mixin(this.options, defaultOptions2, false);
  }
  dispose() {
    super.dispose();
    this._onDidClose.fire(this);
  }
  style(styles40) {
    let options = this.options;
    if (styles40.headerBackgroundColor) {
      options.headerBackgroundColor = styles40.headerBackgroundColor;
    }
    if (styles40.primaryHeadingColor) {
      options.primaryHeadingColor = styles40.primaryHeadingColor;
    }
    if (styles40.secondaryHeadingColor) {
      options.secondaryHeadingColor = styles40.secondaryHeadingColor;
    }
    super.style(styles40);
  }
  _applyStyles() {
    super._applyStyles();
    let options = this.options;
    if (this._headElement && options.headerBackgroundColor) {
      this._headElement.style.backgroundColor = options.headerBackgroundColor.toString();
    }
    if (this._primaryHeading && options.primaryHeadingColor) {
      this._primaryHeading.style.color = options.primaryHeadingColor.toString();
    }
    if (this._secondaryHeading && options.secondaryHeadingColor) {
      this._secondaryHeading.style.color = options.secondaryHeadingColor.toString();
    }
    if (this._bodyElement && options.frameColor) {
      this._bodyElement.style.borderColor = options.frameColor.toString();
    }
  }
  _fillContainer(container) {
    this.setCssClass("peekview-widget");
    this._headElement = $(".head");
    this._bodyElement = $(".body");
    this._fillHead(this._headElement);
    this._fillBody(this._bodyElement);
    container.appendChild(this._headElement);
    container.appendChild(this._bodyElement);
  }
  _fillHead(container, noCloseAction) {
    const titleElement = $(".peekview-title");
    append(this._headElement, titleElement);
    addStandardDisposableListener(titleElement, "click", (event) => this._onTitleClick(event));
    this._fillTitleIcon(titleElement);
    this._primaryHeading = $("span.filename");
    this._secondaryHeading = $("span.dirname");
    this._metaHeading = $("span.meta");
    append(titleElement, this._primaryHeading, this._secondaryHeading, this._metaHeading);
    const actionsContainer = $(".peekview-actions");
    append(this._headElement, actionsContainer);
    const actionBarOptions = this._getActionBarOptions();
    this._actionbarWidget = new ActionBar(actionsContainer, actionBarOptions);
    this._disposables.add(this._actionbarWidget);
    if (!noCloseAction) {
      this._actionbarWidget.push(new Action("peekview.close", localize("label.close", "Close"), Codicon.close.classNames, true, () => {
        this.dispose();
        return Promise.resolve();
      }), {label: false, icon: true});
    }
  }
  _fillTitleIcon(container) {
  }
  _getActionBarOptions() {
    return {
      actionViewItemProvider: (action) => {
        if (action instanceof MenuItemAction) {
          return this.instantiationService.createInstance(MenuEntryActionViewItem, action);
        } else if (action instanceof SubmenuItemAction) {
          return this.instantiationService.createInstance(SubmenuEntryActionViewItem, action);
        }
        return void 0;
      }
    };
  }
  _onTitleClick(event) {
  }
  setTitle(primaryHeading, secondaryHeading) {
    if (this._primaryHeading && this._secondaryHeading) {
      this._primaryHeading.innerText = primaryHeading;
      this._primaryHeading.setAttribute("aria-label", primaryHeading);
      if (secondaryHeading) {
        this._secondaryHeading.innerText = secondaryHeading;
      } else {
        clearNode(this._secondaryHeading);
      }
    }
  }
  setMetaTitle(value) {
    if (this._metaHeading) {
      if (value) {
        this._metaHeading.innerText = value;
        show(this._metaHeading);
      } else {
        hide(this._metaHeading);
      }
    }
  }
  _doLayout(heightInPixel, widthInPixel) {
    if (!this._isShowing && heightInPixel < 0) {
      this.dispose();
      return;
    }
    const headHeight = Math.ceil(this.editor.getOption(51) * 1.2);
    const bodyHeight = Math.round(heightInPixel - (headHeight + 2));
    this._doLayoutHead(headHeight, widthInPixel);
    this._doLayoutBody(bodyHeight, widthInPixel);
  }
  _doLayoutHead(heightInPixel, widthInPixel) {
    if (this._headElement) {
      this._headElement.style.height = `${heightInPixel}px`;
      this._headElement.style.lineHeight = this._headElement.style.height;
    }
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    if (this._bodyElement) {
      this._bodyElement.style.height = `${heightInPixel}px`;
    }
  }
};
PeekViewWidget = __decorate17([
  __param17(2, IInstantiationService)
], PeekViewWidget);
var peekViewTitleBackground = registerColor("peekViewTitle.background", {dark: "#1E1E1E", light: "#FFFFFF", hc: "#0C141F"}, localize("peekViewTitleBackground", "Background color of the peek view title area."));
var peekViewTitleForeground = registerColor("peekViewTitleLabel.foreground", {dark: "#FFFFFF", light: "#333333", hc: "#FFFFFF"}, localize("peekViewTitleForeground", "Color of the peek view title."));
var peekViewTitleInfoForeground = registerColor("peekViewTitleDescription.foreground", {dark: "#ccccccb3", light: "#616161e6", hc: "#FFFFFF99"}, localize("peekViewTitleInfoForeground", "Color of the peek view title info."));
var peekViewBorder = registerColor("peekView.border", {dark: "#007acc", light: "#007acc", hc: contrastBorder}, localize("peekViewBorder", "Color of the peek view borders and arrow."));
var peekViewResultsBackground = registerColor("peekViewResult.background", {dark: "#252526", light: "#F3F3F3", hc: Color.black}, localize("peekViewResultsBackground", "Background color of the peek view result list."));
var peekViewResultsMatchForeground = registerColor("peekViewResult.lineForeground", {dark: "#bbbbbb", light: "#646465", hc: Color.white}, localize("peekViewResultsMatchForeground", "Foreground color for line nodes in the peek view result list."));
var peekViewResultsFileForeground = registerColor("peekViewResult.fileForeground", {dark: Color.white, light: "#1E1E1E", hc: Color.white}, localize("peekViewResultsFileForeground", "Foreground color for file nodes in the peek view result list."));
var peekViewResultsSelectionBackground = registerColor("peekViewResult.selectionBackground", {dark: "#3399ff33", light: "#3399ff33", hc: null}, localize("peekViewResultsSelectionBackground", "Background color of the selected entry in the peek view result list."));
var peekViewResultsSelectionForeground = registerColor("peekViewResult.selectionForeground", {dark: Color.white, light: "#6C6C6C", hc: Color.white}, localize("peekViewResultsSelectionForeground", "Foreground color of the selected entry in the peek view result list."));
var peekViewEditorBackground = registerColor("peekViewEditor.background", {dark: "#001F33", light: "#F2F8FC", hc: Color.black}, localize("peekViewEditorBackground", "Background color of the peek view editor."));
var peekViewEditorGutterBackground = registerColor("peekViewEditorGutter.background", {dark: peekViewEditorBackground, light: peekViewEditorBackground, hc: peekViewEditorBackground}, localize("peekViewEditorGutterBackground", "Background color of the gutter in the peek view editor."));
var peekViewResultsMatchHighlight = registerColor("peekViewResult.matchHighlightBackground", {dark: "#ea5c004d", light: "#ea5c004d", hc: null}, localize("peekViewResultsMatchHighlight", "Match highlight color in the peek view result list."));
var peekViewEditorMatchHighlight = registerColor("peekViewEditor.matchHighlightBackground", {dark: "#ff8f0099", light: "#f5d802de", hc: null}, localize("peekViewEditorMatchHighlight", "Match highlight color in the peek view editor."));
var peekViewEditorMatchHighlightBorder = registerColor("peekViewEditor.matchHighlightBorder", {dark: null, light: null, hc: activeContrastBorder}, localize("peekViewEditorMatchHighlightBorder", "Match highlight border in the peek view editor."));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/referencesModel.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var OneReference = class {
  constructor(isProviderFirst, parent2, uri, _range, _rangeCallback) {
    this.isProviderFirst = isProviderFirst;
    this.parent = parent2;
    this.uri = uri;
    this._range = _range;
    this._rangeCallback = _rangeCallback;
    this.id = defaultGenerator.nextId();
  }
  get range() {
    return this._range;
  }
  set range(value) {
    this._range = value;
    this._rangeCallback(this);
  }
  get ariaMessage() {
    return localize("aria.oneReference", "symbol in {0} on line {1} at column {2}", basename(this.uri), this.range.startLineNumber, this.range.startColumn);
  }
};
var FilePreview = class {
  constructor(_modelReference) {
    this._modelReference = _modelReference;
  }
  dispose() {
    this._modelReference.dispose();
  }
  preview(range2, n = 8) {
    const model = this._modelReference.object.textEditorModel;
    if (!model) {
      return void 0;
    }
    const {startLineNumber, startColumn, endLineNumber, endColumn} = range2;
    const word = model.getWordUntilPosition({lineNumber: startLineNumber, column: startColumn - n});
    const beforeRange = new Range2(startLineNumber, word.startColumn, startLineNumber, startColumn);
    const afterRange = new Range2(endLineNumber, endColumn, endLineNumber, 1073741824);
    const before = model.getValueInRange(beforeRange).replace(/^\s+/, "");
    const inside = model.getValueInRange(range2);
    const after = model.getValueInRange(afterRange).replace(/\s+$/, "");
    return {
      value: before + inside + after,
      highlight: {start: before.length, end: before.length + inside.length}
    };
  }
};
var FileReferences = class {
  constructor(parent2, uri) {
    this.parent = parent2;
    this.uri = uri;
    this.children = [];
    this._previews = new ResourceMap();
  }
  dispose() {
    dispose(this._previews.values());
    this._previews.clear();
  }
  getPreview(child) {
    return this._previews.get(child.uri);
  }
  get ariaMessage() {
    const len = this.children.length;
    if (len === 1) {
      return localize("aria.fileReferences.1", "1 symbol in {0}, full path {1}", basename(this.uri), this.uri.fsPath);
    } else {
      return localize("aria.fileReferences.N", "{0} symbols in {1}, full path {2}", len, basename(this.uri), this.uri.fsPath);
    }
  }
  resolve(textModelResolverService) {
    return __awaiter13(this, void 0, void 0, function* () {
      if (this._previews.size !== 0) {
        return this;
      }
      for (let child of this.children) {
        if (this._previews.has(child.uri)) {
          continue;
        }
        try {
          const ref = yield textModelResolverService.createModelReference(child.uri);
          this._previews.set(child.uri, new FilePreview(ref));
        } catch (err) {
          onUnexpectedError(err);
        }
      }
      return this;
    });
  }
};
var ReferencesModel = class {
  constructor(links, title) {
    this._disposables = new DisposableStore();
    this.groups = [];
    this.references = [];
    this._onDidChangeReferenceRange = new Emitter2();
    this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event;
    this._links = links;
    this._title = title;
    const [providersFirst] = links;
    links.sort(ReferencesModel._compareReferences);
    let current2;
    for (let link of links) {
      if (!current2 || !extUri.isEqual(current2.uri, link.uri, true)) {
        current2 = new FileReferences(this, link.uri);
        this.groups.push(current2);
      }
      if (current2.children.length === 0 || ReferencesModel._compareReferences(link, current2.children[current2.children.length - 1]) !== 0) {
        const oneRef = new OneReference(providersFirst === link, current2, link.uri, link.targetSelectionRange || link.range, (ref) => this._onDidChangeReferenceRange.fire(ref));
        this.references.push(oneRef);
        current2.children.push(oneRef);
      }
    }
  }
  dispose() {
    dispose(this.groups);
    this._disposables.dispose();
    this._onDidChangeReferenceRange.dispose();
    this.groups.length = 0;
  }
  clone() {
    return new ReferencesModel(this._links, this._title);
  }
  get title() {
    return this._title;
  }
  get isEmpty() {
    return this.groups.length === 0;
  }
  get ariaMessage() {
    if (this.isEmpty) {
      return localize("aria.result.0", "No results found");
    } else if (this.references.length === 1) {
      return localize("aria.result.1", "Found 1 symbol in {0}", this.references[0].uri.fsPath);
    } else if (this.groups.length === 1) {
      return localize("aria.result.n1", "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath);
    } else {
      return localize("aria.result.nm", "Found {0} symbols in {1} files", this.references.length, this.groups.length);
    }
  }
  nextOrPreviousReference(reference, next) {
    let {parent: parent2} = reference;
    let idx = parent2.children.indexOf(reference);
    let childCount = parent2.children.length;
    let groupCount = parent2.parent.groups.length;
    if (groupCount === 1 || next && idx + 1 < childCount || !next && idx > 0) {
      if (next) {
        idx = (idx + 1) % childCount;
      } else {
        idx = (idx + childCount - 1) % childCount;
      }
      return parent2.children[idx];
    }
    idx = parent2.parent.groups.indexOf(parent2);
    if (next) {
      idx = (idx + 1) % groupCount;
      return parent2.parent.groups[idx].children[0];
    } else {
      idx = (idx + groupCount - 1) % groupCount;
      return parent2.parent.groups[idx].children[parent2.parent.groups[idx].children.length - 1];
    }
  }
  nearestReference(resource, position) {
    const nearest = this.references.map((ref, idx) => {
      return {
        idx,
        prefixLen: commonPrefixLength(ref.uri.toString(), resource.toString()),
        offsetDist: Math.abs(ref.range.startLineNumber - position.lineNumber) * 100 + Math.abs(ref.range.startColumn - position.column)
      };
    }).sort((a, b) => {
      if (a.prefixLen > b.prefixLen) {
        return -1;
      } else if (a.prefixLen < b.prefixLen) {
        return 1;
      } else if (a.offsetDist < b.offsetDist) {
        return -1;
      } else if (a.offsetDist > b.offsetDist) {
        return 1;
      } else {
        return 0;
      }
    })[0];
    if (nearest) {
      return this.references[nearest.idx];
    }
    return void 0;
  }
  referenceAt(resource, position) {
    for (const ref of this.references) {
      if (ref.uri.toString() === resource.toString()) {
        if (Range2.containsPosition(ref.range, position)) {
          return ref;
        }
      }
    }
    return void 0;
  }
  firstReference() {
    for (const ref of this.references) {
      if (ref.isProviderFirst) {
        return ref;
      }
    }
    return this.references[0];
  }
  static _compareReferences(a, b) {
    return extUri.compare(a.uri, b.uri) || Range2.compareRangesUsingStarts(a.range, b.range);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/labels.js
function getPathLabel(resource, userHomeProvider, rootProvider) {
  if (typeof resource === "string") {
    resource = URI.file(resource);
  }
  if (rootProvider) {
    const baseResource = rootProvider.getWorkspaceFolder(resource);
    if (baseResource) {
      const hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;
      let pathLabel;
      if (isEqual(baseResource.uri, resource)) {
        pathLabel = "";
      } else {
        pathLabel = relativePath(baseResource.uri, resource);
      }
      if (hasMultipleRoots) {
        const rootName = baseResource.name ? baseResource.name : basename(baseResource.uri);
        pathLabel = pathLabel ? rootName + " \u2022 " + pathLabel : rootName;
      }
      return pathLabel;
    }
  }
  if (resource.scheme !== Schemas.file && resource.scheme !== Schemas.untitled) {
    return resource.with({query: null, fragment: null}).toString(true);
  }
  if (hasDriveLetter(resource.fsPath)) {
    return normalize(normalizeDriveLetter(resource.fsPath));
  }
  let res = normalize(resource.fsPath);
  if (!isWindows && (userHomeProvider === null || userHomeProvider === void 0 ? void 0 : userHomeProvider.userHome)) {
    res = tildify(res, userHomeProvider.userHome.fsPath);
  }
  return res;
}
function getBaseLabel(resource) {
  if (!resource) {
    return void 0;
  }
  if (typeof resource === "string") {
    resource = URI.file(resource);
  }
  const base = basename(resource) || (resource.scheme === Schemas.file ? resource.fsPath : resource.path);
  if (hasDriveLetter(base)) {
    return normalizeDriveLetter(base);
  }
  return base;
}
function hasDriveLetter(path3) {
  return !!(isWindows && path3 && path3[1] === ":");
}
function normalizeDriveLetter(path3) {
  if (hasDriveLetter(path3)) {
    return path3.charAt(0).toUpperCase() + path3.slice(1);
  }
  return path3;
}
var normalizedUserHomeCached = Object.create(null);
function tildify(path3, userHome) {
  if (isWindows || !path3 || !userHome) {
    return path3;
  }
  let normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : void 0;
  if (!normalizedUserHome) {
    normalizedUserHome = `${rtrim(userHome, posix.sep)}${posix.sep}`;
    normalizedUserHomeCached = {original: userHome, normalized: normalizedUserHome};
  }
  if (isLinux ? path3.startsWith(normalizedUserHome) : startsWithIgnoreCase(path3, normalizedUserHome)) {
    path3 = `~/${path3.substr(normalizedUserHome.length)}`;
  }
  return path3;
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesTree.js
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param18 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DataSource = class DataSource2 {
  constructor(_resolverService) {
    this._resolverService = _resolverService;
  }
  hasChildren(element) {
    if (element instanceof ReferencesModel) {
      return true;
    }
    if (element instanceof FileReferences) {
      return true;
    }
    return false;
  }
  getChildren(element) {
    if (element instanceof ReferencesModel) {
      return element.groups;
    }
    if (element instanceof FileReferences) {
      return element.resolve(this._resolverService).then((val) => {
        return val.children;
      });
    }
    throw new Error("bad tree");
  }
};
DataSource = __decorate18([
  __param18(0, ITextModelService)
], DataSource);
var Delegate = class {
  getHeight() {
    return 23;
  }
  getTemplateId(element) {
    if (element instanceof FileReferences) {
      return FileReferencesRenderer.id;
    } else {
      return OneReferenceRenderer.id;
    }
  }
};
var StringRepresentationProvider = class StringRepresentationProvider2 {
  constructor(_keybindingService) {
    this._keybindingService = _keybindingService;
  }
  getKeyboardNavigationLabel(element) {
    var _a5;
    if (element instanceof OneReference) {
      const parts = (_a5 = element.parent.getPreview(element)) === null || _a5 === void 0 ? void 0 : _a5.preview(element.range);
      if (parts) {
        return parts.value;
      }
    }
    return basename(element.uri);
  }
};
StringRepresentationProvider = __decorate18([
  __param18(0, IKeybindingService)
], StringRepresentationProvider);
var IdentityProvider = class {
  getId(element) {
    return element instanceof OneReference ? element.id : element.uri;
  }
};
var FileReferencesTemplate = class FileReferencesTemplate2 extends Disposable {
  constructor(container, _uriLabel, themeService) {
    super();
    this._uriLabel = _uriLabel;
    const parent2 = document.createElement("div");
    parent2.classList.add("reference-file");
    this.file = this._register(new IconLabel(parent2, {supportHighlights: true}));
    this.badge = new CountBadge(append(parent2, $(".count")));
    this._register(attachBadgeStyler(this.badge, themeService));
    container.appendChild(parent2);
  }
  set(element, matches) {
    let parent2 = dirname(element.uri);
    this.file.setLabel(getBaseLabel(element.uri), this._uriLabel.getUriLabel(parent2, {relative: true}), {title: this._uriLabel.getUriLabel(element.uri), matches});
    const len = element.children.length;
    this.badge.setCount(len);
    if (len > 1) {
      this.badge.setTitleFormat(localize("referencesCount", "{0} references", len));
    } else {
      this.badge.setTitleFormat(localize("referenceCount", "{0} reference", len));
    }
  }
};
FileReferencesTemplate = __decorate18([
  __param18(1, ILabelService),
  __param18(2, IThemeService)
], FileReferencesTemplate);
var FileReferencesRenderer = class FileReferencesRenderer2 {
  constructor(_instantiationService) {
    this._instantiationService = _instantiationService;
    this.templateId = FileReferencesRenderer2.id;
  }
  renderTemplate(container) {
    return this._instantiationService.createInstance(FileReferencesTemplate, container);
  }
  renderElement(node, index2, template) {
    template.set(node.element, createMatches(node.filterData));
  }
  disposeTemplate(templateData) {
    templateData.dispose();
  }
};
FileReferencesRenderer.id = "FileReferencesRenderer";
FileReferencesRenderer = __decorate18([
  __param18(0, IInstantiationService)
], FileReferencesRenderer);
var OneReferenceTemplate = class {
  constructor(container) {
    this.label = new HighlightedLabel(container, false);
  }
  set(element, score) {
    var _a5;
    const preview = (_a5 = element.parent.getPreview(element)) === null || _a5 === void 0 ? void 0 : _a5.preview(element.range);
    if (!preview || !preview.value) {
      this.label.set(`${basename(element.uri)}:${element.range.startLineNumber + 1}:${element.range.startColumn + 1}`);
    } else {
      const {value, highlight} = preview;
      if (score && !FuzzyScore.isDefault(score)) {
        this.label.element.classList.toggle("referenceMatch", false);
        this.label.set(value, createMatches(score));
      } else {
        this.label.element.classList.toggle("referenceMatch", true);
        this.label.set(value, [highlight]);
      }
    }
  }
};
var OneReferenceRenderer = class {
  constructor() {
    this.templateId = OneReferenceRenderer.id;
  }
  renderTemplate(container) {
    return new OneReferenceTemplate(container);
  }
  renderElement(node, index2, templateData) {
    templateData.set(node.element, node.filterData);
  }
  disposeTemplate() {
  }
};
OneReferenceRenderer.id = "OneReferenceRenderer";
var AccessibilityProvider = class {
  getWidgetAriaLabel() {
    return localize("treeAriaLabel", "References");
  }
  getAriaLabel(element) {
    return element.ariaMessage;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/splitview/splitview.js
var defaultStyles = {
  separatorBorder: Color.transparent
};
var ViewItem = class {
  constructor(container, view, size, disposable) {
    this.container = container;
    this.view = view;
    this.disposable = disposable;
    this._cachedVisibleSize = void 0;
    if (typeof size === "number") {
      this._size = size;
      this._cachedVisibleSize = void 0;
      addClass(container, "visible");
    } else {
      this._size = 0;
      this._cachedVisibleSize = size.cachedVisibleSize;
    }
  }
  set size(size) {
    this._size = size;
  }
  get size() {
    return this._size;
  }
  get visible() {
    return typeof this._cachedVisibleSize === "undefined";
  }
  setVisible(visible, size) {
    if (visible === this.visible) {
      return;
    }
    if (visible) {
      this.size = clamp(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize);
      this._cachedVisibleSize = void 0;
    } else {
      this._cachedVisibleSize = typeof size === "number" ? size : this.size;
      this.size = 0;
    }
    toggleClass(this.container, "visible", visible);
    if (this.view.setVisible) {
      this.view.setVisible(visible);
    }
  }
  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }
  get viewMinimumSize() {
    return this.view.minimumSize;
  }
  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }
  get viewMaximumSize() {
    return this.view.maximumSize;
  }
  get priority() {
    return this.view.priority;
  }
  get snap() {
    return !!this.view.snap;
  }
  set enabled(enabled) {
    this.container.style.pointerEvents = enabled ? "" : "none";
  }
  layout(offset, layoutContext) {
    this.layoutContainer(offset);
    this.view.layout(this.size, offset, layoutContext);
  }
  dispose() {
    this.disposable.dispose();
    return this.view;
  }
};
var VerticalViewItem = class extends ViewItem {
  layoutContainer(offset) {
    this.container.style.top = `${offset}px`;
    this.container.style.height = `${this.size}px`;
  }
};
var HorizontalViewItem = class extends ViewItem {
  layoutContainer(offset) {
    this.container.style.left = `${offset}px`;
    this.container.style.width = `${this.size}px`;
  }
};
var State3;
(function(State7) {
  State7[State7["Idle"] = 0] = "Idle";
  State7[State7["Busy"] = 1] = "Busy";
})(State3 || (State3 = {}));
var Sizing;
(function(Sizing2) {
  Sizing2.Distribute = {type: "distribute"};
  function Split(index2) {
    return {type: "split", index: index2};
  }
  Sizing2.Split = Split;
  function Invisible(cachedVisibleSize) {
    return {type: "invisible", cachedVisibleSize};
  }
  Sizing2.Invisible = Invisible;
})(Sizing || (Sizing = {}));
var SplitView = class extends Disposable {
  constructor(container, options = {}) {
    super();
    this.size = 0;
    this.contentSize = 0;
    this.proportions = void 0;
    this.viewItems = [];
    this.sashItems = [];
    this.state = State3.Idle;
    this._onDidSashChange = this._register(new Emitter2());
    this.onDidSashChange = this._onDidSashChange.event;
    this._onDidSashReset = this._register(new Emitter2());
    this._startSnappingEnabled = true;
    this._endSnappingEnabled = true;
    this.orientation = isUndefined(options.orientation) ? 0 : options.orientation;
    this.inverseAltBehavior = !!options.inverseAltBehavior;
    this.proportionalLayout = isUndefined(options.proportionalLayout) ? true : !!options.proportionalLayout;
    this.el = document.createElement("div");
    addClass(this.el, "monaco-split-view2");
    addClass(this.el, this.orientation === 0 ? "vertical" : "horizontal");
    container.appendChild(this.el);
    this.sashContainer = append(this.el, $(".sash-container"));
    this.viewContainer = append(this.el, $(".split-view-container"));
    this.style(options.styles || defaultStyles);
    if (options.descriptor) {
      this.size = options.descriptor.size;
      options.descriptor.views.forEach((viewDescriptor, index2) => {
        const sizing = isUndefined(viewDescriptor.visible) || viewDescriptor.visible ? viewDescriptor.size : {type: "invisible", cachedVisibleSize: viewDescriptor.size};
        const view = viewDescriptor.view;
        this.doAddView(view, sizing, index2, true);
      });
      this.contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
      this.saveProportions();
    }
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  set orthogonalStartSash(sash) {
    for (const sashItem of this.sashItems) {
      sashItem.sash.orthogonalStartSash = sash;
    }
    this._orthogonalStartSash = sash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  set orthogonalEndSash(sash) {
    for (const sashItem of this.sashItems) {
      sashItem.sash.orthogonalEndSash = sash;
    }
    this._orthogonalEndSash = sash;
  }
  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }
  set startSnappingEnabled(startSnappingEnabled) {
    if (this._startSnappingEnabled === startSnappingEnabled) {
      return;
    }
    this._startSnappingEnabled = startSnappingEnabled;
    this.updateSashEnablement();
  }
  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  set endSnappingEnabled(endSnappingEnabled) {
    if (this._endSnappingEnabled === endSnappingEnabled) {
      return;
    }
    this._endSnappingEnabled = endSnappingEnabled;
    this.updateSashEnablement();
  }
  style(styles40) {
    if (styles40.separatorBorder.isTransparent()) {
      removeClass(this.el, "separator-border");
      this.el.style.removeProperty("--separator-border");
    } else {
      addClass(this.el, "separator-border");
      this.el.style.setProperty("--separator-border", styles40.separatorBorder.toString());
    }
  }
  addView(view, size, index2 = this.viewItems.length, skipLayout) {
    this.doAddView(view, size, index2, skipLayout);
  }
  layout(size, layoutContext) {
    const previousSize = Math.max(this.size, this.contentSize);
    this.size = size;
    this.layoutContext = layoutContext;
    if (!this.proportions) {
      const indexes = range(this.viewItems.length);
      const lowPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 1);
      const highPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 2);
      this.resize(this.viewItems.length - 1, size - previousSize, void 0, lowPriorityIndexes, highPriorityIndexes);
    } else {
      for (let i = 0; i < this.viewItems.length; i++) {
        const item = this.viewItems[i];
        item.size = clamp(Math.round(this.proportions[i] * size), item.minimumSize, item.maximumSize);
      }
    }
    this.distributeEmptySpace();
    this.layoutViews();
  }
  saveProportions() {
    if (this.proportionalLayout && this.contentSize > 0) {
      this.proportions = this.viewItems.map((i) => i.size / this.contentSize);
    }
  }
  onSashStart({sash, start, alt}) {
    for (const item of this.viewItems) {
      item.enabled = false;
    }
    const index2 = firstIndex(this.sashItems, (item) => item.sash === sash);
    const disposable = combinedDisposable(domEvent(document.body, "keydown")((e) => resetSashDragState(this.sashDragState.current, e.altKey)), domEvent(document.body, "keyup")(() => resetSashDragState(this.sashDragState.current, false)));
    const resetSashDragState = (start2, alt2) => {
      const sizes = this.viewItems.map((i) => i.size);
      let minDelta = Number.NEGATIVE_INFINITY;
      let maxDelta = Number.POSITIVE_INFINITY;
      if (this.inverseAltBehavior) {
        alt2 = !alt2;
      }
      if (alt2) {
        const isLastSash = index2 === this.sashItems.length - 1;
        if (isLastSash) {
          const viewItem = this.viewItems[index2];
          minDelta = (viewItem.minimumSize - viewItem.size) / 2;
          maxDelta = (viewItem.maximumSize - viewItem.size) / 2;
        } else {
          const viewItem = this.viewItems[index2 + 1];
          minDelta = (viewItem.size - viewItem.maximumSize) / 2;
          maxDelta = (viewItem.size - viewItem.minimumSize) / 2;
        }
      }
      let snapBefore;
      let snapAfter;
      if (!alt2) {
        const upIndexes = range(index2, -1);
        const downIndexes = range(index2 + 1, this.viewItems.length);
        const minDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].minimumSize - sizes[i]), 0);
        const maxDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].viewMaximumSize - sizes[i]), 0);
        const maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].minimumSize), 0);
        const minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].viewMaximumSize), 0);
        const minDelta2 = Math.max(minDeltaUp, minDeltaDown);
        const maxDelta2 = Math.min(maxDeltaDown, maxDeltaUp);
        const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);
        const snapAfterIndex = this.findFirstSnapIndex(downIndexes);
        if (typeof snapBeforeIndex === "number") {
          const viewItem = this.viewItems[snapBeforeIndex];
          const halfSize = Math.floor(viewItem.viewMinimumSize / 2);
          snapBefore = {
            index: snapBeforeIndex,
            limitDelta: viewItem.visible ? minDelta2 - halfSize : minDelta2 + halfSize,
            size: viewItem.size
          };
        }
        if (typeof snapAfterIndex === "number") {
          const viewItem = this.viewItems[snapAfterIndex];
          const halfSize = Math.floor(viewItem.viewMinimumSize / 2);
          snapAfter = {
            index: snapAfterIndex,
            limitDelta: viewItem.visible ? maxDelta2 + halfSize : maxDelta2 - halfSize,
            size: viewItem.size
          };
        }
      }
      this.sashDragState = {start: start2, current: start2, index: index2, sizes, minDelta, maxDelta, alt: alt2, snapBefore, snapAfter, disposable};
    };
    resetSashDragState(start, alt);
  }
  onSashChange({current: current2}) {
    const {index: index2, start, sizes, alt, minDelta, maxDelta, snapBefore, snapAfter} = this.sashDragState;
    this.sashDragState.current = current2;
    const delta = current2 - start;
    const newDelta = this.resize(index2, delta, sizes, void 0, void 0, minDelta, maxDelta, snapBefore, snapAfter);
    if (alt) {
      const isLastSash = index2 === this.sashItems.length - 1;
      const newSizes = this.viewItems.map((i) => i.size);
      const viewItemIndex = isLastSash ? index2 : index2 + 1;
      const viewItem = this.viewItems[viewItemIndex];
      const newMinDelta = viewItem.size - viewItem.maximumSize;
      const newMaxDelta = viewItem.size - viewItem.minimumSize;
      const resizeIndex = isLastSash ? index2 - 1 : index2 + 1;
      this.resize(resizeIndex, -newDelta, newSizes, void 0, void 0, newMinDelta, newMaxDelta);
    }
    this.distributeEmptySpace();
    this.layoutViews();
  }
  onSashEnd(index2) {
    this._onDidSashChange.fire(index2);
    this.sashDragState.disposable.dispose();
    this.saveProportions();
    for (const item of this.viewItems) {
      item.enabled = true;
    }
  }
  onViewChange(item, size) {
    const index2 = this.viewItems.indexOf(item);
    if (index2 < 0 || index2 >= this.viewItems.length) {
      return;
    }
    size = typeof size === "number" ? size : item.size;
    size = clamp(size, item.minimumSize, item.maximumSize);
    if (this.inverseAltBehavior && index2 > 0) {
      this.resize(index2 - 1, Math.floor((item.size - size) / 2));
      this.distributeEmptySpace();
      this.layoutViews();
    } else {
      item.size = size;
      this.relayout([index2], void 0);
    }
  }
  resizeView(index2, size) {
    if (this.state !== State3.Idle) {
      throw new Error("Cant modify splitview");
    }
    this.state = State3.Busy;
    if (index2 < 0 || index2 >= this.viewItems.length) {
      return;
    }
    const indexes = range(this.viewItems.length).filter((i) => i !== index2);
    const lowPriorityIndexes = [...indexes.filter((i) => this.viewItems[i].priority === 1), index2];
    const highPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 2);
    const item = this.viewItems[index2];
    size = Math.round(size);
    size = clamp(size, item.minimumSize, Math.min(item.maximumSize, this.size));
    item.size = size;
    this.relayout(lowPriorityIndexes, highPriorityIndexes);
    this.state = State3.Idle;
  }
  distributeViewSizes() {
    const flexibleViewItems = [];
    let flexibleSize = 0;
    for (const item of this.viewItems) {
      if (item.maximumSize - item.minimumSize > 0) {
        flexibleViewItems.push(item);
        flexibleSize += item.size;
      }
    }
    const size = Math.floor(flexibleSize / flexibleViewItems.length);
    for (const item of flexibleViewItems) {
      item.size = clamp(size, item.minimumSize, item.maximumSize);
    }
    const indexes = range(this.viewItems.length);
    const lowPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 1);
    const highPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 2);
    this.relayout(lowPriorityIndexes, highPriorityIndexes);
  }
  getViewSize(index2) {
    if (index2 < 0 || index2 >= this.viewItems.length) {
      return -1;
    }
    return this.viewItems[index2].size;
  }
  doAddView(view, size, index2 = this.viewItems.length, skipLayout) {
    if (this.state !== State3.Idle) {
      throw new Error("Cant modify splitview");
    }
    this.state = State3.Busy;
    const container = $(".split-view-view");
    if (index2 === this.viewItems.length) {
      this.viewContainer.appendChild(container);
    } else {
      this.viewContainer.insertBefore(container, this.viewContainer.children.item(index2));
    }
    const onChangeDisposable = view.onDidChange((size2) => this.onViewChange(item, size2));
    const containerDisposable = toDisposable(() => this.viewContainer.removeChild(container));
    const disposable = combinedDisposable(onChangeDisposable, containerDisposable);
    let viewSize;
    if (typeof size === "number") {
      viewSize = size;
    } else if (size.type === "split") {
      viewSize = this.getViewSize(size.index) / 2;
    } else if (size.type === "invisible") {
      viewSize = {cachedVisibleSize: size.cachedVisibleSize};
    } else {
      viewSize = view.minimumSize;
    }
    const item = this.orientation === 0 ? new VerticalViewItem(container, view, viewSize, disposable) : new HorizontalViewItem(container, view, viewSize, disposable);
    this.viewItems.splice(index2, 0, item);
    if (this.viewItems.length > 1) {
      const sash = this.orientation === 0 ? new Sash(this.sashContainer, {getHorizontalSashTop: (sash2) => this.getSashPosition(sash2)}, {
        orientation: 1,
        orthogonalStartSash: this.orthogonalStartSash,
        orthogonalEndSash: this.orthogonalEndSash
      }) : new Sash(this.sashContainer, {getVerticalSashLeft: (sash2) => this.getSashPosition(sash2)}, {
        orientation: 0,
        orthogonalStartSash: this.orthogonalStartSash,
        orthogonalEndSash: this.orthogonalEndSash
      });
      const sashEventMapper = this.orientation === 0 ? (e) => ({sash, start: e.startY, current: e.currentY, alt: e.altKey}) : (e) => ({sash, start: e.startX, current: e.currentX, alt: e.altKey});
      const onStart = Event.map(sash.onDidStart, sashEventMapper);
      const onStartDisposable = onStart(this.onSashStart, this);
      const onChange = Event.map(sash.onDidChange, sashEventMapper);
      const onChangeDisposable2 = onChange(this.onSashChange, this);
      const onEnd = Event.map(sash.onDidEnd, () => firstIndex(this.sashItems, (item2) => item2.sash === sash));
      const onEndDisposable = onEnd(this.onSashEnd, this);
      const onDidResetDisposable = sash.onDidReset(() => {
        const index3 = firstIndex(this.sashItems, (item2) => item2.sash === sash);
        const upIndexes = range(index3, -1);
        const downIndexes = range(index3 + 1, this.viewItems.length);
        const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);
        const snapAfterIndex = this.findFirstSnapIndex(downIndexes);
        if (typeof snapBeforeIndex === "number" && !this.viewItems[snapBeforeIndex].visible) {
          return;
        }
        if (typeof snapAfterIndex === "number" && !this.viewItems[snapAfterIndex].visible) {
          return;
        }
        this._onDidSashReset.fire(index3);
      });
      const disposable2 = combinedDisposable(onStartDisposable, onChangeDisposable2, onEndDisposable, onDidResetDisposable, sash);
      const sashItem = {sash, disposable: disposable2};
      this.sashItems.splice(index2 - 1, 0, sashItem);
    }
    container.appendChild(view.element);
    let highPriorityIndexes;
    if (typeof size !== "number" && size.type === "split") {
      highPriorityIndexes = [size.index];
    }
    if (!skipLayout) {
      this.relayout([index2], highPriorityIndexes);
    }
    this.state = State3.Idle;
    if (!skipLayout && typeof size !== "number" && size.type === "distribute") {
      this.distributeViewSizes();
    }
  }
  relayout(lowPriorityIndexes, highPriorityIndexes) {
    const contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
    this.resize(this.viewItems.length - 1, this.size - contentSize, void 0, lowPriorityIndexes, highPriorityIndexes);
    this.distributeEmptySpace();
    this.layoutViews();
    this.saveProportions();
  }
  resize(index2, delta, sizes = this.viewItems.map((i) => i.size), lowPriorityIndexes, highPriorityIndexes, overloadMinDelta = Number.NEGATIVE_INFINITY, overloadMaxDelta = Number.POSITIVE_INFINITY, snapBefore, snapAfter) {
    if (index2 < 0 || index2 >= this.viewItems.length) {
      return 0;
    }
    const upIndexes = range(index2, -1);
    const downIndexes = range(index2 + 1, this.viewItems.length);
    if (highPriorityIndexes) {
      for (const index3 of highPriorityIndexes) {
        pushToStart(upIndexes, index3);
        pushToStart(downIndexes, index3);
      }
    }
    if (lowPriorityIndexes) {
      for (const index3 of lowPriorityIndexes) {
        pushToEnd(upIndexes, index3);
        pushToEnd(downIndexes, index3);
      }
    }
    const upItems = upIndexes.map((i) => this.viewItems[i]);
    const upSizes = upIndexes.map((i) => sizes[i]);
    const downItems = downIndexes.map((i) => this.viewItems[i]);
    const downSizes = downIndexes.map((i) => sizes[i]);
    const minDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].minimumSize - sizes[i]), 0);
    const maxDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].maximumSize - sizes[i]), 0);
    const maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].minimumSize), 0);
    const minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].maximumSize), 0);
    const minDelta = Math.max(minDeltaUp, minDeltaDown, overloadMinDelta);
    const maxDelta = Math.min(maxDeltaDown, maxDeltaUp, overloadMaxDelta);
    let snapped = false;
    if (snapBefore) {
      const snapView = this.viewItems[snapBefore.index];
      const visible = delta >= snapBefore.limitDelta;
      snapped = visible !== snapView.visible;
      snapView.setVisible(visible, snapBefore.size);
    }
    if (!snapped && snapAfter) {
      const snapView = this.viewItems[snapAfter.index];
      const visible = delta < snapAfter.limitDelta;
      snapped = visible !== snapView.visible;
      snapView.setVisible(visible, snapAfter.size);
    }
    if (snapped) {
      return this.resize(index2, delta, sizes, lowPriorityIndexes, highPriorityIndexes, overloadMinDelta, overloadMaxDelta);
    }
    delta = clamp(delta, minDelta, maxDelta);
    for (let i = 0, deltaUp = delta; i < upItems.length; i++) {
      const item = upItems[i];
      const size = clamp(upSizes[i] + deltaUp, item.minimumSize, item.maximumSize);
      const viewDelta = size - upSizes[i];
      deltaUp -= viewDelta;
      item.size = size;
    }
    for (let i = 0, deltaDown = delta; i < downItems.length; i++) {
      const item = downItems[i];
      const size = clamp(downSizes[i] - deltaDown, item.minimumSize, item.maximumSize);
      const viewDelta = size - downSizes[i];
      deltaDown += viewDelta;
      item.size = size;
    }
    return delta;
  }
  distributeEmptySpace(lowPriorityIndex) {
    const contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
    let emptyDelta = this.size - contentSize;
    const indexes = range(this.viewItems.length - 1, -1);
    const lowPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 1);
    const highPriorityIndexes = indexes.filter((i) => this.viewItems[i].priority === 2);
    for (const index2 of highPriorityIndexes) {
      pushToStart(indexes, index2);
    }
    for (const index2 of lowPriorityIndexes) {
      pushToEnd(indexes, index2);
    }
    if (typeof lowPriorityIndex === "number") {
      pushToEnd(indexes, lowPriorityIndex);
    }
    for (let i = 0; emptyDelta !== 0 && i < indexes.length; i++) {
      const item = this.viewItems[indexes[i]];
      const size = clamp(item.size + emptyDelta, item.minimumSize, item.maximumSize);
      const viewDelta = size - item.size;
      emptyDelta -= viewDelta;
      item.size = size;
    }
  }
  layoutViews() {
    this.contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
    let offset = 0;
    for (const viewItem of this.viewItems) {
      viewItem.layout(offset, this.layoutContext);
      offset += viewItem.size;
    }
    this.sashItems.forEach((item) => item.sash.layout());
    this.updateSashEnablement();
  }
  updateSashEnablement() {
    let previous = false;
    const collapsesDown = this.viewItems.map((i) => previous = i.size - i.minimumSize > 0 || previous);
    previous = false;
    const expandsDown = this.viewItems.map((i) => previous = i.maximumSize - i.size > 0 || previous);
    const reverseViews = [...this.viewItems].reverse();
    previous = false;
    const collapsesUp = reverseViews.map((i) => previous = i.size - i.minimumSize > 0 || previous).reverse();
    previous = false;
    const expandsUp = reverseViews.map((i) => previous = i.maximumSize - i.size > 0 || previous).reverse();
    let position = 0;
    for (let index2 = 0; index2 < this.sashItems.length; index2++) {
      const {sash} = this.sashItems[index2];
      const viewItem = this.viewItems[index2];
      position += viewItem.size;
      const min = !(collapsesDown[index2] && expandsUp[index2 + 1]);
      const max = !(expandsDown[index2] && collapsesUp[index2 + 1]);
      if (min && max) {
        const upIndexes = range(index2, -1);
        const downIndexes = range(index2 + 1, this.viewItems.length);
        const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);
        const snapAfterIndex = this.findFirstSnapIndex(downIndexes);
        const snappedBefore = typeof snapBeforeIndex === "number" && !this.viewItems[snapBeforeIndex].visible;
        const snappedAfter = typeof snapAfterIndex === "number" && !this.viewItems[snapAfterIndex].visible;
        if (snappedBefore && collapsesUp[index2] && (position > 0 || this.startSnappingEnabled)) {
          sash.state = 1;
        } else if (snappedAfter && collapsesDown[index2] && (position < this.contentSize || this.endSnappingEnabled)) {
          sash.state = 2;
        } else {
          sash.state = 0;
        }
      } else if (min && !max) {
        sash.state = 1;
      } else if (!min && max) {
        sash.state = 2;
      } else {
        sash.state = 3;
      }
    }
  }
  getSashPosition(sash) {
    let position = 0;
    for (let i = 0; i < this.sashItems.length; i++) {
      position += this.viewItems[i].size;
      if (this.sashItems[i].sash === sash) {
        return position;
      }
    }
    return 0;
  }
  findFirstSnapIndex(indexes) {
    for (const index2 of indexes) {
      const viewItem = this.viewItems[index2];
      if (!viewItem.visible) {
        continue;
      }
      if (viewItem.snap) {
        return index2;
      }
    }
    for (const index2 of indexes) {
      const viewItem = this.viewItems[index2];
      if (viewItem.visible && viewItem.maximumSize - viewItem.minimumSize > 0) {
        return void 0;
      }
      if (!viewItem.visible && viewItem.snap) {
        return index2;
      }
    }
    return void 0;
  }
  dispose() {
    super.dispose();
    this.viewItems.forEach((i) => i.dispose());
    this.viewItems = [];
    this.sashItems.forEach((i) => i.disposable.dispose());
    this.sashItems = [];
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.js
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param19 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DecorationsManager = class {
  constructor(_editor, _model) {
    this._editor = _editor;
    this._model = _model;
    this._decorations = new Map();
    this._decorationIgnoreSet = new Set();
    this._callOnDispose = new DisposableStore();
    this._callOnModelChange = new DisposableStore();
    this._callOnDispose.add(this._editor.onDidChangeModel(() => this._onModelChanged()));
    this._onModelChanged();
  }
  dispose() {
    this._callOnModelChange.dispose();
    this._callOnDispose.dispose();
    this.removeDecorations();
  }
  _onModelChanged() {
    this._callOnModelChange.clear();
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    for (let ref of this._model.references) {
      if (ref.uri.toString() === model.uri.toString()) {
        this._addDecorations(ref.parent);
        return;
      }
    }
  }
  _addDecorations(reference) {
    if (!this._editor.hasModel()) {
      return;
    }
    this._callOnModelChange.add(this._editor.getModel().onDidChangeDecorations(() => this._onDecorationChanged()));
    const newDecorations = [];
    const newDecorationsActualIndex = [];
    for (let i = 0, len = reference.children.length; i < len; i++) {
      let oneReference = reference.children[i];
      if (this._decorationIgnoreSet.has(oneReference.id)) {
        continue;
      }
      if (oneReference.uri.toString() !== this._editor.getModel().uri.toString()) {
        continue;
      }
      newDecorations.push({
        range: oneReference.range,
        options: DecorationsManager.DecorationOptions
      });
      newDecorationsActualIndex.push(i);
    }
    const decorations = this._editor.deltaDecorations([], newDecorations);
    for (let i = 0; i < decorations.length; i++) {
      this._decorations.set(decorations[i], reference.children[newDecorationsActualIndex[i]]);
    }
  }
  _onDecorationChanged() {
    const toRemove = [];
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    for (let [decorationId, reference] of this._decorations) {
      const newRange = model.getDecorationRange(decorationId);
      if (!newRange) {
        continue;
      }
      let ignore = false;
      if (Range2.equalsRange(newRange, reference.range)) {
        continue;
      }
      if (Range2.spansMultipleLines(newRange)) {
        ignore = true;
      } else {
        const lineLength = reference.range.endColumn - reference.range.startColumn;
        const newLineLength = newRange.endColumn - newRange.startColumn;
        if (lineLength !== newLineLength) {
          ignore = true;
        }
      }
      if (ignore) {
        this._decorationIgnoreSet.add(reference.id);
        toRemove.push(decorationId);
      } else {
        reference.range = newRange;
      }
    }
    for (let i = 0, len = toRemove.length; i < len; i++) {
      this._decorations.delete(toRemove[i]);
    }
    this._editor.deltaDecorations(toRemove, []);
  }
  removeDecorations() {
    this._editor.deltaDecorations([...this._decorations.keys()], []);
    this._decorations.clear();
  }
};
DecorationsManager.DecorationOptions = ModelDecorationOptions.register({
  stickiness: 1,
  className: "reference-decoration"
});
var LayoutData = class {
  constructor() {
    this.ratio = 0.7;
    this.heightInLines = 18;
  }
  static fromJSON(raw) {
    let ratio;
    let heightInLines;
    try {
      const data = JSON.parse(raw);
      ratio = data.ratio;
      heightInLines = data.heightInLines;
    } catch (_a5) {
    }
    return {
      ratio: ratio || 0.7,
      heightInLines: heightInLines || 18
    };
  }
};
var ReferencesTree = class extends WorkbenchAsyncDataTree {
};
var ReferenceWidget = class ReferenceWidget2 extends PeekViewWidget {
  constructor(editor3, _defaultTreeKeyboardSupport, layoutData, themeService, _textModelResolverService, _instantiationService, _peekViewService, _uriLabel, _undoRedoService, _keybindingService) {
    super(editor3, {showFrame: false, showArrow: true, isResizeable: true, isAccessible: true}, _instantiationService);
    this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
    this.layoutData = layoutData;
    this._textModelResolverService = _textModelResolverService;
    this._instantiationService = _instantiationService;
    this._peekViewService = _peekViewService;
    this._uriLabel = _uriLabel;
    this._undoRedoService = _undoRedoService;
    this._keybindingService = _keybindingService;
    this._disposeOnNewModel = new DisposableStore();
    this._callOnDispose = new DisposableStore();
    this._onDidSelectReference = new Emitter2();
    this.onDidSelectReference = this._onDidSelectReference.event;
    this._dim = {height: 0, width: 0};
    this._applyTheme(themeService.getColorTheme());
    this._callOnDispose.add(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
    this._peekViewService.addExclusiveWidget(editor3, this);
    this.create();
  }
  dispose() {
    this.setModel(void 0);
    this._callOnDispose.dispose();
    this._disposeOnNewModel.dispose();
    dispose(this._preview);
    dispose(this._previewNotAvailableMessage);
    dispose(this._tree);
    dispose(this._previewModelReference);
    this._splitView.dispose();
    super.dispose();
  }
  _applyTheme(theme6) {
    const borderColor = theme6.getColor(peekViewBorder) || Color.transparent;
    this.style({
      arrowColor: borderColor,
      frameColor: borderColor,
      headerBackgroundColor: theme6.getColor(peekViewTitleBackground) || Color.transparent,
      primaryHeadingColor: theme6.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme6.getColor(peekViewTitleInfoForeground)
    });
  }
  show(where) {
    this.editor.revealRangeInCenterIfOutsideViewport(where, 0);
    super.show(where, this.layoutData.heightInLines || 18);
  }
  focusOnReferenceTree() {
    this._tree.domFocus();
  }
  focusOnPreviewEditor() {
    this._preview.focus();
  }
  isPreviewEditorFocused() {
    return this._preview.hasTextFocus();
  }
  _onTitleClick(e) {
    if (this._preview && this._preview.getModel()) {
      this._onDidSelectReference.fire({
        element: this._getFocusedReference(),
        kind: e.ctrlKey || e.metaKey || e.altKey ? "side" : "open",
        source: "title"
      });
    }
  }
  _fillBody(containerElement) {
    this.setCssClass("reference-zone-widget");
    this._messageContainer = append(containerElement, $("div.messages"));
    hide(this._messageContainer);
    this._splitView = new SplitView(containerElement, {orientation: 1});
    this._previewContainer = append(containerElement, $("div.preview.inline"));
    let options = {
      scrollBeyondLastLine: false,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: true,
        verticalHasArrows: false,
        horizontalHasArrows: false,
        alwaysConsumeMouseWheel: false
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: true,
      minimap: {
        enabled: false
      }
    };
    this._preview = this._instantiationService.createInstance(EmbeddedCodeEditorWidget, this._previewContainer, options, this.editor);
    hide(this._previewContainer);
    this._previewNotAvailableMessage = new TextModel(localize("missingPreviewMessage", "no preview available"), TextModel.DEFAULT_CREATION_OPTIONS, null, null, this._undoRedoService);
    this._treeContainer = append(containerElement, $("div.ref-tree.inline"));
    const treeOptions = {
      keyboardSupport: this._defaultTreeKeyboardSupport,
      accessibilityProvider: new AccessibilityProvider(),
      keyboardNavigationLabelProvider: this._instantiationService.createInstance(StringRepresentationProvider),
      identityProvider: new IdentityProvider(),
      openOnSingleClick: true,
      openOnFocus: true,
      overrideStyles: {
        listBackground: peekViewResultsBackground
      }
    };
    if (this._defaultTreeKeyboardSupport) {
      this._callOnDispose.add(addStandardDisposableListener(this._treeContainer, "keydown", (e) => {
        if (e.equals(9)) {
          this._keybindingService.dispatchEvent(e, e.target);
          e.stopPropagation();
        }
      }, true));
    }
    this._tree = this._instantiationService.createInstance(ReferencesTree, "ReferencesWidget", this._treeContainer, new Delegate(), [
      this._instantiationService.createInstance(FileReferencesRenderer),
      this._instantiationService.createInstance(OneReferenceRenderer)
    ], this._instantiationService.createInstance(DataSource), treeOptions);
    this._splitView.addView({
      onDidChange: Event.None,
      element: this._previewContainer,
      minimumSize: 200,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        this._preview.layout({height: this._dim.height, width});
      }
    }, Sizing.Distribute);
    this._splitView.addView({
      onDidChange: Event.None,
      element: this._treeContainer,
      minimumSize: 100,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        this._treeContainer.style.height = `${this._dim.height}px`;
        this._treeContainer.style.width = `${width}px`;
        this._tree.layout(this._dim.height, width);
      }
    }, Sizing.Distribute);
    this._disposables.add(this._splitView.onDidSashChange(() => {
      if (this._dim.width) {
        this.layoutData.ratio = this._splitView.getViewSize(0) / this._dim.width;
      }
    }, void 0));
    let onEvent = (element, kind) => {
      if (element instanceof OneReference) {
        if (kind === "show") {
          this._revealReference(element, false);
        }
        this._onDidSelectReference.fire({element, kind, source: "tree"});
      }
    };
    this._tree.onDidOpen((e) => {
      if (e.sideBySide) {
        onEvent(e.element, "side");
      } else if (e.editorOptions.pinned) {
        onEvent(e.element, "goto");
      } else {
        onEvent(e.element, "show");
      }
    });
    hide(this._treeContainer);
  }
  _onWidth(width) {
    if (this._dim) {
      this._doLayoutBody(this._dim.height, width);
    }
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    super._doLayoutBody(heightInPixel, widthInPixel);
    this._dim = {height: heightInPixel, width: widthInPixel};
    this.layoutData.heightInLines = this._viewZone ? this._viewZone.heightInLines : this.layoutData.heightInLines;
    this._splitView.layout(widthInPixel);
    this._splitView.resizeView(0, widthInPixel * this.layoutData.ratio);
  }
  setSelection(selection) {
    return this._revealReference(selection, true).then(() => {
      if (!this._model) {
        return;
      }
      this._tree.setSelection([selection]);
      this._tree.setFocus([selection]);
    });
  }
  setModel(newModel) {
    this._disposeOnNewModel.clear();
    this._model = newModel;
    if (this._model) {
      return this._onNewModel();
    }
    return Promise.resolve();
  }
  _onNewModel() {
    if (!this._model) {
      return Promise.resolve(void 0);
    }
    if (this._model.isEmpty) {
      this.setTitle("");
      this._messageContainer.innerText = localize("noResults", "No results");
      show(this._messageContainer);
      return Promise.resolve(void 0);
    }
    hide(this._messageContainer);
    this._decorationsManager = new DecorationsManager(this._preview, this._model);
    this._disposeOnNewModel.add(this._decorationsManager);
    this._disposeOnNewModel.add(this._model.onDidChangeReferenceRange((reference) => this._tree.rerender(reference)));
    this._disposeOnNewModel.add(this._preview.onMouseDown((e) => {
      const {event, target} = e;
      if (event.detail !== 2) {
        return;
      }
      const element = this._getFocusedReference();
      if (!element) {
        return;
      }
      this._onDidSelectReference.fire({
        element: {uri: element.uri, range: target.range},
        kind: event.ctrlKey || event.metaKey || event.altKey ? "side" : "open",
        source: "editor"
      });
    }));
    this.container.classList.add("results-loaded");
    show(this._treeContainer);
    show(this._previewContainer);
    this._splitView.layout(this._dim.width);
    this.focusOnReferenceTree();
    return this._tree.setInput(this._model.groups.length === 1 ? this._model.groups[0] : this._model);
  }
  _getFocusedReference() {
    const [element] = this._tree.getFocus();
    if (element instanceof OneReference) {
      return element;
    } else if (element instanceof FileReferences) {
      if (element.children.length > 0) {
        return element.children[0];
      }
    }
    return void 0;
  }
  revealReference(reference) {
    return __awaiter14(this, void 0, void 0, function* () {
      yield this._revealReference(reference, false);
      this._onDidSelectReference.fire({element: reference, kind: "goto", source: "tree"});
    });
  }
  _revealReference(reference, revealParent) {
    return __awaiter14(this, void 0, void 0, function* () {
      if (this._revealedReference === reference) {
        return;
      }
      this._revealedReference = reference;
      if (reference.uri.scheme !== Schemas.inMemory) {
        this.setTitle(basenameOrAuthority(reference.uri), this._uriLabel.getUriLabel(dirname(reference.uri)));
      } else {
        this.setTitle(localize("peekView.alternateTitle", "References"));
      }
      const promise3 = this._textModelResolverService.createModelReference(reference.uri);
      if (this._tree.getInput() === reference.parent) {
        this._tree.reveal(reference);
      } else {
        if (revealParent) {
          this._tree.reveal(reference.parent);
        }
        yield this._tree.expand(reference.parent);
        this._tree.reveal(reference);
      }
      const ref = yield promise3;
      if (!this._model) {
        ref.dispose();
        return;
      }
      dispose(this._previewModelReference);
      const model = ref.object;
      if (model) {
        const scrollType = this._preview.getModel() === model.textEditorModel ? 0 : 1;
        const sel = Range2.lift(reference.range).collapseToStart();
        this._previewModelReference = ref;
        this._preview.setModel(model.textEditorModel);
        this._preview.setSelection(sel);
        this._preview.revealRangeInCenter(sel, scrollType);
      } else {
        this._preview.setModel(this._previewNotAvailableMessage);
        ref.dispose();
      }
    });
  }
};
ReferenceWidget = __decorate19([
  __param19(3, IThemeService),
  __param19(4, ITextModelService),
  __param19(5, IInstantiationService),
  __param19(6, IPeekViewService),
  __param19(7, ILabelService),
  __param19(8, IUndoRedoService),
  __param19(9, IKeybindingService)
], ReferenceWidget);
registerThemingParticipant((theme6, collector) => {
  const findMatchHighlightColor = theme6.getColor(peekViewResultsMatchHighlight);
  if (findMatchHighlightColor) {
    collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .referenceMatch .highlight { background-color: ${findMatchHighlightColor}; }`);
  }
  const referenceHighlightColor = theme6.getColor(peekViewEditorMatchHighlight);
  if (referenceHighlightColor) {
    collector.addRule(`.monaco-editor .reference-zone-widget .preview .reference-decoration { background-color: ${referenceHighlightColor}; }`);
  }
  const referenceHighlightBorder = theme6.getColor(peekViewEditorMatchHighlightBorder);
  if (referenceHighlightBorder) {
    collector.addRule(`.monaco-editor .reference-zone-widget .preview .reference-decoration { border: 2px solid ${referenceHighlightBorder}; box-sizing: border-box; }`);
  }
  const hcOutline = theme6.getColor(activeContrastBorder);
  if (hcOutline) {
    collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .referenceMatch .highlight { border: 1px dotted ${hcOutline}; box-sizing: border-box; }`);
  }
  const resultsBackground = theme6.getColor(peekViewResultsBackground);
  if (resultsBackground) {
    collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree { background-color: ${resultsBackground}; }`);
  }
  const resultsMatchForeground = theme6.getColor(peekViewResultsMatchForeground);
  if (resultsMatchForeground) {
    collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree { color: ${resultsMatchForeground}; }`);
  }
  const resultsFileForeground = theme6.getColor(peekViewResultsFileForeground);
  if (resultsFileForeground) {
    collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .reference-file { color: ${resultsFileForeground}; }`);
  }
  const resultsSelectedBackground = theme6.getColor(peekViewResultsSelectionBackground);
  if (resultsSelectedBackground) {
    collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .monaco-list:focus .monaco-list-rows > .monaco-list-row.selected:not(.highlighted) { background-color: ${resultsSelectedBackground}; }`);
  }
  const resultsSelectedForeground = theme6.getColor(peekViewResultsSelectionForeground);
  if (resultsSelectedForeground) {
    collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .monaco-list:focus .monaco-list-rows > .monaco-list-row.selected:not(.highlighted) { color: ${resultsSelectedForeground} !important; }`);
  }
  const editorBackground = theme6.getColor(peekViewEditorBackground);
  if (editorBackground) {
    collector.addRule(`.monaco-editor .reference-zone-widget .preview .monaco-editor .monaco-editor-background,.monaco-editor .reference-zone-widget .preview .monaco-editor .inputarea.ime-input {	background-color: ${editorBackground};}`);
  }
  const editorGutterBackground = theme6.getColor(peekViewEditorGutterBackground);
  if (editorGutterBackground) {
    collector.addRule(`.monaco-editor .reference-zone-widget .preview .monaco-editor .margin {	background-color: ${editorGutterBackground};}`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesController.js
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param20 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ctxReferenceSearchVisible = new RawContextKey("referenceSearchVisible", false);
var ReferencesController = class ReferencesController2 {
  constructor(_defaultTreeKeyboardSupport, _editor, contextKeyService, _editorService, _notificationService, _instantiationService, _storageService, _configurationService) {
    this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
    this._editor = _editor;
    this._editorService = _editorService;
    this._notificationService = _notificationService;
    this._instantiationService = _instantiationService;
    this._storageService = _storageService;
    this._configurationService = _configurationService;
    this._disposables = new DisposableStore();
    this._requestIdPool = 0;
    this._ignoreModelChangeEvent = false;
    this._referenceSearchVisible = ctxReferenceSearchVisible.bindTo(contextKeyService);
  }
  static get(editor3) {
    return editor3.getContribution(ReferencesController2.ID);
  }
  dispose() {
    this._referenceSearchVisible.reset();
    this._disposables.dispose();
    dispose(this._widget);
    dispose(this._model);
    this._widget = void 0;
    this._model = void 0;
  }
  toggleWidget(range2, modelPromise, peekMode) {
    let widgetPosition;
    if (this._widget) {
      widgetPosition = this._widget.position;
    }
    this.closeWidget();
    if (!!widgetPosition && range2.containsPosition(widgetPosition)) {
      return;
    }
    this._peekMode = peekMode;
    this._referenceSearchVisible.set(true);
    this._disposables.add(this._editor.onDidChangeModelLanguage(() => {
      this.closeWidget();
    }));
    this._disposables.add(this._editor.onDidChangeModel(() => {
      if (!this._ignoreModelChangeEvent) {
        this.closeWidget();
      }
    }));
    const storageKey = "peekViewLayout";
    const data = LayoutData.fromJSON(this._storageService.get(storageKey, 0, "{}"));
    this._widget = this._instantiationService.createInstance(ReferenceWidget, this._editor, this._defaultTreeKeyboardSupport, data);
    this._widget.setTitle(localize("labelLoading", "Loading..."));
    this._widget.show(range2);
    this._disposables.add(this._widget.onDidClose(() => {
      modelPromise.cancel();
      if (this._widget) {
        this._storageService.store(storageKey, JSON.stringify(this._widget.layoutData), 0);
        this._widget = void 0;
      }
      this.closeWidget();
    }));
    this._disposables.add(this._widget.onDidSelectReference((event) => {
      let {element, kind} = event;
      if (!element) {
        return;
      }
      switch (kind) {
        case "open":
          if (event.source !== "editor" || !this._configurationService.getValue("editor.stablePeek")) {
            this.openReference(element, false);
          }
          break;
        case "side":
          this.openReference(element, true);
          break;
        case "goto":
          if (peekMode) {
            this._gotoReference(element);
          } else {
            this.openReference(element, false);
          }
          break;
      }
    }));
    const requestId = ++this._requestIdPool;
    modelPromise.then((model) => {
      if (requestId !== this._requestIdPool || !this._widget) {
        return void 0;
      }
      if (this._model) {
        this._model.dispose();
      }
      this._model = model;
      return this._widget.setModel(this._model).then(() => {
        if (this._widget && this._model && this._editor.hasModel()) {
          if (!this._model.isEmpty) {
            this._widget.setMetaTitle(localize("metaTitle.N", "{0} ({1})", this._model.title, this._model.references.length));
          } else {
            this._widget.setMetaTitle("");
          }
          let uri = this._editor.getModel().uri;
          let pos = new Position(range2.startLineNumber, range2.startColumn);
          let selection = this._model.nearestReference(uri, pos);
          if (selection) {
            return this._widget.setSelection(selection).then(() => {
              if (this._widget && this._editor.getOption(68) === "editor") {
                this._widget.focusOnPreviewEditor();
              }
            });
          }
        }
        return void 0;
      });
    }, (error) => {
      this._notificationService.error(error);
    });
  }
  changeFocusBetweenPreviewAndReferences() {
    if (!this._widget) {
      return;
    }
    if (this._widget.isPreviewEditorFocused()) {
      this._widget.focusOnReferenceTree();
    } else {
      this._widget.focusOnPreviewEditor();
    }
  }
  goToNextOrPreviousReference(fwd) {
    return __awaiter15(this, void 0, void 0, function* () {
      if (!this._editor.hasModel() || !this._model || !this._widget) {
        return;
      }
      const currentPosition = this._widget.position;
      if (!currentPosition) {
        return;
      }
      const source = this._model.nearestReference(this._editor.getModel().uri, currentPosition);
      if (!source) {
        return;
      }
      const target = this._model.nextOrPreviousReference(source, fwd);
      const editorFocus = this._editor.hasTextFocus();
      const previewEditorFocus = this._widget.isPreviewEditorFocused();
      yield this._widget.setSelection(target);
      yield this._gotoReference(target);
      if (editorFocus) {
        this._editor.focus();
      } else if (this._widget && previewEditorFocus) {
        this._widget.focusOnPreviewEditor();
      }
    });
  }
  revealReference(reference) {
    return __awaiter15(this, void 0, void 0, function* () {
      if (!this._editor.hasModel() || !this._model || !this._widget) {
        return;
      }
      yield this._widget.revealReference(reference);
    });
  }
  closeWidget(focusEditor = true) {
    dispose(this._widget);
    dispose(this._model);
    this._referenceSearchVisible.reset();
    this._disposables.clear();
    this._widget = void 0;
    this._model = void 0;
    if (focusEditor) {
      this._editor.focus();
    }
    this._requestIdPool += 1;
  }
  _gotoReference(ref) {
    if (this._widget) {
      this._widget.hide();
    }
    this._ignoreModelChangeEvent = true;
    const range2 = Range2.lift(ref.range).collapseToStart();
    return this._editorService.openCodeEditor({
      resource: ref.uri,
      options: {selection: range2}
    }, this._editor).then((openedEditor) => {
      var _a5;
      this._ignoreModelChangeEvent = false;
      if (!openedEditor || !this._widget) {
        this.closeWidget();
        return;
      }
      if (this._editor === openedEditor) {
        this._widget.show(range2);
        this._widget.focusOnReferenceTree();
      } else {
        const other = ReferencesController2.get(openedEditor);
        const model = this._model.clone();
        this.closeWidget();
        openedEditor.focus();
        other.toggleWidget(range2, createCancelablePromise((_) => Promise.resolve(model)), (_a5 = this._peekMode) !== null && _a5 !== void 0 ? _a5 : false);
      }
    }, (err) => {
      this._ignoreModelChangeEvent = false;
      onUnexpectedError(err);
    });
  }
  openReference(ref, sideBySide) {
    if (!sideBySide) {
      this.closeWidget();
    }
    const {uri, range: range2} = ref;
    this._editorService.openCodeEditor({
      resource: uri,
      options: {selection: range2}
    }, this._editor, sideBySide);
  }
};
ReferencesController.ID = "editor.contrib.referencesController";
ReferencesController = __decorate20([
  __param20(2, IContextKeyService),
  __param20(3, ICodeEditorService),
  __param20(4, INotificationService),
  __param20(5, IInstantiationService),
  __param20(6, IStorageService),
  __param20(7, IConfigurationService)
], ReferencesController);
function withController(accessor, fn) {
  const outerEditor = getOuterEditor(accessor);
  if (!outerEditor) {
    return;
  }
  let controller = ReferencesController.get(outerEditor);
  if (controller) {
    fn(controller);
  }
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "togglePeekWidgetFocus",
  weight: 100,
  primary: KeyChord(2048 | 41, 60),
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.changeFocusBetweenPreviewAndReferences();
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "goToNextReference",
  weight: 100 - 10,
  primary: 62,
  secondary: [70],
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.goToNextOrPreviousReference(true);
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "goToPreviousReference",
  weight: 100 - 10,
  primary: 1024 | 62,
  secondary: [1024 | 70],
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.goToNextOrPreviousReference(false);
    });
  }
});
CommandsRegistry.registerCommandAlias("goToNextReferenceFromEmbeddedEditor", "goToNextReference");
CommandsRegistry.registerCommandAlias("goToPreviousReferenceFromEmbeddedEditor", "goToPreviousReference");
CommandsRegistry.registerCommandAlias("closeReferenceSearchEditor", "closeReferenceSearch");
CommandsRegistry.registerCommand("closeReferenceSearch", (accessor) => withController(accessor, (controller) => controller.closeWidget()));
KeybindingsRegistry.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 100 - 101,
  primary: 9,
  secondary: [1024 | 9],
  when: ContextKeyExpr.and(PeekContext.inPeekEditor, ContextKeyExpr.not("config.editor.stablePeek"))
});
KeybindingsRegistry.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 200 + 50,
  primary: 9,
  secondary: [1024 | 9],
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, ContextKeyExpr.not("config.editor.stablePeek"))
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "revealReference",
  weight: 200,
  primary: 3,
  mac: {
    primary: 3,
    secondary: [2048 | 18]
  },
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey),
  handler(accessor) {
    var _a5;
    const listService = accessor.get(IListService);
    const focus = (_a5 = listService.lastFocusedList) === null || _a5 === void 0 ? void 0 : _a5.getFocus();
    if (Array.isArray(focus) && focus[0] instanceof OneReference) {
      withController(accessor, (controller) => controller.revealReference(focus[0]));
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "openReferenceToSide",
  weight: 100,
  primary: 2048 | 3,
  mac: {
    primary: 256 | 3
  },
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey),
  handler(accessor) {
    var _a5;
    const listService = accessor.get(IListService);
    const focus = (_a5 = listService.lastFocusedList) === null || _a5 === void 0 ? void 0 : _a5.getFocus();
    if (Array.isArray(focus) && focus[0] instanceof OneReference) {
      withController(accessor, (controller) => controller.openReference(focus[0], true));
    }
  }
});
CommandsRegistry.registerCommand("openReference", (accessor) => {
  var _a5;
  const listService = accessor.get(IListService);
  const focus = (_a5 = listService.lastFocusedList) === null || _a5 === void 0 ? void 0 : _a5.getFocus();
  if (Array.isArray(focus) && focus[0] instanceof OneReference) {
    withController(accessor, (controller) => controller.openReference(focus[0], false));
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/goToSymbol.js
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getLocationLinks(model, position, registry, provide) {
  const provider = registry.ordered(model);
  const promises = provider.map((provider2) => {
    return Promise.resolve(provide(provider2, model, position)).then(void 0, (err) => {
      onUnexpectedExternalError(err);
      return void 0;
    });
  });
  return Promise.all(promises).then((values) => {
    const result = [];
    for (let value of values) {
      if (Array.isArray(value)) {
        result.push(...value);
      } else if (value) {
        result.push(value);
      }
    }
    return result;
  });
}
function getDefinitionsAtPosition(model, position, token) {
  return getLocationLinks(model, position, DefinitionProviderRegistry, (provider, model2, position2) => {
    return provider.provideDefinition(model2, position2, token);
  });
}
function getDeclarationsAtPosition(model, position, token) {
  return getLocationLinks(model, position, DeclarationProviderRegistry, (provider, model2, position2) => {
    return provider.provideDeclaration(model2, position2, token);
  });
}
function getImplementationsAtPosition(model, position, token) {
  return getLocationLinks(model, position, ImplementationProviderRegistry, (provider, model2, position2) => {
    return provider.provideImplementation(model2, position2, token);
  });
}
function getTypeDefinitionsAtPosition(model, position, token) {
  return getLocationLinks(model, position, TypeDefinitionProviderRegistry, (provider, model2, position2) => {
    return provider.provideTypeDefinition(model2, position2, token);
  });
}
function getReferencesAtPosition(model, position, compact2, token) {
  return getLocationLinks(model, position, ReferenceProviderRegistry, (provider, model2, position2) => __awaiter16(this, void 0, void 0, function* () {
    const result = yield provider.provideReferences(model2, position2, {includeDeclaration: true}, token);
    if (!compact2 || !result || result.length !== 2) {
      return result;
    }
    const resultWithoutDeclaration = yield provider.provideReferences(model2, position2, {includeDeclaration: false}, token);
    if (resultWithoutDeclaration && resultWithoutDeclaration.length === 1) {
      return resultWithoutDeclaration;
    }
    return result;
  }));
}
registerModelAndPositionCommand("_executeDefinitionProvider", (model, position) => getDefinitionsAtPosition(model, position, CancellationToken.None));
registerModelAndPositionCommand("_executeDeclarationProvider", (model, position) => getDeclarationsAtPosition(model, position, CancellationToken.None));
registerModelAndPositionCommand("_executeImplementationProvider", (model, position) => getImplementationsAtPosition(model, position, CancellationToken.None));
registerModelAndPositionCommand("_executeTypeDefinitionProvider", (model, position) => getTypeDefinitionsAtPosition(model, position, CancellationToken.None));
registerModelAndPositionCommand("_executeReferenceProvider", (model, position) => getReferencesAtPosition(model, position, false, CancellationToken.None));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/symbolNavigation.js
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param21 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ctxHasSymbols = new RawContextKey("hasSymbols", false);
var ISymbolNavigationService = createDecorator("ISymbolNavigationService");
var SymbolNavigationService = class SymbolNavigationService2 {
  constructor(contextKeyService, _editorService, _notificationService, _keybindingService) {
    this._editorService = _editorService;
    this._notificationService = _notificationService;
    this._keybindingService = _keybindingService;
    this._currentModel = void 0;
    this._currentIdx = -1;
    this._ignoreEditorChange = false;
    this._ctxHasSymbols = ctxHasSymbols.bindTo(contextKeyService);
  }
  reset() {
    this._ctxHasSymbols.reset();
    dispose(this._currentState);
    dispose(this._currentMessage);
    this._currentModel = void 0;
    this._currentIdx = -1;
  }
  put(anchor) {
    const refModel = anchor.parent.parent;
    if (refModel.references.length <= 1) {
      this.reset();
      return;
    }
    this._currentModel = refModel;
    this._currentIdx = refModel.references.indexOf(anchor);
    this._ctxHasSymbols.set(true);
    this._showMessage();
    const editorState = new EditorState2(this._editorService);
    const listener = editorState.onDidChange((_) => {
      if (this._ignoreEditorChange) {
        return;
      }
      const editor3 = this._editorService.getActiveCodeEditor();
      if (!editor3) {
        return;
      }
      const model = editor3.getModel();
      const position = editor3.getPosition();
      if (!model || !position) {
        return;
      }
      let seenUri = false;
      let seenPosition = false;
      for (const reference of refModel.references) {
        if (isEqual(reference.uri, model.uri)) {
          seenUri = true;
          seenPosition = seenPosition || Range2.containsPosition(reference.range, position);
        } else if (seenUri) {
          break;
        }
      }
      if (!seenUri || !seenPosition) {
        this.reset();
      }
    });
    this._currentState = combinedDisposable(editorState, listener);
  }
  revealNext(source) {
    if (!this._currentModel) {
      return Promise.resolve();
    }
    this._currentIdx += 1;
    this._currentIdx %= this._currentModel.references.length;
    const reference = this._currentModel.references[this._currentIdx];
    this._showMessage();
    this._ignoreEditorChange = true;
    return this._editorService.openCodeEditor({
      resource: reference.uri,
      options: {
        selection: Range2.collapseToStart(reference.range),
        selectionRevealType: 3
      }
    }, source).finally(() => {
      this._ignoreEditorChange = false;
    });
  }
  _showMessage() {
    dispose(this._currentMessage);
    const kb = this._keybindingService.lookupKeybinding("editor.gotoNextSymbolFromResult");
    const message = kb ? localize("location.kb", "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, kb.getLabel()) : localize("location", "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
    this._currentMessage = this._notificationService.status(message);
  }
};
SymbolNavigationService = __decorate21([
  __param21(0, IContextKeyService),
  __param21(1, ICodeEditorService),
  __param21(2, INotificationService),
  __param21(3, IKeybindingService)
], SymbolNavigationService);
registerSingleton(ISymbolNavigationService, SymbolNavigationService, true);
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: "editor.gotoNextSymbolFromResult",
      precondition: ctxHasSymbols,
      kbOpts: {
        weight: 100,
        primary: 70
      }
    });
  }
  runEditorCommand(accessor, editor3) {
    return accessor.get(ISymbolNavigationService).revealNext(editor3);
  }
}());
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "editor.gotoNextSymbolFromResult.cancel",
  weight: 100,
  when: ctxHasSymbols,
  primary: 9,
  handler(accessor) {
    accessor.get(ISymbolNavigationService).reset();
  }
});
var EditorState2 = class EditorState3 {
  constructor(editorService) {
    this._listener = new Map();
    this._disposables = new DisposableStore();
    this._onDidChange = new Emitter2();
    this.onDidChange = this._onDidChange.event;
    this._disposables.add(editorService.onCodeEditorRemove(this._onDidRemoveEditor, this));
    this._disposables.add(editorService.onCodeEditorAdd(this._onDidAddEditor, this));
    editorService.listCodeEditors().forEach(this._onDidAddEditor, this);
  }
  dispose() {
    this._disposables.dispose();
    this._onDidChange.dispose();
    dispose(this._listener.values());
  }
  _onDidAddEditor(editor3) {
    this._listener.set(editor3, combinedDisposable(editor3.onDidChangeCursorPosition((_) => this._onDidChange.fire({editor: editor3})), editor3.onDidChangeModelContent((_) => this._onDidChange.fire({editor: editor3}))));
  }
  _onDidRemoveEditor(editor3) {
    dispose(this._listener.get(editor3));
    this._listener.delete(editor3);
  }
};
EditorState2 = __decorate21([
  __param21(0, ICodeEditorService)
], EditorState2);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/goToCommands.js
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a;
var _b;
var _c;
var _d;
var _e;
var _f;
var _g;
var _h;
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
  submenu: MenuId.EditorContextPeek,
  title: localize("peek.submenu", "Peek"),
  group: "navigation",
  order: 100
});
var SymbolNavigationAction = class extends EditorAction {
  constructor(configuration, opts) {
    super(opts);
    this._configuration = configuration;
  }
  run(accessor, editor3) {
    if (!editor3.hasModel()) {
      return Promise.resolve(void 0);
    }
    const notificationService = accessor.get(INotificationService);
    const editorService = accessor.get(ICodeEditorService);
    const progressService = accessor.get(IEditorProgressService);
    const symbolNavService = accessor.get(ISymbolNavigationService);
    const model = editor3.getModel();
    const pos = editor3.getPosition();
    const cts = new EditorStateCancellationTokenSource(editor3, 1 | 4);
    const promise3 = raceCancellation(this._getLocationModel(model, pos, cts.token), cts.token).then((references) => __awaiter17(this, void 0, void 0, function* () {
      if (!references || cts.token.isCancellationRequested) {
        return;
      }
      alert(references.ariaMessage);
      let altAction;
      if (references.referenceAt(model.uri, pos)) {
        const altActionId = this._getAlternativeCommand(editor3);
        if (altActionId !== this.id) {
          altAction = editor3.getAction(altActionId);
        }
      }
      const referenceCount = references.references.length;
      if (referenceCount === 0) {
        if (!this._configuration.muteMessage) {
          const info = model.getWordAtPosition(pos);
          MessageController.get(editor3).showMessage(this._getNoResultFoundMessage(info), pos);
        }
      } else if (referenceCount === 1 && altAction) {
        altAction.run();
      } else {
        return this._onResult(editorService, symbolNavService, editor3, references);
      }
    }), (err) => {
      notificationService.error(err);
    }).finally(() => {
      cts.dispose();
    });
    progressService.showWhile(promise3, 250);
    return promise3;
  }
  _onResult(editorService, symbolNavService, editor3, model) {
    return __awaiter17(this, void 0, void 0, function* () {
      const gotoLocation = this._getGoToPreference(editor3);
      if (!(editor3 instanceof EmbeddedCodeEditorWidget) && (this._configuration.openInPeek || gotoLocation === "peek" && model.references.length > 1)) {
        this._openInPeek(editor3, model);
      } else {
        const next = model.firstReference();
        const peek = model.references.length > 1 && gotoLocation === "gotoAndPeek";
        const targetEditor = yield this._openReference(editor3, editorService, next, this._configuration.openToSide, !peek);
        if (peek && targetEditor) {
          this._openInPeek(targetEditor, model);
        } else {
          model.dispose();
        }
        if (gotoLocation === "goto") {
          symbolNavService.put(next);
        }
      }
    });
  }
  _openReference(editor3, editorService, reference, sideBySide, highlight) {
    return __awaiter17(this, void 0, void 0, function* () {
      let range2 = void 0;
      if (isLocationLink(reference)) {
        range2 = reference.targetSelectionRange;
      }
      if (!range2) {
        range2 = reference.range;
      }
      const targetEditor = yield editorService.openCodeEditor({
        resource: reference.uri,
        options: {
          selection: Range2.collapseToStart(range2),
          selectionRevealType: 3
        }
      }, editor3, sideBySide);
      if (!targetEditor) {
        return void 0;
      }
      if (highlight) {
        const modelNow = targetEditor.getModel();
        const ids2 = targetEditor.deltaDecorations([], [{range: range2, options: {className: "symbolHighlight"}}]);
        setTimeout(() => {
          if (targetEditor.getModel() === modelNow) {
            targetEditor.deltaDecorations(ids2, []);
          }
        }, 350);
      }
      return targetEditor;
    });
  }
  _openInPeek(target, model) {
    let controller = ReferencesController.get(target);
    if (controller && target.hasModel()) {
      controller.toggleWidget(target.getSelection(), createCancelablePromise((_) => Promise.resolve(model)), this._configuration.openInPeek);
    } else {
      model.dispose();
    }
  }
};
var DefinitionAction = class extends SymbolNavigationAction {
  _getLocationModel(model, position, token) {
    return __awaiter17(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getDefinitionsAtPosition(model, position, token), localize("def.title", "Definitions"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("noResultWord", "No definition found for '{0}'", info.word) : localize("generic.noResults", "No definition found");
  }
  _getAlternativeCommand(editor3) {
    return editor3.getOption(43).alternativeDefinitionCommand;
  }
  _getGoToPreference(editor3) {
    return editor3.getOption(43).multipleDefinitions;
  }
};
var goToDefinitionKb = isWeb && !isStandalone ? 2048 | 70 : 70;
registerEditorAction((_a = class GoToDefinitionAction extends DefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToDefinitionAction.id,
      label: localize("actions.goToDecl.label", "Go to Definition"),
      alias: "Go to Definition",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: goToDefinitionKb,
        weight: 100
      },
      contextMenuOpts: {
        group: "navigation",
        order: 1.1
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        group: "4_symbol_nav",
        order: 2,
        title: localize({key: "miGotoDefinition", comment: ["&& denotes a mnemonic"]}, "Go to &&Definition")
      }
    });
    CommandsRegistry.registerCommandAlias("editor.action.goToDeclaration", GoToDefinitionAction.id);
  }
}, _a.id = "editor.action.revealDefinition", _a));
registerEditorAction((_b = class OpenDefinitionToSideAction extends DefinitionAction {
  constructor() {
    super({
      openToSide: true,
      openInPeek: false,
      muteMessage: false
    }, {
      id: OpenDefinitionToSideAction.id,
      label: localize("actions.goToDeclToSide.label", "Open Definition to the Side"),
      alias: "Open Definition to the Side",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, goToDefinitionKb),
        weight: 100
      }
    });
    CommandsRegistry.registerCommandAlias("editor.action.openDeclarationToTheSide", OpenDefinitionToSideAction.id);
  }
}, _b.id = "editor.action.revealDefinitionAside", _b));
registerEditorAction((_c = class PeekDefinitionAction extends DefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: PeekDefinitionAction.id,
      label: localize("actions.previewDecl.label", "Peek Definition"),
      alias: "Peek Definition",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 70,
        linux: {primary: 2048 | 1024 | 68},
        weight: 100
      },
      contextMenuOpts: {
        menuId: MenuId.EditorContextPeek,
        group: "peek",
        order: 2
      }
    });
    CommandsRegistry.registerCommandAlias("editor.action.previewDeclaration", PeekDefinitionAction.id);
  }
}, _c.id = "editor.action.peekDefinition", _c));
var DeclarationAction = class extends SymbolNavigationAction {
  _getLocationModel(model, position, token) {
    return __awaiter17(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getDeclarationsAtPosition(model, position, token), localize("decl.title", "Declarations"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("decl.noResultWord", "No declaration found for '{0}'", info.word) : localize("decl.generic.noResults", "No declaration found");
  }
  _getAlternativeCommand(editor3) {
    return editor3.getOption(43).alternativeDeclarationCommand;
  }
  _getGoToPreference(editor3) {
    return editor3.getOption(43).multipleDeclarations;
  }
};
registerEditorAction((_d = class GoToDeclarationAction extends DeclarationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToDeclarationAction.id,
      label: localize("actions.goToDeclaration.label", "Go to Declaration"),
      alias: "Go to Declaration",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      contextMenuOpts: {
        group: "navigation",
        order: 1.3
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        group: "4_symbol_nav",
        order: 3,
        title: localize({key: "miGotoDeclaration", comment: ["&& denotes a mnemonic"]}, "Go to &&Declaration")
      }
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("decl.noResultWord", "No declaration found for '{0}'", info.word) : localize("decl.generic.noResults", "No declaration found");
  }
}, _d.id = "editor.action.revealDeclaration", _d));
registerEditorAction(class PeekDeclarationAction extends DeclarationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: "editor.action.peekDeclaration",
      label: localize("actions.peekDecl.label", "Peek Declaration"),
      alias: "Peek Declaration",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      contextMenuOpts: {
        menuId: MenuId.EditorContextPeek,
        group: "peek",
        order: 3
      }
    });
  }
});
var TypeDefinitionAction = class extends SymbolNavigationAction {
  _getLocationModel(model, position, token) {
    return __awaiter17(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getTypeDefinitionsAtPosition(model, position, token), localize("typedef.title", "Type Definitions"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("goToTypeDefinition.noResultWord", "No type definition found for '{0}'", info.word) : localize("goToTypeDefinition.generic.noResults", "No type definition found");
  }
  _getAlternativeCommand(editor3) {
    return editor3.getOption(43).alternativeTypeDefinitionCommand;
  }
  _getGoToPreference(editor3) {
    return editor3.getOption(43).multipleTypeDefinitions;
  }
};
registerEditorAction((_e = class GoToTypeDefinitionAction extends TypeDefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToTypeDefinitionAction.ID,
      label: localize("actions.goToTypeDefinition.label", "Go to Type Definition"),
      alias: "Go to Type Definition",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        weight: 100
      },
      contextMenuOpts: {
        group: "navigation",
        order: 1.4
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        group: "4_symbol_nav",
        order: 3,
        title: localize({key: "miGotoTypeDefinition", comment: ["&& denotes a mnemonic"]}, "Go to &&Type Definition")
      }
    });
  }
}, _e.ID = "editor.action.goToTypeDefinition", _e));
registerEditorAction((_f = class PeekTypeDefinitionAction extends TypeDefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: PeekTypeDefinitionAction.ID,
      label: localize("actions.peekTypeDefinition.label", "Peek Type Definition"),
      alias: "Peek Type Definition",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      contextMenuOpts: {
        menuId: MenuId.EditorContextPeek,
        group: "peek",
        order: 4
      }
    });
  }
}, _f.ID = "editor.action.peekTypeDefinition", _f));
var ImplementationAction = class extends SymbolNavigationAction {
  _getLocationModel(model, position, token) {
    return __awaiter17(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getImplementationsAtPosition(model, position, token), localize("impl.title", "Implementations"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("goToImplementation.noResultWord", "No implementation found for '{0}'", info.word) : localize("goToImplementation.generic.noResults", "No implementation found");
  }
  _getAlternativeCommand(editor3) {
    return editor3.getOption(43).alternativeImplementationCommand;
  }
  _getGoToPreference(editor3) {
    return editor3.getOption(43).multipleImplementations;
  }
};
registerEditorAction((_g = class GoToImplementationAction extends ImplementationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToImplementationAction.ID,
      label: localize("actions.goToImplementation.label", "Go to Implementations"),
      alias: "Go to Implementations",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 70,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        group: "4_symbol_nav",
        order: 4,
        title: localize({key: "miGotoImplementation", comment: ["&& denotes a mnemonic"]}, "Go to &&Implementations")
      },
      contextMenuOpts: {
        group: "navigation",
        order: 1.45
      }
    });
  }
}, _g.ID = "editor.action.goToImplementation", _g));
registerEditorAction((_h = class PeekImplementationAction extends ImplementationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: PeekImplementationAction.ID,
      label: localize("actions.peekImplementation.label", "Peek Implementations"),
      alias: "Peek Implementations",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 70,
        weight: 100
      },
      contextMenuOpts: {
        menuId: MenuId.EditorContextPeek,
        group: "peek",
        order: 5
      }
    });
  }
}, _h.ID = "editor.action.peekImplementation", _h));
var ReferencesAction = class extends SymbolNavigationAction {
  _getNoResultFoundMessage(info) {
    return info ? localize("references.no", "No references found for '{0}'", info.word) : localize("references.noGeneric", "No references found");
  }
  _getAlternativeCommand(editor3) {
    return editor3.getOption(43).alternativeReferenceCommand;
  }
  _getGoToPreference(editor3) {
    return editor3.getOption(43).multipleReferences;
  }
};
registerEditorAction(class GoToReferencesAction extends ReferencesAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: "editor.action.goToReferences",
      label: localize("goToReferences.label", "Go to References"),
      alias: "Go to References",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 70,
        weight: 100
      },
      contextMenuOpts: {
        group: "navigation",
        order: 1.45
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        group: "4_symbol_nav",
        order: 5,
        title: localize({key: "miGotoReference", comment: ["&& denotes a mnemonic"]}, "Go to &&References")
      }
    });
  }
  _getLocationModel(model, position, token) {
    return __awaiter17(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getReferencesAtPosition(model, position, true, token), localize("ref.title", "References"));
    });
  }
});
registerEditorAction(class PeekReferencesAction extends ReferencesAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: "editor.action.referenceSearch.trigger",
      label: localize("references.action.label", "Peek References"),
      alias: "Peek References",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      contextMenuOpts: {
        menuId: MenuId.EditorContextPeek,
        group: "peek",
        order: 6
      }
    });
  }
  _getLocationModel(model, position, token) {
    return __awaiter17(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getReferencesAtPosition(model, position, false, token), localize("ref.title", "References"));
    });
  }
});
var GenericGoToLocationAction = class extends SymbolNavigationAction {
  constructor(config, _references, _gotoMultipleBehaviour) {
    super(config, {
      id: "editor.action.goToLocation",
      label: localize("label.generic", "Go To Any Symbol"),
      alias: "Go To Any Symbol",
      precondition: ContextKeyExpr.and(PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated())
    });
    this._references = _references;
    this._gotoMultipleBehaviour = _gotoMultipleBehaviour;
  }
  _getLocationModel(_model, _position, _token) {
    return __awaiter17(this, void 0, void 0, function* () {
      return new ReferencesModel(this._references, localize("generic.title", "Locations"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && localize("generic.noResult", "No results for '{0}'", info.word) || "";
  }
  _getGoToPreference(editor3) {
    var _a5;
    return (_a5 = this._gotoMultipleBehaviour) !== null && _a5 !== void 0 ? _a5 : editor3.getOption(43).multipleReferences;
  }
  _getAlternativeCommand() {
    return "";
  }
};
CommandsRegistry.registerCommand({
  id: "editor.action.goToLocations",
  description: {
    description: "Go to locations from a position in a file",
    args: [
      {name: "uri", description: "The text document in which to start", constraint: URI},
      {name: "position", description: "The position at which to start", constraint: Position.isIPosition},
      {name: "locations", description: "An array of locations.", constraint: Array},
      {name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto"},
      {name: "noResultsMessage", description: "Human readable message that shows when locations is empty."}
    ]
  },
  handler: (accessor, resource, position, references, multiple, noResultsMessage, openInPeek) => __awaiter17(void 0, void 0, void 0, function* () {
    assertType(URI.isUri(resource));
    assertType(Position.isIPosition(position));
    assertType(Array.isArray(references));
    assertType(typeof multiple === "undefined" || typeof multiple === "string");
    assertType(typeof openInPeek === "undefined" || typeof openInPeek === "boolean");
    const editorService = accessor.get(ICodeEditorService);
    const editor3 = yield editorService.openCodeEditor({resource}, editorService.getFocusedCodeEditor());
    if (isCodeEditor(editor3)) {
      editor3.setPosition(position);
      editor3.revealPositionInCenterIfOutsideViewport(position, 0);
      return editor3.invokeWithinContext((accessor2) => {
        const command = new class extends GenericGoToLocationAction {
          _getNoResultFoundMessage(info) {
            return noResultsMessage || super._getNoResultFoundMessage(info);
          }
        }({
          muteMessage: !Boolean(noResultsMessage),
          openInPeek: Boolean(openInPeek),
          openToSide: false
        }, references, multiple);
        accessor2.get(IInstantiationService).invokeFunction(command.run.bind(command), editor3);
      });
    }
  })
});
CommandsRegistry.registerCommand({
  id: "editor.action.peekLocations",
  description: {
    description: "Peek locations from a position in a file",
    args: [
      {name: "uri", description: "The text document in which to start", constraint: URI},
      {name: "position", description: "The position at which to start", constraint: Position.isIPosition},
      {name: "locations", description: "An array of locations.", constraint: Array},
      {name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto"}
    ]
  },
  handler: (accessor, resource, position, references, multiple) => __awaiter17(void 0, void 0, void 0, function* () {
    accessor.get(ICommandService).executeCommand("editor.action.goToLocations", resource, position, references, multiple, void 0, true);
  })
});
CommandsRegistry.registerCommand({
  id: "editor.action.findReferences",
  handler: (accessor, resource, position) => {
    assertType(URI.isUri(resource));
    assertType(Position.isIPosition(position));
    const codeEditorService = accessor.get(ICodeEditorService);
    return codeEditorService.openCodeEditor({resource}, codeEditorService.getFocusedCodeEditor()).then((control) => {
      if (!isCodeEditor(control) || !control.hasModel()) {
        return void 0;
      }
      const controller = ReferencesController.get(control);
      if (!controller) {
        return void 0;
      }
      const references = createCancelablePromise((token) => getReferencesAtPosition(control.getModel(), Position.lift(position), false, token).then((references2) => new ReferencesModel(references2, localize("ref.title", "References"))));
      const range2 = new Range2(position.lineNumber, position.column, position.lineNumber, position.column);
      return Promise.resolve(controller.toggleWidget(range2, references, false));
    });
  }
});
CommandsRegistry.registerCommandAlias("editor.action.showReferences", "editor.action.peekLocations");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/clickLinkGesture.js
function hasModifier(e, modifier) {
  return !!e[modifier];
}
var ClickLinkMouseEvent = class {
  constructor(source, opts) {
    this.target = source.target;
    this.hasTriggerModifier = hasModifier(source.event, opts.triggerModifier);
    this.hasSideBySideModifier = hasModifier(source.event, opts.triggerSideBySideModifier);
    this.isNoneOrSingleMouseDown = source.event.detail <= 1;
  }
};
var ClickLinkKeyboardEvent = class {
  constructor(source, opts) {
    this.keyCodeIsTriggerKey = source.keyCode === opts.triggerKey;
    this.keyCodeIsSideBySideKey = source.keyCode === opts.triggerSideBySideKey;
    this.hasTriggerModifier = hasModifier(source, opts.triggerModifier);
  }
};
var ClickLinkOptions = class {
  constructor(triggerKey, triggerModifier, triggerSideBySideKey, triggerSideBySideModifier) {
    this.triggerKey = triggerKey;
    this.triggerModifier = triggerModifier;
    this.triggerSideBySideKey = triggerSideBySideKey;
    this.triggerSideBySideModifier = triggerSideBySideModifier;
  }
  equals(other) {
    return this.triggerKey === other.triggerKey && this.triggerModifier === other.triggerModifier && this.triggerSideBySideKey === other.triggerSideBySideKey && this.triggerSideBySideModifier === other.triggerSideBySideModifier;
  }
};
function createOptions(multiCursorModifier) {
  if (multiCursorModifier === "altKey") {
    if (isMacintosh) {
      return new ClickLinkOptions(57, "metaKey", 6, "altKey");
    }
    return new ClickLinkOptions(5, "ctrlKey", 6, "altKey");
  }
  if (isMacintosh) {
    return new ClickLinkOptions(6, "altKey", 57, "metaKey");
  }
  return new ClickLinkOptions(6, "altKey", 5, "ctrlKey");
}
var ClickLinkGesture = class extends Disposable {
  constructor(editor3) {
    super();
    this._onMouseMoveOrRelevantKeyDown = this._register(new Emitter2());
    this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event;
    this._onExecute = this._register(new Emitter2());
    this.onExecute = this._onExecute.event;
    this._onCancel = this._register(new Emitter2());
    this.onCancel = this._onCancel.event;
    this._editor = editor3;
    this._opts = createOptions(this._editor.getOption(61));
    this._lastMouseMoveEvent = null;
    this._hasTriggerKeyOnMouseDown = false;
    this._lineNumberOnMouseDown = 0;
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(61)) {
        const newOpts = createOptions(this._editor.getOption(61));
        if (this._opts.equals(newOpts)) {
          return;
        }
        this._opts = newOpts;
        this._lastMouseMoveEvent = null;
        this._hasTriggerKeyOnMouseDown = false;
        this._lineNumberOnMouseDown = 0;
        this._onCancel.fire();
      }
    }));
    this._register(this._editor.onMouseMove((e) => this._onEditorMouseMove(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onKeyDown((e) => this._onEditorKeyDown(new ClickLinkKeyboardEvent(e, this._opts))));
    this._register(this._editor.onKeyUp((e) => this._onEditorKeyUp(new ClickLinkKeyboardEvent(e, this._opts))));
    this._register(this._editor.onMouseDrag(() => this._resetHandler()));
    this._register(this._editor.onDidChangeCursorSelection((e) => this._onDidChangeCursorSelection(e)));
    this._register(this._editor.onDidChangeModel((e) => this._resetHandler()));
    this._register(this._editor.onDidChangeModelContent(() => this._resetHandler()));
    this._register(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged || e.scrollLeftChanged) {
        this._resetHandler();
      }
    }));
  }
  _onDidChangeCursorSelection(e) {
    if (e.selection && e.selection.startColumn !== e.selection.endColumn) {
      this._resetHandler();
    }
  }
  _onEditorMouseMove(mouseEvent) {
    this._lastMouseMoveEvent = mouseEvent;
    this._onMouseMoveOrRelevantKeyDown.fire([mouseEvent, null]);
  }
  _onEditorMouseDown(mouseEvent) {
    this._hasTriggerKeyOnMouseDown = mouseEvent.hasTriggerModifier;
    this._lineNumberOnMouseDown = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;
  }
  _onEditorMouseUp(mouseEvent) {
    const currentLineNumber = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;
    if (this._hasTriggerKeyOnMouseDown && this._lineNumberOnMouseDown && this._lineNumberOnMouseDown === currentLineNumber) {
      this._onExecute.fire(mouseEvent);
    }
  }
  _onEditorKeyDown(e) {
    if (this._lastMouseMoveEvent && (e.keyCodeIsTriggerKey || e.keyCodeIsSideBySideKey && e.hasTriggerModifier)) {
      this._onMouseMoveOrRelevantKeyDown.fire([this._lastMouseMoveEvent, e]);
    } else if (e.hasTriggerModifier) {
      this._onCancel.fire();
    }
  }
  _onEditorKeyUp(e) {
    if (e.keyCodeIsTriggerKey) {
      this._onCancel.fire();
    }
  }
  _resetHandler() {
    this._lastMouseMoveEvent = null;
    this._hasTriggerKeyOnMouseDown = false;
    this._onCancel.fire();
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.js
var __decorate22 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param22 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var GotoDefinitionAtPositionEditorContribution = class GotoDefinitionAtPositionEditorContribution2 {
  constructor(editor3, textModelResolverService, modeService) {
    this.textModelResolverService = textModelResolverService;
    this.modeService = modeService;
    this.toUnhook = new DisposableStore();
    this.toUnhookForKeyboard = new DisposableStore();
    this.linkDecorations = [];
    this.currentWordAtPosition = null;
    this.previousPromise = null;
    this.editor = editor3;
    let linkGesture = new ClickLinkGesture(editor3);
    this.toUnhook.add(linkGesture);
    this.toUnhook.add(linkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
      this.startFindDefinitionFromMouse(mouseEvent, withNullAsUndefined(keyboardEvent));
    }));
    this.toUnhook.add(linkGesture.onExecute((mouseEvent) => {
      if (this.isEnabled(mouseEvent)) {
        this.gotoDefinition(mouseEvent.target.position, mouseEvent.hasSideBySideModifier).then(() => {
          this.removeLinkDecorations();
        }, (error) => {
          this.removeLinkDecorations();
          onUnexpectedError(error);
        });
      }
    }));
    this.toUnhook.add(linkGesture.onCancel(() => {
      this.removeLinkDecorations();
      this.currentWordAtPosition = null;
    }));
  }
  static get(editor3) {
    return editor3.getContribution(GotoDefinitionAtPositionEditorContribution2.ID);
  }
  startFindDefinitionFromCursor(position) {
    return this.startFindDefinition(position).then(() => {
      this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
        this.currentWordAtPosition = null;
        this.removeLinkDecorations();
        this.toUnhookForKeyboard.clear();
      }));
      this.toUnhookForKeyboard.add(this.editor.onKeyDown((e) => {
        if (e) {
          this.currentWordAtPosition = null;
          this.removeLinkDecorations();
          this.toUnhookForKeyboard.clear();
        }
      }));
    });
  }
  startFindDefinitionFromMouse(mouseEvent, withKey) {
    if (mouseEvent.target.type === 9 && this.linkDecorations.length > 0) {
      return;
    }
    if (!this.editor.hasModel() || !this.isEnabled(mouseEvent, withKey)) {
      this.currentWordAtPosition = null;
      this.removeLinkDecorations();
      return;
    }
    const position = mouseEvent.target.position;
    this.startFindDefinition(position);
  }
  startFindDefinition(position) {
    var _a5;
    this.toUnhookForKeyboard.clear();
    const word = position ? (_a5 = this.editor.getModel()) === null || _a5 === void 0 ? void 0 : _a5.getWordAtPosition(position) : null;
    if (!word) {
      this.currentWordAtPosition = null;
      this.removeLinkDecorations();
      return Promise.resolve(0);
    }
    if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === word.startColumn && this.currentWordAtPosition.endColumn === word.endColumn && this.currentWordAtPosition.word === word.word) {
      return Promise.resolve(0);
    }
    this.currentWordAtPosition = word;
    let state = new EditorState(this.editor, 4 | 1 | 2 | 8);
    if (this.previousPromise) {
      this.previousPromise.cancel();
      this.previousPromise = null;
    }
    this.previousPromise = createCancelablePromise((token) => this.findDefinition(position, token));
    return this.previousPromise.then((results) => {
      if (!results || !results.length || !state.validate(this.editor)) {
        this.removeLinkDecorations();
        return;
      }
      if (results.length > 1) {
        this.addDecoration(new Range2(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn), new MarkdownString().appendText(localize("multipleResults", "Click to show {0} definitions.", results.length)));
      } else {
        let result = results[0];
        if (!result.uri) {
          return;
        }
        this.textModelResolverService.createModelReference(result.uri).then((ref) => {
          if (!ref.object || !ref.object.textEditorModel) {
            ref.dispose();
            return;
          }
          const {object: {textEditorModel}} = ref;
          const {startLineNumber} = result.range;
          if (startLineNumber < 1 || startLineNumber > textEditorModel.getLineCount()) {
            ref.dispose();
            return;
          }
          const previewValue = this.getPreviewValue(textEditorModel, startLineNumber, result);
          let wordRange;
          if (result.originSelectionRange) {
            wordRange = Range2.lift(result.originSelectionRange);
          } else {
            wordRange = new Range2(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
          }
          const modeId = this.modeService.getModeIdByFilepathOrFirstLine(textEditorModel.uri);
          this.addDecoration(wordRange, new MarkdownString().appendCodeblock(modeId ? modeId : "", previewValue));
          ref.dispose();
        });
      }
    }).then(void 0, onUnexpectedError);
  }
  getPreviewValue(textEditorModel, startLineNumber, result) {
    let rangeToUse = result.targetSelectionRange ? result.range : this.getPreviewRangeBasedOnBrackets(textEditorModel, startLineNumber);
    const numberOfLinesInRange = rangeToUse.endLineNumber - rangeToUse.startLineNumber;
    if (numberOfLinesInRange >= GotoDefinitionAtPositionEditorContribution2.MAX_SOURCE_PREVIEW_LINES) {
      rangeToUse = this.getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber);
    }
    const previewValue = this.stripIndentationFromPreviewRange(textEditorModel, startLineNumber, rangeToUse);
    return previewValue;
  }
  stripIndentationFromPreviewRange(textEditorModel, startLineNumber, previewRange) {
    const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    let minIndent = startIndent;
    for (let endLineNumber = startLineNumber + 1; endLineNumber < previewRange.endLineNumber; endLineNumber++) {
      const endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
      minIndent = Math.min(minIndent, endIndent);
    }
    const previewValue = textEditorModel.getValueInRange(previewRange).replace(new RegExp(`^\\s{${minIndent - 1}}`, "gm"), "").trim();
    return previewValue;
  }
  getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber) {
    const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    const maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionAtPositionEditorContribution2.MAX_SOURCE_PREVIEW_LINES);
    let endLineNumber = startLineNumber + 1;
    for (; endLineNumber < maxLineNumber; endLineNumber++) {
      let endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
      if (startIndent === endIndent) {
        break;
      }
    }
    return new Range2(startLineNumber, 1, endLineNumber + 1, 1);
  }
  getPreviewRangeBasedOnBrackets(textEditorModel, startLineNumber) {
    const maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionAtPositionEditorContribution2.MAX_SOURCE_PREVIEW_LINES);
    const brackets = [];
    let ignoreFirstEmpty = true;
    let currentBracket = textEditorModel.findNextBracket(new Position(startLineNumber, 1));
    while (currentBracket !== null) {
      if (brackets.length === 0) {
        brackets.push(currentBracket);
      } else {
        const lastBracket = brackets[brackets.length - 1];
        if (lastBracket.open[0] === currentBracket.open[0] && lastBracket.isOpen && !currentBracket.isOpen) {
          brackets.pop();
        } else {
          brackets.push(currentBracket);
        }
        if (brackets.length === 0) {
          if (ignoreFirstEmpty) {
            ignoreFirstEmpty = false;
          } else {
            return new Range2(startLineNumber, 1, currentBracket.range.endLineNumber + 1, 1);
          }
        }
      }
      const maxColumn = textEditorModel.getLineMaxColumn(startLineNumber);
      let nextLineNumber = currentBracket.range.endLineNumber;
      let nextColumn = currentBracket.range.endColumn;
      if (maxColumn === currentBracket.range.endColumn) {
        nextLineNumber++;
        nextColumn = 1;
      }
      if (nextLineNumber > maxLineNumber) {
        return new Range2(startLineNumber, 1, maxLineNumber + 1, 1);
      }
      currentBracket = textEditorModel.findNextBracket(new Position(nextLineNumber, nextColumn));
    }
    return new Range2(startLineNumber, 1, maxLineNumber + 1, 1);
  }
  addDecoration(range2, hoverMessage) {
    const newDecorations = {
      range: range2,
      options: {
        inlineClassName: "goto-definition-link",
        hoverMessage
      }
    };
    this.linkDecorations = this.editor.deltaDecorations(this.linkDecorations, [newDecorations]);
  }
  removeLinkDecorations() {
    if (this.linkDecorations.length > 0) {
      this.linkDecorations = this.editor.deltaDecorations(this.linkDecorations, []);
    }
  }
  isEnabled(mouseEvent, withKey) {
    return this.editor.hasModel() && mouseEvent.isNoneOrSingleMouseDown && mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || (withKey ? withKey.keyCodeIsTriggerKey : false)) && DefinitionProviderRegistry.has(this.editor.getModel());
  }
  findDefinition(position, token) {
    const model = this.editor.getModel();
    if (!model) {
      return Promise.resolve(null);
    }
    return getDefinitionsAtPosition(model, position, token);
  }
  gotoDefinition(position, openToSide) {
    this.editor.setPosition(position);
    return this.editor.invokeWithinContext((accessor) => {
      const canPeek = !openToSide && this.editor.getOption(69) && !this.isInPeekEditor(accessor);
      const action = new DefinitionAction({openToSide, openInPeek: canPeek, muteMessage: true}, {alias: "", label: "", id: "", precondition: void 0});
      return action.run(accessor, this.editor);
    });
  }
  isInPeekEditor(accessor) {
    const contextKeyService = accessor.get(IContextKeyService);
    return PeekContext.inPeekEditor.getValue(contextKeyService);
  }
  dispose() {
    this.toUnhook.dispose();
  }
};
GotoDefinitionAtPositionEditorContribution.ID = "editor.contrib.gotodefinitionatposition";
GotoDefinitionAtPositionEditorContribution.MAX_SOURCE_PREVIEW_LINES = 8;
GotoDefinitionAtPositionEditorContribution = __decorate22([
  __param22(1, ITextModelService),
  __param22(2, IModeService)
], GotoDefinitionAtPositionEditorContribution);
registerEditorContribution(GotoDefinitionAtPositionEditorContribution.ID, GotoDefinitionAtPositionEditorContribution);
registerThemingParticipant((theme6, collector) => {
  const activeLinkForeground = theme6.getColor(editorActiveLinkForeground);
  if (activeLinkForeground) {
    collector.addRule(`.monaco-editor .goto-definition-link { color: ${activeLinkForeground} !important; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/platform/severityIcon/common/severityIcon.js
var SeverityIcon;
(function(SeverityIcon2) {
  function className(severity) {
    switch (severity) {
      case severity_default.Ignore:
        return "severity-ignore " + Codicon.info.classNames;
      case severity_default.Info:
        return Codicon.info.classNames;
      case severity_default.Warning:
        return Codicon.warning.classNames;
      case severity_default.Error:
        return Codicon.error.classNames;
      default:
        return "";
    }
  }
  SeverityIcon2.className = className;
})(SeverityIcon || (SeverityIcon = {}));
registerThemingParticipant((theme6, collector) => {
  const errorIconForeground = theme6.getColor(problemsErrorIconForeground);
  if (errorIconForeground) {
    const errorCodiconSelector = Codicon.error.cssSelector;
    collector.addRule(`
			.monaco-editor .zone-widget ${errorCodiconSelector},
			.markers-panel .marker-icon${errorCodiconSelector},
			.extensions-viewlet > .extensions ${errorCodiconSelector} {
				color: ${errorIconForeground};
			}
		`);
  }
  const warningIconForeground = theme6.getColor(problemsWarningIconForeground);
  if (warningIconForeground) {
    const warningCodiconSelector = Codicon.warning.cssSelector;
    collector.addRule(`
			.monaco-editor .zone-widget ${warningCodiconSelector},
			.markers-panel .marker-icon${warningCodiconSelector},
			.extensions-viewlet > .extensions ${warningCodiconSelector},
			.extension-editor ${warningCodiconSelector} {
				color: ${warningIconForeground};
			}
		`);
  }
  const infoIconForeground = theme6.getColor(problemsInfoIconForeground);
  if (infoIconForeground) {
    const infoCodiconSelector = Codicon.info.cssSelector;
    collector.addRule(`
			.monaco-editor .zone-widget ${infoCodiconSelector},
			.markers-panel .marker-icon${infoCodiconSelector},
			.extensions-viewlet > .extensions ${infoCodiconSelector},
			.extension-editor ${infoCodiconSelector} {
				color: ${infoIconForeground};
			}
		`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/gotoErrorWidget.js
var __decorate23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param23 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MessageWidget2 = class {
  constructor(parent2, editor3, onRelatedInformation, _openerService) {
    this._openerService = _openerService;
    this._lines = 0;
    this._longestLineLength = 0;
    this._relatedDiagnostics = new WeakMap();
    this._disposables = new DisposableStore();
    this._editor = editor3;
    const domNode = document.createElement("div");
    domNode.className = "descriptioncontainer";
    this._messageBlock = document.createElement("div");
    addClass(this._messageBlock, "message");
    this._messageBlock.setAttribute("aria-live", "assertive");
    this._messageBlock.setAttribute("role", "alert");
    domNode.appendChild(this._messageBlock);
    this._relatedBlock = document.createElement("div");
    domNode.appendChild(this._relatedBlock);
    this._disposables.add(addStandardDisposableListener(this._relatedBlock, "click", (event) => {
      event.preventDefault();
      const related = this._relatedDiagnostics.get(event.target);
      if (related) {
        onRelatedInformation(related);
      }
    }));
    this._scrollable = new ScrollableElement(domNode, {
      horizontal: 1,
      vertical: 1,
      useShadows: false,
      horizontalScrollbarSize: 3,
      verticalScrollbarSize: 3
    });
    parent2.appendChild(this._scrollable.getDomNode());
    this._disposables.add(this._scrollable.onScroll((e) => {
      domNode.style.left = `-${e.scrollLeft}px`;
      domNode.style.top = `-${e.scrollTop}px`;
    }));
    this._disposables.add(this._scrollable);
  }
  dispose() {
    dispose(this._disposables);
  }
  update(marker) {
    const {source, message, relatedInformation, code: code3} = marker;
    let sourceAndCodeLength = ((source === null || source === void 0 ? void 0 : source.length) || 0) + "()".length;
    if (code3) {
      if (typeof code3 === "string") {
        sourceAndCodeLength += code3.length;
      } else {
        sourceAndCodeLength += code3.value.length;
      }
    }
    const lines = message.split(/\r\n|\r|\n/g);
    this._lines = lines.length;
    this._longestLineLength = 0;
    for (const line of lines) {
      this._longestLineLength = Math.max(line.length + sourceAndCodeLength, this._longestLineLength);
    }
    clearNode(this._messageBlock);
    this._messageBlock.setAttribute("aria-label", this.getAriaLabel(marker));
    this._editor.applyFontInfo(this._messageBlock);
    let lastLineElement = this._messageBlock;
    for (const line of lines) {
      lastLineElement = document.createElement("div");
      lastLineElement.innerText = line;
      if (line === "") {
        lastLineElement.style.height = this._messageBlock.style.lineHeight;
      }
      this._messageBlock.appendChild(lastLineElement);
    }
    if (source || code3) {
      const detailsElement = document.createElement("span");
      addClass(detailsElement, "details");
      lastLineElement.appendChild(detailsElement);
      if (source) {
        const sourceElement = document.createElement("span");
        sourceElement.innerText = source;
        addClass(sourceElement, "source");
        detailsElement.appendChild(sourceElement);
      }
      if (code3) {
        if (typeof code3 === "string") {
          const codeElement = document.createElement("span");
          codeElement.innerText = `(${code3})`;
          addClass(codeElement, "code");
          detailsElement.appendChild(codeElement);
        } else {
          this._codeLink = $("a.code-link");
          this._codeLink.setAttribute("href", `${code3.target.toString()}`);
          this._codeLink.onclick = (e) => {
            this._openerService.open(code3.target);
            e.preventDefault();
            e.stopPropagation();
          };
          const codeElement = append(this._codeLink, $("span"));
          codeElement.innerText = code3.value;
          detailsElement.appendChild(this._codeLink);
        }
      }
    }
    clearNode(this._relatedBlock);
    this._editor.applyFontInfo(this._relatedBlock);
    if (isNonEmptyArray(relatedInformation)) {
      const relatedInformationNode = this._relatedBlock.appendChild(document.createElement("div"));
      relatedInformationNode.style.paddingTop = `${Math.floor(this._editor.getOption(51) * 0.66)}px`;
      this._lines += 1;
      for (const related of relatedInformation) {
        let container = document.createElement("div");
        let relatedResource = document.createElement("a");
        addClass(relatedResource, "filename");
        relatedResource.innerText = `${getBaseLabel(related.resource)}(${related.startLineNumber}, ${related.startColumn}): `;
        relatedResource.title = getPathLabel(related.resource, void 0);
        this._relatedDiagnostics.set(relatedResource, related);
        let relatedMessage = document.createElement("span");
        relatedMessage.innerText = related.message;
        container.appendChild(relatedResource);
        container.appendChild(relatedMessage);
        this._lines += 1;
        relatedInformationNode.appendChild(container);
      }
    }
    const fontInfo = this._editor.getOption(36);
    const scrollWidth = Math.ceil(fontInfo.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75);
    const scrollHeight = fontInfo.lineHeight * this._lines;
    this._scrollable.setScrollDimensions({scrollWidth, scrollHeight});
  }
  layout(height, width) {
    this._scrollable.getDomNode().style.height = `${height}px`;
    this._scrollable.getDomNode().style.width = `${width}px`;
    this._scrollable.setScrollDimensions({width, height});
  }
  getHeightInLines() {
    return Math.min(17, this._lines);
  }
  getAriaLabel(marker) {
    let severityLabel = "";
    switch (marker.severity) {
      case MarkerSeverity.Error:
        severityLabel = localize("Error", "Error");
        break;
      case MarkerSeverity.Warning:
        severityLabel = localize("Warning", "Warning");
        break;
      case MarkerSeverity.Info:
        severityLabel = localize("Info", "Info");
        break;
      case MarkerSeverity.Hint:
        severityLabel = localize("Hint", "Hint");
        break;
    }
    let ariaLabel = localize("marker aria", "{0} at {1}. ", severityLabel, marker.startLineNumber + ":" + marker.startColumn);
    const model = this._editor.getModel();
    if (model && marker.startLineNumber <= model.getLineCount() && marker.startLineNumber >= 1) {
      const lineContent = model.getLineContent(marker.startLineNumber);
      ariaLabel = `${lineContent}, ${ariaLabel}`;
    }
    return ariaLabel;
  }
};
var MarkerNavigationWidget = class MarkerNavigationWidget2 extends PeekViewWidget {
  constructor(editor3, _themeService, _openerService, _menuService, instantiationService, _contextKeyService) {
    super(editor3, {showArrow: true, showFrame: true, isAccessible: true}, instantiationService);
    this._themeService = _themeService;
    this._openerService = _openerService;
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._callOnDispose = new DisposableStore();
    this._onDidSelectRelatedInformation = new Emitter2();
    this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event;
    this._severity = MarkerSeverity.Warning;
    this._backgroundColor = Color.white;
    this._applyTheme(_themeService.getColorTheme());
    this._callOnDispose.add(_themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
    this.create();
  }
  _applyTheme(theme6) {
    this._backgroundColor = theme6.getColor(editorMarkerNavigationBackground);
    let colorId = editorMarkerNavigationError;
    if (this._severity === MarkerSeverity.Warning) {
      colorId = editorMarkerNavigationWarning;
    } else if (this._severity === MarkerSeverity.Info) {
      colorId = editorMarkerNavigationInfo;
    }
    const frameColor = theme6.getColor(colorId);
    this.style({
      arrowColor: frameColor,
      frameColor,
      headerBackgroundColor: this._backgroundColor,
      primaryHeadingColor: theme6.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme6.getColor(peekViewTitleInfoForeground)
    });
  }
  _applyStyles() {
    if (this._parentContainer) {
      this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : "";
    }
    super._applyStyles();
  }
  dispose() {
    this._callOnDispose.dispose();
    super.dispose();
  }
  _fillHead(container) {
    super._fillHead(container);
    this._disposables.add(this._actionbarWidget.actionRunner.onDidBeforeRun((e) => this.editor.focus()));
    const actions25 = [];
    const menu = this._menuService.createMenu(MarkerNavigationWidget2.TitleMenu, this._contextKeyService);
    createAndFillInActionBarActions(menu, void 0, actions25);
    this._actionbarWidget.push(actions25, {label: false, icon: true, index: 0});
    menu.dispose();
  }
  _fillTitleIcon(container) {
    this._icon = append(container, $(""));
  }
  _getActionBarOptions() {
    return Object.assign(Object.assign({}, super._getActionBarOptions()), {orientation: 0});
  }
  _fillBody(container) {
    this._parentContainer = container;
    addClass(container, "marker-widget");
    this._parentContainer.tabIndex = 0;
    this._parentContainer.setAttribute("role", "tooltip");
    this._container = document.createElement("div");
    container.appendChild(this._container);
    this._message = new MessageWidget2(this._container, this.editor, (related) => this._onDidSelectRelatedInformation.fire(related), this._openerService);
    this._disposables.add(this._message);
  }
  show() {
    throw new Error("call showAtMarker");
  }
  showAtMarker(marker, markerIdx, markerCount) {
    this._container.classList.remove("stale");
    this._message.update(marker);
    this._severity = marker.severity;
    this._applyTheme(this._themeService.getColorTheme());
    let range2 = Range2.lift(marker);
    const editorPosition = this.editor.getPosition();
    let position = editorPosition && range2.containsPosition(editorPosition) ? editorPosition : range2.getStartPosition();
    super.show(position, this.computeRequiredHeight());
    const model = this.editor.getModel();
    if (model) {
      const detail = markerCount > 1 ? localize("problems", "{0} of {1} problems", markerIdx, markerCount) : localize("change", "{0} of {1} problem", markerIdx, markerCount);
      this.setTitle(basename(model.uri), detail);
    }
    this._icon.className = `codicon ${SeverityIcon.className(MarkerSeverity.toSeverity(this._severity))}`;
    this.editor.revealPositionNearTop(position, 0);
    this.editor.focus();
  }
  updateMarker(marker) {
    this._container.classList.remove("stale");
    this._message.update(marker);
  }
  showStale() {
    this._container.classList.add("stale");
    this._relayout();
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    super._doLayoutBody(heightInPixel, widthInPixel);
    this._heightInPixel = heightInPixel;
    this._message.layout(heightInPixel, widthInPixel);
    this._container.style.height = `${heightInPixel}px`;
  }
  _onWidth(widthInPixel) {
    this._message.layout(this._heightInPixel, widthInPixel);
  }
  _relayout() {
    super._relayout(this.computeRequiredHeight());
  }
  computeRequiredHeight() {
    return 3 + this._message.getHeightInLines();
  }
};
MarkerNavigationWidget.TitleMenu = new MenuId("gotoErrorTitleMenu");
MarkerNavigationWidget = __decorate23([
  __param23(1, IThemeService),
  __param23(2, IOpenerService),
  __param23(3, IMenuService),
  __param23(4, IInstantiationService),
  __param23(5, IContextKeyService)
], MarkerNavigationWidget);
var errorDefault = oneOf(editorErrorForeground, editorErrorBorder);
var warningDefault = oneOf(editorWarningForeground, editorWarningBorder);
var infoDefault = oneOf(editorInfoForeground, editorInfoBorder);
var editorMarkerNavigationError = registerColor("editorMarkerNavigationError.background", {dark: errorDefault, light: errorDefault, hc: errorDefault}, localize("editorMarkerNavigationError", "Editor marker navigation widget error color."));
var editorMarkerNavigationWarning = registerColor("editorMarkerNavigationWarning.background", {dark: warningDefault, light: warningDefault, hc: warningDefault}, localize("editorMarkerNavigationWarning", "Editor marker navigation widget warning color."));
var editorMarkerNavigationInfo = registerColor("editorMarkerNavigationInfo.background", {dark: infoDefault, light: infoDefault, hc: infoDefault}, localize("editorMarkerNavigationInfo", "Editor marker navigation widget info color."));
var editorMarkerNavigationBackground = registerColor("editorMarkerNavigation.background", {dark: "#2D2D30", light: Color.white, hc: "#0C141F"}, localize("editorMarkerNavigationBackground", "Editor marker navigation widget background."));
registerThemingParticipant((theme6, collector) => {
  const linkFg = theme6.getColor(textLinkForeground);
  if (linkFg) {
    collector.addRule(`.monaco-editor .marker-widget a { color: ${linkFg}; }`);
    collector.addRule(`.monaco-editor .marker-widget a.code-link span:hover { color: ${linkFg}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/markerNavigationService.js
var __decorate24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param24 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MarkerCoordinate = class {
  constructor(marker, index2, total) {
    this.marker = marker;
    this.index = index2;
    this.total = total;
  }
};
var MarkerList = class MarkerList2 {
  constructor(resourceFilter, _markerService) {
    this._markerService = _markerService;
    this._onDidChange = new Emitter2();
    this.onDidChange = this._onDidChange.event;
    this._dispoables = new DisposableStore();
    this._markers = [];
    this._nextIdx = -1;
    if (URI.isUri(resourceFilter)) {
      this._resourceFilter = (uri) => uri.toString() === resourceFilter.toString();
    } else if (resourceFilter) {
      this._resourceFilter = resourceFilter;
    }
    const updateMarker = () => {
      this._markers = this._markerService.read({
        resource: URI.isUri(resourceFilter) ? resourceFilter : void 0,
        severities: MarkerSeverity.Error | MarkerSeverity.Warning | MarkerSeverity.Info
      });
      if (typeof resourceFilter === "function") {
        this._markers = this._markers.filter((m) => this._resourceFilter(m.resource));
      }
      this._markers.sort(MarkerList2._compareMarker);
    };
    updateMarker();
    this._dispoables.add(_markerService.onMarkerChanged((uris) => {
      if (!this._resourceFilter || uris.some((uri) => this._resourceFilter(uri))) {
        updateMarker();
        this._nextIdx = -1;
        this._onDidChange.fire();
      }
    }));
  }
  dispose() {
    this._dispoables.dispose();
    this._onDidChange.dispose();
  }
  matches(uri) {
    if (!this._resourceFilter && !uri) {
      return true;
    }
    if (!this._resourceFilter || !uri) {
      return false;
    }
    return this._resourceFilter(uri);
  }
  get selected() {
    const marker = this._markers[this._nextIdx];
    return marker && new MarkerCoordinate(marker, this._nextIdx + 1, this._markers.length);
  }
  _initIdx(model, position, fwd) {
    let found = false;
    let idx = this._markers.findIndex((marker) => marker.resource.toString() === model.uri.toString());
    if (idx < 0) {
      idx = binarySearch(this._markers, {resource: model.uri}, (a, b) => compare(a.resource.toString(), b.resource.toString()));
      if (idx < 0) {
        idx = ~idx;
      }
    }
    for (let i = idx; i < this._markers.length; i++) {
      let range2 = Range2.lift(this._markers[i]);
      if (range2.isEmpty()) {
        const word = model.getWordAtPosition(range2.getStartPosition());
        if (word) {
          range2 = new Range2(range2.startLineNumber, word.startColumn, range2.startLineNumber, word.endColumn);
        }
      }
      if (position && (range2.containsPosition(position) || position.isBeforeOrEqual(range2.getStartPosition()))) {
        this._nextIdx = i;
        found = true;
        break;
      }
      if (this._markers[i].resource.toString() !== model.uri.toString()) {
        break;
      }
    }
    if (!found) {
      this._nextIdx = fwd ? 0 : this._markers.length - 1;
    }
    if (this._nextIdx < 0) {
      this._nextIdx = this._markers.length - 1;
    }
  }
  resetIndex() {
    this._nextIdx = -1;
  }
  move(fwd, model, position) {
    if (this._markers.length === 0) {
      return false;
    }
    let oldIdx = this._nextIdx;
    if (this._nextIdx === -1) {
      this._initIdx(model, position, fwd);
    } else if (fwd) {
      this._nextIdx = (this._nextIdx + 1) % this._markers.length;
    } else if (!fwd) {
      this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length;
    }
    if (oldIdx !== this._nextIdx) {
      return true;
    }
    return false;
  }
  find(uri, position) {
    let idx = this._markers.findIndex((marker) => marker.resource.toString() === uri.toString());
    if (idx < 0) {
      return void 0;
    }
    for (; idx < this._markers.length; idx++) {
      if (Range2.containsPosition(this._markers[idx], position)) {
        return new MarkerCoordinate(this._markers[idx], idx + 1, this._markers.length);
      }
    }
    return void 0;
  }
  static _compareMarker(a, b) {
    let res = compare(a.resource.toString(), b.resource.toString());
    if (res === 0) {
      res = MarkerSeverity.compare(a.severity, b.severity);
    }
    if (res === 0) {
      res = Range2.compareRangesUsingStarts(a, b);
    }
    return res;
  }
};
MarkerList = __decorate24([
  __param24(1, IMarkerService)
], MarkerList);
var IMarkerNavigationService = createDecorator("IMarkerNavigationService");
var MarkerNavigationService = class MarkerNavigationService2 {
  constructor(_markerService) {
    this._markerService = _markerService;
    this._provider = new LinkedList();
  }
  getMarkerList(resource) {
    for (let provider of this._provider) {
      const result = provider.getMarkerList(resource);
      if (result) {
        return result;
      }
    }
    return new MarkerList(resource, this._markerService);
  }
};
MarkerNavigationService = __decorate24([
  __param24(0, IMarkerService)
], MarkerNavigationService);
registerSingleton(IMarkerNavigationService, MarkerNavigationService, true);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/gotoError.js
var __decorate25 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param25 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MarkerController = class MarkerController2 {
  constructor(editor3, _markerNavigationService, _contextKeyService, _editorService, _instantiationService) {
    this._markerNavigationService = _markerNavigationService;
    this._contextKeyService = _contextKeyService;
    this._editorService = _editorService;
    this._instantiationService = _instantiationService;
    this._sessionDispoables = new DisposableStore();
    this._editor = editor3;
    this._widgetVisible = CONTEXT_MARKERS_NAVIGATION_VISIBLE.bindTo(this._contextKeyService);
  }
  static get(editor3) {
    return editor3.getContribution(MarkerController2.ID);
  }
  dispose() {
    this._cleanUp();
    this._sessionDispoables.dispose();
  }
  _cleanUp() {
    this._widgetVisible.reset();
    this._sessionDispoables.clear();
    this._widget = void 0;
    this._model = void 0;
  }
  _getOrCreateModel(uri) {
    if (this._model && this._model.matches(uri)) {
      return this._model;
    }
    let reusePosition = false;
    if (this._model) {
      reusePosition = true;
      this._cleanUp();
    }
    this._model = this._markerNavigationService.getMarkerList(uri);
    if (reusePosition) {
      this._model.move(true, this._editor.getModel(), this._editor.getPosition());
    }
    this._widget = this._instantiationService.createInstance(MarkerNavigationWidget, this._editor);
    this._widget.onDidClose(() => this.close(), this, this._sessionDispoables);
    this._widgetVisible.set(true);
    this._sessionDispoables.add(this._model);
    this._sessionDispoables.add(this._widget);
    this._sessionDispoables.add(this._editor.onDidChangeCursorPosition((e) => {
      var _a5, _b2, _c2;
      if (!((_a5 = this._model) === null || _a5 === void 0 ? void 0 : _a5.selected) || !Range2.containsPosition((_b2 = this._model) === null || _b2 === void 0 ? void 0 : _b2.selected.marker, e.position)) {
        (_c2 = this._model) === null || _c2 === void 0 ? void 0 : _c2.resetIndex();
      }
    }));
    this._sessionDispoables.add(this._model.onDidChange(() => {
      if (!this._widget || !this._widget.position || !this._model) {
        return;
      }
      const info = this._model.find(this._editor.getModel().uri, this._widget.position);
      if (info) {
        this._widget.updateMarker(info.marker);
      } else {
        this._widget.showStale();
      }
    }));
    this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation((related) => {
      this._editorService.openCodeEditor({
        resource: related.resource,
        options: {pinned: true, revealIfOpened: true, selection: Range2.lift(related).collapseToStart()}
      }, this._editor);
      this.close(false);
    }));
    this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp()));
    return this._model;
  }
  close(focusEditor = true) {
    this._cleanUp();
    if (focusEditor) {
      this._editor.focus();
    }
  }
  showAtMarker(marker) {
    if (this._editor.hasModel()) {
      const model = this._getOrCreateModel(this._editor.getModel().uri);
      model.resetIndex();
      model.move(true, this._editor.getModel(), new Position(marker.startLineNumber, marker.startColumn));
      if (model.selected) {
        this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
      }
    }
  }
  nagivate(next, multiFile) {
    return __awaiter18(this, void 0, void 0, function* () {
      if (this._editor.hasModel()) {
        const model = this._getOrCreateModel(multiFile ? void 0 : this._editor.getModel().uri);
        model.move(next, this._editor.getModel(), this._editor.getPosition());
        if (!model.selected) {
          return;
        }
        if (model.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
          this._cleanUp();
          const otherEditor = yield this._editorService.openCodeEditor({
            resource: model.selected.marker.resource,
            options: {pinned: false, revealIfOpened: true, selectionRevealType: 2, selection: model.selected.marker}
          }, this._editor);
          if (otherEditor) {
            MarkerController2.get(otherEditor).close();
            MarkerController2.get(otherEditor).nagivate(next, multiFile);
          }
        } else {
          this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
        }
      }
    });
  }
};
MarkerController.ID = "editor.contrib.markerController";
MarkerController = __decorate25([
  __param25(1, IMarkerNavigationService),
  __param25(2, IContextKeyService),
  __param25(3, ICodeEditorService),
  __param25(4, IInstantiationService)
], MarkerController);
var MarkerNavigationAction = class extends EditorAction {
  constructor(_next, _multiFile, opts) {
    super(opts);
    this._next = _next;
    this._multiFile = _multiFile;
  }
  run(_accessor, editor3) {
    return __awaiter18(this, void 0, void 0, function* () {
      if (editor3.hasModel()) {
        MarkerController.get(editor3).nagivate(this._next, this._multiFile);
      }
    });
  }
};
var NextMarkerAction = class extends MarkerNavigationAction {
  constructor() {
    super(true, false, {
      id: NextMarkerAction.ID,
      label: NextMarkerAction.LABEL,
      alias: "Go to Next Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 512 | 66,
        weight: 100
      },
      menuOpts: {
        menuId: MarkerNavigationWidget.TitleMenu,
        title: NextMarkerAction.LABEL,
        icon: registerIcon("marker-navigation-next", Codicon.chevronDown),
        group: "navigation",
        order: 1
      }
    });
  }
};
NextMarkerAction.ID = "editor.action.marker.next";
NextMarkerAction.LABEL = localize("markerAction.next.label", "Go to Next Problem (Error, Warning, Info)");
var PrevMarkerAction = class extends MarkerNavigationAction {
  constructor() {
    super(false, false, {
      id: PrevMarkerAction.ID,
      label: PrevMarkerAction.LABEL,
      alias: "Go to Previous Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 1024 | 512 | 66,
        weight: 100
      },
      menuOpts: {
        menuId: MarkerNavigationWidget.TitleMenu,
        title: NextMarkerAction.LABEL,
        icon: registerIcon("marker-navigation-previous", Codicon.chevronUp),
        group: "navigation",
        order: 2
      }
    });
  }
};
PrevMarkerAction.ID = "editor.action.marker.prev";
PrevMarkerAction.LABEL = localize("markerAction.previous.label", "Go to Previous Problem (Error, Warning, Info)");
var NextMarkerInFilesAction = class extends MarkerNavigationAction {
  constructor() {
    super(true, true, {
      id: "editor.action.marker.nextInFiles",
      label: localize("markerAction.nextInFiles.label", "Go to Next Problem in Files (Error, Warning, Info)"),
      alias: "Go to Next Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 66,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        title: localize({key: "miGotoNextProblem", comment: ["&& denotes a mnemonic"]}, "Next &&Problem"),
        group: "6_problem_nav",
        order: 1
      }
    });
  }
};
var PrevMarkerInFilesAction = class extends MarkerNavigationAction {
  constructor() {
    super(false, true, {
      id: "editor.action.marker.prevInFiles",
      label: localize("markerAction.previousInFiles.label", "Go to Previous Problem in Files (Error, Warning, Info)"),
      alias: "Go to Previous Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 1024 | 66,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        title: localize({key: "miGotoPreviousProblem", comment: ["&& denotes a mnemonic"]}, "Previous &&Problem"),
        group: "6_problem_nav",
        order: 2
      }
    });
  }
};
registerEditorContribution(MarkerController.ID, MarkerController);
registerEditorAction(NextMarkerAction);
registerEditorAction(PrevMarkerAction);
registerEditorAction(NextMarkerInFilesAction);
registerEditorAction(PrevMarkerInFilesAction);
var CONTEXT_MARKERS_NAVIGATION_VISIBLE = new RawContextKey("markersNavigationVisible", false);
var MarkerCommand = EditorCommand.bindToContribution(MarkerController.get);
registerEditorCommand(new MarkerCommand({
  id: "closeMarkersNavigation",
  precondition: CONTEXT_MARKERS_NAVIGATION_VISIBLE,
  handler: (x) => x.close(),
  kbOpts: {
    weight: 100 + 50,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPickerModel.js
var ColorPickerModel = class {
  constructor(color, availableColorPresentations, presentationIndex) {
    this.presentationIndex = presentationIndex;
    this._onColorFlushed = new Emitter2();
    this.onColorFlushed = this._onColorFlushed.event;
    this._onDidChangeColor = new Emitter2();
    this.onDidChangeColor = this._onDidChangeColor.event;
    this._onDidChangePresentation = new Emitter2();
    this.onDidChangePresentation = this._onDidChangePresentation.event;
    this.originalColor = color;
    this._color = color;
    this._colorPresentations = availableColorPresentations;
  }
  get color() {
    return this._color;
  }
  set color(color) {
    if (this._color.equals(color)) {
      return;
    }
    this._color = color;
    this._onDidChangeColor.fire(color);
  }
  get presentation() {
    return this.colorPresentations[this.presentationIndex];
  }
  get colorPresentations() {
    return this._colorPresentations;
  }
  set colorPresentations(colorPresentations) {
    this._colorPresentations = colorPresentations;
    if (this.presentationIndex > colorPresentations.length - 1) {
      this.presentationIndex = 0;
    }
    this._onDidChangePresentation.fire(this.presentation);
  }
  selectNextColorPresentation() {
    this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length;
    this.flushColor();
    this._onDidChangePresentation.fire(this.presentation);
  }
  guessColorPresentation(color, originalText) {
    for (let i = 0; i < this.colorPresentations.length; i++) {
      if (originalText.toLowerCase() === this.colorPresentations[i].label) {
        this.presentationIndex = i;
        this._onDidChangePresentation.fire(this.presentation);
        break;
      }
    }
  }
  flushColor() {
    this._onColorFlushed.fire(this._color);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPickerWidget.js
var $2 = $;
var ColorPickerHeader = class extends Disposable {
  constructor(container, model, themeService) {
    super();
    this.model = model;
    this.domNode = $2(".colorpicker-header");
    append(container, this.domNode);
    this.pickedColorNode = append(this.domNode, $2(".picked-color"));
    const colorBox = append(this.domNode, $2(".original-color"));
    colorBox.style.backgroundColor = Color.Format.CSS.format(this.model.originalColor) || "";
    this.backgroundColor = themeService.getColorTheme().getColor(editorHoverBackground) || Color.white;
    this._register(registerThemingParticipant((theme6, collector) => {
      this.backgroundColor = theme6.getColor(editorHoverBackground) || Color.white;
    }));
    this._register(addDisposableListener(this.pickedColorNode, EventType2.CLICK, () => this.model.selectNextColorPresentation()));
    this._register(addDisposableListener(colorBox, EventType2.CLICK, () => {
      this.model.color = this.model.originalColor;
      this.model.flushColor();
    }));
    this._register(model.onDidChangeColor(this.onDidChangeColor, this));
    this._register(model.onDidChangePresentation(this.onDidChangePresentation, this));
    this.pickedColorNode.style.backgroundColor = Color.Format.CSS.format(model.color) || "";
    toggleClass(this.pickedColorNode, "light", model.color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : model.color.isLighter());
  }
  onDidChangeColor(color) {
    this.pickedColorNode.style.backgroundColor = Color.Format.CSS.format(color) || "";
    toggleClass(this.pickedColorNode, "light", color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : color.isLighter());
    this.onDidChangePresentation();
  }
  onDidChangePresentation() {
    this.pickedColorNode.textContent = this.model.presentation ? this.model.presentation.label : "";
  }
};
var ColorPickerBody = class extends Disposable {
  constructor(container, model, pixelRatio) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this.domNode = $2(".colorpicker-body");
    append(container, this.domNode);
    this.saturationBox = new SaturationBox(this.domNode, this.model, this.pixelRatio);
    this._register(this.saturationBox);
    this._register(this.saturationBox.onDidChange(this.onDidSaturationValueChange, this));
    this._register(this.saturationBox.onColorFlushed(this.flushColor, this));
    this.opacityStrip = new OpacityStrip(this.domNode, this.model);
    this._register(this.opacityStrip);
    this._register(this.opacityStrip.onDidChange(this.onDidOpacityChange, this));
    this._register(this.opacityStrip.onColorFlushed(this.flushColor, this));
    this.hueStrip = new HueStrip(this.domNode, this.model);
    this._register(this.hueStrip);
    this._register(this.hueStrip.onDidChange(this.onDidHueChange, this));
    this._register(this.hueStrip.onColorFlushed(this.flushColor, this));
  }
  flushColor() {
    this.model.flushColor();
  }
  onDidSaturationValueChange({s, v}) {
    const hsva = this.model.color.hsva;
    this.model.color = new Color(new HSVA(hsva.h, s, v, hsva.a));
  }
  onDidOpacityChange(a) {
    const hsva = this.model.color.hsva;
    this.model.color = new Color(new HSVA(hsva.h, hsva.s, hsva.v, a));
  }
  onDidHueChange(value) {
    const hsva = this.model.color.hsva;
    const h = (1 - value) * 360;
    this.model.color = new Color(new HSVA(h === 360 ? 0 : h, hsva.s, hsva.v, hsva.a));
  }
  layout() {
    this.saturationBox.layout();
    this.opacityStrip.layout();
    this.hueStrip.layout();
  }
};
var SaturationBox = class extends Disposable {
  constructor(container, model, pixelRatio) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._onDidChange = new Emitter2();
    this.onDidChange = this._onDidChange.event;
    this._onColorFlushed = new Emitter2();
    this.onColorFlushed = this._onColorFlushed.event;
    this.domNode = $2(".saturation-wrap");
    append(container, this.domNode);
    this.canvas = document.createElement("canvas");
    this.canvas.className = "saturation-box";
    append(this.domNode, this.canvas);
    this.selection = $2(".saturation-selection");
    append(this.domNode, this.selection);
    this.layout();
    this._register(addDisposableGenericMouseDownListner(this.domNode, (e) => this.onMouseDown(e)));
    this._register(this.model.onDidChangeColor(this.onDidChangeColor, this));
    this.monitor = null;
  }
  onMouseDown(e) {
    this.monitor = this._register(new GlobalMouseMoveMonitor());
    const origin = getDomNodePagePosition(this.domNode);
    if (e.target !== this.selection) {
      this.onDidChangePosition(e.offsetX, e.offsetY);
    }
    this.monitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, (event) => this.onDidChangePosition(event.posx - origin.left, event.posy - origin.top), () => null);
    const mouseUpListener = addDisposableGenericMouseUpListner(document, () => {
      this._onColorFlushed.fire();
      mouseUpListener.dispose();
      if (this.monitor) {
        this.monitor.stopMonitoring(true);
        this.monitor = null;
      }
    }, true);
  }
  onDidChangePosition(left, top) {
    const s = Math.max(0, Math.min(1, left / this.width));
    const v = Math.max(0, Math.min(1, 1 - top / this.height));
    this.paintSelection(s, v);
    this._onDidChange.fire({s, v});
  }
  layout() {
    this.width = this.domNode.offsetWidth;
    this.height = this.domNode.offsetHeight;
    this.canvas.width = this.width * this.pixelRatio;
    this.canvas.height = this.height * this.pixelRatio;
    this.paint();
    const hsva = this.model.color.hsva;
    this.paintSelection(hsva.s, hsva.v);
  }
  paint() {
    const hsva = this.model.color.hsva;
    const saturatedColor = new Color(new HSVA(hsva.h, 1, 1, 1));
    const ctx = this.canvas.getContext("2d");
    const whiteGradient = ctx.createLinearGradient(0, 0, this.canvas.width, 0);
    whiteGradient.addColorStop(0, "rgba(255, 255, 255, 1)");
    whiteGradient.addColorStop(0.5, "rgba(255, 255, 255, 0.5)");
    whiteGradient.addColorStop(1, "rgba(255, 255, 255, 0)");
    const blackGradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
    blackGradient.addColorStop(0, "rgba(0, 0, 0, 0)");
    blackGradient.addColorStop(1, "rgba(0, 0, 0, 1)");
    ctx.rect(0, 0, this.canvas.width, this.canvas.height);
    ctx.fillStyle = Color.Format.CSS.format(saturatedColor);
    ctx.fill();
    ctx.fillStyle = whiteGradient;
    ctx.fill();
    ctx.fillStyle = blackGradient;
    ctx.fill();
  }
  paintSelection(s, v) {
    this.selection.style.left = `${s * this.width}px`;
    this.selection.style.top = `${this.height - v * this.height}px`;
  }
  onDidChangeColor() {
    if (this.monitor && this.monitor.isMonitoring()) {
      return;
    }
    this.paint();
  }
};
var Strip = class extends Disposable {
  constructor(container, model) {
    super();
    this.model = model;
    this._onDidChange = new Emitter2();
    this.onDidChange = this._onDidChange.event;
    this._onColorFlushed = new Emitter2();
    this.onColorFlushed = this._onColorFlushed.event;
    this.domNode = append(container, $2(".strip"));
    this.overlay = append(this.domNode, $2(".overlay"));
    this.slider = append(this.domNode, $2(".slider"));
    this.slider.style.top = `0px`;
    this._register(addDisposableGenericMouseDownListner(this.domNode, (e) => this.onMouseDown(e)));
    this.layout();
  }
  layout() {
    this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
    const value = this.getValue(this.model.color);
    this.updateSliderPosition(value);
  }
  onMouseDown(e) {
    const monitor = this._register(new GlobalMouseMoveMonitor());
    const origin = getDomNodePagePosition(this.domNode);
    addClass(this.domNode, "grabbing");
    if (e.target !== this.slider) {
      this.onDidChangeTop(e.offsetY);
    }
    monitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, (event) => this.onDidChangeTop(event.posy - origin.top), () => null);
    const mouseUpListener = addDisposableGenericMouseUpListner(document, () => {
      this._onColorFlushed.fire();
      mouseUpListener.dispose();
      monitor.stopMonitoring(true);
      removeClass(this.domNode, "grabbing");
    }, true);
  }
  onDidChangeTop(top) {
    const value = Math.max(0, Math.min(1, 1 - top / this.height));
    this.updateSliderPosition(value);
    this._onDidChange.fire(value);
  }
  updateSliderPosition(value) {
    this.slider.style.top = `${(1 - value) * this.height}px`;
  }
};
var OpacityStrip = class extends Strip {
  constructor(container, model) {
    super(container, model);
    addClass(this.domNode, "opacity-strip");
    this._register(model.onDidChangeColor(this.onDidChangeColor, this));
    this.onDidChangeColor(this.model.color);
  }
  onDidChangeColor(color) {
    const {r, g, b} = color.rgba;
    const opaque = new Color(new RGBA(r, g, b, 1));
    const transparent2 = new Color(new RGBA(r, g, b, 0));
    this.overlay.style.background = `linear-gradient(to bottom, ${opaque} 0%, ${transparent2} 100%)`;
  }
  getValue(color) {
    return color.hsva.a;
  }
};
var HueStrip = class extends Strip {
  constructor(container, model) {
    super(container, model);
    addClass(this.domNode, "hue-strip");
  }
  getValue(color) {
    return 1 - color.hsva.h / 360;
  }
};
var ColorPickerWidget = class extends Widget {
  constructor(container, model, pixelRatio, themeService) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._register(onDidChangeZoomLevel(() => this.layout()));
    const element = $2(".colorpicker-widget");
    container.appendChild(element);
    const header = new ColorPickerHeader(element, this.model, themeService);
    this.body = new ColorPickerBody(element, this.model, this.pixelRatio);
    this._register(header);
    this._register(this.body);
  }
  layout() {
    this.body.layout();
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/getHover.js
function getHover(model, position, token) {
  const supports = HoverProviderRegistry.ordered(model);
  const promises = supports.map((support) => {
    return Promise.resolve(support.provideHover(model, position, token)).then((hover) => {
      return hover && isValid(hover) ? hover : void 0;
    }, (err) => {
      onUnexpectedExternalError(err);
      return void 0;
    });
  });
  return Promise.all(promises).then(coalesce);
}
registerModelAndPositionCommand("_executeHoverProvider", (model, position) => getHover(model, position, CancellationToken.None));
function isValid(result) {
  const hasRange = typeof result.range !== "undefined";
  const hasHtmlContent = typeof result.contents !== "undefined" && result.contents && result.contents.length > 0;
  return hasRange && hasHtmlContent;
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/hoverOperation.js
var HoverOperation = class {
  constructor(computer, success, error, progress, hoverTime) {
    this._computer = computer;
    this._state = 0;
    this._hoverTime = hoverTime;
    this._firstWaitScheduler = new RunOnceScheduler(() => this._triggerAsyncComputation(), 0);
    this._secondWaitScheduler = new RunOnceScheduler(() => this._triggerSyncComputation(), 0);
    this._loadingMessageScheduler = new RunOnceScheduler(() => this._showLoadingMessage(), 0);
    this._asyncComputationPromise = null;
    this._asyncComputationPromiseDone = false;
    this._completeCallback = success;
    this._errorCallback = error;
    this._progressCallback = progress;
  }
  setHoverTime(hoverTime) {
    this._hoverTime = hoverTime;
  }
  _firstWaitTime() {
    return this._hoverTime / 2;
  }
  _secondWaitTime() {
    return this._hoverTime / 2;
  }
  _loadingMessageTime() {
    return 3 * this._hoverTime;
  }
  _triggerAsyncComputation() {
    this._state = 2;
    this._secondWaitScheduler.schedule(this._secondWaitTime());
    if (this._computer.computeAsync) {
      this._asyncComputationPromiseDone = false;
      this._asyncComputationPromise = createCancelablePromise((token) => this._computer.computeAsync(token));
      this._asyncComputationPromise.then((asyncResult) => {
        this._asyncComputationPromiseDone = true;
        this._withAsyncResult(asyncResult);
      }, (e) => this._onError(e));
    } else {
      this._asyncComputationPromiseDone = true;
    }
  }
  _triggerSyncComputation() {
    if (this._computer.computeSync) {
      this._computer.onResult(this._computer.computeSync(), true);
    }
    if (this._asyncComputationPromiseDone) {
      this._state = 0;
      this._onComplete(this._computer.getResult());
    } else {
      this._state = 3;
      this._onProgress(this._computer.getResult());
    }
  }
  _showLoadingMessage() {
    if (this._state === 3) {
      this._onProgress(this._computer.getResultWithLoadingMessage());
    }
  }
  _withAsyncResult(asyncResult) {
    if (asyncResult) {
      this._computer.onResult(asyncResult, false);
    }
    if (this._state === 3) {
      this._state = 0;
      this._onComplete(this._computer.getResult());
    }
  }
  _onComplete(value) {
    this._completeCallback(value);
  }
  _onError(error) {
    if (this._errorCallback) {
      this._errorCallback(error);
    } else {
      onUnexpectedError(error);
    }
  }
  _onProgress(value) {
    this._progressCallback(value);
  }
  start(mode) {
    if (mode === 0) {
      if (this._state === 0) {
        this._state = 1;
        this._firstWaitScheduler.schedule(this._firstWaitTime());
        this._loadingMessageScheduler.schedule(this._loadingMessageTime());
      }
    } else {
      switch (this._state) {
        case 0:
          this._triggerAsyncComputation();
          this._secondWaitScheduler.cancel();
          this._triggerSyncComputation();
          break;
        case 2:
          this._secondWaitScheduler.cancel();
          this._triggerSyncComputation();
          break;
      }
    }
  }
  cancel() {
    this._loadingMessageScheduler.cancel();
    if (this._state === 1) {
      this._firstWaitScheduler.cancel();
    }
    if (this._state === 2) {
      this._secondWaitScheduler.cancel();
      if (this._asyncComputationPromise) {
        this._asyncComputationPromise.cancel();
        this._asyncComputationPromise = null;
      }
    }
    if (this._state === 3) {
      if (this._asyncComputationPromise) {
        this._asyncComputationPromise.cancel();
        this._asyncComputationPromise = null;
      }
    }
    this._state = 0;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hoverWidget.js
var $3 = $;
var HoverWidget = class extends Disposable {
  constructor() {
    super();
    this.containerDomNode = document.createElement("div");
    this.containerDomNode.className = "monaco-hover";
    this.containerDomNode.tabIndex = 0;
    this.containerDomNode.setAttribute("role", "tooltip");
    this.contentsDomNode = document.createElement("div");
    this.contentsDomNode.className = "monaco-hover-content";
    this._scrollbar = this._register(new DomScrollableElement(this.contentsDomNode, {}));
    this.containerDomNode.appendChild(this._scrollbar.getDomNode());
  }
  onContentsChanged() {
    this._scrollbar.scanDomNode();
  }
};
function renderHoverAction(parent2, actionOptions, keybindingLabel) {
  const actionContainer = append(parent2, $3("div.action-container"));
  const action = append(actionContainer, $3("a.action"));
  action.setAttribute("href", "#");
  action.setAttribute("role", "button");
  if (actionOptions.iconClass) {
    append(action, $3(`span.icon.${actionOptions.iconClass}`));
  }
  const label = append(action, $3("span"));
  label.textContent = keybindingLabel ? `${actionOptions.label} (${keybindingLabel})` : actionOptions.label;
  return addDisposableListener(actionContainer, EventType2.CLICK, (e) => {
    e.stopPropagation();
    e.preventDefault();
    actionOptions.run(actionContainer);
  });
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/hoverWidgets.js
var ContentHoverWidget = class extends Widget {
  constructor(id, editor3, _hoverVisibleKey, _keybindingService) {
    super();
    this._hoverVisibleKey = _hoverVisibleKey;
    this._keybindingService = _keybindingService;
    this.allowEditorOverflow = true;
    this._hover = this._register(new HoverWidget());
    this._id = id;
    this._editor = editor3;
    this._isVisible = false;
    this._stoleFocus = false;
    this.onkeydown(this._hover.containerDomNode, (e) => {
      if (e.equals(9)) {
        this.hide();
      }
    });
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(36)) {
        this.updateFont();
      }
    }));
    this._editor.onDidLayoutChange((e) => this.layout());
    this.layout();
    this._editor.addContentWidget(this);
    this._showAtPosition = null;
    this._showAtRange = null;
    this._stoleFocus = false;
  }
  get isVisible() {
    return this._isVisible;
  }
  set isVisible(value) {
    this._isVisible = value;
    toggleClass(this._hover.containerDomNode, "hidden", !this._isVisible);
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._hover.containerDomNode;
  }
  showAt(position, range2, focus) {
    this._showAtPosition = position;
    this._showAtRange = range2;
    this._hoverVisibleKey.set(true);
    this.isVisible = true;
    this._editor.layoutContentWidget(this);
    this._editor.render();
    this._stoleFocus = focus;
    if (focus) {
      this._hover.containerDomNode.focus();
    }
  }
  hide() {
    if (!this.isVisible) {
      return;
    }
    setTimeout(() => {
      if (!this.isVisible) {
        this._hoverVisibleKey.set(false);
      }
    }, 0);
    this.isVisible = false;
    this._editor.layoutContentWidget(this);
    if (this._stoleFocus) {
      this._editor.focus();
    }
  }
  getPosition() {
    if (this.isVisible) {
      return {
        position: this._showAtPosition,
        range: this._showAtRange,
        preference: [
          1,
          2
        ]
      };
    }
    return null;
  }
  dispose() {
    this._editor.removeContentWidget(this);
    super.dispose();
  }
  updateFont() {
    const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code"));
    codeClasses.forEach((node) => this._editor.applyFontInfo(node));
  }
  updateContents(node) {
    this._hover.contentsDomNode.textContent = "";
    this._hover.contentsDomNode.appendChild(node);
    this.updateFont();
    this._editor.layoutContentWidget(this);
    this._hover.onContentsChanged();
  }
  _renderAction(parent2, actionOptions) {
    const keybinding = this._keybindingService.lookupKeybinding(actionOptions.commandId);
    const keybindingLabel = keybinding ? keybinding.getLabel() : null;
    return renderHoverAction(parent2, actionOptions, keybindingLabel);
  }
  layout() {
    const height = Math.max(this._editor.getLayoutInfo().height / 4, 250);
    const {fontSize, lineHeight} = this._editor.getOption(36);
    this._hover.contentsDomNode.style.fontSize = `${fontSize}px`;
    this._hover.contentsDomNode.style.lineHeight = `${lineHeight}px`;
    this._hover.contentsDomNode.style.maxHeight = `${height}px`;
    this._hover.contentsDomNode.style.maxWidth = `${Math.max(this._editor.getLayoutInfo().width * 0.66, 500)}px`;
  }
};
var GlyphHoverWidget = class extends Widget {
  constructor(id, editor3) {
    super();
    this._id = id;
    this._editor = editor3;
    this._isVisible = false;
    this._domNode = document.createElement("div");
    this._domNode.className = "monaco-hover hidden";
    this._domNode.setAttribute("aria-hidden", "true");
    this._domNode.setAttribute("role", "tooltip");
    this._showAtLineNumber = -1;
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(36)) {
        this.updateFont();
      }
    }));
    this._editor.addOverlayWidget(this);
  }
  get isVisible() {
    return this._isVisible;
  }
  set isVisible(value) {
    this._isVisible = value;
    toggleClass(this._domNode, "hidden", !this._isVisible);
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  showAt(lineNumber) {
    this._showAtLineNumber = lineNumber;
    if (!this.isVisible) {
      this.isVisible = true;
    }
    const editorLayout = this._editor.getLayoutInfo();
    const topForLineNumber = this._editor.getTopForLineNumber(this._showAtLineNumber);
    const editorScrollTop = this._editor.getScrollTop();
    const lineHeight = this._editor.getOption(51);
    const nodeHeight = this._domNode.clientHeight;
    const top = topForLineNumber - editorScrollTop - (nodeHeight - lineHeight) / 2;
    this._domNode.style.left = `${editorLayout.glyphMarginLeft + editorLayout.glyphMarginWidth}px`;
    this._domNode.style.top = `${Math.max(Math.round(top), 0)}px`;
  }
  hide() {
    if (!this.isVisible) {
      return;
    }
    this.isVisible = false;
  }
  getPosition() {
    return null;
  }
  dispose() {
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  updateFont() {
    const codeTags = Array.prototype.slice.call(this._domNode.getElementsByTagName("code"));
    const codeClasses = Array.prototype.slice.call(this._domNode.getElementsByClassName("code"));
    [...codeTags, ...codeClasses].forEach((node) => this._editor.applyFontInfo(node));
  }
  updateContents(node) {
    this._domNode.textContent = "";
    this._domNode.appendChild(node);
    this.updateFont();
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js
var marked = __toModule(require_marked());

// ../../node_modules/monaco-editor/esm/vs/base/common/insane/insane.js
var __insane_func;
(function() {
  function r(e, n, t) {
    function o(i2, f) {
      if (!n[i2]) {
        if (!e[i2]) {
          var c = false;
          if (!f && c)
            return c(i2, true);
          if (u)
            return u(i2, true);
          var a = new Error("Cannot find module '" + i2 + "'");
          throw a.code = "MODULE_NOT_FOUND", a;
        }
        var p = n[i2] = {exports: {}};
        e[i2][0].call(p.exports, function(r2) {
          var n2 = e[i2][1][r2];
          return o(n2 || r2);
        }, p, p.exports, r, e, n, t);
      }
      return n[i2].exports;
    }
    for (var u = false, i = 0; i < t.length; i++)
      o(t[i]);
    return o;
  }
  return r;
})()({
  1: [function(require2, module, exports) {
    "use strict";
    var toMap = require2("./toMap");
    var uris = ["background", "base", "cite", "href", "longdesc", "src", "usemap"];
    module.exports = {
      uris: toMap(uris)
    };
  }, {"./toMap": 10}],
  2: [function(require2, module, exports) {
    "use strict";
    var defaults = {
      allowedAttributes: {
        "*": ["title", "accesskey"],
        a: ["href", "name", "target", "aria-label"],
        iframe: ["allowfullscreen", "frameborder", "src"],
        img: ["src", "alt", "title", "aria-label"]
      },
      allowedClasses: {},
      allowedSchemes: ["http", "https", "mailto"],
      allowedTags: [
        "a",
        "abbr",
        "article",
        "b",
        "blockquote",
        "br",
        "caption",
        "code",
        "del",
        "details",
        "div",
        "em",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hr",
        "i",
        "img",
        "ins",
        "kbd",
        "li",
        "main",
        "mark",
        "ol",
        "p",
        "pre",
        "section",
        "span",
        "strike",
        "strong",
        "sub",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "th",
        "thead",
        "tr",
        "u",
        "ul"
      ],
      filter: null
    };
    module.exports = defaults;
  }, {}],
  3: [function(require2, module, exports) {
    "use strict";
    var toMap = require2("./toMap");
    var voids = ["area", "br", "col", "hr", "img", "wbr", "input", "base", "basefont", "link", "meta"];
    module.exports = {
      voids: toMap(voids)
    };
  }, {"./toMap": 10}],
  4: [function(require2, module, exports) {
    "use strict";
    var he = require2("he");
    var assign = require2("assignment");
    var parser = require2("./parser");
    var sanitizer = require2("./sanitizer");
    var defaults = require2("./defaults");
    function insane2(html2, options, strict) {
      var buffer2 = [];
      var configuration = strict === true ? options : assign({}, defaults, options);
      var handler = sanitizer(buffer2, configuration);
      parser(html2, handler);
      return buffer2.join("");
    }
    insane2.defaults = defaults;
    module.exports = insane2;
    __insane_func = insane2;
  }, {"./defaults": 2, "./parser": 7, "./sanitizer": 8, assignment: 6, he: 9}],
  5: [function(require2, module, exports) {
    "use strict";
    module.exports = function lowercase(string5) {
      return typeof string5 === "string" ? string5.toLowerCase() : string5;
    };
  }, {}],
  6: [function(require2, module, exports) {
    "use strict";
    function assignment(result) {
      var stack = Array.prototype.slice.call(arguments, 1);
      var item;
      var key;
      while (stack.length) {
        item = stack.shift();
        for (key in item) {
          if (item.hasOwnProperty(key)) {
            if (Object.prototype.toString.call(result[key]) === "[object Object]") {
              result[key] = assignment(result[key], item[key]);
            } else {
              result[key] = item[key];
            }
          }
        }
      }
      return result;
    }
    module.exports = assignment;
  }, {}],
  7: [function(require2, module, exports) {
    "use strict";
    var he = require2("he");
    var lowercase = require2("./lowercase");
    var attributes = require2("./attributes");
    var elements = require2("./elements");
    var rstart = /^<\s*([\w:-]+)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*>/;
    var rend = /^<\s*\/\s*([\w:-]+)[^>]*>/;
    var rattrs = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g;
    var rtag = /^</;
    var rtagend = /^<\s*\//;
    function createStack() {
      var stack = [];
      stack.lastItem = function lastItem() {
        return stack[stack.length - 1];
      };
      return stack;
    }
    function parser(html2, handler) {
      var stack = createStack();
      var last = html2;
      var chars;
      while (html2) {
        parsePart();
      }
      parseEndTag();
      function parsePart() {
        chars = true;
        parseTag();
        var same = html2 === last;
        last = html2;
        if (same) {
          html2 = "";
        }
      }
      function parseTag() {
        if (html2.substr(0, 4) === "<!--") {
          parseComment();
        } else if (rtagend.test(html2)) {
          parseEdge(rend, parseEndTag);
        } else if (rtag.test(html2)) {
          parseEdge(rstart, parseStartTag);
        }
        parseTagDecode();
      }
      function parseEdge(regex, parser2) {
        var match = html2.match(regex);
        if (match) {
          html2 = html2.substring(match[0].length);
          match[0].replace(regex, parser2);
          chars = false;
        }
      }
      function parseComment() {
        var index2 = html2.indexOf("-->");
        if (index2 >= 0) {
          if (handler.comment) {
            handler.comment(html2.substring(4, index2));
          }
          html2 = html2.substring(index2 + 3);
          chars = false;
        }
      }
      function parseTagDecode() {
        if (!chars) {
          return;
        }
        var text;
        var index2 = html2.indexOf("<");
        if (index2 >= 0) {
          text = html2.substring(0, index2);
          html2 = html2.substring(index2);
        } else {
          text = html2;
          html2 = "";
        }
        if (handler.chars) {
          handler.chars(text);
        }
      }
      function parseStartTag(tag, tagName, rest, unary) {
        var attrs = {};
        var low = lowercase(tagName);
        var u = elements.voids[low] || !!unary;
        rest.replace(rattrs, attrReplacer);
        if (!u) {
          stack.push(low);
        }
        if (handler.start) {
          handler.start(low, attrs, u);
        }
        function attrReplacer(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
          if (doubleQuotedValue === void 0 && singleQuotedValue === void 0 && unquotedValue === void 0) {
            attrs[name] = void 0;
          } else {
            attrs[name] = he.decode(doubleQuotedValue || singleQuotedValue || unquotedValue || "");
          }
        }
      }
      function parseEndTag(tag, tagName) {
        var i;
        var pos = 0;
        var low = lowercase(tagName);
        if (low) {
          for (pos = stack.length - 1; pos >= 0; pos--) {
            if (stack[pos] === low) {
              break;
            }
          }
        }
        if (pos >= 0) {
          for (i = stack.length - 1; i >= pos; i--) {
            if (handler.end) {
              handler.end(stack[i]);
            }
          }
          stack.length = pos;
        }
      }
    }
    module.exports = parser;
  }, {"./attributes": 1, "./elements": 3, "./lowercase": 5, he: 9}],
  8: [function(require2, module, exports) {
    "use strict";
    var he = require2("he");
    var lowercase = require2("./lowercase");
    var attributes = require2("./attributes");
    var elements = require2("./elements");
    function sanitizer(buffer2, options) {
      var last;
      var context2;
      var o = options || {};
      reset2();
      return {
        start,
        end,
        chars
      };
      function out(value) {
        buffer2.push(value);
      }
      function start(tag, attrs, unary) {
        var low = lowercase(tag);
        if (context2.ignoring) {
          ignore(low);
          return;
        }
        if ((o.allowedTags || []).indexOf(low) === -1) {
          ignore(low);
          return;
        }
        if (o.filter && !o.filter({tag: low, attrs})) {
          ignore(low);
          return;
        }
        out("<");
        out(low);
        Object.keys(attrs).forEach(parse4);
        out(unary ? "/>" : ">");
        function parse4(key) {
          var value = attrs[key];
          var classesOk = (o.allowedClasses || {})[low] || [];
          var attrsOk = (o.allowedAttributes || {})[low] || [];
          attrsOk = attrsOk.concat((o.allowedAttributes || {})["*"] || []);
          var valid;
          var lkey = lowercase(key);
          if (lkey === "class" && attrsOk.indexOf(lkey) === -1) {
            value = value.split(" ").filter(isValidClass).join(" ").trim();
            valid = value.length;
          } else {
            valid = attrsOk.indexOf(lkey) !== -1 && (attributes.uris[lkey] !== true || testUrl(value));
          }
          if (valid) {
            out(" ");
            out(key);
            if (typeof value === "string") {
              out('="');
              out(he.encode(value));
              out('"');
            }
          }
          function isValidClass(className) {
            return classesOk && classesOk.indexOf(className) !== -1;
          }
        }
      }
      function end(tag) {
        var low = lowercase(tag);
        var allowed = (o.allowedTags || []).indexOf(low) !== -1;
        if (allowed) {
          if (context2.ignoring === false) {
            out("</");
            out(low);
            out(">");
          } else {
            unignore(low);
          }
        } else {
          unignore(low);
        }
      }
      function testUrl(text) {
        var start2 = text[0];
        if (start2 === "#" || start2 === "/") {
          return true;
        }
        var colon = text.indexOf(":");
        if (colon === -1) {
          return true;
        }
        var questionmark = text.indexOf("?");
        if (questionmark !== -1 && colon > questionmark) {
          return true;
        }
        var hash2 = text.indexOf("#");
        if (hash2 !== -1 && colon > hash2) {
          return true;
        }
        return o.allowedSchemes.some(matches);
        function matches(scheme) {
          return text.indexOf(scheme + ":") === 0;
        }
      }
      function chars(text) {
        if (context2.ignoring === false) {
          out(o.transformText ? o.transformText(text) : text);
        }
      }
      function ignore(tag) {
        if (elements.voids[tag]) {
          return;
        }
        if (context2.ignoring === false) {
          context2 = {ignoring: tag, depth: 1};
        } else if (context2.ignoring === tag) {
          context2.depth++;
        }
      }
      function unignore(tag) {
        if (context2.ignoring === tag) {
          if (--context2.depth <= 0) {
            reset2();
          }
        }
      }
      function reset2() {
        context2 = {ignoring: false, depth: 0};
      }
    }
    module.exports = sanitizer;
  }, {"./attributes": 1, "./elements": 3, "./lowercase": 5, he: 9}],
  9: [function(require2, module, exports) {
    "use strict";
    var escapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var unescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var rescaped = /(&amp;|&lt;|&gt;|&quot;|&#39;)/g;
    var runescaped = /[&<>"']/g;
    function escapeHtmlChar(match) {
      return escapes[match];
    }
    function unescapeHtmlChar(match) {
      return unescapes[match];
    }
    function escapeHtml(text) {
      return text == null ? "" : String(text).replace(runescaped, escapeHtmlChar);
    }
    function unescapeHtml(html2) {
      return html2 == null ? "" : String(html2).replace(rescaped, unescapeHtmlChar);
    }
    escapeHtml.options = unescapeHtml.options = {};
    module.exports = {
      encode: escapeHtml,
      escape: escapeHtml,
      decode: unescapeHtml,
      unescape: unescapeHtml,
      version: "1.0.0-browser"
    };
  }, {}],
  10: [function(require2, module, exports) {
    "use strict";
    function toMap(list) {
      return list.reduce(asKey, {});
    }
    function asKey(accumulator, item) {
      accumulator[item] = true;
      return accumulator;
    }
    module.exports = toMap;
  }, {}]
}, {}, [4]);
var insane = __insane_func;

// ../../node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js
function renderMarkdown(markdown, options = {}, markedOptions = {}) {
  var _a5;
  const element = createElement(options);
  const _uriMassage = function(part) {
    let data;
    try {
      data = parse(decodeURIComponent(part));
    } catch (e) {
    }
    if (!data) {
      return part;
    }
    data = cloneAndChange(data, (value2) => {
      if (markdown.uris && markdown.uris[value2]) {
        return URI.revive(markdown.uris[value2]);
      } else {
        return void 0;
      }
    });
    return encodeURIComponent(JSON.stringify(data));
  };
  const _href = function(href, isDomUri) {
    const data = markdown.uris && markdown.uris[href];
    if (!data) {
      return href;
    }
    let uri = URI.revive(data);
    if (URI.parse(href).toString() === uri.toString()) {
      return href;
    }
    if (isDomUri) {
      return asDomUri(uri).toString(true);
    }
    if (uri.query) {
      uri = uri.with({query: _uriMassage(uri.query)});
    }
    return uri.toString();
  };
  let signalInnerHTML;
  const withInnerHTML = new Promise((c) => signalInnerHTML = c);
  const renderer = new marked.Renderer();
  renderer.image = (href, title, text) => {
    let dimensions = [];
    let attributes = [];
    if (href) {
      ({href, dimensions} = parseHrefAndDimensions(href));
      href = _href(href, true);
      try {
        const hrefAsUri = URI.parse(href);
        if (options.baseUrl && hrefAsUri.scheme === Schemas.file) {
          href = resolvePath(options.baseUrl, href).toString();
        }
      } catch (err) {
      }
      attributes.push(`src="${href}"`);
    }
    if (text) {
      attributes.push(`alt="${text}"`);
    }
    if (title) {
      attributes.push(`title="${title}"`);
    }
    if (dimensions.length) {
      attributes = attributes.concat(dimensions);
    }
    return "<img " + attributes.join(" ") + ">";
  };
  renderer.link = (href, title, text) => {
    if (href === text) {
      text = removeMarkdownEscapes(text);
    }
    href = _href(href, false);
    if (options.baseUrl) {
      const hasScheme = /^\w[\w\d+.-]*:/.test(href);
      if (!hasScheme) {
        href = resolvePath(options.baseUrl, href).toString();
      }
    }
    title = removeMarkdownEscapes(title);
    href = removeMarkdownEscapes(href);
    if (!href || href.match(/^data:|javascript:/i) || href.match(/^command:/i) && !markdown.isTrusted || href.match(/^command:(\/\/\/)?_workbench\.downloadResource/i)) {
      return text;
    } else {
      href = href.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      return `<a href="#" data-href="${href}" title="${title || href}">${text}</a>`;
    }
  };
  renderer.paragraph = (text) => {
    return `<p>${markdown.supportThemeIcons ? renderCodicons(text) : text}</p>`;
  };
  if (options.codeBlockRenderer) {
    renderer.code = (code3, lang) => {
      const value2 = options.codeBlockRenderer(lang, code3);
      const id = defaultGenerator.nextId();
      const promise3 = Promise.all([value2, withInnerHTML]).then((values) => {
        const strValue = values[0];
        const span = element.querySelector(`div[data-code="${id}"]`);
        if (span) {
          span.innerHTML = strValue;
        }
      }).catch((err) => {
      });
      if (options.codeBlockRenderCallback) {
        promise3.then(options.codeBlockRenderCallback);
      }
      return `<div class="code" data-code="${id}">${escape(code3)}</div>`;
    };
  }
  const actionHandler = options.actionHandler;
  if (actionHandler) {
    [EventType2.CLICK, EventType2.AUXCLICK].forEach((event) => {
      actionHandler.disposeables.add(addDisposableListener(element, event, (e) => {
        const mouseEvent = new StandardMouseEvent(e);
        if (!mouseEvent.leftButton && !mouseEvent.middleButton) {
          return;
        }
        let target = mouseEvent.target;
        if (target.tagName !== "A") {
          target = target.parentElement;
          if (!target || target.tagName !== "A") {
            return;
          }
        }
        try {
          const href = target.dataset["href"];
          if (href) {
            actionHandler.callback(href, mouseEvent);
          }
        } catch (err) {
          onUnexpectedError(err);
        } finally {
          mouseEvent.preventDefault();
        }
      }));
    });
  }
  markedOptions.sanitizer = (html2) => {
    const match = markdown.isTrusted ? html2.match(/^(<span[^<]+>)|(<\/\s*span>)$/) : void 0;
    return match ? html2 : "";
  };
  markedOptions.sanitize = true;
  markedOptions.renderer = renderer;
  const allowedSchemes = [Schemas.http, Schemas.https, Schemas.mailto, Schemas.data, Schemas.file, Schemas.vscodeRemote, Schemas.vscodeRemoteResource];
  if (markdown.isTrusted) {
    allowedSchemes.push(Schemas.command);
  }
  let value = (_a5 = markdown.value) !== null && _a5 !== void 0 ? _a5 : "";
  if (value.length > 1e5) {
    value = `${value.substr(0, 1e5)}\u2026`;
  }
  const renderedMarkdown = marked.parse(markdown.supportThemeIcons ? markdownEscapeEscapedCodicons(value) : value, markedOptions);
  function filter2(token) {
    if (token.tag === "span" && markdown.isTrusted && Object.keys(token.attrs).length === 1) {
      if (token.attrs["style"]) {
        return !!token.attrs["style"].match(/^(color\:#[0-9a-fA-F]+;)?(background-color\:#[0-9a-fA-F]+;)?$/);
      } else if (token.attrs["class"]) {
        return !!token.attrs["class"].match(/^codicon codicon-[a-z\-]+( codicon-animation-[a-z\-]+)?$/);
      }
      return false;
    }
    return true;
  }
  element.innerHTML = insane(renderedMarkdown, {
    allowedSchemes,
    allowedTags: ["ul", "li", "p", "code", "blockquote", "ol", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "em", "pre", "table", "thead", "tbody", "tr", "th", "td", "div", "del", "a", "strong", "br", "img", "span"],
    allowedAttributes: {
      a: ["href", "name", "target", "data-href"],
      img: ["src", "title", "alt", "width", "height"],
      div: ["class", "data-code"],
      span: ["class", "style"],
      th: ["align"],
      td: ["align"]
    },
    filter: filter2
  });
  signalInnerHTML();
  return element;
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/markdown/markdownRenderer.js
var __decorate26 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param26 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MarkdownRenderer = class MarkdownRenderer2 extends Disposable {
  constructor(_editor, _modeService, _openerService = NullOpenerService) {
    super();
    this._editor = _editor;
    this._modeService = _modeService;
    this._openerService = _openerService;
    this._onDidRenderCodeBlock = this._register(new Emitter2());
    this.onDidRenderCodeBlock = this._onDidRenderCodeBlock.event;
  }
  getOptions(disposeables) {
    return {
      codeBlockRenderer: (languageAlias, value) => {
        let modeId = null;
        if (languageAlias) {
          modeId = this._modeService.getModeIdForLanguageName(languageAlias);
        } else {
          const model = this._editor.getModel();
          if (model) {
            modeId = model.getLanguageIdentifier().language;
          }
        }
        this._modeService.triggerMode(modeId || "");
        return Promise.resolve(true).then((_) => {
          const promise3 = TokenizationRegistry.getPromise(modeId || "");
          if (promise3) {
            return promise3.then((support) => tokenizeToString(value, support));
          }
          return tokenizeToString(value, void 0);
        }).then((code3) => {
          return `<span style="font-family: ${this._editor.getOption(36).fontFamily}">${code3}</span>`;
        });
      },
      codeBlockRenderCallback: () => this._onDidRenderCodeBlock.fire(),
      actionHandler: {
        callback: (content) => {
          this._openerService.open(content, {fromUserGesture: true}).catch(onUnexpectedError);
        },
        disposeables
      }
    };
  }
  render(markdown) {
    const disposeables = new DisposableStore();
    let element;
    if (!markdown) {
      element = document.createElement("span");
    } else {
      element = renderMarkdown(markdown, this.getOptions(disposeables));
    }
    return {
      element,
      dispose: () => disposeables.dispose()
    };
  }
};
MarkdownRenderer = __decorate26([
  __param26(1, IModeService),
  __param26(2, optional(IOpenerService))
], MarkdownRenderer);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/modesContentHover.js
var $4 = $;
var ColorHover = class {
  constructor(range2, color, provider) {
    this.range = range2;
    this.color = color;
    this.provider = provider;
  }
};
var MarkerHover = class {
  constructor(range2, marker) {
    this.range = range2;
    this.marker = marker;
  }
};
var ModesContentComputer = class {
  constructor(editor3, _markerDecorationsService) {
    this._markerDecorationsService = _markerDecorationsService;
    this._editor = editor3;
    this._result = [];
  }
  setRange(range2) {
    this._range = range2;
    this._result = [];
  }
  clearResult() {
    this._result = [];
  }
  computeAsync(token) {
    if (!this._editor.hasModel() || !this._range) {
      return Promise.resolve([]);
    }
    const model = this._editor.getModel();
    if (!HoverProviderRegistry.has(model)) {
      return Promise.resolve([]);
    }
    return getHover(model, new Position(this._range.startLineNumber, this._range.startColumn), token);
  }
  computeSync() {
    if (!this._editor.hasModel() || !this._range) {
      return [];
    }
    const model = this._editor.getModel();
    const lineNumber = this._range.startLineNumber;
    if (lineNumber > this._editor.getModel().getLineCount()) {
      return [];
    }
    const colorDetector = ColorDetector.get(this._editor);
    const maxColumn = model.getLineMaxColumn(lineNumber);
    const lineDecorations = this._editor.getLineDecorations(lineNumber);
    let didFindColor = false;
    const hoverRange = this._range;
    const result = lineDecorations.map((d) => {
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      if (startColumn > hoverRange.startColumn || hoverRange.endColumn > endColumn) {
        return null;
      }
      const range2 = new Range2(hoverRange.startLineNumber, startColumn, hoverRange.startLineNumber, endColumn);
      const marker = this._markerDecorationsService.getMarker(model, d);
      if (marker) {
        return new MarkerHover(range2, marker);
      }
      const colorData = colorDetector.getColorData(d.range.getStartPosition());
      if (!didFindColor && colorData) {
        didFindColor = true;
        const {color, range: range3} = colorData.colorInfo;
        return new ColorHover(range3, color, colorData.provider);
      } else {
        if (isEmptyMarkdownString(d.options.hoverMessage)) {
          return null;
        }
        const contents = d.options.hoverMessage ? asArray(d.options.hoverMessage) : [];
        return {contents, range: range2};
      }
    });
    return coalesce(result);
  }
  onResult(result, isFromSynchronousComputation) {
    if (isFromSynchronousComputation) {
      this._result = result.concat(this._result.sort((a, b) => {
        if (a instanceof ColorHover) {
          return -1;
        } else if (b instanceof ColorHover) {
          return 1;
        }
        return 0;
      }));
    } else {
      this._result = this._result.concat(result);
    }
  }
  getResult() {
    return this._result.slice(0);
  }
  getResultWithLoadingMessage() {
    return this._result.slice(0).concat([this._getLoadingMessage()]);
  }
  _getLoadingMessage() {
    return {
      range: this._range,
      contents: [new MarkdownString().appendText(localize("modesContentHover.loading", "Loading..."))]
    };
  }
};
var markerCodeActionTrigger = {
  type: 2,
  filter: {include: CodeActionKind.QuickFix}
};
var ModesContentHoverWidget = class extends ContentHoverWidget {
  constructor(editor3, _hoverVisibleKey, markerDecorationsService, keybindingService, _themeService, _modeService, _openerService = NullOpenerService) {
    super(ModesContentHoverWidget.ID, editor3, _hoverVisibleKey, keybindingService);
    this._themeService = _themeService;
    this._modeService = _modeService;
    this._openerService = _openerService;
    this.renderDisposable = this._register(new MutableDisposable());
    this._messages = [];
    this._lastRange = null;
    this._computer = new ModesContentComputer(this._editor, markerDecorationsService);
    this._highlightDecorations = [];
    this._isChangingDecorations = false;
    this._shouldFocus = false;
    this._colorPicker = null;
    this._hoverOperation = new HoverOperation(this._computer, (result) => this._withResult(result, true), null, (result) => this._withResult(result, false), this._editor.getOption(46).delay);
    this._register(addStandardDisposableListener(this.getDomNode(), EventType2.FOCUS, () => {
      if (this._colorPicker) {
        addClass(this.getDomNode(), "colorpicker-hover");
      }
    }));
    this._register(addStandardDisposableListener(this.getDomNode(), EventType2.BLUR, () => {
      removeClass(this.getDomNode(), "colorpicker-hover");
    }));
    this._register(editor3.onDidChangeConfiguration((e) => {
      this._hoverOperation.setHoverTime(this._editor.getOption(46).delay);
    }));
    this._register(TokenizationRegistry.onDidChange((e) => {
      if (this.isVisible && this._lastRange && this._messages.length > 0) {
        this._hover.contentsDomNode.textContent = "";
        this._renderMessages(this._lastRange, this._messages);
      }
    }));
  }
  dispose() {
    this._hoverOperation.cancel();
    super.dispose();
  }
  onModelDecorationsChanged() {
    if (this._isChangingDecorations) {
      return;
    }
    if (this.isVisible) {
      this._hoverOperation.cancel();
      this._computer.clearResult();
      if (!this._colorPicker) {
        this._hoverOperation.start(0);
      }
    }
  }
  startShowingAt(range2, mode, focus) {
    if (this._lastRange && this._lastRange.equalsRange(range2)) {
      return;
    }
    this._hoverOperation.cancel();
    if (this.isVisible) {
      if (!this._showAtPosition || this._showAtPosition.lineNumber !== range2.startLineNumber) {
        this.hide();
      } else {
        let filteredMessages = [];
        for (let i = 0, len = this._messages.length; i < len; i++) {
          const msg = this._messages[i];
          const rng = msg.range;
          if (rng && rng.startColumn <= range2.startColumn && rng.endColumn >= range2.endColumn) {
            filteredMessages.push(msg);
          }
        }
        if (filteredMessages.length > 0) {
          if (hoverContentsEquals(filteredMessages, this._messages)) {
            return;
          }
          this._renderMessages(range2, filteredMessages);
        } else {
          this.hide();
        }
      }
    }
    this._lastRange = range2;
    this._computer.setRange(range2);
    this._shouldFocus = focus;
    this._hoverOperation.start(mode);
  }
  hide() {
    this._lastRange = null;
    this._hoverOperation.cancel();
    super.hide();
    this._isChangingDecorations = true;
    this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, []);
    this._isChangingDecorations = false;
    this.renderDisposable.clear();
    this._colorPicker = null;
  }
  isColorPickerVisible() {
    if (this._colorPicker) {
      return true;
    }
    return false;
  }
  _withResult(result, complete) {
    this._messages = result;
    if (this._lastRange && this._messages.length > 0) {
      this._renderMessages(this._lastRange, this._messages);
    } else if (complete) {
      this.hide();
    }
  }
  _renderMessages(renderRange, messages) {
    this.renderDisposable.dispose();
    this._colorPicker = null;
    let renderColumn = 1073741824;
    let highlightRange = messages[0].range ? Range2.lift(messages[0].range) : null;
    let fragment = document.createDocumentFragment();
    let isEmptyHoverContent = true;
    let containColorPicker = false;
    const markdownDisposeables = new DisposableStore();
    const markerMessages = [];
    messages.forEach((msg) => {
      if (!msg.range) {
        return;
      }
      renderColumn = Math.min(renderColumn, msg.range.startColumn);
      highlightRange = highlightRange ? Range2.plusRange(highlightRange, msg.range) : Range2.lift(msg.range);
      if (msg instanceof ColorHover) {
        containColorPicker = true;
        const {red, green, blue, alpha} = msg.color;
        const rgba2 = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
        const color = new Color(rgba2);
        if (!this._editor.hasModel()) {
          return;
        }
        const editorModel = this._editor.getModel();
        let range2 = new Range2(msg.range.startLineNumber, msg.range.startColumn, msg.range.endLineNumber, msg.range.endColumn);
        let colorInfo = {range: msg.range, color: msg.color};
        const model = new ColorPickerModel(color, [], 0);
        const widget = new ColorPickerWidget(fragment, model, this._editor.getOption(115), this._themeService);
        getColorPresentations(editorModel, colorInfo, msg.provider, CancellationToken.None).then((colorPresentations) => {
          model.colorPresentations = colorPresentations || [];
          if (!this._editor.hasModel()) {
            return;
          }
          const originalText = this._editor.getModel().getValueInRange(msg.range);
          model.guessColorPresentation(color, originalText);
          const updateEditorModel = () => {
            let textEdits;
            let newRange;
            if (model.presentation.textEdit) {
              textEdits = [model.presentation.textEdit];
              newRange = new Range2(model.presentation.textEdit.range.startLineNumber, model.presentation.textEdit.range.startColumn, model.presentation.textEdit.range.endLineNumber, model.presentation.textEdit.range.endColumn);
              newRange = newRange.setEndPosition(newRange.endLineNumber, newRange.startColumn + model.presentation.textEdit.text.length);
            } else {
              textEdits = [{identifier: null, range: range2, text: model.presentation.label, forceMoveMarkers: false}];
              newRange = range2.setEndPosition(range2.endLineNumber, range2.startColumn + model.presentation.label.length);
            }
            this._editor.pushUndoStop();
            this._editor.executeEdits("colorpicker", textEdits);
            if (model.presentation.additionalTextEdits) {
              textEdits = [...model.presentation.additionalTextEdits];
              this._editor.executeEdits("colorpicker", textEdits);
              this.hide();
            }
            this._editor.pushUndoStop();
            range2 = newRange;
          };
          const updateColorPresentations = (color2) => {
            return getColorPresentations(editorModel, {
              range: range2,
              color: {
                red: color2.rgba.r / 255,
                green: color2.rgba.g / 255,
                blue: color2.rgba.b / 255,
                alpha: color2.rgba.a
              }
            }, msg.provider, CancellationToken.None).then((colorPresentations2) => {
              model.colorPresentations = colorPresentations2 || [];
            });
          };
          const colorListener = model.onColorFlushed((color2) => {
            updateColorPresentations(color2).then(updateEditorModel);
          });
          const colorChangeListener = model.onDidChangeColor(updateColorPresentations);
          this._colorPicker = widget;
          this.showAt(range2.getStartPosition(), range2, this._shouldFocus);
          this.updateContents(fragment);
          this._colorPicker.layout();
          this.renderDisposable.value = combinedDisposable(colorListener, colorChangeListener, widget, markdownDisposeables);
        });
      } else {
        if (msg instanceof MarkerHover) {
          markerMessages.push(msg);
          isEmptyHoverContent = false;
        } else {
          msg.contents.filter((contents) => !isEmptyMarkdownString(contents)).forEach((contents) => {
            const markdownHoverElement = $4("div.hover-row.markdown-hover");
            const hoverContentsElement = append(markdownHoverElement, $4("div.hover-contents"));
            const renderer = markdownDisposeables.add(new MarkdownRenderer(this._editor, this._modeService, this._openerService));
            markdownDisposeables.add(renderer.onDidRenderCodeBlock(() => {
              hoverContentsElement.className = "hover-contents code-hover-contents";
              this._hover.onContentsChanged();
            }));
            const renderedContents = markdownDisposeables.add(renderer.render(contents));
            hoverContentsElement.appendChild(renderedContents.element);
            fragment.appendChild(markdownHoverElement);
            isEmptyHoverContent = false;
          });
        }
      }
    });
    if (markerMessages.length) {
      markerMessages.forEach((msg) => fragment.appendChild(this.renderMarkerHover(msg)));
      const markerHoverForStatusbar = markerMessages.length === 1 ? markerMessages[0] : markerMessages.sort((a, b) => MarkerSeverity.compare(a.marker.severity, b.marker.severity))[0];
      fragment.appendChild(this.renderMarkerStatusbar(markerHoverForStatusbar));
    }
    if (!containColorPicker && !isEmptyHoverContent) {
      this.showAt(new Position(renderRange.startLineNumber, renderColumn), highlightRange, this._shouldFocus);
      this.updateContents(fragment);
    }
    this._isChangingDecorations = true;
    this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, highlightRange ? [{
      range: highlightRange,
      options: ModesContentHoverWidget._DECORATION_OPTIONS
    }] : []);
    this._isChangingDecorations = false;
  }
  renderMarkerHover(markerHover) {
    const hoverElement = $4("div.hover-row");
    const markerElement = append(hoverElement, $4("div.marker.hover-contents"));
    const {source, message, code: code3, relatedInformation} = markerHover.marker;
    this._editor.applyFontInfo(markerElement);
    const messageElement = append(markerElement, $4("span"));
    messageElement.style.whiteSpace = "pre-wrap";
    messageElement.innerText = message;
    if (source || code3) {
      if (code3 && typeof code3 !== "string") {
        const sourceAndCodeElement = $4("span");
        if (source) {
          const sourceElement = append(sourceAndCodeElement, $4("span"));
          sourceElement.innerText = source;
        }
        this._codeLink = append(sourceAndCodeElement, $4("a.code-link"));
        this._codeLink.setAttribute("href", code3.target.toString());
        this._codeLink.onclick = (e) => {
          this._openerService.open(code3.target);
          e.preventDefault();
          e.stopPropagation();
        };
        const codeElement = append(this._codeLink, $4("span"));
        codeElement.innerText = code3.value;
        const detailsElement = append(markerElement, sourceAndCodeElement);
        detailsElement.style.opacity = "0.6";
        detailsElement.style.paddingLeft = "6px";
      } else {
        const detailsElement = append(markerElement, $4("span"));
        detailsElement.style.opacity = "0.6";
        detailsElement.style.paddingLeft = "6px";
        detailsElement.innerText = source && code3 ? `${source}(${code3})` : source ? source : `(${code3})`;
      }
    }
    if (isNonEmptyArray(relatedInformation)) {
      for (const {message: message2, resource, startLineNumber, startColumn} of relatedInformation) {
        const relatedInfoContainer = append(markerElement, $4("div"));
        relatedInfoContainer.style.marginTop = "8px";
        const a = append(relatedInfoContainer, $4("a"));
        a.innerText = `${basename(resource)}(${startLineNumber}, ${startColumn}): `;
        a.style.cursor = "pointer";
        a.onclick = (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (this._openerService) {
            this._openerService.open(resource.with({fragment: `${startLineNumber},${startColumn}`}), {fromUserGesture: true}).catch(onUnexpectedError);
          }
        };
        const messageElement2 = append(relatedInfoContainer, $4("span"));
        messageElement2.innerText = message2;
        this._editor.applyFontInfo(messageElement2);
      }
    }
    return hoverElement;
  }
  renderMarkerStatusbar(markerHover) {
    const hoverElement = $4("div.hover-row.status-bar");
    const disposables = new DisposableStore();
    const actionsElement = append(hoverElement, $4("div.actions"));
    if (markerHover.marker.severity === MarkerSeverity.Error || markerHover.marker.severity === MarkerSeverity.Warning || markerHover.marker.severity === MarkerSeverity.Info) {
      disposables.add(this._renderAction(actionsElement, {
        label: localize("peek problem", "Peek Problem"),
        commandId: NextMarkerAction.ID,
        run: () => {
          this.hide();
          MarkerController.get(this._editor).showAtMarker(markerHover.marker);
          this._editor.focus();
        }
      }));
    }
    if (!this._editor.getOption(72)) {
      const quickfixPlaceholderElement = append(actionsElement, $4("div"));
      quickfixPlaceholderElement.style.opacity = "0";
      quickfixPlaceholderElement.style.transition = "opacity 0.2s";
      setTimeout(() => quickfixPlaceholderElement.style.opacity = "1", 200);
      quickfixPlaceholderElement.textContent = localize("checkingForQuickFixes", "Checking for quick fixes...");
      disposables.add(toDisposable(() => quickfixPlaceholderElement.remove()));
      const codeActionsPromise = this.getCodeActions(markerHover.marker);
      disposables.add(toDisposable(() => codeActionsPromise.cancel()));
      codeActionsPromise.then((actions25) => {
        quickfixPlaceholderElement.style.transition = "";
        quickfixPlaceholderElement.style.opacity = "1";
        if (!actions25.validActions.length) {
          actions25.dispose();
          quickfixPlaceholderElement.textContent = localize("noQuickFixes", "No quick fixes available");
          return;
        }
        quickfixPlaceholderElement.remove();
        let showing = false;
        disposables.add(toDisposable(() => {
          if (!showing) {
            actions25.dispose();
          }
        }));
        disposables.add(this._renderAction(actionsElement, {
          label: localize("quick fixes", "Quick Fix..."),
          commandId: QuickFixAction.Id,
          run: (target) => {
            showing = true;
            const controller = QuickFixController.get(this._editor);
            const elementPosition = getDomNodePagePosition(target);
            this.hide();
            controller.showCodeActions(markerCodeActionTrigger, actions25, {
              x: elementPosition.left + 6,
              y: elementPosition.top + elementPosition.height + 6
            });
          }
        }));
      });
    }
    this.renderDisposable.value = disposables;
    return hoverElement;
  }
  getCodeActions(marker) {
    return createCancelablePromise((cancellationToken) => {
      return getCodeActions(this._editor.getModel(), new Range2(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn), markerCodeActionTrigger, Progress.None, cancellationToken);
    });
  }
};
ModesContentHoverWidget.ID = "editor.contrib.modesContentHoverWidget";
ModesContentHoverWidget._DECORATION_OPTIONS = ModelDecorationOptions.register({
  className: "hoverHighlight"
});
function hoverContentsEquals(first2, second) {
  if (!first2 && second || first2 && !second || first2.length !== second.length) {
    return false;
  }
  for (let i = 0; i < first2.length; i++) {
    const firstElement = first2[i];
    const secondElement = second[i];
    if (firstElement instanceof MarkerHover && secondElement instanceof MarkerHover) {
      return IMarkerData.makeKey(firstElement.marker) === IMarkerData.makeKey(secondElement.marker);
    }
    if (firstElement instanceof ColorHover || secondElement instanceof ColorHover) {
      return false;
    }
    if (firstElement instanceof MarkerHover || secondElement instanceof MarkerHover) {
      return false;
    }
    if (!markedStringsEquals(firstElement.contents, secondElement.contents)) {
      return false;
    }
  }
  return true;
}
registerThemingParticipant((theme6, collector) => {
  const linkFg = theme6.getColor(textLinkForeground);
  if (linkFg) {
    collector.addRule(`.monaco-hover .hover-contents a.code-link span:hover { color: ${linkFg}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/modesGlyphHover.js
var MarginComputer = class {
  constructor(editor3) {
    this._editor = editor3;
    this._lineNumber = -1;
    this._result = [];
  }
  setLineNumber(lineNumber) {
    this._lineNumber = lineNumber;
    this._result = [];
  }
  clearResult() {
    this._result = [];
  }
  computeSync() {
    const toHoverMessage = (contents) => {
      return {
        value: contents
      };
    };
    const lineDecorations = this._editor.getLineDecorations(this._lineNumber);
    const result = [];
    if (!lineDecorations) {
      return result;
    }
    for (const d of lineDecorations) {
      if (!d.options.glyphMarginClassName) {
        continue;
      }
      const hoverMessage = d.options.glyphMarginHoverMessage;
      if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {
        continue;
      }
      result.push(...asArray(hoverMessage).map(toHoverMessage));
    }
    return result;
  }
  onResult(result, isFromSynchronousComputation) {
    this._result = this._result.concat(result);
  }
  getResult() {
    return this._result;
  }
  getResultWithLoadingMessage() {
    return this.getResult();
  }
};
var ModesGlyphHoverWidget = class extends GlyphHoverWidget {
  constructor(editor3, modeService, openerService = NullOpenerService) {
    super(ModesGlyphHoverWidget.ID, editor3);
    this._renderDisposeables = this._register(new DisposableStore());
    this._messages = [];
    this._lastLineNumber = -1;
    this._markdownRenderer = this._register(new MarkdownRenderer(this._editor, modeService, openerService));
    this._computer = new MarginComputer(this._editor);
    this._hoverOperation = new HoverOperation(this._computer, (result) => this._withResult(result), void 0, (result) => this._withResult(result), 300);
  }
  dispose() {
    this._hoverOperation.cancel();
    super.dispose();
  }
  onModelDecorationsChanged() {
    if (this.isVisible) {
      this._hoverOperation.cancel();
      this._computer.clearResult();
      this._hoverOperation.start(0);
    }
  }
  startShowingAt(lineNumber) {
    if (this._lastLineNumber === lineNumber) {
      return;
    }
    this._hoverOperation.cancel();
    this.hide();
    this._lastLineNumber = lineNumber;
    this._computer.setLineNumber(lineNumber);
    this._hoverOperation.start(0);
  }
  hide() {
    this._lastLineNumber = -1;
    this._hoverOperation.cancel();
    super.hide();
  }
  _withResult(result) {
    this._messages = result;
    if (this._messages.length > 0) {
      this._renderMessages(this._lastLineNumber, this._messages);
    } else {
      this.hide();
    }
  }
  _renderMessages(lineNumber, messages) {
    this._renderDisposeables.clear();
    const fragment = document.createDocumentFragment();
    for (const msg of messages) {
      const renderedContents = this._markdownRenderer.render(msg.value);
      this._renderDisposeables.add(renderedContents);
      fragment.appendChild($("div.hover-row", void 0, renderedContents.element));
    }
    this.updateContents(fragment);
    this.showAt(lineNumber);
  }
};
ModesGlyphHoverWidget.ID = "editor.contrib.modesGlyphHoverWidget";

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/hover.js
var __decorate27 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param27 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ModesHoverController = class ModesHoverController2 {
  constructor(_editor, _openerService, _modeService, _markerDecorationsService, _keybindingService, _themeService, _contextKeyService) {
    this._editor = _editor;
    this._openerService = _openerService;
    this._modeService = _modeService;
    this._markerDecorationsService = _markerDecorationsService;
    this._keybindingService = _keybindingService;
    this._themeService = _themeService;
    this._toUnhook = new DisposableStore();
    this._contentWidget = new MutableDisposable();
    this._glyphWidget = new MutableDisposable();
    this._isMouseDown = false;
    this._hoverClicked = false;
    this._hookEvents();
    this._didChangeConfigurationHandler = this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(46)) {
        this._hideWidgets();
        this._unhookEvents();
        this._hookEvents();
      }
    });
    this._hoverVisibleKey = EditorContextKeys.hoverVisible.bindTo(_contextKeyService);
  }
  get contentWidget() {
    if (!this._contentWidget.value) {
      this._createHoverWidgets();
    }
    return this._contentWidget.value;
  }
  get glyphWidget() {
    if (!this._glyphWidget.value) {
      this._createHoverWidgets();
    }
    return this._glyphWidget.value;
  }
  static get(editor3) {
    return editor3.getContribution(ModesHoverController2.ID);
  }
  _hookEvents() {
    const hideWidgetsEventHandler = () => this._hideWidgets();
    const hoverOpts = this._editor.getOption(46);
    this._isHoverEnabled = hoverOpts.enabled;
    this._isHoverSticky = hoverOpts.sticky;
    if (this._isHoverEnabled) {
      this._toUnhook.add(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
      this._toUnhook.add(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
      this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
      this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
      this._toUnhook.add(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged()));
    } else {
      this._toUnhook.add(this._editor.onMouseMove(hideWidgetsEventHandler));
      this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
    }
    this._toUnhook.add(this._editor.onMouseLeave(hideWidgetsEventHandler));
    this._toUnhook.add(this._editor.onDidChangeModel(hideWidgetsEventHandler));
    this._toUnhook.add(this._editor.onDidScrollChange((e) => this._onEditorScrollChanged(e)));
  }
  _unhookEvents() {
    this._toUnhook.clear();
  }
  _onModelDecorationsChanged() {
    this.contentWidget.onModelDecorationsChanged();
    this.glyphWidget.onModelDecorationsChanged();
  }
  _onEditorScrollChanged(e) {
    if (e.scrollTopChanged || e.scrollLeftChanged) {
      this._hideWidgets();
    }
  }
  _onEditorMouseDown(mouseEvent) {
    this._isMouseDown = true;
    const targetType = mouseEvent.target.type;
    if (targetType === 9 && mouseEvent.target.detail === ModesContentHoverWidget.ID) {
      this._hoverClicked = true;
      return;
    }
    if (targetType === 12 && mouseEvent.target.detail === ModesGlyphHoverWidget.ID) {
      return;
    }
    if (targetType !== 12 && mouseEvent.target.detail !== ModesGlyphHoverWidget.ID) {
      this._hoverClicked = false;
    }
    this._hideWidgets();
  }
  _onEditorMouseUp(mouseEvent) {
    this._isMouseDown = false;
  }
  _onEditorMouseMove(mouseEvent) {
    let targetType = mouseEvent.target.type;
    if (this._isMouseDown && this._hoverClicked && this.contentWidget.isColorPickerVisible()) {
      return;
    }
    if (this._isHoverSticky && targetType === 9 && mouseEvent.target.detail === ModesContentHoverWidget.ID) {
      return;
    }
    if (this._isHoverSticky && targetType === 12 && mouseEvent.target.detail === ModesGlyphHoverWidget.ID) {
      return;
    }
    if (targetType === 7) {
      const epsilon = this._editor.getOption(36).typicalHalfwidthCharacterWidth / 2;
      const data = mouseEvent.target.detail;
      if (data && !data.isAfterLines && typeof data.horizontalDistanceToText === "number" && data.horizontalDistanceToText < epsilon) {
        targetType = 6;
      }
    }
    if (targetType === 6) {
      this.glyphWidget.hide();
      if (this._isHoverEnabled && mouseEvent.target.range) {
        this.contentWidget.startShowingAt(mouseEvent.target.range, 0, false);
      }
    } else if (targetType === 2) {
      this.contentWidget.hide();
      if (this._isHoverEnabled && mouseEvent.target.position) {
        this.glyphWidget.startShowingAt(mouseEvent.target.position.lineNumber);
      }
    } else {
      this._hideWidgets();
    }
  }
  _onKeyDown(e) {
    if (e.keyCode !== 5 && e.keyCode !== 6 && e.keyCode !== 57 && e.keyCode !== 4) {
      this._hideWidgets();
    }
  }
  _hideWidgets() {
    if (!this._glyphWidget.value || !this._contentWidget.value || this._isMouseDown && this._hoverClicked && this._contentWidget.value.isColorPickerVisible()) {
      return;
    }
    this._glyphWidget.value.hide();
    this._contentWidget.value.hide();
  }
  _createHoverWidgets() {
    this._contentWidget.value = new ModesContentHoverWidget(this._editor, this._hoverVisibleKey, this._markerDecorationsService, this._keybindingService, this._themeService, this._modeService, this._openerService);
    this._glyphWidget.value = new ModesGlyphHoverWidget(this._editor, this._modeService, this._openerService);
  }
  showContentHover(range2, mode, focus) {
    this.contentWidget.startShowingAt(range2, mode, focus);
  }
  dispose() {
    this._unhookEvents();
    this._toUnhook.dispose();
    this._didChangeConfigurationHandler.dispose();
    this._glyphWidget.dispose();
    this._contentWidget.dispose();
  }
};
ModesHoverController.ID = "editor.contrib.hover";
ModesHoverController = __decorate27([
  __param27(1, IOpenerService),
  __param27(2, IModeService),
  __param27(3, IMarkerDecorationsService),
  __param27(4, IKeybindingService),
  __param27(5, IThemeService),
  __param27(6, IContextKeyService)
], ModesHoverController);
var ShowHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showHover",
      label: localize({
        key: "showHover",
        comment: [
          "Label for action that will trigger the showing of a hover in the editor.",
          "This allows for users to show the hover without using the mouse."
        ]
      }, "Show Hover"),
      alias: "Show Hover",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 39),
        weight: 100
      }
    });
  }
  run(accessor, editor3) {
    if (!editor3.hasModel()) {
      return;
    }
    let controller = ModesHoverController.get(editor3);
    if (!controller) {
      return;
    }
    const position = editor3.getPosition();
    const range2 = new Range2(position.lineNumber, position.column, position.lineNumber, position.column);
    const focus = editor3.getOption(2) === 2;
    controller.showContentHover(range2, 1, focus);
  }
};
var ShowDefinitionPreviewHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showDefinitionPreviewHover",
      label: localize({
        key: "showDefinitionPreviewHover",
        comment: [
          "Label for action that will trigger the showing of definition preview hover in the editor.",
          "This allows for users to show the definition preview hover without using the mouse."
        ]
      }, "Show Definition Preview Hover"),
      alias: "Show Definition Preview Hover",
      precondition: void 0
    });
  }
  run(accessor, editor3) {
    let controller = ModesHoverController.get(editor3);
    if (!controller) {
      return;
    }
    const position = editor3.getPosition();
    if (!position) {
      return;
    }
    const range2 = new Range2(position.lineNumber, position.column, position.lineNumber, position.column);
    const goto = GotoDefinitionAtPositionEditorContribution.get(editor3);
    const promise3 = goto.startFindDefinitionFromCursor(position);
    if (promise3) {
      promise3.then(() => {
        controller.showContentHover(range2, 1, true);
      });
    } else {
      controller.showContentHover(range2, 1, true);
    }
  }
};
registerEditorContribution(ModesHoverController.ID, ModesHoverController);
registerEditorAction(ShowHoverAction);
registerEditorAction(ShowDefinitionPreviewHoverAction);
registerThemingParticipant((theme6, collector) => {
  const editorHoverHighlightColor = theme6.getColor(editorHoverHighlight);
  if (editorHoverHighlightColor) {
    collector.addRule(`.monaco-editor .hoverHighlight { background-color: ${editorHoverHighlightColor}; }`);
  }
  const hoverBackground = theme6.getColor(editorHoverBackground);
  if (hoverBackground) {
    collector.addRule(`.monaco-editor .monaco-hover { background-color: ${hoverBackground}; }`);
  }
  const hoverBorder = theme6.getColor(editorHoverBorder);
  if (hoverBorder) {
    collector.addRule(`.monaco-editor .monaco-hover { border: 1px solid ${hoverBorder}; }`);
    collector.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${hoverBorder.transparent(0.5)}; }`);
  }
  const link = theme6.getColor(textLinkForeground);
  if (link) {
    collector.addRule(`.monaco-editor .monaco-hover a { color: ${link}; }`);
  }
  const hoverForeground = theme6.getColor(editorHoverForeground);
  if (hoverForeground) {
    collector.addRule(`.monaco-editor .monaco-hover { color: ${hoverForeground}; }`);
  }
  const actionsBackground = theme6.getColor(editorHoverStatusBarBackground);
  if (actionsBackground) {
    collector.addRule(`.monaco-editor .monaco-hover .hover-row .actions { background-color: ${actionsBackground}; }`);
  }
  const codeBackground = theme6.getColor(textCodeBlockBackground);
  if (codeBackground) {
    collector.addRule(`.monaco-editor .monaco-hover code { background-color: ${codeBackground}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/indentation/indentUtils.js
function getSpaceCnt(str, tabSize) {
  let spacesCnt = 0;
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) === "	") {
      spacesCnt += tabSize;
    } else {
      spacesCnt++;
    }
  }
  return spacesCnt;
}
function generateIndent(spacesCnt, tabSize, insertSpaces) {
  spacesCnt = spacesCnt < 0 ? 0 : spacesCnt;
  let result = "";
  if (!insertSpaces) {
    let tabsCnt = Math.floor(spacesCnt / tabSize);
    spacesCnt = spacesCnt % tabSize;
    for (let i = 0; i < tabsCnt; i++) {
      result += "	";
    }
  }
  for (let i = 0; i < spacesCnt; i++) {
    result += " ";
  }
  return result;
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/indentation/indentation.js
function getReindentEditOperations(model, startLineNumber, endLineNumber, inheritedIndent) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return [];
  }
  let indentationRules = LanguageConfigurationRegistry.getIndentationRules(model.getLanguageIdentifier().id);
  if (!indentationRules) {
    return [];
  }
  endLineNumber = Math.min(endLineNumber, model.getLineCount());
  while (startLineNumber <= endLineNumber) {
    if (!indentationRules.unIndentedLinePattern) {
      break;
    }
    let text = model.getLineContent(startLineNumber);
    if (!indentationRules.unIndentedLinePattern.test(text)) {
      break;
    }
    startLineNumber++;
  }
  if (startLineNumber > endLineNumber - 1) {
    return [];
  }
  const {tabSize, indentSize, insertSpaces} = model.getOptions();
  const shiftIndent = (indentation, count) => {
    count = count || 1;
    return ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  };
  const unshiftIndent = (indentation, count) => {
    count = count || 1;
    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  };
  let indentEdits = [];
  let globalIndent;
  let currentLineText = model.getLineContent(startLineNumber);
  let adjustedLineContent = currentLineText;
  if (inheritedIndent !== void 0 && inheritedIndent !== null) {
    globalIndent = inheritedIndent;
    let oldIndentation = getLeadingWhitespace(currentLineText);
    adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {
      globalIndent = unshiftIndent(globalIndent);
      adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
    }
    if (currentLineText !== adjustedLineContent) {
      indentEdits.push(EditOperation.replace(new Selection(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(globalIndent, indentSize, insertSpaces)));
    }
  } else {
    globalIndent = getLeadingWhitespace(currentLineText);
  }
  let idealIndentForNextLine = globalIndent;
  if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    globalIndent = shiftIndent(globalIndent);
  } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
  }
  startLineNumber++;
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    let text = model.getLineContent(lineNumber);
    let oldIndentation = getLeadingWhitespace(text);
    let adjustedLineContent2 = idealIndentForNextLine + text.substring(oldIndentation.length);
    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent2)) {
      idealIndentForNextLine = unshiftIndent(idealIndentForNextLine);
      globalIndent = unshiftIndent(globalIndent);
    }
    if (oldIndentation !== idealIndentForNextLine) {
      indentEdits.push(EditOperation.replace(new Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));
    }
    if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text)) {
      continue;
    } else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent2)) {
      globalIndent = shiftIndent(globalIndent);
      idealIndentForNextLine = globalIndent;
    } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent2)) {
      idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    } else {
      idealIndentForNextLine = globalIndent;
    }
  }
  return indentEdits;
}
var IndentationToSpacesAction = class extends EditorAction {
  constructor() {
    super({
      id: IndentationToSpacesAction.ID,
      label: localize("indentationToSpaces", "Convert Indentation to Spaces"),
      alias: "Convert Indentation to Spaces",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor3) {
    let model = editor3.getModel();
    if (!model) {
      return;
    }
    let modelOpts = model.getOptions();
    let selection = editor3.getSelection();
    if (!selection) {
      return;
    }
    const command = new IndentationToSpacesCommand(selection, modelOpts.tabSize);
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, [command]);
    editor3.pushUndoStop();
    model.updateOptions({
      insertSpaces: true
    });
  }
};
IndentationToSpacesAction.ID = "editor.action.indentationToSpaces";
var IndentationToTabsAction = class extends EditorAction {
  constructor() {
    super({
      id: IndentationToTabsAction.ID,
      label: localize("indentationToTabs", "Convert Indentation to Tabs"),
      alias: "Convert Indentation to Tabs",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor3) {
    let model = editor3.getModel();
    if (!model) {
      return;
    }
    let modelOpts = model.getOptions();
    let selection = editor3.getSelection();
    if (!selection) {
      return;
    }
    const command = new IndentationToTabsCommand(selection, modelOpts.tabSize);
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, [command]);
    editor3.pushUndoStop();
    model.updateOptions({
      insertSpaces: false
    });
  }
};
IndentationToTabsAction.ID = "editor.action.indentationToTabs";
var ChangeIndentationSizeAction = class extends EditorAction {
  constructor(insertSpaces, opts) {
    super(opts);
    this.insertSpaces = insertSpaces;
  }
  run(accessor, editor3) {
    const quickInputService = accessor.get(IQuickInputService);
    const modelService = accessor.get(IModelService);
    let model = editor3.getModel();
    if (!model) {
      return;
    }
    let creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language, model.uri, model.isForSimpleWidget);
    const picks = [1, 2, 3, 4, 5, 6, 7, 8].map((n) => ({
      id: n.toString(),
      label: n.toString(),
      description: n === creationOpts.tabSize ? localize("configuredTabSize", "Configured Tab Size") : void 0
    }));
    const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);
    setTimeout(() => {
      quickInputService.pick(picks, {placeHolder: localize({key: "selectTabWidth", comment: ["Tab corresponds to the tab key"]}, "Select Tab Size for Current File"), activeItem: picks[autoFocusIndex]}).then((pick) => {
        if (pick) {
          if (model && !model.isDisposed()) {
            model.updateOptions({
              tabSize: parseInt(pick.label, 10),
              insertSpaces: this.insertSpaces
            });
          }
        }
      });
    }, 50);
  }
};
var IndentUsingTabs = class extends ChangeIndentationSizeAction {
  constructor() {
    super(false, {
      id: IndentUsingTabs.ID,
      label: localize("indentUsingTabs", "Indent Using Tabs"),
      alias: "Indent Using Tabs",
      precondition: void 0
    });
  }
};
IndentUsingTabs.ID = "editor.action.indentUsingTabs";
var IndentUsingSpaces = class extends ChangeIndentationSizeAction {
  constructor() {
    super(true, {
      id: IndentUsingSpaces.ID,
      label: localize("indentUsingSpaces", "Indent Using Spaces"),
      alias: "Indent Using Spaces",
      precondition: void 0
    });
  }
};
IndentUsingSpaces.ID = "editor.action.indentUsingSpaces";
var DetectIndentation = class extends EditorAction {
  constructor() {
    super({
      id: DetectIndentation.ID,
      label: localize("detectIndentation", "Detect Indentation from Content"),
      alias: "Detect Indentation from Content",
      precondition: void 0
    });
  }
  run(accessor, editor3) {
    const modelService = accessor.get(IModelService);
    let model = editor3.getModel();
    if (!model) {
      return;
    }
    let creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language, model.uri, model.isForSimpleWidget);
    model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);
  }
};
DetectIndentation.ID = "editor.action.detectIndentation";
var ReindentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.reindentlines",
      label: localize("editor.reindentlines", "Reindent Lines"),
      alias: "Reindent Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor3) {
    let model = editor3.getModel();
    if (!model) {
      return;
    }
    let edits = getReindentEditOperations(model, 1, model.getLineCount());
    if (edits.length > 0) {
      editor3.pushUndoStop();
      editor3.executeEdits(this.id, edits);
      editor3.pushUndoStop();
    }
  }
};
var ReindentSelectedLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.reindentselectedlines",
      label: localize("editor.reindentselectedlines", "Reindent Selected Lines"),
      alias: "Reindent Selected Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor3) {
    let model = editor3.getModel();
    if (!model) {
      return;
    }
    let selections = editor3.getSelections();
    if (selections === null) {
      return;
    }
    let edits = [];
    for (let selection of selections) {
      let startLineNumber = selection.startLineNumber;
      let endLineNumber = selection.endLineNumber;
      if (startLineNumber !== endLineNumber && selection.endColumn === 1) {
        endLineNumber--;
      }
      if (startLineNumber === 1) {
        if (startLineNumber === endLineNumber) {
          continue;
        }
      } else {
        startLineNumber--;
      }
      let editOperations = getReindentEditOperations(model, startLineNumber, endLineNumber);
      edits.push(...editOperations);
    }
    if (edits.length > 0) {
      editor3.pushUndoStop();
      editor3.executeEdits(this.id, edits);
      editor3.pushUndoStop();
    }
  }
};
var AutoIndentOnPasteCommand = class {
  constructor(edits, initialSelection) {
    this._initialSelection = initialSelection;
    this._edits = [];
    this._selectionId = null;
    for (let edit2 of edits) {
      if (edit2.range && typeof edit2.text === "string") {
        this._edits.push(edit2);
      }
    }
  }
  getEditOperations(model, builder) {
    for (let edit2 of this._edits) {
      builder.addEditOperation(Range2.lift(edit2.range), edit2.text);
    }
    let selectionIsSet = false;
    if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {
      if (this._edits[0].range.startColumn === this._initialSelection.endColumn && this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {
        selectionIsSet = true;
        this._selectionId = builder.trackSelection(this._initialSelection, true);
      } else if (this._edits[0].range.endColumn === this._initialSelection.startColumn && this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {
        selectionIsSet = true;
        this._selectionId = builder.trackSelection(this._initialSelection, false);
      }
    }
    if (!selectionIsSet) {
      this._selectionId = builder.trackSelection(this._initialSelection);
    }
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
};
var AutoIndentOnPaste = class {
  constructor(editor3) {
    this.callOnDispose = new DisposableStore();
    this.callOnModel = new DisposableStore();
    this.editor = editor3;
    this.callOnDispose.add(editor3.onDidChangeConfiguration(() => this.update()));
    this.callOnDispose.add(editor3.onDidChangeModel(() => this.update()));
    this.callOnDispose.add(editor3.onDidChangeModelLanguage(() => this.update()));
  }
  update() {
    this.callOnModel.clear();
    if (this.editor.getOption(8) < 4 || this.editor.getOption(40)) {
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    this.callOnModel.add(this.editor.onDidPaste(({range: range2}) => {
      this.trigger(range2);
    }));
  }
  trigger(range2) {
    let selections = this.editor.getSelections();
    if (selections === null || selections.length > 1) {
      return;
    }
    const model = this.editor.getModel();
    if (!model) {
      return;
    }
    if (!model.isCheapToTokenize(range2.getStartPosition().lineNumber)) {
      return;
    }
    const autoIndent = this.editor.getOption(8);
    const {tabSize, indentSize, insertSpaces} = model.getOptions();
    this.editor.pushUndoStop();
    let textEdits = [];
    let indentConverter = {
      shiftIndent: (indentation) => {
        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      },
      unshiftIndent: (indentation) => {
        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      }
    };
    let startLineNumber = range2.startLineNumber;
    while (startLineNumber <= range2.endLineNumber) {
      if (this.shouldIgnoreLine(model, startLineNumber)) {
        startLineNumber++;
        continue;
      }
      break;
    }
    if (startLineNumber > range2.endLineNumber) {
      return;
    }
    let firstLineText = model.getLineContent(startLineNumber);
    if (!/\S/.test(firstLineText.substring(0, range2.startColumn - 1))) {
      let indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, model, model.getLanguageIdentifier().id, startLineNumber, indentConverter);
      if (indentOfFirstLine !== null) {
        let oldIndentation = getLeadingWhitespace(firstLineText);
        let newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
        let oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
        if (newSpaceCnt !== oldSpaceCnt) {
          let newIndent = generateIndent(newSpaceCnt, tabSize, insertSpaces);
          textEdits.push({
            range: new Range2(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),
            text: newIndent
          });
          firstLineText = newIndent + firstLineText.substr(oldIndentation.length);
        } else {
          let indentMetadata = LanguageConfigurationRegistry.getIndentMetadata(model, startLineNumber);
          if (indentMetadata === 0 || indentMetadata === 8) {
            return;
          }
        }
      }
    }
    const firstLineNumber = startLineNumber;
    while (startLineNumber < range2.endLineNumber) {
      if (!/\S/.test(model.getLineContent(startLineNumber + 1))) {
        startLineNumber++;
        continue;
      }
      break;
    }
    if (startLineNumber !== range2.endLineNumber) {
      let virtualModel = {
        getLineTokens: (lineNumber) => {
          return model.getLineTokens(lineNumber);
        },
        getLanguageIdentifier: () => {
          return model.getLanguageIdentifier();
        },
        getLanguageIdAtPosition: (lineNumber, column) => {
          return model.getLanguageIdAtPosition(lineNumber, column);
        },
        getLineContent: (lineNumber) => {
          if (lineNumber === firstLineNumber) {
            return firstLineText;
          } else {
            return model.getLineContent(lineNumber);
          }
        }
      };
      let indentOfSecondLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, virtualModel, model.getLanguageIdentifier().id, startLineNumber + 1, indentConverter);
      if (indentOfSecondLine !== null) {
        let newSpaceCntOfSecondLine = getSpaceCnt(indentOfSecondLine, tabSize);
        let oldSpaceCntOfSecondLine = getSpaceCnt(getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);
        if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {
          let spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;
          for (let i = startLineNumber + 1; i <= range2.endLineNumber; i++) {
            let lineContent = model.getLineContent(i);
            let originalIndent = getLeadingWhitespace(lineContent);
            let originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
            let newSpacesCnt = originalSpacesCnt + spaceCntOffset;
            let newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
            if (newIndent !== originalIndent) {
              textEdits.push({
                range: new Range2(i, 1, i, originalIndent.length + 1),
                text: newIndent
              });
            }
          }
        }
      }
    }
    let cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());
    this.editor.executeCommand("autoIndentOnPaste", cmd);
    this.editor.pushUndoStop();
  }
  shouldIgnoreLine(model, lineNumber) {
    model.forceTokenization(lineNumber);
    let nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
    if (nonWhitespaceColumn === 0) {
      return true;
    }
    let tokens = model.getLineTokens(lineNumber);
    if (tokens.getCount() > 0) {
      let firstNonWhitespaceTokenIndex = tokens.findTokenIndexAtOffset(nonWhitespaceColumn);
      if (firstNonWhitespaceTokenIndex >= 0 && tokens.getStandardTokenType(firstNonWhitespaceTokenIndex) === 1) {
        return true;
      }
    }
    return false;
  }
  dispose() {
    this.callOnDispose.dispose();
    this.callOnModel.dispose();
  }
};
AutoIndentOnPaste.ID = "editor.contrib.autoIndentOnPaste";
function getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return;
  }
  let spaces = "";
  for (let i = 0; i < tabSize; i++) {
    spaces += " ";
  }
  let spacesRegExp = new RegExp(spaces, "gi");
  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
    let lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
    if (lastIndentationColumn === 0) {
      lastIndentationColumn = model.getLineMaxColumn(lineNumber);
    }
    if (lastIndentationColumn === 1) {
      continue;
    }
    const originalIndentationRange = new Range2(lineNumber, 1, lineNumber, lastIndentationColumn);
    const originalIndentation = model.getValueInRange(originalIndentationRange);
    const newIndentation = tabsToSpaces ? originalIndentation.replace(/\t/ig, spaces) : originalIndentation.replace(spacesRegExp, "	");
    builder.addEditOperation(originalIndentationRange, newIndentation);
  }
}
var IndentationToSpacesCommand = class {
  constructor(selection, tabSize) {
    this.selection = selection;
    this.tabSize = tabSize;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    this.selectionId = builder.trackSelection(this.selection);
    getIndentationEditOperations(model, builder, this.tabSize, true);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
};
var IndentationToTabsCommand = class {
  constructor(selection, tabSize) {
    this.selection = selection;
    this.tabSize = tabSize;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    this.selectionId = builder.trackSelection(this.selection);
    getIndentationEditOperations(model, builder, this.tabSize, false);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
};
registerEditorContribution(AutoIndentOnPaste.ID, AutoIndentOnPaste);
registerEditorAction(IndentationToSpacesAction);
registerEditorAction(IndentationToTabsAction);
registerEditorAction(IndentUsingTabs);
registerEditorAction(IndentUsingSpaces);
registerEditorAction(DetectIndentation);
registerEditorAction(ReindentLinesAction);
registerEditorAction(ReindentSelectedLinesAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/inPlaceReplaceCommand.js
var InPlaceReplaceCommand = class {
  constructor(editRange, originalSelection, text) {
    this._editRange = editRange;
    this._originalSelection = originalSelection;
    this._text = text;
  }
  getEditOperations(model, builder) {
    builder.addTrackedEditOperation(this._editRange, this._text);
  }
  computeCursorState(model, helper) {
    const inverseEditOperations = helper.getInverseEditOperations();
    const srcRange = inverseEditOperations[0].range;
    if (!this._originalSelection.isEmpty()) {
      return new Selection(srcRange.endLineNumber, srcRange.endColumn - this._text.length, srcRange.endLineNumber, srcRange.endColumn);
    }
    return new Selection(srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn), srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn));
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/inPlaceReplace.js
var __decorate28 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param28 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InPlaceReplaceController = class InPlaceReplaceController2 {
  constructor(editor3, editorWorkerService) {
    this.decorationIds = [];
    this.editor = editor3;
    this.editorWorkerService = editorWorkerService;
  }
  static get(editor3) {
    return editor3.getContribution(InPlaceReplaceController2.ID);
  }
  dispose() {
  }
  run(source, up) {
    if (this.currentRequest) {
      this.currentRequest.cancel();
    }
    const editorSelection = this.editor.getSelection();
    const model = this.editor.getModel();
    if (!model || !editorSelection) {
      return void 0;
    }
    let selection = editorSelection;
    if (selection.startLineNumber !== selection.endLineNumber) {
      return void 0;
    }
    const state = new EditorState(this.editor, 1 | 4);
    const modelURI = model.uri;
    if (!this.editorWorkerService.canNavigateValueSet(modelURI)) {
      return Promise.resolve(void 0);
    }
    this.currentRequest = createCancelablePromise((token) => this.editorWorkerService.navigateValueSet(modelURI, selection, up));
    return this.currentRequest.then((result) => {
      if (!result || !result.range || !result.value) {
        return;
      }
      if (!state.validate(this.editor)) {
        return;
      }
      let editRange = Range2.lift(result.range);
      let highlightRange = result.range;
      let diff = result.value.length - (selection.endColumn - selection.startColumn);
      highlightRange = {
        startLineNumber: highlightRange.startLineNumber,
        startColumn: highlightRange.startColumn,
        endLineNumber: highlightRange.endLineNumber,
        endColumn: highlightRange.startColumn + result.value.length
      };
      if (diff > 1) {
        selection = new Selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn + diff - 1);
      }
      const command = new InPlaceReplaceCommand(editRange, selection, result.value);
      this.editor.pushUndoStop();
      this.editor.executeCommand(source, command);
      this.editor.pushUndoStop();
      this.decorationIds = this.editor.deltaDecorations(this.decorationIds, [{
        range: highlightRange,
        options: InPlaceReplaceController2.DECORATION
      }]);
      if (this.decorationRemover) {
        this.decorationRemover.cancel();
      }
      this.decorationRemover = timeout(350);
      this.decorationRemover.then(() => this.decorationIds = this.editor.deltaDecorations(this.decorationIds, [])).catch(onUnexpectedError);
    }).catch(onUnexpectedError);
  }
};
InPlaceReplaceController.ID = "editor.contrib.inPlaceReplaceController";
InPlaceReplaceController.DECORATION = ModelDecorationOptions.register({
  className: "valueSetReplacement"
});
InPlaceReplaceController = __decorate28([
  __param28(1, IEditorWorkerService)
], InPlaceReplaceController);
var InPlaceReplaceUp = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inPlaceReplace.up",
      label: localize("InPlaceReplaceAction.previous.label", "Replace with Previous Value"),
      alias: "Replace with Previous Value",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 82,
        weight: 100
      }
    });
  }
  run(accessor, editor3) {
    const controller = InPlaceReplaceController.get(editor3);
    if (!controller) {
      return Promise.resolve(void 0);
    }
    return controller.run(this.id, true);
  }
};
var InPlaceReplaceDown = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inPlaceReplace.down",
      label: localize("InPlaceReplaceAction.next.label", "Replace with Next Value"),
      alias: "Replace with Next Value",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 84,
        weight: 100
      }
    });
  }
  run(accessor, editor3) {
    const controller = InPlaceReplaceController.get(editor3);
    if (!controller) {
      return Promise.resolve(void 0);
    }
    return controller.run(this.id, false);
  }
};
registerEditorContribution(InPlaceReplaceController.ID, InPlaceReplaceController);
registerEditorAction(InPlaceReplaceUp);
registerEditorAction(InPlaceReplaceDown);
registerThemingParticipant((theme6, collector) => {
  const border = theme6.getColor(editorBracketMatchBorder);
  if (border) {
    collector.addRule(`.monaco-editor.vs .valueSetReplacement { outline: solid 2px ${border}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/common/commands/trimTrailingWhitespaceCommand.js
var TrimTrailingWhitespaceCommand = class {
  constructor(selection, cursors) {
    this._selection = selection;
    this._cursors = cursors;
    this._selectionId = null;
  }
  getEditOperations(model, builder) {
    let ops = trimTrailingWhitespace(model, this._cursors);
    for (let i = 0, len = ops.length; i < len; i++) {
      let op = ops[i];
      builder.addEditOperation(op.range, op.text);
    }
    this._selectionId = builder.trackSelection(this._selection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
};
function trimTrailingWhitespace(model, cursors) {
  cursors.sort((a, b) => {
    if (a.lineNumber === b.lineNumber) {
      return a.column - b.column;
    }
    return a.lineNumber - b.lineNumber;
  });
  for (let i = cursors.length - 2; i >= 0; i--) {
    if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {
      cursors.splice(i, 1);
    }
  }
  let r = [];
  let rLen = 0;
  let cursorIndex = 0;
  let cursorLen = cursors.length;
  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
    let lineContent = model.getLineContent(lineNumber);
    let maxLineColumn = lineContent.length + 1;
    let minEditColumn = 0;
    if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {
      minEditColumn = cursors[cursorIndex].column;
      cursorIndex++;
      if (minEditColumn === maxLineColumn) {
        continue;
      }
    }
    if (lineContent.length === 0) {
      continue;
    }
    let lastNonWhitespaceIndex2 = lastNonWhitespaceIndex(lineContent);
    let fromColumn = 0;
    if (lastNonWhitespaceIndex2 === -1) {
      fromColumn = 1;
    } else if (lastNonWhitespaceIndex2 !== lineContent.length - 1) {
      fromColumn = lastNonWhitespaceIndex2 + 2;
    } else {
      continue;
    }
    fromColumn = Math.max(minEditColumn, fromColumn);
    r[rLen++] = EditOperation.delete(new Range2(lineNumber, fromColumn, lineNumber, maxLineColumn));
  }
  return r;
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/copyLinesCommand.js
var CopyLinesCommand = class {
  constructor(selection, isCopyingDown) {
    this._selection = selection;
    this._isCopyingDown = isCopyingDown;
    this._selectionDirection = 0;
    this._selectionId = null;
    this._startLineNumberDelta = 0;
    this._endLineNumberDelta = 0;
  }
  getEditOperations(model, builder) {
    let s = this._selection;
    this._startLineNumberDelta = 0;
    this._endLineNumberDelta = 0;
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._endLineNumberDelta = 1;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    let sourceLines = [];
    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {
      sourceLines.push(model.getLineContent(i));
    }
    const sourceText = sourceLines.join("\n");
    if (sourceText === "") {
      if (this._isCopyingDown) {
        this._startLineNumberDelta++;
        this._endLineNumberDelta++;
      }
    }
    if (!this._isCopyingDown) {
      builder.addEditOperation(new Range2(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + sourceText);
    } else {
      builder.addEditOperation(new Range2(s.startLineNumber, 1, s.startLineNumber, 1), sourceText + "\n");
    }
    this._selectionId = builder.trackSelection(s);
    this._selectionDirection = this._selection.getDirection();
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
      let startLineNumber = result.startLineNumber;
      let startColumn = result.startColumn;
      let endLineNumber = result.endLineNumber;
      let endColumn = result.endColumn;
      if (this._startLineNumberDelta !== 0) {
        startLineNumber = startLineNumber + this._startLineNumberDelta;
        startColumn = 1;
      }
      if (this._endLineNumberDelta !== 0) {
        endLineNumber = endLineNumber + this._endLineNumberDelta;
        endColumn = 1;
      }
      result = Selection.createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, this._selectionDirection);
    }
    return result;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/moveLinesCommand.js
var MoveLinesCommand = class {
  constructor(selection, isMovingDown, autoIndent) {
    this._selection = selection;
    this._isMovingDown = isMovingDown;
    this._autoIndent = autoIndent;
    this._selectionId = null;
    this._moveEndLineSelectionShrink = false;
  }
  getEditOperations(model, builder) {
    let modelLineCount = model.getLineCount();
    if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {
      this._selectionId = builder.trackSelection(this._selection);
      return;
    }
    if (!this._isMovingDown && this._selection.startLineNumber === 1) {
      this._selectionId = builder.trackSelection(this._selection);
      return;
    }
    this._moveEndPositionDown = false;
    let s = this._selection;
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._moveEndPositionDown = true;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const {tabSize, indentSize, insertSpaces} = model.getOptions();
    let indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);
    let virtualModel = {
      getLineTokens: (lineNumber) => {
        return model.getLineTokens(lineNumber);
      },
      getLanguageIdentifier: () => {
        return model.getLanguageIdentifier();
      },
      getLanguageIdAtPosition: (lineNumber, column) => {
        return model.getLanguageIdAtPosition(lineNumber, column);
      },
      getLineContent: null
    };
    if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {
      let lineNumber = s.startLineNumber;
      let otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;
      if (model.getLineMaxColumn(otherLineNumber) === 1) {
        builder.addEditOperation(new Range2(1, 1, 1, 1), null);
      } else {
        builder.addEditOperation(new Range2(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));
        builder.addEditOperation(new Range2(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);
      }
      s = new Selection(otherLineNumber, 1, otherLineNumber, 1);
    } else {
      let movingLineNumber;
      let movingLineText;
      if (this._isMovingDown) {
        movingLineNumber = s.endLineNumber + 1;
        movingLineText = model.getLineContent(movingLineNumber);
        builder.addEditOperation(new Range2(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);
        let insertingText = movingLineText;
        if (this.shouldAutoIndent(model, s)) {
          let movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);
          if (movingLineMatchResult !== null) {
            let oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
            let newSpaceCnt = movingLineMatchResult + getSpaceCnt(oldIndentation, tabSize);
            let newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
            insertingText = newIndentation + this.trimLeft(movingLineText);
          } else {
            virtualModel.getLineContent = (lineNumber) => {
              if (lineNumber === s.startLineNumber) {
                return model.getLineContent(movingLineNumber);
              } else {
                return model.getLineContent(lineNumber);
              }
            };
            let indentOfMovingLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter);
            if (indentOfMovingLine !== null) {
              let oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
              let newSpaceCnt = getSpaceCnt(indentOfMovingLine, tabSize);
              let oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                let newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
                insertingText = newIndentation + this.trimLeft(movingLineText);
              }
            }
          }
          builder.addEditOperation(new Range2(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
          let ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber, insertingText);
          if (ret !== null) {
            if (ret !== 0) {
              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
            }
          } else {
            virtualModel.getLineContent = (lineNumber) => {
              if (lineNumber === s.startLineNumber) {
                return insertingText;
              } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {
                return model.getLineContent(lineNumber - 1);
              } else {
                return model.getLineContent(lineNumber);
              }
            };
            let newIndentatOfMovingBlock = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter);
            if (newIndentatOfMovingBlock !== null) {
              const oldIndentation = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
              const newSpaceCnt = getSpaceCnt(newIndentatOfMovingBlock, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
              }
            }
          }
        } else {
          builder.addEditOperation(new Range2(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
        }
      } else {
        movingLineNumber = s.startLineNumber - 1;
        movingLineText = model.getLineContent(movingLineNumber);
        builder.addEditOperation(new Range2(movingLineNumber, 1, movingLineNumber + 1, 1), null);
        builder.addEditOperation(new Range2(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + movingLineText);
        if (this.shouldAutoIndent(model, s)) {
          virtualModel.getLineContent = (lineNumber) => {
            if (lineNumber === movingLineNumber) {
              return model.getLineContent(s.startLineNumber);
            } else {
              return model.getLineContent(lineNumber);
            }
          };
          let ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);
          if (ret !== null) {
            if (ret !== 0) {
              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
            }
          } else {
            let indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter);
            if (indentOfFirstLine !== null) {
              let oldIndent = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
              let newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
              let oldSpaceCnt = getSpaceCnt(oldIndent, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                let spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
              }
            }
          }
        }
      }
    }
    this._selectionId = builder.trackSelection(s);
  }
  buildIndentConverter(tabSize, indentSize, insertSpaces) {
    return {
      shiftIndent: (indentation) => {
        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      },
      unshiftIndent: (indentation) => {
        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      }
    };
  }
  matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, oneLineAboveText) {
    let validPrecedingLine = oneLineAbove;
    while (validPrecedingLine >= 1) {
      let lineContent;
      if (validPrecedingLine === oneLineAbove && oneLineAboveText !== void 0) {
        lineContent = oneLineAboveText;
      } else {
        lineContent = model.getLineContent(validPrecedingLine);
      }
      let nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
      if (nonWhitespaceIdx >= 0) {
        break;
      }
      validPrecedingLine--;
    }
    if (validPrecedingLine < 1 || line > model.getLineCount()) {
      return null;
    }
    let maxColumn = model.getLineMaxColumn(validPrecedingLine);
    let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range2(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));
    if (enter) {
      let enterPrefix = enter.indentation;
      if (enter.indentAction === IndentAction.None) {
        enterPrefix = enter.indentation + enter.appendText;
      } else if (enter.indentAction === IndentAction.Indent) {
        enterPrefix = enter.indentation + enter.appendText;
      } else if (enter.indentAction === IndentAction.IndentOutdent) {
        enterPrefix = enter.indentation;
      } else if (enter.indentAction === IndentAction.Outdent) {
        enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;
      }
      let movingLineText = model.getLineContent(line);
      if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {
        let oldIndentation = getLeadingWhitespace(model.getLineContent(line));
        let newIndentation = getLeadingWhitespace(enterPrefix);
        let indentMetadataOfMovelingLine = LanguageConfigurationRegistry.getIndentMetadata(model, line);
        if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2) {
          newIndentation = indentConverter.unshiftIndent(newIndentation);
        }
        let newSpaceCnt = getSpaceCnt(newIndentation, tabSize);
        let oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
        return newSpaceCnt - oldSpaceCnt;
      }
    }
    return null;
  }
  trimLeft(str) {
    return str.replace(/^\s+/, "");
  }
  shouldAutoIndent(model, selection) {
    if (this._autoIndent < 4) {
      return false;
    }
    if (!model.isCheapToTokenize(selection.startLineNumber)) {
      return false;
    }
    let languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);
    let languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);
    if (languageAtSelectionStart !== languageAtSelectionEnd) {
      return false;
    }
    if (LanguageConfigurationRegistry.getIndentRulesSupport(languageAtSelectionStart) === null) {
      return false;
    }
    return true;
  }
  getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {
    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {
      let lineContent = model.getLineContent(i);
      let originalIndent = getLeadingWhitespace(lineContent);
      let originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
      let newSpacesCnt = originalSpacesCnt + offset;
      let newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
      if (newIndent !== originalIndent) {
        builder.addEditOperation(new Range2(i, 1, i, originalIndent.length + 1), newIndent);
        if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === "") {
          this._moveEndLineSelectionShrink = true;
        }
      }
    }
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._moveEndPositionDown) {
      result = result.setEndPosition(result.endLineNumber + 1, 1);
    }
    if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {
      result = result.setEndPosition(result.endLineNumber, 2);
    }
    return result;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/sortLinesCommand.js
var SortLinesCommand = class {
  constructor(selection, descending) {
    this.selection = selection;
    this.descending = descending;
    this.selectionId = null;
  }
  static getCollator() {
    if (!SortLinesCommand._COLLATOR) {
      SortLinesCommand._COLLATOR = new Intl.Collator();
    }
    return SortLinesCommand._COLLATOR;
  }
  getEditOperations(model, builder) {
    let op = sortLines(model, this.selection, this.descending);
    if (op) {
      builder.addEditOperation(op.range, op.text);
    }
    this.selectionId = builder.trackSelection(this.selection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
  static canRun(model, selection, descending) {
    if (model === null) {
      return false;
    }
    let data = getSortData(model, selection, descending);
    if (!data) {
      return false;
    }
    for (let i = 0, len = data.before.length; i < len; i++) {
      if (data.before[i] !== data.after[i]) {
        return true;
      }
    }
    return false;
  }
};
SortLinesCommand._COLLATOR = null;
function getSortData(model, selection, descending) {
  let startLineNumber = selection.startLineNumber;
  let endLineNumber = selection.endLineNumber;
  if (selection.endColumn === 1) {
    endLineNumber--;
  }
  if (startLineNumber >= endLineNumber) {
    return null;
  }
  let linesToSort = [];
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    linesToSort.push(model.getLineContent(lineNumber));
  }
  let sorted = linesToSort.slice(0);
  sorted.sort(SortLinesCommand.getCollator().compare);
  if (descending === true) {
    sorted = sorted.reverse();
  }
  return {
    startLineNumber,
    endLineNumber,
    before: linesToSort,
    after: sorted
  };
}
function sortLines(model, selection, descending) {
  let data = getSortData(model, selection, descending);
  if (!data) {
    return null;
  }
  return EditOperation.replace(new Range2(data.startLineNumber, 1, data.endLineNumber, model.getLineMaxColumn(data.endLineNumber)), data.after.join("\n"));
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/linesOperations.js
var AbstractCopyLinesAction = class extends EditorAction {
  constructor(down, opts) {
    super(opts);
    this.down = down;
  }
  run(_accessor, editor3) {
    if (!editor3.hasModel()) {
      return;
    }
    const selections = editor3.getSelections().map((selection, index2) => ({selection, index: index2, ignore: false}));
    selections.sort((a, b) => Range2.compareRangesUsingStarts(a.selection, b.selection));
    let prev = selections[0];
    for (let i = 1; i < selections.length; i++) {
      const curr = selections[i];
      if (prev.selection.endLineNumber === curr.selection.startLineNumber) {
        if (prev.index < curr.index) {
          curr.ignore = true;
        } else {
          prev.ignore = true;
          prev = curr;
        }
      }
    }
    const commands = [];
    for (const selection of selections) {
      if (selection.ignore) {
        continue;
      }
      commands.push(new CopyLinesCommand(selection.selection, this.down));
    }
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, commands);
    editor3.pushUndoStop();
  }
};
var CopyLinesUpAction = class extends AbstractCopyLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.copyLinesUpAction",
      label: localize("lines.copyUp", "Copy Line Up"),
      alias: "Copy Line Up",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 16,
        linux: {primary: 2048 | 512 | 1024 | 16},
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({key: "miCopyLinesUp", comment: ["&& denotes a mnemonic"]}, "&&Copy Line Up"),
        order: 1
      }
    });
  }
};
var CopyLinesDownAction = class extends AbstractCopyLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.copyLinesDownAction",
      label: localize("lines.copyDown", "Copy Line Down"),
      alias: "Copy Line Down",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 18,
        linux: {primary: 2048 | 512 | 1024 | 18},
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({key: "miCopyLinesDown", comment: ["&& denotes a mnemonic"]}, "Co&&py Line Down"),
        order: 2
      }
    });
  }
};
var DuplicateSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.duplicateSelection",
      label: localize("duplicateSelection", "Duplicate Selection"),
      alias: "Duplicate Selection",
      precondition: EditorContextKeys.writable,
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({key: "miDuplicateSelection", comment: ["&& denotes a mnemonic"]}, "&&Duplicate Selection"),
        order: 5
      }
    });
  }
  run(accessor, editor3, args) {
    if (!editor3.hasModel()) {
      return;
    }
    const commands = [];
    const selections = editor3.getSelections();
    const model = editor3.getModel();
    for (const selection of selections) {
      if (selection.isEmpty()) {
        commands.push(new CopyLinesCommand(selection, true));
      } else {
        const insertSelection = new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn);
        commands.push(new ReplaceCommandThatSelectsText(insertSelection, model.getValueInRange(selection)));
      }
    }
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, commands);
    editor3.pushUndoStop();
  }
};
var AbstractMoveLinesAction = class extends EditorAction {
  constructor(down, opts) {
    super(opts);
    this.down = down;
  }
  run(_accessor, editor3) {
    let commands = [];
    let selections = editor3.getSelections() || [];
    const autoIndent = editor3.getOption(8);
    for (const selection of selections) {
      commands.push(new MoveLinesCommand(selection, this.down, autoIndent));
    }
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, commands);
    editor3.pushUndoStop();
  }
};
var MoveLinesUpAction = class extends AbstractMoveLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.moveLinesUpAction",
      label: localize("lines.moveUp", "Move Line Up"),
      alias: "Move Line Up",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 16,
        linux: {primary: 512 | 16},
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({key: "miMoveLinesUp", comment: ["&& denotes a mnemonic"]}, "Mo&&ve Line Up"),
        order: 3
      }
    });
  }
};
var MoveLinesDownAction = class extends AbstractMoveLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.moveLinesDownAction",
      label: localize("lines.moveDown", "Move Line Down"),
      alias: "Move Line Down",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 18,
        linux: {primary: 512 | 18},
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({key: "miMoveLinesDown", comment: ["&& denotes a mnemonic"]}, "Move &&Line Down"),
        order: 4
      }
    });
  }
};
var AbstractSortLinesAction = class extends EditorAction {
  constructor(descending, opts) {
    super(opts);
    this.descending = descending;
  }
  run(_accessor, editor3) {
    const selections = editor3.getSelections() || [];
    for (const selection of selections) {
      if (!SortLinesCommand.canRun(editor3.getModel(), selection, this.descending)) {
        return;
      }
    }
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      commands[i] = new SortLinesCommand(selections[i], this.descending);
    }
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, commands);
    editor3.pushUndoStop();
  }
};
var SortLinesAscendingAction = class extends AbstractSortLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.sortLinesAscending",
      label: localize("lines.sortAscending", "Sort Lines Ascending"),
      alias: "Sort Lines Ascending",
      precondition: EditorContextKeys.writable
    });
  }
};
var SortLinesDescendingAction = class extends AbstractSortLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.sortLinesDescending",
      label: localize("lines.sortDescending", "Sort Lines Descending"),
      alias: "Sort Lines Descending",
      precondition: EditorContextKeys.writable
    });
  }
};
var TrimTrailingWhitespaceAction = class extends EditorAction {
  constructor() {
    super({
      id: TrimTrailingWhitespaceAction.ID,
      label: localize("lines.trimTrailingWhitespace", "Trim Trailing Whitespace"),
      alias: "Trim Trailing Whitespace",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 54),
        weight: 100
      }
    });
  }
  run(_accessor, editor3, args) {
    let cursors = [];
    if (args.reason === "auto-save") {
      cursors = (editor3.getSelections() || []).map((s) => new Position(s.positionLineNumber, s.positionColumn));
    }
    let selection = editor3.getSelection();
    if (selection === null) {
      return;
    }
    let command = new TrimTrailingWhitespaceCommand(selection, cursors);
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, [command]);
    editor3.pushUndoStop();
  }
};
TrimTrailingWhitespaceAction.ID = "editor.action.trimTrailingWhitespace";
var DeleteLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.deleteLines",
      label: localize("lines.delete", "Delete Line"),
      alias: "Delete Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1024 | 41,
        weight: 100
      }
    });
  }
  run(_accessor, editor3) {
    if (!editor3.hasModel()) {
      return;
    }
    let ops = this._getLinesToRemove(editor3);
    let model = editor3.getModel();
    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
      return;
    }
    let linesDeleted = 0;
    let edits = [];
    let cursorState = [];
    for (let i = 0, len = ops.length; i < len; i++) {
      const op = ops[i];
      let startLineNumber = op.startLineNumber;
      let endLineNumber = op.endLineNumber;
      let startColumn = 1;
      let endColumn = model.getLineMaxColumn(endLineNumber);
      if (endLineNumber < model.getLineCount()) {
        endLineNumber += 1;
        endColumn = 1;
      } else if (startLineNumber > 1) {
        startLineNumber -= 1;
        startColumn = model.getLineMaxColumn(startLineNumber);
      }
      edits.push(EditOperation.replace(new Selection(startLineNumber, startColumn, endLineNumber, endColumn), ""));
      cursorState.push(new Selection(startLineNumber - linesDeleted, op.positionColumn, startLineNumber - linesDeleted, op.positionColumn));
      linesDeleted += op.endLineNumber - op.startLineNumber + 1;
    }
    editor3.pushUndoStop();
    editor3.executeEdits(this.id, edits, cursorState);
    editor3.pushUndoStop();
  }
  _getLinesToRemove(editor3) {
    let operations = editor3.getSelections().map((s) => {
      let endLineNumber = s.endLineNumber;
      if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
        endLineNumber -= 1;
      }
      return {
        startLineNumber: s.startLineNumber,
        selectionStartColumn: s.selectionStartColumn,
        endLineNumber,
        positionColumn: s.positionColumn
      };
    });
    operations.sort((a, b) => {
      if (a.startLineNumber === b.startLineNumber) {
        return a.endLineNumber - b.endLineNumber;
      }
      return a.startLineNumber - b.startLineNumber;
    });
    let mergedOperations = [];
    let previousOperation = operations[0];
    for (let i = 1; i < operations.length; i++) {
      if (previousOperation.endLineNumber + 1 >= operations[i].startLineNumber) {
        previousOperation.endLineNumber = operations[i].endLineNumber;
      } else {
        mergedOperations.push(previousOperation);
        previousOperation = operations[i];
      }
    }
    mergedOperations.push(previousOperation);
    return mergedOperations;
  }
};
var IndentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.indentLines",
      label: localize("lines.indent", "Indent Line"),
      alias: "Indent Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 89,
        weight: 100
      }
    });
  }
  run(_accessor, editor3) {
    const viewModel = editor3._getViewModel();
    if (!viewModel) {
      return;
    }
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, TypeOperations.indent(viewModel.cursorConfig, editor3.getModel(), editor3.getSelections()));
    editor3.pushUndoStop();
  }
};
var OutdentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.outdentLines",
      label: localize("lines.outdent", "Outdent Line"),
      alias: "Outdent Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 87,
        weight: 100
      }
    });
  }
  run(_accessor, editor3) {
    CoreEditingCommands.Outdent.runEditorCommand(_accessor, editor3, null);
  }
};
var InsertLineBeforeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertLineBefore",
      label: localize("lines.insertBefore", "Insert Line Above"),
      alias: "Insert Line Above",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 3,
        weight: 100
      }
    });
  }
  run(_accessor, editor3) {
    const viewModel = editor3._getViewModel();
    if (!viewModel) {
      return;
    }
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, TypeOperations.lineInsertBefore(viewModel.cursorConfig, editor3.getModel(), editor3.getSelections()));
  }
};
var InsertLineAfterAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertLineAfter",
      label: localize("lines.insertAfter", "Insert Line Below"),
      alias: "Insert Line Below",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 3,
        weight: 100
      }
    });
  }
  run(_accessor, editor3) {
    const viewModel = editor3._getViewModel();
    if (!viewModel) {
      return;
    }
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, TypeOperations.lineInsertAfter(viewModel.cursorConfig, editor3.getModel(), editor3.getSelections()));
  }
};
var AbstractDeleteAllToBoundaryAction = class extends EditorAction {
  run(_accessor, editor3) {
    if (!editor3.hasModel()) {
      return;
    }
    const primaryCursor = editor3.getSelection();
    let rangesToDelete = this._getRangesToDelete(editor3);
    let effectiveRanges = [];
    for (let i = 0, count = rangesToDelete.length - 1; i < count; i++) {
      let range2 = rangesToDelete[i];
      let nextRange = rangesToDelete[i + 1];
      if (Range2.intersectRanges(range2, nextRange) === null) {
        effectiveRanges.push(range2);
      } else {
        rangesToDelete[i + 1] = Range2.plusRange(range2, nextRange);
      }
    }
    effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);
    let endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);
    let edits = effectiveRanges.map((range2) => {
      return EditOperation.replace(range2, "");
    });
    editor3.pushUndoStop();
    editor3.executeEdits(this.id, edits, endCursorState);
    editor3.pushUndoStop();
  }
};
var DeleteAllLeftAction = class extends AbstractDeleteAllToBoundaryAction {
  constructor() {
    super({
      id: "deleteAllLeft",
      label: localize("lines.deleteAllLeft", "Delete All Left"),
      alias: "Delete All Left",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {primary: 2048 | 1},
        weight: 100
      }
    });
  }
  _getEndCursorState(primaryCursor, rangesToDelete) {
    let endPrimaryCursor = null;
    let endCursorState = [];
    let deletedLines = 0;
    rangesToDelete.forEach((range2) => {
      let endCursor;
      if (range2.endColumn === 1 && deletedLines > 0) {
        let newStartLine = range2.startLineNumber - deletedLines;
        endCursor = new Selection(newStartLine, range2.startColumn, newStartLine, range2.startColumn);
      } else {
        endCursor = new Selection(range2.startLineNumber, range2.startColumn, range2.startLineNumber, range2.startColumn);
      }
      deletedLines += range2.endLineNumber - range2.startLineNumber;
      if (range2.intersectRanges(primaryCursor)) {
        endPrimaryCursor = endCursor;
      } else {
        endCursorState.push(endCursor);
      }
    });
    if (endPrimaryCursor) {
      endCursorState.unshift(endPrimaryCursor);
    }
    return endCursorState;
  }
  _getRangesToDelete(editor3) {
    let selections = editor3.getSelections();
    if (selections === null) {
      return [];
    }
    let rangesToDelete = selections;
    let model = editor3.getModel();
    if (model === null) {
      return [];
    }
    rangesToDelete.sort(Range2.compareRangesUsingStarts);
    rangesToDelete = rangesToDelete.map((selection) => {
      if (selection.isEmpty()) {
        if (selection.startColumn === 1) {
          let deleteFromLine = Math.max(1, selection.startLineNumber - 1);
          let deleteFromColumn = selection.startLineNumber === 1 ? 1 : model.getLineContent(deleteFromLine).length + 1;
          return new Range2(deleteFromLine, deleteFromColumn, selection.startLineNumber, 1);
        } else {
          return new Range2(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);
        }
      } else {
        return new Range2(selection.startLineNumber, 1, selection.endLineNumber, selection.endColumn);
      }
    });
    return rangesToDelete;
  }
};
var DeleteAllRightAction = class extends AbstractDeleteAllToBoundaryAction {
  constructor() {
    super({
      id: "deleteAllRight",
      label: localize("lines.deleteAllRight", "Delete All Right"),
      alias: "Delete All Right",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {primary: 256 | 41, secondary: [2048 | 20]},
        weight: 100
      }
    });
  }
  _getEndCursorState(primaryCursor, rangesToDelete) {
    let endPrimaryCursor = null;
    let endCursorState = [];
    for (let i = 0, len = rangesToDelete.length, offset = 0; i < len; i++) {
      let range2 = rangesToDelete[i];
      let endCursor = new Selection(range2.startLineNumber - offset, range2.startColumn, range2.startLineNumber - offset, range2.startColumn);
      if (range2.intersectRanges(primaryCursor)) {
        endPrimaryCursor = endCursor;
      } else {
        endCursorState.push(endCursor);
      }
    }
    if (endPrimaryCursor) {
      endCursorState.unshift(endPrimaryCursor);
    }
    return endCursorState;
  }
  _getRangesToDelete(editor3) {
    let model = editor3.getModel();
    if (model === null) {
      return [];
    }
    let selections = editor3.getSelections();
    if (selections === null) {
      return [];
    }
    let rangesToDelete = selections.map((sel) => {
      if (sel.isEmpty()) {
        const maxColumn = model.getLineMaxColumn(sel.startLineNumber);
        if (sel.startColumn === maxColumn) {
          return new Range2(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);
        } else {
          return new Range2(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);
        }
      }
      return sel;
    });
    rangesToDelete.sort(Range2.compareRangesUsingStarts);
    return rangesToDelete;
  }
};
var JoinLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.joinLines",
      label: localize("lines.joinLines", "Join Lines"),
      alias: "Join Lines",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        mac: {primary: 256 | 40},
        weight: 100
      }
    });
  }
  run(_accessor, editor3) {
    let selections = editor3.getSelections();
    if (selections === null) {
      return;
    }
    let primaryCursor = editor3.getSelection();
    if (primaryCursor === null) {
      return;
    }
    selections.sort(Range2.compareRangesUsingStarts);
    let reducedSelections = [];
    let lastSelection = selections.reduce((previousValue, currentValue) => {
      if (previousValue.isEmpty()) {
        if (previousValue.endLineNumber === currentValue.startLineNumber) {
          if (primaryCursor.equalsSelection(previousValue)) {
            primaryCursor = currentValue;
          }
          return currentValue;
        }
        if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {
          reducedSelections.push(previousValue);
          return currentValue;
        } else {
          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
        }
      } else {
        if (currentValue.startLineNumber > previousValue.endLineNumber) {
          reducedSelections.push(previousValue);
          return currentValue;
        } else {
          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
        }
      }
    });
    reducedSelections.push(lastSelection);
    let model = editor3.getModel();
    if (model === null) {
      return;
    }
    let edits = [];
    let endCursorState = [];
    let endPrimaryCursor = primaryCursor;
    let lineOffset = 0;
    for (let i = 0, len = reducedSelections.length; i < len; i++) {
      let selection = reducedSelections[i];
      let startLineNumber = selection.startLineNumber;
      let startColumn = 1;
      let columnDeltaOffset = 0;
      let endLineNumber, endColumn;
      let selectionEndPositionOffset = model.getLineContent(selection.endLineNumber).length - selection.endColumn;
      if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {
        let position = selection.getStartPosition();
        if (position.lineNumber < model.getLineCount()) {
          endLineNumber = startLineNumber + 1;
          endColumn = model.getLineMaxColumn(endLineNumber);
        } else {
          endLineNumber = position.lineNumber;
          endColumn = model.getLineMaxColumn(position.lineNumber);
        }
      } else {
        endLineNumber = selection.endLineNumber;
        endColumn = model.getLineMaxColumn(endLineNumber);
      }
      let trimmedLinesContent = model.getLineContent(startLineNumber);
      for (let i2 = startLineNumber + 1; i2 <= endLineNumber; i2++) {
        let lineText = model.getLineContent(i2);
        let firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i2);
        if (firstNonWhitespaceIdx >= 1) {
          let insertSpace = true;
          if (trimmedLinesContent === "") {
            insertSpace = false;
          }
          if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === " " || trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === "	")) {
            insertSpace = false;
            trimmedLinesContent = trimmedLinesContent.replace(/[\s\uFEFF\xA0]+$/g, " ");
          }
          let lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);
          trimmedLinesContent += (insertSpace ? " " : "") + lineTextWithoutIndent;
          if (insertSpace) {
            columnDeltaOffset = lineTextWithoutIndent.length + 1;
          } else {
            columnDeltaOffset = lineTextWithoutIndent.length;
          }
        } else {
          columnDeltaOffset = 0;
        }
      }
      let deleteSelection = new Range2(startLineNumber, startColumn, endLineNumber, endColumn);
      if (!deleteSelection.isEmpty()) {
        let resultSelection;
        if (selection.isEmpty()) {
          edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
          resultSelection = new Selection(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);
        } else {
          if (selection.startLineNumber === selection.endLineNumber) {
            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);
          } else {
            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);
          }
        }
        if (Range2.intersectRanges(deleteSelection, primaryCursor) !== null) {
          endPrimaryCursor = resultSelection;
        } else {
          endCursorState.push(resultSelection);
        }
      }
      lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;
    }
    endCursorState.unshift(endPrimaryCursor);
    editor3.pushUndoStop();
    editor3.executeEdits(this.id, edits, endCursorState);
    editor3.pushUndoStop();
  }
};
var TransposeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.transpose",
      label: localize("editor.transpose", "Transpose characters around the cursor"),
      alias: "Transpose characters around the cursor",
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor3) {
    let selections = editor3.getSelections();
    if (selections === null) {
      return;
    }
    let model = editor3.getModel();
    if (model === null) {
      return;
    }
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      let selection = selections[i];
      if (!selection.isEmpty()) {
        continue;
      }
      let cursor = selection.getStartPosition();
      let maxColumn = model.getLineMaxColumn(cursor.lineNumber);
      if (cursor.column >= maxColumn) {
        if (cursor.lineNumber === model.getLineCount()) {
          continue;
        }
        let deleteSelection = new Range2(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);
        let chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
        commands.push(new ReplaceCommand(new Selection(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));
      } else {
        let deleteSelection = new Range2(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);
        let chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
        commands.push(new ReplaceCommandThatPreservesSelection(deleteSelection, chars, new Selection(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));
      }
    }
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, commands);
    editor3.pushUndoStop();
  }
};
var AbstractCaseAction = class extends EditorAction {
  run(_accessor, editor3) {
    let selections = editor3.getSelections();
    if (selections === null) {
      return;
    }
    let model = editor3.getModel();
    if (model === null) {
      return;
    }
    let wordSeparators2 = editor3.getOption(105);
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      let selection = selections[i];
      if (selection.isEmpty()) {
        let cursor = selection.getStartPosition();
        const word = editor3.getConfiguredWordAtPosition(cursor);
        if (!word) {
          continue;
        }
        let wordRange = new Range2(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);
        let text = model.getValueInRange(wordRange);
        commands.push(new ReplaceCommandThatPreservesSelection(wordRange, this._modifyText(text, wordSeparators2), new Selection(cursor.lineNumber, cursor.column, cursor.lineNumber, cursor.column)));
      } else {
        let text = model.getValueInRange(selection);
        commands.push(new ReplaceCommandThatPreservesSelection(selection, this._modifyText(text, wordSeparators2), selection));
      }
    }
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, commands);
    editor3.pushUndoStop();
  }
};
var UpperCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToUppercase",
      label: localize("editor.transformToUppercase", "Transform to Uppercase"),
      alias: "Transform to Uppercase",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators2) {
    return text.toLocaleUpperCase();
  }
};
var LowerCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToLowercase",
      label: localize("editor.transformToLowercase", "Transform to Lowercase"),
      alias: "Transform to Lowercase",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators2) {
    return text.toLocaleLowerCase();
  }
};
var TitleCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToTitlecase",
      label: localize("editor.transformToTitlecase", "Transform to Title Case"),
      alias: "Transform to Title Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators2) {
    const separators = "\r\n	 " + wordSeparators2;
    const excludedChars = separators.split("");
    let title = "";
    let startUpperCase = true;
    for (let i = 0; i < text.length; i++) {
      let currentChar = text[i];
      if (excludedChars.indexOf(currentChar) >= 0) {
        startUpperCase = true;
        title += currentChar;
      } else if (startUpperCase) {
        startUpperCase = false;
        title += currentChar.toLocaleUpperCase();
      } else {
        title += currentChar.toLocaleLowerCase();
      }
    }
    return title;
  }
};
registerEditorAction(CopyLinesUpAction);
registerEditorAction(CopyLinesDownAction);
registerEditorAction(DuplicateSelectionAction);
registerEditorAction(MoveLinesUpAction);
registerEditorAction(MoveLinesDownAction);
registerEditorAction(SortLinesAscendingAction);
registerEditorAction(SortLinesDescendingAction);
registerEditorAction(TrimTrailingWhitespaceAction);
registerEditorAction(DeleteLinesAction);
registerEditorAction(IndentLinesAction);
registerEditorAction(OutdentLinesAction);
registerEditorAction(InsertLineBeforeAction);
registerEditorAction(InsertLineAfterAction);
registerEditorAction(DeleteAllLeftAction);
registerEditorAction(DeleteAllRightAction);
registerEditorAction(JoinLinesAction);
registerEditorAction(TransposeAction);
registerEditorAction(UpperCaseAction);
registerEditorAction(LowerCaseAction);
registerEditorAction(TitleCaseAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/links/getLinks.js
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Link2 = class {
  constructor(link, provider) {
    this._link = link;
    this._provider = provider;
  }
  toJSON() {
    return {
      range: this.range,
      url: this.url,
      tooltip: this.tooltip
    };
  }
  get range() {
    return this._link.range;
  }
  get url() {
    return this._link.url;
  }
  get tooltip() {
    return this._link.tooltip;
  }
  resolve(token) {
    return __awaiter19(this, void 0, void 0, function* () {
      if (this._link.url) {
        return this._link.url;
      }
      if (typeof this._provider.resolveLink === "function") {
        return Promise.resolve(this._provider.resolveLink(this._link, token)).then((value) => {
          this._link = value || this._link;
          if (this._link.url) {
            return this.resolve(token);
          }
          return Promise.reject(new Error("missing"));
        });
      }
      return Promise.reject(new Error("missing"));
    });
  }
};
var LinksList = class extends Disposable {
  constructor(tuples) {
    super();
    let links = [];
    for (const [list, provider] of tuples) {
      const newLinks = list.links.map((link) => new Link2(link, provider));
      links = LinksList._union(links, newLinks);
      if (isDisposable(list)) {
        this._register(list);
      }
    }
    this.links = links;
  }
  static _union(oldLinks, newLinks) {
    let result = [];
    let oldIndex;
    let oldLen;
    let newIndex;
    let newLen;
    for (oldIndex = 0, newIndex = 0, oldLen = oldLinks.length, newLen = newLinks.length; oldIndex < oldLen && newIndex < newLen; ) {
      const oldLink = oldLinks[oldIndex];
      const newLink = newLinks[newIndex];
      if (Range2.areIntersectingOrTouching(oldLink.range, newLink.range)) {
        oldIndex++;
        continue;
      }
      const comparisonResult = Range2.compareRangesUsingStarts(oldLink.range, newLink.range);
      if (comparisonResult < 0) {
        result.push(oldLink);
        oldIndex++;
      } else {
        result.push(newLink);
        newIndex++;
      }
    }
    for (; oldIndex < oldLen; oldIndex++) {
      result.push(oldLinks[oldIndex]);
    }
    for (; newIndex < newLen; newIndex++) {
      result.push(newLinks[newIndex]);
    }
    return result;
  }
};
function getLinks(model, token) {
  const lists = [];
  const promises = LinkProviderRegistry.ordered(model).reverse().map((provider, i) => {
    return Promise.resolve(provider.provideLinks(model, token)).then((result) => {
      if (result) {
        lists[i] = [result, provider];
      }
    }, onUnexpectedExternalError);
  });
  return Promise.all(promises).then(() => {
    const result = new LinksList(coalesce(lists));
    if (!token.isCancellationRequested) {
      return result;
    }
    result.dispose();
    return new LinksList([]);
  });
}
CommandsRegistry.registerCommand("_executeLinkProvider", (accessor, ...args) => __awaiter19(void 0, void 0, void 0, function* () {
  const [uri] = args;
  if (!(uri instanceof URI)) {
    return [];
  }
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return [];
  }
  const list = yield getLinks(model, CancellationToken.None);
  if (!list) {
    return [];
  }
  const result = list.links.slice(0);
  list.dispose();
  return result;
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/links/links.js
var __decorate29 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param29 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getHoverMessage(link, useMetaKey) {
  const executeCmd = link.url && /^command:/i.test(link.url.toString());
  const label = link.tooltip ? link.tooltip : executeCmd ? localize("links.navigate.executeCmd", "Execute command") : localize("links.navigate.follow", "Follow link");
  const kb = useMetaKey ? isMacintosh ? localize("links.navigate.kb.meta.mac", "cmd + click") : localize("links.navigate.kb.meta", "ctrl + click") : isMacintosh ? localize("links.navigate.kb.alt.mac", "option + click") : localize("links.navigate.kb.alt", "alt + click");
  if (link.url) {
    const hoverMessage = new MarkdownString("", true).appendMarkdown(`[${label}](${link.url.toString()}) (${kb})`);
    return hoverMessage;
  } else {
    return new MarkdownString().appendText(`${label} (${kb})`);
  }
}
var decoration = {
  general: ModelDecorationOptions.register({
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: "detected-link"
  }),
  active: ModelDecorationOptions.register({
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: "detected-link-active"
  })
};
var LinkOccurrence = class {
  constructor(link, decorationId) {
    this.link = link;
    this.decorationId = decorationId;
  }
  static decoration(link, useMetaKey) {
    return {
      range: link.range,
      options: LinkOccurrence._getOptions(link, useMetaKey, false)
    };
  }
  static _getOptions(link, useMetaKey, isActive) {
    const options = Object.assign({}, isActive ? decoration.active : decoration.general);
    options.hoverMessage = getHoverMessage(link, useMetaKey);
    return options;
  }
  activate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, true));
  }
  deactivate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, false));
  }
};
var LinkDetector = class LinkDetector2 {
  constructor(editor3, openerService, notificationService) {
    this.listenersToRemove = new DisposableStore();
    this.editor = editor3;
    this.openerService = openerService;
    this.notificationService = notificationService;
    let clickLinkGesture = new ClickLinkGesture(editor3);
    this.listenersToRemove.add(clickLinkGesture);
    this.listenersToRemove.add(clickLinkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
      this._onEditorMouseMove(mouseEvent, keyboardEvent);
    }));
    this.listenersToRemove.add(clickLinkGesture.onExecute((e) => {
      this.onEditorMouseUp(e);
    }));
    this.listenersToRemove.add(clickLinkGesture.onCancel((e) => {
      this.cleanUpActiveLinkDecoration();
    }));
    this.enabled = editor3.getOption(54);
    this.listenersToRemove.add(editor3.onDidChangeConfiguration((e) => {
      const enabled = editor3.getOption(54);
      if (this.enabled === enabled) {
        return;
      }
      this.enabled = enabled;
      this.updateDecorations([]);
      this.stop();
      this.beginCompute();
    }));
    this.listenersToRemove.add(editor3.onDidChangeModelContent((e) => this.onChange()));
    this.listenersToRemove.add(editor3.onDidChangeModel((e) => this.onModelChanged()));
    this.listenersToRemove.add(editor3.onDidChangeModelLanguage((e) => this.onModelModeChanged()));
    this.listenersToRemove.add(LinkProviderRegistry.onDidChange((e) => this.onModelModeChanged()));
    this.timeout = new TimeoutTimer();
    this.computePromise = null;
    this.activeLinksList = null;
    this.currentOccurrences = {};
    this.activeLinkDecorationId = null;
    this.beginCompute();
  }
  static get(editor3) {
    return editor3.getContribution(LinkDetector2.ID);
  }
  onModelChanged() {
    this.currentOccurrences = {};
    this.activeLinkDecorationId = null;
    this.stop();
    this.beginCompute();
  }
  onModelModeChanged() {
    this.stop();
    this.beginCompute();
  }
  onChange() {
    this.timeout.setIfNotSet(() => this.beginCompute(), LinkDetector2.RECOMPUTE_TIME);
  }
  beginCompute() {
    return __awaiter20(this, void 0, void 0, function* () {
      if (!this.editor.hasModel() || !this.enabled) {
        return;
      }
      const model = this.editor.getModel();
      if (!LinkProviderRegistry.has(model)) {
        return;
      }
      if (this.activeLinksList) {
        this.activeLinksList.dispose();
        this.activeLinksList = null;
      }
      this.computePromise = createCancelablePromise((token) => getLinks(model, token));
      try {
        this.activeLinksList = yield this.computePromise;
        this.updateDecorations(this.activeLinksList.links);
      } catch (err) {
        onUnexpectedError(err);
      } finally {
        this.computePromise = null;
      }
    });
  }
  updateDecorations(links) {
    const useMetaKey = this.editor.getOption(61) === "altKey";
    let oldDecorations = [];
    let keys = Object.keys(this.currentOccurrences);
    for (let i = 0, len = keys.length; i < len; i++) {
      let decorationId = keys[i];
      let occurance = this.currentOccurrences[decorationId];
      oldDecorations.push(occurance.decorationId);
    }
    let newDecorations = [];
    if (links) {
      for (const link of links) {
        newDecorations.push(LinkOccurrence.decoration(link, useMetaKey));
      }
    }
    let decorations = this.editor.deltaDecorations(oldDecorations, newDecorations);
    this.currentOccurrences = {};
    this.activeLinkDecorationId = null;
    for (let i = 0, len = decorations.length; i < len; i++) {
      let occurance = new LinkOccurrence(links[i], decorations[i]);
      this.currentOccurrences[occurance.decorationId] = occurance;
    }
  }
  _onEditorMouseMove(mouseEvent, withKey) {
    const useMetaKey = this.editor.getOption(61) === "altKey";
    if (this.isEnabled(mouseEvent, withKey)) {
      this.cleanUpActiveLinkDecoration();
      const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
      if (occurrence) {
        this.editor.changeDecorations((changeAccessor) => {
          occurrence.activate(changeAccessor, useMetaKey);
          this.activeLinkDecorationId = occurrence.decorationId;
        });
      }
    } else {
      this.cleanUpActiveLinkDecoration();
    }
  }
  cleanUpActiveLinkDecoration() {
    const useMetaKey = this.editor.getOption(61) === "altKey";
    if (this.activeLinkDecorationId) {
      const occurrence = this.currentOccurrences[this.activeLinkDecorationId];
      if (occurrence) {
        this.editor.changeDecorations((changeAccessor) => {
          occurrence.deactivate(changeAccessor, useMetaKey);
        });
      }
      this.activeLinkDecorationId = null;
    }
  }
  onEditorMouseUp(mouseEvent) {
    if (!this.isEnabled(mouseEvent)) {
      return;
    }
    const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
    if (!occurrence) {
      return;
    }
    this.openLinkOccurrence(occurrence, mouseEvent.hasSideBySideModifier, true);
  }
  openLinkOccurrence(occurrence, openToSide, fromUserGesture = false) {
    if (!this.openerService) {
      return;
    }
    const {link} = occurrence;
    link.resolve(CancellationToken.None).then((uri) => {
      if (typeof uri === "string" && this.editor.hasModel()) {
        const modelUri = this.editor.getModel().uri;
        if (modelUri.scheme === Schemas.file && startsWith(uri, "file:")) {
          const parsedUri = URI.parse(uri);
          if (parsedUri.scheme === Schemas.file) {
            const fsPath = originalFSPath(parsedUri);
            let relativePath2 = null;
            if (startsWith(fsPath, "/./")) {
              relativePath2 = `.${fsPath.substr(1)}`;
            } else if (startsWith(fsPath, "//./")) {
              relativePath2 = `.${fsPath.substr(2)}`;
            }
            if (relativePath2) {
              uri = joinPath(modelUri, relativePath2);
            }
          }
        }
      }
      return this.openerService.open(uri, {openToSide, fromUserGesture});
    }, (err) => {
      const messageOrError = err instanceof Error ? err.message : err;
      if (messageOrError === "invalid") {
        this.notificationService.warn(localize("invalid.url", "Failed to open this link because it is not well-formed: {0}", link.url.toString()));
      } else if (messageOrError === "missing") {
        this.notificationService.warn(localize("missing.url", "Failed to open this link because its target is missing."));
      } else {
        onUnexpectedError(err);
      }
    });
  }
  getLinkOccurrence(position) {
    if (!this.editor.hasModel() || !position) {
      return null;
    }
    const decorations = this.editor.getModel().getDecorationsInRange({
      startLineNumber: position.lineNumber,
      startColumn: position.column,
      endLineNumber: position.lineNumber,
      endColumn: position.column
    }, 0, true);
    for (const decoration2 of decorations) {
      const currentOccurrence = this.currentOccurrences[decoration2.id];
      if (currentOccurrence) {
        return currentOccurrence;
      }
    }
    return null;
  }
  isEnabled(mouseEvent, withKey) {
    return Boolean(mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || withKey && withKey.keyCodeIsTriggerKey));
  }
  stop() {
    this.timeout.cancel();
    if (this.activeLinksList) {
      this.activeLinksList.dispose();
    }
    if (this.computePromise) {
      this.computePromise.cancel();
      this.computePromise = null;
    }
  }
  dispose() {
    this.listenersToRemove.dispose();
    this.stop();
    this.timeout.dispose();
  }
};
LinkDetector.ID = "editor.linkDetector";
LinkDetector.RECOMPUTE_TIME = 1e3;
LinkDetector = __decorate29([
  __param29(1, IOpenerService),
  __param29(2, INotificationService)
], LinkDetector);
var OpenLinkAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.openLink",
      label: localize("label", "Open Link"),
      alias: "Open Link",
      precondition: void 0
    });
  }
  run(accessor, editor3) {
    let linkDetector = LinkDetector.get(editor3);
    if (!linkDetector) {
      return;
    }
    if (!editor3.hasModel()) {
      return;
    }
    let selections = editor3.getSelections();
    for (let sel of selections) {
      let link = linkDetector.getLinkOccurrence(sel.getEndPosition());
      if (link) {
        linkDetector.openLinkOccurrence(link, false);
      }
    }
  }
};
registerEditorContribution(LinkDetector.ID, LinkDetector);
registerEditorAction(OpenLinkAction);
registerThemingParticipant((theme6, collector) => {
  const activeLinkForeground = theme6.getColor(editorActiveLinkForeground);
  if (activeLinkForeground) {
    collector.addRule(`.monaco-editor .detected-link-active { color: ${activeLinkForeground} !important; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/multicursor/multicursor.js
var InsertCursorAbove = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorAbove",
      label: localize("mutlicursor.insertAbove", "Add Cursor Above"),
      alias: "Add Cursor Above",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 16,
        linux: {
          primary: 1024 | 512 | 16,
          secondary: [2048 | 1024 | 16]
        },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({key: "miInsertCursorAbove", comment: ["&& denotes a mnemonic"]}, "&&Add Cursor Above"),
        order: 2
      }
    });
  }
  run(accessor, editor3, args) {
    if (!editor3.hasModel()) {
      return;
    }
    const useLogicalLine = args && args.logicalLine === true;
    const viewModel = editor3._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.pushStackElement();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorUp(viewModel, viewModel.getCursorStates(), useLogicalLine));
    viewModel.revealTopMostCursor(args.source);
  }
};
var InsertCursorBelow = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorBelow",
      label: localize("mutlicursor.insertBelow", "Add Cursor Below"),
      alias: "Add Cursor Below",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 18,
        linux: {
          primary: 1024 | 512 | 18,
          secondary: [2048 | 1024 | 18]
        },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({key: "miInsertCursorBelow", comment: ["&& denotes a mnemonic"]}, "A&&dd Cursor Below"),
        order: 3
      }
    });
  }
  run(accessor, editor3, args) {
    if (!editor3.hasModel()) {
      return;
    }
    const useLogicalLine = args && args.logicalLine === true;
    const viewModel = editor3._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.pushStackElement();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorDown(viewModel, viewModel.getCursorStates(), useLogicalLine));
    viewModel.revealBottomMostCursor(args.source);
  }
};
var InsertCursorAtEndOfEachLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorAtEndOfEachLineSelected",
      label: localize("mutlicursor.insertAtEndOfEachLineSelected", "Add Cursors to Line Ends"),
      alias: "Add Cursors to Line Ends",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 39,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({key: "miInsertCursorAtEndOfEachLineSelected", comment: ["&& denotes a mnemonic"]}, "Add C&&ursors to Line Ends"),
        order: 4
      }
    });
  }
  getCursorsForSelection(selection, model, result) {
    if (selection.isEmpty()) {
      return;
    }
    for (let i = selection.startLineNumber; i < selection.endLineNumber; i++) {
      let currentLineMaxColumn = model.getLineMaxColumn(i);
      result.push(new Selection(i, currentLineMaxColumn, i, currentLineMaxColumn));
    }
    if (selection.endColumn > 1) {
      result.push(new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn));
    }
  }
  run(accessor, editor3) {
    if (!editor3.hasModel()) {
      return;
    }
    const model = editor3.getModel();
    const selections = editor3.getSelections();
    let newSelections = [];
    selections.forEach((sel) => this.getCursorsForSelection(sel, model, newSelections));
    if (newSelections.length > 0) {
      editor3.setSelections(newSelections);
    }
  }
};
var InsertCursorAtEndOfLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.addCursorsToBottom",
      label: localize("mutlicursor.addCursorsToBottom", "Add Cursors To Bottom"),
      alias: "Add Cursors To Bottom",
      precondition: void 0
    });
  }
  run(accessor, editor3) {
    if (!editor3.hasModel()) {
      return;
    }
    const selections = editor3.getSelections();
    const lineCount = editor3.getModel().getLineCount();
    let newSelections = [];
    for (let i = selections[0].startLineNumber; i <= lineCount; i++) {
      newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));
    }
    if (newSelections.length > 0) {
      editor3.setSelections(newSelections);
    }
  }
};
var InsertCursorAtTopOfLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.addCursorsToTop",
      label: localize("mutlicursor.addCursorsToTop", "Add Cursors To Top"),
      alias: "Add Cursors To Top",
      precondition: void 0
    });
  }
  run(accessor, editor3) {
    if (!editor3.hasModel()) {
      return;
    }
    const selections = editor3.getSelections();
    let newSelections = [];
    for (let i = selections[0].startLineNumber; i >= 1; i--) {
      newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));
    }
    if (newSelections.length > 0) {
      editor3.setSelections(newSelections);
    }
  }
};
var MultiCursorSessionResult = class {
  constructor(selections, revealRange, revealScrollType) {
    this.selections = selections;
    this.revealRange = revealRange;
    this.revealScrollType = revealScrollType;
  }
};
var MultiCursorSession = class {
  constructor(_editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch) {
    this._editor = _editor;
    this.findController = findController;
    this.isDisconnectedFromFindController = isDisconnectedFromFindController;
    this.searchText = searchText;
    this.wholeWord = wholeWord;
    this.matchCase = matchCase;
    this.currentMatch = currentMatch;
  }
  static create(editor3, findController) {
    if (!editor3.hasModel()) {
      return null;
    }
    const findState = findController.getState();
    if (!editor3.hasTextFocus() && findState.isRevealed && findState.searchString.length > 0) {
      return new MultiCursorSession(editor3, findController, false, findState.searchString, findState.wholeWord, findState.matchCase, null);
    }
    let isDisconnectedFromFindController = false;
    let wholeWord;
    let matchCase;
    const selections = editor3.getSelections();
    if (selections.length === 1 && selections[0].isEmpty()) {
      isDisconnectedFromFindController = true;
      wholeWord = true;
      matchCase = true;
    } else {
      wholeWord = findState.wholeWord;
      matchCase = findState.matchCase;
    }
    const s = editor3.getSelection();
    let searchText;
    let currentMatch = null;
    if (s.isEmpty()) {
      const word = editor3.getConfiguredWordAtPosition(s.getStartPosition());
      if (!word) {
        return null;
      }
      searchText = word.word;
      currentMatch = new Selection(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);
    } else {
      searchText = editor3.getModel().getValueInRange(s).replace(/\r\n/g, "\n");
    }
    return new MultiCursorSession(editor3, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch);
  }
  addSelectionToNextFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const nextMatch = this._getNextMatch();
    if (!nextMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(allSelections.concat(nextMatch), nextMatch, 0);
  }
  moveSelectionToNextFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const nextMatch = this._getNextMatch();
    if (!nextMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(nextMatch), nextMatch, 0);
  }
  _getNextMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    if (this.currentMatch) {
      const result = this.currentMatch;
      this.currentMatch = null;
      return result;
    }
    this.findController.highlightFindOptions();
    const allSelections = this._editor.getSelections();
    const lastAddedSelection = allSelections[allSelections.length - 1];
    const nextMatch = this._editor.getModel().findNextMatch(this.searchText, lastAddedSelection.getEndPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(105) : null, false);
    if (!nextMatch) {
      return null;
    }
    return new Selection(nextMatch.range.startLineNumber, nextMatch.range.startColumn, nextMatch.range.endLineNumber, nextMatch.range.endColumn);
  }
  addSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const previousMatch = this._getPreviousMatch();
    if (!previousMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(allSelections.concat(previousMatch), previousMatch, 0);
  }
  moveSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const previousMatch = this._getPreviousMatch();
    if (!previousMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(previousMatch), previousMatch, 0);
  }
  _getPreviousMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    if (this.currentMatch) {
      const result = this.currentMatch;
      this.currentMatch = null;
      return result;
    }
    this.findController.highlightFindOptions();
    const allSelections = this._editor.getSelections();
    const lastAddedSelection = allSelections[allSelections.length - 1];
    const previousMatch = this._editor.getModel().findPreviousMatch(this.searchText, lastAddedSelection.getStartPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(105) : null, false);
    if (!previousMatch) {
      return null;
    }
    return new Selection(previousMatch.range.startLineNumber, previousMatch.range.startColumn, previousMatch.range.endLineNumber, previousMatch.range.endColumn);
  }
  selectAll() {
    if (!this._editor.hasModel()) {
      return [];
    }
    this.findController.highlightFindOptions();
    return this._editor.getModel().findMatches(this.searchText, true, false, this.matchCase, this.wholeWord ? this._editor.getOption(105) : null, false, 1073741824);
  }
};
var MultiCursorSelectionController = class extends Disposable {
  constructor(editor3) {
    super();
    this._sessionDispose = this._register(new DisposableStore());
    this._editor = editor3;
    this._ignoreSelectionChange = false;
    this._session = null;
  }
  static get(editor3) {
    return editor3.getContribution(MultiCursorSelectionController.ID);
  }
  dispose() {
    this._endSession();
    super.dispose();
  }
  _beginSessionIfNeeded(findController) {
    if (!this._session) {
      const session = MultiCursorSession.create(this._editor, findController);
      if (!session) {
        return;
      }
      this._session = session;
      const newState = {searchString: this._session.searchText};
      if (this._session.isDisconnectedFromFindController) {
        newState.wholeWordOverride = 1;
        newState.matchCaseOverride = 1;
        newState.isRegexOverride = 2;
      }
      findController.getState().change(newState, false);
      this._sessionDispose.add(this._editor.onDidChangeCursorSelection((e) => {
        if (this._ignoreSelectionChange) {
          return;
        }
        this._endSession();
      }));
      this._sessionDispose.add(this._editor.onDidBlurEditorText(() => {
        this._endSession();
      }));
      this._sessionDispose.add(findController.getState().onFindReplaceStateChange((e) => {
        if (e.matchCase || e.wholeWord) {
          this._endSession();
        }
      }));
    }
  }
  _endSession() {
    this._sessionDispose.clear();
    if (this._session && this._session.isDisconnectedFromFindController) {
      const newState = {
        wholeWordOverride: 0,
        matchCaseOverride: 0,
        isRegexOverride: 0
      };
      this._session.findController.getState().change(newState, false);
    }
    this._session = null;
  }
  _setSelections(selections) {
    this._ignoreSelectionChange = true;
    this._editor.setSelections(selections);
    this._ignoreSelectionChange = false;
  }
  _expandEmptyToWord(model, selection) {
    if (!selection.isEmpty()) {
      return selection;
    }
    const word = this._editor.getConfiguredWordAtPosition(selection.getStartPosition());
    if (!word) {
      return selection;
    }
    return new Selection(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
  }
  _applySessionResult(result) {
    if (!result) {
      return;
    }
    this._setSelections(result.selections);
    if (result.revealRange) {
      this._editor.revealRangeInCenterIfOutsideViewport(result.revealRange, result.revealScrollType);
    }
  }
  getSession(findController) {
    return this._session;
  }
  addSelectionToNextFindMatch(findController) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._session) {
      const allSelections = this._editor.getSelections();
      if (allSelections.length > 1) {
        const findState = findController.getState();
        const matchCase = findState.matchCase;
        const selectionsContainSameText = modelRangesContainSameText(this._editor.getModel(), allSelections, matchCase);
        if (!selectionsContainSameText) {
          const model = this._editor.getModel();
          let resultingSelections = [];
          for (let i = 0, len = allSelections.length; i < len; i++) {
            resultingSelections[i] = this._expandEmptyToWord(model, allSelections[i]);
          }
          this._editor.setSelections(resultingSelections);
          return;
        }
      }
    }
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.addSelectionToNextFindMatch());
    }
  }
  addSelectionToPreviousFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.addSelectionToPreviousFindMatch());
    }
  }
  moveSelectionToNextFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.moveSelectionToNextFindMatch());
    }
  }
  moveSelectionToPreviousFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());
    }
  }
  selectAll(findController) {
    if (!this._editor.hasModel()) {
      return;
    }
    let matches = null;
    const findState = findController.getState();
    if (findState.isRevealed && findState.searchString.length > 0 && findState.isRegex) {
      matches = this._editor.getModel().findMatches(findState.searchString, true, findState.isRegex, findState.matchCase, findState.wholeWord ? this._editor.getOption(105) : null, false, 1073741824);
    } else {
      this._beginSessionIfNeeded(findController);
      if (!this._session) {
        return;
      }
      matches = this._session.selectAll();
    }
    if (findState.searchScope) {
      const states = findState.searchScope;
      let inSelection = [];
      matches.forEach((match) => {
        states.forEach((state) => {
          if (match.range.endLineNumber <= state.endLineNumber && match.range.startLineNumber >= state.startLineNumber) {
            inSelection.push(match);
          }
        });
      });
      matches = inSelection;
    }
    if (matches.length > 0) {
      const editorSelection = this._editor.getSelection();
      for (let i = 0, len = matches.length; i < len; i++) {
        const match = matches[i];
        const intersection = match.range.intersectRanges(editorSelection);
        if (intersection) {
          matches[i] = matches[0];
          matches[0] = match;
          break;
        }
      }
      this._setSelections(matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)));
    }
  }
};
MultiCursorSelectionController.ID = "editor.contrib.multiCursorController";
var MultiCursorSelectionControllerAction = class extends EditorAction {
  run(accessor, editor3) {
    const multiCursorController = MultiCursorSelectionController.get(editor3);
    if (!multiCursorController) {
      return;
    }
    const findController = CommonFindController.get(editor3);
    if (!findController) {
      return;
    }
    this._run(multiCursorController, findController);
  }
};
var AddSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.addSelectionToNextFindMatch",
      label: localize("addSelectionToNextFindMatch", "Add Selection To Next Find Match"),
      alias: "Add Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 34,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({key: "miAddSelectionToNextFindMatch", comment: ["&& denotes a mnemonic"]}, "Add &&Next Occurrence"),
        order: 5
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.addSelectionToNextFindMatch(findController);
  }
};
var AddSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.addSelectionToPreviousFindMatch",
      label: localize("addSelectionToPreviousFindMatch", "Add Selection To Previous Find Match"),
      alias: "Add Selection To Previous Find Match",
      precondition: void 0,
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({key: "miAddSelectionToPreviousFindMatch", comment: ["&& denotes a mnemonic"]}, "Add P&&revious Occurrence"),
        order: 6
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.addSelectionToPreviousFindMatch(findController);
  }
};
var MoveSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.moveSelectionToNextFindMatch",
      label: localize("moveSelectionToNextFindMatch", "Move Last Selection To Next Find Match"),
      alias: "Move Last Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: KeyChord(2048 | 41, 2048 | 34),
        weight: 100
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.moveSelectionToNextFindMatch(findController);
  }
};
var MoveSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.moveSelectionToPreviousFindMatch",
      label: localize("moveSelectionToPreviousFindMatch", "Move Last Selection To Previous Find Match"),
      alias: "Move Last Selection To Previous Find Match",
      precondition: void 0
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.moveSelectionToPreviousFindMatch(findController);
  }
};
var SelectHighlightsAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.selectHighlights",
      label: localize("selectAllOccurrencesOfFindMatch", "Select All Occurrences of Find Match"),
      alias: "Select All Occurrences of Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 42,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({key: "miSelectHighlights", comment: ["&& denotes a mnemonic"]}, "Select All &&Occurrences"),
        order: 7
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.selectAll(findController);
  }
};
var CompatChangeAll = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.changeAll",
      label: localize("changeAll.label", "Change All Occurrences"),
      alias: "Change All Occurrences",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.editorTextFocus),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 60,
        weight: 100
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.2
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.selectAll(findController);
  }
};
var SelectionHighlighterState = class {
  constructor(searchText, matchCase, wordSeparators2, modelVersionId) {
    this.searchText = searchText;
    this.matchCase = matchCase;
    this.wordSeparators = wordSeparators2;
    this.modelVersionId = modelVersionId;
  }
  static softEquals(a, b) {
    if (!a && !b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    return a.searchText === b.searchText && a.matchCase === b.matchCase && a.wordSeparators === b.wordSeparators && a.modelVersionId === b.modelVersionId;
  }
};
var SelectionHighlighter = class extends Disposable {
  constructor(editor3) {
    super();
    this.editor = editor3;
    this._isEnabled = editor3.getOption(89);
    this.decorations = [];
    this.updateSoon = this._register(new RunOnceScheduler(() => this._update(), 300));
    this.state = null;
    this._register(editor3.onDidChangeConfiguration((e) => {
      this._isEnabled = editor3.getOption(89);
    }));
    this._register(editor3.onDidChangeCursorSelection((e) => {
      if (!this._isEnabled) {
        return;
      }
      if (e.selection.isEmpty()) {
        if (e.reason === 3) {
          if (this.state) {
            this._setState(null);
          }
          this.updateSoon.schedule();
        } else {
          this._setState(null);
        }
      } else {
        this._update();
      }
    }));
    this._register(editor3.onDidChangeModel((e) => {
      this._setState(null);
    }));
    this._register(editor3.onDidChangeModelContent((e) => {
      if (this._isEnabled) {
        this.updateSoon.schedule();
      }
    }));
    this._register(CommonFindController.get(editor3).getState().onFindReplaceStateChange((e) => {
      this._update();
    }));
  }
  _update() {
    this._setState(SelectionHighlighter._createState(this._isEnabled, this.editor));
  }
  static _createState(isEnabled, editor3) {
    if (!isEnabled) {
      return null;
    }
    if (!editor3.hasModel()) {
      return null;
    }
    const s = editor3.getSelection();
    if (s.startLineNumber !== s.endLineNumber) {
      return null;
    }
    const multiCursorController = MultiCursorSelectionController.get(editor3);
    if (!multiCursorController) {
      return null;
    }
    const findController = CommonFindController.get(editor3);
    if (!findController) {
      return null;
    }
    let r = multiCursorController.getSession(findController);
    if (!r) {
      const allSelections = editor3.getSelections();
      if (allSelections.length > 1) {
        const findState2 = findController.getState();
        const matchCase = findState2.matchCase;
        const selectionsContainSameText = modelRangesContainSameText(editor3.getModel(), allSelections, matchCase);
        if (!selectionsContainSameText) {
          return null;
        }
      }
      r = MultiCursorSession.create(editor3, findController);
    }
    if (!r) {
      return null;
    }
    if (r.currentMatch) {
      return null;
    }
    if (/^[ \t]+$/.test(r.searchText)) {
      return null;
    }
    if (r.searchText.length > 200) {
      return null;
    }
    const findState = findController.getState();
    const caseSensitive = findState.matchCase;
    if (findState.isRevealed) {
      let findStateSearchString = findState.searchString;
      if (!caseSensitive) {
        findStateSearchString = findStateSearchString.toLowerCase();
      }
      let mySearchString = r.searchText;
      if (!caseSensitive) {
        mySearchString = mySearchString.toLowerCase();
      }
      if (findStateSearchString === mySearchString && r.matchCase === findState.matchCase && r.wholeWord === findState.wholeWord && !findState.isRegex) {
        return null;
      }
    }
    return new SelectionHighlighterState(r.searchText, r.matchCase, r.wholeWord ? editor3.getOption(105) : null, editor3.getModel().getVersionId());
  }
  _setState(state) {
    if (SelectionHighlighterState.softEquals(this.state, state)) {
      this.state = state;
      return;
    }
    this.state = state;
    if (!this.state) {
      this.decorations = this.editor.deltaDecorations(this.decorations, []);
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    const model = this.editor.getModel();
    if (model.isTooLargeForTokenization()) {
      return;
    }
    const hasFindOccurrences = DocumentHighlightProviderRegistry.has(model) && this.editor.getOption(63);
    let allMatches = model.findMatches(this.state.searchText, true, false, this.state.matchCase, this.state.wordSeparators, false).map((m) => m.range);
    allMatches.sort(Range2.compareRangesUsingStarts);
    let selections = this.editor.getSelections();
    selections.sort(Range2.compareRangesUsingStarts);
    let matches = [];
    for (let i = 0, j = 0, len = allMatches.length, lenJ = selections.length; i < len; ) {
      const match = allMatches[i];
      if (j >= lenJ) {
        matches.push(match);
        i++;
      } else {
        const cmp = Range2.compareRangesUsingStarts(match, selections[j]);
        if (cmp < 0) {
          if (selections[j].isEmpty() || !Range2.areIntersecting(match, selections[j])) {
            matches.push(match);
          }
          i++;
        } else if (cmp > 0) {
          j++;
        } else {
          i++;
          j++;
        }
      }
    }
    const decorations = matches.map((r) => {
      return {
        range: r,
        options: hasFindOccurrences ? SelectionHighlighter._SELECTION_HIGHLIGHT : SelectionHighlighter._SELECTION_HIGHLIGHT_OVERVIEW
      };
    });
    this.decorations = this.editor.deltaDecorations(this.decorations, decorations);
  }
  dispose() {
    this._setState(null);
    super.dispose();
  }
};
SelectionHighlighter.ID = "editor.contrib.selectionHighlighter";
SelectionHighlighter._SELECTION_HIGHLIGHT_OVERVIEW = ModelDecorationOptions.register({
  stickiness: 1,
  className: "selectionHighlight",
  overviewRuler: {
    color: themeColorFromId(overviewRulerSelectionHighlightForeground),
    position: OverviewRulerLane.Center
  }
});
SelectionHighlighter._SELECTION_HIGHLIGHT = ModelDecorationOptions.register({
  stickiness: 1,
  className: "selectionHighlight"
});
function modelRangesContainSameText(model, ranges, matchCase) {
  const selectedText = getValueInRange(model, ranges[0], !matchCase);
  for (let i = 1, len = ranges.length; i < len; i++) {
    const range2 = ranges[i];
    if (range2.isEmpty()) {
      return false;
    }
    const thisSelectedText = getValueInRange(model, range2, !matchCase);
    if (selectedText !== thisSelectedText) {
      return false;
    }
  }
  return true;
}
function getValueInRange(model, range2, toLowerCase) {
  const text = model.getValueInRange(range2);
  return toLowerCase ? text.toLowerCase() : text;
}
registerEditorContribution(MultiCursorSelectionController.ID, MultiCursorSelectionController);
registerEditorContribution(SelectionHighlighter.ID, SelectionHighlighter);
registerEditorAction(InsertCursorAbove);
registerEditorAction(InsertCursorBelow);
registerEditorAction(InsertCursorAtEndOfEachLineSelected);
registerEditorAction(AddSelectionToNextFindMatchAction);
registerEditorAction(AddSelectionToPreviousFindMatchAction);
registerEditorAction(MoveSelectionToNextFindMatchAction);
registerEditorAction(MoveSelectionToPreviousFindMatchAction);
registerEditorAction(SelectHighlightsAction);
registerEditorAction(CompatChangeAll);
registerEditorAction(InsertCursorAtEndOfLineSelected);
registerEditorAction(InsertCursorAtTopOfLineSelected);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/provideSignatureHelp.js
var __awaiter21 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Context = {
  Visible: new RawContextKey("parameterHintsVisible", false),
  MultipleSignatures: new RawContextKey("parameterHintsMultipleSignatures", false)
};
function provideSignatureHelp(model, position, context2, token) {
  const supports = SignatureHelpProviderRegistry.ordered(model);
  return first(supports.map((support) => () => {
    return Promise.resolve(support.provideSignatureHelp(model, position, token, context2)).catch((e) => onUnexpectedExternalError(e));
  }));
}
registerDefaultLanguageCommand("_executeSignatureHelpProvider", (model, position, args) => __awaiter21(void 0, void 0, void 0, function* () {
  const result = yield provideSignatureHelp(model, position, {
    triggerKind: SignatureHelpTriggerKind.Invoke,
    isRetrigger: false,
    triggerCharacter: args["triggerCharacter"]
  }, CancellationToken.None);
  if (!result) {
    return void 0;
  }
  setTimeout(() => result.dispose(), 0);
  return result.value;
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHintsModel.js
var __awaiter22 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ParameterHintState;
(function(ParameterHintState2) {
  ParameterHintState2.Default = {type: 0};
  class Pending {
    constructor(request) {
      this.request = request;
      this.type = 2;
    }
  }
  ParameterHintState2.Pending = Pending;
  class Active {
    constructor(hints) {
      this.hints = hints;
      this.type = 1;
    }
  }
  ParameterHintState2.Active = Active;
})(ParameterHintState || (ParameterHintState = {}));
var ParameterHintsModel = class extends Disposable {
  constructor(editor3, delay2 = ParameterHintsModel.DEFAULT_DELAY) {
    super();
    this._onChangedHints = this._register(new Emitter2());
    this.onChangedHints = this._onChangedHints.event;
    this.triggerOnType = false;
    this._state = ParameterHintState.Default;
    this._pendingTriggers = [];
    this._lastSignatureHelpResult = this._register(new MutableDisposable());
    this.triggerChars = new CharacterSet();
    this.retriggerChars = new CharacterSet();
    this.triggerId = 0;
    this.editor = editor3;
    this.throttledDelayer = new Delayer(delay2);
    this._register(this.editor.onDidChangeConfiguration(() => this.onEditorConfigurationChange()));
    this._register(this.editor.onDidChangeModel((e) => this.onModelChanged()));
    this._register(this.editor.onDidChangeModelLanguage((_) => this.onModelChanged()));
    this._register(this.editor.onDidChangeCursorSelection((e) => this.onCursorChange(e)));
    this._register(this.editor.onDidChangeModelContent((e) => this.onModelContentChange()));
    this._register(SignatureHelpProviderRegistry.onDidChange(this.onModelChanged, this));
    this._register(this.editor.onDidType((text) => this.onDidType(text)));
    this.onEditorConfigurationChange();
    this.onModelChanged();
  }
  get state() {
    return this._state;
  }
  set state(value) {
    if (this._state.type === 2) {
      this._state.request.cancel();
    }
    this._state = value;
  }
  cancel(silent = false) {
    this.state = ParameterHintState.Default;
    this.throttledDelayer.cancel();
    if (!silent) {
      this._onChangedHints.fire(void 0);
    }
  }
  trigger(context2, delay2) {
    const model = this.editor.getModel();
    if (!model || !SignatureHelpProviderRegistry.has(model)) {
      return;
    }
    const triggerId = ++this.triggerId;
    this._pendingTriggers.push(context2);
    this.throttledDelayer.trigger(() => {
      return this.doTrigger(triggerId);
    }, delay2).catch(onUnexpectedError);
  }
  next() {
    if (this.state.type !== 1) {
      return;
    }
    const length = this.state.hints.signatures.length;
    const activeSignature = this.state.hints.activeSignature;
    const last = activeSignature % length === length - 1;
    const cycle = this.editor.getOption(67).cycle;
    if ((length < 2 || last) && !cycle) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(last && cycle ? 0 : activeSignature + 1);
  }
  previous() {
    if (this.state.type !== 1) {
      return;
    }
    const length = this.state.hints.signatures.length;
    const activeSignature = this.state.hints.activeSignature;
    const first2 = activeSignature === 0;
    const cycle = this.editor.getOption(67).cycle;
    if ((length < 2 || first2) && !cycle) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(first2 && cycle ? length - 1 : activeSignature - 1);
  }
  updateActiveSignature(activeSignature) {
    if (this.state.type !== 1) {
      return;
    }
    this.state = new ParameterHintState.Active(Object.assign(Object.assign({}, this.state.hints), {activeSignature}));
    this._onChangedHints.fire(this.state.hints);
  }
  doTrigger(triggerId) {
    return __awaiter22(this, void 0, void 0, function* () {
      const isRetrigger = this.state.type === 1 || this.state.type === 2;
      const activeSignatureHelp = this.state.type === 1 ? this.state.hints : void 0;
      this.cancel(true);
      if (this._pendingTriggers.length === 0) {
        return false;
      }
      const context2 = this._pendingTriggers.reduce(mergeTriggerContexts);
      this._pendingTriggers = [];
      const triggerContext = {
        triggerKind: context2.triggerKind,
        triggerCharacter: context2.triggerCharacter,
        isRetrigger,
        activeSignatureHelp
      };
      if (!this.editor.hasModel()) {
        return false;
      }
      const model = this.editor.getModel();
      const position = this.editor.getPosition();
      this.state = new ParameterHintState.Pending(createCancelablePromise((token) => provideSignatureHelp(model, position, triggerContext, token)));
      try {
        const result = yield this.state.request;
        if (triggerId !== this.triggerId) {
          result === null || result === void 0 ? void 0 : result.dispose();
          return false;
        }
        if (!result || !result.value.signatures || result.value.signatures.length === 0) {
          result === null || result === void 0 ? void 0 : result.dispose();
          this._lastSignatureHelpResult.clear();
          this.cancel();
          return false;
        } else {
          this.state = new ParameterHintState.Active(result.value);
          this._lastSignatureHelpResult.value = result;
          this._onChangedHints.fire(this.state.hints);
          return true;
        }
      } catch (error) {
        if (triggerId === this.triggerId) {
          this.state = ParameterHintState.Default;
        }
        onUnexpectedError(error);
        return false;
      }
    });
  }
  get isTriggered() {
    return this.state.type === 1 || this.state.type === 2 || this.throttledDelayer.isTriggered();
  }
  onModelChanged() {
    this.cancel();
    this.triggerChars = new CharacterSet();
    this.retriggerChars = new CharacterSet();
    const model = this.editor.getModel();
    if (!model) {
      return;
    }
    for (const support of SignatureHelpProviderRegistry.ordered(model)) {
      for (const ch of support.signatureHelpTriggerCharacters || []) {
        this.triggerChars.add(ch.charCodeAt(0));
        this.retriggerChars.add(ch.charCodeAt(0));
      }
      for (const ch of support.signatureHelpRetriggerCharacters || []) {
        this.retriggerChars.add(ch.charCodeAt(0));
      }
    }
  }
  onDidType(text) {
    if (!this.triggerOnType) {
      return;
    }
    const lastCharIndex = text.length - 1;
    const triggerCharCode = text.charCodeAt(lastCharIndex);
    if (this.triggerChars.has(triggerCharCode) || this.isTriggered && this.retriggerChars.has(triggerCharCode)) {
      this.trigger({
        triggerKind: SignatureHelpTriggerKind.TriggerCharacter,
        triggerCharacter: text.charAt(lastCharIndex)
      });
    }
  }
  onCursorChange(e) {
    if (e.source === "mouse") {
      this.cancel();
    } else if (this.isTriggered) {
      this.trigger({triggerKind: SignatureHelpTriggerKind.ContentChange});
    }
  }
  onModelContentChange() {
    if (this.isTriggered) {
      this.trigger({triggerKind: SignatureHelpTriggerKind.ContentChange});
    }
  }
  onEditorConfigurationChange() {
    this.triggerOnType = this.editor.getOption(67).enabled;
    if (!this.triggerOnType) {
      this.cancel();
    }
  }
  dispose() {
    this.cancel(true);
    super.dispose();
  }
};
ParameterHintsModel.DEFAULT_DELAY = 120;
function mergeTriggerContexts(previous, current2) {
  switch (current2.triggerKind) {
    case SignatureHelpTriggerKind.Invoke:
      return current2;
    case SignatureHelpTriggerKind.ContentChange:
      return previous;
    case SignatureHelpTriggerKind.TriggerCharacter:
    default:
      return current2;
  }
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHintsWidget.js
var __decorate30 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param30 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $5 = $;
var parameterHintsNextIcon = registerIcon("parameter-hints-next", Codicon.chevronDown);
var parameterHintsPreviousIcon = registerIcon("parameter-hints-previous", Codicon.chevronUp);
var ParameterHintsWidget = class ParameterHintsWidget2 extends Disposable {
  constructor(editor3, contextKeyService, openerService, modeService) {
    super();
    this.editor = editor3;
    this.renderDisposeables = this._register(new DisposableStore());
    this.visible = false;
    this.announcedLabel = null;
    this.allowEditorOverflow = true;
    this.markdownRenderer = this._register(new MarkdownRenderer(editor3, modeService, openerService));
    this.model = this._register(new ParameterHintsModel(editor3));
    this.keyVisible = Context.Visible.bindTo(contextKeyService);
    this.keyMultipleSignatures = Context.MultipleSignatures.bindTo(contextKeyService);
    this._register(this.model.onChangedHints((newParameterHints) => {
      if (newParameterHints) {
        this.show();
        this.render(newParameterHints);
      } else {
        this.hide();
      }
    }));
  }
  createParamaterHintDOMNodes() {
    const element = $5(".editor-widget.parameter-hints-widget");
    const wrapper = append(element, $5(".wrapper"));
    wrapper.tabIndex = -1;
    const controls = append(wrapper, $5(".controls"));
    const previous = append(controls, $5(".button" + parameterHintsPreviousIcon.cssSelector));
    const overloads = append(controls, $5(".overloads"));
    const next = append(controls, $5(".button" + parameterHintsNextIcon.cssSelector));
    const onPreviousClick = stop(domEvent(previous, "click"));
    this._register(onPreviousClick(this.previous, this));
    const onNextClick = stop(domEvent(next, "click"));
    this._register(onNextClick(this.next, this));
    const body3 = $5(".body");
    const scrollbar = new DomScrollableElement(body3, {});
    this._register(scrollbar);
    wrapper.appendChild(scrollbar.getDomNode());
    const signature = append(body3, $5(".signature"));
    const docs = append(body3, $5(".docs"));
    element.style.userSelect = "text";
    this.domNodes = {
      element,
      signature,
      overloads,
      docs,
      scrollbar
    };
    this.editor.addContentWidget(this);
    this.hide();
    this._register(this.editor.onDidChangeCursorSelection((e) => {
      if (this.visible) {
        this.editor.layoutContentWidget(this);
      }
    }));
    const updateFont = () => {
      if (!this.domNodes) {
        return;
      }
      const fontInfo = this.editor.getOption(36);
      this.domNodes.element.style.fontSize = `${fontInfo.fontSize}px`;
    };
    updateFont();
    this._register(Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor)).filter((e) => e.hasChanged(36)).on(updateFont, null));
    this._register(this.editor.onDidLayoutChange((e) => this.updateMaxHeight()));
    this.updateMaxHeight();
  }
  show() {
    if (this.visible) {
      return;
    }
    if (!this.domNodes) {
      this.createParamaterHintDOMNodes();
    }
    this.keyVisible.set(true);
    this.visible = true;
    setTimeout(() => {
      if (this.domNodes) {
        addClass(this.domNodes.element, "visible");
      }
    }, 100);
    this.editor.layoutContentWidget(this);
  }
  hide() {
    this.renderDisposeables.clear();
    if (!this.visible) {
      return;
    }
    this.keyVisible.reset();
    this.visible = false;
    this.announcedLabel = null;
    if (this.domNodes) {
      removeClass(this.domNodes.element, "visible");
    }
    this.editor.layoutContentWidget(this);
  }
  getPosition() {
    if (this.visible) {
      return {
        position: this.editor.getPosition(),
        preference: [1, 2]
      };
    }
    return null;
  }
  render(hints) {
    var _a5;
    this.renderDisposeables.clear();
    if (!this.domNodes) {
      return;
    }
    const multiple = hints.signatures.length > 1;
    toggleClass(this.domNodes.element, "multiple", multiple);
    this.keyMultipleSignatures.set(multiple);
    this.domNodes.signature.innerText = "";
    this.domNodes.docs.innerText = "";
    const signature = hints.signatures[hints.activeSignature];
    if (!signature) {
      return;
    }
    const code3 = append(this.domNodes.signature, $5(".code"));
    const fontInfo = this.editor.getOption(36);
    code3.style.fontSize = `${fontInfo.fontSize}px`;
    code3.style.fontFamily = fontInfo.fontFamily;
    const hasParameters = signature.parameters.length > 0;
    const activeParameterIndex = (_a5 = signature.activeParameter) !== null && _a5 !== void 0 ? _a5 : hints.activeParameter;
    if (!hasParameters) {
      const label = append(code3, $5("span"));
      label.textContent = signature.label;
    } else {
      this.renderParameters(code3, signature, activeParameterIndex);
    }
    const activeParameter = signature.parameters[activeParameterIndex];
    if (activeParameter === null || activeParameter === void 0 ? void 0 : activeParameter.documentation) {
      const documentation = $5("span.documentation");
      if (typeof activeParameter.documentation === "string") {
        documentation.textContent = activeParameter.documentation;
      } else {
        const renderedContents = this.renderDisposeables.add(this.markdownRenderer.render(activeParameter.documentation));
        addClass(renderedContents.element, "markdown-docs");
        documentation.appendChild(renderedContents.element);
      }
      append(this.domNodes.docs, $5("p", {}, documentation));
    }
    if (signature.documentation === void 0) {
    } else if (typeof signature.documentation === "string") {
      append(this.domNodes.docs, $5("p", {}, signature.documentation));
    } else {
      const renderedContents = this.renderDisposeables.add(this.markdownRenderer.render(signature.documentation));
      addClass(renderedContents.element, "markdown-docs");
      append(this.domNodes.docs, renderedContents.element);
    }
    const hasDocs = this.hasDocs(signature, activeParameter);
    toggleClass(this.domNodes.signature, "has-docs", hasDocs);
    toggleClass(this.domNodes.docs, "empty", !hasDocs);
    this.domNodes.overloads.textContent = pad(hints.activeSignature + 1, hints.signatures.length.toString().length) + "/" + hints.signatures.length;
    if (activeParameter) {
      const labelToAnnounce = this.getParameterLabel(signature, activeParameterIndex);
      if (this.announcedLabel !== labelToAnnounce) {
        alert(localize("hint", "{0}, hint", labelToAnnounce));
        this.announcedLabel = labelToAnnounce;
      }
    }
    this.editor.layoutContentWidget(this);
    this.domNodes.scrollbar.scanDomNode();
  }
  hasDocs(signature, activeParameter) {
    if (activeParameter && typeof activeParameter.documentation === "string" && assertIsDefined(activeParameter.documentation).length > 0) {
      return true;
    }
    if (activeParameter && typeof activeParameter.documentation === "object" && assertIsDefined(activeParameter.documentation).value.length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === "string" && assertIsDefined(signature.documentation).length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === "object" && assertIsDefined(signature.documentation.value).length > 0) {
      return true;
    }
    return false;
  }
  renderParameters(parent2, signature, activeParameterIndex) {
    const [start, end] = this.getParameterLabelOffsets(signature, activeParameterIndex);
    const beforeSpan = document.createElement("span");
    beforeSpan.textContent = signature.label.substring(0, start);
    const paramSpan = document.createElement("span");
    paramSpan.textContent = signature.label.substring(start, end);
    paramSpan.className = "parameter active";
    const afterSpan = document.createElement("span");
    afterSpan.textContent = signature.label.substring(end);
    append(parent2, beforeSpan, paramSpan, afterSpan);
  }
  getParameterLabel(signature, paramIdx) {
    const param = signature.parameters[paramIdx];
    if (Array.isArray(param.label)) {
      return signature.label.substring(param.label[0], param.label[1]);
    } else {
      return param.label;
    }
  }
  getParameterLabelOffsets(signature, paramIdx) {
    const param = signature.parameters[paramIdx];
    if (!param) {
      return [0, 0];
    } else if (Array.isArray(param.label)) {
      return param.label;
    } else {
      const idx = signature.label.lastIndexOf(param.label);
      return idx >= 0 ? [idx, idx + param.label.length] : [0, 0];
    }
  }
  next() {
    this.editor.focus();
    this.model.next();
  }
  previous() {
    this.editor.focus();
    this.model.previous();
  }
  cancel() {
    this.model.cancel();
  }
  getDomNode() {
    if (!this.domNodes) {
      this.createParamaterHintDOMNodes();
    }
    return this.domNodes.element;
  }
  getId() {
    return ParameterHintsWidget2.ID;
  }
  trigger(context2) {
    this.model.trigger(context2, 0);
  }
  updateMaxHeight() {
    if (!this.domNodes) {
      return;
    }
    const height = Math.max(this.editor.getLayoutInfo().height / 4, 250);
    const maxHeight = `${height}px`;
    this.domNodes.element.style.maxHeight = maxHeight;
    const wrapper = this.domNodes.element.getElementsByClassName("wrapper");
    if (wrapper.length) {
      wrapper[0].style.maxHeight = maxHeight;
    }
  }
};
ParameterHintsWidget.ID = "editor.widget.parameterHintsWidget";
ParameterHintsWidget = __decorate30([
  __param30(1, IContextKeyService),
  __param30(2, IOpenerService),
  __param30(3, IModeService)
], ParameterHintsWidget);
registerThemingParticipant((theme6, collector) => {
  const border = theme6.getColor(editorHoverBorder);
  if (border) {
    const borderWidth = theme6.type === HIGH_CONTRAST ? 2 : 1;
    collector.addRule(`.monaco-editor .parameter-hints-widget { border: ${borderWidth}px solid ${border}; }`);
    collector.addRule(`.monaco-editor .parameter-hints-widget.multiple .body { border-left: 1px solid ${border.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .parameter-hints-widget .signature.has-docs { border-bottom: 1px solid ${border.transparent(0.5)}; }`);
  }
  const background = theme6.getColor(editorHoverBackground);
  if (background) {
    collector.addRule(`.monaco-editor .parameter-hints-widget { background-color: ${background}; }`);
  }
  const link = theme6.getColor(textLinkForeground);
  if (link) {
    collector.addRule(`.monaco-editor .parameter-hints-widget a { color: ${link}; }`);
  }
  const foreground2 = theme6.getColor(editorHoverForeground);
  if (foreground2) {
    collector.addRule(`.monaco-editor .parameter-hints-widget { color: ${foreground2}; }`);
  }
  const codeBackground = theme6.getColor(textCodeBlockBackground);
  if (codeBackground) {
    collector.addRule(`.monaco-editor .parameter-hints-widget code { background-color: ${codeBackground}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHints.js
var __decorate31 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param31 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ParameterHintsController = class ParameterHintsController2 extends Disposable {
  constructor(editor3, instantiationService) {
    super();
    this.editor = editor3;
    this.widget = this._register(instantiationService.createInstance(ParameterHintsWidget, this.editor));
  }
  static get(editor3) {
    return editor3.getContribution(ParameterHintsController2.ID);
  }
  cancel() {
    this.widget.cancel();
  }
  previous() {
    this.widget.previous();
  }
  next() {
    this.widget.next();
  }
  trigger(context2) {
    this.widget.trigger(context2);
  }
};
ParameterHintsController.ID = "editor.controller.parameterHints";
ParameterHintsController = __decorate31([
  __param31(1, IInstantiationService)
], ParameterHintsController);
var TriggerParameterHintsAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.triggerParameterHints",
      label: localize("parameterHints.trigger.label", "Trigger Parameter Hints"),
      alias: "Trigger Parameter Hints",
      precondition: EditorContextKeys.hasSignatureHelpProvider,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 10,
        weight: 100
      }
    });
  }
  run(accessor, editor3) {
    const controller = ParameterHintsController.get(editor3);
    if (controller) {
      controller.trigger({
        triggerKind: SignatureHelpTriggerKind.Invoke
      });
    }
  }
};
registerEditorContribution(ParameterHintsController.ID, ParameterHintsController);
registerEditorAction(TriggerParameterHintsAction);
var weight = 100 + 75;
var ParameterHintsCommand = EditorCommand.bindToContribution(ParameterHintsController.get);
registerEditorCommand(new ParameterHintsCommand({
  id: "closeParameterHints",
  precondition: Context.Visible,
  handler: (x) => x.cancel(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerEditorCommand(new ParameterHintsCommand({
  id: "showPrevParameterHint",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSignatures),
  handler: (x) => x.previous(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.focus,
    primary: 16,
    secondary: [512 | 16],
    mac: {primary: 16, secondary: [512 | 16, 256 | 46]}
  }
}));
registerEditorCommand(new ParameterHintsCommand({
  id: "showNextParameterHint",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSignatures),
  handler: (x) => x.next(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.focus,
    primary: 18,
    secondary: [512 | 18],
    mac: {primary: 18, secondary: [512 | 18, 256 | 44]}
  }
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/rename/onTypeRename.js
var __decorate32 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param32 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter23 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE = new RawContextKey("onTypeRenameInputVisible", false);
var OnTypeRenameContribution = class OnTypeRenameContribution2 extends Disposable {
  constructor(editor3, contextKeyService) {
    super();
    this._debounceDuration = 200;
    this._localToDispose = this._register(new DisposableStore());
    this._editor = editor3;
    this._enabled = false;
    this._visibleContextKey = CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
    this._currentDecorations = [];
    this._languageWordPattern = null;
    this._currentWordPattern = null;
    this._ignoreChangeEvent = false;
    this._localToDispose = this._register(new DisposableStore());
    this._rangeUpdateTriggerPromise = null;
    this._rangeSyncTriggerPromise = null;
    this._currentRequest = null;
    this._currentRequestPosition = null;
    this._currentRequestModelVersion = null;
    this._register(this._editor.onDidChangeModel(() => this.reinitialize()));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(73)) {
        this.reinitialize();
      }
    }));
    this._register(OnTypeRenameProviderRegistry.onDidChange(() => this.reinitialize()));
    this._register(this._editor.onDidChangeModelLanguage(() => this.reinitialize()));
    this.reinitialize();
  }
  static get(editor3) {
    return editor3.getContribution(OnTypeRenameContribution2.ID);
  }
  reinitialize() {
    const model = this._editor.getModel();
    const isEnabled = model !== null && this._editor.getOption(73) && OnTypeRenameProviderRegistry.has(model);
    if (isEnabled === this._enabled) {
      return;
    }
    this._enabled = isEnabled;
    this.clearRanges();
    this._localToDispose.clear();
    if (!isEnabled || model === null) {
      return;
    }
    this._languageWordPattern = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);
    this._localToDispose.add(model.onDidChangeLanguageConfiguration(() => {
      this._languageWordPattern = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);
    }));
    const rangeUpdateScheduler = new Delayer(this._debounceDuration);
    const triggerRangeUpdate = () => {
      this._rangeUpdateTriggerPromise = rangeUpdateScheduler.trigger(() => this.updateRanges(), this._debounceDuration);
    };
    const rangeSyncScheduler = new Delayer(0);
    const triggerRangeSync = (decorations) => {
      this._rangeSyncTriggerPromise = rangeSyncScheduler.trigger(() => this._syncRanges(decorations));
    };
    this._localToDispose.add(this._editor.onDidChangeCursorPosition(() => {
      triggerRangeUpdate();
    }));
    this._localToDispose.add(this._editor.onDidChangeModelContent((e) => {
      if (!this._ignoreChangeEvent) {
        if (this._currentDecorations.length > 0) {
          const referenceRange = model.getDecorationRange(this._currentDecorations[0]);
          if (referenceRange && e.changes.every((c) => referenceRange.intersectRanges(c.range))) {
            triggerRangeSync(this._currentDecorations);
            return;
          }
        }
      }
      triggerRangeUpdate();
    }));
    this._localToDispose.add({
      dispose: () => {
        rangeUpdateScheduler.cancel();
        rangeSyncScheduler.cancel();
      }
    });
    this.updateRanges();
  }
  _syncRanges(decorations) {
    if (!this._editor.hasModel() || decorations !== this._currentDecorations || decorations.length === 0) {
      return;
    }
    const model = this._editor.getModel();
    const referenceRange = model.getDecorationRange(decorations[0]);
    if (!referenceRange || referenceRange.startLineNumber !== referenceRange.endLineNumber) {
      return this.clearRanges();
    }
    const referenceValue = model.getValueInRange(referenceRange);
    if (this._currentWordPattern) {
      const match = referenceValue.match(this._currentWordPattern);
      const matchLength = match ? match[0].length : 0;
      if (matchLength !== referenceValue.length) {
        return this.clearRanges();
      }
    }
    let edits = [];
    for (let i = 1, len = decorations.length; i < len; i++) {
      const mirrorRange = model.getDecorationRange(decorations[i]);
      if (!mirrorRange) {
        continue;
      }
      if (mirrorRange.startLineNumber !== mirrorRange.endLineNumber) {
        edits.push({
          range: mirrorRange,
          text: referenceValue
        });
      } else {
        let oldValue = model.getValueInRange(mirrorRange);
        let newValue = referenceValue;
        let rangeStartColumn = mirrorRange.startColumn;
        let rangeEndColumn = mirrorRange.endColumn;
        const commonPrefixLength2 = commonPrefixLength(oldValue, newValue);
        rangeStartColumn += commonPrefixLength2;
        oldValue = oldValue.substr(commonPrefixLength2);
        newValue = newValue.substr(commonPrefixLength2);
        const commonSuffixLength2 = commonSuffixLength(oldValue, newValue);
        rangeEndColumn -= commonSuffixLength2;
        oldValue = oldValue.substr(0, oldValue.length - commonSuffixLength2);
        newValue = newValue.substr(0, newValue.length - commonSuffixLength2);
        if (rangeStartColumn !== rangeEndColumn || newValue.length !== 0) {
          edits.push({
            range: new Range2(mirrorRange.startLineNumber, rangeStartColumn, mirrorRange.endLineNumber, rangeEndColumn),
            text: newValue
          });
        }
      }
    }
    if (edits.length === 0) {
      return;
    }
    try {
      this._ignoreChangeEvent = true;
      const prevEditOperationType = this._editor._getViewModel().getPrevEditOperationType();
      this._editor.executeEdits("onTypeRename", edits);
      this._editor._getViewModel().setPrevEditOperationType(prevEditOperationType);
    } finally {
      this._ignoreChangeEvent = false;
    }
  }
  dispose() {
    this.clearRanges();
    super.dispose();
  }
  clearRanges() {
    this._visibleContextKey.set(false);
    this._currentDecorations = this._editor.deltaDecorations(this._currentDecorations, []);
    if (this._currentRequest) {
      this._currentRequest.cancel();
      this._currentRequest = null;
      this._currentRequestPosition = null;
    }
  }
  updateRanges(force = false) {
    return __awaiter23(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        this.clearRanges();
        return;
      }
      const position = this._editor.getPosition();
      if (!this._enabled && !force || this._editor.getSelections().length > 1) {
        this.clearRanges();
        return;
      }
      const model = this._editor.getModel();
      const modelVersionId = model.getVersionId();
      if (this._currentRequestPosition && this._currentRequestModelVersion === modelVersionId) {
        if (position.equals(this._currentRequestPosition)) {
          return;
        }
        if (this._currentDecorations && this._currentDecorations.length > 0) {
          const range2 = model.getDecorationRange(this._currentDecorations[0]);
          if (range2 && range2.containsPosition(position)) {
            return;
          }
        }
      }
      this._currentRequestPosition = position;
      this._currentRequestModelVersion = modelVersionId;
      const request = createCancelablePromise((token) => __awaiter23(this, void 0, void 0, function* () {
        try {
          const response = yield getOnTypeRenameRanges(model, position, token);
          if (request !== this._currentRequest) {
            return;
          }
          this._currentRequest = null;
          if (modelVersionId !== model.getVersionId()) {
            return;
          }
          let ranges = [];
          if (response === null || response === void 0 ? void 0 : response.ranges) {
            ranges = response.ranges;
          }
          this._currentWordPattern = (response === null || response === void 0 ? void 0 : response.wordPattern) || this._languageWordPattern;
          let foundReferenceRange = false;
          for (let i = 0, len = ranges.length; i < len; i++) {
            if (Range2.containsPosition(ranges[i], position)) {
              foundReferenceRange = true;
              if (i !== 0) {
                const referenceRange = ranges[i];
                ranges.splice(i, 1);
                ranges.unshift(referenceRange);
              }
              break;
            }
          }
          if (!foundReferenceRange) {
            this.clearRanges();
            return;
          }
          const decorations = ranges.map((range2) => ({range: range2, options: OnTypeRenameContribution2.DECORATION}));
          this._visibleContextKey.set(true);
          this._currentDecorations = this._editor.deltaDecorations(this._currentDecorations, decorations);
        } catch (err) {
          if (!isPromiseCanceledError(err)) {
            onUnexpectedError(err);
          }
          if (this._currentRequest === request || !this._currentRequest) {
            this.clearRanges();
          }
        }
      }));
      this._currentRequest = request;
      return request;
    });
  }
};
OnTypeRenameContribution.ID = "editor.contrib.onTypeRename";
OnTypeRenameContribution.DECORATION = ModelDecorationOptions.register({
  stickiness: 0,
  className: "on-type-rename-decoration"
});
OnTypeRenameContribution = __decorate32([
  __param32(1, IContextKeyService)
], OnTypeRenameContribution);
var OnTypeRenameAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.onTypeRename",
      label: localize("onTypeRename.label", "On Type Rename Symbol"),
      alias: "On Type Rename Symbol",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 60,
        weight: 100
      }
    });
  }
  runCommand(accessor, args) {
    const editorService = accessor.get(ICodeEditorService);
    const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
    if (URI.isUri(uri) && Position.isIPosition(pos)) {
      return editorService.openCodeEditor({resource: uri}, editorService.getActiveCodeEditor()).then((editor3) => {
        if (!editor3) {
          return;
        }
        editor3.setPosition(pos);
        editor3.invokeWithinContext((accessor2) => {
          this.reportTelemetry(accessor2, editor3);
          return this.run(accessor2, editor3);
        });
      }, onUnexpectedError);
    }
    return super.runCommand(accessor, args);
  }
  run(_accessor, editor3) {
    const controller = OnTypeRenameContribution.get(editor3);
    if (controller) {
      return Promise.resolve(controller.updateRanges(true));
    }
    return Promise.resolve();
  }
};
var OnTypeRenameCommand = EditorCommand.bindToContribution(OnTypeRenameContribution.get);
registerEditorCommand(new OnTypeRenameCommand({
  id: "cancelOnTypeRenameInput",
  precondition: CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE,
  handler: (x) => x.clearRanges(),
  kbOpts: {
    kbExpr: EditorContextKeys.editorTextFocus,
    weight: 100 + 99,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
function getOnTypeRenameRanges(model, position, token) {
  const orderedByScore = OnTypeRenameProviderRegistry.ordered(model);
  return first(orderedByScore.map((provider) => () => {
    return Promise.resolve(provider.provideOnTypeRenameRanges(model, position, token)).then((res) => {
      if (!res) {
        return void 0;
      }
      return {
        ranges: res.ranges,
        wordPattern: res.wordPattern || provider.wordPattern
      };
    }, (err) => {
      onUnexpectedExternalError(err);
      return void 0;
    });
  }), (result) => !!result && isNonEmptyArray(result === null || result === void 0 ? void 0 : result.ranges));
}
var editorOnTypeRenameBackground = registerColor("editor.onTypeRenameBackground", {dark: Color.fromHex("#f00").transparent(0.3), light: Color.fromHex("#f00").transparent(0.3), hc: Color.fromHex("#f00").transparent(0.3)}, localize("editorOnTypeRenameBackground", "Background color when the editor auto renames on type."));
registerThemingParticipant((theme6, collector) => {
  const editorOnTypeRenameBackgroundColor = theme6.getColor(editorOnTypeRenameBackground);
  if (editorOnTypeRenameBackgroundColor) {
    collector.addRule(`.monaco-editor .on-type-rename-decoration { background: ${editorOnTypeRenameBackgroundColor}; border-left-color: ${editorOnTypeRenameBackgroundColor}; }`);
  }
});
registerModelAndPositionCommand("_executeRenameOnTypeProvider", (model, position) => getOnTypeRenameRanges(model, position, CancellationToken.None));
registerEditorContribution(OnTypeRenameContribution.ID, OnTypeRenameContribution);
registerEditorAction(OnTypeRenameAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/rename/renameInputField.js
var __decorate33 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param33 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CONTEXT_RENAME_INPUT_VISIBLE = new RawContextKey("renameInputVisible", false);
var RenameInputField = class RenameInputField2 {
  constructor(_editor, _acceptKeybindings, _themeService, _keybindingService, contextKeyService) {
    this._editor = _editor;
    this._acceptKeybindings = _acceptKeybindings;
    this._themeService = _themeService;
    this._keybindingService = _keybindingService;
    this._disposables = new DisposableStore();
    this.allowEditorOverflow = true;
    this._visibleContextKey = CONTEXT_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
    this._editor.addContentWidget(this);
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(36)) {
        this._updateFont();
      }
    }));
    this._disposables.add(_themeService.onDidColorThemeChange(this._updateStyles, this));
  }
  dispose() {
    this._disposables.dispose();
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "__renameInputWidget";
  }
  getDomNode() {
    if (!this._domNode) {
      this._domNode = document.createElement("div");
      this._domNode.className = "monaco-editor rename-box";
      this._input = document.createElement("input");
      this._input.className = "rename-input";
      this._input.type = "text";
      this._input.setAttribute("aria-label", localize("renameAriaLabel", "Rename input. Type new name and press Enter to commit."));
      this._domNode.appendChild(this._input);
      this._label = document.createElement("div");
      this._label.className = "rename-label";
      this._domNode.appendChild(this._label);
      const updateLabel = () => {
        var _a5, _b2;
        const [accept, preview] = this._acceptKeybindings;
        this._keybindingService.lookupKeybinding(accept);
        this._label.innerText = localize({key: "label", comment: ['placeholders are keybindings, e.g "F2 to Rename, Shift+F2 to Preview"']}, "{0} to Rename, {1} to Preview", (_a5 = this._keybindingService.lookupKeybinding(accept)) === null || _a5 === void 0 ? void 0 : _a5.getLabel(), (_b2 = this._keybindingService.lookupKeybinding(preview)) === null || _b2 === void 0 ? void 0 : _b2.getLabel());
      };
      updateLabel();
      this._disposables.add(this._keybindingService.onDidUpdateKeybindings(updateLabel));
      this._updateFont();
      this._updateStyles(this._themeService.getColorTheme());
    }
    return this._domNode;
  }
  _updateStyles(theme6) {
    var _a5, _b2, _c2, _d2;
    if (!this._input || !this._domNode) {
      return;
    }
    const widgetShadowColor = theme6.getColor(widgetShadow);
    this._domNode.style.backgroundColor = String((_a5 = theme6.getColor(editorWidgetBackground)) !== null && _a5 !== void 0 ? _a5 : "");
    this._domNode.style.boxShadow = widgetShadowColor ? ` 0 2px 8px ${widgetShadowColor}` : "";
    this._domNode.style.color = String((_b2 = theme6.getColor(inputForeground)) !== null && _b2 !== void 0 ? _b2 : "");
    this._input.style.backgroundColor = String((_c2 = theme6.getColor(inputBackground)) !== null && _c2 !== void 0 ? _c2 : "");
    const border = theme6.getColor(inputBorder);
    this._input.style.borderWidth = border ? "1px" : "0px";
    this._input.style.borderStyle = border ? "solid" : "none";
    this._input.style.borderColor = (_d2 = border === null || border === void 0 ? void 0 : border.toString()) !== null && _d2 !== void 0 ? _d2 : "none";
  }
  _updateFont() {
    if (!this._input || !this._label) {
      return;
    }
    const fontInfo = this._editor.getOption(36);
    this._input.style.fontFamily = fontInfo.fontFamily;
    this._input.style.fontWeight = fontInfo.fontWeight;
    this._input.style.fontSize = `${fontInfo.fontSize}px`;
    this._label.style.fontSize = `${fontInfo.fontSize * 0.8}px`;
  }
  getPosition() {
    if (!this._visible) {
      return null;
    }
    return {
      position: this._position,
      preference: [2, 1]
    };
  }
  acceptInput(wantsPreview) {
    if (this._currentAcceptInput) {
      this._currentAcceptInput(wantsPreview);
    }
  }
  cancelInput(focusEditor) {
    if (this._currentCancelInput) {
      this._currentCancelInput(focusEditor);
    }
  }
  getInput(where, value, selectionStart, selectionEnd, supportPreview, token) {
    this._domNode.classList.toggle("preview", supportPreview);
    this._position = new Position(where.startLineNumber, where.startColumn);
    this._input.value = value;
    this._input.setAttribute("selectionStart", selectionStart.toString());
    this._input.setAttribute("selectionEnd", selectionEnd.toString());
    this._input.size = Math.max((where.endColumn - where.startColumn) * 1.1, 20);
    const disposeOnDone = new DisposableStore();
    return new Promise((resolve) => {
      this._currentCancelInput = (focusEditor) => {
        this._currentAcceptInput = void 0;
        this._currentCancelInput = void 0;
        resolve(focusEditor);
        return true;
      };
      this._currentAcceptInput = (wantsPreview) => {
        if (this._input.value.trim().length === 0 || this._input.value === value) {
          this.cancelInput(true);
          return;
        }
        this._currentAcceptInput = void 0;
        this._currentCancelInput = void 0;
        resolve({
          newName: this._input.value,
          wantsPreview: supportPreview && wantsPreview
        });
      };
      token.onCancellationRequested(() => this.cancelInput(true));
      disposeOnDone.add(this._editor.onDidBlurEditorWidget(() => this.cancelInput(false)));
      this._show();
    }).finally(() => {
      disposeOnDone.dispose();
      this._hide();
    });
  }
  _show() {
    this._editor.revealLineInCenterIfOutsideViewport(this._position.lineNumber, 0);
    this._visible = true;
    this._visibleContextKey.set(true);
    this._editor.layoutContentWidget(this);
    setTimeout(() => {
      this._input.focus();
      this._input.setSelectionRange(parseInt(this._input.getAttribute("selectionStart")), parseInt(this._input.getAttribute("selectionEnd")));
    }, 100);
  }
  _hide() {
    this._visible = false;
    this._visibleContextKey.reset();
    this._editor.layoutContentWidget(this);
  }
};
RenameInputField = __decorate33([
  __param33(2, IThemeService),
  __param33(3, IKeybindingService),
  __param33(4, IContextKeyService)
], RenameInputField);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/rename/rename.js
var __decorate34 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param34 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter24 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RenameSkeleton = class {
  constructor(model, position) {
    this.model = model;
    this.position = position;
    this._providerRenameIdx = 0;
    this._providers = RenameProviderRegistry.ordered(model);
  }
  hasProvider() {
    return this._providers.length > 0;
  }
  resolveRenameLocation(token) {
    return __awaiter24(this, void 0, void 0, function* () {
      const rejects = [];
      for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
        const provider = this._providers[this._providerRenameIdx];
        if (!provider.resolveRenameLocation) {
          break;
        }
        let res = yield provider.resolveRenameLocation(this.model, this.position, token);
        if (!res) {
          continue;
        }
        if (res.rejectReason) {
          rejects.push(res.rejectReason);
          continue;
        }
        return res;
      }
      const word = this.model.getWordAtPosition(this.position);
      if (!word) {
        return {
          range: Range2.fromPositions(this.position),
          text: "",
          rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
        };
      }
      return {
        range: new Range2(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),
        text: word.word,
        rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
      };
    });
  }
  provideRenameEdits(newName, token) {
    return __awaiter24(this, void 0, void 0, function* () {
      return this._provideRenameEdits(newName, this._providerRenameIdx, [], token);
    });
  }
  _provideRenameEdits(newName, i, rejects, token) {
    return __awaiter24(this, void 0, void 0, function* () {
      const provider = this._providers[i];
      if (!provider) {
        return {
          edits: [],
          rejectReason: rejects.join("\n")
        };
      }
      const result = yield provider.provideRenameEdits(this.model, this.position, newName, token);
      if (!result) {
        return this._provideRenameEdits(newName, i + 1, rejects.concat(localize("no result", "No result.")), token);
      } else if (result.rejectReason) {
        return this._provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason), token);
      }
      return result;
    });
  }
};
function rename(model, position, newName) {
  return __awaiter24(this, void 0, void 0, function* () {
    const skeleton = new RenameSkeleton(model, position);
    const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
    if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
      return {edits: [], rejectReason: loc.rejectReason};
    }
    return skeleton.provideRenameEdits(newName, CancellationToken.None);
  });
}
var RenameController = class RenameController2 {
  constructor(editor3, _instaService, _notificationService, _bulkEditService, _progressService, _logService, _configService) {
    this.editor = editor3;
    this._instaService = _instaService;
    this._notificationService = _notificationService;
    this._bulkEditService = _bulkEditService;
    this._progressService = _progressService;
    this._logService = _logService;
    this._configService = _configService;
    this._dispoableStore = new DisposableStore();
    this._cts = new CancellationTokenSource();
    this._renameInputField = this._dispoableStore.add(new IdleValue(() => this._dispoableStore.add(this._instaService.createInstance(RenameInputField, this.editor, ["acceptRenameInput", "acceptRenameInputWithPreview"]))));
  }
  static get(editor3) {
    return editor3.getContribution(RenameController2.ID);
  }
  dispose() {
    this._dispoableStore.dispose();
    this._cts.dispose(true);
  }
  run() {
    return __awaiter24(this, void 0, void 0, function* () {
      this._cts.dispose(true);
      if (!this.editor.hasModel()) {
        return void 0;
      }
      const position = this.editor.getPosition();
      const skeleton = new RenameSkeleton(this.editor.getModel(), position);
      if (!skeleton.hasProvider()) {
        return void 0;
      }
      this._cts = new EditorStateCancellationTokenSource(this.editor, 4 | 1);
      let loc;
      try {
        const resolveLocationOperation = skeleton.resolveRenameLocation(this._cts.token);
        this._progressService.showWhile(resolveLocationOperation, 250);
        loc = yield resolveLocationOperation;
      } catch (e) {
        MessageController.get(this.editor).showMessage(e || localize("resolveRenameLocationFailed", "An unknown error occurred while resolving rename location"), position);
        return void 0;
      }
      if (!loc) {
        return void 0;
      }
      if (loc.rejectReason) {
        MessageController.get(this.editor).showMessage(loc.rejectReason, position);
        return void 0;
      }
      if (this._cts.token.isCancellationRequested) {
        return void 0;
      }
      this._cts.dispose();
      this._cts = new EditorStateCancellationTokenSource(this.editor, 4 | 1, loc.range);
      let selection = this.editor.getSelection();
      let selectionStart = 0;
      let selectionEnd = loc.text.length;
      if (!Range2.isEmpty(selection) && !Range2.spansMultipleLines(selection) && Range2.containsRange(loc.range, selection)) {
        selectionStart = Math.max(0, selection.startColumn - loc.range.startColumn);
        selectionEnd = Math.min(loc.range.endColumn, selection.endColumn) - loc.range.startColumn;
      }
      const supportPreview = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, "editor.rename.enablePreview");
      const inputFieldResult = yield this._renameInputField.value.getInput(loc.range, loc.text, selectionStart, selectionEnd, supportPreview, this._cts.token);
      if (typeof inputFieldResult === "boolean") {
        if (inputFieldResult) {
          this.editor.focus();
        }
        return void 0;
      }
      this.editor.focus();
      const renameOperation = raceCancellation(skeleton.provideRenameEdits(inputFieldResult.newName, this._cts.token), this._cts.token).then((renameResult) => __awaiter24(this, void 0, void 0, function* () {
        if (!renameResult || !this.editor.hasModel()) {
          return;
        }
        if (renameResult.rejectReason) {
          this._notificationService.info(renameResult.rejectReason);
          return;
        }
        this._bulkEditService.apply(ResourceEdit.convert(renameResult), {
          editor: this.editor,
          showPreview: inputFieldResult.wantsPreview,
          label: localize("label", "Renaming '{0}'", loc === null || loc === void 0 ? void 0 : loc.text),
          quotableLabel: localize("quotableLabel", "Renaming {0}", loc === null || loc === void 0 ? void 0 : loc.text)
        }).then((result) => {
          if (result.ariaSummary) {
            alert(localize("aria", "Successfully renamed '{0}' to '{1}'. Summary: {2}", loc.text, inputFieldResult.newName, result.ariaSummary));
          }
        }).catch((err) => {
          this._notificationService.error(localize("rename.failedApply", "Rename failed to apply edits"));
          this._logService.error(err);
        });
      }), (err) => {
        this._notificationService.error(localize("rename.failed", "Rename failed to compute edits"));
        this._logService.error(err);
      });
      this._progressService.showWhile(renameOperation, 250);
      return renameOperation;
    });
  }
  acceptRenameInput(wantsPreview) {
    this._renameInputField.value.acceptInput(wantsPreview);
  }
  cancelRenameInput() {
    this._renameInputField.value.cancelInput(true);
  }
};
RenameController.ID = "editor.contrib.renameController";
RenameController = __decorate34([
  __param34(1, IInstantiationService),
  __param34(2, INotificationService),
  __param34(3, IBulkEditService),
  __param34(4, IEditorProgressService),
  __param34(5, ILogService),
  __param34(6, ITextResourceConfigurationService)
], RenameController);
var RenameAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.rename",
      label: localize("rename.label", "Rename Symbol"),
      alias: "Rename Symbol",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 60,
        weight: 100
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.1
      }
    });
  }
  runCommand(accessor, args) {
    const editorService = accessor.get(ICodeEditorService);
    const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
    if (URI.isUri(uri) && Position.isIPosition(pos)) {
      return editorService.openCodeEditor({resource: uri}, editorService.getActiveCodeEditor()).then((editor3) => {
        if (!editor3) {
          return;
        }
        editor3.setPosition(pos);
        editor3.invokeWithinContext((accessor2) => {
          this.reportTelemetry(accessor2, editor3);
          return this.run(accessor2, editor3);
        });
      }, onUnexpectedError);
    }
    return super.runCommand(accessor, args);
  }
  run(accessor, editor3) {
    const controller = RenameController.get(editor3);
    if (controller) {
      return controller.run();
    }
    return Promise.resolve();
  }
};
registerEditorContribution(RenameController.ID, RenameController);
registerEditorAction(RenameAction);
var RenameCommand = EditorCommand.bindToContribution(RenameController.get);
registerEditorCommand(new RenameCommand({
  id: "acceptRenameInput",
  precondition: CONTEXT_RENAME_INPUT_VISIBLE,
  handler: (x) => x.acceptRenameInput(false),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: EditorContextKeys.focus,
    primary: 3
  }
}));
registerEditorCommand(new RenameCommand({
  id: "acceptRenameInputWithPreview",
  precondition: ContextKeyExpr.and(CONTEXT_RENAME_INPUT_VISIBLE, ContextKeyExpr.has("config.editor.rename.enablePreview")),
  handler: (x) => x.acceptRenameInput(true),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: EditorContextKeys.focus,
    primary: 1024 + 3
  }
}));
registerEditorCommand(new RenameCommand({
  id: "cancelRenameInput",
  precondition: CONTEXT_RENAME_INPUT_VISIBLE,
  handler: (x) => x.cancelRenameInput(),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerModelAndPositionCommand("_executeDocumentRenameProvider", function(model, position, ...args) {
  const [newName] = args;
  assertType(typeof newName === "string");
  return rename(model, position, newName);
});
Registry.as(Extensions2.Configuration).registerConfiguration({
  id: "editor",
  properties: {
    "editor.rename.enablePreview": {
      scope: 5,
      description: localize("enablePreview", "Enable/disable the ability to preview changes before renaming"),
      default: true,
      type: "boolean"
    }
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/wordSelections.js
var WordSelectionRangeProvider = class {
  provideSelectionRanges(model, positions) {
    const result = [];
    for (const position of positions) {
      const bucket = [];
      result.push(bucket);
      this._addInWordRanges(bucket, model, position);
      this._addWordRanges(bucket, model, position);
      this._addWhitespaceLine(bucket, model, position);
      bucket.push({range: model.getFullModelRange()});
    }
    return result;
  }
  _addInWordRanges(bucket, model, pos) {
    const obj = model.getWordAtPosition(pos);
    if (!obj) {
      return;
    }
    let {word, startColumn} = obj;
    let offset = pos.column - startColumn;
    let start = offset;
    let end = offset;
    let lastCh = 0;
    for (; start >= 0; start--) {
      let ch = word.charCodeAt(start);
      if (start !== offset && (ch === 95 || ch === 45)) {
        break;
      } else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) {
        break;
      }
      lastCh = ch;
    }
    start += 1;
    for (; end < word.length; end++) {
      let ch = word.charCodeAt(end);
      if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) {
        break;
      } else if (ch === 95 || ch === 45) {
        break;
      }
      lastCh = ch;
    }
    if (start < end) {
      bucket.push({range: new Range2(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end)});
    }
  }
  _addWordRanges(bucket, model, pos) {
    const word = model.getWordAtPosition(pos);
    if (word) {
      bucket.push({range: new Range2(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn)});
    }
  }
  _addWhitespaceLine(bucket, model, pos) {
    if (model.getLineLength(pos.lineNumber) > 0 && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0 && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {
      bucket.push({range: new Range2(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber))});
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/bracketSelections.js
var __awaiter25 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BracketSelectionRangeProvider = class {
  provideSelectionRanges(model, positions) {
    return __awaiter25(this, void 0, void 0, function* () {
      const result = [];
      for (const position of positions) {
        const bucket = [];
        result.push(bucket);
        const ranges = new Map();
        yield new Promise((resolve) => BracketSelectionRangeProvider._bracketsRightYield(resolve, 0, model, position, ranges));
        yield new Promise((resolve) => BracketSelectionRangeProvider._bracketsLeftYield(resolve, 0, model, position, ranges, bucket));
      }
      return result;
    });
  }
  static _bracketsRightYield(resolve, round, model, pos, ranges) {
    const counts = new Map();
    const t1 = Date.now();
    while (true) {
      if (round >= BracketSelectionRangeProvider._maxRounds) {
        resolve();
        break;
      }
      if (!pos) {
        resolve();
        break;
      }
      let bracket = model.findNextBracket(pos);
      if (!bracket) {
        resolve();
        break;
      }
      let d = Date.now() - t1;
      if (d > BracketSelectionRangeProvider._maxDuration) {
        setTimeout(() => BracketSelectionRangeProvider._bracketsRightYield(resolve, round + 1, model, pos, ranges));
        break;
      }
      const key = bracket.close[0];
      if (bracket.isOpen) {
        let val = counts.has(key) ? counts.get(key) : 0;
        counts.set(key, val + 1);
      } else {
        let val = counts.has(key) ? counts.get(key) : 0;
        val -= 1;
        counts.set(key, Math.max(0, val));
        if (val < 0) {
          let list = ranges.get(key);
          if (!list) {
            list = new LinkedList();
            ranges.set(key, list);
          }
          list.push(bracket.range);
        }
      }
      pos = bracket.range.getEndPosition();
    }
  }
  static _bracketsLeftYield(resolve, round, model, pos, ranges, bucket) {
    const counts = new Map();
    const t1 = Date.now();
    while (true) {
      if (round >= BracketSelectionRangeProvider._maxRounds && ranges.size === 0) {
        resolve();
        break;
      }
      if (!pos) {
        resolve();
        break;
      }
      let bracket = model.findPrevBracket(pos);
      if (!bracket) {
        resolve();
        break;
      }
      let d = Date.now() - t1;
      if (d > BracketSelectionRangeProvider._maxDuration) {
        setTimeout(() => BracketSelectionRangeProvider._bracketsLeftYield(resolve, round + 1, model, pos, ranges, bucket));
        break;
      }
      const key = bracket.close[0];
      if (!bracket.isOpen) {
        let val = counts.has(key) ? counts.get(key) : 0;
        counts.set(key, val + 1);
      } else {
        let val = counts.has(key) ? counts.get(key) : 0;
        val -= 1;
        counts.set(key, Math.max(0, val));
        if (val < 0) {
          let list = ranges.get(key);
          if (list) {
            let closing = list.shift();
            if (list.size === 0) {
              ranges.delete(key);
            }
            const innerBracket = Range2.fromPositions(bracket.range.getEndPosition(), closing.getStartPosition());
            const outerBracket = Range2.fromPositions(bracket.range.getStartPosition(), closing.getEndPosition());
            bucket.push({range: innerBracket});
            bucket.push({range: outerBracket});
            BracketSelectionRangeProvider._addBracketLeading(model, outerBracket, bucket);
          }
        }
      }
      pos = bracket.range.getStartPosition();
    }
  }
  static _addBracketLeading(model, bracket, bucket) {
    if (bracket.startLineNumber === bracket.endLineNumber) {
      return;
    }
    const startLine = bracket.startLineNumber;
    const column = model.getLineFirstNonWhitespaceColumn(startLine);
    if (column !== 0 && column !== bracket.startColumn) {
      bucket.push({range: Range2.fromPositions(new Position(startLine, column), bracket.getEndPosition())});
      bucket.push({range: Range2.fromPositions(new Position(startLine, 1), bracket.getEndPosition())});
    }
    const aboveLine = startLine - 1;
    if (aboveLine > 0) {
      const column2 = model.getLineFirstNonWhitespaceColumn(aboveLine);
      if (column2 === bracket.startColumn && column2 !== model.getLineLastNonWhitespaceColumn(aboveLine)) {
        bucket.push({range: Range2.fromPositions(new Position(aboveLine, column2), bracket.getEndPosition())});
        bucket.push({range: Range2.fromPositions(new Position(aboveLine, 1), bracket.getEndPosition())});
      }
    }
  }
};
BracketSelectionRangeProvider._maxDuration = 30;
BracketSelectionRangeProvider._maxRounds = 2;

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/smartSelect.js
var __awaiter26 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SelectionRanges = class {
  constructor(index2, ranges) {
    this.index = index2;
    this.ranges = ranges;
  }
  mov(fwd) {
    let index2 = this.index + (fwd ? 1 : -1);
    if (index2 < 0 || index2 >= this.ranges.length) {
      return this;
    }
    const res = new SelectionRanges(index2, this.ranges);
    if (res.ranges[index2].equalsRange(this.ranges[this.index])) {
      return res.mov(fwd);
    }
    return res;
  }
};
var SmartSelectController = class {
  constructor(editor3) {
    this._ignoreSelection = false;
    this._editor = editor3;
  }
  static get(editor3) {
    return editor3.getContribution(SmartSelectController.ID);
  }
  dispose() {
    dispose(this._selectionListener);
  }
  run(forward) {
    if (!this._editor.hasModel()) {
      return;
    }
    const selections = this._editor.getSelections();
    const model = this._editor.getModel();
    if (!SelectionRangeRegistry.has(model)) {
      return;
    }
    let promise3 = Promise.resolve(void 0);
    if (!this._state) {
      promise3 = provideSelectionRanges(model, selections.map((s) => s.getPosition()), CancellationToken.None).then((ranges) => {
        if (!isNonEmptyArray(ranges) || ranges.length !== selections.length) {
          return;
        }
        if (!this._editor.hasModel() || !equals(this._editor.getSelections(), selections, (a, b) => a.equalsSelection(b))) {
          return;
        }
        for (let i = 0; i < ranges.length; i++) {
          ranges[i] = ranges[i].filter((range2) => {
            return range2.containsPosition(selections[i].getStartPosition()) && range2.containsPosition(selections[i].getEndPosition());
          });
          ranges[i].unshift(selections[i]);
        }
        this._state = ranges.map((ranges2) => new SelectionRanges(0, ranges2));
        dispose(this._selectionListener);
        this._selectionListener = this._editor.onDidChangeCursorPosition(() => {
          if (!this._ignoreSelection) {
            dispose(this._selectionListener);
            this._state = void 0;
          }
        });
      });
    }
    return promise3.then(() => {
      if (!this._state) {
        return;
      }
      this._state = this._state.map((state) => state.mov(forward));
      const selections2 = this._state.map((state) => Selection.fromPositions(state.ranges[state.index].getStartPosition(), state.ranges[state.index].getEndPosition()));
      this._ignoreSelection = true;
      try {
        this._editor.setSelections(selections2);
      } finally {
        this._ignoreSelection = false;
      }
    });
  }
};
SmartSelectController.ID = "editor.contrib.smartSelectController";
var AbstractSmartSelect = class extends EditorAction {
  constructor(forward, opts) {
    super(opts);
    this._forward = forward;
  }
  run(_accessor, editor3) {
    return __awaiter26(this, void 0, void 0, function* () {
      let controller = SmartSelectController.get(editor3);
      if (controller) {
        yield controller.run(this._forward);
      }
    });
  }
};
var GrowSelectionAction = class extends AbstractSmartSelect {
  constructor() {
    super(true, {
      id: "editor.action.smartSelect.expand",
      label: localize("smartSelect.expand", "Expand Selection"),
      alias: "Expand Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 17,
        mac: {
          primary: 2048 | 256 | 1024 | 17,
          secondary: [256 | 1024 | 17]
        },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "1_basic",
        title: localize({key: "miSmartSelectGrow", comment: ["&& denotes a mnemonic"]}, "&&Expand Selection"),
        order: 2
      }
    });
  }
};
CommandsRegistry.registerCommandAlias("editor.action.smartSelect.grow", "editor.action.smartSelect.expand");
var ShrinkSelectionAction = class extends AbstractSmartSelect {
  constructor() {
    super(false, {
      id: "editor.action.smartSelect.shrink",
      label: localize("smartSelect.shrink", "Shrink Selection"),
      alias: "Shrink Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 15,
        mac: {
          primary: 2048 | 256 | 1024 | 15,
          secondary: [256 | 1024 | 15]
        },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "1_basic",
        title: localize({key: "miSmartSelectShrink", comment: ["&& denotes a mnemonic"]}, "&&Shrink Selection"),
        order: 3
      }
    });
  }
};
registerEditorContribution(SmartSelectController.ID, SmartSelectController);
registerEditorAction(GrowSelectionAction);
registerEditorAction(ShrinkSelectionAction);
SelectionRangeRegistry.register("*", new WordSelectionRangeProvider());
function provideSelectionRanges(model, positions, token) {
  const providers = SelectionRangeRegistry.all(model);
  if (providers.length === 1) {
    providers.unshift(new BracketSelectionRangeProvider());
  }
  let work = [];
  let allRawRanges = [];
  for (const provider of providers) {
    work.push(Promise.resolve(provider.provideSelectionRanges(model, positions, token)).then((allProviderRanges) => {
      if (isNonEmptyArray(allProviderRanges) && allProviderRanges.length === positions.length) {
        for (let i = 0; i < positions.length; i++) {
          if (!allRawRanges[i]) {
            allRawRanges[i] = [];
          }
          for (const oneProviderRanges of allProviderRanges[i]) {
            if (Range2.isIRange(oneProviderRanges.range) && Range2.containsPosition(oneProviderRanges.range, positions[i])) {
              allRawRanges[i].push(Range2.lift(oneProviderRanges.range));
            }
          }
        }
      }
    }, onUnexpectedExternalError));
  }
  return Promise.all(work).then(() => {
    return allRawRanges.map((oneRawRanges) => {
      if (oneRawRanges.length === 0) {
        return [];
      }
      oneRawRanges.sort((a, b) => {
        if (Position.isBefore(a.getStartPosition(), b.getStartPosition())) {
          return 1;
        } else if (Position.isBefore(b.getStartPosition(), a.getStartPosition())) {
          return -1;
        } else if (Position.isBefore(a.getEndPosition(), b.getEndPosition())) {
          return -1;
        } else if (Position.isBefore(b.getEndPosition(), a.getEndPosition())) {
          return 1;
        } else {
          return 0;
        }
      });
      let oneRanges = [];
      let last;
      for (const range2 of oneRawRanges) {
        if (!last || Range2.containsRange(range2, last) && !Range2.equalsRange(range2, last)) {
          oneRanges.push(range2);
          last = range2;
        }
      }
      let oneRangesWithTrivia = [oneRanges[0]];
      for (let i = 1; i < oneRanges.length; i++) {
        const prev = oneRanges[i - 1];
        const cur = oneRanges[i];
        if (cur.startLineNumber !== prev.startLineNumber || cur.endLineNumber !== prev.endLineNumber) {
          const rangeNoWhitespace = new Range2(prev.startLineNumber, model.getLineFirstNonWhitespaceColumn(prev.startLineNumber), prev.endLineNumber, model.getLineLastNonWhitespaceColumn(prev.endLineNumber));
          if (rangeNoWhitespace.containsRange(prev) && !rangeNoWhitespace.equalsRange(prev) && cur.containsRange(rangeNoWhitespace) && !cur.equalsRange(rangeNoWhitespace)) {
            oneRangesWithTrivia.push(rangeNoWhitespace);
          }
          const rangeFull = new Range2(prev.startLineNumber, 1, prev.endLineNumber, model.getLineMaxColumn(prev.endLineNumber));
          if (rangeFull.containsRange(prev) && !rangeFull.equalsRange(rangeNoWhitespace) && cur.containsRange(rangeFull) && !cur.equalsRange(rangeFull)) {
            oneRangesWithTrivia.push(rangeFull);
          }
        }
        oneRangesWithTrivia.push(cur);
      }
      return oneRangesWithTrivia;
    });
  });
}
registerModelCommand("_executeSelectionRangeProvider", function(model, ...args) {
  const [positions] = args;
  return provideSelectionRanges(model, positions, CancellationToken.None);
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetParser.js
var Scanner = class {
  constructor() {
    this.value = "";
    this.pos = 0;
  }
  static isDigitCharacter(ch) {
    return ch >= 48 && ch <= 57;
  }
  static isVariableCharacter(ch) {
    return ch === 95 || ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90;
  }
  text(value) {
    this.value = value;
    this.pos = 0;
  }
  tokenText(token) {
    return this.value.substr(token.pos, token.len);
  }
  next() {
    if (this.pos >= this.value.length) {
      return {type: 14, pos: this.pos, len: 0};
    }
    let pos = this.pos;
    let len = 0;
    let ch = this.value.charCodeAt(pos);
    let type;
    type = Scanner._table[ch];
    if (typeof type === "number") {
      this.pos += 1;
      return {type, pos, len: 1};
    }
    if (Scanner.isDigitCharacter(ch)) {
      type = 8;
      do {
        len += 1;
        ch = this.value.charCodeAt(pos + len);
      } while (Scanner.isDigitCharacter(ch));
      this.pos += len;
      return {type, pos, len};
    }
    if (Scanner.isVariableCharacter(ch)) {
      type = 9;
      do {
        ch = this.value.charCodeAt(pos + ++len);
      } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));
      this.pos += len;
      return {type, pos, len};
    }
    type = 10;
    do {
      len += 1;
      ch = this.value.charCodeAt(pos + len);
    } while (!isNaN(ch) && typeof Scanner._table[ch] === "undefined" && !Scanner.isDigitCharacter(ch) && !Scanner.isVariableCharacter(ch));
    this.pos += len;
    return {type, pos, len};
  }
};
Scanner._table = {
  [36]: 0,
  [58]: 1,
  [44]: 2,
  [123]: 3,
  [125]: 4,
  [92]: 5,
  [47]: 6,
  [124]: 7,
  [43]: 11,
  [45]: 12,
  [63]: 13
};
var Marker = class {
  constructor() {
    this._children = [];
  }
  appendChild(child) {
    if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
      this._children[this._children.length - 1].value += child.value;
    } else {
      child.parent = this;
      this._children.push(child);
    }
    return this;
  }
  replace(child, others) {
    const {parent: parent2} = child;
    const idx = parent2.children.indexOf(child);
    const newChildren = parent2.children.slice(0);
    newChildren.splice(idx, 1, ...others);
    parent2._children = newChildren;
    (function _fixParent(children, parent3) {
      for (const child2 of children) {
        child2.parent = parent3;
        _fixParent(child2.children, child2);
      }
    })(others, parent2);
  }
  get children() {
    return this._children;
  }
  get snippet() {
    let candidate = this;
    while (true) {
      if (!candidate) {
        return void 0;
      }
      if (candidate instanceof TextmateSnippet) {
        return candidate;
      }
      candidate = candidate.parent;
    }
  }
  toString() {
    return this.children.reduce((prev, cur) => prev + cur.toString(), "");
  }
  len() {
    return 0;
  }
};
var Text = class extends Marker {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return this.value;
  }
  len() {
    return this.value.length;
  }
  clone() {
    return new Text(this.value);
  }
};
var TransformableMarker = class extends Marker {
};
var Placeholder = class extends TransformableMarker {
  constructor(index2) {
    super();
    this.index = index2;
  }
  static compareByIndex(a, b) {
    if (a.index === b.index) {
      return 0;
    } else if (a.isFinalTabstop) {
      return 1;
    } else if (b.isFinalTabstop) {
      return -1;
    } else if (a.index < b.index) {
      return -1;
    } else if (a.index > b.index) {
      return 1;
    } else {
      return 0;
    }
  }
  get isFinalTabstop() {
    return this.index === 0;
  }
  get choice() {
    return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
  }
  clone() {
    let ret = new Placeholder(this.index);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
var Choice = class extends Marker {
  constructor() {
    super(...arguments);
    this.options = [];
  }
  appendChild(marker) {
    if (marker instanceof Text) {
      marker.parent = this;
      this.options.push(marker);
    }
    return this;
  }
  toString() {
    return this.options[0].value;
  }
  len() {
    return this.options[0].len();
  }
  clone() {
    let ret = new Choice();
    this.options.forEach(ret.appendChild, ret);
    return ret;
  }
};
var Transform = class extends Marker {
  constructor() {
    super(...arguments);
    this.regexp = new RegExp("");
  }
  resolve(value) {
    const _this = this;
    let didMatch = false;
    let ret = value.replace(this.regexp, function() {
      didMatch = true;
      return _this._replace(Array.prototype.slice.call(arguments, 0, -2));
    });
    if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
      ret = this._replace([]);
    }
    return ret;
  }
  _replace(groups) {
    let ret = "";
    for (const marker of this._children) {
      if (marker instanceof FormatString) {
        let value = groups[marker.index] || "";
        value = marker.resolve(value);
        ret += value;
      } else {
        ret += marker.toString();
      }
    }
    return ret;
  }
  toString() {
    return "";
  }
  clone() {
    let ret = new Transform();
    ret.regexp = new RegExp(this.regexp.source, "" + (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
var FormatString = class extends Marker {
  constructor(index2, shorthandName, ifValue, elseValue) {
    super();
    this.index = index2;
    this.shorthandName = shorthandName;
    this.ifValue = ifValue;
    this.elseValue = elseValue;
  }
  resolve(value) {
    if (this.shorthandName === "upcase") {
      return !value ? "" : value.toLocaleUpperCase();
    } else if (this.shorthandName === "downcase") {
      return !value ? "" : value.toLocaleLowerCase();
    } else if (this.shorthandName === "capitalize") {
      return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
    } else if (this.shorthandName === "pascalcase") {
      return !value ? "" : this._toPascalCase(value);
    } else if (Boolean(value) && typeof this.ifValue === "string") {
      return this.ifValue;
    } else if (!Boolean(value) && typeof this.elseValue === "string") {
      return this.elseValue;
    } else {
      return value || "";
    }
  }
  _toPascalCase(value) {
    const match = value.match(/[a-z]+/gi);
    if (!match) {
      return value;
    }
    return match.map(function(word) {
      return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
    }).join("");
  }
  clone() {
    let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
    return ret;
  }
};
var Variable = class extends TransformableMarker {
  constructor(name) {
    super();
    this.name = name;
  }
  resolve(resolver) {
    let value = resolver.resolve(this);
    if (this.transform) {
      value = this.transform.resolve(value || "");
    }
    if (value !== void 0) {
      this._children = [new Text(value)];
      return true;
    }
    return false;
  }
  clone() {
    const ret = new Variable(this.name);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
function walk(marker, visitor) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
var TextmateSnippet = class extends Marker {
  get placeholderInfo() {
    if (!this._placeholders) {
      let all2 = [];
      let last;
      this.walk(function(candidate) {
        if (candidate instanceof Placeholder) {
          all2.push(candidate);
          last = !last || last.index < candidate.index ? candidate : last;
        }
        return true;
      });
      this._placeholders = {all: all2, last};
    }
    return this._placeholders;
  }
  get placeholders() {
    const {all: all2} = this.placeholderInfo;
    return all2;
  }
  offset(marker) {
    let pos = 0;
    let found = false;
    this.walk((candidate) => {
      if (candidate === marker) {
        found = true;
        return false;
      }
      pos += candidate.len();
      return true;
    });
    if (!found) {
      return -1;
    }
    return pos;
  }
  fullLen(marker) {
    let ret = 0;
    walk([marker], (marker2) => {
      ret += marker2.len();
      return true;
    });
    return ret;
  }
  enclosingPlaceholders(placeholder) {
    let ret = [];
    let {parent: parent2} = placeholder;
    while (parent2) {
      if (parent2 instanceof Placeholder) {
        ret.push(parent2);
      }
      parent2 = parent2.parent;
    }
    return ret;
  }
  resolveVariables(resolver) {
    this.walk((candidate) => {
      if (candidate instanceof Variable) {
        if (candidate.resolve(resolver)) {
          this._placeholders = void 0;
        }
      }
      return true;
    });
    return this;
  }
  appendChild(child) {
    this._placeholders = void 0;
    return super.appendChild(child);
  }
  replace(child, others) {
    this._placeholders = void 0;
    return super.replace(child, others);
  }
  clone() {
    let ret = new TextmateSnippet();
    this._children = this.children.map((child) => child.clone());
    return ret;
  }
  walk(visitor) {
    walk(this.children, visitor);
  }
};
var SnippetParser = class {
  constructor() {
    this._scanner = new Scanner();
    this._token = {type: 14, pos: 0, len: 0};
  }
  static escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  static guessNeedsClipboard(template) {
    return /\${?CLIPBOARD/.test(template);
  }
  parse(value, insertFinalTabstop, enforceFinalTabstop) {
    this._scanner.text(value);
    this._token = this._scanner.next();
    const snippet = new TextmateSnippet();
    while (this._parse(snippet)) {
    }
    const placeholderDefaultValues = new Map();
    const incompletePlaceholders = [];
    let placeholderCount = 0;
    snippet.walk((marker) => {
      if (marker instanceof Placeholder) {
        placeholderCount += 1;
        if (marker.isFinalTabstop) {
          placeholderDefaultValues.set(0, void 0);
        } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {
          placeholderDefaultValues.set(marker.index, marker.children);
        } else {
          incompletePlaceholders.push(marker);
        }
      }
      return true;
    });
    for (const placeholder of incompletePlaceholders) {
      const defaultValues = placeholderDefaultValues.get(placeholder.index);
      if (defaultValues) {
        const clone = new Placeholder(placeholder.index);
        clone.transform = placeholder.transform;
        for (const child of defaultValues) {
          clone.appendChild(child.clone());
        }
        snippet.replace(placeholder, [clone]);
      }
    }
    if (!enforceFinalTabstop) {
      enforceFinalTabstop = placeholderCount > 0 && insertFinalTabstop;
    }
    if (!placeholderDefaultValues.has(0) && enforceFinalTabstop) {
      snippet.appendChild(new Placeholder(0));
    }
    return snippet;
  }
  _accept(type, value) {
    if (type === void 0 || this._token.type === type) {
      let ret = !value ? true : this._scanner.tokenText(this._token);
      this._token = this._scanner.next();
      return ret;
    }
    return false;
  }
  _backTo(token) {
    this._scanner.pos = token.pos + token.len;
    this._token = token;
    return false;
  }
  _until(type) {
    const start = this._token;
    while (this._token.type !== type) {
      if (this._token.type === 14) {
        return false;
      } else if (this._token.type === 5) {
        const nextToken = this._scanner.next();
        if (nextToken.type !== 0 && nextToken.type !== 4 && nextToken.type !== 5) {
          return false;
        }
      }
      this._token = this._scanner.next();
    }
    const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\(\$|}|\\)/g, "$1");
    this._token = this._scanner.next();
    return value;
  }
  _parse(marker) {
    return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
  }
  _parseEscaped(marker) {
    let value;
    if (value = this._accept(5, true)) {
      value = this._accept(0, true) || this._accept(4, true) || this._accept(5, true) || value;
      marker.appendChild(new Text(value));
      return true;
    }
    return false;
  }
  _parseTabstopOrVariableName(parent2) {
    let value;
    const token = this._token;
    const match = this._accept(0) && (value = this._accept(9, true) || this._accept(8, true));
    if (!match) {
      return this._backTo(token);
    }
    parent2.appendChild(/^\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));
    return true;
  }
  _parseComplexPlaceholder(parent2) {
    let index2;
    const token = this._token;
    const match = this._accept(0) && this._accept(3) && (index2 = this._accept(8, true));
    if (!match) {
      return this._backTo(token);
    }
    const placeholder = new Placeholder(Number(index2));
    if (this._accept(1)) {
      while (true) {
        if (this._accept(4)) {
          parent2.appendChild(placeholder);
          return true;
        }
        if (this._parse(placeholder)) {
          continue;
        }
        parent2.appendChild(new Text("${" + index2 + ":"));
        placeholder.children.forEach(parent2.appendChild, parent2);
        return true;
      }
    } else if (placeholder.index > 0 && this._accept(7)) {
      const choice = new Choice();
      while (true) {
        if (this._parseChoiceElement(choice)) {
          if (this._accept(2)) {
            continue;
          }
          if (this._accept(7)) {
            placeholder.appendChild(choice);
            if (this._accept(4)) {
              parent2.appendChild(placeholder);
              return true;
            }
          }
        }
        this._backTo(token);
        return false;
      }
    } else if (this._accept(6)) {
      if (this._parseTransform(placeholder)) {
        parent2.appendChild(placeholder);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4)) {
      parent2.appendChild(placeholder);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseChoiceElement(parent2) {
    const token = this._token;
    const values = [];
    while (true) {
      if (this._token.type === 2 || this._token.type === 7) {
        break;
      }
      let value;
      if (value = this._accept(5, true)) {
        value = this._accept(2, true) || this._accept(7, true) || this._accept(5, true) || value;
      } else {
        value = this._accept(void 0, true);
      }
      if (!value) {
        this._backTo(token);
        return false;
      }
      values.push(value);
    }
    if (values.length === 0) {
      this._backTo(token);
      return false;
    }
    parent2.appendChild(new Text(values.join("")));
    return true;
  }
  _parseComplexVariable(parent2) {
    let name;
    const token = this._token;
    const match = this._accept(0) && this._accept(3) && (name = this._accept(9, true));
    if (!match) {
      return this._backTo(token);
    }
    const variable = new Variable(name);
    if (this._accept(1)) {
      while (true) {
        if (this._accept(4)) {
          parent2.appendChild(variable);
          return true;
        }
        if (this._parse(variable)) {
          continue;
        }
        parent2.appendChild(new Text("${" + name + ":"));
        variable.children.forEach(parent2.appendChild, parent2);
        return true;
      }
    } else if (this._accept(6)) {
      if (this._parseTransform(variable)) {
        parent2.appendChild(variable);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4)) {
      parent2.appendChild(variable);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseTransform(parent2) {
    let transform = new Transform();
    let regexValue = "";
    let regexOptions = "";
    while (true) {
      if (this._accept(6)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5, true)) {
        escaped = this._accept(6, true) || escaped;
        regexValue += escaped;
        continue;
      }
      if (this._token.type !== 14) {
        regexValue += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(6)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5, true)) {
        escaped = this._accept(5, true) || this._accept(6, true) || escaped;
        transform.appendChild(new Text(escaped));
        continue;
      }
      if (this._parseFormatString(transform) || this._parseAnything(transform)) {
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(4)) {
        break;
      }
      if (this._token.type !== 14) {
        regexOptions += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    try {
      transform.regexp = new RegExp(regexValue, regexOptions);
    } catch (e) {
      return false;
    }
    parent2.transform = transform;
    return true;
  }
  _parseFormatString(parent2) {
    const token = this._token;
    if (!this._accept(0)) {
      return false;
    }
    let complex = false;
    if (this._accept(3)) {
      complex = true;
    }
    let index2 = this._accept(8, true);
    if (!index2) {
      this._backTo(token);
      return false;
    } else if (!complex) {
      parent2.appendChild(new FormatString(Number(index2)));
      return true;
    } else if (this._accept(4)) {
      parent2.appendChild(new FormatString(Number(index2)));
      return true;
    } else if (!this._accept(1)) {
      this._backTo(token);
      return false;
    }
    if (this._accept(6)) {
      let shorthand = this._accept(9, true);
      if (!shorthand || !this._accept(4)) {
        this._backTo(token);
        return false;
      } else {
        parent2.appendChild(new FormatString(Number(index2), shorthand));
        return true;
      }
    } else if (this._accept(11)) {
      let ifValue = this._until(4);
      if (ifValue) {
        parent2.appendChild(new FormatString(Number(index2), void 0, ifValue, void 0));
        return true;
      }
    } else if (this._accept(12)) {
      let elseValue = this._until(4);
      if (elseValue) {
        parent2.appendChild(new FormatString(Number(index2), void 0, void 0, elseValue));
        return true;
      }
    } else if (this._accept(13)) {
      let ifValue = this._until(1);
      if (ifValue) {
        let elseValue = this._until(4);
        if (elseValue) {
          parent2.appendChild(new FormatString(Number(index2), void 0, ifValue, elseValue));
          return true;
        }
      }
    } else {
      let elseValue = this._until(4);
      if (elseValue) {
        parent2.appendChild(new FormatString(Number(index2), void 0, void 0, elseValue));
        return true;
      }
    }
    this._backTo(token);
    return false;
  }
  _parseAnything(marker) {
    if (this._token.type !== 14) {
      marker.appendChild(new Text(this._scanner.tokenText(this._token)));
      this._accept(void 0);
      return true;
    }
    return false;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggest.js
var __awaiter27 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Context2 = {
  Visible: new RawContextKey("suggestWidgetVisible", false),
  DetailsVisible: new RawContextKey("suggestWidgetDetailsVisible", false),
  MultipleSuggestions: new RawContextKey("suggestWidgetMultipleSuggestions", false),
  MakesTextEdit: new RawContextKey("suggestionMakesTextEdit", true),
  AcceptSuggestionsOnEnter: new RawContextKey("acceptSuggestionOnEnter", true),
  HasInsertAndReplaceRange: new RawContextKey("suggestionHasInsertAndReplaceRange", false),
  CanResolve: new RawContextKey("suggestionCanResolve", false)
};
var suggestWidgetStatusbarMenu = new MenuId("suggestWidgetStatusBar");
var CompletionItem = class {
  constructor(position, completion, container, provider) {
    this.position = position;
    this.completion = completion;
    this.container = container;
    this.provider = provider;
    this.isInvalid = false;
    this.score = FuzzyScore.Default;
    this.distance = 0;
    this.textLabel = typeof completion.label === "string" ? completion.label : completion.label.name;
    this.labelLow = this.textLabel.toLowerCase();
    this.isInvalid = !this.textLabel;
    this.sortTextLow = completion.sortText && completion.sortText.toLowerCase();
    this.filterTextLow = completion.filterText && completion.filterText.toLowerCase();
    if (Range2.isIRange(completion.range)) {
      this.editStart = new Position(completion.range.startLineNumber, completion.range.startColumn);
      this.editInsertEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);
      this.editReplaceEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);
      this.isInvalid = this.isInvalid || Range2.spansMultipleLines(completion.range) || completion.range.startLineNumber !== position.lineNumber;
    } else {
      this.editStart = new Position(completion.range.insert.startLineNumber, completion.range.insert.startColumn);
      this.editInsertEnd = new Position(completion.range.insert.endLineNumber, completion.range.insert.endColumn);
      this.editReplaceEnd = new Position(completion.range.replace.endLineNumber, completion.range.replace.endColumn);
      this.isInvalid = this.isInvalid || Range2.spansMultipleLines(completion.range.insert) || Range2.spansMultipleLines(completion.range.replace) || completion.range.insert.startLineNumber !== position.lineNumber || completion.range.replace.startLineNumber !== position.lineNumber || completion.range.insert.startColumn !== completion.range.replace.startColumn;
    }
    if (typeof provider.resolveCompletionItem !== "function") {
      this._resolveCache = Promise.resolve();
      this._isResolved = true;
    }
  }
  get isResolved() {
    return !!this._isResolved;
  }
  resolve(token) {
    return __awaiter27(this, void 0, void 0, function* () {
      if (!this._resolveCache) {
        const sub = token.onCancellationRequested(() => {
          this._resolveCache = void 0;
          this._isResolved = false;
        });
        this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, token)).then((value) => {
          Object.assign(this.completion, value);
          this._isResolved = true;
          sub.dispose();
        }, (err) => {
          if (isPromiseCanceledError(err)) {
            this._resolveCache = void 0;
            this._isResolved = false;
          }
        });
      }
      return this._resolveCache;
    });
  }
};
var CompletionOptions = class {
  constructor(snippetSortOrder = 2, kindFilter = new Set(), providerFilter = new Set()) {
    this.snippetSortOrder = snippetSortOrder;
    this.kindFilter = kindFilter;
    this.providerFilter = providerFilter;
  }
};
CompletionOptions.default = new CompletionOptions();
var _snippetSuggestSupport;
function getSnippetSuggestSupport() {
  return _snippetSuggestSupport;
}
var CompletionItemModel = class {
  constructor(items, needsClipboard, dispoables) {
    this.items = items;
    this.needsClipboard = needsClipboard;
    this.dispoables = dispoables;
  }
};
function provideSuggestionItems(model, position, options = CompletionOptions.default, context2 = {triggerKind: 0}, token = CancellationToken.None) {
  return __awaiter27(this, void 0, void 0, function* () {
    position = position.clone();
    const word = model.getWordAtPosition(position);
    const defaultReplaceRange = word ? new Range2(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn) : Range2.fromPositions(position);
    const defaultRange = {replace: defaultReplaceRange, insert: defaultReplaceRange.setEndPosition(position.lineNumber, position.column)};
    const result = [];
    const disposables = new DisposableStore();
    let needsClipboard = false;
    const onCompletionList = (provider, container) => {
      if (!container) {
        return;
      }
      for (let suggestion of container.suggestions) {
        if (!options.kindFilter.has(suggestion.kind)) {
          if (!suggestion.range) {
            suggestion.range = defaultRange;
          }
          if (!suggestion.sortText) {
            suggestion.sortText = typeof suggestion.label === "string" ? suggestion.label : suggestion.label.name;
          }
          if (!needsClipboard && suggestion.insertTextRules && suggestion.insertTextRules & 4) {
            needsClipboard = SnippetParser.guessNeedsClipboard(suggestion.insertText);
          }
          result.push(new CompletionItem(position, suggestion, container, provider));
        }
      }
      if (isDisposable(container)) {
        disposables.add(container);
      }
    };
    const snippetCompletions = (() => __awaiter27(this, void 0, void 0, function* () {
      if (!_snippetSuggestSupport || options.kindFilter.has(27)) {
        return;
      }
      if (options.providerFilter.size > 0 && !options.providerFilter.has(_snippetSuggestSupport)) {
        return;
      }
      const list = yield _snippetSuggestSupport.provideCompletionItems(model, position, context2, token);
      onCompletionList(_snippetSuggestSupport, list);
    }))();
    for (let providerGroup of CompletionProviderRegistry.orderedGroups(model)) {
      let lenBefore = result.length;
      yield Promise.all(providerGroup.map((provider) => __awaiter27(this, void 0, void 0, function* () {
        if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) {
          return;
        }
        try {
          const list = yield provider.provideCompletionItems(model, position, context2, token);
          onCompletionList(provider, list);
        } catch (err) {
          onUnexpectedExternalError(err);
        }
      })));
      if (lenBefore !== result.length || token.isCancellationRequested) {
        break;
      }
    }
    yield snippetCompletions;
    if (token.isCancellationRequested) {
      disposables.dispose();
      return Promise.reject(canceled());
    }
    return new CompletionItemModel(result.sort(getSuggestionComparator(options.snippetSortOrder)), needsClipboard, disposables);
  });
}
function defaultComparator(a, b) {
  if (a.sortTextLow && b.sortTextLow) {
    if (a.sortTextLow < b.sortTextLow) {
      return -1;
    } else if (a.sortTextLow > b.sortTextLow) {
      return 1;
    }
  }
  if (a.completion.label < b.completion.label) {
    return -1;
  } else if (a.completion.label > b.completion.label) {
    return 1;
  }
  return a.completion.kind - b.completion.kind;
}
function snippetUpComparator(a, b) {
  if (a.completion.kind !== b.completion.kind) {
    if (a.completion.kind === 27) {
      return -1;
    } else if (b.completion.kind === 27) {
      return 1;
    }
  }
  return defaultComparator(a, b);
}
function snippetDownComparator(a, b) {
  if (a.completion.kind !== b.completion.kind) {
    if (a.completion.kind === 27) {
      return 1;
    } else if (b.completion.kind === 27) {
      return -1;
    }
  }
  return defaultComparator(a, b);
}
var _snippetComparators = new Map();
_snippetComparators.set(0, snippetUpComparator);
_snippetComparators.set(2, snippetDownComparator);
_snippetComparators.set(1, defaultComparator);
function getSuggestionComparator(snippetConfig) {
  return _snippetComparators.get(snippetConfig);
}
registerDefaultLanguageCommand("_executeCompletionItemProvider", (model, position, args) => __awaiter27(void 0, void 0, void 0, function* () {
  const result = {
    incomplete: false,
    suggestions: []
  };
  const resolving = [];
  const maxItemsToResolve = args["maxItemsToResolve"] || 0;
  const completions = yield provideSuggestionItems(model, position);
  for (const item of completions.items) {
    if (resolving.length < maxItemsToResolve) {
      resolving.push(item.resolve(CancellationToken.None));
    }
    result.incomplete = result.incomplete || item.container.incomplete;
    result.suggestions.push(item.completion);
  }
  try {
    yield Promise.all(resolving);
    return result;
  } finally {
    setTimeout(() => completions.dispoables.dispose(), 100);
  }
}));
var _provider = new class {
  constructor() {
    this.onlyOnceSuggestions = [];
  }
  provideCompletionItems() {
    let suggestions = this.onlyOnceSuggestions.slice(0);
    let result = {suggestions};
    this.onlyOnceSuggestions.length = 0;
    return result;
  }
}();
CompletionProviderRegistry.register("*", _provider);
function showSimpleSuggestions(editor3, suggestions) {
  setTimeout(() => {
    _provider.onlyOnceSuggestions.push(...suggestions);
    editor3.getContribution("editor.contrib.suggestController").triggerSuggest(new Set().add(_provider));
  }, 0);
}

// ../../node_modules/monaco-editor/esm/vs/platform/workspaces/common/workspaces.js
var WORKSPACE_EXTENSION = "code-workspace";
function isSingleFolderWorkspaceIdentifier(obj) {
  return obj instanceof URI;
}
function toWorkspaceIdentifier(workspace) {
  if (workspace.configuration) {
    return {
      configPath: workspace.configuration,
      id: workspace.id
    };
  }
  if (workspace.folders.length === 1) {
    return workspace.folders[0].uri;
  }
  return void 0;
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetVariables.js
var CompositeSnippetVariableResolver = class {
  constructor(_delegates) {
    this._delegates = _delegates;
  }
  resolve(variable) {
    for (const delegate of this._delegates) {
      let value = delegate.resolve(variable);
      if (value !== void 0) {
        return value;
      }
    }
    return void 0;
  }
};
var SelectionBasedVariableResolver = class {
  constructor(_model, _selection, _selectionIdx, _overtypingCapturer) {
    this._model = _model;
    this._selection = _selection;
    this._selectionIdx = _selectionIdx;
    this._overtypingCapturer = _overtypingCapturer;
  }
  resolve(variable) {
    const {name} = variable;
    if (name === "SELECTION" || name === "TM_SELECTED_TEXT") {
      let value = this._model.getValueInRange(this._selection) || void 0;
      let isMultiline = this._selection.startLineNumber !== this._selection.endLineNumber;
      if (!value && this._overtypingCapturer) {
        const info = this._overtypingCapturer.getLastOvertypedInfo(this._selectionIdx);
        if (info) {
          value = info.value;
          isMultiline = info.multiline;
        }
      }
      if (value && isMultiline && variable.snippet) {
        const line = this._model.getLineContent(this._selection.startLineNumber);
        const lineLeadingWhitespace = getLeadingWhitespace(line, 0, this._selection.startColumn - 1);
        let varLeadingWhitespace = lineLeadingWhitespace;
        variable.snippet.walk((marker) => {
          if (marker === variable) {
            return false;
          }
          if (marker instanceof Text) {
            varLeadingWhitespace = getLeadingWhitespace(marker.value.split(/\r\n|\r|\n/).pop());
          }
          return true;
        });
        const whitespaceCommonLength = commonPrefixLength(varLeadingWhitespace, lineLeadingWhitespace);
        value = value.replace(/(\r\n|\r|\n)(.*)/g, (m, newline, rest) => `${newline}${varLeadingWhitespace.substr(whitespaceCommonLength)}${rest}`);
      }
      return value;
    } else if (name === "TM_CURRENT_LINE") {
      return this._model.getLineContent(this._selection.positionLineNumber);
    } else if (name === "TM_CURRENT_WORD") {
      const info = this._model.getWordAtPosition({
        lineNumber: this._selection.positionLineNumber,
        column: this._selection.positionColumn
      });
      return info && info.word || void 0;
    } else if (name === "TM_LINE_INDEX") {
      return String(this._selection.positionLineNumber - 1);
    } else if (name === "TM_LINE_NUMBER") {
      return String(this._selection.positionLineNumber);
    }
    return void 0;
  }
};
var ModelBasedVariableResolver = class {
  constructor(_labelService, _model) {
    this._labelService = _labelService;
    this._model = _model;
  }
  resolve(variable) {
    const {name} = variable;
    if (name === "TM_FILENAME") {
      return basename2(this._model.uri.fsPath);
    } else if (name === "TM_FILENAME_BASE") {
      const name2 = basename2(this._model.uri.fsPath);
      const idx = name2.lastIndexOf(".");
      if (idx <= 0) {
        return name2;
      } else {
        return name2.slice(0, idx);
      }
    } else if (name === "TM_DIRECTORY" && this._labelService) {
      if (dirname2(this._model.uri.fsPath) === ".") {
        return "";
      }
      return this._labelService.getUriLabel(dirname(this._model.uri));
    } else if (name === "TM_FILEPATH" && this._labelService) {
      return this._labelService.getUriLabel(this._model.uri);
    }
    return void 0;
  }
};
var ClipboardBasedVariableResolver = class {
  constructor(_readClipboardText, _selectionIdx, _selectionCount, _spread) {
    this._readClipboardText = _readClipboardText;
    this._selectionIdx = _selectionIdx;
    this._selectionCount = _selectionCount;
    this._spread = _spread;
  }
  resolve(variable) {
    if (variable.name !== "CLIPBOARD") {
      return void 0;
    }
    const clipboardText = this._readClipboardText();
    if (!clipboardText) {
      return void 0;
    }
    if (this._spread) {
      const lines = clipboardText.split(/\r\n|\n|\r/).filter((s) => !isFalsyOrWhitespace(s));
      if (lines.length === this._selectionCount) {
        return lines[this._selectionIdx];
      }
    }
    return clipboardText;
  }
};
var CommentBasedVariableResolver = class {
  constructor(_model, _selection) {
    this._model = _model;
    this._selection = _selection;
  }
  resolve(variable) {
    const {name} = variable;
    const langId = this._model.getLanguageIdAtPosition(this._selection.selectionStartLineNumber, this._selection.selectionStartColumn);
    const config = LanguageConfigurationRegistry.getComments(langId);
    if (!config) {
      return void 0;
    }
    if (name === "LINE_COMMENT") {
      return config.lineCommentToken || void 0;
    } else if (name === "BLOCK_COMMENT_START") {
      return config.blockCommentStartToken || void 0;
    } else if (name === "BLOCK_COMMENT_END") {
      return config.blockCommentEndToken || void 0;
    }
    return void 0;
  }
};
var TimeBasedVariableResolver = class {
  resolve(variable) {
    const {name} = variable;
    if (name === "CURRENT_YEAR") {
      return String(new Date().getFullYear());
    } else if (name === "CURRENT_YEAR_SHORT") {
      return String(new Date().getFullYear()).slice(-2);
    } else if (name === "CURRENT_MONTH") {
      return String(new Date().getMonth().valueOf() + 1).padStart(2, "0");
    } else if (name === "CURRENT_DATE") {
      return String(new Date().getDate().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_HOUR") {
      return String(new Date().getHours().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_MINUTE") {
      return String(new Date().getMinutes().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_SECOND") {
      return String(new Date().getSeconds().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_DAY_NAME") {
      return TimeBasedVariableResolver.dayNames[new Date().getDay()];
    } else if (name === "CURRENT_DAY_NAME_SHORT") {
      return TimeBasedVariableResolver.dayNamesShort[new Date().getDay()];
    } else if (name === "CURRENT_MONTH_NAME") {
      return TimeBasedVariableResolver.monthNames[new Date().getMonth()];
    } else if (name === "CURRENT_MONTH_NAME_SHORT") {
      return TimeBasedVariableResolver.monthNamesShort[new Date().getMonth()];
    } else if (name === "CURRENT_SECONDS_UNIX") {
      return String(Math.floor(Date.now() / 1e3));
    }
    return void 0;
  }
};
TimeBasedVariableResolver.dayNames = [localize("Sunday", "Sunday"), localize("Monday", "Monday"), localize("Tuesday", "Tuesday"), localize("Wednesday", "Wednesday"), localize("Thursday", "Thursday"), localize("Friday", "Friday"), localize("Saturday", "Saturday")];
TimeBasedVariableResolver.dayNamesShort = [localize("SundayShort", "Sun"), localize("MondayShort", "Mon"), localize("TuesdayShort", "Tue"), localize("WednesdayShort", "Wed"), localize("ThursdayShort", "Thu"), localize("FridayShort", "Fri"), localize("SaturdayShort", "Sat")];
TimeBasedVariableResolver.monthNames = [localize("January", "January"), localize("February", "February"), localize("March", "March"), localize("April", "April"), localize("May", "May"), localize("June", "June"), localize("July", "July"), localize("August", "August"), localize("September", "September"), localize("October", "October"), localize("November", "November"), localize("December", "December")];
TimeBasedVariableResolver.monthNamesShort = [localize("JanuaryShort", "Jan"), localize("FebruaryShort", "Feb"), localize("MarchShort", "Mar"), localize("AprilShort", "Apr"), localize("MayShort", "May"), localize("JuneShort", "Jun"), localize("JulyShort", "Jul"), localize("AugustShort", "Aug"), localize("SeptemberShort", "Sep"), localize("OctoberShort", "Oct"), localize("NovemberShort", "Nov"), localize("DecemberShort", "Dec")];
var WorkspaceBasedVariableResolver = class {
  constructor(_workspaceService) {
    this._workspaceService = _workspaceService;
  }
  resolve(variable) {
    if (!this._workspaceService) {
      return void 0;
    }
    const workspaceIdentifier = toWorkspaceIdentifier(this._workspaceService.getWorkspace());
    if (!workspaceIdentifier) {
      return void 0;
    }
    if (variable.name === "WORKSPACE_NAME") {
      return this._resolveWorkspaceName(workspaceIdentifier);
    } else if (variable.name === "WORKSPACE_FOLDER") {
      return this._resoveWorkspacePath(workspaceIdentifier);
    }
    return void 0;
  }
  _resolveWorkspaceName(workspaceIdentifier) {
    if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
      return basename2(workspaceIdentifier.path);
    }
    let filename = basename2(workspaceIdentifier.configPath.path);
    if (filename.endsWith(WORKSPACE_EXTENSION)) {
      filename = filename.substr(0, filename.length - WORKSPACE_EXTENSION.length - 1);
    }
    return filename;
  }
  _resoveWorkspacePath(workspaceIdentifier) {
    if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
      return normalizeDriveLetter(workspaceIdentifier.fsPath);
    }
    let filename = basename2(workspaceIdentifier.configPath.path);
    let folderpath = workspaceIdentifier.configPath.fsPath;
    if (folderpath.endsWith(filename)) {
      folderpath = folderpath.substr(0, folderpath.length - filename.length - 1);
    }
    return folderpath ? normalizeDriveLetter(folderpath) : "/";
  }
};
var RandomBasedVariableResolver = class {
  resolve(variable) {
    const {name} = variable;
    if (name === "RANDOM") {
      return Math.random().toString().slice(-6);
    } else if (name === "RANDOM_HEX") {
      return Math.random().toString(16).slice(-6);
    }
    return void 0;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.js
registerThemingParticipant((theme6, collector) => {
  function getColorGraceful(name) {
    const color = theme6.getColor(name);
    return color ? color.toString() : "transparent";
  }
  collector.addRule(`.monaco-editor .snippet-placeholder { background-color: ${getColorGraceful(snippetTabstopHighlightBackground)}; outline-color: ${getColorGraceful(snippetTabstopHighlightBorder)}; }`);
  collector.addRule(`.monaco-editor .finish-snippet-placeholder { background-color: ${getColorGraceful(snippetFinalTabstopHighlightBackground)}; outline-color: ${getColorGraceful(snippetFinalTabstopHighlightBorder)}; }`);
});
var OneSnippet = class {
  constructor(editor3, snippet, offset) {
    this._nestingLevel = 1;
    this._editor = editor3;
    this._snippet = snippet;
    this._offset = offset;
    this._placeholderGroups = groupBy(snippet.placeholders, Placeholder.compareByIndex);
    this._placeholderGroupsIdx = -1;
  }
  dispose() {
    if (this._placeholderDecorations) {
      this._editor.deltaDecorations([...this._placeholderDecorations.values()], []);
    }
    this._placeholderGroups.length = 0;
  }
  _initDecorations() {
    if (this._placeholderDecorations) {
      return;
    }
    this._placeholderDecorations = new Map();
    const model = this._editor.getModel();
    this._editor.changeDecorations((accessor) => {
      for (const placeholder of this._snippet.placeholders) {
        const placeholderOffset = this._snippet.offset(placeholder);
        const placeholderLen = this._snippet.fullLen(placeholder);
        const range2 = Range2.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));
        const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;
        const handle = accessor.addDecoration(range2, options);
        this._placeholderDecorations.set(placeholder, handle);
      }
    });
  }
  move(fwd) {
    if (!this._editor.hasModel()) {
      return [];
    }
    this._initDecorations();
    if (this._placeholderGroupsIdx >= 0) {
      let operations = [];
      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
        if (placeholder.transform) {
          const id = this._placeholderDecorations.get(placeholder);
          const range2 = this._editor.getModel().getDecorationRange(id);
          const currentValue = this._editor.getModel().getValueInRange(range2);
          operations.push(EditOperation.replaceMove(range2, placeholder.transform.resolve(currentValue)));
        }
      }
      if (operations.length > 0) {
        this._editor.executeEdits("snippet.placeholderTransform", operations);
      }
    }
    let couldSkipThisPlaceholder = false;
    if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {
      this._placeholderGroupsIdx += 1;
      couldSkipThisPlaceholder = true;
    } else if (fwd === false && this._placeholderGroupsIdx > 0) {
      this._placeholderGroupsIdx -= 1;
      couldSkipThisPlaceholder = true;
    } else {
    }
    const newSelections = this._editor.getModel().changeDecorations((accessor) => {
      const activePlaceholders = new Set();
      const selections = [];
      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const id = this._placeholderDecorations.get(placeholder);
        const range2 = this._editor.getModel().getDecorationRange(id);
        selections.push(new Selection(range2.startLineNumber, range2.startColumn, range2.endLineNumber, range2.endColumn));
        couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);
        accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);
        activePlaceholders.add(placeholder);
        for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {
          const id2 = this._placeholderDecorations.get(enclosingPlaceholder);
          accessor.changeDecorationOptions(id2, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);
          activePlaceholders.add(enclosingPlaceholder);
        }
      }
      for (const [placeholder, id] of this._placeholderDecorations) {
        if (!activePlaceholders.has(placeholder)) {
          accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);
        }
      }
      return selections;
    });
    return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);
  }
  _hasPlaceholderBeenCollapsed(placeholder) {
    let marker = placeholder;
    while (marker) {
      if (marker instanceof Placeholder) {
        const id = this._placeholderDecorations.get(marker);
        const range2 = this._editor.getModel().getDecorationRange(id);
        if (range2.isEmpty() && marker.toString().length > 0) {
          return true;
        }
      }
      marker = marker.parent;
    }
    return false;
  }
  get isAtFirstPlaceholder() {
    return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;
  }
  get isAtLastPlaceholder() {
    return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;
  }
  get hasPlaceholder() {
    return this._snippet.placeholders.length > 0;
  }
  computePossibleSelections() {
    const result = new Map();
    for (const placeholdersWithEqualIndex of this._placeholderGroups) {
      let ranges;
      for (const placeholder of placeholdersWithEqualIndex) {
        if (placeholder.isFinalTabstop) {
          break;
        }
        if (!ranges) {
          ranges = [];
          result.set(placeholder.index, ranges);
        }
        const id = this._placeholderDecorations.get(placeholder);
        const range2 = this._editor.getModel().getDecorationRange(id);
        if (!range2) {
          result.delete(placeholder.index);
          break;
        }
        ranges.push(range2);
      }
    }
    return result;
  }
  get choice() {
    return this._placeholderGroups[this._placeholderGroupsIdx][0].choice;
  }
  merge(others) {
    const model = this._editor.getModel();
    this._nestingLevel *= 10;
    this._editor.changeDecorations((accessor) => {
      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const nested = others.shift();
        console.assert(!nested._placeholderDecorations);
        const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;
        for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {
          if (nestedPlaceholder.isFinalTabstop) {
            nestedPlaceholder.index = placeholder.index + (indexLastPlaceholder + 1) / this._nestingLevel;
          } else {
            nestedPlaceholder.index = placeholder.index + nestedPlaceholder.index / this._nestingLevel;
          }
        }
        this._snippet.replace(placeholder, nested._snippet.children);
        const id = this._placeholderDecorations.get(placeholder);
        accessor.removeDecoration(id);
        this._placeholderDecorations.delete(placeholder);
        for (const placeholder2 of nested._snippet.placeholders) {
          const placeholderOffset = nested._snippet.offset(placeholder2);
          const placeholderLen = nested._snippet.fullLen(placeholder2);
          const range2 = Range2.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));
          const handle = accessor.addDecoration(range2, OneSnippet._decor.inactive);
          this._placeholderDecorations.set(placeholder2, handle);
        }
      }
      this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);
    });
  }
};
OneSnippet._decor = {
  active: ModelDecorationOptions.register({stickiness: 0, className: "snippet-placeholder"}),
  inactive: ModelDecorationOptions.register({stickiness: 1, className: "snippet-placeholder"}),
  activeFinal: ModelDecorationOptions.register({stickiness: 1, className: "finish-snippet-placeholder"}),
  inactiveFinal: ModelDecorationOptions.register({stickiness: 1, className: "finish-snippet-placeholder"})
};
var _defaultOptions = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  adjustWhitespace: true,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
var SnippetSession = class {
  constructor(editor3, template, options = _defaultOptions) {
    this._templateMerges = [];
    this._snippets = [];
    this._editor = editor3;
    this._template = template;
    this._options = options;
  }
  static adjustWhitespace(model, position, snippet, adjustIndentation, adjustNewlines) {
    const line = model.getLineContent(position.lineNumber);
    const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);
    snippet.walk((marker) => {
      if (marker instanceof Text && !(marker.parent instanceof Choice)) {
        const lines = marker.value.split(/\r\n|\r|\n/);
        if (adjustIndentation) {
          for (let i = 1; i < lines.length; i++) {
            let templateLeadingWhitespace = getLeadingWhitespace(lines[i]);
            lines[i] = model.normalizeIndentation(lineLeadingWhitespace + templateLeadingWhitespace) + lines[i].substr(templateLeadingWhitespace.length);
          }
        }
        if (adjustNewlines) {
          const newValue = lines.join(model.getEOL());
          if (newValue !== marker.value) {
            marker.parent.replace(marker, [new Text(newValue)]);
          }
        }
      }
      return true;
    });
  }
  static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {
    if (overwriteBefore !== 0 || overwriteAfter !== 0) {
      const {positionLineNumber, positionColumn} = selection;
      const positionColumnBefore = positionColumn - overwriteBefore;
      const positionColumnAfter = positionColumn + overwriteAfter;
      const range2 = model.validateRange({
        startLineNumber: positionLineNumber,
        startColumn: positionColumnBefore,
        endLineNumber: positionLineNumber,
        endColumn: positionColumnAfter
      });
      selection = Selection.createWithDirection(range2.startLineNumber, range2.startColumn, range2.endLineNumber, range2.endColumn, selection.getDirection());
    }
    return selection;
  }
  static createEditsAndSnippets(editor3, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer) {
    const edits = [];
    const snippets = [];
    if (!editor3.hasModel()) {
      return {edits, snippets};
    }
    const model = editor3.getModel();
    const workspaceService = editor3.invokeWithinContext((accessor) => accessor.get(IWorkspaceContextService, optional));
    const modelBasedVariableResolver = editor3.invokeWithinContext((accessor) => new ModelBasedVariableResolver(accessor.get(ILabelService, optional), model));
    const readClipboardText = () => clipboardText;
    let delta = 0;
    let firstBeforeText = model.getValueInRange(SnippetSession.adjustSelection(model, editor3.getSelection(), overwriteBefore, 0));
    let firstAfterText = model.getValueInRange(SnippetSession.adjustSelection(model, editor3.getSelection(), 0, overwriteAfter));
    let firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor3.getSelection().positionLineNumber);
    const indexedSelections = editor3.getSelections().map((selection, idx) => ({selection, idx})).sort((a, b) => Range2.compareRangesUsingStarts(a.selection, b.selection));
    for (const {selection, idx} of indexedSelections) {
      let extensionBefore = SnippetSession.adjustSelection(model, selection, overwriteBefore, 0);
      let extensionAfter = SnippetSession.adjustSelection(model, selection, 0, overwriteAfter);
      if (firstBeforeText !== model.getValueInRange(extensionBefore)) {
        extensionBefore = selection;
      }
      if (firstAfterText !== model.getValueInRange(extensionAfter)) {
        extensionAfter = selection;
      }
      const snippetSelection = selection.setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn).setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);
      const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);
      const start = snippetSelection.getStartPosition();
      SnippetSession.adjustWhitespace(model, start, snippet, adjustWhitespace || idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber), true);
      snippet.resolveVariables(new CompositeSnippetVariableResolver([
        modelBasedVariableResolver,
        new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor3.getOption(62) === "spread"),
        new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer),
        new CommentBasedVariableResolver(model, selection),
        new TimeBasedVariableResolver(),
        new WorkspaceBasedVariableResolver(workspaceService),
        new RandomBasedVariableResolver()
      ]));
      const offset = model.getOffsetAt(start) + delta;
      delta += snippet.toString().length - model.getValueLengthInRange(snippetSelection);
      edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());
      edits[idx].identifier = {major: idx, minor: 0};
      snippets[idx] = new OneSnippet(editor3, snippet, offset);
    }
    return {edits, snippets};
  }
  dispose() {
    dispose(this._snippets);
  }
  _logInfo() {
    return `template="${this._template}", merged_templates="${this._templateMerges.join(" -> ")}"`;
  }
  insert() {
    if (!this._editor.hasModel()) {
      return;
    }
    const {edits, snippets} = SnippetSession.createEditsAndSnippets(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer);
    this._snippets = snippets;
    this._editor.executeEdits("snippet", edits, (undoEdits) => {
      if (this._snippets[0].hasPlaceholder) {
        return this._move(true);
      } else {
        return undoEdits.filter((edit2) => !!edit2.identifier).map((edit2) => Selection.fromPositions(edit2.range.getEndPosition()));
      }
    });
    this._editor.revealRange(this._editor.getSelections()[0]);
  }
  merge(template, options = _defaultOptions) {
    if (!this._editor.hasModel()) {
      return;
    }
    this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);
    const {edits, snippets} = SnippetSession.createEditsAndSnippets(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer);
    this._editor.executeEdits("snippet", edits, (undoEdits) => {
      for (const snippet of this._snippets) {
        snippet.merge(snippets);
      }
      console.assert(snippets.length === 0);
      if (this._snippets[0].hasPlaceholder) {
        return this._move(void 0);
      } else {
        return undoEdits.filter((edit2) => !!edit2.identifier).map((edit2) => Selection.fromPositions(edit2.range.getEndPosition()));
      }
    });
  }
  next() {
    const newSelections = this._move(true);
    this._editor.setSelections(newSelections);
    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
  }
  prev() {
    const newSelections = this._move(false);
    this._editor.setSelections(newSelections);
    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
  }
  _move(fwd) {
    const selections = [];
    for (const snippet of this._snippets) {
      const oneSelection = snippet.move(fwd);
      selections.push(...oneSelection);
    }
    return selections;
  }
  get isAtFirstPlaceholder() {
    return this._snippets[0].isAtFirstPlaceholder;
  }
  get isAtLastPlaceholder() {
    return this._snippets[0].isAtLastPlaceholder;
  }
  get hasPlaceholder() {
    return this._snippets[0].hasPlaceholder;
  }
  get choice() {
    return this._snippets[0].choice;
  }
  isSelectionWithinPlaceholders() {
    if (!this.hasPlaceholder) {
      return false;
    }
    const selections = this._editor.getSelections();
    if (selections.length < this._snippets.length) {
      return false;
    }
    let allPossibleSelections = new Map();
    for (const snippet of this._snippets) {
      const possibleSelections = snippet.computePossibleSelections();
      if (allPossibleSelections.size === 0) {
        for (const [index2, ranges] of possibleSelections) {
          ranges.sort(Range2.compareRangesUsingStarts);
          for (const selection of selections) {
            if (ranges[0].containsRange(selection)) {
              allPossibleSelections.set(index2, []);
              break;
            }
          }
        }
      }
      if (allPossibleSelections.size === 0) {
        return false;
      }
      allPossibleSelections.forEach((array4, index2) => {
        array4.push(...possibleSelections.get(index2));
      });
    }
    selections.sort(Range2.compareRangesUsingStarts);
    for (let [index2, ranges] of allPossibleSelections) {
      if (ranges.length !== selections.length) {
        allPossibleSelections.delete(index2);
        continue;
      }
      ranges.sort(Range2.compareRangesUsingStarts);
      for (let i = 0; i < ranges.length; i++) {
        if (!ranges[i].containsRange(selections[i])) {
          allPossibleSelections.delete(index2);
          continue;
        }
      }
    }
    return allPossibleSelections.size > 0;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetController2.js
var __decorate35 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param35 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _defaultOptions2 = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  undoStopBefore: true,
  undoStopAfter: true,
  adjustWhitespace: true,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
var SnippetController2 = class SnippetController22 {
  constructor(_editor, _logService, contextKeyService) {
    this._editor = _editor;
    this._logService = _logService;
    this._snippetListener = new DisposableStore();
    this._modelVersionId = -1;
    this._inSnippet = SnippetController22.InSnippetMode.bindTo(contextKeyService);
    this._hasNextTabstop = SnippetController22.HasNextTabstop.bindTo(contextKeyService);
    this._hasPrevTabstop = SnippetController22.HasPrevTabstop.bindTo(contextKeyService);
  }
  static get(editor3) {
    return editor3.getContribution(SnippetController22.ID);
  }
  dispose() {
    this._inSnippet.reset();
    this._hasPrevTabstop.reset();
    this._hasNextTabstop.reset();
    dispose(this._session);
    this._snippetListener.dispose();
  }
  insert(template, opts) {
    try {
      this._doInsert(template, typeof opts === "undefined" ? _defaultOptions2 : Object.assign(Object.assign({}, _defaultOptions2), opts));
    } catch (e) {
      this.cancel();
      this._logService.error(e);
      this._logService.error("snippet_error");
      this._logService.error("insert_template=", template);
      this._logService.error("existing_template=", this._session ? this._session._logInfo() : "<no_session>");
    }
  }
  _doInsert(template, opts) {
    if (!this._editor.hasModel()) {
      return;
    }
    this._snippetListener.clear();
    if (opts.undoStopBefore) {
      this._editor.getModel().pushStackElement();
    }
    if (!this._session) {
      this._modelVersionId = this._editor.getModel().getAlternativeVersionId();
      this._session = new SnippetSession(this._editor, template, opts);
      this._session.insert();
    } else {
      this._session.merge(template, opts);
    }
    if (opts.undoStopAfter) {
      this._editor.getModel().pushStackElement();
    }
    this._updateState();
    this._snippetListener.add(this._editor.onDidChangeModelContent((e) => e.isFlush && this.cancel()));
    this._snippetListener.add(this._editor.onDidChangeModel(() => this.cancel()));
    this._snippetListener.add(this._editor.onDidChangeCursorSelection(() => this._updateState()));
  }
  _updateState() {
    if (!this._session || !this._editor.hasModel()) {
      return;
    }
    if (this._modelVersionId === this._editor.getModel().getAlternativeVersionId()) {
      return this.cancel();
    }
    if (!this._session.hasPlaceholder) {
      return this.cancel();
    }
    if (this._session.isAtLastPlaceholder || !this._session.isSelectionWithinPlaceholders()) {
      return this.cancel();
    }
    this._inSnippet.set(true);
    this._hasPrevTabstop.set(!this._session.isAtFirstPlaceholder);
    this._hasNextTabstop.set(!this._session.isAtLastPlaceholder);
    this._handleChoice();
  }
  _handleChoice() {
    if (!this._session || !this._editor.hasModel()) {
      this._currentChoice = void 0;
      return;
    }
    const {choice} = this._session;
    if (!choice) {
      this._currentChoice = void 0;
      return;
    }
    if (this._currentChoice !== choice) {
      this._currentChoice = choice;
      this._editor.setSelections(this._editor.getSelections().map((s) => Selection.fromPositions(s.getStartPosition())));
      const [first2] = choice.options;
      showSimpleSuggestions(this._editor, choice.options.map((option, i) => {
        return {
          kind: 13,
          label: option.value,
          insertText: option.value,
          sortText: "a".repeat(i + 1),
          range: Range2.fromPositions(this._editor.getPosition(), this._editor.getPosition().delta(0, first2.value.length))
        };
      }));
    }
  }
  finish() {
    while (this._inSnippet.get()) {
      this.next();
    }
  }
  cancel(resetSelection = false) {
    this._inSnippet.reset();
    this._hasPrevTabstop.reset();
    this._hasNextTabstop.reset();
    this._snippetListener.clear();
    dispose(this._session);
    this._session = void 0;
    this._modelVersionId = -1;
    if (resetSelection) {
      this._editor.setSelections([this._editor.getSelection()]);
    }
  }
  prev() {
    if (this._session) {
      this._session.prev();
    }
    this._updateState();
  }
  next() {
    if (this._session) {
      this._session.next();
    }
    this._updateState();
  }
  isInSnippet() {
    return Boolean(this._inSnippet.get());
  }
};
SnippetController2.ID = "snippetController2";
SnippetController2.InSnippetMode = new RawContextKey("inSnippetMode", false);
SnippetController2.HasNextTabstop = new RawContextKey("hasNextTabstop", false);
SnippetController2.HasPrevTabstop = new RawContextKey("hasPrevTabstop", false);
SnippetController2 = __decorate35([
  __param35(1, ILogService),
  __param35(2, IContextKeyService)
], SnippetController2);
registerEditorContribution(SnippetController2.ID, SnippetController2);
var CommandCtor = EditorCommand.bindToContribution(SnippetController2.get);
registerEditorCommand(new CommandCtor({
  id: "jumpToNextSnippetPlaceholder",
  precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasNextTabstop),
  handler: (ctrl) => ctrl.next(),
  kbOpts: {
    weight: 100 + 30,
    kbExpr: EditorContextKeys.editorTextFocus,
    primary: 2
  }
}));
registerEditorCommand(new CommandCtor({
  id: "jumpToPrevSnippetPlaceholder",
  precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasPrevTabstop),
  handler: (ctrl) => ctrl.prev(),
  kbOpts: {
    weight: 100 + 30,
    kbExpr: EditorContextKeys.editorTextFocus,
    primary: 1024 | 2
  }
}));
registerEditorCommand(new CommandCtor({
  id: "leaveSnippet",
  precondition: SnippetController2.InSnippetMode,
  handler: (ctrl) => ctrl.cancel(true),
  kbOpts: {
    weight: 100 + 30,
    kbExpr: EditorContextKeys.editorTextFocus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerEditorCommand(new CommandCtor({
  id: "acceptSnippet",
  precondition: SnippetController2.InSnippetMode,
  handler: (ctrl) => ctrl.finish()
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestMemory.js
var __decorate36 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param36 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var Memory = class {
  constructor(name) {
    this.name = name;
  }
  select(model, pos, items) {
    if (items.length === 0) {
      return 0;
    }
    let topScore = items[0].score[0];
    for (let i = 0; i < items.length; i++) {
      const {score, completion: suggestion} = items[i];
      if (score[0] !== topScore) {
        break;
      }
      if (suggestion.preselect) {
        return i;
      }
    }
    return 0;
  }
};
var NoMemory = class extends Memory {
  constructor() {
    super("first");
  }
  memorize(model, pos, item) {
  }
  toJSON() {
    return void 0;
  }
  fromJSON() {
  }
};
var LRUMemory = class extends Memory {
  constructor() {
    super("recentlyUsed");
    this._cache = new LRUCache(300, 0.66);
    this._seq = 0;
  }
  memorize(model, pos, item) {
    const {label} = item.completion;
    const key = `${model.getLanguageIdentifier().language}/${label}`;
    this._cache.set(key, {
      touch: this._seq++,
      type: item.completion.kind,
      insertText: item.completion.insertText
    });
  }
  select(model, pos, items) {
    if (items.length === 0) {
      return 0;
    }
    const lineSuffix = model.getLineContent(pos.lineNumber).substr(pos.column - 10, pos.column - 1);
    if (/\s$/.test(lineSuffix)) {
      return super.select(model, pos, items);
    }
    let topScore = items[0].score[0];
    let indexPreselect = -1;
    let indexRecency = -1;
    let seq = -1;
    for (let i = 0; i < items.length; i++) {
      if (items[i].score[0] !== topScore) {
        break;
      }
      const key = `${model.getLanguageIdentifier().language}/${items[i].completion.label}`;
      const item = this._cache.peek(key);
      if (item && item.touch > seq && item.type === items[i].completion.kind && item.insertText === items[i].completion.insertText) {
        seq = item.touch;
        indexRecency = i;
      }
      if (items[i].completion.preselect && indexPreselect === -1) {
        return indexPreselect = i;
      }
    }
    if (indexRecency !== -1) {
      return indexRecency;
    } else if (indexPreselect !== -1) {
      return indexPreselect;
    } else {
      return 0;
    }
  }
  toJSON() {
    return this._cache.toJSON();
  }
  fromJSON(data) {
    this._cache.clear();
    let seq = 0;
    for (const [key, value] of data) {
      value.touch = seq;
      value.type = typeof value.type === "number" ? value.type : completionKindFromString(value.type);
      this._cache.set(key, value);
    }
    this._seq = this._cache.size;
  }
};
var PrefixMemory = class extends Memory {
  constructor() {
    super("recentlyUsedByPrefix");
    this._trie = TernarySearchTree.forStrings();
    this._seq = 0;
  }
  memorize(model, pos, item) {
    const {word} = model.getWordUntilPosition(pos);
    const key = `${model.getLanguageIdentifier().language}/${word}`;
    this._trie.set(key, {
      type: item.completion.kind,
      insertText: item.completion.insertText,
      touch: this._seq++
    });
  }
  select(model, pos, items) {
    let {word} = model.getWordUntilPosition(pos);
    if (!word) {
      return super.select(model, pos, items);
    }
    let key = `${model.getLanguageIdentifier().language}/${word}`;
    let item = this._trie.get(key);
    if (!item) {
      item = this._trie.findSubstr(key);
    }
    if (item) {
      for (let i = 0; i < items.length; i++) {
        let {kind, insertText} = items[i].completion;
        if (kind === item.type && insertText === item.insertText) {
          return i;
        }
      }
    }
    return super.select(model, pos, items);
  }
  toJSON() {
    let entries3 = [];
    this._trie.forEach((value, key) => entries3.push([key, value]));
    entries3.sort((a, b) => -(a[1].touch - b[1].touch)).forEach((value, i) => value[1].touch = i);
    return entries3.slice(0, 200);
  }
  fromJSON(data) {
    this._trie.clear();
    if (data.length > 0) {
      this._seq = data[0][1].touch + 1;
      for (const [key, value] of data) {
        value.type = typeof value.type === "number" ? value.type : completionKindFromString(value.type);
        this._trie.set(key, value);
      }
    }
  }
};
var SuggestMemoryService = class SuggestMemoryService2 {
  constructor(_storageService, _modeService, _configService) {
    this._storageService = _storageService;
    this._modeService = _modeService;
    this._configService = _configService;
    this._disposables = new DisposableStore();
    this._persistSoon = new RunOnceScheduler(() => this._saveState(), 500);
    this._disposables.add(_storageService.onWillSaveState((e) => {
      if (e.reason === WillSaveStateReason.SHUTDOWN) {
        this._saveState();
      }
    }));
  }
  dispose() {
    this._disposables.dispose();
    this._persistSoon.dispose();
  }
  memorize(model, pos, item) {
    this._withStrategy(model, pos).memorize(model, pos, item);
    this._persistSoon.schedule();
  }
  select(model, pos, items) {
    return this._withStrategy(model, pos).select(model, pos, items);
  }
  _withStrategy(model, pos) {
    var _a5, _b2;
    const mode = this._configService.getValue("editor.suggestSelection", {
      overrideIdentifier: (_a5 = this._modeService.getLanguageIdentifier(model.getLanguageIdAtPosition(pos.lineNumber, pos.column))) === null || _a5 === void 0 ? void 0 : _a5.language,
      resource: model.uri
    });
    if (((_b2 = this._strategy) === null || _b2 === void 0 ? void 0 : _b2.name) !== mode) {
      this._saveState();
      const ctor = SuggestMemoryService2._strategyCtors.get(mode) || NoMemory;
      this._strategy = new ctor();
      try {
        const share = this._configService.getValue("editor.suggest.shareSuggestSelections");
        const scope = share ? 0 : 1;
        const raw = this._storageService.get(`${SuggestMemoryService2._storagePrefix}/${mode}`, scope);
        if (raw) {
          this._strategy.fromJSON(JSON.parse(raw));
        }
      } catch (e) {
      }
    }
    return this._strategy;
  }
  _saveState() {
    if (this._strategy) {
      const share = this._configService.getValue("editor.suggest.shareSuggestSelections");
      const scope = share ? 0 : 1;
      const raw = JSON.stringify(this._strategy);
      this._storageService.store(`${SuggestMemoryService2._storagePrefix}/${this._strategy.name}`, raw, scope);
    }
  }
};
SuggestMemoryService._strategyCtors = new Map([
  ["recentlyUsedByPrefix", PrefixMemory],
  ["recentlyUsed", LRUMemory],
  ["first", NoMemory]
]);
SuggestMemoryService._storagePrefix = "suggest/memories";
SuggestMemoryService = __decorate36([
  __param36(0, IStorageService),
  __param36(1, IModeService),
  __param36(2, IConfigurationService)
], SuggestMemoryService);
var ISuggestMemoryService = createDecorator("ISuggestMemories");
registerSingleton(ISuggestMemoryService, SuggestMemoryService, true);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestAlternatives.js
var __decorate37 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param37 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SuggestAlternatives = class SuggestAlternatives2 {
  constructor(_editor, contextKeyService) {
    this._editor = _editor;
    this._index = 0;
    this._ckOtherSuggestions = SuggestAlternatives2.OtherSuggestions.bindTo(contextKeyService);
  }
  dispose() {
    this.reset();
  }
  reset() {
    this._ckOtherSuggestions.reset();
    dispose(this._listener);
    this._model = void 0;
    this._acceptNext = void 0;
    this._ignore = false;
  }
  set({model, index: index2}, acceptNext) {
    if (model.items.length === 0) {
      this.reset();
      return;
    }
    let nextIndex = SuggestAlternatives2._moveIndex(true, model, index2);
    if (nextIndex === index2) {
      this.reset();
      return;
    }
    this._acceptNext = acceptNext;
    this._model = model;
    this._index = index2;
    this._listener = this._editor.onDidChangeCursorPosition(() => {
      if (!this._ignore) {
        this.reset();
      }
    });
    this._ckOtherSuggestions.set(true);
  }
  static _moveIndex(fwd, model, index2) {
    let newIndex = index2;
    while (true) {
      newIndex = (newIndex + model.items.length + (fwd ? 1 : -1)) % model.items.length;
      if (newIndex === index2) {
        break;
      }
      if (!model.items[newIndex].completion.additionalTextEdits) {
        break;
      }
    }
    return newIndex;
  }
  next() {
    this._move(true);
  }
  prev() {
    this._move(false);
  }
  _move(fwd) {
    if (!this._model) {
      return;
    }
    try {
      this._ignore = true;
      this._index = SuggestAlternatives2._moveIndex(fwd, this._model, this._index);
      this._acceptNext({index: this._index, item: this._model.items[this._index], model: this._model});
    } finally {
      this._ignore = false;
    }
  }
};
SuggestAlternatives.OtherSuggestions = new RawContextKey("hasOtherSuggestions", false);
SuggestAlternatives = __decorate37([
  __param37(1, IContextKeyService)
], SuggestAlternatives);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/completionModel.js
var CompletionModel = class {
  constructor(items, column, lineContext, wordDistance, options, snippetSuggestions, clipboardText) {
    this.clipboardText = clipboardText;
    this._snippetCompareFn = CompletionModel._compareCompletionItems;
    this._items = items;
    this._column = column;
    this._wordDistance = wordDistance;
    this._options = options;
    this._refilterKind = 1;
    this._lineContext = lineContext;
    if (snippetSuggestions === "top") {
      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;
    } else if (snippetSuggestions === "bottom") {
      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;
    }
  }
  get lineContext() {
    return this._lineContext;
  }
  set lineContext(value) {
    if (this._lineContext.leadingLineContent !== value.leadingLineContent || this._lineContext.characterCountDelta !== value.characterCountDelta) {
      this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 : 1;
      this._lineContext = value;
    }
  }
  get items() {
    this._ensureCachedState();
    return this._filteredItems;
  }
  get allProvider() {
    this._ensureCachedState();
    return this._allProvider;
  }
  get incomplete() {
    this._ensureCachedState();
    return this._isIncomplete;
  }
  adopt(except) {
    let res = [];
    for (let i = 0; i < this._items.length; ) {
      if (!except.has(this._items[i].provider)) {
        res.push(this._items[i]);
        this._items[i] = this._items[this._items.length - 1];
        this._items.pop();
      } else {
        i++;
      }
    }
    this._refilterKind = 1;
    return res;
  }
  get stats() {
    this._ensureCachedState();
    return this._stats;
  }
  _ensureCachedState() {
    if (this._refilterKind !== 0) {
      this._createCachedState();
    }
  }
  _createCachedState() {
    this._isIncomplete = new Set();
    this._allProvider = new Set();
    this._stats = {suggestionCount: 0, snippetCount: 0, textCount: 0};
    const {leadingLineContent, characterCountDelta} = this._lineContext;
    let word = "";
    let wordLow = "";
    const source = this._refilterKind === 1 ? this._items : this._filteredItems;
    const target = [];
    const scoreFn = !this._options.filterGraceful || source.length > 2e3 ? fuzzyScore : fuzzyScoreGracefulAggressive;
    for (let i = 0; i < source.length; i++) {
      const item = source[i];
      if (item.isInvalid) {
        continue;
      }
      if (item.container.incomplete) {
        this._isIncomplete.add(item.provider);
      }
      this._allProvider.add(item.provider);
      const overwriteBefore = item.position.column - item.editStart.column;
      const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);
      if (word.length !== wordLen) {
        word = wordLen === 0 ? "" : leadingLineContent.slice(-wordLen);
        wordLow = word.toLowerCase();
      }
      item.word = word;
      if (wordLen === 0) {
        item.score = FuzzyScore.Default;
      } else {
        let wordPos = 0;
        while (wordPos < overwriteBefore) {
          const ch = word.charCodeAt(wordPos);
          if (ch === 32 || ch === 9) {
            wordPos += 1;
          } else {
            break;
          }
        }
        const textLabel = typeof item.completion.label === "string" ? item.completion.label : item.completion.label.name;
        if (wordPos >= wordLen) {
          item.score = FuzzyScore.Default;
        } else if (typeof item.completion.filterText === "string") {
          let match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, false);
          if (!match) {
            continue;
          }
          if (compareIgnoreCase(item.completion.filterText, textLabel) === 0) {
            item.score = match;
          } else {
            item.score = anyScore(word, wordLow, wordPos, textLabel, item.labelLow, 0);
            item.score[0] = match[0];
          }
        } else {
          let match = scoreFn(word, wordLow, wordPos, textLabel, item.labelLow, 0, false);
          if (!match) {
            continue;
          }
          item.score = match;
        }
      }
      item.idx = i;
      item.distance = this._wordDistance.distance(item.position, item.completion);
      target.push(item);
      this._stats.suggestionCount++;
      switch (item.completion.kind) {
        case 27:
          this._stats.snippetCount++;
          break;
        case 18:
          this._stats.textCount++;
          break;
      }
    }
    this._filteredItems = target.sort(this._snippetCompareFn);
    this._refilterKind = 0;
  }
  static _compareCompletionItems(a, b) {
    if (a.score[0] > b.score[0]) {
      return -1;
    } else if (a.score[0] < b.score[0]) {
      return 1;
    } else if (a.distance < b.distance) {
      return -1;
    } else if (a.distance > b.distance) {
      return 1;
    } else if (a.idx < b.idx) {
      return -1;
    } else if (a.idx > b.idx) {
      return 1;
    } else {
      return 0;
    }
  }
  static _compareCompletionItemsSnippetsDown(a, b) {
    if (a.completion.kind !== b.completion.kind) {
      if (a.completion.kind === 27) {
        return 1;
      } else if (b.completion.kind === 27) {
        return -1;
      }
    }
    return CompletionModel._compareCompletionItems(a, b);
  }
  static _compareCompletionItemsSnippetsUp(a, b) {
    if (a.completion.kind !== b.completion.kind) {
      if (a.completion.kind === 27) {
        return -1;
      } else if (b.completion.kind === 27) {
        return 1;
      }
    }
    return CompletionModel._compareCompletionItems(a, b);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/wordDistance.js
var __awaiter28 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var WordDistance = class {
  static create(service, editor3) {
    return __awaiter28(this, void 0, void 0, function* () {
      if (!editor3.getOption(96).localityBonus) {
        return WordDistance.None;
      }
      if (!editor3.hasModel()) {
        return WordDistance.None;
      }
      const model = editor3.getModel();
      const position = editor3.getPosition();
      if (!service.canComputeWordRanges(model.uri)) {
        return WordDistance.None;
      }
      const [ranges] = yield new BracketSelectionRangeProvider().provideSelectionRanges(model, [position]);
      if (ranges.length === 0) {
        return WordDistance.None;
      }
      const wordRanges = yield service.computeWordRanges(model.uri, ranges[0].range);
      if (!wordRanges) {
        return WordDistance.None;
      }
      const wordUntilPos = model.getWordUntilPosition(position);
      delete wordRanges[wordUntilPos.word];
      return new class extends WordDistance {
        distance(anchor, suggestion) {
          if (!position.equals(editor3.getPosition())) {
            return 0;
          }
          if (suggestion.kind === 17) {
            return 2 << 20;
          }
          let word = typeof suggestion.label === "string" ? suggestion.label : suggestion.label.name;
          let wordLines = wordRanges[word];
          if (isFalsyOrEmpty(wordLines)) {
            return 2 << 20;
          }
          let idx = binarySearch(wordLines, Range2.fromPositions(anchor), Range2.compareRangesUsingStarts);
          let bestWordRange = idx >= 0 ? wordLines[idx] : wordLines[Math.max(0, ~idx - 1)];
          let blockDistance = ranges.length;
          for (const range2 of ranges) {
            if (!Range2.containsRange(range2.range, bestWordRange)) {
              break;
            }
            blockDistance -= 1;
          }
          return blockDistance;
        }
      }();
    });
  }
};
WordDistance.None = new class extends WordDistance {
  distance() {
    return 0;
  }
}();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestModel.js
var __awaiter29 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var LineContext = class {
  constructor(model, position, auto, shy) {
    this.leadingLineContent = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
    this.leadingWord = model.getWordUntilPosition(position);
    this.lineNumber = position.lineNumber;
    this.column = position.column;
    this.auto = auto;
    this.shy = shy;
  }
  static shouldAutoTrigger(editor3) {
    if (!editor3.hasModel()) {
      return false;
    }
    const model = editor3.getModel();
    const pos = editor3.getPosition();
    model.tokenizeIfCheap(pos.lineNumber);
    const word = model.getWordAtPosition(pos);
    if (!word) {
      return false;
    }
    if (word.endColumn !== pos.column) {
      return false;
    }
    if (!isNaN(Number(word.word))) {
      return false;
    }
    return true;
  }
};
var SuggestModel = class {
  constructor(_editor, _editorWorkerService, _clipboardService) {
    this._editor = _editor;
    this._editorWorkerService = _editorWorkerService;
    this._clipboardService = _clipboardService;
    this._toDispose = new DisposableStore();
    this._quickSuggestDelay = 10;
    this._triggerCharacterListener = new DisposableStore();
    this._triggerQuickSuggest = new TimeoutTimer();
    this._state = 0;
    this._completionDisposables = new DisposableStore();
    this._onDidCancel = new Emitter2();
    this._onDidTrigger = new Emitter2();
    this._onDidSuggest = new Emitter2();
    this.onDidCancel = this._onDidCancel.event;
    this.onDidTrigger = this._onDidTrigger.event;
    this.onDidSuggest = this._onDidSuggest.event;
    this._currentSelection = this._editor.getSelection() || new Selection(1, 1, 1, 1);
    this._toDispose.add(this._editor.onDidChangeModel(() => {
      this._updateTriggerCharacters();
      this.cancel();
    }));
    this._toDispose.add(this._editor.onDidChangeModelLanguage(() => {
      this._updateTriggerCharacters();
      this.cancel();
    }));
    this._toDispose.add(this._editor.onDidChangeConfiguration(() => {
      this._updateTriggerCharacters();
      this._updateQuickSuggest();
    }));
    this._toDispose.add(CompletionProviderRegistry.onDidChange(() => {
      this._updateTriggerCharacters();
      this._updateActiveSuggestSession();
    }));
    this._toDispose.add(this._editor.onDidChangeCursorSelection((e) => {
      this._onCursorChange(e);
    }));
    let editorIsComposing = false;
    this._toDispose.add(this._editor.onDidCompositionStart(() => {
      editorIsComposing = true;
    }));
    this._toDispose.add(this._editor.onDidCompositionEnd(() => {
      editorIsComposing = false;
      this._refilterCompletionItems();
    }));
    this._toDispose.add(this._editor.onDidChangeModelContent(() => {
      if (!editorIsComposing) {
        this._refilterCompletionItems();
      }
    }));
    this._updateTriggerCharacters();
    this._updateQuickSuggest();
  }
  dispose() {
    dispose(this._triggerCharacterListener);
    dispose([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerQuickSuggest]);
    this._toDispose.dispose();
    this._completionDisposables.dispose();
    this.cancel();
  }
  _updateQuickSuggest() {
    this._quickSuggestDelay = this._editor.getOption(71);
    if (isNaN(this._quickSuggestDelay) || !this._quickSuggestDelay && this._quickSuggestDelay !== 0 || this._quickSuggestDelay < 0) {
      this._quickSuggestDelay = 10;
    }
  }
  _updateTriggerCharacters() {
    this._triggerCharacterListener.clear();
    if (this._editor.getOption(72) || !this._editor.hasModel() || !this._editor.getOption(99)) {
      return;
    }
    const supportsByTriggerCharacter = new Map();
    for (const support of CompletionProviderRegistry.all(this._editor.getModel())) {
      for (const ch of support.triggerCharacters || []) {
        let set5 = supportsByTriggerCharacter.get(ch);
        if (!set5) {
          set5 = new Set();
          set5.add(getSnippetSuggestSupport());
          supportsByTriggerCharacter.set(ch, set5);
        }
        set5.add(support);
      }
    }
    const checkTriggerCharacter = (text) => {
      var _a5;
      if (!text) {
        const position = this._editor.getPosition();
        const model = this._editor.getModel();
        text = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
      }
      let lastChar = "";
      if (isLowSurrogate(text.charCodeAt(text.length - 1))) {
        if (isHighSurrogate(text.charCodeAt(text.length - 2))) {
          lastChar = text.substr(text.length - 2);
        }
      } else {
        lastChar = text.charAt(text.length - 1);
      }
      const supports = supportsByTriggerCharacter.get(lastChar);
      if (supports) {
        const items = (_a5 = this._completionModel) === null || _a5 === void 0 ? void 0 : _a5.adopt(supports);
        this.trigger({auto: true, shy: false, triggerCharacter: lastChar}, Boolean(this._completionModel), supports, items);
      }
    };
    this._triggerCharacterListener.add(this._editor.onDidType(checkTriggerCharacter));
    this._triggerCharacterListener.add(this._editor.onDidCompositionEnd(checkTriggerCharacter));
  }
  get state() {
    return this._state;
  }
  cancel(retrigger = false) {
    if (this._state !== 0) {
      this._triggerQuickSuggest.cancel();
      if (this._requestToken) {
        this._requestToken.cancel();
        this._requestToken = void 0;
      }
      this._state = 0;
      this._completionModel = void 0;
      this._context = void 0;
      this._onDidCancel.fire({retrigger});
    }
  }
  clear() {
    this._completionDisposables.clear();
  }
  _updateActiveSuggestSession() {
    if (this._state !== 0) {
      if (!this._editor.hasModel() || !CompletionProviderRegistry.has(this._editor.getModel())) {
        this.cancel();
      } else {
        this.trigger({auto: this._state === 2, shy: false}, true);
      }
    }
  }
  _onCursorChange(e) {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const prevSelection = this._currentSelection;
    this._currentSelection = this._editor.getSelection();
    if (!e.selection.isEmpty() || e.reason !== 0 || e.source !== "keyboard" && e.source !== "deleteLeft") {
      this.cancel();
      return;
    }
    if (!CompletionProviderRegistry.has(model)) {
      return;
    }
    if (this._state === 0) {
      if (this._editor.getOption(70) === false) {
        return;
      }
      if (!prevSelection.containsRange(this._currentSelection) && !prevSelection.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition())) {
        return;
      }
      if (this._editor.getOption(96).snippetsPreventQuickSuggestions && SnippetController2.get(this._editor).isInSnippet()) {
        return;
      }
      this.cancel();
      this._triggerQuickSuggest.cancelAndSet(() => {
        if (this._state !== 0) {
          return;
        }
        if (!LineContext.shouldAutoTrigger(this._editor)) {
          return;
        }
        if (!this._editor.hasModel()) {
          return;
        }
        const model2 = this._editor.getModel();
        const pos = this._editor.getPosition();
        const quickSuggestions = this._editor.getOption(70);
        if (quickSuggestions === false) {
          return;
        } else if (quickSuggestions === true) {
        } else {
          model2.tokenizeIfCheap(pos.lineNumber);
          const lineTokens = model2.getLineTokens(pos.lineNumber);
          const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(pos.column - 1 - 1, 0)));
          const inValidScope = quickSuggestions.other && tokenType === 0 || quickSuggestions.comments && tokenType === 1 || quickSuggestions.strings && tokenType === 2;
          if (!inValidScope) {
            return;
          }
        }
        this.trigger({auto: true, shy: false});
      }, this._quickSuggestDelay);
    }
  }
  _refilterCompletionItems() {
    Promise.resolve().then(() => {
      if (this._state === 0) {
        return;
      }
      if (!this._editor.hasModel()) {
        return;
      }
      const model = this._editor.getModel();
      const position = this._editor.getPosition();
      const ctx = new LineContext(model, position, this._state === 2, false);
      this._onNewContext(ctx);
    });
  }
  trigger(context2, retrigger = false, onlyFrom, existingItems) {
    var _a5;
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const auto = context2.auto;
    const ctx = new LineContext(model, this._editor.getPosition(), auto, context2.shy);
    this.cancel(retrigger);
    this._state = auto ? 2 : 1;
    this._onDidTrigger.fire({auto, shy: context2.shy, position: this._editor.getPosition()});
    this._context = ctx;
    let suggestCtx = {triggerKind: (_a5 = context2.triggerKind) !== null && _a5 !== void 0 ? _a5 : 0};
    if (context2.triggerCharacter) {
      suggestCtx = {
        triggerKind: 1,
        triggerCharacter: context2.triggerCharacter
      };
    }
    this._requestToken = new CancellationTokenSource();
    const snippetSuggestions = this._editor.getOption(93);
    let snippetSortOrder = 1;
    switch (snippetSuggestions) {
      case "top":
        snippetSortOrder = 0;
        break;
      case "bottom":
        snippetSortOrder = 2;
        break;
    }
    let itemKindFilter = SuggestModel._createItemKindFilter(this._editor);
    let wordDistance = WordDistance.create(this._editorWorkerService, this._editor);
    let completions = provideSuggestionItems(model, this._editor.getPosition(), new CompletionOptions(snippetSortOrder, itemKindFilter, onlyFrom), suggestCtx, this._requestToken.token);
    Promise.all([completions, wordDistance]).then(([completions2, wordDistance2]) => __awaiter29(this, void 0, void 0, function* () {
      dispose(this._requestToken);
      if (this._state === 0) {
        return;
      }
      if (!this._editor.hasModel()) {
        return;
      }
      let clipboardText;
      if (completions2.needsClipboard || isNonEmptyArray(existingItems)) {
        clipboardText = yield this._clipboardService.readText();
      }
      const model2 = this._editor.getModel();
      let items = completions2.items;
      if (isNonEmptyArray(existingItems)) {
        const cmpFn = getSuggestionComparator(snippetSortOrder);
        items = items.concat(existingItems).sort(cmpFn);
      }
      const ctx2 = new LineContext(model2, this._editor.getPosition(), auto, context2.shy);
      this._completionModel = new CompletionModel(items, this._context.column, {
        leadingLineContent: ctx2.leadingLineContent,
        characterCountDelta: ctx2.column - this._context.column
      }, wordDistance2, this._editor.getOption(96), this._editor.getOption(93), clipboardText);
      this._completionDisposables.add(completions2.dispoables);
      this._onNewContext(ctx2);
    })).catch(onUnexpectedError);
  }
  static _createItemKindFilter(editor3) {
    const result = new Set();
    const snippetSuggestions = editor3.getOption(93);
    if (snippetSuggestions === "none") {
      result.add(27);
    }
    const suggestOptions = editor3.getOption(96);
    if (!suggestOptions.showMethods) {
      result.add(0);
    }
    if (!suggestOptions.showFunctions) {
      result.add(1);
    }
    if (!suggestOptions.showConstructors) {
      result.add(2);
    }
    if (!suggestOptions.showFields) {
      result.add(3);
    }
    if (!suggestOptions.showVariables) {
      result.add(4);
    }
    if (!suggestOptions.showClasses) {
      result.add(5);
    }
    if (!suggestOptions.showStructs) {
      result.add(6);
    }
    if (!suggestOptions.showInterfaces) {
      result.add(7);
    }
    if (!suggestOptions.showModules) {
      result.add(8);
    }
    if (!suggestOptions.showProperties) {
      result.add(9);
    }
    if (!suggestOptions.showEvents) {
      result.add(10);
    }
    if (!suggestOptions.showOperators) {
      result.add(11);
    }
    if (!suggestOptions.showUnits) {
      result.add(12);
    }
    if (!suggestOptions.showValues) {
      result.add(13);
    }
    if (!suggestOptions.showConstants) {
      result.add(14);
    }
    if (!suggestOptions.showEnums) {
      result.add(15);
    }
    if (!suggestOptions.showEnumMembers) {
      result.add(16);
    }
    if (!suggestOptions.showKeywords) {
      result.add(17);
    }
    if (!suggestOptions.showWords) {
      result.add(18);
    }
    if (!suggestOptions.showColors) {
      result.add(19);
    }
    if (!suggestOptions.showFiles) {
      result.add(20);
    }
    if (!suggestOptions.showReferences) {
      result.add(21);
    }
    if (!suggestOptions.showColors) {
      result.add(22);
    }
    if (!suggestOptions.showFolders) {
      result.add(23);
    }
    if (!suggestOptions.showTypeParameters) {
      result.add(24);
    }
    if (!suggestOptions.showSnippets) {
      result.add(27);
    }
    if (!suggestOptions.showUsers) {
      result.add(25);
    }
    if (!suggestOptions.showIssues) {
      result.add(26);
    }
    return result;
  }
  _onNewContext(ctx) {
    if (!this._context) {
      return;
    }
    if (ctx.lineNumber !== this._context.lineNumber) {
      this.cancel();
      return;
    }
    if (ctx.leadingWord.startColumn < this._context.leadingWord.startColumn) {
      this.cancel();
      return;
    }
    if (ctx.column < this._context.column) {
      if (ctx.leadingWord.word) {
        this.trigger({auto: this._context.auto, shy: false}, true);
      } else {
        this.cancel();
      }
      return;
    }
    if (!this._completionModel) {
      return;
    }
    if (ctx.leadingWord.word.length !== 0 && ctx.leadingWord.startColumn > this._context.leadingWord.startColumn) {
      const inactiveProvider = new Set(CompletionProviderRegistry.all(this._editor.getModel()));
      this._completionModel.allProvider.forEach((provider) => inactiveProvider.delete(provider));
      const items = this._completionModel.adopt(new Set());
      this.trigger({auto: this._context.auto, shy: false}, true, inactiveProvider, items);
      return;
    }
    if (ctx.column > this._context.column && this._completionModel.incomplete.size > 0 && ctx.leadingWord.word.length !== 0) {
      const {incomplete} = this._completionModel;
      const adopted = this._completionModel.adopt(incomplete);
      this.trigger({auto: this._state === 2, shy: false, triggerKind: 2}, true, incomplete, adopted);
    } else {
      let oldLineContext = this._completionModel.lineContext;
      let isFrozen = false;
      this._completionModel.lineContext = {
        leadingLineContent: ctx.leadingLineContent,
        characterCountDelta: ctx.column - this._context.column
      };
      if (this._completionModel.items.length === 0) {
        if (LineContext.shouldAutoTrigger(this._editor) && this._context.leadingWord.endColumn < ctx.leadingWord.startColumn) {
          this.trigger({auto: this._context.auto, shy: false}, true);
          return;
        }
        if (!this._context.auto) {
          this._completionModel.lineContext = oldLineContext;
          isFrozen = this._completionModel.items.length > 0;
          if (isFrozen && ctx.leadingWord.word.length === 0) {
            this.cancel();
            return;
          }
        } else {
          this.cancel();
          return;
        }
      }
      this._onDidSuggest.fire({
        completionModel: this._completionModel,
        auto: this._context.auto,
        shy: this._context.shy,
        isFrozen
      });
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/outlineTree.js
var SYMBOL_ICON_ARRAY_FOREGROUND = registerColor("symbolIcon.arrayForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.arrayForeground", "The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_BOOLEAN_FOREGROUND = registerColor("symbolIcon.booleanForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.booleanForeground", "The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_CLASS_FOREGROUND = registerColor("symbolIcon.classForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hc: "#EE9D28"
}, localize("symbolIcon.classForeground", "The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_COLOR_FOREGROUND = registerColor("symbolIcon.colorForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.colorForeground", "The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_CONSTANT_FOREGROUND = registerColor("symbolIcon.constantForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.constantForeground", "The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_CONSTRUCTOR_FOREGROUND = registerColor("symbolIcon.constructorForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hc: "#B180D7"
}, localize("symbolIcon.constructorForeground", "The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_ENUMERATOR_FOREGROUND = registerColor("symbolIcon.enumeratorForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hc: "#EE9D28"
}, localize("symbolIcon.enumeratorForeground", "The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND = registerColor("symbolIcon.enumeratorMemberForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hc: "#75BEFF"
}, localize("symbolIcon.enumeratorMemberForeground", "The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_EVENT_FOREGROUND = registerColor("symbolIcon.eventForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hc: "#EE9D28"
}, localize("symbolIcon.eventForeground", "The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FIELD_FOREGROUND = registerColor("symbolIcon.fieldForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hc: "#75BEFF"
}, localize("symbolIcon.fieldForeground", "The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FILE_FOREGROUND = registerColor("symbolIcon.fileForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.fileForeground", "The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FOLDER_FOREGROUND = registerColor("symbolIcon.folderForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.folderForeground", "The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FUNCTION_FOREGROUND = registerColor("symbolIcon.functionForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hc: "#B180D7"
}, localize("symbolIcon.functionForeground", "The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_INTERFACE_FOREGROUND = registerColor("symbolIcon.interfaceForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hc: "#75BEFF"
}, localize("symbolIcon.interfaceForeground", "The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_KEY_FOREGROUND = registerColor("symbolIcon.keyForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.keyForeground", "The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_KEYWORD_FOREGROUND = registerColor("symbolIcon.keywordForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.keywordForeground", "The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_METHOD_FOREGROUND = registerColor("symbolIcon.methodForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hc: "#B180D7"
}, localize("symbolIcon.methodForeground", "The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_MODULE_FOREGROUND = registerColor("symbolIcon.moduleForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.moduleForeground", "The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_NAMESPACE_FOREGROUND = registerColor("symbolIcon.namespaceForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.namespaceForeground", "The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_NULL_FOREGROUND = registerColor("symbolIcon.nullForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.nullForeground", "The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_NUMBER_FOREGROUND = registerColor("symbolIcon.numberForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.numberForeground", "The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_OBJECT_FOREGROUND = registerColor("symbolIcon.objectForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.objectForeground", "The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_OPERATOR_FOREGROUND = registerColor("symbolIcon.operatorForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.operatorForeground", "The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_PACKAGE_FOREGROUND = registerColor("symbolIcon.packageForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.packageForeground", "The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_PROPERTY_FOREGROUND = registerColor("symbolIcon.propertyForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.propertyForeground", "The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_REFERENCE_FOREGROUND = registerColor("symbolIcon.referenceForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.referenceForeground", "The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_SNIPPET_FOREGROUND = registerColor("symbolIcon.snippetForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.snippetForeground", "The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_STRING_FOREGROUND = registerColor("symbolIcon.stringForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.stringForeground", "The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_STRUCT_FOREGROUND = registerColor("symbolIcon.structForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.structForeground", "The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_TEXT_FOREGROUND = registerColor("symbolIcon.textForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.textForeground", "The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_TYPEPARAMETER_FOREGROUND = registerColor("symbolIcon.typeParameterForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.typeParameterForeground", "The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_UNIT_FOREGROUND = registerColor("symbolIcon.unitForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.unitForeground", "The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_VARIABLE_FOREGROUND = registerColor("symbolIcon.variableForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hc: "#75BEFF"
}, localize("symbolIcon.variableForeground", "The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
registerThemingParticipant((theme6, collector) => {
  const symbolIconArrayColor = theme6.getColor(SYMBOL_ICON_ARRAY_FOREGROUND);
  if (symbolIconArrayColor) {
    collector.addRule(`${Codicon.symbolArray.cssSelector} { color: ${symbolIconArrayColor}; }`);
  }
  const symbolIconBooleanColor = theme6.getColor(SYMBOL_ICON_BOOLEAN_FOREGROUND);
  if (symbolIconBooleanColor) {
    collector.addRule(`${Codicon.symbolBoolean.cssSelector} { color: ${symbolIconBooleanColor}; }`);
  }
  const symbolIconClassColor = theme6.getColor(SYMBOL_ICON_CLASS_FOREGROUND);
  if (symbolIconClassColor) {
    collector.addRule(`${Codicon.symbolClass.cssSelector} { color: ${symbolIconClassColor}; }`);
  }
  const symbolIconMethodColor = theme6.getColor(SYMBOL_ICON_METHOD_FOREGROUND);
  if (symbolIconMethodColor) {
    collector.addRule(`${Codicon.symbolMethod.cssSelector} { color: ${symbolIconMethodColor}; }`);
  }
  const symbolIconColorColor = theme6.getColor(SYMBOL_ICON_COLOR_FOREGROUND);
  if (symbolIconColorColor) {
    collector.addRule(`${Codicon.symbolColor.cssSelector} { color: ${symbolIconColorColor}; }`);
  }
  const symbolIconConstantColor = theme6.getColor(SYMBOL_ICON_CONSTANT_FOREGROUND);
  if (symbolIconConstantColor) {
    collector.addRule(`${Codicon.symbolConstant.cssSelector} { color: ${symbolIconConstantColor}; }`);
  }
  const symbolIconConstructorColor = theme6.getColor(SYMBOL_ICON_CONSTRUCTOR_FOREGROUND);
  if (symbolIconConstructorColor) {
    collector.addRule(`${Codicon.symbolConstructor.cssSelector} { color: ${symbolIconConstructorColor}; }`);
  }
  const symbolIconEnumeratorColor = theme6.getColor(SYMBOL_ICON_ENUMERATOR_FOREGROUND);
  if (symbolIconEnumeratorColor) {
    collector.addRule(`
			${Codicon.symbolValue.cssSelector},${Codicon.symbolEnum.cssSelector} { color: ${symbolIconEnumeratorColor}; }`);
  }
  const symbolIconEnumeratorMemberColor = theme6.getColor(SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND);
  if (symbolIconEnumeratorMemberColor) {
    collector.addRule(`${Codicon.symbolEnumMember.cssSelector} { color: ${symbolIconEnumeratorMemberColor}; }`);
  }
  const symbolIconEventColor = theme6.getColor(SYMBOL_ICON_EVENT_FOREGROUND);
  if (symbolIconEventColor) {
    collector.addRule(`${Codicon.symbolEvent.cssSelector} { color: ${symbolIconEventColor}; }`);
  }
  const symbolIconFieldColor = theme6.getColor(SYMBOL_ICON_FIELD_FOREGROUND);
  if (symbolIconFieldColor) {
    collector.addRule(`${Codicon.symbolField.cssSelector} { color: ${symbolIconFieldColor}; }`);
  }
  const symbolIconFileColor = theme6.getColor(SYMBOL_ICON_FILE_FOREGROUND);
  if (symbolIconFileColor) {
    collector.addRule(`${Codicon.symbolFile.cssSelector} { color: ${symbolIconFileColor}; }`);
  }
  const symbolIconFolderColor = theme6.getColor(SYMBOL_ICON_FOLDER_FOREGROUND);
  if (symbolIconFolderColor) {
    collector.addRule(`${Codicon.symbolFolder.cssSelector} { color: ${symbolIconFolderColor}; }`);
  }
  const symbolIconFunctionColor = theme6.getColor(SYMBOL_ICON_FUNCTION_FOREGROUND);
  if (symbolIconFunctionColor) {
    collector.addRule(`${Codicon.symbolFunction.cssSelector} { color: ${symbolIconFunctionColor}; }`);
  }
  const symbolIconInterfaceColor = theme6.getColor(SYMBOL_ICON_INTERFACE_FOREGROUND);
  if (symbolIconInterfaceColor) {
    collector.addRule(`${Codicon.symbolInterface.cssSelector} { color: ${symbolIconInterfaceColor}; }`);
  }
  const symbolIconKeyColor = theme6.getColor(SYMBOL_ICON_KEY_FOREGROUND);
  if (symbolIconKeyColor) {
    collector.addRule(`${Codicon.symbolKey.cssSelector} { color: ${symbolIconKeyColor}; }`);
  }
  const symbolIconKeywordColor = theme6.getColor(SYMBOL_ICON_KEYWORD_FOREGROUND);
  if (symbolIconKeywordColor) {
    collector.addRule(`${Codicon.symbolKeyword.cssSelector} { color: ${symbolIconKeywordColor}; }`);
  }
  const symbolIconModuleColor = theme6.getColor(SYMBOL_ICON_MODULE_FOREGROUND);
  if (symbolIconModuleColor) {
    collector.addRule(`${Codicon.symbolModule.cssSelector} { color: ${symbolIconModuleColor}; }`);
  }
  const outlineNamespaceColor = theme6.getColor(SYMBOL_ICON_NAMESPACE_FOREGROUND);
  if (outlineNamespaceColor) {
    collector.addRule(`${Codicon.symbolNamespace.cssSelector} { color: ${outlineNamespaceColor}; }`);
  }
  const symbolIconNullColor = theme6.getColor(SYMBOL_ICON_NULL_FOREGROUND);
  if (symbolIconNullColor) {
    collector.addRule(`${Codicon.symbolNull.cssSelector} { color: ${symbolIconNullColor}; }`);
  }
  const symbolIconNumberColor = theme6.getColor(SYMBOL_ICON_NUMBER_FOREGROUND);
  if (symbolIconNumberColor) {
    collector.addRule(`${Codicon.symbolNumber.cssSelector} { color: ${symbolIconNumberColor}; }`);
  }
  const symbolIconObjectColor = theme6.getColor(SYMBOL_ICON_OBJECT_FOREGROUND);
  if (symbolIconObjectColor) {
    collector.addRule(`${Codicon.symbolObject.cssSelector} { color: ${symbolIconObjectColor}; }`);
  }
  const symbolIconOperatorColor = theme6.getColor(SYMBOL_ICON_OPERATOR_FOREGROUND);
  if (symbolIconOperatorColor) {
    collector.addRule(`${Codicon.symbolOperator.cssSelector} { color: ${symbolIconOperatorColor}; }`);
  }
  const symbolIconPackageColor = theme6.getColor(SYMBOL_ICON_PACKAGE_FOREGROUND);
  if (symbolIconPackageColor) {
    collector.addRule(`${Codicon.symbolPackage.cssSelector} { color: ${symbolIconPackageColor}; }`);
  }
  const symbolIconPropertyColor = theme6.getColor(SYMBOL_ICON_PROPERTY_FOREGROUND);
  if (symbolIconPropertyColor) {
    collector.addRule(`${Codicon.symbolProperty.cssSelector} { color: ${symbolIconPropertyColor}; }`);
  }
  const symbolIconReferenceColor = theme6.getColor(SYMBOL_ICON_REFERENCE_FOREGROUND);
  if (symbolIconReferenceColor) {
    collector.addRule(`${Codicon.symbolReference.cssSelector} { color: ${symbolIconReferenceColor}; }`);
  }
  const symbolIconSnippetColor = theme6.getColor(SYMBOL_ICON_SNIPPET_FOREGROUND);
  if (symbolIconSnippetColor) {
    collector.addRule(`${Codicon.symbolSnippet.cssSelector} { color: ${symbolIconSnippetColor}; }`);
  }
  const symbolIconStringColor = theme6.getColor(SYMBOL_ICON_STRING_FOREGROUND);
  if (symbolIconStringColor) {
    collector.addRule(`${Codicon.symbolString.cssSelector} { color: ${symbolIconStringColor}; }`);
  }
  const symbolIconStructColor = theme6.getColor(SYMBOL_ICON_STRUCT_FOREGROUND);
  if (symbolIconStructColor) {
    collector.addRule(`${Codicon.symbolStruct.cssSelector} { color: ${symbolIconStructColor}; }`);
  }
  const symbolIconTextColor = theme6.getColor(SYMBOL_ICON_TEXT_FOREGROUND);
  if (symbolIconTextColor) {
    collector.addRule(`${Codicon.symbolText.cssSelector} { color: ${symbolIconTextColor}; }`);
  }
  const symbolIconTypeParameterColor = theme6.getColor(SYMBOL_ICON_TYPEPARAMETER_FOREGROUND);
  if (symbolIconTypeParameterColor) {
    collector.addRule(`${Codicon.symbolTypeParameter.cssSelector} { color: ${symbolIconTypeParameterColor}; }`);
  }
  const symbolIconUnitColor = theme6.getColor(SYMBOL_ICON_UNIT_FOREGROUND);
  if (symbolIconUnitColor) {
    collector.addRule(`${Codicon.symbolUnit.cssSelector} { color: ${symbolIconUnitColor}; }`);
  }
  const symbolIconVariableColor = theme6.getColor(SYMBOL_ICON_VARIABLE_FOREGROUND);
  if (symbolIconVariableColor) {
    collector.addRule(`${Codicon.symbolVariable.cssSelector} { color: ${symbolIconVariableColor}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/platform/files/common/files.js
var FileKind;
(function(FileKind2) {
  FileKind2[FileKind2["FILE"] = 0] = "FILE";
  FileKind2[FileKind2["FOLDER"] = 1] = "FOLDER";
  FileKind2[FileKind2["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
})(FileKind || (FileKind = {}));

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js
function getIconClasses(modelService, modeService, resource, fileKind) {
  const classes = fileKind === FileKind.ROOT_FOLDER ? ["rootfolder-icon"] : fileKind === FileKind.FOLDER ? ["folder-icon"] : ["file-icon"];
  if (resource) {
    let name;
    if (resource.scheme === Schemas.data) {
      const metadata = DataUri.parseMetaData(resource);
      name = metadata.get(DataUri.META_DATA_LABEL);
    } else {
      name = cssEscape(basenameOrAuthority(resource).toLowerCase());
    }
    if (fileKind === FileKind.FOLDER) {
      classes.push(`${name}-name-folder-icon`);
    } else {
      if (name) {
        classes.push(`${name}-name-file-icon`);
        const dotSegments = name.split(".");
        for (let i = 1; i < dotSegments.length; i++) {
          classes.push(`${dotSegments.slice(i).join(".")}-ext-file-icon`);
        }
        classes.push(`ext-file-icon`);
      }
      const detectedModeId = detectModeId(modelService, modeService, resource);
      if (detectedModeId) {
        classes.push(`${cssEscape(detectedModeId)}-lang-file-icon`);
      }
    }
  }
  return classes;
}
function detectModeId(modelService, modeService, resource) {
  if (!resource) {
    return null;
  }
  let modeId = null;
  if (resource.scheme === Schemas.data) {
    const metadata = DataUri.parseMetaData(resource);
    const mime = metadata.get(DataUri.META_DATA_MIME);
    if (mime) {
      modeId = modeService.getModeId(mime);
    }
  } else {
    const model = modelService.getModel(resource);
    if (model) {
      modeId = model.getModeId();
    }
  }
  if (modeId && modeId !== PLAINTEXT_MODE_ID) {
    return modeId;
  }
  return modeService.getModeIdByFilepathOrFirstLine(resource);
}
function cssEscape(val) {
  return val.replace(/\s/g, "\\$&");
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidget.js
var __decorate38 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param38 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter30 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var expandSuggestionDocsByDefault = false;
var suggestMoreInfoIcon = registerIcon("suggest-more-info", Codicon.chevronRight);
var editorSuggestWidgetBackground = registerColor("editorSuggestWidget.background", {dark: editorWidgetBackground, light: editorWidgetBackground, hc: editorWidgetBackground}, localize("editorSuggestWidgetBackground", "Background color of the suggest widget."));
var editorSuggestWidgetBorder = registerColor("editorSuggestWidget.border", {dark: editorWidgetBorder, light: editorWidgetBorder, hc: editorWidgetBorder}, localize("editorSuggestWidgetBorder", "Border color of the suggest widget."));
var editorSuggestWidgetForeground = registerColor("editorSuggestWidget.foreground", {dark: editorForeground, light: editorForeground, hc: editorForeground}, localize("editorSuggestWidgetForeground", "Foreground color of the suggest widget."));
var editorSuggestWidgetSelectedBackground = registerColor("editorSuggestWidget.selectedBackground", {dark: listFocusBackground, light: listFocusBackground, hc: listFocusBackground}, localize("editorSuggestWidgetSelectedBackground", "Background color of the selected entry in the suggest widget."));
var editorSuggestWidgetHighlightForeground = registerColor("editorSuggestWidget.highlightForeground", {dark: listHighlightForeground, light: listHighlightForeground, hc: listHighlightForeground}, localize("editorSuggestWidgetHighlightForeground", "Color of the match highlights in the suggest widget."));
var colorRegExp = /^(#([\da-f]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))$/i;
function extractColor(item, out) {
  const label = typeof item.completion.label === "string" ? item.completion.label : item.completion.label.name;
  if (label.match(colorRegExp)) {
    out[0] = label;
    return true;
  }
  if (typeof item.completion.documentation === "string" && item.completion.documentation.match(colorRegExp)) {
    out[0] = item.completion.documentation;
    return true;
  }
  return false;
}
function canExpandCompletionItem(item) {
  if (!item) {
    return false;
  }
  const suggestion = item.completion;
  if (suggestion.documentation) {
    return true;
  }
  return suggestion.detail && suggestion.detail !== suggestion.label;
}
function getAriaId(index2) {
  return `suggest-aria-id:${index2}`;
}
var ItemRenderer = class ItemRenderer2 {
  constructor(widget, editor3, triggerKeybindingLabel, _modelService, _modeService, _themeService) {
    this.widget = widget;
    this.editor = editor3;
    this.triggerKeybindingLabel = triggerKeybindingLabel;
    this._modelService = _modelService;
    this._modeService = _modeService;
    this._themeService = _themeService;
  }
  get templateId() {
    return "suggestion";
  }
  renderTemplate(container) {
    const data = Object.create(null);
    data.disposables = new DisposableStore();
    data.root = container;
    data.root.classList.add("show-file-icons");
    data.icon = append(container, $(".icon"));
    data.colorspan = append(data.icon, $("span.colorspan"));
    const text = append(container, $(".contents"));
    const main2 = append(text, $(".main"));
    data.iconContainer = append(main2, $(".icon-label.codicon"));
    data.left = append(main2, $("span.left"));
    data.right = append(main2, $("span.right"));
    data.iconLabel = new IconLabel(data.left, {supportHighlights: true, supportCodicons: true});
    data.disposables.add(data.iconLabel);
    data.parametersLabel = append(data.left, $("span.signature-label"));
    data.qualifierLabel = append(data.left, $("span.qualifier-label"));
    data.detailsLabel = append(data.right, $("span.details-label"));
    data.readMore = append(data.right, $("span.readMore" + suggestMoreInfoIcon.cssSelector));
    data.readMore.title = localize("readMore", "Read More ({0})", this.triggerKeybindingLabel);
    const configureFont = () => {
      const options = this.editor.getOptions();
      const fontInfo = options.get(36);
      const fontFamily = fontInfo.fontFamily;
      const fontFeatureSettings = fontInfo.fontFeatureSettings;
      const fontSize = options.get(97) || fontInfo.fontSize;
      const lineHeight = options.get(98) || fontInfo.lineHeight;
      const fontWeight = fontInfo.fontWeight;
      const fontSizePx = `${fontSize}px`;
      const lineHeightPx = `${lineHeight}px`;
      data.root.style.fontSize = fontSizePx;
      data.root.style.fontWeight = fontWeight;
      main2.style.fontFamily = fontFamily;
      main2.style.fontFeatureSettings = fontFeatureSettings;
      main2.style.lineHeight = lineHeightPx;
      data.icon.style.height = lineHeightPx;
      data.icon.style.width = lineHeightPx;
      data.readMore.style.height = lineHeightPx;
      data.readMore.style.width = lineHeightPx;
    };
    configureFont();
    data.disposables.add(Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor)).filter((e) => e.hasChanged(36) || e.hasChanged(97) || e.hasChanged(98)).on(configureFont, null));
    return data;
  }
  renderElement(element, index2, templateData) {
    const data = templateData;
    const suggestion = element.completion;
    const textLabel = typeof suggestion.label === "string" ? suggestion.label : suggestion.label.name;
    data.root.id = getAriaId(index2);
    data.colorspan.style.backgroundColor = "";
    const labelOptions = {
      labelEscapeNewLines: true,
      matches: createMatches(element.score)
    };
    let color = [];
    if (suggestion.kind === 19 && extractColor(element, color)) {
      data.icon.className = "icon customcolor";
      data.iconContainer.className = "icon hide";
      data.colorspan.style.backgroundColor = color[0];
    } else if (suggestion.kind === 20 && this._themeService.getFileIconTheme().hasFileIcons) {
      data.icon.className = "icon hide";
      data.iconContainer.className = "icon hide";
      const labelClasses = getIconClasses(this._modelService, this._modeService, URI.from({scheme: "fake", path: textLabel}), FileKind.FILE);
      const detailClasses = getIconClasses(this._modelService, this._modeService, URI.from({scheme: "fake", path: suggestion.detail}), FileKind.FILE);
      labelOptions.extraClasses = labelClasses.length > detailClasses.length ? labelClasses : detailClasses;
    } else if (suggestion.kind === 23 && this._themeService.getFileIconTheme().hasFolderIcons) {
      data.icon.className = "icon hide";
      data.iconContainer.className = "icon hide";
      labelOptions.extraClasses = flatten([
        getIconClasses(this._modelService, this._modeService, URI.from({scheme: "fake", path: textLabel}), FileKind.FOLDER),
        getIconClasses(this._modelService, this._modeService, URI.from({scheme: "fake", path: suggestion.detail}), FileKind.FOLDER)
      ]);
    } else {
      data.icon.className = "icon hide";
      data.iconContainer.className = "";
      addClasses(data.iconContainer, `suggest-icon ${completionKindToCssClass(suggestion.kind)}`);
    }
    if (suggestion.tags && suggestion.tags.indexOf(1) >= 0) {
      labelOptions.extraClasses = (labelOptions.extraClasses || []).concat(["deprecated"]);
      labelOptions.matches = [];
    }
    data.iconLabel.setLabel(textLabel, void 0, labelOptions);
    if (typeof suggestion.label === "string") {
      data.parametersLabel.textContent = "";
      data.qualifierLabel.textContent = "";
      data.detailsLabel.textContent = (suggestion.detail || "").replace(/\n.*$/m, "");
      data.root.classList.add("string-label");
    } else {
      data.parametersLabel.textContent = (suggestion.label.parameters || "").replace(/\n.*$/m, "");
      data.qualifierLabel.textContent = (suggestion.label.qualifier || "").replace(/\n.*$/m, "");
      data.detailsLabel.textContent = (suggestion.label.type || "").replace(/\n.*$/m, "");
      data.root.classList.remove("string-label");
    }
    if (canExpandCompletionItem(element)) {
      data.right.classList.add("can-expand-details");
      show(data.readMore);
      data.readMore.onmousedown = (e) => {
        e.stopPropagation();
        e.preventDefault();
      };
      data.readMore.onclick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        this.widget.toggleDetails();
      };
    } else {
      data.right.classList.remove("can-expand-details");
      hide(data.readMore);
      data.readMore.onmousedown = null;
      data.readMore.onclick = null;
    }
  }
  disposeTemplate(templateData) {
    templateData.disposables.dispose();
  }
};
ItemRenderer = __decorate38([
  __param38(3, IModelService),
  __param38(4, IModeService),
  __param38(5, IThemeService)
], ItemRenderer);
var SuggestionDetails = class {
  constructor(container, widget, editor3, markdownRenderer, kbToggleDetails) {
    this.widget = widget;
    this.editor = editor3;
    this.markdownRenderer = markdownRenderer;
    this.kbToggleDetails = kbToggleDetails;
    this.borderWidth = 1;
    this.disposables = new DisposableStore();
    this.el = append(container, $(".details"));
    this.disposables.add(toDisposable(() => container.removeChild(this.el)));
    this.body = $(".body");
    this.scrollbar = new DomScrollableElement(this.body, {});
    append(this.el, this.scrollbar.getDomNode());
    this.disposables.add(this.scrollbar);
    this.header = append(this.body, $(".header"));
    this.close = append(this.header, $("span" + Codicon.close.cssSelector));
    this.close.title = localize("readLess", "Read Less ({0})", this.kbToggleDetails);
    this.type = append(this.header, $("p.type"));
    this.docs = append(this.body, $("p.docs"));
    this.configureFont();
    Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor)).filter((e) => e.hasChanged(36)).on(this.configureFont, this, this.disposables);
    markdownRenderer.onDidRenderCodeBlock(() => this.scrollbar.scanDomNode(), this, this.disposables);
  }
  get element() {
    return this.el;
  }
  renderLoading() {
    this.type.textContent = localize("loading", "Loading...");
    this.docs.textContent = "";
  }
  renderItem(item, explainMode) {
    dispose(this.renderDisposeable);
    this.renderDisposeable = void 0;
    let {documentation, detail} = item.completion;
    if (explainMode) {
      let md = "";
      md += `score: ${item.score[0]}${item.word ? `, compared '${item.completion.filterText && item.completion.filterText + " (filterText)" || item.completion.label}' with '${item.word}'` : " (no prefix)"}
`;
      md += `distance: ${item.distance}, see localityBonus-setting
`;
      md += `index: ${item.idx}, based on ${item.completion.sortText && `sortText: "${item.completion.sortText}"` || "label"}
`;
      documentation = new MarkdownString().appendCodeblock("empty", md);
      detail = `Provider: ${item.provider._debugDisplayName}`;
    }
    if (!explainMode && !canExpandCompletionItem(item)) {
      this.type.textContent = "";
      this.docs.textContent = "";
      this.el.classList.add("no-docs");
      return;
    }
    this.el.classList.remove("no-docs");
    if (typeof documentation === "string") {
      this.docs.classList.remove("markdown-docs");
      this.docs.textContent = documentation;
    } else {
      this.docs.classList.add("markdown-docs");
      this.docs.innerText = "";
      const renderedContents = this.markdownRenderer.render(documentation);
      this.renderDisposeable = renderedContents;
      this.docs.appendChild(renderedContents.element);
    }
    if (detail) {
      this.type.innerText = detail.length > 1e5 ? `${detail.substr(0, 1e5)}\u2026` : detail;
      show(this.type);
    } else {
      this.type.innerText = "";
      hide(this.type);
    }
    this.el.style.height = this.header.offsetHeight + this.docs.offsetHeight + this.borderWidth * 2 + "px";
    this.el.style.userSelect = "text";
    this.el.tabIndex = -1;
    this.close.onmousedown = (e) => {
      e.preventDefault();
      e.stopPropagation();
    };
    this.close.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.widget.toggleDetails();
    };
    this.body.scrollTop = 0;
    this.scrollbar.scanDomNode();
  }
  scrollDown(much = 8) {
    this.body.scrollTop += much;
  }
  scrollUp(much = 8) {
    this.body.scrollTop -= much;
  }
  scrollTop() {
    this.body.scrollTop = 0;
  }
  scrollBottom() {
    this.body.scrollTop = this.body.scrollHeight;
  }
  pageDown() {
    this.scrollDown(80);
  }
  pageUp() {
    this.scrollUp(80);
  }
  setBorderWidth(width) {
    this.borderWidth = width;
  }
  configureFont() {
    const options = this.editor.getOptions();
    const fontInfo = options.get(36);
    const fontFamily = fontInfo.fontFamily;
    const fontSize = options.get(97) || fontInfo.fontSize;
    const lineHeight = options.get(98) || fontInfo.lineHeight;
    const fontWeight = fontInfo.fontWeight;
    const fontSizePx = `${fontSize}px`;
    const lineHeightPx = `${lineHeight}px`;
    this.el.style.fontSize = fontSizePx;
    this.el.style.fontWeight = fontWeight;
    this.el.style.fontFeatureSettings = fontInfo.fontFeatureSettings;
    this.type.style.fontFamily = fontFamily;
    this.close.style.height = lineHeightPx;
    this.close.style.width = lineHeightPx;
  }
  dispose() {
    this.disposables.dispose();
    dispose(this.renderDisposeable);
    this.renderDisposeable = void 0;
  }
};
var SuggestWidget = class SuggestWidget2 {
  constructor(editor3, telemetryService, keybindingService, contextKeyService, themeService, storageService, modeService, openerService, menuService, instantiationService) {
    var _a5, _b2;
    this.editor = editor3;
    this.telemetryService = telemetryService;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this.state = 0;
    this.isAddedAsContentWidget = false;
    this.isAuto = false;
    this.loadingTimeout = Disposable.None;
    this.currentSuggestionDetails = null;
    this.ignoreFocusEvents = false;
    this.completionModel = null;
    this.showTimeout = new TimeoutTimer();
    this.toDispose = new DisposableStore();
    this.onDidSelectEmitter = new Emitter2();
    this.onDidFocusEmitter = new Emitter2();
    this.onDidHideEmitter = new Emitter2();
    this.onDidShowEmitter = new Emitter2();
    this.onDidSelect = this.onDidSelectEmitter.event;
    this.onDidFocus = this.onDidFocusEmitter.event;
    this.onDidHide = this.onDidHideEmitter.event;
    this.onDidShow = this.onDidShowEmitter.event;
    this.maxWidgetWidth = 660;
    this.listWidth = 330;
    this.firstFocusInCurrentList = false;
    this.preferDocPositionTop = false;
    this.docsPositionPreviousWidgetY = null;
    this.explainMode = false;
    this._onDetailsKeydown = new Emitter2();
    this.onDetailsKeyDown = this._onDetailsKeydown.event;
    const markdownRenderer = this.toDispose.add(new MarkdownRenderer(editor3, modeService, openerService));
    const kbToggleDetails = (_b2 = (_a5 = keybindingService.lookupKeybinding("toggleSuggestionDetails")) === null || _a5 === void 0 ? void 0 : _a5.getLabel()) !== null && _b2 !== void 0 ? _b2 : "";
    this.isAuto = false;
    this.focusedItem = null;
    this.storageService = storageService;
    this.element = $(".editor-widget.suggest-widget");
    this.toDispose.add(addDisposableListener(this.element, "click", (e) => {
      if (e.target === this.element) {
        this.hideWidget();
      }
    }));
    this.messageElement = append(this.element, $(".message"));
    this.listElement = append(this.element, $(".tree"));
    const applyStatusBarStyle = () => this.element.classList.toggle("with-status-bar", this.editor.getOption(96).statusBar.visible);
    applyStatusBarStyle();
    this.statusBarElement = append(this.element, $(".suggest-status-bar"));
    const actionViewItemProvider = (action) => {
      const kb = keybindingService.lookupKeybindings(action.id);
      return new class extends ActionViewItem {
        constructor() {
          super(void 0, action, {label: true, icon: false});
        }
        updateLabel() {
          if (isFalsyOrEmpty(kb) || !this.label) {
            return super.updateLabel();
          }
          const {label} = this.getAction();
          this.label.textContent = /{\d}/.test(label) ? format(this.getAction().label, kb[0].getLabel()) : `${this.getAction().label} (${kb[0].getLabel()})`;
        }
      }();
    };
    const leftActions = new ActionBar(this.statusBarElement, {actionViewItemProvider});
    const rightActions = new ActionBar(this.statusBarElement, {actionViewItemProvider});
    const menu = menuService.createMenu(suggestWidgetStatusbarMenu, contextKeyService);
    const renderMenu = () => {
      const left = [];
      const right = [];
      for (let [group, actions25] of menu.getActions()) {
        if (group === "left") {
          left.push(...actions25);
        } else {
          right.push(...actions25);
        }
      }
      leftActions.clear();
      leftActions.push(left);
      rightActions.clear();
      rightActions.push(right);
    };
    this.toDispose.add(menu.onDidChange(() => renderMenu()));
    this.toDispose.add(menu);
    this.details = instantiationService.createInstance(SuggestionDetails, this.element, this, this.editor, markdownRenderer, kbToggleDetails);
    const applyIconStyle = () => this.element.classList.toggle("no-icons", !this.editor.getOption(96).showIcons);
    applyIconStyle();
    let renderer = instantiationService.createInstance(ItemRenderer, this, this.editor, kbToggleDetails);
    this.list = new List("SuggestWidget", this.listElement, this, [renderer], {
      useShadows: false,
      mouseSupport: false,
      accessibilityProvider: {
        getRole: () => "option",
        getAriaLabel: (item) => {
          const textLabel = typeof item.completion.label === "string" ? item.completion.label : item.completion.label.name;
          if (item.isResolved && this.expandDocsSettingFromStorage()) {
            const {documentation, detail} = item.completion;
            const docs = format("{0}{1}", detail || "", documentation ? typeof documentation === "string" ? documentation : documentation.value : "");
            return localize("ariaCurrenttSuggestionReadDetails", "{0}, docs: {1}", textLabel, docs);
          } else {
            return textLabel;
          }
        },
        getWidgetAriaLabel: () => localize("suggest", "Suggest"),
        getWidgetRole: () => "listbox"
      }
    });
    this.toDispose.add(attachListStyler(this.list, themeService, {
      listInactiveFocusBackground: editorSuggestWidgetSelectedBackground,
      listInactiveFocusOutline: activeContrastBorder
    }));
    this.toDispose.add(themeService.onDidColorThemeChange((t) => this.onThemeChange(t)));
    this.toDispose.add(editor3.onDidLayoutChange(() => this.onEditorLayoutChange()));
    this.toDispose.add(this.list.onMouseDown((e) => this.onListMouseDownOrTap(e)));
    this.toDispose.add(this.list.onTap((e) => this.onListMouseDownOrTap(e)));
    this.toDispose.add(this.list.onDidChangeSelection((e) => this.onListSelection(e)));
    this.toDispose.add(this.list.onDidChangeFocus((e) => this.onListFocus(e)));
    this.toDispose.add(this.editor.onDidChangeCursorSelection(() => this.onCursorSelectionChanged()));
    this.toDispose.add(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(96)) {
        applyStatusBarStyle();
        applyIconStyle();
      }
    }));
    this.ctxSuggestWidgetVisible = Context2.Visible.bindTo(contextKeyService);
    this.ctxSuggestWidgetDetailsVisible = Context2.DetailsVisible.bindTo(contextKeyService);
    this.ctxSuggestWidgetMultipleSuggestions = Context2.MultipleSuggestions.bindTo(contextKeyService);
    this.onThemeChange(themeService.getColorTheme());
    this.toDispose.add(addStandardDisposableListener(this.details.element, "keydown", (e) => {
      this._onDetailsKeydown.fire(e);
    }));
    this.toDispose.add(this.editor.onMouseDown((e) => this.onEditorMouseDown(e)));
  }
  onEditorMouseDown(mouseEvent) {
    if (this.details.element.contains(mouseEvent.target.element)) {
      this.details.element.focus();
    } else {
      if (this.element.contains(mouseEvent.target.element)) {
        this.editor.focus();
      }
    }
  }
  onCursorSelectionChanged() {
    if (this.state === 0) {
      return;
    }
    this.editor.layoutContentWidget(this);
  }
  onEditorLayoutChange() {
    if ((this.state === 3 || this.state === 5) && this.expandDocsSettingFromStorage()) {
      this.expandSideOrBelow();
    }
  }
  onListMouseDownOrTap(e) {
    if (typeof e.element === "undefined" || typeof e.index === "undefined") {
      return;
    }
    e.browserEvent.preventDefault();
    e.browserEvent.stopPropagation();
    this.select(e.element, e.index);
  }
  onListSelection(e) {
    if (!e.elements.length) {
      return;
    }
    this.select(e.elements[0], e.indexes[0]);
  }
  select(item, index2) {
    const completionModel = this.completionModel;
    if (!completionModel) {
      return;
    }
    this.onDidSelectEmitter.fire({item, index: index2, model: completionModel});
    this.editor.focus();
  }
  onThemeChange(theme6) {
    const backgroundColor = theme6.getColor(editorSuggestWidgetBackground);
    if (backgroundColor) {
      this.listElement.style.backgroundColor = backgroundColor.toString();
      this.statusBarElement.style.backgroundColor = backgroundColor.toString();
      this.details.element.style.backgroundColor = backgroundColor.toString();
      this.messageElement.style.backgroundColor = backgroundColor.toString();
    }
    const borderColor = theme6.getColor(editorSuggestWidgetBorder);
    if (borderColor) {
      this.listElement.style.borderColor = borderColor.toString();
      this.statusBarElement.style.borderColor = borderColor.toString();
      this.details.element.style.borderColor = borderColor.toString();
      this.messageElement.style.borderColor = borderColor.toString();
      this.detailsBorderColor = borderColor.toString();
    }
    const focusBorderColor = theme6.getColor(focusBorder);
    if (focusBorderColor) {
      this.detailsFocusBorderColor = focusBorderColor.toString();
    }
    this.details.setBorderWidth(theme6.type === "hc" ? 2 : 1);
  }
  onListFocus(e) {
    if (this.ignoreFocusEvents) {
      return;
    }
    if (!e.elements.length) {
      if (this.currentSuggestionDetails) {
        this.currentSuggestionDetails.cancel();
        this.currentSuggestionDetails = null;
        this.focusedItem = null;
      }
      this.editor.setAriaOptions({activeDescendant: void 0});
      return;
    }
    if (!this.completionModel) {
      return;
    }
    const item = e.elements[0];
    const index2 = e.indexes[0];
    this.firstFocusInCurrentList = !this.focusedItem;
    if (item !== this.focusedItem) {
      if (this.currentSuggestionDetails) {
        this.currentSuggestionDetails.cancel();
        this.currentSuggestionDetails = null;
      }
      this.focusedItem = item;
      this.list.reveal(index2);
      this.currentSuggestionDetails = createCancelablePromise((token) => __awaiter30(this, void 0, void 0, function* () {
        const loading = disposableTimeout(() => this.showDetails(true), 250);
        token.onCancellationRequested(() => loading.dispose());
        const result = yield item.resolve(token);
        loading.dispose();
        return result;
      }));
      this.currentSuggestionDetails.then(() => {
        if (index2 >= this.list.length || item !== this.list.element(index2)) {
          return;
        }
        this.ignoreFocusEvents = true;
        this.list.splice(index2, 1, [item]);
        this.list.setFocus([index2]);
        this.ignoreFocusEvents = false;
        if (this.expandDocsSettingFromStorage()) {
          this.showDetails(false);
        } else {
          this.element.classList.remove("docs-side");
        }
        this.editor.setAriaOptions({activeDescendant: getAriaId(index2)});
      }).catch(onUnexpectedError);
    }
    this.onDidFocusEmitter.fire({item, index: index2, model: this.completionModel});
  }
  setState(state) {
    if (!this.element) {
      return;
    }
    if (!this.isAddedAsContentWidget && state !== 0) {
      this.isAddedAsContentWidget = true;
      this.editor.addContentWidget(this);
    }
    const stateChanged = this.state !== state;
    this.state = state;
    this.element.classList.toggle("frozen", state === 4);
    switch (state) {
      case 0:
        hide(this.messageElement, this.details.element, this.listElement, this.statusBarElement);
        this.hide();
        this.listHeight = 0;
        if (stateChanged) {
          this.list.splice(0, this.list.length);
        }
        this.focusedItem = null;
        break;
      case 1:
        this.messageElement.textContent = SuggestWidget2.LOADING_MESSAGE;
        hide(this.listElement, this.details.element, this.statusBarElement);
        show(this.messageElement);
        this.element.classList.remove("docs-side");
        this.show();
        this.focusedItem = null;
        break;
      case 2:
        this.messageElement.textContent = SuggestWidget2.NO_SUGGESTIONS_MESSAGE;
        hide(this.listElement, this.details.element, this.statusBarElement);
        show(this.messageElement);
        this.element.classList.remove("docs-side");
        this.show();
        this.focusedItem = null;
        break;
      case 3:
        hide(this.messageElement);
        show(this.listElement, this.statusBarElement);
        this.show();
        break;
      case 4:
        hide(this.messageElement);
        show(this.listElement);
        this.show();
        break;
      case 5:
        hide(this.messageElement);
        show(this.details.element, this.listElement, this.statusBarElement);
        this.show();
        break;
    }
  }
  showTriggered(auto, delay2) {
    if (this.state !== 0) {
      return;
    }
    this.isAuto = !!auto;
    if (!this.isAuto) {
      this.loadingTimeout = disposableTimeout(() => this.setState(1), delay2);
    }
  }
  showSuggestions(completionModel, selectionIndex, isFrozen, isAuto) {
    this.preferDocPositionTop = false;
    this.docsPositionPreviousWidgetY = null;
    this.loadingTimeout.dispose();
    if (this.currentSuggestionDetails) {
      this.currentSuggestionDetails.cancel();
      this.currentSuggestionDetails = null;
    }
    if (this.completionModel !== completionModel) {
      this.completionModel = completionModel;
    }
    if (isFrozen && this.state !== 2 && this.state !== 0) {
      this.setState(4);
      return;
    }
    let visibleCount = this.completionModel.items.length;
    const isEmpty2 = visibleCount === 0;
    this.ctxSuggestWidgetMultipleSuggestions.set(visibleCount > 1);
    if (isEmpty2) {
      if (isAuto) {
        this.setState(0);
      } else {
        this.setState(2);
      }
      this.completionModel = null;
    } else {
      if (this.state !== 3) {
        const {stats} = this.completionModel;
        stats["wasAutomaticallyTriggered"] = !!isAuto;
        this.telemetryService.publicLog("suggestWidget", Object.assign({}, stats));
      }
      this.focusedItem = null;
      this.list.splice(0, this.list.length, this.completionModel.items);
      if (isFrozen) {
        this.setState(4);
      } else {
        this.setState(3);
      }
      this.list.reveal(selectionIndex, 0);
      this.list.setFocus([selectionIndex]);
      if (this.detailsBorderColor) {
        this.details.element.style.borderColor = this.detailsBorderColor;
      }
    }
  }
  selectNextPage() {
    switch (this.state) {
      case 0:
        return false;
      case 5:
        this.details.pageDown();
        return true;
      case 1:
        return !this.isAuto;
      default:
        this.list.focusNextPage();
        return true;
    }
  }
  selectNext() {
    switch (this.state) {
      case 0:
        return false;
      case 1:
        return !this.isAuto;
      default:
        this.list.focusNext(1, true);
        return true;
    }
  }
  selectLast() {
    switch (this.state) {
      case 0:
        return false;
      case 5:
        this.details.scrollBottom();
        return true;
      case 1:
        return !this.isAuto;
      default:
        this.list.focusLast();
        return true;
    }
  }
  selectPreviousPage() {
    switch (this.state) {
      case 0:
        return false;
      case 5:
        this.details.pageUp();
        return true;
      case 1:
        return !this.isAuto;
      default:
        this.list.focusPreviousPage();
        return true;
    }
  }
  selectPrevious() {
    switch (this.state) {
      case 0:
        return false;
      case 1:
        return !this.isAuto;
      default:
        this.list.focusPrevious(1, true);
        return false;
    }
  }
  selectFirst() {
    switch (this.state) {
      case 0:
        return false;
      case 5:
        this.details.scrollTop();
        return true;
      case 1:
        return !this.isAuto;
      default:
        this.list.focusFirst();
        return true;
    }
  }
  getFocusedItem() {
    if (this.state !== 0 && this.state !== 2 && this.state !== 1 && this.completionModel) {
      return {
        item: this.list.getFocusedElements()[0],
        index: this.list.getFocus()[0],
        model: this.completionModel
      };
    }
    return void 0;
  }
  toggleDetailsFocus() {
    if (this.state === 5) {
      this.setState(3);
      if (this.detailsBorderColor) {
        this.details.element.style.borderColor = this.detailsBorderColor;
      }
    } else if (this.state === 3 && this.expandDocsSettingFromStorage()) {
      this.setState(5);
      if (this.detailsFocusBorderColor) {
        this.details.element.style.borderColor = this.detailsFocusBorderColor;
      }
    }
    this.telemetryService.publicLog2("suggestWidget:toggleDetailsFocus");
  }
  toggleDetails() {
    if (!canExpandCompletionItem(this.list.getFocusedElements()[0])) {
      return;
    }
    if (this.expandDocsSettingFromStorage()) {
      this.ctxSuggestWidgetDetailsVisible.set(false);
      this.updateExpandDocsSetting(false);
      hide(this.details.element);
      this.element.classList.remove("docs-side", "doc-below");
      this.editor.layoutContentWidget(this);
      this.telemetryService.publicLog2("suggestWidget:collapseDetails");
    } else {
      if (this.state !== 3 && this.state !== 5 && this.state !== 4) {
        return;
      }
      this.ctxSuggestWidgetDetailsVisible.set(true);
      this.updateExpandDocsSetting(true);
      this.showDetails(false);
      this.telemetryService.publicLog2("suggestWidget:expandDetails");
    }
  }
  showDetails(loading) {
    if (!loading) {
      this.expandSideOrBelow();
    }
    show(this.details.element);
    this.details.element.style.maxHeight = this.maxWidgetHeight + "px";
    if (loading) {
      this.details.renderLoading();
    } else {
      this.details.renderItem(this.list.getFocusedElements()[0], this.explainMode);
    }
    this.listElement.style.marginTop = "0px";
    this.editor.layoutContentWidget(this);
    this.adjustDocsPosition();
    this.editor.focus();
  }
  toggleExplainMode() {
    if (this.list.getFocusedElements()[0] && this.expandDocsSettingFromStorage()) {
      this.explainMode = !this.explainMode;
      this.showDetails(false);
    }
  }
  show() {
    const newHeight = this.updateListHeight();
    if (newHeight !== this.listHeight) {
      this.editor.layoutContentWidget(this);
      this.listHeight = newHeight;
    }
    this.ctxSuggestWidgetVisible.set(true);
    this.showTimeout.cancelAndSet(() => {
      this.element.classList.add("visible");
      this.onDidShowEmitter.fire(this);
    }, 100);
  }
  hide() {
    this.editor.layoutContentWidget(this);
    this.ctxSuggestWidgetVisible.reset();
    this.ctxSuggestWidgetMultipleSuggestions.reset();
    this.element.classList.remove("visible");
  }
  hideWidget() {
    this.loadingTimeout.dispose();
    this.setState(0);
    this.onDidHideEmitter.fire(this);
  }
  getPosition() {
    if (this.state === 0) {
      return null;
    }
    let preference = [2, 1];
    if (this.preferDocPositionTop) {
      preference = [1];
    }
    return {
      position: this.editor.getPosition(),
      preference
    };
  }
  getDomNode() {
    return this.element;
  }
  getId() {
    return SuggestWidget2.ID;
  }
  isFrozen() {
    return this.state === 4;
  }
  updateListHeight() {
    let height = 0;
    if (this.state === 2 || this.state === 1) {
      height = this.unfocusedHeight;
    } else {
      const suggestionCount = this.list.contentHeight / this.unfocusedHeight;
      const {maxVisibleSuggestions} = this.editor.getOption(96);
      height = Math.min(suggestionCount, maxVisibleSuggestions) * this.unfocusedHeight;
    }
    this.element.style.lineHeight = `${this.unfocusedHeight}px`;
    this.listElement.style.height = `${height}px`;
    this.statusBarElement.style.top = `${height}px`;
    this.list.layout(height);
    return height;
  }
  adjustDocsPosition() {
    if (!this.editor.hasModel()) {
      return;
    }
    const lineHeight = this.editor.getOption(51);
    const cursorCoords = this.editor.getScrolledVisiblePosition(this.editor.getPosition());
    const editorCoords = getDomNodePagePosition(this.editor.getDomNode());
    const cursorX = editorCoords.left + cursorCoords.left;
    const cursorY = editorCoords.top + cursorCoords.top + cursorCoords.height;
    const widgetCoords = getDomNodePagePosition(this.element);
    const widgetX = widgetCoords.left;
    const widgetY = widgetCoords.top;
    if (this.docsPositionPreviousWidgetY && this.docsPositionPreviousWidgetY < widgetY && !this.preferDocPositionTop) {
      this.preferDocPositionTop = true;
      this.adjustDocsPosition();
      return;
    }
    this.docsPositionPreviousWidgetY = widgetY;
    if (widgetX < cursorX - this.listWidth) {
      this.element.classList.add("list-right");
    } else {
      this.element.classList.remove("list-right");
    }
    if (this.element.classList.contains("docs-side") && cursorY - lineHeight > widgetY && this.details.element.offsetHeight > this.listElement.offsetHeight) {
      this.listElement.style.marginTop = `${this.details.element.offsetHeight - this.listElement.offsetHeight}px`;
    }
  }
  expandSideOrBelow() {
    if (!canExpandCompletionItem(this.focusedItem) && this.firstFocusInCurrentList) {
      this.element.classList.remove("docs-side", "docs-below");
      return;
    }
    let matches = this.element.style.maxWidth.match(/(\d+)px/);
    if (!matches || Number(matches[1]) < this.maxWidgetWidth) {
      this.element.classList.add("docs-below");
      this.element.classList.remove("docs-side");
    } else if (canExpandCompletionItem(this.focusedItem)) {
      this.element.classList.add("docs-side");
      this.element.classList.remove("docs-below");
    }
  }
  get maxWidgetHeight() {
    return this.unfocusedHeight * this.editor.getOption(96).maxVisibleSuggestions;
  }
  get unfocusedHeight() {
    const options = this.editor.getOptions();
    return options.get(98) || options.get(36).lineHeight;
  }
  getHeight(element) {
    return this.unfocusedHeight;
  }
  getTemplateId(element) {
    return "suggestion";
  }
  expandDocsSettingFromStorage() {
    return this.storageService.getBoolean("expandSuggestionDocs", 0, expandSuggestionDocsByDefault);
  }
  updateExpandDocsSetting(value) {
    this.storageService.store("expandSuggestionDocs", value, 0);
  }
  dispose() {
    this.details.dispose();
    this.list.dispose();
    this.toDispose.dispose();
    this.loadingTimeout.dispose();
    this.showTimeout.dispose();
    this.editor.removeContentWidget(this);
  }
};
SuggestWidget.ID = "editor.widget.suggestWidget";
SuggestWidget.LOADING_MESSAGE = localize("suggestWidget.loading", "Loading...");
SuggestWidget.NO_SUGGESTIONS_MESSAGE = localize("suggestWidget.noSuggestions", "No suggestions.");
SuggestWidget = __decorate38([
  __param38(1, ITelemetryService),
  __param38(2, IKeybindingService),
  __param38(3, IContextKeyService),
  __param38(4, IThemeService),
  __param38(5, IStorageService),
  __param38(6, IModeService),
  __param38(7, IOpenerService),
  __param38(8, IMenuService),
  __param38(9, IInstantiationService)
], SuggestWidget);
registerThemingParticipant((theme6, collector) => {
  const matchHighlight = theme6.getColor(editorSuggestWidgetHighlightForeground);
  if (matchHighlight) {
    collector.addRule(`.monaco-editor .suggest-widget .monaco-list .monaco-list-row .monaco-highlighted-label .highlight { color: ${matchHighlight}; }`);
  }
  const foreground2 = theme6.getColor(editorSuggestWidgetForeground);
  if (foreground2) {
    collector.addRule(`.monaco-editor .suggest-widget { color: ${foreground2}; }`);
  }
  const link = theme6.getColor(textLinkForeground);
  if (link) {
    collector.addRule(`.monaco-editor .suggest-widget a { color: ${link}; }`);
  }
  const codeBackground = theme6.getColor(textCodeBlockBackground);
  if (codeBackground) {
    collector.addRule(`.monaco-editor .suggest-widget code { background-color: ${codeBackground}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/wordContextKey.js
var __decorate39 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param39 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var WordContextKey = class WordContextKey2 extends Disposable {
  constructor(_editor, contextKeyService) {
    super();
    this._editor = _editor;
    this._enabled = false;
    this._ckAtEnd = WordContextKey2.AtEnd.bindTo(contextKeyService);
    this._register(this._editor.onDidChangeConfiguration((e) => e.hasChanged(101) && this._update()));
    this._update();
  }
  dispose() {
    super.dispose();
    dispose(this._selectionListener);
    this._ckAtEnd.reset();
  }
  _update() {
    const enabled = this._editor.getOption(101) === "on";
    if (this._enabled === enabled) {
      return;
    }
    this._enabled = enabled;
    if (this._enabled) {
      const checkForWordEnd = () => {
        if (!this._editor.hasModel()) {
          this._ckAtEnd.set(false);
          return;
        }
        const model = this._editor.getModel();
        const selection = this._editor.getSelection();
        const word = model.getWordAtPosition(selection.getStartPosition());
        if (!word) {
          this._ckAtEnd.set(false);
          return;
        }
        this._ckAtEnd.set(word.endColumn === selection.getStartPosition().column);
      };
      this._selectionListener = this._editor.onDidChangeCursorSelection(checkForWordEnd);
      checkForWordEnd();
    } else if (this._selectionListener) {
      this._ckAtEnd.reset();
      this._selectionListener.dispose();
      this._selectionListener = void 0;
    }
  }
};
WordContextKey.AtEnd = new RawContextKey("atEndOfWord", false);
WordContextKey = __decorate39([
  __param39(1, IContextKeyService)
], WordContextKey);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestCommitCharacters.js
var CommitCharacterController = class {
  constructor(editor3, widget, accept) {
    this._disposables = new DisposableStore();
    this._disposables.add(widget.onDidShow(() => this._onItem(widget.getFocusedItem())));
    this._disposables.add(widget.onDidFocus(this._onItem, this));
    this._disposables.add(widget.onDidHide(this.reset, this));
    this._disposables.add(editor3.onWillType((text) => {
      if (this._active && !widget.isFrozen()) {
        const ch = text.charCodeAt(text.length - 1);
        if (this._active.acceptCharacters.has(ch) && editor3.getOption(0)) {
          accept(this._active.item);
        }
      }
    }));
  }
  _onItem(selected) {
    if (!selected || !isNonEmptyArray(selected.item.completion.commitCharacters)) {
      this.reset();
      return;
    }
    if (this._active && this._active.item.item === selected.item) {
      return;
    }
    const acceptCharacters = new CharacterSet();
    for (const ch of selected.item.completion.commitCharacters) {
      if (ch.length > 0) {
        acceptCharacters.add(ch.charCodeAt(0));
      }
    }
    this._active = {acceptCharacters, item: selected};
  }
  reset() {
    this._active = void 0;
  }
  dispose() {
    this._disposables.dispose();
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestOvertypingCapturer.js
var OvertypingCapturer = class {
  constructor(editor3, suggestModel) {
    this._disposables = new DisposableStore();
    this._lastOvertyped = [];
    this._empty = true;
    this._disposables.add(editor3.onWillType(() => {
      if (!this._empty) {
        return;
      }
      if (!editor3.hasModel()) {
        return;
      }
      const selections = editor3.getSelections();
      const selectionsLength = selections.length;
      let willOvertype = false;
      for (let i = 0; i < selectionsLength; i++) {
        if (!selections[i].isEmpty()) {
          willOvertype = true;
          break;
        }
      }
      if (!willOvertype) {
        return;
      }
      this._lastOvertyped = [];
      const model = editor3.getModel();
      for (let i = 0; i < selectionsLength; i++) {
        const selection = selections[i];
        if (model.getValueLengthInRange(selection) > OvertypingCapturer._maxSelectionLength) {
          return;
        }
        this._lastOvertyped[i] = {value: model.getValueInRange(selection), multiline: selection.startLineNumber !== selection.endLineNumber};
      }
      this._empty = false;
    }));
    this._disposables.add(suggestModel.onDidCancel((e) => {
      if (!this._empty) {
        this._empty = true;
      }
    }));
  }
  getLastOvertypedInfo(idx) {
    if (!this._empty && idx >= 0 && idx < this._lastOvertyped.length) {
      return this._lastOvertyped[idx];
    }
    return void 0;
  }
  dispose() {
    this._disposables.dispose();
  }
};
OvertypingCapturer._maxSelectionLength = 51200;

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestController.js
var __decorate40 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param40 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _sticky = false;
var LineSuffix = class {
  constructor(_model, _position) {
    this._model = _model;
    this._position = _position;
    const maxColumn = _model.getLineMaxColumn(_position.lineNumber);
    if (maxColumn !== _position.column) {
      const offset = _model.getOffsetAt(_position);
      const end = _model.getPositionAt(offset + 1);
      this._marker = _model.deltaDecorations([], [{
        range: Range2.fromPositions(_position, end),
        options: {stickiness: 1}
      }]);
    }
  }
  dispose() {
    if (this._marker && !this._model.isDisposed()) {
      this._model.deltaDecorations(this._marker, []);
    }
  }
  delta(position) {
    if (this._model.isDisposed() || this._position.lineNumber !== position.lineNumber) {
      return 0;
    }
    if (this._marker) {
      const range2 = this._model.getDecorationRange(this._marker[0]);
      const end = this._model.getOffsetAt(range2.getStartPosition());
      return end - this._model.getOffsetAt(position);
    } else {
      return this._model.getLineMaxColumn(position.lineNumber) - position.column;
    }
  }
};
var SuggestController = class SuggestController2 {
  constructor(editor3, editorWorker, _memoryService, _commandService, _contextKeyService, _instantiationService, _logService, clipboardService) {
    this._memoryService = _memoryService;
    this._commandService = _commandService;
    this._contextKeyService = _contextKeyService;
    this._instantiationService = _instantiationService;
    this._logService = _logService;
    this._lineSuffix = new MutableDisposable();
    this._toDispose = new DisposableStore();
    this.editor = editor3;
    this.model = new SuggestModel(this.editor, editorWorker, clipboardService);
    this.widget = this._toDispose.add(new IdleValue(() => {
      const widget = this._instantiationService.createInstance(SuggestWidget, this.editor);
      this._toDispose.add(widget);
      this._toDispose.add(widget.onDidSelect((item) => this._insertSuggestion(item, 0), this));
      const commitCharacterController = new CommitCharacterController(this.editor, widget, (item) => this._insertSuggestion(item, 2));
      this._toDispose.add(commitCharacterController);
      this._toDispose.add(this.model.onDidSuggest((e) => {
        if (e.completionModel.items.length === 0) {
          commitCharacterController.reset();
        }
      }));
      const ctxMakesTextEdit = Context2.MakesTextEdit.bindTo(this._contextKeyService);
      const ctxHasInsertAndReplace = Context2.HasInsertAndReplaceRange.bindTo(this._contextKeyService);
      const ctxCanResolve = Context2.CanResolve.bindTo(this._contextKeyService);
      this._toDispose.add(toDisposable(() => {
        ctxMakesTextEdit.reset();
        ctxHasInsertAndReplace.reset();
        ctxCanResolve.reset();
      }));
      this._toDispose.add(widget.onDidFocus(({item}) => {
        const position = this.editor.getPosition();
        const startColumn = item.editStart.column;
        const endColumn = position.column;
        let value = true;
        if (this.editor.getOption(1) === "smart" && this.model.state === 2 && !item.completion.command && !item.completion.additionalTextEdits && !(item.completion.insertTextRules & 4) && endColumn - startColumn === item.completion.insertText.length) {
          const oldText = this.editor.getModel().getValueInRange({
            startLineNumber: position.lineNumber,
            startColumn,
            endLineNumber: position.lineNumber,
            endColumn
          });
          value = oldText !== item.completion.insertText;
        }
        ctxMakesTextEdit.set(value);
        ctxHasInsertAndReplace.set(!Position.equals(item.editInsertEnd, item.editReplaceEnd));
        ctxCanResolve.set(Boolean(item.provider.resolveCompletionItem) || Boolean(item.completion.documentation) || item.completion.detail !== item.completion.label);
      }));
      this._toDispose.add(widget.onDetailsKeyDown((e) => {
        if (e.toKeybinding().equals(new SimpleKeybinding(true, false, false, false, 33)) || isMacintosh && e.toKeybinding().equals(new SimpleKeybinding(false, false, false, true, 33))) {
          e.stopPropagation();
          return;
        }
        if (!e.toKeybinding().isModifierKey()) {
          this.editor.focus();
        }
      }));
      return widget;
    }));
    this._overtypingCapturer = this._toDispose.add(new IdleValue(() => {
      return this._toDispose.add(new OvertypingCapturer(this.editor, this.model));
    }));
    this._alternatives = this._toDispose.add(new IdleValue(() => {
      return this._toDispose.add(new SuggestAlternatives(this.editor, this._contextKeyService));
    }));
    this._toDispose.add(_instantiationService.createInstance(WordContextKey, editor3));
    this._toDispose.add(this.model.onDidTrigger((e) => {
      this.widget.value.showTriggered(e.auto, e.shy ? 250 : 50);
      this._lineSuffix.value = new LineSuffix(this.editor.getModel(), e.position);
    }));
    this._toDispose.add(this.model.onDidSuggest((e) => {
      if (!e.shy) {
        let index2 = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), e.completionModel.items);
        this.widget.value.showSuggestions(e.completionModel, index2, e.isFrozen, e.auto);
      }
    }));
    this._toDispose.add(this.model.onDidCancel((e) => {
      if (!e.retrigger) {
        this.widget.value.hideWidget();
      }
    }));
    this._toDispose.add(this.editor.onDidBlurEditorWidget(() => {
      if (!_sticky) {
        this.model.cancel();
        this.model.clear();
      }
    }));
    let acceptSuggestionsOnEnter = Context2.AcceptSuggestionsOnEnter.bindTo(_contextKeyService);
    let updateFromConfig = () => {
      const acceptSuggestionOnEnter = this.editor.getOption(1);
      acceptSuggestionsOnEnter.set(acceptSuggestionOnEnter === "on" || acceptSuggestionOnEnter === "smart");
    };
    this._toDispose.add(this.editor.onDidChangeConfiguration(() => updateFromConfig()));
    updateFromConfig();
  }
  static get(editor3) {
    return editor3.getContribution(SuggestController2.ID);
  }
  dispose() {
    this._alternatives.dispose();
    this._toDispose.dispose();
    this.widget.dispose();
    this.model.dispose();
    this._lineSuffix.dispose();
  }
  _insertSuggestion(event, flags) {
    if (!event || !event.item) {
      this._alternatives.value.reset();
      this.model.cancel();
      this.model.clear();
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    const model = this.editor.getModel();
    const modelVersionNow = model.getAlternativeVersionId();
    const {item} = event;
    const tasks = [];
    const cts = new CancellationTokenSource();
    if (!(flags & 1)) {
      this.editor.pushUndoStop();
    }
    const info = this.getOverwriteInfo(item, Boolean(flags & 8));
    this._memoryService.memorize(model, this.editor.getPosition(), item);
    if (Array.isArray(item.completion.additionalTextEdits)) {
      const scrollState = StableEditorScrollState.capture(this.editor);
      this.editor.executeEdits("suggestController.additionalTextEdits.sync", item.completion.additionalTextEdits.map((edit2) => EditOperation.replace(Range2.lift(edit2.range), edit2.text)));
      scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);
    } else if (!item.isResolved) {
      const sw = new StopWatch(true);
      let position;
      const docListener = model.onDidChangeContent((e) => {
        if (e.isFlush) {
          cts.cancel();
          docListener.dispose();
          return;
        }
        for (let change of e.changes) {
          const thisPosition = Range2.getEndPosition(change.range);
          if (!position || Position.isBefore(thisPosition, position)) {
            position = thisPosition;
          }
        }
      });
      let oldFlags = flags;
      flags |= 2;
      let didType = false;
      let typeListener = this.editor.onWillType(() => {
        typeListener.dispose();
        didType = true;
        if (!(oldFlags & 2)) {
          this.editor.pushUndoStop();
        }
      });
      tasks.push(item.resolve(cts.token).then(() => {
        if (!item.completion.additionalTextEdits || cts.token.isCancellationRequested) {
          return false;
        }
        if (position && item.completion.additionalTextEdits.some((edit2) => Position.isBefore(position, Range2.getStartPosition(edit2.range)))) {
          return false;
        }
        if (didType) {
          this.editor.pushUndoStop();
        }
        const scrollState = StableEditorScrollState.capture(this.editor);
        this.editor.executeEdits("suggestController.additionalTextEdits.async", item.completion.additionalTextEdits.map((edit2) => EditOperation.replace(Range2.lift(edit2.range), edit2.text)));
        scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);
        if (didType || !(oldFlags & 2)) {
          this.editor.pushUndoStop();
        }
        return true;
      }).then((applied) => {
        this._logService.trace("[suggest] async resolving of edits DONE (ms, applied?)", sw.elapsed(), applied);
        docListener.dispose();
        typeListener.dispose();
      }));
    }
    let {insertText} = item.completion;
    if (!(item.completion.insertTextRules & 4)) {
      insertText = SnippetParser.escape(insertText);
    }
    SnippetController2.get(this.editor).insert(insertText, {
      overwriteBefore: info.overwriteBefore,
      overwriteAfter: info.overwriteAfter,
      undoStopBefore: false,
      undoStopAfter: false,
      adjustWhitespace: !(item.completion.insertTextRules & 1),
      clipboardText: event.model.clipboardText,
      overtypingCapturer: this._overtypingCapturer.value
    });
    if (!(flags & 2)) {
      this.editor.pushUndoStop();
    }
    if (!item.completion.command) {
      this.model.cancel();
    } else if (item.completion.command.id === TriggerSuggestAction.id) {
      this.model.trigger({auto: true, shy: false}, true);
    } else {
      tasks.push(this._commandService.executeCommand(item.completion.command.id, ...item.completion.command.arguments ? [...item.completion.command.arguments] : []).catch(onUnexpectedError));
      this.model.cancel();
    }
    if (flags & 4) {
      this._alternatives.value.set(event, (next) => {
        cts.cancel();
        while (model.canUndo()) {
          if (modelVersionNow !== model.getAlternativeVersionId()) {
            model.undo();
          }
          this._insertSuggestion(next, 1 | 2 | (flags & 8 ? 8 : 0));
          break;
        }
      });
    }
    this._alertCompletionItem(item);
    Promise.all(tasks).finally(() => {
      this.model.clear();
      cts.dispose();
    });
  }
  getOverwriteInfo(item, toggleMode) {
    assertType(this.editor.hasModel());
    let replace = this.editor.getOption(96).insertMode === "replace";
    if (toggleMode) {
      replace = !replace;
    }
    const overwriteBefore = item.position.column - item.editStart.column;
    const overwriteAfter = (replace ? item.editReplaceEnd.column : item.editInsertEnd.column) - item.position.column;
    const columnDelta = this.editor.getPosition().column - item.position.column;
    const suffixDelta = this._lineSuffix.value ? this._lineSuffix.value.delta(this.editor.getPosition()) : 0;
    return {
      overwriteBefore: overwriteBefore + columnDelta,
      overwriteAfter: overwriteAfter + suffixDelta
    };
  }
  _alertCompletionItem({completion: suggestion}) {
    const textLabel = typeof suggestion.label === "string" ? suggestion.label : suggestion.label.name;
    if (isNonEmptyArray(suggestion.additionalTextEdits)) {
      let msg = localize("arai.alert.snippet", "Accepting '{0}' made {1} additional edits", textLabel, suggestion.additionalTextEdits.length);
      alert(msg);
    }
  }
  triggerSuggest(onlyFrom) {
    if (this.editor.hasModel()) {
      this.model.trigger({auto: false, shy: false}, false, onlyFrom);
      this.editor.revealLine(this.editor.getPosition().lineNumber, 0);
      this.editor.focus();
    }
  }
  triggerSuggestAndAcceptBest(arg) {
    if (!this.editor.hasModel()) {
      return;
    }
    const positionNow = this.editor.getPosition();
    const fallback2 = () => {
      if (positionNow.equals(this.editor.getPosition())) {
        this._commandService.executeCommand(arg.fallback);
      }
    };
    const makesTextEdit = (item) => {
      if (item.completion.insertTextRules & 4 || item.completion.additionalTextEdits) {
        return true;
      }
      const position = this.editor.getPosition();
      const startColumn = item.editStart.column;
      const endColumn = position.column;
      if (endColumn - startColumn !== item.completion.insertText.length) {
        return true;
      }
      const textNow = this.editor.getModel().getValueInRange({
        startLineNumber: position.lineNumber,
        startColumn,
        endLineNumber: position.lineNumber,
        endColumn
      });
      return textNow !== item.completion.insertText;
    };
    Event.once(this.model.onDidTrigger)((_) => {
      let listener = [];
      Event.any(this.model.onDidTrigger, this.model.onDidCancel)(() => {
        dispose(listener);
        fallback2();
      }, void 0, listener);
      this.model.onDidSuggest(({completionModel}) => {
        dispose(listener);
        if (completionModel.items.length === 0) {
          fallback2();
          return;
        }
        const index2 = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), completionModel.items);
        const item = completionModel.items[index2];
        if (!makesTextEdit(item)) {
          fallback2();
          return;
        }
        this.editor.pushUndoStop();
        this._insertSuggestion({index: index2, item, model: completionModel}, 4 | 1 | 2);
      }, void 0, listener);
    });
    this.model.trigger({auto: false, shy: true});
    this.editor.revealLine(positionNow.lineNumber, 0);
    this.editor.focus();
  }
  acceptSelectedSuggestion(keepAlternativeSuggestions, alternativeOverwriteConfig) {
    const item = this.widget.value.getFocusedItem();
    let flags = 0;
    if (keepAlternativeSuggestions) {
      flags |= 4;
    }
    if (alternativeOverwriteConfig) {
      flags |= 8;
    }
    this._insertSuggestion(item, flags);
  }
  acceptNextSuggestion() {
    this._alternatives.value.next();
  }
  acceptPrevSuggestion() {
    this._alternatives.value.prev();
  }
  cancelSuggestWidget() {
    this.model.cancel();
    this.model.clear();
    this.widget.value.hideWidget();
  }
  selectNextSuggestion() {
    this.widget.value.selectNext();
  }
  selectNextPageSuggestion() {
    this.widget.value.selectNextPage();
  }
  selectLastSuggestion() {
    this.widget.value.selectLast();
  }
  selectPrevSuggestion() {
    this.widget.value.selectPrevious();
  }
  selectPrevPageSuggestion() {
    this.widget.value.selectPreviousPage();
  }
  selectFirstSuggestion() {
    this.widget.value.selectFirst();
  }
  toggleSuggestionDetails() {
    this.widget.value.toggleDetails();
  }
  toggleExplainMode() {
    this.widget.value.toggleExplainMode();
  }
  toggleSuggestionFocus() {
    this.widget.value.toggleDetailsFocus();
  }
};
SuggestController.ID = "editor.contrib.suggestController";
SuggestController = __decorate40([
  __param40(1, IEditorWorkerService),
  __param40(2, ISuggestMemoryService),
  __param40(3, ICommandService),
  __param40(4, IContextKeyService),
  __param40(5, IInstantiationService),
  __param40(6, ILogService),
  __param40(7, IClipboardService)
], SuggestController);
var TriggerSuggestAction = class extends EditorAction {
  constructor() {
    super({
      id: TriggerSuggestAction.id,
      label: localize("suggest.trigger.label", "Trigger Suggest"),
      alias: "Trigger Suggest",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCompletionItemProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 10,
        mac: {primary: 256 | 10, secondary: [512 | 9]},
        weight: 100
      }
    });
  }
  run(accessor, editor3) {
    const controller = SuggestController.get(editor3);
    if (!controller) {
      return;
    }
    controller.triggerSuggest();
  }
};
TriggerSuggestAction.id = "editor.action.triggerSuggest";
registerEditorContribution(SuggestController.ID, SuggestController);
registerEditorAction(TriggerSuggestAction);
var weight2 = 100 + 90;
var SuggestCommand = EditorCommand.bindToContribution(SuggestController.get);
registerEditorCommand(new SuggestCommand({
  id: "acceptSelectedSuggestion",
  precondition: Context2.Visible,
  handler(x) {
    x.acceptSelectedSuggestion(true, false);
  }
}));
KeybindingsRegistry.registerKeybindingRule({
  id: "acceptSelectedSuggestion",
  when: ContextKeyExpr.and(Context2.Visible, EditorContextKeys.textInputFocus),
  primary: 2,
  weight: weight2
});
KeybindingsRegistry.registerKeybindingRule({
  id: "acceptSelectedSuggestion",
  when: ContextKeyExpr.and(Context2.Visible, EditorContextKeys.textInputFocus, Context2.AcceptSuggestionsOnEnter, Context2.MakesTextEdit),
  primary: 3,
  weight: weight2
});
MenuRegistry.appendMenuItem(suggestWidgetStatusbarMenu, {
  command: {id: "acceptSelectedSuggestion", title: localize({key: "accept.accept", comment: ['{0} will be a keybinding, e.g "Enter to insert"']}, "{0} to insert")},
  group: "left",
  order: 1,
  when: Context2.HasInsertAndReplaceRange.toNegated()
});
MenuRegistry.appendMenuItem(suggestWidgetStatusbarMenu, {
  command: {id: "acceptSelectedSuggestion", title: localize({key: "accept.insert", comment: ['{0} will be a keybinding, e.g "Enter to insert"']}, "{0} to insert")},
  group: "left",
  order: 1,
  when: ContextKeyExpr.and(Context2.HasInsertAndReplaceRange, ContextKeyExpr.equals("config.editor.suggest.insertMode", "insert"))
});
MenuRegistry.appendMenuItem(suggestWidgetStatusbarMenu, {
  command: {id: "acceptSelectedSuggestion", title: localize({key: "accept.replace", comment: ['{0} will be a keybinding, e.g "Enter to replace"']}, "{0} to replace")},
  group: "left",
  order: 1,
  when: ContextKeyExpr.and(Context2.HasInsertAndReplaceRange, ContextKeyExpr.equals("config.editor.suggest.insertMode", "replace"))
});
registerEditorCommand(new SuggestCommand({
  id: "acceptAlternativeSelectedSuggestion",
  precondition: ContextKeyExpr.and(Context2.Visible, EditorContextKeys.textInputFocus),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 1024 | 3,
    secondary: [1024 | 2]
  },
  handler(x) {
    x.acceptSelectedSuggestion(false, true);
  },
  menuOpts: [{
    menuId: suggestWidgetStatusbarMenu,
    group: "left",
    order: 2,
    when: ContextKeyExpr.and(Context2.HasInsertAndReplaceRange, ContextKeyExpr.equals("config.editor.suggest.insertMode", "insert")),
    title: localize({key: "accept.replace", comment: ['{0} will be a keybinding, e.g "Enter to replace"']}, "{0} to replace")
  }, {
    menuId: suggestWidgetStatusbarMenu,
    group: "left",
    order: 2,
    when: ContextKeyExpr.and(Context2.HasInsertAndReplaceRange, ContextKeyExpr.equals("config.editor.suggest.insertMode", "replace")),
    title: localize({key: "accept.insert", comment: ['{0} will be a keybinding, e.g "Enter to insert"']}, "{0} to insert")
  }]
}));
CommandsRegistry.registerCommandAlias("acceptSelectedSuggestionOnEnter", "acceptSelectedSuggestion");
registerEditorCommand(new SuggestCommand({
  id: "hideSuggestWidget",
  precondition: Context2.Visible,
  handler: (x) => x.cancelSuggestWidget(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectNextSuggestion",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSuggestions),
  handler: (c) => c.selectNextSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 18,
    secondary: [2048 | 18],
    mac: {primary: 18, secondary: [2048 | 18, 256 | 44]}
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectNextPageSuggestion",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSuggestions),
  handler: (c) => c.selectNextPageSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 12,
    secondary: [2048 | 12]
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectLastSuggestion",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSuggestions),
  handler: (c) => c.selectLastSuggestion()
}));
registerEditorCommand(new SuggestCommand({
  id: "selectPrevSuggestion",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSuggestions),
  handler: (c) => c.selectPrevSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 16,
    secondary: [2048 | 16],
    mac: {primary: 16, secondary: [2048 | 16, 256 | 46]}
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectPrevPageSuggestion",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSuggestions),
  handler: (c) => c.selectPrevPageSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 11,
    secondary: [2048 | 11]
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectFirstSuggestion",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSuggestions),
  handler: (c) => c.selectFirstSuggestion()
}));
registerEditorCommand(new SuggestCommand({
  id: "toggleSuggestionDetails",
  precondition: Context2.Visible,
  handler: (x) => x.toggleSuggestionDetails(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2048 | 10,
    mac: {primary: 256 | 10}
  },
  menuOpts: [{
    menuId: suggestWidgetStatusbarMenu,
    group: "right",
    order: 1,
    when: ContextKeyExpr.and(Context2.DetailsVisible, Context2.CanResolve),
    title: localize("detail.more", "show less")
  }, {
    menuId: suggestWidgetStatusbarMenu,
    group: "right",
    order: 1,
    when: ContextKeyExpr.and(Context2.DetailsVisible.toNegated(), Context2.CanResolve),
    title: localize("detail.less", "show more")
  }]
}));
registerEditorCommand(new SuggestCommand({
  id: "toggleExplainMode",
  precondition: Context2.Visible,
  handler: (x) => x.toggleExplainMode(),
  kbOpts: {
    weight: 100,
    primary: 2048 | 85
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "toggleSuggestionFocus",
  precondition: Context2.Visible,
  handler: (x) => x.toggleSuggestionFocus(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2048 | 512 | 10,
    mac: {primary: 256 | 512 | 10}
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "insertBestCompletion",
  precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), WordContextKey.AtEnd, Context2.Visible.toNegated(), SuggestAlternatives.OtherSuggestions.toNegated(), SnippetController2.InSnippetMode.toNegated()),
  handler: (x, arg) => {
    x.triggerSuggestAndAcceptBest(isObject(arg) ? Object.assign({fallback: "tab"}, arg) : {fallback: "tab"});
  },
  kbOpts: {
    weight: weight2,
    primary: 2
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "insertNextSuggestion",
  precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), SuggestAlternatives.OtherSuggestions, Context2.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),
  handler: (x) => x.acceptNextSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "insertPrevSuggestion",
  precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), SuggestAlternatives.OtherSuggestions, Context2.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),
  handler: (x) => x.acceptPrevSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 1024 | 2
  }
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/tokenization/tokenization.js
var ForceRetokenizeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.forceRetokenize",
      label: localize("forceRetokenize", "Developer: Force Retokenize"),
      alias: "Developer: Force Retokenize",
      precondition: void 0
    });
  }
  run(accessor, editor3) {
    if (!editor3.hasModel()) {
      return;
    }
    const model = editor3.getModel();
    model.resetTokenization();
    const sw = new StopWatch(true);
    model.forceTokenization(model.getLineCount());
    sw.stop();
    console.log(`tokenization took ${sw.elapsed()}`);
  }
};
registerEditorAction(ForceRetokenizeAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/toggleTabFocusMode/toggleTabFocusMode.js
var ToggleTabFocusModeAction = class extends EditorAction {
  constructor() {
    super({
      id: ToggleTabFocusModeAction.ID,
      label: localize({key: "toggle.tabMovesFocus", comment: ["Turn on/off use of tab key for moving focus around VS Code"]}, "Toggle Tab Key Moves Focus"),
      alias: "Toggle Tab Key Moves Focus",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 2048 | 43,
        mac: {primary: 256 | 1024 | 43},
        weight: 100
      }
    });
  }
  run(accessor, editor3) {
    const oldValue = TabFocus.getTabFocusMode();
    const newValue = !oldValue;
    TabFocus.setTabFocusMode(newValue);
    if (newValue) {
      alert(localize("toggle.tabMovesFocus.on", "Pressing Tab will now move focus to the next focusable element"));
    } else {
      alert(localize("toggle.tabMovesFocus.off", "Pressing Tab will now insert the tab character"));
    }
  }
};
ToggleTabFocusModeAction.ID = "editor.action.toggleTabFocusMode";
registerEditorAction(ToggleTabFocusModeAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/unusualLineTerminators/unusualLineTerminators.js
var __decorate41 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param41 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter31 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ignoreUnusualLineTerminators = "ignoreUnusualLineTerminators";
function writeIgnoreState(codeEditorService, model, state) {
  codeEditorService.setModelProperty(model.uri, ignoreUnusualLineTerminators, state);
}
function readIgnoreState(codeEditorService, model) {
  return codeEditorService.getModelProperty(model.uri, ignoreUnusualLineTerminators);
}
var UnusualLineTerminatorsDetector = class UnusualLineTerminatorsDetector2 extends Disposable {
  constructor(_editor, _dialogService, _codeEditorService) {
    super();
    this._editor = _editor;
    this._dialogService = _dialogService;
    this._codeEditorService = _codeEditorService;
    this._config = this._editor.getOption(103);
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(103)) {
        this._config = this._editor.getOption(103);
        this._checkForUnusualLineTerminators();
      }
    }));
    this._register(this._editor.onDidChangeModel(() => {
      this._checkForUnusualLineTerminators();
    }));
    this._register(this._editor.onDidChangeModelContent((e) => {
      if (e.isUndoing) {
        return;
      }
      this._checkForUnusualLineTerminators();
    }));
  }
  _checkForUnusualLineTerminators() {
    return __awaiter31(this, void 0, void 0, function* () {
      if (this._config === "off") {
        return;
      }
      if (!this._editor.hasModel()) {
        return;
      }
      const model = this._editor.getModel();
      if (!model.mightContainUnusualLineTerminators()) {
        return;
      }
      const ignoreState = readIgnoreState(this._codeEditorService, model);
      if (ignoreState === true) {
        return;
      }
      if (this._editor.getOption(72)) {
        return;
      }
      if (this._config === "auto") {
        model.removeUnusualLineTerminators(this._editor.getSelections());
        return;
      }
      const result = yield this._dialogService.confirm({
        title: localize("unusualLineTerminators.title", "Unusual Line Terminators"),
        message: localize("unusualLineTerminators.message", "Detected unusual line terminators"),
        detail: localize("unusualLineTerminators.detail", "This file contains one or more unusual line terminator characters, like Line Separator (LS) or Paragraph Separator (PS).\n\nIt is recommended to remove them from the file. This can be configured via `editor.unusualLineTerminators`."),
        primaryButton: localize("unusualLineTerminators.fix", "Fix this file"),
        secondaryButton: localize("unusualLineTerminators.ignore", "Ignore problem for this file")
      });
      if (!result.confirmed) {
        writeIgnoreState(this._codeEditorService, model, true);
        return;
      }
      model.removeUnusualLineTerminators(this._editor.getSelections());
    });
  }
};
UnusualLineTerminatorsDetector.ID = "editor.contrib.unusualLineTerminatorsDetector";
UnusualLineTerminatorsDetector = __decorate41([
  __param41(1, IDialogService),
  __param41(2, ICodeEditorService)
], UnusualLineTerminatorsDetector);
registerEditorContribution(UnusualLineTerminatorsDetector.ID, UnusualLineTerminatorsDetector);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/viewportSemanticTokens/viewportSemanticTokens.js
var __decorate42 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param42 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ViewportSemanticTokensContribution = class ViewportSemanticTokensContribution2 extends Disposable {
  constructor(editor3, _modelService, _themeService, _configurationService) {
    super();
    this._modelService = _modelService;
    this._themeService = _themeService;
    this._configurationService = _configurationService;
    this._editor = editor3;
    this._tokenizeViewport = new RunOnceScheduler(() => this._tokenizeViewportNow(), 100);
    this._outstandingRequests = [];
    this._register(this._editor.onDidScrollChange(() => {
      this._tokenizeViewport.schedule();
    }));
    this._register(this._editor.onDidChangeModel(() => {
      this._cancelAll();
      this._tokenizeViewport.schedule();
    }));
    this._register(this._editor.onDidChangeModelContent((e) => {
      this._cancelAll();
      this._tokenizeViewport.schedule();
    }));
    this._register(DocumentRangeSemanticTokensProviderRegistry.onDidChange(() => {
      this._cancelAll();
      this._tokenizeViewport.schedule();
    }));
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {
        this._cancelAll();
        this._tokenizeViewport.schedule();
      }
    }));
    this._register(this._themeService.onDidColorThemeChange(() => {
      this._cancelAll();
      this._tokenizeViewport.schedule();
    }));
  }
  static _getSemanticColoringProvider(model) {
    const result = DocumentRangeSemanticTokensProviderRegistry.ordered(model);
    return result.length > 0 ? result[0] : null;
  }
  _cancelAll() {
    for (const request of this._outstandingRequests) {
      request.cancel();
    }
    this._outstandingRequests = [];
  }
  _removeOutstandingRequest(req) {
    for (let i = 0, len = this._outstandingRequests.length; i < len; i++) {
      if (this._outstandingRequests[i] === req) {
        this._outstandingRequests.splice(i, 1);
        return;
      }
    }
  }
  _tokenizeViewportNow() {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    if (model.hasSemanticTokens()) {
      return;
    }
    if (!isSemanticColoringEnabled(model, this._themeService, this._configurationService)) {
      return;
    }
    const provider = ViewportSemanticTokensContribution2._getSemanticColoringProvider(model);
    if (!provider) {
      return;
    }
    const styling = this._modelService.getSemanticTokensProviderStyling(provider);
    const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
    this._outstandingRequests = this._outstandingRequests.concat(visibleRanges.map((range2) => this._requestRange(model, range2, provider, styling)));
  }
  _requestRange(model, range2, provider, styling) {
    const requestVersionId = model.getVersionId();
    const request = createCancelablePromise((token) => Promise.resolve(provider.provideDocumentRangeSemanticTokens(model, range2, token)));
    request.then((r) => {
      if (!r || model.isDisposed() || model.getVersionId() !== requestVersionId) {
        return;
      }
      model.setPartialSemanticTokens(range2, toMultilineTokens2(r, styling, model.getLanguageIdentifier()));
    }).then(() => this._removeOutstandingRequest(request), () => this._removeOutstandingRequest(request));
    return request;
  }
};
ViewportSemanticTokensContribution.ID = "editor.contrib.viewportSemanticTokens";
ViewportSemanticTokensContribution = __decorate42([
  __param42(1, IModelService),
  __param42(2, IThemeService),
  __param42(3, IConfigurationService)
], ViewportSemanticTokensContribution);
registerEditorContribution(ViewportSemanticTokensContribution.ID, ViewportSemanticTokensContribution);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/wordHighlighter.js
var __decorate43 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param43 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var editorWordHighlight = registerColor("editor.wordHighlightBackground", {dark: "#575757B8", light: "#57575740", hc: null}, localize("wordHighlight", "Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations."), true);
var editorWordHighlightStrong = registerColor("editor.wordHighlightStrongBackground", {dark: "#004972B8", light: "#0e639c40", hc: null}, localize("wordHighlightStrong", "Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations."), true);
var editorWordHighlightBorder = registerColor("editor.wordHighlightBorder", {light: null, dark: null, hc: activeContrastBorder}, localize("wordHighlightBorder", "Border color of a symbol during read-access, like reading a variable."));
var editorWordHighlightStrongBorder = registerColor("editor.wordHighlightStrongBorder", {light: null, dark: null, hc: activeContrastBorder}, localize("wordHighlightStrongBorder", "Border color of a symbol during write-access, like writing to a variable."));
var overviewRulerWordHighlightForeground = registerColor("editorOverviewRuler.wordHighlightForeground", {dark: "#A0A0A0CC", light: "#A0A0A0CC", hc: "#A0A0A0CC"}, localize("overviewRulerWordHighlightForeground", "Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var overviewRulerWordHighlightStrongForeground = registerColor("editorOverviewRuler.wordHighlightStrongForeground", {dark: "#C0A0C0CC", light: "#C0A0C0CC", hc: "#C0A0C0CC"}, localize("overviewRulerWordHighlightStrongForeground", "Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var ctxHasWordHighlights = new RawContextKey("hasWordHighlights", false);
function getOccurrencesAtPosition(model, position, token) {
  const orderedByScore = DocumentHighlightProviderRegistry.ordered(model);
  return first(orderedByScore.map((provider) => () => {
    return Promise.resolve(provider.provideDocumentHighlights(model, position, token)).then(void 0, onUnexpectedExternalError);
  }), isNonEmptyArray);
}
var OccurenceAtPositionRequest = class {
  constructor(model, selection, wordSeparators2) {
    this._wordRange = this._getCurrentWordRange(model, selection);
    this.result = createCancelablePromise((token) => this._compute(model, selection, wordSeparators2, token));
  }
  _getCurrentWordRange(model, selection) {
    const word = model.getWordAtPosition(selection.getPosition());
    if (word) {
      return new Range2(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
    }
    return null;
  }
  isValid(model, selection, decorationIds) {
    const lineNumber = selection.startLineNumber;
    const startColumn = selection.startColumn;
    const endColumn = selection.endColumn;
    const currentWordRange = this._getCurrentWordRange(model, selection);
    let requestIsValid = Boolean(this._wordRange && this._wordRange.equalsRange(currentWordRange));
    for (let i = 0, len = decorationIds.length; !requestIsValid && i < len; i++) {
      let range2 = model.getDecorationRange(decorationIds[i]);
      if (range2 && range2.startLineNumber === lineNumber) {
        if (range2.startColumn <= startColumn && range2.endColumn >= endColumn) {
          requestIsValid = true;
        }
      }
    }
    return requestIsValid;
  }
  cancel() {
    this.result.cancel();
  }
};
var SemanticOccurenceAtPositionRequest = class extends OccurenceAtPositionRequest {
  _compute(model, selection, wordSeparators2, token) {
    return getOccurrencesAtPosition(model, selection.getPosition(), token).then((value) => value || []);
  }
};
var TextualOccurenceAtPositionRequest = class extends OccurenceAtPositionRequest {
  constructor(model, selection, wordSeparators2) {
    super(model, selection, wordSeparators2);
    this._selectionIsEmpty = selection.isEmpty();
  }
  _compute(model, selection, wordSeparators2, token) {
    return timeout(250, token).then(() => {
      if (!selection.isEmpty()) {
        return [];
      }
      const word = model.getWordAtPosition(selection.getPosition());
      if (!word || word.word.length > 1e3) {
        return [];
      }
      const matches = model.findMatches(word.word, true, false, true, wordSeparators2, false);
      return matches.map((m) => {
        return {
          range: m.range,
          kind: DocumentHighlightKind.Text
        };
      });
    });
  }
  isValid(model, selection, decorationIds) {
    const currentSelectionIsEmpty = selection.isEmpty();
    if (this._selectionIsEmpty !== currentSelectionIsEmpty) {
      return false;
    }
    return super.isValid(model, selection, decorationIds);
  }
};
function computeOccurencesAtPosition(model, selection, wordSeparators2) {
  if (DocumentHighlightProviderRegistry.has(model)) {
    return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators2);
  }
  return new TextualOccurenceAtPositionRequest(model, selection, wordSeparators2);
}
registerModelAndPositionCommand("_executeDocumentHighlights", (model, position) => getOccurrencesAtPosition(model, position, CancellationToken.None));
var WordHighlighter = class {
  constructor(editor3, contextKeyService) {
    this.toUnhook = new DisposableStore();
    this.workerRequestTokenId = 0;
    this.workerRequestCompleted = false;
    this.workerRequestValue = [];
    this.lastCursorPositionChangeTime = 0;
    this.renderDecorationsTimer = -1;
    this.editor = editor3;
    this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);
    this._ignorePositionChangeEvent = false;
    this.occurrencesHighlight = this.editor.getOption(63);
    this.model = this.editor.getModel();
    this.toUnhook.add(editor3.onDidChangeCursorPosition((e) => {
      if (this._ignorePositionChangeEvent) {
        return;
      }
      if (!this.occurrencesHighlight) {
        return;
      }
      this._onPositionChanged(e);
    }));
    this.toUnhook.add(editor3.onDidChangeModelContent((e) => {
      this._stopAll();
    }));
    this.toUnhook.add(editor3.onDidChangeConfiguration((e) => {
      let newValue = this.editor.getOption(63);
      if (this.occurrencesHighlight !== newValue) {
        this.occurrencesHighlight = newValue;
        this._stopAll();
      }
    }));
    this._decorationIds = [];
    this.workerRequestTokenId = 0;
    this.workerRequest = null;
    this.workerRequestCompleted = false;
    this.lastCursorPositionChangeTime = 0;
    this.renderDecorationsTimer = -1;
  }
  hasDecorations() {
    return this._decorationIds.length > 0;
  }
  restore() {
    if (!this.occurrencesHighlight) {
      return;
    }
    this._run();
  }
  _getSortedHighlights() {
    return coalesce(this._decorationIds.map((id) => this.model.getDecorationRange(id)).sort(Range2.compareRangesUsingStarts));
  }
  moveNext() {
    let highlights = this._getSortedHighlights();
    let index2 = firstIndex(highlights, (range2) => range2.containsPosition(this.editor.getPosition()));
    let newIndex = (index2 + 1) % highlights.length;
    let dest = highlights[newIndex];
    try {
      this._ignorePositionChangeEvent = true;
      this.editor.setPosition(dest.getStartPosition());
      this.editor.revealRangeInCenterIfOutsideViewport(dest);
      const word = this._getWord();
      if (word) {
        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = false;
    }
  }
  moveBack() {
    let highlights = this._getSortedHighlights();
    let index2 = firstIndex(highlights, (range2) => range2.containsPosition(this.editor.getPosition()));
    let newIndex = (index2 - 1 + highlights.length) % highlights.length;
    let dest = highlights[newIndex];
    try {
      this._ignorePositionChangeEvent = true;
      this.editor.setPosition(dest.getStartPosition());
      this.editor.revealRangeInCenterIfOutsideViewport(dest);
      const word = this._getWord();
      if (word) {
        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = false;
    }
  }
  _removeDecorations() {
    if (this._decorationIds.length > 0) {
      this._decorationIds = this.editor.deltaDecorations(this._decorationIds, []);
      this._hasWordHighlights.set(false);
    }
  }
  _stopAll() {
    this._removeDecorations();
    if (this.renderDecorationsTimer !== -1) {
      clearTimeout(this.renderDecorationsTimer);
      this.renderDecorationsTimer = -1;
    }
    if (this.workerRequest !== null) {
      this.workerRequest.cancel();
      this.workerRequest = null;
    }
    if (!this.workerRequestCompleted) {
      this.workerRequestTokenId++;
      this.workerRequestCompleted = true;
    }
  }
  _onPositionChanged(e) {
    if (!this.occurrencesHighlight) {
      this._stopAll();
      return;
    }
    if (e.reason !== 3) {
      this._stopAll();
      return;
    }
    this._run();
  }
  _getWord() {
    let editorSelection = this.editor.getSelection();
    let lineNumber = editorSelection.startLineNumber;
    let startColumn = editorSelection.startColumn;
    return this.model.getWordAtPosition({
      lineNumber,
      column: startColumn
    });
  }
  _run() {
    let editorSelection = this.editor.getSelection();
    if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {
      this._stopAll();
      return;
    }
    let startColumn = editorSelection.startColumn;
    let endColumn = editorSelection.endColumn;
    const word = this._getWord();
    if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {
      this._stopAll();
      return;
    }
    const workerRequestIsValid = this.workerRequest && this.workerRequest.isValid(this.model, editorSelection, this._decorationIds);
    this.lastCursorPositionChangeTime = new Date().getTime();
    if (workerRequestIsValid) {
      if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {
        clearTimeout(this.renderDecorationsTimer);
        this.renderDecorationsTimer = -1;
        this._beginRenderDecorations();
      }
    } else {
      this._stopAll();
      let myRequestId = ++this.workerRequestTokenId;
      this.workerRequestCompleted = false;
      this.workerRequest = computeOccurencesAtPosition(this.model, this.editor.getSelection(), this.editor.getOption(105));
      this.workerRequest.result.then((data) => {
        if (myRequestId === this.workerRequestTokenId) {
          this.workerRequestCompleted = true;
          this.workerRequestValue = data || [];
          this._beginRenderDecorations();
        }
      }, onUnexpectedError);
    }
  }
  _beginRenderDecorations() {
    let currentTime = new Date().getTime();
    let minimumRenderTime = this.lastCursorPositionChangeTime + 250;
    if (currentTime >= minimumRenderTime) {
      this.renderDecorationsTimer = -1;
      this.renderDecorations();
    } else {
      this.renderDecorationsTimer = setTimeout(() => {
        this.renderDecorations();
      }, minimumRenderTime - currentTime);
    }
  }
  renderDecorations() {
    this.renderDecorationsTimer = -1;
    let decorations = [];
    for (const info of this.workerRequestValue) {
      if (info.range) {
        decorations.push({
          range: info.range,
          options: WordHighlighter._getDecorationOptions(info.kind)
        });
      }
    }
    this._decorationIds = this.editor.deltaDecorations(this._decorationIds, decorations);
    this._hasWordHighlights.set(this.hasDecorations());
  }
  static _getDecorationOptions(kind) {
    if (kind === DocumentHighlightKind.Write) {
      return this._WRITE_OPTIONS;
    } else if (kind === DocumentHighlightKind.Text) {
      return this._TEXT_OPTIONS;
    } else {
      return this._REGULAR_OPTIONS;
    }
  }
  dispose() {
    this._stopAll();
    this.toUnhook.dispose();
  }
};
WordHighlighter._WRITE_OPTIONS = ModelDecorationOptions.register({
  stickiness: 1,
  className: "wordHighlightStrong",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightStrongForeground),
    position: OverviewRulerLane.Center
  }
});
WordHighlighter._TEXT_OPTIONS = ModelDecorationOptions.register({
  stickiness: 1,
  className: "selectionHighlight",
  overviewRuler: {
    color: themeColorFromId(overviewRulerSelectionHighlightForeground),
    position: OverviewRulerLane.Center
  }
});
WordHighlighter._REGULAR_OPTIONS = ModelDecorationOptions.register({
  stickiness: 1,
  className: "wordHighlight",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightForeground),
    position: OverviewRulerLane.Center
  }
});
var WordHighlighterContribution = class WordHighlighterContribution2 extends Disposable {
  constructor(editor3, contextKeyService) {
    super();
    this.wordHighlighter = null;
    const createWordHighlighterIfPossible = () => {
      if (editor3.hasModel()) {
        this.wordHighlighter = new WordHighlighter(editor3, contextKeyService);
      }
    };
    this._register(editor3.onDidChangeModel((e) => {
      if (this.wordHighlighter) {
        this.wordHighlighter.dispose();
        this.wordHighlighter = null;
      }
      createWordHighlighterIfPossible();
    }));
    createWordHighlighterIfPossible();
  }
  static get(editor3) {
    return editor3.getContribution(WordHighlighterContribution2.ID);
  }
  saveViewState() {
    if (this.wordHighlighter && this.wordHighlighter.hasDecorations()) {
      return true;
    }
    return false;
  }
  moveNext() {
    if (this.wordHighlighter) {
      this.wordHighlighter.moveNext();
    }
  }
  moveBack() {
    if (this.wordHighlighter) {
      this.wordHighlighter.moveBack();
    }
  }
  restoreViewState(state) {
    if (this.wordHighlighter && state) {
      this.wordHighlighter.restore();
    }
  }
  dispose() {
    if (this.wordHighlighter) {
      this.wordHighlighter.dispose();
      this.wordHighlighter = null;
    }
    super.dispose();
  }
};
WordHighlighterContribution.ID = "editor.contrib.wordHighlighter";
WordHighlighterContribution = __decorate43([
  __param43(1, IContextKeyService)
], WordHighlighterContribution);
var WordHighlightNavigationAction = class extends EditorAction {
  constructor(next, opts) {
    super(opts);
    this._isNext = next;
  }
  run(accessor, editor3) {
    const controller = WordHighlighterContribution.get(editor3);
    if (!controller) {
      return;
    }
    if (this._isNext) {
      controller.moveNext();
    } else {
      controller.moveBack();
    }
  }
};
var NextWordHighlightAction = class extends WordHighlightNavigationAction {
  constructor() {
    super(true, {
      id: "editor.action.wordHighlight.next",
      label: localize("wordHighlight.next.label", "Go to Next Symbol Highlight"),
      alias: "Go to Next Symbol Highlight",
      precondition: ctxHasWordHighlights,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 65,
        weight: 100
      }
    });
  }
};
var PrevWordHighlightAction = class extends WordHighlightNavigationAction {
  constructor() {
    super(false, {
      id: "editor.action.wordHighlight.prev",
      label: localize("wordHighlight.previous.label", "Go to Previous Symbol Highlight"),
      alias: "Go to Previous Symbol Highlight",
      precondition: ctxHasWordHighlights,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 65,
        weight: 100
      }
    });
  }
};
var TriggerWordHighlightAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.wordHighlight.trigger",
      label: localize("wordHighlight.trigger.label", "Trigger Symbol Highlight"),
      alias: "Trigger Symbol Highlight",
      precondition: ctxHasWordHighlights.toNegated(),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        weight: 100
      }
    });
  }
  run(accessor, editor3, args) {
    const controller = WordHighlighterContribution.get(editor3);
    if (!controller) {
      return;
    }
    controller.restoreViewState(true);
  }
};
registerEditorContribution(WordHighlighterContribution.ID, WordHighlighterContribution);
registerEditorAction(NextWordHighlightAction);
registerEditorAction(PrevWordHighlightAction);
registerEditorAction(TriggerWordHighlightAction);
registerThemingParticipant((theme6, collector) => {
  const selectionHighlight = theme6.getColor(editorSelectionHighlight);
  if (selectionHighlight) {
    collector.addRule(`.monaco-editor .focused .selectionHighlight { background-color: ${selectionHighlight}; }`);
    collector.addRule(`.monaco-editor .selectionHighlight { background-color: ${selectionHighlight.transparent(0.5)}; }`);
  }
  const wordHighlight = theme6.getColor(editorWordHighlight);
  if (wordHighlight) {
    collector.addRule(`.monaco-editor .wordHighlight { background-color: ${wordHighlight}; }`);
  }
  const wordHighlightStrong = theme6.getColor(editorWordHighlightStrong);
  if (wordHighlightStrong) {
    collector.addRule(`.monaco-editor .wordHighlightStrong { background-color: ${wordHighlightStrong}; }`);
  }
  const selectionHighlightBorder = theme6.getColor(editorSelectionHighlightBorder);
  if (selectionHighlightBorder) {
    collector.addRule(`.monaco-editor .selectionHighlight { border: 1px ${theme6.type === "hc" ? "dotted" : "solid"} ${selectionHighlightBorder}; box-sizing: border-box; }`);
  }
  const wordHighlightBorder = theme6.getColor(editorWordHighlightBorder);
  if (wordHighlightBorder) {
    collector.addRule(`.monaco-editor .wordHighlight { border: 1px ${theme6.type === "hc" ? "dashed" : "solid"} ${wordHighlightBorder}; box-sizing: border-box; }`);
  }
  const wordHighlightStrongBorder = theme6.getColor(editorWordHighlightStrongBorder);
  if (wordHighlightStrongBorder) {
    collector.addRule(`.monaco-editor .wordHighlightStrong { border: 1px ${theme6.type === "hc" ? "dashed" : "solid"} ${wordHighlightStrongBorder}; box-sizing: border-box; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/wordOperations/wordOperations.js
var MoveWordCommand = class extends EditorCommand {
  constructor(opts) {
    super(opts);
    this._inSelectionMode = opts.inSelectionMode;
    this._wordNavigationType = opts.wordNavigationType;
  }
  runEditorCommand(accessor, editor3, args) {
    if (!editor3.hasModel()) {
      return;
    }
    const wordSeparators2 = getMapForWordSeparators(editor3.getOption(105));
    const model = editor3.getModel();
    const selections = editor3.getSelections();
    const result = selections.map((sel) => {
      const inPosition = new Position(sel.positionLineNumber, sel.positionColumn);
      const outPosition = this._move(wordSeparators2, model, inPosition, this._wordNavigationType);
      return this._moveTo(sel, outPosition, this._inSelectionMode);
    });
    model.pushStackElement();
    editor3._getViewModel().setCursorStates("moveWordCommand", 0, result.map((r) => CursorState.fromModelSelection(r)));
    if (result.length === 1) {
      const pos = new Position(result[0].positionLineNumber, result[0].positionColumn);
      editor3.revealPosition(pos, 0);
    }
  }
  _moveTo(from2, to, inSelectionMode) {
    if (inSelectionMode) {
      return new Selection(from2.selectionStartLineNumber, from2.selectionStartColumn, to.lineNumber, to.column);
    } else {
      return new Selection(to.lineNumber, to.column, to.lineNumber, to.column);
    }
  }
};
var WordLeftCommand = class extends MoveWordCommand {
  _move(wordSeparators2, model, position, wordNavigationType) {
    return WordOperations.moveWordLeft(wordSeparators2, model, position, wordNavigationType);
  }
};
var WordRightCommand = class extends MoveWordCommand {
  _move(wordSeparators2, model, position, wordNavigationType) {
    return WordOperations.moveWordRight(wordSeparators2, model, position, wordNavigationType);
  }
};
var CursorWordStartLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordStartLeft",
      precondition: void 0
    });
  }
};
var CursorWordEndLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordEndLeft",
      precondition: void 0
    });
  }
};
var CursorWordLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 1,
      id: "cursorWordLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 15,
        mac: {primary: 512 | 15},
        weight: 100
      }
    });
  }
};
var CursorWordStartLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordStartLeftSelect",
      precondition: void 0
    });
  }
};
var CursorWordEndLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordEndLeftSelect",
      precondition: void 0
    });
  }
};
var CursorWordLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 1,
      id: "cursorWordLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1024 | 15,
        mac: {primary: 512 | 1024 | 15},
        weight: 100
      }
    });
  }
};
var CursorWordAccessibilityLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, CONTEXT_ACCESSIBILITY_MODE_ENABLED),
        win: {primary: 2048 | 15},
        weight: 100 + 1
      }
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
var CursorWordAccessibilityLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, CONTEXT_ACCESSIBILITY_MODE_ENABLED),
        win: {primary: 2048 | 1024 | 15},
        weight: 100 + 1
      }
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
var CursorWordStartRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordStartRight",
      precondition: void 0
    });
  }
};
var CursorWordEndRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordEndRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 17,
        mac: {primary: 512 | 17},
        weight: 100
      }
    });
  }
};
var CursorWordRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordRight",
      precondition: void 0
    });
  }
};
var CursorWordStartRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordStartRightSelect",
      precondition: void 0
    });
  }
};
var CursorWordEndRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordEndRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1024 | 17,
        mac: {primary: 512 | 1024 | 17},
        weight: 100
      }
    });
  }
};
var CursorWordRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordRightSelect",
      precondition: void 0
    });
  }
};
var CursorWordAccessibilityRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, CONTEXT_ACCESSIBILITY_MODE_ENABLED),
        win: {primary: 2048 | 17},
        weight: 100 + 1
      }
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
var CursorWordAccessibilityRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, CONTEXT_ACCESSIBILITY_MODE_ENABLED),
        win: {primary: 2048 | 1024 | 17},
        weight: 100 + 1
      }
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
var DeleteWordCommand = class extends EditorCommand {
  constructor(opts) {
    super(opts);
    this._whitespaceHeuristics = opts.whitespaceHeuristics;
    this._wordNavigationType = opts.wordNavigationType;
  }
  runEditorCommand(accessor, editor3, args) {
    if (!editor3.hasModel()) {
      return;
    }
    const wordSeparators2 = getMapForWordSeparators(editor3.getOption(105));
    const model = editor3.getModel();
    const selections = editor3.getSelections();
    const commands = selections.map((sel) => {
      const deleteRange = this._delete(wordSeparators2, model, sel, this._whitespaceHeuristics, this._wordNavigationType);
      return new ReplaceCommand(deleteRange, "");
    });
    editor3.pushUndoStop();
    editor3.executeCommands(this.id, commands);
    editor3.pushUndoStop();
  }
};
var DeleteWordLeftCommand = class extends DeleteWordCommand {
  _delete(wordSeparators2, model, selection, whitespaceHeuristics, wordNavigationType) {
    let r = WordOperations.deleteWordLeft(wordSeparators2, model, selection, whitespaceHeuristics, wordNavigationType);
    if (r) {
      return r;
    }
    return new Range2(1, 1, 1, 1);
  }
};
var DeleteWordRightCommand = class extends DeleteWordCommand {
  _delete(wordSeparators2, model, selection, whitespaceHeuristics, wordNavigationType) {
    let r = WordOperations.deleteWordRight(wordSeparators2, model, selection, whitespaceHeuristics, wordNavigationType);
    if (r) {
      return r;
    }
    const lineCount = model.getLineCount();
    const maxColumn = model.getLineMaxColumn(lineCount);
    return new Range2(lineCount, maxColumn, lineCount, maxColumn);
  }
};
var DeleteWordStartLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 0,
      id: "deleteWordStartLeft",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordEndLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 2,
      id: "deleteWordEndLeft",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 0,
      id: "deleteWordLeft",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1,
        mac: {primary: 512 | 1},
        weight: 100
      }
    });
  }
};
var DeleteWordStartRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 0,
      id: "deleteWordStartRight",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordEndRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 2,
      id: "deleteWordEndRight",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 2,
      id: "deleteWordRight",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 20,
        mac: {primary: 512 | 20},
        weight: 100
      }
    });
  }
};
registerEditorCommand(new CursorWordStartLeft());
registerEditorCommand(new CursorWordEndLeft());
registerEditorCommand(new CursorWordLeft());
registerEditorCommand(new CursorWordStartLeftSelect());
registerEditorCommand(new CursorWordEndLeftSelect());
registerEditorCommand(new CursorWordLeftSelect());
registerEditorCommand(new CursorWordStartRight());
registerEditorCommand(new CursorWordEndRight());
registerEditorCommand(new CursorWordRight());
registerEditorCommand(new CursorWordStartRightSelect());
registerEditorCommand(new CursorWordEndRightSelect());
registerEditorCommand(new CursorWordRightSelect());
registerEditorCommand(new CursorWordAccessibilityLeft());
registerEditorCommand(new CursorWordAccessibilityLeftSelect());
registerEditorCommand(new CursorWordAccessibilityRight());
registerEditorCommand(new CursorWordAccessibilityRightSelect());
registerEditorCommand(new DeleteWordStartLeft());
registerEditorCommand(new DeleteWordEndLeft());
registerEditorCommand(new DeleteWordLeft());
registerEditorCommand(new DeleteWordStartRight());
registerEditorCommand(new DeleteWordEndRight());
registerEditorCommand(new DeleteWordRight());

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/wordPartOperations/wordPartOperations.js
var DeleteWordPartLeft = class extends DeleteWordCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 0,
      id: "deleteWordPartLeft",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {primary: 256 | 512 | 1},
        weight: 100
      }
    });
  }
  _delete(wordSeparators2, model, selection, whitespaceHeuristics, wordNavigationType) {
    let r = WordPartOperations.deleteWordPartLeft(wordSeparators2, model, selection, whitespaceHeuristics);
    if (r) {
      return r;
    }
    return new Range2(1, 1, 1, 1);
  }
};
var DeleteWordPartRight = class extends DeleteWordCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 2,
      id: "deleteWordPartRight",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {primary: 256 | 512 | 20},
        weight: 100
      }
    });
  }
  _delete(wordSeparators2, model, selection, whitespaceHeuristics, wordNavigationType) {
    let r = WordPartOperations.deleteWordPartRight(wordSeparators2, model, selection, whitespaceHeuristics);
    if (r) {
      return r;
    }
    const lineCount = model.getLineCount();
    const maxColumn = model.getLineMaxColumn(lineCount);
    return new Range2(lineCount, maxColumn, lineCount, maxColumn);
  }
};
var WordPartLeftCommand = class extends MoveWordCommand {
  _move(wordSeparators2, model, position, wordNavigationType) {
    return WordPartOperations.moveWordPartLeft(wordSeparators2, model, position);
  }
};
var CursorWordPartLeft = class extends WordPartLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordPartLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {primary: 256 | 512 | 15},
        weight: 100
      }
    });
  }
};
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeft", "cursorWordPartLeft");
var CursorWordPartLeftSelect = class extends WordPartLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordPartLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {primary: 256 | 512 | 1024 | 15},
        weight: 100
      }
    });
  }
};
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeftSelect", "cursorWordPartLeftSelect");
var WordPartRightCommand = class extends MoveWordCommand {
  _move(wordSeparators2, model, position, wordNavigationType) {
    return WordPartOperations.moveWordPartRight(wordSeparators2, model, position);
  }
};
var CursorWordPartRight = class extends WordPartRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordPartRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {primary: 256 | 512 | 17},
        weight: 100
      }
    });
  }
};
var CursorWordPartRightSelect = class extends WordPartRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordPartRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {primary: 256 | 512 | 1024 | 17},
        weight: 100
      }
    });
  }
};
registerEditorCommand(new DeleteWordPartLeft());
registerEditorCommand(new DeleteWordPartRight());
registerEditorCommand(new CursorWordPartLeft());
registerEditorCommand(new CursorWordPartLeftSelect());
registerEditorCommand(new CursorWordPartRight());
registerEditorCommand(new CursorWordPartRightSelect());

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp.js
var __decorate44 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param44 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE = new RawContextKey("accessibilityHelpWidgetVisible", false);
var AccessibilityHelpController = class AccessibilityHelpController2 extends Disposable {
  constructor(editor3, instantiationService) {
    super();
    this._editor = editor3;
    this._widget = this._register(instantiationService.createInstance(AccessibilityHelpWidget, this._editor));
  }
  static get(editor3) {
    return editor3.getContribution(AccessibilityHelpController2.ID);
  }
  show() {
    this._widget.show();
  }
  hide() {
    this._widget.hide();
  }
};
AccessibilityHelpController.ID = "editor.contrib.accessibilityHelpController";
AccessibilityHelpController = __decorate44([
  __param44(1, IInstantiationService)
], AccessibilityHelpController);
function getSelectionLabel(selections, charactersSelected) {
  if (!selections || selections.length === 0) {
    return AccessibilityHelpNLS.noSelection;
  }
  if (selections.length === 1) {
    if (charactersSelected) {
      return format(AccessibilityHelpNLS.singleSelectionRange, selections[0].positionLineNumber, selections[0].positionColumn, charactersSelected);
    }
    return format(AccessibilityHelpNLS.singleSelection, selections[0].positionLineNumber, selections[0].positionColumn);
  }
  if (charactersSelected) {
    return format(AccessibilityHelpNLS.multiSelectionRange, selections.length, charactersSelected);
  }
  if (selections.length > 0) {
    return format(AccessibilityHelpNLS.multiSelection, selections.length);
  }
  return "";
}
var AccessibilityHelpWidget = class AccessibilityHelpWidget2 extends Widget {
  constructor(editor3, _contextKeyService, _keybindingService, _openerService) {
    super();
    this._contextKeyService = _contextKeyService;
    this._keybindingService = _keybindingService;
    this._openerService = _openerService;
    this._editor = editor3;
    this._isVisibleKey = CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE.bindTo(this._contextKeyService);
    this._domNode = createFastDomNode(document.createElement("div"));
    this._domNode.setClassName("accessibilityHelpWidget");
    this._domNode.setDisplay("none");
    this._domNode.setAttribute("role", "dialog");
    this._domNode.setAttribute("aria-hidden", "true");
    this._contentDomNode = createFastDomNode(document.createElement("div"));
    this._contentDomNode.setAttribute("role", "document");
    this._domNode.appendChild(this._contentDomNode);
    this._isVisible = false;
    this._register(this._editor.onDidLayoutChange(() => {
      if (this._isVisible) {
        this._layout();
      }
    }));
    this._register(addStandardDisposableListener(this._contentDomNode.domNode, "keydown", (e) => {
      if (!this._isVisible) {
        return;
      }
      if (e.equals(2048 | 35)) {
        alert(AccessibilityHelpNLS.emergencyConfOn);
        this._editor.updateOptions({
          accessibilitySupport: "on"
        });
        clearNode(this._contentDomNode.domNode);
        this._buildContent();
        this._contentDomNode.domNode.focus();
        e.preventDefault();
        e.stopPropagation();
      }
      if (e.equals(2048 | 38)) {
        alert(AccessibilityHelpNLS.openingDocs);
        let url = this._editor.getRawOptions().accessibilityHelpUrl;
        if (typeof url === "undefined") {
          url = "https://go.microsoft.com/fwlink/?linkid=852450";
        }
        this._openerService.open(URI.parse(url));
        e.preventDefault();
        e.stopPropagation();
      }
    }));
    this.onblur(this._contentDomNode.domNode, () => {
      this.hide();
    });
    this._editor.addOverlayWidget(this);
  }
  dispose() {
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  getId() {
    return AccessibilityHelpWidget2.ID;
  }
  getDomNode() {
    return this._domNode.domNode;
  }
  getPosition() {
    return {
      preference: null
    };
  }
  show() {
    if (this._isVisible) {
      return;
    }
    this._isVisible = true;
    this._isVisibleKey.set(true);
    this._layout();
    this._domNode.setDisplay("block");
    this._domNode.setAttribute("aria-hidden", "false");
    this._contentDomNode.domNode.tabIndex = 0;
    this._buildContent();
    this._contentDomNode.domNode.focus();
  }
  _descriptionForCommand(commandId, msg, noKbMsg) {
    let kb = this._keybindingService.lookupKeybinding(commandId);
    if (kb) {
      return format(msg, kb.getAriaLabel());
    }
    return format(noKbMsg, commandId);
  }
  _buildContent() {
    const options = this._editor.getOptions();
    const selections = this._editor.getSelections();
    let charactersSelected = 0;
    if (selections) {
      const model = this._editor.getModel();
      if (model) {
        selections.forEach((selection) => {
          charactersSelected += model.getValueLengthInRange(selection);
        });
      }
    }
    let text = getSelectionLabel(selections, charactersSelected);
    if (options.get(47)) {
      if (options.get(72)) {
        text += AccessibilityHelpNLS.readonlyDiffEditor;
      } else {
        text += AccessibilityHelpNLS.editableDiffEditor;
      }
    } else {
      if (options.get(72)) {
        text += AccessibilityHelpNLS.readonlyEditor;
      } else {
        text += AccessibilityHelpNLS.editableEditor;
      }
    }
    const turnOnMessage = isMacintosh ? AccessibilityHelpNLS.changeConfigToOnMac : AccessibilityHelpNLS.changeConfigToOnWinLinux;
    switch (options.get(2)) {
      case 0:
        text += "\n\n - " + turnOnMessage;
        break;
      case 2:
        text += "\n\n - " + AccessibilityHelpNLS.auto_on;
        break;
      case 1:
        text += "\n\n - " + AccessibilityHelpNLS.auto_off;
        text += " " + turnOnMessage;
        break;
    }
    if (options.get(116)) {
      text += "\n\n - " + this._descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOnMsg, AccessibilityHelpNLS.tabFocusModeOnMsgNoKb);
    } else {
      text += "\n\n - " + this._descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOffMsg, AccessibilityHelpNLS.tabFocusModeOffMsgNoKb);
    }
    const openDocMessage = isMacintosh ? AccessibilityHelpNLS.openDocMac : AccessibilityHelpNLS.openDocWinLinux;
    text += "\n\n - " + openDocMessage;
    text += "\n\n" + AccessibilityHelpNLS.outroMsg;
    this._contentDomNode.domNode.appendChild(renderFormattedText(text));
    this._contentDomNode.domNode.setAttribute("aria-label", text);
  }
  hide() {
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    this._isVisibleKey.reset();
    this._domNode.setDisplay("none");
    this._domNode.setAttribute("aria-hidden", "true");
    this._contentDomNode.domNode.tabIndex = -1;
    clearNode(this._contentDomNode.domNode);
    this._editor.focus();
  }
  _layout() {
    let editorLayout = this._editor.getLayoutInfo();
    let w = Math.max(5, Math.min(AccessibilityHelpWidget2.WIDTH, editorLayout.width - 40));
    let h = Math.max(5, Math.min(AccessibilityHelpWidget2.HEIGHT, editorLayout.height - 40));
    this._domNode.setWidth(w);
    this._domNode.setHeight(h);
    let top = Math.round((editorLayout.height - h) / 2);
    this._domNode.setTop(top);
    let left = Math.round((editorLayout.width - w) / 2);
    this._domNode.setLeft(left);
  }
};
AccessibilityHelpWidget.ID = "editor.contrib.accessibilityHelpWidget";
AccessibilityHelpWidget.WIDTH = 500;
AccessibilityHelpWidget.HEIGHT = 300;
AccessibilityHelpWidget = __decorate44([
  __param44(1, IContextKeyService),
  __param44(2, IKeybindingService),
  __param44(3, IOpenerService)
], AccessibilityHelpWidget);
var ShowAccessibilityHelpAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showAccessibilityHelp",
      label: AccessibilityHelpNLS.showAccessibilityHelpAction,
      alias: "Show Accessibility Help",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 512 | 59,
        weight: 100,
        linux: {
          primary: 512 | 1024 | 59,
          secondary: [512 | 59]
        }
      }
    });
  }
  run(accessor, editor3) {
    let controller = AccessibilityHelpController.get(editor3);
    if (controller) {
      controller.show();
    }
  }
};
registerEditorContribution(AccessibilityHelpController.ID, AccessibilityHelpController);
registerEditorAction(ShowAccessibilityHelpAction);
var AccessibilityHelpCommand = EditorCommand.bindToContribution(AccessibilityHelpController.get);
registerEditorCommand(new AccessibilityHelpCommand({
  id: "closeAccessibilityHelp",
  precondition: CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE,
  handler: (x) => x.hide(),
  kbOpts: {
    weight: 100 + 100,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerThemingParticipant((theme6, collector) => {
  const widgetBackground = theme6.getColor(editorWidgetBackground);
  if (widgetBackground) {
    collector.addRule(`.monaco-editor .accessibilityHelpWidget { background-color: ${widgetBackground}; }`);
  }
  const widgetForeground = theme6.getColor(editorWidgetForeground);
  if (widgetForeground) {
    collector.addRule(`.monaco-editor .accessibilityHelpWidget { color: ${widgetForeground}; }`);
  }
  const widgetShadowColor = theme6.getColor(widgetShadow);
  if (widgetShadowColor) {
    collector.addRule(`.monaco-editor .accessibilityHelpWidget { box-shadow: 0 2px 8px ${widgetShadowColor}; }`);
  }
  const hcBorder = theme6.getColor(contrastBorder);
  if (hcBorder) {
    collector.addRule(`.monaco-editor .accessibilityHelpWidget { border: 2px solid ${hcBorder}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard.js
var IPadShowKeyboard = class extends Disposable {
  constructor(editor3) {
    super();
    this.editor = editor3;
    this.widget = null;
    if (isIPad) {
      this._register(editor3.onDidChangeConfiguration(() => this.update()));
      this.update();
    }
  }
  update() {
    const shouldHaveWidget = !this.editor.getOption(72);
    if (!this.widget && shouldHaveWidget) {
      this.widget = new ShowKeyboardWidget(this.editor);
    } else if (this.widget && !shouldHaveWidget) {
      this.widget.dispose();
      this.widget = null;
    }
  }
  dispose() {
    super.dispose();
    if (this.widget) {
      this.widget.dispose();
      this.widget = null;
    }
  }
};
IPadShowKeyboard.ID = "editor.contrib.iPadShowKeyboard";
var ShowKeyboardWidget = class extends Disposable {
  constructor(editor3) {
    super();
    this.editor = editor3;
    this._domNode = document.createElement("textarea");
    this._domNode.className = "iPadShowKeyboard";
    this._register(addDisposableListener(this._domNode, "touchstart", (e) => {
      this.editor.focus();
    }));
    this._register(addDisposableListener(this._domNode, "focus", (e) => {
      this.editor.focus();
    }));
    this.editor.addOverlayWidget(this);
  }
  dispose() {
    this.editor.removeOverlayWidget(this);
    super.dispose();
  }
  getId() {
    return ShowKeyboardWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 1
    };
  }
};
ShowKeyboardWidget.ID = "editor.contrib.ShowKeyboardWidget";
registerEditorContribution(IPadShowKeyboard.ID, IPadShowKeyboard);

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/inspectTokens/inspectTokens.js
var __decorate45 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param45 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InspectTokensController = class InspectTokensController2 extends Disposable {
  constructor(editor3, standaloneColorService, modeService) {
    super();
    this._editor = editor3;
    this._modeService = modeService;
    this._widget = null;
    this._register(this._editor.onDidChangeModel((e) => this.stop()));
    this._register(this._editor.onDidChangeModelLanguage((e) => this.stop()));
    this._register(TokenizationRegistry.onDidChange((e) => this.stop()));
    this._register(this._editor.onKeyUp((e) => e.keyCode === 9 && this.stop()));
  }
  static get(editor3) {
    return editor3.getContribution(InspectTokensController2.ID);
  }
  dispose() {
    this.stop();
    super.dispose();
  }
  launch() {
    if (this._widget) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    this._widget = new InspectTokensWidget(this._editor, this._modeService);
  }
  stop() {
    if (this._widget) {
      this._widget.dispose();
      this._widget = null;
    }
  }
};
InspectTokensController.ID = "editor.contrib.inspectTokens";
InspectTokensController = __decorate45([
  __param45(1, IStandaloneThemeService),
  __param45(2, IModeService)
], InspectTokensController);
var InspectTokens = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inspectTokens",
      label: InspectTokensNLS.inspectTokensAction,
      alias: "Developer: Inspect Tokens",
      precondition: void 0
    });
  }
  run(accessor, editor3) {
    let controller = InspectTokensController.get(editor3);
    if (controller) {
      controller.launch();
    }
  }
};
function renderTokenText(tokenText) {
  let result = "";
  for (let charIndex = 0, len = tokenText.length; charIndex < len; charIndex++) {
    let charCode = tokenText.charCodeAt(charIndex);
    switch (charCode) {
      case 9:
        result += "\u2192";
        break;
      case 32:
        result += "\xB7";
        break;
      default:
        result += String.fromCharCode(charCode);
    }
  }
  return result;
}
function getSafeTokenizationSupport(languageIdentifier) {
  let tokenizationSupport = TokenizationRegistry.get(languageIdentifier.language);
  if (tokenizationSupport) {
    return tokenizationSupport;
  }
  return {
    getInitialState: () => NULL_STATE,
    tokenize: (line, state, deltaOffset) => nullTokenize(languageIdentifier.language, line, state, deltaOffset),
    tokenize2: (line, state, deltaOffset) => nullTokenize2(languageIdentifier.id, line, state, deltaOffset)
  };
}
var InspectTokensWidget = class extends Disposable {
  constructor(editor3, modeService) {
    super();
    this.allowEditorOverflow = true;
    this._editor = editor3;
    this._modeService = modeService;
    this._model = this._editor.getModel();
    this._domNode = document.createElement("div");
    this._domNode.className = "tokens-inspect-widget";
    this._tokenizationSupport = getSafeTokenizationSupport(this._model.getLanguageIdentifier());
    this._compute(this._editor.getPosition());
    this._register(this._editor.onDidChangeCursorPosition((e) => this._compute(this._editor.getPosition())));
    this._editor.addContentWidget(this);
  }
  dispose() {
    this._editor.removeContentWidget(this);
    super.dispose();
  }
  getId() {
    return InspectTokensWidget._ID;
  }
  _compute(position) {
    let data = this._getTokensAtLine(position.lineNumber);
    let token1Index = 0;
    for (let i = data.tokens1.length - 1; i >= 0; i--) {
      let t = data.tokens1[i];
      if (position.column - 1 >= t.offset) {
        token1Index = i;
        break;
      }
    }
    let token2Index = 0;
    for (let i = data.tokens2.length >>> 1; i >= 0; i--) {
      if (position.column - 1 >= data.tokens2[i << 1]) {
        token2Index = i;
        break;
      }
    }
    let lineContent = this._model.getLineContent(position.lineNumber);
    let tokenText = "";
    if (token1Index < data.tokens1.length) {
      let tokenStartIndex = data.tokens1[token1Index].offset;
      let tokenEndIndex = token1Index + 1 < data.tokens1.length ? data.tokens1[token1Index + 1].offset : lineContent.length;
      tokenText = lineContent.substring(tokenStartIndex, tokenEndIndex);
    }
    reset(this._domNode, $("h2.tm-token", void 0, renderTokenText(tokenText), $("span.tm-token-length", void 0, `${tokenText.length} ${tokenText.length === 1 ? "char" : "chars"}`)));
    append(this._domNode, $("hr.tokens-inspect-separator", {style: "clear:both"}));
    const metadata = (token2Index << 1) + 1 < data.tokens2.length ? this._decodeMetadata(data.tokens2[(token2Index << 1) + 1]) : null;
    append(this._domNode, $("table.tm-metadata-table", void 0, $("tbody", void 0, $("tr", void 0, $("td.tm-metadata-key", void 0, "language"), $("td.tm-metadata-value", void 0, `${metadata ? metadata.languageIdentifier.language : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "token type"), $("td.tm-metadata-value", void 0, `${metadata ? this._tokenTypeToString(metadata.tokenType) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "font style"), $("td.tm-metadata-value", void 0, `${metadata ? this._fontStyleToString(metadata.fontStyle) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "foreground"), $("td.tm-metadata-value", void 0, `${metadata ? Color.Format.CSS.formatHex(metadata.foreground) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "background"), $("td.tm-metadata-value", void 0, `${metadata ? Color.Format.CSS.formatHex(metadata.background) : "-?-"}`)))));
    append(this._domNode, $("hr.tokens-inspect-separator"));
    if (token1Index < data.tokens1.length) {
      append(this._domNode, $("span.tm-token-type", void 0, data.tokens1[token1Index].type));
    }
    this._editor.layoutContentWidget(this);
  }
  _decodeMetadata(metadata) {
    let colorMap = TokenizationRegistry.getColorMap();
    let languageId = TokenMetadata.getLanguageId(metadata);
    let tokenType = TokenMetadata.getTokenType(metadata);
    let fontStyle = TokenMetadata.getFontStyle(metadata);
    let foreground2 = TokenMetadata.getForeground(metadata);
    let background = TokenMetadata.getBackground(metadata);
    return {
      languageIdentifier: this._modeService.getLanguageIdentifier(languageId),
      tokenType,
      fontStyle,
      foreground: colorMap[foreground2],
      background: colorMap[background]
    };
  }
  _tokenTypeToString(tokenType) {
    switch (tokenType) {
      case 0:
        return "Other";
      case 1:
        return "Comment";
      case 2:
        return "String";
      case 4:
        return "RegEx";
      default:
        return "??";
    }
  }
  _fontStyleToString(fontStyle) {
    let r = "";
    if (fontStyle & 1) {
      r += "italic ";
    }
    if (fontStyle & 2) {
      r += "bold ";
    }
    if (fontStyle & 4) {
      r += "underline ";
    }
    if (r.length === 0) {
      r = "---";
    }
    return r;
  }
  _getTokensAtLine(lineNumber) {
    let stateBeforeLine = this._getStateBeforeLine(lineNumber);
    let tokenizationResult1 = this._tokenizationSupport.tokenize(this._model.getLineContent(lineNumber), stateBeforeLine, 0);
    let tokenizationResult2 = this._tokenizationSupport.tokenize2(this._model.getLineContent(lineNumber), stateBeforeLine, 0);
    return {
      startState: stateBeforeLine,
      tokens1: tokenizationResult1.tokens,
      tokens2: tokenizationResult2.tokens,
      endState: tokenizationResult1.endState
    };
  }
  _getStateBeforeLine(lineNumber) {
    let state = this._tokenizationSupport.getInitialState();
    for (let i = 1; i < lineNumber; i++) {
      let tokenizationResult = this._tokenizationSupport.tokenize(this._model.getLineContent(i), state, 0);
      state = tokenizationResult.endState;
    }
    return state;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      position: this._editor.getPosition(),
      preference: [2, 1]
    };
  }
};
InspectTokensWidget._ID = "editor.contrib.inspectTokensWidget";
registerEditorContribution(InspectTokensController.ID, InspectTokensController);
registerEditorAction(InspectTokens);
registerThemingParticipant((theme6, collector) => {
  const border = theme6.getColor(editorHoverBorder);
  if (border) {
    let borderWidth = theme6.type === HIGH_CONTRAST ? 2 : 1;
    collector.addRule(`.monaco-editor .tokens-inspect-widget { border: ${borderWidth}px solid ${border}; }`);
    collector.addRule(`.monaco-editor .tokens-inspect-widget .tokens-inspect-separator { background-color: ${border}; }`);
  }
  const background = theme6.getColor(editorHoverBackground);
  if (background) {
    collector.addRule(`.monaco-editor .tokens-inspect-widget { background-color: ${background}; }`);
  }
  const foreground2 = theme6.getColor(editorHoverForeground);
  if (foreground2) {
    collector.addRule(`.monaco-editor .tokens-inspect-widget { color: ${foreground2}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/platform/quickinput/browser/helpQuickAccess.js
var __decorate46 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param46 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var HelpQuickAccessProvider = class HelpQuickAccessProvider2 {
  constructor(quickInputService) {
    this.quickInputService = quickInputService;
    this.registry = Registry.as(Extensions.Quickaccess);
  }
  provide(picker) {
    const disposables = new DisposableStore();
    disposables.add(picker.onDidAccept(() => {
      const [item] = picker.selectedItems;
      if (item) {
        this.quickInputService.quickAccess.show(item.prefix, {preserveValue: true});
      }
    }));
    disposables.add(picker.onDidChangeValue((value) => {
      const providerDescriptor = this.registry.getQuickAccessProvider(value.substr(HelpQuickAccessProvider2.PREFIX.length));
      if (providerDescriptor && providerDescriptor.prefix && providerDescriptor.prefix !== HelpQuickAccessProvider2.PREFIX) {
        this.quickInputService.quickAccess.show(providerDescriptor.prefix, {preserveValue: true});
      }
    }));
    const {editorProviders, globalProviders} = this.getQuickAccessProviders();
    picker.items = editorProviders.length === 0 || globalProviders.length === 0 ? [
      ...editorProviders.length === 0 ? globalProviders : editorProviders
    ] : [
      {label: localize("globalCommands", "global commands"), type: "separator"},
      ...globalProviders,
      {label: localize("editorCommands", "editor commands"), type: "separator"},
      ...editorProviders
    ];
    return disposables;
  }
  getQuickAccessProviders() {
    const globalProviders = [];
    const editorProviders = [];
    for (const provider of this.registry.getQuickAccessProviders().sort((providerA, providerB) => providerA.prefix.localeCompare(providerB.prefix))) {
      if (provider.prefix === HelpQuickAccessProvider2.PREFIX) {
        continue;
      }
      for (const helpEntry of provider.helpEntries) {
        const prefix2 = helpEntry.prefix || provider.prefix;
        const label = prefix2 || "\u2026";
        (helpEntry.needsEditor ? editorProviders : globalProviders).push({
          prefix: prefix2,
          label,
          ariaLabel: localize("helpPickAriaLabel", "{0}, {1}", label, helpEntry.description),
          description: helpEntry.description
        });
      }
    }
    return {editorProviders, globalProviders};
  }
};
HelpQuickAccessProvider.PREFIX = "?";
HelpQuickAccessProvider = __decorate46([
  __param46(0, IQuickInputService)
], HelpQuickAccessProvider);

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneHelpQuickAccess.js
Registry.as(Extensions.Quickaccess).registerQuickAccessProvider({
  ctor: HelpQuickAccessProvider,
  prefix: "",
  helpEntries: [{description: QuickHelpNLS.helpQuickAccessActionLabel, needsEditor: true}]
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/editorNavigationQuickAccess.js
var AbstractEditorNavigationQuickAccessProvider = class {
  constructor(options) {
    this.options = options;
    this.rangeHighlightDecorationId = void 0;
  }
  provide(picker, token) {
    var _a5;
    const disposables = new DisposableStore();
    picker.canAcceptInBackground = !!((_a5 = this.options) === null || _a5 === void 0 ? void 0 : _a5.canAcceptInBackground);
    picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
    const pickerDisposable = disposables.add(new MutableDisposable());
    pickerDisposable.value = this.doProvide(picker, token);
    disposables.add(this.onDidActiveTextEditorControlChange(() => {
      pickerDisposable.value = void 0;
      pickerDisposable.value = this.doProvide(picker, token);
    }));
    return disposables;
  }
  doProvide(picker, token) {
    const disposables = new DisposableStore();
    const editor3 = this.activeTextEditorControl;
    if (editor3 && this.canProvideWithTextEditor(editor3)) {
      const codeEditor = getCodeEditor(editor3);
      if (codeEditor) {
        let lastKnownEditorViewState = withNullAsUndefined(editor3.saveViewState());
        disposables.add(codeEditor.onDidChangeCursorPosition(() => {
          lastKnownEditorViewState = withNullAsUndefined(editor3.saveViewState());
        }));
        disposables.add(once(token.onCancellationRequested)(() => {
          if (lastKnownEditorViewState && editor3 === this.activeTextEditorControl) {
            editor3.restoreViewState(lastKnownEditorViewState);
          }
        }));
      }
      disposables.add(toDisposable(() => this.clearDecorations(editor3)));
      disposables.add(this.provideWithTextEditor(editor3, picker, token));
    } else {
      disposables.add(this.provideWithoutTextEditor(picker, token));
    }
    return disposables;
  }
  canProvideWithTextEditor(editor3) {
    return true;
  }
  gotoLocation(editor3, options) {
    editor3.setSelection(options.range);
    editor3.revealRangeInCenter(options.range, 0);
    if (!options.preserveFocus) {
      editor3.focus();
    }
  }
  getModel(editor3) {
    var _a5;
    return isDiffEditor(editor3) ? (_a5 = editor3.getModel()) === null || _a5 === void 0 ? void 0 : _a5.modified : editor3.getModel();
  }
  addDecorations(editor3, range2) {
    editor3.changeDecorations((changeAccessor) => {
      const deleteDecorations = [];
      if (this.rangeHighlightDecorationId) {
        deleteDecorations.push(this.rangeHighlightDecorationId.overviewRulerDecorationId);
        deleteDecorations.push(this.rangeHighlightDecorationId.rangeHighlightId);
        this.rangeHighlightDecorationId = void 0;
      }
      const newDecorations = [
        {
          range: range2,
          options: {
            className: "rangeHighlight",
            isWholeLine: true
          }
        },
        {
          range: range2,
          options: {
            overviewRuler: {
              color: themeColorFromId(overviewRulerRangeHighlight),
              position: OverviewRulerLane.Full
            }
          }
        }
      ];
      const [rangeHighlightId, overviewRulerDecorationId] = changeAccessor.deltaDecorations(deleteDecorations, newDecorations);
      this.rangeHighlightDecorationId = {rangeHighlightId, overviewRulerDecorationId};
    });
  }
  clearDecorations(editor3) {
    const rangeHighlightDecorationId = this.rangeHighlightDecorationId;
    if (rangeHighlightDecorationId) {
      editor3.changeDecorations((changeAccessor) => {
        changeAccessor.deltaDecorations([
          rangeHighlightDecorationId.overviewRulerDecorationId,
          rangeHighlightDecorationId.rangeHighlightId
        ], []);
      });
      this.rangeHighlightDecorationId = void 0;
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/gotoLineQuickAccess.js
var AbstractGotoLineQuickAccessProvider = class extends AbstractEditorNavigationQuickAccessProvider {
  constructor() {
    super({canAcceptInBackground: true});
  }
  provideWithoutTextEditor(picker) {
    const label = localize("cannotRunGotoLine", "Open a text editor first to go to a line.");
    picker.items = [{label}];
    picker.ariaLabel = label;
    return Disposable.None;
  }
  provideWithTextEditor(editor3, picker, token) {
    const disposables = new DisposableStore();
    disposables.add(picker.onDidAccept((event) => {
      const [item] = picker.selectedItems;
      if (item) {
        if (!this.isValidLineNumber(editor3, item.lineNumber)) {
          return;
        }
        this.gotoLocation(editor3, {range: this.toRange(item.lineNumber, item.column), keyMods: picker.keyMods, preserveFocus: event.inBackground});
        if (!event.inBackground) {
          picker.hide();
        }
      }
    }));
    const updatePickerAndEditor = () => {
      const position = this.parsePosition(editor3, picker.value.trim().substr(AbstractGotoLineQuickAccessProvider.PREFIX.length));
      const label = this.getPickLabel(editor3, position.lineNumber, position.column);
      picker.items = [{
        lineNumber: position.lineNumber,
        column: position.column,
        label
      }];
      picker.ariaLabel = label;
      if (!this.isValidLineNumber(editor3, position.lineNumber)) {
        this.clearDecorations(editor3);
        return;
      }
      const range2 = this.toRange(position.lineNumber, position.column);
      editor3.revealRangeInCenter(range2, 0);
      this.addDecorations(editor3, range2);
    };
    updatePickerAndEditor();
    disposables.add(picker.onDidChangeValue(() => updatePickerAndEditor()));
    const codeEditor = getCodeEditor(editor3);
    if (codeEditor) {
      const options = codeEditor.getOptions();
      const lineNumbers = options.get(52);
      if (lineNumbers.renderType === 2) {
        codeEditor.updateOptions({lineNumbers: "on"});
        disposables.add(toDisposable(() => codeEditor.updateOptions({lineNumbers: "relative"})));
      }
    }
    return disposables;
  }
  toRange(lineNumber = 1, column = 1) {
    return {
      startLineNumber: lineNumber,
      startColumn: column,
      endLineNumber: lineNumber,
      endColumn: column
    };
  }
  parsePosition(editor3, value) {
    const numbers = value.split(/,|:|#/).map((part) => parseInt(part, 10)).filter((part) => !isNaN(part));
    const endLine = this.lineCount(editor3) + 1;
    return {
      lineNumber: numbers[0] > 0 ? numbers[0] : endLine + numbers[0],
      column: numbers[1]
    };
  }
  getPickLabel(editor3, lineNumber, column) {
    if (this.isValidLineNumber(editor3, lineNumber)) {
      if (this.isValidColumn(editor3, lineNumber, column)) {
        return localize("gotoLineColumnLabel", "Go to line {0} and column {1}.", lineNumber, column);
      }
      return localize("gotoLineLabel", "Go to line {0}.", lineNumber);
    }
    const position = editor3.getPosition() || {lineNumber: 1, column: 1};
    const lineCount = this.lineCount(editor3);
    if (lineCount > 1) {
      return localize("gotoLineLabelEmptyWithLimit", "Current Line: {0}, Character: {1}. Type a line number between 1 and {2} to navigate to.", position.lineNumber, position.column, lineCount);
    }
    return localize("gotoLineLabelEmpty", "Current Line: {0}, Character: {1}. Type a line number to navigate to.", position.lineNumber, position.column);
  }
  isValidLineNumber(editor3, lineNumber) {
    if (!lineNumber || typeof lineNumber !== "number") {
      return false;
    }
    return lineNumber > 0 && lineNumber <= this.lineCount(editor3);
  }
  isValidColumn(editor3, lineNumber, column) {
    if (!column || typeof column !== "number") {
      return false;
    }
    const model = this.getModel(editor3);
    if (!model) {
      return false;
    }
    const positionCandidate = {lineNumber, column};
    return model.validatePosition(positionCandidate).equals(positionCandidate);
  }
  lineCount(editor3) {
    var _a5, _b2;
    return (_b2 = (_a5 = this.getModel(editor3)) === null || _a5 === void 0 ? void 0 : _a5.getLineCount()) !== null && _b2 !== void 0 ? _b2 : 0;
  }
};
AbstractGotoLineQuickAccessProvider.PREFIX = ":";

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneGotoLineQuickAccess.js
var __decorate47 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param47 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneGotoLineQuickAccessProvider = class StandaloneGotoLineQuickAccessProvider2 extends AbstractGotoLineQuickAccessProvider {
  constructor(editorService) {
    super();
    this.editorService = editorService;
    this.onDidActiveTextEditorControlChange = Event.None;
  }
  get activeTextEditorControl() {
    return withNullAsUndefined(this.editorService.getFocusedCodeEditor());
  }
};
StandaloneGotoLineQuickAccessProvider = __decorate47([
  __param47(0, ICodeEditorService)
], StandaloneGotoLineQuickAccessProvider);
Registry.as(Extensions.Quickaccess).registerQuickAccessProvider({
  ctor: StandaloneGotoLineQuickAccessProvider,
  prefix: StandaloneGotoLineQuickAccessProvider.PREFIX,
  helpEntries: [{description: GoToLineNLS.gotoLineActionLabel, needsEditor: true}]
});
var GotoLineAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.gotoLine",
      label: GoToLineNLS.gotoLineActionLabel,
      alias: "Go to Line/Column...",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 37,
        mac: {primary: 256 | 37},
        weight: 100
      }
    });
  }
  run(accessor) {
    accessor.get(IQuickInputService).quickAccess.show(StandaloneGotoLineQuickAccessProvider.PREFIX);
  }
};
registerEditorAction(GotoLineAction);

// ../../node_modules/monaco-editor/esm/vs/base/common/fuzzyScorer.js
var NO_SCORE2 = [void 0, []];
function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {
  const preparedQuery = query;
  if (preparedQuery.values && preparedQuery.values.length > 1) {
    return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);
  }
  return doScoreFuzzy2Single(target, query, patternStart, wordStart);
}
function doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {
  let totalScore = 0;
  const totalMatches = [];
  for (const queryPiece of query) {
    const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);
    if (typeof score !== "number") {
      return NO_SCORE2;
    }
    totalScore += score;
    totalMatches.push(...matches);
  }
  return [totalScore, normalizeMatches(totalMatches)];
}
function doScoreFuzzy2Single(target, query, patternStart, wordStart) {
  const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, true);
  if (!score) {
    return NO_SCORE2;
  }
  return [score[0], createMatches(score)];
}
function normalizeMatches(matches) {
  const sortedMatches = matches.sort((matchA, matchB) => {
    return matchA.start - matchB.start;
  });
  const normalizedMatches = [];
  let currentMatch = void 0;
  for (const match of sortedMatches) {
    if (!currentMatch || !matchOverlaps(currentMatch, match)) {
      currentMatch = match;
      normalizedMatches.push(match);
    } else {
      currentMatch.start = Math.min(currentMatch.start, match.start);
      currentMatch.end = Math.max(currentMatch.end, match.end);
    }
  }
  return normalizedMatches;
}
function matchOverlaps(matchA, matchB) {
  if (matchA.end < matchB.start) {
    return false;
  }
  if (matchB.end < matchA.start) {
    return false;
  }
  return true;
}
var MULTIPLE_QUERY_VALUES_SEPARATOR = " ";
function prepareQuery(original) {
  if (typeof original !== "string") {
    original = "";
  }
  const originalLowercase = original.toLowerCase();
  const {pathNormalized, normalized, normalizedLowercase} = normalizeQuery(original);
  const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;
  let values = void 0;
  const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);
  if (originalSplit.length > 1) {
    for (const originalPiece of originalSplit) {
      const {pathNormalized: pathNormalizedPiece, normalized: normalizedPiece, normalizedLowercase: normalizedLowercasePiece} = normalizeQuery(originalPiece);
      if (normalizedPiece) {
        if (!values) {
          values = [];
        }
        values.push({
          original: originalPiece,
          originalLowercase: originalPiece.toLowerCase(),
          pathNormalized: pathNormalizedPiece,
          normalized: normalizedPiece,
          normalizedLowercase: normalizedLowercasePiece
        });
      }
    }
  }
  return {original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator};
}
function normalizeQuery(original) {
  let pathNormalized;
  if (isWindows) {
    pathNormalized = original.replace(/\//g, sep);
  } else {
    pathNormalized = original.replace(/\\/g, sep);
  }
  const normalized = stripWildcards(pathNormalized).replace(/\s/g, "");
  return {
    pathNormalized,
    normalized,
    normalizedLowercase: normalized.toLowerCase()
  };
}
function pieceToQuery(arg1) {
  if (Array.isArray(arg1)) {
    return prepareQuery(arg1.map((piece) => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));
  }
  return prepareQuery(arg1.original);
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/gotoSymbolQuickAccess.js
var __awaiter32 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AbstractGotoSymbolQuickAccessProvider = class extends AbstractEditorNavigationQuickAccessProvider {
  constructor(options = Object.create(null)) {
    super(options);
    this.options = options;
    options.canAcceptInBackground = true;
  }
  provideWithoutTextEditor(picker) {
    this.provideLabelPick(picker, localize("cannotRunGotoSymbolWithoutEditor", "To go to a symbol, first open a text editor with symbol information."));
    return Disposable.None;
  }
  provideWithTextEditor(editor3, picker, token) {
    const model = this.getModel(editor3);
    if (!model) {
      return Disposable.None;
    }
    if (DocumentSymbolProviderRegistry.has(model)) {
      return this.doProvideWithEditorSymbols(editor3, model, picker, token);
    }
    return this.doProvideWithoutEditorSymbols(editor3, model, picker, token);
  }
  doProvideWithoutEditorSymbols(editor3, model, picker, token) {
    const disposables = new DisposableStore();
    this.provideLabelPick(picker, localize("cannotRunGotoSymbolWithoutSymbolProvider", "The active text editor does not provide symbol information."));
    (() => __awaiter32(this, void 0, void 0, function* () {
      const result = yield this.waitForLanguageSymbolRegistry(model, disposables);
      if (!result || token.isCancellationRequested) {
        return;
      }
      disposables.add(this.doProvideWithEditorSymbols(editor3, model, picker, token));
    }))();
    return disposables;
  }
  provideLabelPick(picker, label) {
    picker.items = [{label, index: 0, kind: 14}];
    picker.ariaLabel = label;
  }
  waitForLanguageSymbolRegistry(model, disposables) {
    return __awaiter32(this, void 0, void 0, function* () {
      if (DocumentSymbolProviderRegistry.has(model)) {
        return true;
      }
      let symbolProviderRegistryPromiseResolve;
      const symbolProviderRegistryPromise = new Promise((resolve) => symbolProviderRegistryPromiseResolve = resolve);
      const symbolProviderListener = disposables.add(DocumentSymbolProviderRegistry.onDidChange(() => {
        if (DocumentSymbolProviderRegistry.has(model)) {
          symbolProviderListener.dispose();
          symbolProviderRegistryPromiseResolve(true);
        }
      }));
      disposables.add(toDisposable(() => symbolProviderRegistryPromiseResolve(false)));
      return symbolProviderRegistryPromise;
    });
  }
  doProvideWithEditorSymbols(editor3, model, picker, token) {
    const disposables = new DisposableStore();
    disposables.add(picker.onDidAccept((event) => {
      const [item] = picker.selectedItems;
      if (item && item.range) {
        this.gotoLocation(editor3, {range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground});
        if (!event.inBackground) {
          picker.hide();
        }
      }
    }));
    disposables.add(picker.onDidTriggerItemButton(({item}) => {
      if (item && item.range) {
        this.gotoLocation(editor3, {range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true});
        picker.hide();
      }
    }));
    const symbolsPromise = this.getDocumentSymbols(model, true, token);
    let picksCts = void 0;
    const updatePickerItems = () => __awaiter32(this, void 0, void 0, function* () {
      picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);
      picker.busy = false;
      picksCts = new CancellationTokenSource(token);
      picker.busy = true;
      try {
        const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider.PREFIX.length).trim());
        const items = yield this.doGetSymbolPicks(symbolsPromise, query, void 0, picksCts.token);
        if (token.isCancellationRequested) {
          return;
        }
        if (items.length > 0) {
          picker.items = items;
        } else {
          if (query.original.length > 0) {
            this.provideLabelPick(picker, localize("noMatchingSymbolResults", "No matching editor symbols"));
          } else {
            this.provideLabelPick(picker, localize("noSymbolResults", "No editor symbols"));
          }
        }
      } finally {
        if (!token.isCancellationRequested) {
          picker.busy = false;
        }
      }
    });
    disposables.add(picker.onDidChangeValue(() => updatePickerItems()));
    updatePickerItems();
    let ignoreFirstActiveEvent = true;
    disposables.add(picker.onDidChangeActive(() => {
      const [item] = picker.activeItems;
      if (item && item.range) {
        if (ignoreFirstActiveEvent) {
          ignoreFirstActiveEvent = false;
          return;
        }
        editor3.revealRangeInCenter(item.range.selection, 0);
        this.addDecorations(editor3, item.range.decoration);
      }
    }));
    return disposables;
  }
  doGetSymbolPicks(symbolsPromise, query, options, token) {
    return __awaiter32(this, void 0, void 0, function* () {
      const symbols = yield symbolsPromise;
      if (token.isCancellationRequested) {
        return [];
      }
      const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX) === 0;
      const filterPos = filterBySymbolKind ? 1 : 0;
      let symbolQuery;
      let containerQuery;
      if (query.values && query.values.length > 1) {
        symbolQuery = pieceToQuery(query.values[0]);
        containerQuery = pieceToQuery(query.values.slice(1));
      } else {
        symbolQuery = query;
      }
      const filteredSymbolPicks = [];
      for (let index2 = 0; index2 < symbols.length; index2++) {
        const symbol5 = symbols[index2];
        const symbolLabel = trim(symbol5.name);
        const symbolLabelWithIcon = `$(symbol-${SymbolKinds.toString(symbol5.kind) || "property"}) ${symbolLabel}`;
        const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;
        let containerLabel = symbol5.containerName;
        if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {
          if (containerLabel) {
            containerLabel = `${options.extraContainerLabel} \u2022 ${containerLabel}`;
          } else {
            containerLabel = options.extraContainerLabel;
          }
        }
        let symbolScore = void 0;
        let symbolMatches = void 0;
        let containerScore = void 0;
        let containerMatches = void 0;
        if (query.original.length > filterPos) {
          let skipContainerQuery = false;
          if (symbolQuery !== query) {
            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), {values: void 0}), filterPos, symbolLabelIconOffset);
            if (typeof symbolScore === "number") {
              skipContainerQuery = true;
            }
          }
          if (typeof symbolScore !== "number") {
            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);
            if (typeof symbolScore !== "number") {
              continue;
            }
          }
          if (!skipContainerQuery && containerQuery) {
            if (containerLabel && containerQuery.original.length > 0) {
              [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);
            }
            if (typeof containerScore !== "number") {
              continue;
            }
            if (typeof symbolScore === "number") {
              symbolScore += containerScore;
            }
          }
        }
        const deprecated = symbol5.tags && symbol5.tags.indexOf(1) >= 0;
        filteredSymbolPicks.push({
          index: index2,
          kind: symbol5.kind,
          score: symbolScore,
          label: symbolLabelWithIcon,
          ariaLabel: symbolLabel,
          description: containerLabel,
          highlights: deprecated ? void 0 : {
            label: symbolMatches,
            description: containerMatches
          },
          range: {
            selection: Range2.collapseToStart(symbol5.selectionRange),
            decoration: symbol5.range
          },
          strikethrough: deprecated,
          buttons: (() => {
            var _a5, _b2;
            const openSideBySideDirection = ((_a5 = this.options) === null || _a5 === void 0 ? void 0 : _a5.openSideBySideDirection) ? (_b2 = this.options) === null || _b2 === void 0 ? void 0 : _b2.openSideBySideDirection() : void 0;
            if (!openSideBySideDirection) {
              return void 0;
            }
            return [
              {
                iconClass: openSideBySideDirection === "right" ? Codicon.splitHorizontal.classNames : Codicon.splitVertical.classNames,
                tooltip: openSideBySideDirection === "right" ? localize("openToSide", "Open to the Side") : localize("openToBottom", "Open to the Bottom")
              }
            ];
          })()
        });
      }
      const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? this.compareByKindAndScore(symbolA, symbolB) : this.compareByScore(symbolA, symbolB));
      let symbolPicks = [];
      if (filterBySymbolKind) {
        let lastSymbolKind = void 0;
        let lastSeparator = void 0;
        let lastSymbolKindCounter = 0;
        function updateLastSeparatorLabel() {
          if (lastSeparator && typeof lastSymbolKind === "number" && lastSymbolKindCounter > 0) {
            lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);
          }
        }
        for (const symbolPick of sortedFilteredSymbolPicks) {
          if (lastSymbolKind !== symbolPick.kind) {
            updateLastSeparatorLabel();
            lastSymbolKind = symbolPick.kind;
            lastSymbolKindCounter = 1;
            lastSeparator = {type: "separator"};
            symbolPicks.push(lastSeparator);
          } else {
            lastSymbolKindCounter++;
          }
          symbolPicks.push(symbolPick);
        }
        updateLastSeparatorLabel();
      } else if (sortedFilteredSymbolPicks.length > 0) {
        symbolPicks = [
          {label: localize("symbols", "symbols ({0})", filteredSymbolPicks.length), type: "separator"},
          ...sortedFilteredSymbolPicks
        ];
      }
      return symbolPicks;
    });
  }
  compareByScore(symbolA, symbolB) {
    if (typeof symbolA.score !== "number" && typeof symbolB.score === "number") {
      return 1;
    } else if (typeof symbolA.score === "number" && typeof symbolB.score !== "number") {
      return -1;
    }
    if (typeof symbolA.score === "number" && typeof symbolB.score === "number") {
      if (symbolA.score > symbolB.score) {
        return -1;
      } else if (symbolA.score < symbolB.score) {
        return 1;
      }
    }
    if (symbolA.index < symbolB.index) {
      return -1;
    } else if (symbolA.index > symbolB.index) {
      return 1;
    }
    return 0;
  }
  compareByKindAndScore(symbolA, symbolB) {
    const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;
    const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;
    const result = kindA.localeCompare(kindB);
    if (result === 0) {
      return this.compareByScore(symbolA, symbolB);
    }
    return result;
  }
  getDocumentSymbols(document2, flatten3, token) {
    return __awaiter32(this, void 0, void 0, function* () {
      const model = yield OutlineModel.create(document2, token);
      if (token.isCancellationRequested) {
        return [];
      }
      const roots = [];
      for (const child of model.children.values()) {
        if (child instanceof OutlineElement) {
          roots.push(child.symbol);
        } else {
          roots.push(...Iterable.map(child.children.values(), (child2) => child2.symbol));
        }
      }
      let flatEntries = [];
      if (flatten3) {
        this.flattenDocumentSymbols(flatEntries, roots, "");
      } else {
        flatEntries = roots;
      }
      return flatEntries.sort((symbolA, symbolB) => Range2.compareRangesUsingStarts(symbolA.range, symbolB.range));
    });
  }
  flattenDocumentSymbols(bucket, entries3, overrideContainerLabel) {
    for (const entry of entries3) {
      bucket.push({
        kind: entry.kind,
        tags: entry.tags,
        name: entry.name,
        detail: entry.detail,
        containerName: entry.containerName || overrideContainerLabel,
        range: entry.range,
        selectionRange: entry.selectionRange,
        children: void 0
      });
      if (entry.children) {
        this.flattenDocumentSymbols(bucket, entry.children, entry.name);
      }
    }
  }
};
AbstractGotoSymbolQuickAccessProvider.PREFIX = "@";
AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ":";
AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider.PREFIX}${AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX}`;
var FALLBACK_NLS_SYMBOL_KIND = localize("property", "properties ({0})");
var NLS_SYMBOL_KIND_CACHE = {
  [5]: localize("method", "methods ({0})"),
  [11]: localize("function", "functions ({0})"),
  [8]: localize("_constructor", "constructors ({0})"),
  [12]: localize("variable", "variables ({0})"),
  [4]: localize("class", "classes ({0})"),
  [22]: localize("struct", "structs ({0})"),
  [23]: localize("event", "events ({0})"),
  [24]: localize("operator", "operators ({0})"),
  [10]: localize("interface", "interfaces ({0})"),
  [2]: localize("namespace", "namespaces ({0})"),
  [3]: localize("package", "packages ({0})"),
  [25]: localize("typeParameter", "type parameters ({0})"),
  [1]: localize("modules", "modules ({0})"),
  [6]: localize("property", "properties ({0})"),
  [9]: localize("enum", "enumerations ({0})"),
  [21]: localize("enumMember", "enumeration members ({0})"),
  [14]: localize("string", "strings ({0})"),
  [0]: localize("file", "files ({0})"),
  [17]: localize("array", "arrays ({0})"),
  [15]: localize("number", "numbers ({0})"),
  [16]: localize("boolean", "booleans ({0})"),
  [18]: localize("object", "objects ({0})"),
  [19]: localize("key", "keys ({0})"),
  [7]: localize("field", "fields ({0})"),
  [13]: localize("constant", "constants ({0})")
};

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneGotoSymbolQuickAccess.js
var __decorate48 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param48 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneGotoSymbolQuickAccessProvider = class StandaloneGotoSymbolQuickAccessProvider2 extends AbstractGotoSymbolQuickAccessProvider {
  constructor(editorService) {
    super();
    this.editorService = editorService;
    this.onDidActiveTextEditorControlChange = Event.None;
  }
  get activeTextEditorControl() {
    return withNullAsUndefined(this.editorService.getFocusedCodeEditor());
  }
};
StandaloneGotoSymbolQuickAccessProvider = __decorate48([
  __param48(0, ICodeEditorService)
], StandaloneGotoSymbolQuickAccessProvider);
Registry.as(Extensions.Quickaccess).registerQuickAccessProvider({
  ctor: StandaloneGotoSymbolQuickAccessProvider,
  prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX,
  helpEntries: [
    {description: QuickOutlineNLS.quickOutlineActionLabel, prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX, needsEditor: true},
    {description: QuickOutlineNLS.quickOutlineByCategoryActionLabel, prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY, needsEditor: true}
  ]
});
var GotoLineAction2 = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.quickOutline",
      label: QuickOutlineNLS.quickOutlineActionLabel,
      alias: "Go to Symbol...",
      precondition: EditorContextKeys.hasDocumentSymbolProvider,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 45,
        weight: 100
      },
      contextMenuOpts: {
        group: "navigation",
        order: 3
      }
    });
  }
  run(accessor) {
    accessor.get(IQuickInputService).quickAccess.show(AbstractGotoSymbolQuickAccessProvider.PREFIX);
  }
};
registerEditorAction(GotoLineAction2);

// ../../node_modules/monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js
var __awaiter33 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TriggerAction;
(function(TriggerAction2) {
  TriggerAction2[TriggerAction2["NO_ACTION"] = 0] = "NO_ACTION";
  TriggerAction2[TriggerAction2["CLOSE_PICKER"] = 1] = "CLOSE_PICKER";
  TriggerAction2[TriggerAction2["REFRESH_PICKER"] = 2] = "REFRESH_PICKER";
  TriggerAction2[TriggerAction2["REMOVE_ITEM"] = 3] = "REMOVE_ITEM";
})(TriggerAction || (TriggerAction = {}));
function isPicksWithActive(obj) {
  const candidate = obj;
  return Array.isArray(candidate.items);
}
function isFastAndSlowPicks(obj) {
  const candidate = obj;
  return !!candidate.picks && candidate.additionalPicks instanceof Promise;
}
var PickerQuickAccessProvider = class extends Disposable {
  constructor(prefix2, options) {
    super();
    this.prefix = prefix2;
    this.options = options;
  }
  provide(picker, token) {
    var _a5;
    const disposables = new DisposableStore();
    picker.canAcceptInBackground = !!((_a5 = this.options) === null || _a5 === void 0 ? void 0 : _a5.canAcceptInBackground);
    picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
    let picksCts = void 0;
    const picksDisposable = disposables.add(new MutableDisposable());
    const updatePickerItems = () => __awaiter33(this, void 0, void 0, function* () {
      const picksDisposables = picksDisposable.value = new DisposableStore();
      picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);
      picker.busy = false;
      picksCts = new CancellationTokenSource(token);
      const picksToken = picksCts.token;
      const picksFilter = picker.value.substr(this.prefix.length).trim();
      const providedPicks = this.getPicks(picksFilter, picksDisposables, picksToken);
      const applyPicks = (picks, skipEmpty) => {
        var _a6;
        let items;
        let activeItem = void 0;
        if (isPicksWithActive(picks)) {
          items = picks.items;
          activeItem = picks.active;
        } else {
          items = picks;
        }
        if (items.length === 0) {
          if (skipEmpty) {
            return false;
          }
          if (picksFilter.length > 0 && ((_a6 = this.options) === null || _a6 === void 0 ? void 0 : _a6.noResultsPick)) {
            items = [this.options.noResultsPick];
          }
        }
        picker.items = items;
        if (activeItem) {
          picker.activeItems = [activeItem];
        }
        return true;
      };
      if (providedPicks === null) {
      } else if (isFastAndSlowPicks(providedPicks)) {
        let fastPicksApplied = false;
        let slowPicksApplied = false;
        yield Promise.all([
          (() => __awaiter33(this, void 0, void 0, function* () {
            yield timeout(PickerQuickAccessProvider.FAST_PICKS_RACE_DELAY);
            if (picksToken.isCancellationRequested) {
              return;
            }
            if (!slowPicksApplied) {
              fastPicksApplied = applyPicks(providedPicks.picks, true);
            }
          }))(),
          (() => __awaiter33(this, void 0, void 0, function* () {
            picker.busy = true;
            try {
              const awaitedAdditionalPicks = yield providedPicks.additionalPicks;
              if (picksToken.isCancellationRequested) {
                return;
              }
              let picks;
              let activePick = void 0;
              if (isPicksWithActive(providedPicks.picks)) {
                picks = providedPicks.picks.items;
                activePick = providedPicks.picks.active;
              } else {
                picks = providedPicks.picks;
              }
              let additionalPicks;
              let additionalActivePick = void 0;
              if (isPicksWithActive(awaitedAdditionalPicks)) {
                additionalPicks = awaitedAdditionalPicks.items;
                additionalActivePick = awaitedAdditionalPicks.active;
              } else {
                additionalPicks = awaitedAdditionalPicks;
              }
              if (additionalPicks.length > 0 || !fastPicksApplied) {
                let fallbackActivePick = void 0;
                if (!activePick && !additionalActivePick) {
                  const fallbackActivePickCandidate = picker.activeItems[0];
                  if (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) {
                    fallbackActivePick = fallbackActivePickCandidate;
                  }
                }
                applyPicks({
                  items: [...picks, ...additionalPicks],
                  active: activePick || additionalActivePick || fallbackActivePick
                });
              }
            } finally {
              if (!picksToken.isCancellationRequested) {
                picker.busy = false;
              }
              slowPicksApplied = true;
            }
          }))()
        ]);
      } else if (!(providedPicks instanceof Promise)) {
        applyPicks(providedPicks);
      } else {
        picker.busy = true;
        try {
          const awaitedPicks = yield providedPicks;
          if (picksToken.isCancellationRequested) {
            return;
          }
          applyPicks(awaitedPicks);
        } finally {
          if (!picksToken.isCancellationRequested) {
            picker.busy = false;
          }
        }
      }
    });
    disposables.add(picker.onDidChangeValue(() => updatePickerItems()));
    updatePickerItems();
    disposables.add(picker.onDidAccept((event) => {
      const [item] = picker.selectedItems;
      if (typeof (item === null || item === void 0 ? void 0 : item.accept) === "function") {
        if (!event.inBackground) {
          picker.hide();
        }
        item.accept(picker.keyMods, event);
      }
    }));
    disposables.add(picker.onDidTriggerItemButton(({button, item}) => __awaiter33(this, void 0, void 0, function* () {
      var _b2, _c2;
      if (typeof item.trigger === "function") {
        const buttonIndex = (_c2 = (_b2 = item.buttons) === null || _b2 === void 0 ? void 0 : _b2.indexOf(button)) !== null && _c2 !== void 0 ? _c2 : -1;
        if (buttonIndex >= 0) {
          const result = item.trigger(buttonIndex, picker.keyMods);
          const action = typeof result === "number" ? result : yield result;
          if (token.isCancellationRequested) {
            return;
          }
          switch (action) {
            case TriggerAction.NO_ACTION:
              break;
            case TriggerAction.CLOSE_PICKER:
              picker.hide();
              break;
            case TriggerAction.REFRESH_PICKER:
              updatePickerItems();
              break;
            case TriggerAction.REMOVE_ITEM:
              const index2 = picker.items.indexOf(item);
              if (index2 !== -1) {
                const items = picker.items.slice();
                items.splice(index2, 1);
                picker.items = items;
              }
              break;
          }
        }
      }
    })));
    return disposables;
  }
};
PickerQuickAccessProvider.FAST_PICKS_RACE_DELAY = 200;

// ../../node_modules/monaco-editor/esm/vs/base/common/errorMessage.js
function exceptionToErrorMessage(exception, verbose) {
  if (verbose && (exception.stack || exception.stacktrace)) {
    return localize("stackTrace.format", "{0}: {1}", detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));
  }
  return detectSystemErrorMessage(exception);
}
function stackToString(stack) {
  if (Array.isArray(stack)) {
    return stack.join("\n");
  }
  return stack;
}
function detectSystemErrorMessage(exception) {
  if (typeof exception.code === "string" && typeof exception.errno === "number" && typeof exception.syscall === "string") {
    return localize("nodeExceptionMessage", "A system error occurred ({0})", exception.message);
  }
  return exception.message || localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}
function toErrorMessage(error = null, verbose = false) {
  if (!error) {
    return localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
  }
  if (Array.isArray(error)) {
    const errors = coalesce(error);
    const msg = toErrorMessage(errors[0], verbose);
    if (errors.length > 1) {
      return localize("error.moreErrors", "{0} ({1} errors in total)", msg, errors.length);
    }
    return msg;
  }
  if (isString(error)) {
    return error;
  }
  if (error.detail) {
    const detail = error.detail;
    if (detail.error) {
      return exceptionToErrorMessage(detail.error, verbose);
    }
    if (detail.exception) {
      return exceptionToErrorMessage(detail.exception, verbose);
    }
  }
  if (error.stack) {
    return exceptionToErrorMessage(error, verbose);
  }
  if (error.message) {
    return error.message;
  }
  return localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}

// ../../node_modules/monaco-editor/esm/vs/platform/quickinput/browser/commandsQuickAccess.js
var __decorate49 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param49 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter34 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AbstractCommandsQuickAccessProvider = class AbstractCommandsQuickAccessProvider2 extends PickerQuickAccessProvider {
  constructor(options, instantiationService, keybindingService, commandService, telemetryService, notificationService) {
    super(AbstractCommandsQuickAccessProvider2.PREFIX, options);
    this.options = options;
    this.instantiationService = instantiationService;
    this.keybindingService = keybindingService;
    this.commandService = commandService;
    this.telemetryService = telemetryService;
    this.notificationService = notificationService;
    this.commandsHistory = this._register(this.instantiationService.createInstance(CommandsHistory));
  }
  getPicks(filter2, disposables, token) {
    return __awaiter34(this, void 0, void 0, function* () {
      const allCommandPicks = yield this.getCommandPicks(disposables, token);
      if (token.isCancellationRequested) {
        return [];
      }
      const filteredCommandPicks = [];
      for (const commandPick of allCommandPicks) {
        const labelHighlights = withNullAsUndefined(AbstractCommandsQuickAccessProvider2.WORD_FILTER(filter2, commandPick.label));
        const aliasHighlights = commandPick.commandAlias ? withNullAsUndefined(AbstractCommandsQuickAccessProvider2.WORD_FILTER(filter2, commandPick.commandAlias)) : void 0;
        if (labelHighlights || aliasHighlights) {
          commandPick.highlights = {
            label: labelHighlights,
            detail: this.options.showAlias ? aliasHighlights : void 0
          };
          filteredCommandPicks.push(commandPick);
        } else if (filter2 === commandPick.commandId) {
          filteredCommandPicks.push(commandPick);
        }
      }
      const mapLabelToCommand = new Map();
      for (const commandPick of filteredCommandPicks) {
        const existingCommandForLabel = mapLabelToCommand.get(commandPick.label);
        if (existingCommandForLabel) {
          commandPick.description = commandPick.commandId;
          existingCommandForLabel.description = existingCommandForLabel.commandId;
        } else {
          mapLabelToCommand.set(commandPick.label, commandPick);
        }
      }
      filteredCommandPicks.sort((commandPickA, commandPickB) => {
        const commandACounter = this.commandsHistory.peek(commandPickA.commandId);
        const commandBCounter = this.commandsHistory.peek(commandPickB.commandId);
        if (commandACounter && commandBCounter) {
          return commandACounter > commandBCounter ? -1 : 1;
        }
        if (commandACounter) {
          return -1;
        }
        if (commandBCounter) {
          return 1;
        }
        return commandPickA.label.localeCompare(commandPickB.label);
      });
      const commandPicks = [];
      let addSeparator = false;
      for (let i = 0; i < filteredCommandPicks.length; i++) {
        const commandPick = filteredCommandPicks[i];
        const keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);
        const ariaLabel = keybinding ? localize("commandPickAriaLabelWithKeybinding", "{0}, {1}", commandPick.label, keybinding.getAriaLabel()) : commandPick.label;
        if (i === 0 && this.commandsHistory.peek(commandPick.commandId)) {
          commandPicks.push({type: "separator", label: localize("recentlyUsed", "recently used")});
          addSeparator = true;
        }
        if (i !== 0 && addSeparator && !this.commandsHistory.peek(commandPick.commandId)) {
          commandPicks.push({type: "separator", label: localize("morecCommands", "other commands")});
          addSeparator = false;
        }
        commandPicks.push(Object.assign(Object.assign({}, commandPick), {ariaLabel, detail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : void 0, keybinding, accept: () => __awaiter34(this, void 0, void 0, function* () {
          this.commandsHistory.push(commandPick.commandId);
          this.telemetryService.publicLog2("workbenchActionExecuted", {
            id: commandPick.commandId,
            from: "quick open"
          });
          try {
            yield this.commandService.executeCommand(commandPick.commandId);
          } catch (error) {
            if (!isPromiseCanceledError(error)) {
              this.notificationService.error(localize("canNotRun", "Command '{0}' resulted in an error ({1})", commandPick.label, toErrorMessage(error)));
            }
          }
        })}));
      }
      return commandPicks;
    });
  }
};
AbstractCommandsQuickAccessProvider.PREFIX = ">";
AbstractCommandsQuickAccessProvider.WORD_FILTER = or(matchesPrefix, matchesWords, matchesContiguousSubString);
AbstractCommandsQuickAccessProvider = __decorate49([
  __param49(1, IInstantiationService),
  __param49(2, IKeybindingService),
  __param49(3, ICommandService),
  __param49(4, ITelemetryService),
  __param49(5, INotificationService)
], AbstractCommandsQuickAccessProvider);
var CommandsHistory = class CommandsHistory2 extends Disposable {
  constructor(storageService, configurationService, storageKeysSyncRegistryService) {
    super();
    this.storageService = storageService;
    this.configurationService = configurationService;
    this.configuredCommandsHistoryLength = 0;
    storageKeysSyncRegistryService.registerStorageKey({key: CommandsHistory2.PREF_KEY_CACHE, version: 1});
    storageKeysSyncRegistryService.registerStorageKey({key: CommandsHistory2.PREF_KEY_COUNTER, version: 1});
    this.updateConfiguration();
    this.load();
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration(() => this.updateConfiguration()));
  }
  updateConfiguration() {
    this.configuredCommandsHistoryLength = CommandsHistory2.getConfiguredCommandHistoryLength(this.configurationService);
    if (CommandsHistory2.cache && CommandsHistory2.cache.limit !== this.configuredCommandsHistoryLength) {
      CommandsHistory2.cache.limit = this.configuredCommandsHistoryLength;
      CommandsHistory2.saveState(this.storageService);
    }
  }
  load() {
    const raw = this.storageService.get(CommandsHistory2.PREF_KEY_CACHE, 0);
    let serializedCache;
    if (raw) {
      try {
        serializedCache = JSON.parse(raw);
      } catch (error) {
      }
    }
    const cache = CommandsHistory2.cache = new LRUCache(this.configuredCommandsHistoryLength, 1);
    if (serializedCache) {
      let entries3;
      if (serializedCache.usesLRU) {
        entries3 = serializedCache.entries;
      } else {
        entries3 = serializedCache.entries.sort((a, b) => a.value - b.value);
      }
      entries3.forEach((entry) => cache.set(entry.key, entry.value));
    }
    CommandsHistory2.counter = this.storageService.getNumber(CommandsHistory2.PREF_KEY_COUNTER, 0, CommandsHistory2.counter);
  }
  push(commandId) {
    if (!CommandsHistory2.cache) {
      return;
    }
    CommandsHistory2.cache.set(commandId, CommandsHistory2.counter++);
    CommandsHistory2.saveState(this.storageService);
  }
  peek(commandId) {
    var _a5;
    return (_a5 = CommandsHistory2.cache) === null || _a5 === void 0 ? void 0 : _a5.peek(commandId);
  }
  static saveState(storageService) {
    if (!CommandsHistory2.cache) {
      return;
    }
    const serializedCache = {usesLRU: true, entries: []};
    CommandsHistory2.cache.forEach((value, key) => serializedCache.entries.push({key, value}));
    storageService.store(CommandsHistory2.PREF_KEY_CACHE, JSON.stringify(serializedCache), 0);
    storageService.store(CommandsHistory2.PREF_KEY_COUNTER, CommandsHistory2.counter, 0);
  }
  static getConfiguredCommandHistoryLength(configurationService) {
    var _a5, _b2;
    const config = configurationService.getValue();
    const configuredCommandHistoryLength = (_b2 = (_a5 = config.workbench) === null || _a5 === void 0 ? void 0 : _a5.commandPalette) === null || _b2 === void 0 ? void 0 : _b2.history;
    if (typeof configuredCommandHistoryLength === "number") {
      return configuredCommandHistoryLength;
    }
    return CommandsHistory2.DEFAULT_COMMANDS_HISTORY_LENGTH;
  }
};
CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH = 50;
CommandsHistory.PREF_KEY_CACHE = "commandPalette.mru.cache";
CommandsHistory.PREF_KEY_COUNTER = "commandPalette.mru.counter";
CommandsHistory.counter = 1;
CommandsHistory = __decorate49([
  __param49(0, IStorageService),
  __param49(1, IConfigurationService),
  __param49(2, IStorageKeysSyncRegistryService)
], CommandsHistory);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/commandsQuickAccess.js
var AbstractEditorCommandsQuickAccessProvider = class extends AbstractCommandsQuickAccessProvider {
  constructor(options, instantiationService, keybindingService, commandService, telemetryService, notificationService) {
    super(options, instantiationService, keybindingService, commandService, telemetryService, notificationService);
  }
  getCodeEditorCommandPicks() {
    const activeTextEditorControl = this.activeTextEditorControl;
    if (!activeTextEditorControl) {
      return [];
    }
    const editorCommandPicks = [];
    for (const editorAction of activeTextEditorControl.getSupportedActions()) {
      editorCommandPicks.push({
        commandId: editorAction.id,
        commandAlias: editorAction.alias,
        label: stripCodicons(editorAction.label) || editorAction.id
      });
    }
    return editorCommandPicks;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneCommandsQuickAccess.js
var __decorate50 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param50 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter35 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StandaloneCommandsQuickAccessProvider = class StandaloneCommandsQuickAccessProvider2 extends AbstractEditorCommandsQuickAccessProvider {
  constructor(instantiationService, codeEditorService, keybindingService, commandService, telemetryService, notificationService) {
    super({showAlias: false}, instantiationService, keybindingService, commandService, telemetryService, notificationService);
    this.codeEditorService = codeEditorService;
  }
  get activeTextEditorControl() {
    return withNullAsUndefined(this.codeEditorService.getFocusedCodeEditor());
  }
  getCommandPicks() {
    return __awaiter35(this, void 0, void 0, function* () {
      return this.getCodeEditorCommandPicks();
    });
  }
};
StandaloneCommandsQuickAccessProvider = __decorate50([
  __param50(0, IInstantiationService),
  __param50(1, ICodeEditorService),
  __param50(2, IKeybindingService),
  __param50(3, ICommandService),
  __param50(4, ITelemetryService),
  __param50(5, INotificationService)
], StandaloneCommandsQuickAccessProvider);
Registry.as(Extensions.Quickaccess).registerQuickAccessProvider({
  ctor: StandaloneCommandsQuickAccessProvider,
  prefix: StandaloneCommandsQuickAccessProvider.PREFIX,
  helpEntries: [{description: QuickCommandNLS.quickCommandHelp, needsEditor: true}]
});
var GotoLineAction3 = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.quickCommand",
      label: QuickCommandNLS.quickCommandActionLabel,
      alias: "Command Palette",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 59,
        weight: 100
      },
      contextMenuOpts: {
        group: "z_commands",
        order: 1
      }
    });
  }
  run(accessor) {
    accessor.get(IQuickInputService).quickAccess.show(StandaloneCommandsQuickAccessProvider.PREFIX);
  }
};
registerEditorAction(GotoLineAction3);

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/referenceSearch/standaloneReferenceSearch.js
var __decorate51 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param51 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneReferencesController = class StandaloneReferencesController2 extends ReferencesController {
  constructor(editor3, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService) {
    super(true, editor3, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService);
  }
};
StandaloneReferencesController = __decorate51([
  __param51(1, IContextKeyService),
  __param51(2, ICodeEditorService),
  __param51(3, INotificationService),
  __param51(4, IInstantiationService),
  __param51(5, IStorageService),
  __param51(6, IConfigurationService)
], StandaloneReferencesController);
registerEditorContribution(ReferencesController.ID, StandaloneReferencesController);

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/toggleHighContrast/toggleHighContrast.js
var ToggleHighContrast = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.toggleHighContrast",
      label: ToggleHighContrastNLS.toggleHighContrast,
      alias: "Toggle High Contrast Theme",
      precondition: void 0
    });
    this._originalThemeName = null;
  }
  run(accessor, editor3) {
    const standaloneThemeService = accessor.get(IStandaloneThemeService);
    if (this._originalThemeName) {
      standaloneThemeService.setTheme(this._originalThemeName);
      this._originalThemeName = null;
    } else {
      this._originalThemeName = standaloneThemeService.getColorTheme().themeName;
      standaloneThemeService.setTheme("hc-black");
    }
  }
};
registerEditorAction(ToggleHighContrast);

// worker-loader:monaco-editor/esm/vs/editor/editor.worker.js
var WorkerWrapper = class extends Worker {
  constructor() {
    super("./editor.worker.js");
  }
};
var editor_worker_default = WorkerWrapper;

// worker-loader:/Users/mat/code/opstrace/packages/app/src/workers/opscript/opscript.worker
var WorkerWrapper2 = class extends Worker {
  constructor() {
    super("./opscript.worker.js");
  }
};
var opscript_default = WorkerWrapper2;

// src/workers/monaco-typescript-4.1.1/monaco.contribution.ts
"use strict";
var ModuleKind;
(function(ModuleKind2) {
  ModuleKind2[ModuleKind2["None"] = 0] = "None";
  ModuleKind2[ModuleKind2["CommonJS"] = 1] = "CommonJS";
  ModuleKind2[ModuleKind2["AMD"] = 2] = "AMD";
  ModuleKind2[ModuleKind2["UMD"] = 3] = "UMD";
  ModuleKind2[ModuleKind2["System"] = 4] = "System";
  ModuleKind2[ModuleKind2["ES2015"] = 5] = "ES2015";
  ModuleKind2[ModuleKind2["ESNext"] = 99] = "ESNext";
})(ModuleKind || (ModuleKind = {}));
var JsxEmit;
(function(JsxEmit2) {
  JsxEmit2[JsxEmit2["None"] = 0] = "None";
  JsxEmit2[JsxEmit2["Preserve"] = 1] = "Preserve";
  JsxEmit2[JsxEmit2["React"] = 2] = "React";
  JsxEmit2[JsxEmit2["ReactNative"] = 3] = "ReactNative";
})(JsxEmit || (JsxEmit = {}));
var NewLineKind;
(function(NewLineKind2) {
  NewLineKind2[NewLineKind2["CarriageReturnLineFeed"] = 0] = "CarriageReturnLineFeed";
  NewLineKind2[NewLineKind2["LineFeed"] = 1] = "LineFeed";
})(NewLineKind || (NewLineKind = {}));
var ScriptTarget;
(function(ScriptTarget2) {
  ScriptTarget2[ScriptTarget2["ES3"] = 0] = "ES3";
  ScriptTarget2[ScriptTarget2["ES5"] = 1] = "ES5";
  ScriptTarget2[ScriptTarget2["ES2015"] = 2] = "ES2015";
  ScriptTarget2[ScriptTarget2["ES2016"] = 3] = "ES2016";
  ScriptTarget2[ScriptTarget2["ES2017"] = 4] = "ES2017";
  ScriptTarget2[ScriptTarget2["ES2018"] = 5] = "ES2018";
  ScriptTarget2[ScriptTarget2["ES2019"] = 6] = "ES2019";
  ScriptTarget2[ScriptTarget2["ES2020"] = 7] = "ES2020";
  ScriptTarget2[ScriptTarget2["ESNext"] = 99] = "ESNext";
  ScriptTarget2[ScriptTarget2["JSON"] = 100] = "JSON";
  ScriptTarget2[ScriptTarget2["Latest"] = 99] = "Latest";
})(ScriptTarget || (ScriptTarget = {}));
var ModuleResolutionKind;
(function(ModuleResolutionKind2) {
  ModuleResolutionKind2[ModuleResolutionKind2["Classic"] = 1] = "Classic";
  ModuleResolutionKind2[ModuleResolutionKind2["NodeJs"] = 2] = "NodeJs";
})(ModuleResolutionKind || (ModuleResolutionKind = {}));
var LanguageServiceDefaultsImpl = class {
  constructor(compilerOptions, diagnosticsOptions, workerOptions) {
    this._onDidChange = new Emitter();
    this._onDidExtraLibsChange = new Emitter();
    this._extraLibs = Object.create(null);
    this._removedExtraLibs = Object.create(null);
    this._eagerModelSync = false;
    this.setCompilerOptions(compilerOptions);
    this.setDiagnosticsOptions(diagnosticsOptions);
    this.setWorkerOptions(workerOptions);
    this._onDidExtraLibsChangeTimeout = -1;
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get onDidExtraLibsChange() {
    return this._onDidExtraLibsChange.event;
  }
  get workerOptions() {
    return this._workerOptions;
  }
  getExtraLibs() {
    return this._extraLibs;
  }
  addExtraLib(content, _filePath) {
    let filePath;
    if (typeof _filePath === "undefined") {
      filePath = `ts:extralib-${Math.random().toString(36).substring(2, 15)}`;
    } else {
      filePath = _filePath;
    }
    if (this._extraLibs[filePath] && this._extraLibs[filePath].content === content) {
      return {
        dispose: () => {
        }
      };
    }
    let myVersion = 1;
    if (this._removedExtraLibs[filePath]) {
      myVersion = this._removedExtraLibs[filePath] + 1;
    }
    if (this._extraLibs[filePath]) {
      myVersion = this._extraLibs[filePath].version + 1;
    }
    this._extraLibs[filePath] = {
      content,
      version: myVersion
    };
    this._fireOnDidExtraLibsChangeSoon();
    return {
      dispose: () => {
        let extraLib = this._extraLibs[filePath];
        if (!extraLib) {
          return;
        }
        if (extraLib.version !== myVersion) {
          return;
        }
        delete this._extraLibs[filePath];
        this._removedExtraLibs[filePath] = myVersion;
        this._fireOnDidExtraLibsChangeSoon();
      }
    };
  }
  setExtraLibs(libs) {
    for (const filePath in this._extraLibs) {
      this._removedExtraLibs[filePath] = this._extraLibs[filePath].version;
    }
    this._extraLibs = Object.create(null);
    if (libs && libs.length > 0) {
      for (const lib of libs) {
        const filePath = lib.filePath || `ts:extralib-${Math.random().toString(36).substring(2, 15)}`;
        const content = lib.content;
        let myVersion = 1;
        if (this._removedExtraLibs[filePath]) {
          myVersion = this._removedExtraLibs[filePath] + 1;
        }
        this._extraLibs[filePath] = {
          content,
          version: myVersion
        };
      }
    }
    this._fireOnDidExtraLibsChangeSoon();
  }
  _fireOnDidExtraLibsChangeSoon() {
    if (this._onDidExtraLibsChangeTimeout !== -1) {
      return;
    }
    this._onDidExtraLibsChangeTimeout = setTimeout(() => {
      this._onDidExtraLibsChangeTimeout = -1;
      this._onDidExtraLibsChange.fire(void 0);
    }, 0);
  }
  getCompilerOptions() {
    return this._compilerOptions;
  }
  setCompilerOptions(options) {
    this._compilerOptions = options || Object.create(null);
    this._onDidChange.fire(void 0);
  }
  getDiagnosticsOptions() {
    return this._diagnosticsOptions;
  }
  setDiagnosticsOptions(options) {
    this._diagnosticsOptions = options || Object.create(null);
    this._onDidChange.fire(void 0);
  }
  setWorkerOptions(options) {
    this._workerOptions = options || Object.create(null);
    this._onDidChange.fire(void 0);
  }
  setMaximumWorkerIdleTime(value) {
  }
  setEagerModelSync(value) {
    this._eagerModelSync = value;
  }
  getEagerModelSync() {
    return this._eagerModelSync;
  }
};
var typescriptDefaults = new LanguageServiceDefaultsImpl({allowNonTsExtensions: true, target: 99}, {noSemanticValidation: false, noSyntaxValidation: false}, {});
var javascriptDefaults = new LanguageServiceDefaultsImpl({allowNonTsExtensions: true, allowJs: true, target: 99}, {noSemanticValidation: true, noSyntaxValidation: false}, {});
var getTypeScriptWorker = () => {
  return getMode().then((mode) => mode.getTypeScriptWorker());
};
function getMode() {
  return import("./_.._/workers/monaco-typescript-4.1.1/tsMode.js");
}
languages.onLanguage("typescript", () => {
  return getMode().then((mode) => mode.setupTypeScript(typescriptDefaults));
});
languages.onLanguage("javascript", () => {
  return getMode().then((mode) => mode.setupJavaScript(javascriptDefaults));
});

// src/client/buildInfo.ts
var buildTime = "1613606140042";
var buildInfo_default = buildTime;

// src/workers/index.ts
var getOpScriptWorker = async () => {
  const worker = await getTypeScriptWorker();
  const client2 = await worker();
  return client2;
};
var opScriptDefaults = typescriptDefaults;
(async function fetchSDKTypings() {
  if (true) {
    return;
  }
  try {
    const res = await fetch(`/_/modules/opstrace.lib.d.ts?mtime=${buildInfo_default}`);
    const content = await res.text();
    opScriptDefaults.addExtraLib(content, "opstrace.lib.d.ts");
  } catch (err) {
    console.error(err);
  }
})();
opScriptDefaults.setEagerModelSync(true);
opScriptDefaults.setCompilerOptions({
  jsx: JsxEmit.React,
  allowJs: true,
  allowNonTsExtensions: true,
  allowSyntheticDefaultImports: true,
  target: ScriptTarget.ES2015,
  moduleResolution: ModuleResolutionKind.NodeJs,
  module: ModuleKind.ESNext,
  lib: ["es6"],
  noImplicitAny: true,
  noImplicitThis: true,
  declaration: true,
  sourceMap: true
});
self.MonacoEnvironment = {
  getWorker: function(_, label) {
    if (label === "typescript") {
      return new opscript_default();
    }
    return new editor_worker_default();
  }
};

// ../../node_modules/es-module-lexer/dist/lexer.js
var A = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
function parse3(E2, g = "@") {
  if (!B)
    return init.then(() => parse3(E2));
  const I = E2.length + 1, D = (B.__heap_base.value || B.__heap_base) + 4 * I - B.memory.buffer.byteLength;
  D > 0 && B.memory.grow(Math.ceil(D / 65536));
  const w = B.sa(I - 1);
  if ((A ? C : Q)(E2, new Uint16Array(B.memory.buffer, w, I)), !B.parse())
    throw Object.assign(new Error(`Parse error ${g}:${E2.slice(0, B.e()).split("\n").length}:${B.e() - E2.lastIndexOf("\n", B.e() - 1)}`), {idx: B.e()});
  const L = [], k = [];
  for (; B.ri(); )
    L.push({s: B.is(), e: B.ie(), ss: B.ss(), se: B.se(), d: B.id()});
  for (; B.re(); )
    k.push(E2.slice(B.es(), B.ee()));
  return [L, k, !!B.f()];
}
function Q(A2, Q2) {
  const C2 = A2.length;
  let B2 = 0;
  for (; B2 < C2; ) {
    const C3 = A2.charCodeAt(B2);
    Q2[B2++] = (255 & C3) << 8 | C3 >>> 8;
  }
}
function C(A2, Q2) {
  const C2 = A2.length;
  let B2 = 0;
  for (; B2 < C2; )
    Q2[B2] = A2.charCodeAt(B2++);
}
var B;
var init = WebAssembly.compile((E = "AGFzbQEAAAABWAxgAX8Bf2AEf39/fwBgAn9/AGAAAX9gAABgBn9/f39/fwF/YAR/f39/AX9gA39/fwF/YAd/f39/f39/AX9gBX9/f39/AX9gAn9/AX9gCH9/f39/f39/AX8DLy4AAQIDAwMDAwMDAwMDAwAEBAAFBAQAAAAABAQEBAQABQYHCAkKCwMCAAAKAwgLBAUBcAEBAQUDAQABBg8CfwFB8PAAC38AQfDwAAsHWg8GbWVtb3J5AgACc2EAAAFlAAMCaXMABAJpZQAFAnNzAAYCc2UABwJpZAAIAmVzAAkCZWUACgJyaQALAnJlAAwBZgANBXBhcnNlAA4LX19oZWFwX2Jhc2UDAQqjMy5oAQF/QQAgADYCtAhBACgCkAgiASAAQQF0aiIAQQA7AQBBACAAQQJqIgA2ArgIQQAgADYCvAhBAEEANgKUCEEAQQA2AqQIQQBBADYCnAhBAEEANgKYCEEAQQA2AqwIQQBBADYCoAggAQudAQECf0EAKAKkCCIEQRRqQZQIIAQbQQAoArwIIgU2AgBBACAFNgKkCEEAIAQ2AqgIQQAgBUEYajYCvAggBSAANgIIAkACQEEAKAKICCADRw0AIAUgAjYCDAwBCwJAQQAoAoQIIANHDQAgBSACQQJqNgIMDAELIAVBACgCkAg2AgwLIAVBADYCFCAFIAM2AhAgBSACNgIEIAUgATYCAAtIAQF/QQAoAqwIIgJBCGpBmAggAhtBACgCvAgiAjYCAEEAIAI2AqwIQQAgAkEMajYCvAggAkEANgIIIAIgATYCBCACIAA2AgALCABBACgCwAgLFQBBACgCnAgoAgBBACgCkAhrQQF1CxUAQQAoApwIKAIEQQAoApAIa0EBdQsVAEEAKAKcCCgCCEEAKAKQCGtBAXULFQBBACgCnAgoAgxBACgCkAhrQQF1CzsBAX8CQEEAKAKcCCgCECIAQQAoAoQIRw0AQX8PCwJAIABBACgCiAhHDQBBfg8LIABBACgCkAhrQQF1CxUAQQAoAqAIKAIAQQAoApAIa0EBdQsVAEEAKAKgCCgCBEEAKAKQCGtBAXULJQEBf0EAQQAoApwIIgBBFGpBlAggABsoAgAiADYCnAggAEEARwslAQF/QQBBACgCoAgiAEEIakGYCCAAGygCACIANgKgCCAAQQBHCwgAQQAtAMQIC4UMAQV/IwBBgPAAayIBJABBAEEBOgDECEEAQf//AzsByghBAEEAKAKMCDYCzAhBAEEAKAKQCEF+aiICNgLgCEEAIAJBACgCtAhBAXRqIgM2AuQIQQBBADsBxghBAEEAOwHICEEAQQA6ANAIQQBBADYCwAhBAEEAOgCwCEEAIAFBgNAAajYC1AhBACABQYAQajYC2AhBAEEAOgDcCAJAAkACQANAQQAgAkECaiIENgLgCAJAAkACQAJAIAIgA08NACAELwEAIgNBd2pBBUkNAyADQZt/aiIFQQRNDQEgA0EgRg0DAkAgA0EvRg0AIANBO0YNAwwGCwJAIAIvAQQiBEEqRg0AIARBL0cNBhAPDAQLEBAMAwtBACEDIAQhAkEALQCwCA0GDAULAkACQCAFDgUBBQUFAAELIAQQEUUNASACQQRqQe0AQfAAQe8AQfIAQfQAEBJFDQEQEwwBC0EALwHICA0AIAQQEUUNACACQQRqQfgAQfAAQe8AQfIAQfQAEBJFDQAQFEEALQDECA0AQQBBACgC4AgiAjYCzAgMBAtBAEEAKALgCDYCzAgLQQAoAuQIIQNBACgC4AghAgwACwtBACACNgLgCEEAQQA6AMQICwNAQQAgAkECaiIDNgLgCAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACQQAoAuQITw0AIAMvAQAiBEF3akEFSQ0OIARBYGoiBUEJTQ0BIARBoH9qIgVBCU0NAgJAAkACQCAEQYV/aiIDQQJNDQAgBEEvRw0QIAIvAQQiAkEqRg0BIAJBL0cNAhAPDBELAkACQCADDgMAEQEACwJAQQAoAswIIgQvAQBBKUcNAEEAKAKkCCICRQ0AIAIoAgQgBEcNAEEAQQAoAqgIIgI2AqQIAkAgAkUNACACQQA2AhQMAQtBAEEANgKUCAsgAUEALwHICCICakEALQDcCDoAAEEAIAJBAWo7AcgIQQAoAtgIIAJBAnRqIAQ2AgBBAEEAOgDcCAwQC0EALwHICCICRQ0JQQAgAkF/aiIDOwHICAJAIAJBAC8ByggiBEcNAEEAQQAvAcYIQX9qIgI7AcYIQQBBACgC1AggAkH//wNxQQF0ai8BADsByggMCAsgBEH//wNGDQ8gA0H//wNxIARJDQkMDwsQEAwPCwJAAkACQAJAQQAoAswIIgQvAQAiAhAVRQ0AIAJBVWoiA0EDSw0CAkACQAJAIAMOBAEFAgABCyAEQX5qLwEAQVBqQf//A3FBCkkNAwwECyAEQX5qLwEAQStGDQIMAwsgBEF+ai8BAEEtRg0BDAILAkAgAkH9AEYNACACQSlHDQFBACgC2AhBAC8ByAhBAnRqKAIAEBZFDQEMAgtBACgC2AhBAC8ByAgiA0ECdGooAgAQFw0BIAEgA2otAAANAQsgBBAYDQAgAkUNAEEBIQQgAkEvRkEALQDQCEEAR3FFDQELEBlBACEEC0EAIAQ6ANAIDA0LQQAvAcoIQf//A0ZBAC8ByAhFcUEALQCwCEVxIQMMDwsgBQ4KDAsBCwsLCwIHBAwLIAUOCgIKCgcKCQoKCggCCxAaDAkLEBsMCAsQHAwHC0EALwHICCICDQELEB1BACEDDAgLQQAgAkF/aiIEOwHICEEAKAKkCCICRQ0EIAIoAhBBACgC2AggBEH//wNxQQJ0aigCAEcNBCACIAM2AgQMBAtBAEEALwHICCICQQFqOwHICEEAKALYCCACQQJ0akEAKALMCDYCAAwDCyADEBFFDQIgAi8BCkHzAEcNAiACLwEIQfMARw0CIAIvAQZB4QBHDQIgAi8BBEHsAEcNAgJAAkAgAi8BDCIEQXdqIgJBF0sNAEEBIAJ0QZ+AgARxDQELIARBoAFHDQMLQQBBAToA3AgMAgsgAxARRQ0BIAJBBGpB7QBB8ABB7wBB8gBB9AAQEkUNARATDAELQQAvAcgIDQAgAxARRQ0AIAJBBGpB+ABB8ABB7wBB8gBB9AAQEkUNABAUC0EAQQAoAuAINgLMCAtBACgC4AghAgwACwsgAUGA8ABqJAAgAwtQAQR/QQAoAuAIQQJqIQBBACgC5AghAQJAA0AgACICQX5qIAFPDQEgAkECaiEAIAIvAQBBdmoiA0EDSw0AIAMOBAEAAAEBCwtBACACNgLgCAt3AQJ/QQBBACgC4AgiAEECajYC4AggAEEGaiEAQQAoAuQIIQEDQAJAAkACQCAAQXxqIAFPDQAgAEF+ai8BAEEqRw0CIAAvAQBBL0cNAkEAIABBfmo2AuAIDAELIABBfmohAAtBACAANgLgCA8LIABBAmohAAwACwsdAAJAQQAoApAIIABHDQBBAQ8LIABBfmovAQAQHgs/AQF/QQAhBgJAIAAvAQggBUcNACAALwEGIARHDQAgAC8BBCADRw0AIAAvAQIgAkcNACAALwEAIAFGIQYLIAYL6QIBBH9BAEEAKALgCCIAQQxqIgE2AuAIAkACQAJAAkACQBAmIgJBWWoiA0EHTQ0AIAJBIkYNAiACQfsARg0CDAELAkACQCADDggDAQIDAgICAAMLQQBBACgC4AhBAmo2AuAIECZB7QBHDQNBACgC4AgiAy8BBkHhAEcNAyADLwEEQfQARw0DIAMvAQJB5QBHDQNBACgCzAgvAQBBLkYNAyAAIAAgA0EIakEAKAKICBABDwtBACgC2AhBAC8ByAgiA0ECdGogADYCAEEAIANBAWo7AcgIQQAoAswILwEAQS5GDQIgAEEAKALgCEECakEAIAAQAQ8LQQAoAuAIIAFGDQELQQAvAcgIDQFBACgC4AghA0EAKALkCCEBAkADQCADIAFPDQECQAJAIAMvAQAiAkEnRg0AIAJBIkcNAQsgACACECcPC0EAIANBAmoiAzYC4AgMAAsLEB0LDwtBAEEAKALgCEF+ajYC4AgLiAYBBH9BAEEAKALgCCIAQQxqIgE2AuAIECYhAgJAAkACQAJAAkACQEEAKALgCCIDIAFHDQAgAhAoRQ0BCwJAAkACQAJAIAJBn39qIgFBC00NAAJAAkAgAkEqRg0AIAJB9gBGDQUgAkH7AEcNA0EAIANBAmo2AuAIECYhA0EAKALgCCEBA0AgA0H//wNxECkaQQAoAuAIIQIQJhoCQCABIAIQKiIDQSxHDQBBAEEAKALgCEECajYC4AgQJiEDC0EAKALgCCECAkAgA0H9AEYNACACIAFGDQwgAiEBIAJBACgC5AhNDQEMDAsLQQAgAkECajYC4AgMAQtBACADQQJqNgLgCBAmGkEAKALgCCICIAIQKhoLECYhAgwBCyABDgwEAAEGAAUAAAAAAAIEC0EAKALgCCEDAkAgAkHmAEcNACADLwEGQe0ARw0AIAMvAQRB7wBHDQAgAy8BAkHyAEcNAEEAIANBCGo2AuAIIAAQJhAnDwtBACADQX5qNgLgCAwCCwJAIAMvAQhB8wBHDQAgAy8BBkHzAEcNACADLwEEQeEARw0AIAMvAQJB7ABHDQAgAy8BChAeRQ0AQQAgA0EKajYC4AgQJiECQQAoAuAIIQMgAhApGiADQQAoAuAIEAJBAEEAKALgCEF+ajYC4AgPC0EAIANBBGoiAzYC4AgLQQAgA0EEaiICNgLgCEEAQQA6AMQIA0BBACACQQJqNgLgCBAmIQJBACgC4AghAwJAAkAgAhApIgJBPUYNACACQfsARg0AIAJB2wBHDQELQQBBACgC4AhBfmo2AuAIDwtBACgC4AgiAiADRg0BIAMgAhACECYhA0EAKALgCCECIANBLEYNAAtBACACQX5qNgLgCA8LDwtBACADQQpqNgLgCBAmGkEAKALgCCEDC0EAIANBEGo2AuAIAkAQJiICQSpHDQBBAEEAKALgCEECajYC4AgQJiECC0EAKALgCCEDIAIQKRogA0EAKALgCBACQQBBACgC4AhBfmo2AuAIDwsgAyADQQ5qEAIPCxAdC3UBAX8CQAJAIABBX2oiAUEFSw0AQQEgAXRBMXENAQsgAEFGakH//wNxQQZJDQAgAEFYakH//wNxQQdJIABBKUdxDQACQCAAQaV/aiIBQQNLDQAgAQ4EAQAAAQELIABB/QBHIABBhX9qQf//A3FBBElxDwtBAQs9AQF/QQEhAQJAIABB9wBB6ABB6QBB7ABB5QAQHw0AIABB5gBB7wBB8gAQIA0AIABB6QBB5gAQISEBCyABC60BAQN/QQEhAQJAAkACQAJAAkACQAJAIAAvAQAiAkFFaiIDQQNNDQAgAkGbf2oiA0EDTQ0BIAJBKUYNAyACQfkARw0CIABBfmpB5gBB6QBB7gBB4QBB7ABB7AAQIg8LIAMOBAIBAQUCCyADDgQCAAADAgtBACEBCyABDwsgAEF+akHlAEHsAEHzABAgDwsgAEF+akHjAEHhAEH0AEHjABAjDwsgAEF+ai8BAEE9RgvtAwECf0EAIQECQCAALwEAQZx/aiICQRNLDQACQAJAAkACQAJAAkACQAJAIAIOFAABAggICAgICAgDBAgIBQgGCAgHAAsgAEF+ai8BAEGXf2oiAkEDSw0HAkACQCACDgQACQkBAAsgAEF8akH2AEHvABAhDwsgAEF8akH5AEHpAEHlABAgDwsgAEF+ai8BAEGNf2oiAkEBSw0GAkACQCACDgIAAQALAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQggAEF6akHlABAkDwsgAEF6akHjABAkDwsgAEF8akHkAEHlAEHsAEHlABAjDwsgAEF+ai8BAEHvAEcNBSAAQXxqLwEAQeUARw0FAkAgAEF6ai8BACICQfAARg0AIAJB4wBHDQYgAEF4akHpAEHuAEHzAEH0AEHhAEHuABAiDwsgAEF4akH0AEH5ABAhDwtBASEBIABBfmoiAEHpABAkDQQgAEHyAEHlAEH0AEH1AEHyABAfDwsgAEF+akHkABAkDwsgAEF+akHkAEHlAEHiAEH1AEHnAEHnAEHlABAlDwsgAEF+akHhAEH3AEHhAEHpABAjDwsCQCAAQX5qLwEAIgJB7wBGDQAgAkHlAEcNASAAQXxqQe4AECQPCyAAQXxqQfQAQegAQfIAECAhAQsgAQuDAQEDfwNAQQBBACgC4AgiAEECaiIBNgLgCAJAAkACQCAAQQAoAuQITw0AIAEvAQAiAUGlf2oiAkEBTQ0CAkAgAUF2aiIAQQNNDQAgAUEvRw0EDAILIAAOBAADAwAACxAdCw8LAkACQCACDgIBAAELQQAgAEEEajYC4AgMAQsQKxoMAAsLkQEBBH9BACgC4AghAEEAKALkCCEBAkADQCAAIgJBAmohACACIAFPDQECQCAALwEAIgNB3ABGDQACQCADQXZqIgJBA00NACADQSJHDQJBACAANgLgCA8LIAIOBAIBAQICCyACQQRqIQAgAi8BBEENRw0AIAJBBmogACACLwEGQQpGGyEADAALC0EAIAA2AuAIEB0LkQEBBH9BACgC4AghAEEAKALkCCEBAkADQCAAIgJBAmohACACIAFPDQECQCAALwEAIgNB3ABGDQACQCADQXZqIgJBA00NACADQSdHDQJBACAANgLgCA8LIAIOBAIBAQICCyACQQRqIQAgAi8BBEENRw0AIAJBBmogACACLwEGQQpGGyEADAALC0EAIAA2AuAIEB0LyQEBBX9BACgC4AghAEEAKALkCCEBA0AgACICQQJqIQACQAJAIAIgAU8NACAALwEAIgNBpH9qIgRBBE0NASADQSRHDQIgAi8BBEH7AEcNAkEAQQAvAcYIIgBBAWo7AcYIQQAoAtQIIABBAXRqQQAvAcoIOwEAQQAgAkEEajYC4AhBAEEALwHICEEBaiIAOwHKCEEAIAA7AcgIDwtBACAANgLgCBAdDwsCQAJAIAQOBQECAgIAAQtBACAANgLgCA8LIAJBBGohAAwACws1AQF/QQBBAToAsAhBACgC4AghAEEAQQAoAuQIQQJqNgLgCEEAIABBACgCkAhrQQF1NgLACAs0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABAocSEBCyABC0kBA39BACEGAkAgAEF4aiIHQQAoApAIIghJDQAgByABIAIgAyAEIAUQEkUNAAJAIAcgCEcNAEEBDwsgAEF2ai8BABAeIQYLIAYLWQEDf0EAIQQCQCAAQXxqIgVBACgCkAgiBkkNACAALwEAIANHDQAgAEF+ai8BACACRw0AIAUvAQAgAUcNAAJAIAUgBkcNAEEBDwsgAEF6ai8BABAeIQQLIAQLTAEDf0EAIQMCQCAAQX5qIgRBACgCkAgiBUkNACAALwEAIAJHDQAgBC8BACABRw0AAkAgBCAFRw0AQQEPCyAAQXxqLwEAEB4hAwsgAwtLAQN/QQAhBwJAIABBdmoiCEEAKAKQCCIJSQ0AIAggASACIAMgBCAFIAYQLEUNAAJAIAggCUcNAEEBDwsgAEF0ai8BABAeIQcLIAcLZgEDf0EAIQUCQCAAQXpqIgZBACgCkAgiB0kNACAALwEAIARHDQAgAEF+ai8BACADRw0AIABBfGovAQAgAkcNACAGLwEAIAFHDQACQCAGIAdHDQBBAQ8LIABBeGovAQAQHiEFCyAFCz0BAn9BACECAkBBACgCkAgiAyAASw0AIAAvAQAgAUcNAAJAIAMgAEcNAEEBDwsgAEF+ai8BABAeIQILIAILTQEDf0EAIQgCQCAAQXRqIglBACgCkAgiCkkNACAJIAEgAiADIAQgBSAGIAcQLUUNAAJAIAkgCkcNAEEBDwsgAEFyai8BABAeIQgLIAgLdgEDf0EAKALgCCEAAkADQAJAIAAvAQAiAUF3akEFSQ0AIAFBIEYNACABQaABRg0AIAFBL0cNAgJAIAAvAQIiAEEqRg0AIABBL0cNAxAPDAELEBALQQBBACgC4AgiAkECaiIANgLgCCACQQAoAuQISQ0ACwsgAQtYAAJAAkAgAUEiRg0AIAFBJ0cNAUEAKALgCCEBEBsgACABQQJqQQAoAuAIQQAoAoQIEAEPC0EAKALgCCEBEBogACABQQJqQQAoAuAIQQAoAoQIEAEPCxAdC2gBAn9BASEBAkACQCAAQV9qIgJBBUsNAEEBIAJ0QTFxDQELIABB+P8DcUEoRg0AIABBRmpB//8DcUEGSQ0AAkAgAEGlf2oiAkEDSw0AIAJBAUcNAQsgAEGFf2pB//8DcUEESSEBCyABC20BAn8CQAJAA0ACQCAAQf//A3EiAUF3aiICQRdLDQBBASACdEGfgIAEcQ0CCyABQaABRg0BIAAhAiABECgNAkEAIQJBAEEAKALgCCIAQQJqNgLgCCAALwECIgANAAwCCwsgACECCyACQf//A3ELXAECfwJAQQAoAuAIIgIvAQAiA0HhAEcNAEEAIAJBBGo2AuAIECYhAkEAKALgCCEAIAIQKRpBACgC4AghARAmIQNBACgC4AghAgsCQCACIABGDQAgACABEAILIAMLiQEBBX9BACgC4AghAEEAKALkCCEBA38gAEECaiECAkACQCAAIAFPDQAgAi8BACIDQaR/aiIEQQFNDQEgAiEAIANBdmoiA0EDSw0CIAIhACADDgQAAgIAAAtBACACNgLgCBAdQQAPCwJAAkAgBA4CAQABC0EAIAI2AuAIQd0ADwsgAEEEaiEADAALC0kBAX9BACEHAkAgAC8BCiAGRw0AIAAvAQggBUcNACAALwEGIARHDQAgAC8BBCADRw0AIAAvAQIgAkcNACAALwEAIAFGIQcLIAcLUwEBf0EAIQgCQCAALwEMIAdHDQAgAC8BCiAGRw0AIAAvAQggBUcNACAALwEGIARHDQAgAC8BBCADRw0AIAAvAQIgAkcNACAALwEAIAFGIQgLIAgLCx8CAEGACAsCAAAAQYQICxABAAAAAgAAAAAEAABwOAAA", typeof atob == "function" ? Uint8Array.from(atob(E), (A2) => A2.charCodeAt(0)) : Buffer.from(E, "base64"))).then(WebAssembly.instantiate).then(({exports: A2}) => {
  B = A2;
});
var E;

// src/state/file/utils/registry.ts
function isRegistryImport(importPath) {
  return importPath.startsWith("opstrace.com/x/") || importPath.startsWith("https://cdn.skypack.dev/");
}
function cleanImport(importPath) {
  return importPath.replace(/^opstrace\.com\/x\//, "").replace(/^.+cdn\.skypack\.dev\//, "");
}

// src/state/file/utils/path.ts
function join2(...paths) {
  var parts = [];
  for (var i = 0, l = paths.length; i < l; i++) {
    parts = parts.concat(paths[i].split("/"));
  }
  var newParts = [];
  for (i = 0, l = parts.length; i < l; i++) {
    var part = parts[i];
    if (!part || part === ".")
      continue;
    if (part === "..")
      newParts.pop();
    else
      newParts.push(part);
  }
  if (parts[0] === "")
    newParts.unshift("");
  return newParts.join("/") || (newParts.length ? "/" : ".");
}
function dirname3(path3) {
  return join2(path3, "..");
}

// src/state/file/Registry.ts
function parseRawPackageImport(spec) {
  const impParts = spec.split("/");
  if (spec.startsWith("@")) {
    const [scope, name2, ...rest2] = impParts;
    return [`${scope}/${name2}`, rest2.join("/") || null];
  }
  const [name, ...rest] = impParts;
  return [name, rest.join("/") || null];
}
var Registry2 = class {
  constructor() {
    this.loadedTypes = new Map();
    this.packageSpecs = new Set();
    this.fetchCache = new Map();
  }
  async parseAndLoadImports(content) {
    await init;
    try {
      const [imports] = parse3(content);
      for (const {s, e} of imports) {
        const importPath = content.substring(s, e);
        if (isRegistryImport(importPath)) {
          this.loadTypings(cleanImport(importPath));
        }
      }
    } catch (err) {
      console.error(err, content);
    }
  }
  async fetchText(url) {
    return this.fetch(url).then((resp) => resp.ok ? resp.clone().text() : "");
  }
  async fetchJson(url) {
    return this.fetch(url).then((resp) => resp.ok ? resp.clone().json() : {});
  }
  async fetch(url) {
    const cached = this.fetchCache.get(url);
    if (cached) {
      return cached;
    }
    const res = fetch(url);
    this.fetchCache.set(url, res);
    return res;
  }
  async loadTypings(packageSpec) {
    if (this.packageSpecs.has(packageSpec)) {
      return;
    }
    this.packageSpecs.add(packageSpec);
    if (packageSpec.startsWith("sdk/")) {
      return;
    }
    const types4 = await this.fetchPackageTypings(packageSpec);
    if (!types4) {
      return;
    }
    await this.loadDependencies(types4);
  }
  async loadDependencies(types4) {
    await init;
    if (!types4.content) {
      return;
    }
    const [imports] = parse3(types4.content);
    let delta = 0;
    let updatedContent = types4.content;
    for (const {s, e} of imports) {
      const importPath = types4.content.substring(s, e);
      if (importPath.startsWith(".")) {
        const url = join2(dirname3(types4.url), importPath.endsWith(".d.ts") ? importPath : importPath + ".d.ts");
        this.fetchText(url).then((content) => ({
          url,
          content,
          packageSpec: types4.packageSpec,
          deps: types4.deps
        })).then((depTypes) => this.loadDependencies(depTypes));
      } else {
        const packageSemver = types4.deps[importPath] || types4.deps["@types/" + importPath] || "latest";
        const depsPackageSpec = importPath + "@" + packageSemver;
        updatedContent = updatedContent.slice(0, s + delta) + depsPackageSpec + updatedContent.slice(e + delta);
        delta += depsPackageSpec.length - importPath.length;
        this.fetchPackageTypings(depsPackageSpec).then((depTypes) => {
          if (depTypes) {
            this.loadDependencies(depTypes);
          }
        });
      }
    }
    this.addTypings({...types4, content: updatedContent});
  }
  addTypings(types4) {
    const existingTypes = this.loadedTypes.get(types4.packageSpec) || [];
    this.loadedTypes.set(types4.packageSpec, [...existingTypes, types4]);
    let filepath = types4.packageSpec + "/" + types4.url.replace(/^.+\/unpkg\.com\/@types\//, "").replace(/^.+\/unpkg\.com\//, "").split("/").slice(1).join("/");
    opScriptDefaults.addExtraLib(types4.content, `file:///node_modules/opstrace.com/x/${filepath}`);
  }
  async fetchPackageJson(packageSpec) {
    const [packageName] = parseRawPackageImport(packageSpec);
    return this.fetchJson(`https://unpkg.com/${packageName}/package.json`);
  }
  async fetchPackageTypes(packageSpec, types4, deps) {
    packageSpec = packageSpec.endsWith("/" + types4) ? packageSpec.substr(0, packageSpec.length - types4.length - 1) : packageSpec;
    const url = join2(`https://unpkg.com/`, packageSpec, types4.endsWith(".d.ts") ? types4 : types4 + ".d.ts");
    return this.fetchText(url).then((content) => ({
      url,
      content,
      packageSpec,
      deps
    }));
  }
  async fetchAtTypes(packageSpec) {
    let deps = {};
    let typings = "index.d.ts";
    const [packageName, packagePath] = parseRawPackageImport(packageSpec);
    if (packagePath) {
      typings = packagePath + ".d.ts";
    }
    packageSpec = packageSpec.endsWith("/" + packagePath) ? packageSpec.substr(0, packageSpec.length - (packagePath || "").length - 1) : packageSpec;
    try {
      deps = this.fetchJson(`https://unpkg.com/@types/${packageName.replace(/^@/, "").replace("/", "__")}/package.json`).then((content) => {
        if (content.typings) {
          typings = content.typings;
        }
        if (content.types) {
          typings = content.types;
        }
        return {
          ...content.devDependencies || {},
          ...content.dependencies || {}
        };
      });
    } catch (err) {
    }
    const url = join2(`https://unpkg.com/@types`, packageName.replace(/^@/, "").replace("/", "__"), typings);
    return this.fetchText(url).then((content) => ({
      url,
      content,
      packageSpec,
      deps
    }));
  }
  async fetchPackageTypings(packageSpec) {
    if (this.loadedTypes.has(packageSpec)) {
      return null;
    }
    const packagePath = parseRawPackageImport(packageSpec)[1];
    let packageJson = {
      devDependencies: {},
      dependencies: {}
    };
    if (!packagePath) {
      try {
        packageJson = await this.fetchPackageJson(packageSpec);
      } catch (err) {
        console.error(`package '${packageSpec}' does not exist`);
        return null;
      }
    }
    const typings = packageJson.types || packageJson.typings || null;
    if (typings) {
      try {
        return await this.fetchPackageTypes(packageSpec, packagePath ? packagePath + ".d.ts" : typings, {
          ...packageJson.devDependencies || {},
          ...packageJson.dependencies || {}
        });
      } catch (err) {
        console.warn(`package types '${typings}' for package '${packageSpec}' do not exist, trying @types/`);
      }
    }
    try {
      return await this.fetchAtTypes(packageSpec);
    } catch (err) {
      console.error(`package types '@types/${packageSpec}' do not exist`);
      return null;
    }
  }
};
var Registry_default = new Registry2();

// src/state/file/LiveClient.ts
var ViewerColors = [
  [0, 200, 255],
  [255, 200, 0],
  [0, 255, 200],
  [100, 0, 255],
  [255, 0, 0],
  [255, 0, 200],
  [0, 100, 255],
  [200, 255, 0],
  [0, 255, 0],
  [200, 0, 255],
  [0, 0, 255],
  [0, 255, 100],
  [255, 0, 100],
  [100, 255, 0],
  [255, 100, 0]
];
function createCursorStyle(color) {
  return `${import_glamor.css({
    display: "inherit",
    position: "absolute",
    backgroundColor: rgba([...color, 0.8]),
    width: "2px !important",
    height: "100%",
    cursor: "text",
    zindex: 200
  })}`;
}
function createSecondaryCursorStyle(color) {
  return `${import_glamor.css({
    backgroundColor: rgba([...color, 0.6]),
    width: "2px !important"
  })}`;
}
function createSelectionStyle(color, opacity) {
  return `${import_glamor.css({
    backgroundColor: rgba([...color, opacity]),
    borderRadius: 3,
    minWidth: 8
  })}`;
}
function rgba(arr) {
  if (arr.length < 3) {
    throw Error("not a valid rgb array");
  }
  return arr.length > 3 ? `rgba(${arr[0]}, ${arr[1]}, ${arr[2]}, ${arr[3]})` : `rgb(${arr[0]}, ${arr[1]}, ${arr[2]})`;
}
var LiveClient = class {
  constructor(options) {
    this.isEditor = false;
    this.viewers = [];
    this.suppress = false;
    this.viewerClasses = {};
    this.vsd = {};
    this.modelDisposables = [];
    this.editorDisposables = [];
    this.getSelectionDecorationId = (userId) => [userId, this.file.id].join("|");
    this.cleanViewerSelections = (viewerSelectionsToKeep) => {
      const existingVsds = Object.keys(this.vsd);
      const newViewerSelections = {};
      for (let i = 0; i < viewerSelectionsToKeep.length; i++) {
        newViewerSelections[viewerSelectionsToKeep[i].userId] = viewerSelectionsToKeep[i];
      }
      existingVsds.forEach((existingDecorationId) => {
        const userId = existingDecorationId.split("|")[0];
        if (!newViewerSelections[userId]) {
          const decorationId = this.getSelectionDecorationId(userId);
          this.vsd[decorationId] = this.model.deltaDecorations(this.vsd[decorationId] || [], []);
        }
      });
    };
    this.file = options.file;
    this.model = options.model;
    this.onViewersChanged = options.onViewersChanged;
    this.onMessage = this.onMessage.bind(this);
    this.onLocalChange = this.onLocalChange.bind(this);
    this.debouncedOnContentChanged = import_lodash.debounce(this.debouncedOnContentChanged.bind(this), 200);
    this.modelDisposables.push(this.model.onDidChangeContent(this.onLocalChange));
    websocket_default.listen(this.onMessage);
    websocket_default.emit(subscribeFile(this.file.id));
  }
  debouncedOnContentChanged(e) {
    (async () => {
      const output = await this.getEmitOutput();
      if (output.js) {
        Registry_default.parseAndLoadImports(output.js);
      }
      this.sendEmitOutput(output);
    })();
  }
  async getEmitOutput() {
    const worker = await getOpScriptWorker();
    const output = await worker.emitFile(this.model.uri.toString());
    return output;
  }
  sendEmitOutput(output) {
    websocket_default.emit(compilerOutput({fileId: this.file.id, output}));
  }
  attachEditor(editor3) {
    this.editorDisposables.push(editor3.onDidChangeCursorSelection((e) => {
      if (this.suppress) {
        return;
      }
      this.currentSelection = viewerSelectionChange({
        selection: {
          primary: this.getSelection(e.selection),
          secondary: e.secondarySelections.map((s) => this.getSelection(s)),
          source: e.source
        },
        fileId: this.file.id
      });
      websocket_default.emit(this.currentSelection);
    }));
    this.editor = editor3;
    (async () => {
      const output = await this.getEmitOutput();
      if (output.js) {
        Registry_default.parseAndLoadImports(output.js);
      }
    })();
  }
  detachEditor() {
    this.editorDisposables.forEach((d) => d.dispose());
    this.editorDisposables = [];
    this.editor = void 0;
  }
  dispose() {
    websocket_default.unlisten(this.onMessage);
    this.modelDisposables.forEach((d) => d.dispose());
    this.editorDisposables.forEach((d) => d.dispose());
  }
  getSelection(selection) {
    const startPrimarySelection = this.model.getOffsetAt({
      lineNumber: selection.startLineNumber,
      column: selection.startColumn
    });
    const endPrimarySelection = this.model.getOffsetAt({
      lineNumber: selection.endLineNumber,
      column: selection.endColumn
    });
    return {
      selection: startPrimarySelection === endPrimarySelection ? [] : [startPrimarySelection, endPrimarySelection],
      cursorPosition: this.model.getOffsetAt({
        lineNumber: selection.positionLineNumber,
        column: selection.positionColumn
      })
    };
  }
  setEditable(editable) {
    this.editor?.updateOptions({readOnly: !editable});
  }
  onLocalChange(e) {
    if (this.suppress) {
      return;
    }
    this.debouncedOnContentChanged(e);
    const ops = [];
    e.changes.forEach((c) => {
      const {rangeOffset, rangeLength, text} = c;
      if (text.length > 0 && rangeLength === 0) {
        ops.push([rangeOffset, text]);
      } else if (text.length > 0 && rangeLength > 0) {
        ops.push([rangeOffset, text], [rangeOffset + text.length, rangeLength]);
      } else if (text.length === 0 && rangeLength > 0) {
        ops.push([rangeOffset, rangeLength]);
      } else {
        throw new Error("Unexpected change: " + JSON.stringify(c));
      }
    });
    this.sendOps(ops);
  }
  onRemoteChange(ops) {
    this.suppress = true;
    this.setEditable(true);
    for (const [offset, change] of ops) {
      const pos = this.model.getPositionAt(offset);
      const start = pos;
      let edits = [];
      if (typeof change === "string") {
        edits.push({
          range: new Range(start.lineNumber, start.column, start.lineNumber, start.column),
          text: change,
          forceMoveMarkers: true
        });
      } else {
        const end = this.model.getPositionAt(offset + change);
        edits.push({
          range: new Range(start.lineNumber, start.column, end.lineNumber, end.column),
          text: null,
          forceMoveMarkers: true
        });
      }
      this.editor?.executeEdits("remote", edits);
    }
    this.setEditable(false);
    this.suppress = false;
    if (this.editor) {
      (async () => {
        const output = await this.getEmitOutput();
        if (output.js) {
          Registry_default.parseAndLoadImports(output.js);
        }
      })();
    }
  }
  onMessage(action) {
    if (import_typesafe_actions12.isActionOf(edit, action) && action.payload.fileId === this.file.id) {
      this.onRemoteChange(action.payload.ops);
    }
    if (import_typesafe_actions12.isActionOf(viewers, action) && action.payload.fileId === this.file.id) {
      this.onViewersChange(action);
    }
    if (import_typesafe_actions12.isActionOf(viewerSelectionChange, action) && action.payload.fileId === this.file.id) {
      this.updateViewerSelections(action);
    }
  }
  onViewersChange(action) {
    if (this.currentSelection) {
      websocket_default.emit(this.currentSelection);
    }
    const {viewers: viewers2, editor: editor3} = action.payload;
    this.clearViewerSelections();
    this.currentUser = getCurrentUser(getStore().getState());
    if (!this.currentUser) {
      throw Error("no current user defined");
    }
    this.isEditor = this.currentUser?.email === editor3;
    if (this.isEditor) {
      this.clearViewerSelections(this.currentUser.opaque_id);
    }
    this.viewers = viewers2.map((v, idx) => {
      const existingViewer = this.viewers.find((ev) => ev.email === v);
      return {
        email: v,
        color: ViewerColors[idx % ViewerColors.length],
        isEditor: v === editor3,
        selection: existingViewer?.selection || {
          primary: {
            cursorPosition: 0,
            selection: []
          },
          secondary: [],
          source: "LiveClient"
        }
      };
    });
    this.setEditable(this.isEditor);
    this.onViewersChanged();
  }
  sendOps(ops) {
    websocket_default.emit(edit({
      fileId: this.file.id,
      ops
    }));
  }
  clearViewerSelections(userId) {
    const decorations = Object.keys(this.vsd).filter((d) => userId ? d.startsWith(userId) : true);
    decorations.forEach((decorationId) => {
      if (!userId || decorationId.startsWith(this.getSelectionDecorationId(userId))) {
        this.vsd[decorationId] = this.model.deltaDecorations(this.vsd[decorationId] || [], []);
      }
    });
  }
  updateViewerSelections(action) {
    const {selection, email} = action.payload;
    const existingViewer = this.viewers.find((ev) => ev.email === email);
    if (!existingViewer) {
      return;
    }
    existingViewer.selection = selection;
    const viewerSelections = this.getSelections().filter((s) => s.userId !== this.currentUser?.opaque_id);
    this.cleanViewerSelections(viewerSelections);
    viewerSelections.forEach((viewerSelection) => {
      const {userId} = viewerSelection;
      const decorationId = this.getSelectionDecorationId(userId);
      if (viewerSelection.selection === null) {
        this.vsd[decorationId] = this.model.deltaDecorations(this.vsd[decorationId] || [], []);
        return;
      }
      const decorations = [];
      const {selection: selection2, color} = viewerSelection;
      const getCursorDecoration = (position, className) => {
        const cursorPos = this.model.getPositionAt(position);
        return {
          range: new monaco.Range(cursorPos.lineNumber, cursorPos.column, cursorPos.lineNumber, cursorPos.column),
          options: {
            className: `${this.viewerClasses[className]}`
          }
        };
      };
      const getSelectionDecoration = (start, end, className) => {
        const from2 = this.model.getPositionAt(start);
        const to = this.model.getPositionAt(end);
        return {
          range: new monaco.Range(from2.lineNumber, from2.column, to.lineNumber, to.column),
          options: {
            className: this.viewerClasses[className],
            stickiness: 3
          }
        };
      };
      const prefix2 = color.join("-") + "_" + userId;
      const cursorClassName = prefix2 + "-c";
      const nameTagClassName = prefix2 + "-nt";
      const secondaryCursorClassName = prefix2 + "-sc";
      const selectionClassName = prefix2 + "-s";
      const secondarySelectionClassName = prefix2 + "-ss";
      if (!this.viewerClasses[cursorClassName]) {
        this.viewerClasses[cursorClassName] = createCursorStyle(color);
      }
      if (!this.viewerClasses[secondaryCursorClassName]) {
        this.viewerClasses[secondaryCursorClassName] = createSecondaryCursorStyle(color);
      }
      if (!this.viewerClasses[selectionClassName]) {
        this.viewerClasses[selectionClassName] = createSelectionStyle(color, 0.3);
      }
      if (!this.viewerClasses[secondarySelectionClassName]) {
        this.viewerClasses[secondarySelectionClassName] = createSelectionStyle(color, 0.2);
      }
      decorations.push(getCursorDecoration(selection2.primary.cursorPosition, cursorClassName));
      if (selection2.primary.selection.length) {
        decorations.push(getSelectionDecoration(selection2.primary.selection[0], selection2.primary.selection[1], selectionClassName));
      }
      if (selection2.secondary.length) {
        selection2.secondary.forEach((s) => {
          decorations.push(getCursorDecoration(s.cursorPosition, secondaryCursorClassName));
          if (s.selection.length) {
            decorations.push(getSelectionDecoration(s.selection[0], s.selection[1], secondarySelectionClassName));
          }
        });
      }
      this.vsd[decorationId] = this.model.deltaDecorations(this.vsd[decorationId] || [], decorations);
      if (selection2.source !== "modelChange") {
        const decoration2 = this.model.deltaDecorations([], [
          getCursorDecoration(selection2.primary.cursorPosition, nameTagClassName)
        ]);
        this.vsd[decorationId].push(...decoration2);
      }
    });
  }
  getSelections() {
    const selections = [];
    const users = getUserList(getStore().getState());
    this.viewers.forEach((viewer) => {
      const user = users.find((u) => u.email === viewer.email);
      if (user && viewer.selection) {
        selections.push({
          userId: user.opaque_id,
          color: viewer.color,
          name: user.username || user.email,
          selection: viewer.selection
        });
      }
    });
    return selections;
  }
};
var LiveClient_default = LiveClient;

// src/state/file/TextFileModel.ts
var TextFileModel = class {
  constructor(file) {
    this._emptyArray = [];
    this.disposables = [];
    this.viewerListeners = new Set();
    this.file = file;
    this.live = file.module_version === "latest" && file.branch_name !== "main";
    this.readOnly = !this.live;
    this.contents = file.contents;
    this.model = editor.createModel(file.contents || "", "typescript", getMonacoFileUri(this.file));
    this.maybeSetupLiveClient();
    this.model.updateOptions({tabSize: 2});
  }
  maybeSetupLiveClient() {
    if (this.contents && this.live && !this.liveClient) {
      this.liveClient = new LiveClient_default({
        model: this.model,
        file: this.file,
        onViewersChanged: () => this.onViewersChanged()
      });
    }
  }
  async attachEditor(editor3) {
    await this.loadContents();
    this.editor = editor3;
    this.liveClient?.attachEditor(editor3);
    if (this.monacoEditorViewState) {
      this.editor.restoreViewState(this.monacoEditorViewState);
    }
  }
  detachEditor() {
    this.monacoEditorViewState = this.editor?.saveViewState();
    this.editor = void 0;
    this.liveClient?.detachEditor();
  }
  get viewers() {
    if (!this.liveClient) {
      return this._emptyArray;
    }
    return this.liveClient.viewers;
  }
  async loadContents() {
    if (this.contents)
      return;
    const contents = await this.getContents();
    if (contents) {
      this.contents = contents;
      this.model.setValue(contents);
      this.maybeSetupLiveClient();
    }
  }
  onViewersChange(callback) {
    this.viewerListeners.add(callback);
    return () => {
      this.viewerListeners.delete(callback);
    };
  }
  onViewersChanged() {
    for (const cb of this.viewerListeners) {
      cb();
    }
  }
  dispose() {
    websocket_default.emit(unsubscribeFile(this.file.id));
    this.liveClient?.dispose();
    this.liveClient = void 0;
    this.disposables.forEach((d) => {
      try {
        d.dispose();
      } catch (err) {
      }
    });
    this.model.dispose();
  }
  getResourceURI(file) {
    return `/modules/${getFileUri(file, {
      branch: this.file.branch_name,
      ext: true
    })}`;
  }
  async loadFromAPI(file) {
    try {
      const res = await import_axios.default.get(this.getResourceURI(file));
      return res.data;
    } catch (err) {
      console.error("loading file failed", err);
    }
    return null;
  }
  async getContents() {
    return await this.loadFromAPI(this.file);
  }
};
var TextFileModel_default = TextFileModel;

// src/state/file/reducer.ts
var FilesInitialState = {
  filesByBranch: {},
  openFiles: [],
  openFileBrowsingHistory: [],
  loaded: {},
  requestOpenFilePending: false
};
var reducer4 = import_typesafe_actions13.createReducer(FilesInitialState).handleAction(set4, (state, action) => {
  const filesByPath = {};
  const files = action.payload.files;
  const branch = action.payload.branch;
  const branchFiles = state.filesByBranch[branch] || {};
  files.forEach((file) => {
    const path3 = getFileUri(file, {branch, ext: true});
    const existingFile = branchFiles[path3];
    filesByPath[path3] = existingFile ? existingFile : new TextFileModel_default({branch_name: branch, ...file});
  });
  return {
    ...state,
    filesByBranch: {...state.filesByBranch, [branch]: filesByPath},
    loaded: {...state.loaded, [branch]: true}
  };
}).handleAction(requestOpenFileWithParams, (state, action) => {
  return {
    ...state,
    ...action.payload,
    requestOpenFilePending: true
  };
}).handleAction(openFile, (state, action) => {
  const fileId = action.payload.file.id;
  const alreadyOpen = state.openFiles.find((f) => f.file.id === fileId);
  const openFiles = alreadyOpen ? state.openFiles : [...state.openFiles, action.payload];
  const browsingHistory = state.openFileBrowsingHistory.filter((id) => id !== fileId).concat([fileId]);
  const filesToKeepOpen = browsingHistory.slice(Math.max(browsingHistory.length - 5, 0));
  const trimmedOpenFiles = openFiles.filter((a) => filesToKeepOpen.find((b) => a.file.id === b));
  return {
    ...state,
    openFiles: trimmedOpenFiles,
    openFileBrowsingHistory: filesToKeepOpen,
    selectedFileId: action.payload.file.id,
    selectedFilePath: action.payload.file.path,
    selectedModuleName: action.payload.file.module_name,
    selectedModuleScope: action.payload.file.module_scope,
    selectedModuleVersion: action.payload.file.module_version,
    requestOpenFilePending: false
  };
}).handleAction(closeFile, (state, action) => {
  if (state.openFiles.length === 1) {
    return state;
  }
  const openFiles = state.openFiles.filter((f) => f.file.id !== action.payload);
  const selectedFileId = state.selectedFileId === action.payload ? openFiles[openFiles.length - 1].file.id : state.selectedFileId;
  return {
    ...state,
    openFileBrowsingHistory: state.openFileBrowsingHistory.filter((id) => id !== action.payload),
    selectedFileId,
    openFiles
  };
});

// src/state/user/reducer.ts
var import_typesafe_actions14 = __toModule(require_typesafe_actions_umd_production());
var UserInitialState = {
  currentUserId: "",
  loading: true,
  currentUserIdLoaded: false,
  users: [],
  activeUsers: []
};
var reducer5 = import_typesafe_actions14.createReducer(UserInitialState).handleAction(setCurrentUser, (state, action) => ({
  ...state,
  currentUserId: action.payload,
  currentUserIdLoaded: true
})).handleAction(setDarkMode, (state, action) => {
  const currentUser = state.users.find((u) => u.opaque_id === state.currentUserId);
  if (!currentUser) {
    return state;
  }
  const users = state.users.filter((u) => u.opaque_id !== state.currentUserId).concat({
    ...currentUser,
    preference: {
      ...currentUser.preference,
      dark_mode: action.payload
    }
  });
  return {
    ...state,
    users
  };
}).handleAction(setUserList, (state, action) => ({
  ...state,
  users: action.payload,
  activeUsers: action.payload.filter((u) => u.active),
  loading: false
}));

// src/state/tenant/reducer.ts
var import_typesafe_actions16 = __toModule(require_typesafe_actions_umd_production());

// src/state/tenant/actions.ts
var import_typesafe_actions15 = __toModule(require_typesafe_actions_umd_production());
var subscribeToTenantList = import_typesafe_actions15.createAction("SUBSCRIBE_TENANT_LIST")();
var unsubscribeFromTenantList = import_typesafe_actions15.createAction("UNSUBSCRIBE_TENANT_LIST")();
var setTenantList = import_typesafe_actions15.createAction("SET_TENANT_LIST")();
var deleteTenant = import_typesafe_actions15.createAction("DELETE_TENANT")();
var addTenant = import_typesafe_actions15.createAction("ADD_TENANT")();

// src/state/tenant/reducer.ts
var TenantInitialState = {
  loading: true,
  tenants: []
};
var reducer6 = import_typesafe_actions16.createReducer(TenantInitialState).handleAction(setTenantList, (state, action) => ({
  ...state,
  tenants: action.payload,
  loading: false
}));

// src/state/sandbox/reducer.ts
var import_typesafe_actions18 = __toModule(require_typesafe_actions_umd_production());

// src/state/sandbox/actions.ts
var actions_exports = {};
__export(actions_exports, {
  disposeSandbox: () => disposeSandbox,
  hmrSandboxUpdate: () => hmrSandboxUpdate,
  initSandbox: () => initSandbox,
  sandboxReady: () => sandboxReady
});
var import_typesafe_actions17 = __toModule(require_typesafe_actions_umd_production());
var initSandbox = import_typesafe_actions17.createAction("SANDBOX_INIT")();
var hmrSandboxUpdate = import_typesafe_actions17.createAction("SANDBOX_HMR_UPDATE")();
var disposeSandbox = import_typesafe_actions17.createAction("SANDBOX_DISPOSE")();
var sandboxReady = import_typesafe_actions17.createAction("SANDBOX_READY")();

// src/state/sandbox/reducer.ts
var SandboxInitialState = {
  ready: false
};
var reducer7 = import_typesafe_actions18.createReducer(SandboxInitialState).handleAction(initSandbox, (state, action) => ({
  ...state,
  moduleUri: action.payload.uri
})).handleAction(sandboxReady, (state, action) => ({
  ...state,
  ready: true
})).handleAction(hmrSandboxUpdate, (state, action) => ({
  ...state,
  refreshRequestId: Date.now()
}));

// src/state/reducer.ts
var mainReducers = {
  users: reducer5,
  files: reducer4,
  tenants: reducer6,
  branches: reducer,
  modules: reducer2,
  moduleVersions: reducer3,
  sandbox: reducer7
};
var mainReducer = import_redux2.combineReducers(mainReducers);

// ../../node_modules/@redux-saga/core/dist/redux-saga-effects.esm.js
var done = function done2(value) {
  return {
    done: true,
    value
  };
};
var qEnd = {};
function safeName(patternOrChannel) {
  if (channel(patternOrChannel)) {
    return "channel";
  }
  if (stringableFunc(patternOrChannel)) {
    return String(patternOrChannel);
  }
  if (func(patternOrChannel)) {
    return patternOrChannel.name;
  }
  return String(patternOrChannel);
}
function fsmIterator(fsm, startState, name) {
  var stateUpdater, errorState, effect2, nextState = startState;
  function next(arg, error) {
    if (nextState === qEnd) {
      return done(arg);
    }
    if (error && !errorState) {
      nextState = qEnd;
      throw error;
    } else {
      stateUpdater && stateUpdater(arg);
      var currentState = error ? fsm[errorState](error) : fsm[nextState]();
      nextState = currentState.nextState;
      effect2 = currentState.effect;
      stateUpdater = currentState.stateUpdater;
      errorState = currentState.errorState;
      return nextState === qEnd ? done(arg) : effect2;
    }
  }
  return makeIterator(next, function(error) {
    return next(null, error);
  }, name);
}
function takeEvery(patternOrChannel, worker) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  var yTake = {
    done: false,
    value: take(patternOrChannel)
  };
  var yFork = function yFork2(ac) {
    return {
      done: false,
      value: fork.apply(void 0, [worker].concat(args, [ac]))
    };
  };
  var action, setAction = function setAction2(ac) {
    return action = ac;
  };
  return fsmIterator({
    q1: function q1() {
      return {
        nextState: "q2",
        effect: yTake,
        stateUpdater: setAction
      };
    },
    q2: function q2() {
      return {
        nextState: "q1",
        effect: yFork(action)
      };
    }
  }, "q1", "takeEvery(" + safeName(patternOrChannel) + ", " + worker.name + ")");
}
function takeLatest(patternOrChannel, worker) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  var yTake = {
    done: false,
    value: take(patternOrChannel)
  };
  var yFork = function yFork2(ac) {
    return {
      done: false,
      value: fork.apply(void 0, [worker].concat(args, [ac]))
    };
  };
  var yCancel = function yCancel2(task3) {
    return {
      done: false,
      value: cancel(task3)
    };
  };
  var task2, action;
  var setTask = function setTask2(t) {
    return task2 = t;
  };
  var setAction = function setAction2(ac) {
    return action = ac;
  };
  return fsmIterator({
    q1: function q1() {
      return {
        nextState: "q2",
        effect: yTake,
        stateUpdater: setAction
      };
    },
    q2: function q2() {
      return task2 ? {
        nextState: "q3",
        effect: yCancel(task2)
      } : {
        nextState: "q1",
        effect: yFork(action),
        stateUpdater: setTask
      };
    },
    q3: function q3() {
      return {
        nextState: "q1",
        effect: yFork(action),
        stateUpdater: setTask
      };
    }
  }, "q1", "takeLatest(" + safeName(patternOrChannel) + ", " + worker.name + ")");
}
function takeEvery$1(patternOrChannel, worker) {
  if (false) {
    validateTakeEffect(takeEvery$1, patternOrChannel, worker);
  }
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  return fork.apply(void 0, [takeEvery, patternOrChannel, worker].concat(args));
}
function takeLatest$1(patternOrChannel, worker) {
  if (false) {
    validateTakeEffect(takeLatest$1, patternOrChannel, worker);
  }
  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }
  return fork.apply(void 0, [takeLatest, patternOrChannel, worker].concat(args));
}

// ../../node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs
var nodejsCustomInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0;
var nodejsCustomInspectSymbol_default = nodejsCustomInspectSymbol;

// ../../node_modules/graphql/jsutils/inspect.mjs
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (_typeof(value)) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? "[function ".concat(value.name, "]") : "[function]";
    case "object":
      if (value === null) {
        return "null";
      }
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (previouslySeenValues.indexOf(value) !== -1) {
    return "[Circular]";
  }
  var seenValues = [].concat(previouslySeenValues, [value]);
  var customInspectFn = getCustomFn(value);
  if (customInspectFn !== void 0) {
    var customValue = customInspectFn.call(value);
    if (customValue !== value) {
      return typeof customValue === "string" ? customValue : formatValue(customValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function formatObject(object2, seenValues) {
  var keys = Object.keys(object2);
  if (keys.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object2) + "]";
  }
  var properties = keys.map(function(key) {
    var value = formatValue(object2[key], seenValues);
    return key + ": " + value;
  });
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array4, seenValues) {
  if (array4.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  var len = Math.min(MAX_ARRAY_LENGTH, array4.length);
  var remaining = array4.length - len;
  var items = [];
  for (var i = 0; i < len; ++i) {
    items.push(formatValue(array4[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push("... ".concat(remaining, " more items"));
  }
  return "[" + items.join(", ") + "]";
}
function getCustomFn(object2) {
  var customInspectFn = object2[String(nodejsCustomInspectSymbol_default)];
  if (typeof customInspectFn === "function") {
    return customInspectFn;
  }
  if (typeof object2.inspect === "function") {
    return object2.inspect;
  }
}
function getObjectTag(object2) {
  var tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object2.constructor === "function") {
    var name = object2.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// ../../node_modules/graphql/jsutils/invariant.mjs
function invariant2(condition, message) {
  var booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// ../../node_modules/graphql/jsutils/defineInspect.mjs
function defineInspect(classObject) {
  var fn = classObject.prototype.toJSON;
  typeof fn === "function" || invariant2(0);
  classObject.prototype.inspect = fn;
  if (nodejsCustomInspectSymbol_default) {
    classObject.prototype[nodejsCustomInspectSymbol_default] = fn;
  }
}

// ../../node_modules/graphql/language/ast.mjs
var Location = /* @__PURE__ */ function() {
  function Location2(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  var _proto = Location2.prototype;
  _proto.toJSON = function toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  };
  return Location2;
}();
defineInspect(Location);
var Token = /* @__PURE__ */ function() {
  function Token2(kind, start, end, line, column, prev, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = prev;
    this.next = null;
  }
  var _proto2 = Token2.prototype;
  _proto2.toJSON = function toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  };
  return Token2;
}();
defineInspect(Token);
function isNode(maybeNode) {
  return maybeNode != null && typeof maybeNode.kind === "string";
}

// ../../node_modules/graphql/language/visitor.mjs
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
  InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var BREAK = Object.freeze({});
function visit(root, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : QueryDocumentKeys;
  var stack = void 0;
  var inArray = Array.isArray(root);
  var keys = [root];
  var index2 = -1;
  var edits = [];
  var node = void 0;
  var key = void 0;
  var parent2 = void 0;
  var path3 = [];
  var ancestors = [];
  var newRoot = root;
  do {
    index2++;
    var isLeaving = index2 === keys.length;
    var isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path3[path3.length - 1];
      node = parent2;
      parent2 = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
        } else {
          var clone = {};
          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
            var k = _Object$keys2[_i2];
            clone[k] = node[k];
          }
          node = clone;
        }
        var editOffset = 0;
        for (var ii = 0; ii < edits.length; ii++) {
          var editKey = edits[ii][0];
          var editValue = edits[ii][1];
          if (inArray) {
            editKey -= editOffset;
          }
          if (inArray && editValue === null) {
            node.splice(editKey, 1);
            editOffset++;
          } else {
            node[editKey] = editValue;
          }
        }
      }
      index2 = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key = parent2 ? inArray ? index2 : keys[index2] : void 0;
      node = parent2 ? parent2[key] : newRoot;
      if (node === null || node === void 0) {
        continue;
      }
      if (parent2) {
        path3.push(key);
      }
    }
    var result = void 0;
    if (!Array.isArray(node)) {
      if (!isNode(node)) {
        throw new Error("Invalid AST Node: ".concat(inspect(node), "."));
      }
      var visitFn = getVisitFn(visitor, node.kind, isLeaving);
      if (visitFn) {
        result = visitFn.call(visitor, node, key, parent2, path3, ancestors);
        if (result === BREAK) {
          break;
        }
        if (result === false) {
          if (!isLeaving) {
            path3.pop();
            continue;
          }
        } else if (result !== void 0) {
          edits.push([key, result]);
          if (!isLeaving) {
            if (isNode(result)) {
              node = result;
            } else {
              path3.pop();
              continue;
            }
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path3.pop();
    } else {
      var _visitorKeys$node$kin;
      stack = {
        inArray,
        index: index2,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];
      index2 = -1;
      edits = [];
      if (parent2) {
        ancestors.push(parent2);
      }
      parent2 = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }
  return newRoot;
}
function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];
  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === "function") {
      return kindVisitor;
    }
    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;
    if (typeof kindSpecificVisitor === "function") {
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;
    if (specificVisitor) {
      if (typeof specificVisitor === "function") {
        return specificVisitor;
      }
      var specificKindVisitor = specificVisitor[kind];
      if (typeof specificKindVisitor === "function") {
        return specificKindVisitor;
      }
    }
  }
}

// ../../node_modules/graphql/language/blockString.mjs
function dedentBlockStringValue(rawString) {
  var lines = rawString.split(/\r\n|[\n\r]/g);
  var commonIndent = getBlockStringIndentation(rawString);
  if (commonIndent !== 0) {
    for (var i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  }
  var startLine = 0;
  while (startLine < lines.length && isBlank(lines[startLine])) {
    ++startLine;
  }
  var endLine = lines.length;
  while (endLine > startLine && isBlank(lines[endLine - 1])) {
    --endLine;
  }
  return lines.slice(startLine, endLine).join("\n");
}
function isBlank(str) {
  for (var i = 0; i < str.length; ++i) {
    if (str[i] !== " " && str[i] !== "	") {
      return false;
    }
  }
  return true;
}
function getBlockStringIndentation(value) {
  var _commonIndent;
  var isFirstLine = true;
  var isEmptyLine = true;
  var indent = 0;
  var commonIndent = null;
  for (var i = 0; i < value.length; ++i) {
    switch (value.charCodeAt(i)) {
      case 13:
        if (value.charCodeAt(i + 1) === 10) {
          ++i;
        }
      case 10:
        isFirstLine = false;
        isEmptyLine = true;
        indent = 0;
        break;
      case 9:
      case 32:
        ++indent;
        break;
      default:
        if (isEmptyLine && !isFirstLine && (commonIndent === null || indent < commonIndent)) {
          commonIndent = indent;
        }
        isEmptyLine = false;
    }
  }
  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;
}
function printBlockString(value) {
  var indentation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var preferMultipleLines = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isSingleLine = value.indexOf("\n") === -1;
  var hasLeadingSpace = value[0] === " " || value[0] === "	";
  var hasTrailingQuote = value[value.length - 1] === '"';
  var hasTrailingSlash = value[value.length - 1] === "\\";
  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;
  var result = "";
  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
    result += "\n" + indentation;
  }
  result += indentation ? value.replace(/\n/g, "\n" + indentation) : value;
  if (printAsMultipleLines) {
    result += "\n";
  }
  return '"""' + result.replace(/"""/g, '\\"""') + '"""';
}

// src/state/clients/graphqlClient/index.ts
var import_graphql_request = __toModule(require_dist2());

// ../../node_modules/graphql/jsutils/isObjectLike.mjs
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function isObjectLike(value) {
  return _typeof2(value) == "object" && value !== null;
}

// ../../node_modules/graphql/polyfills/symbols.mjs
var SYMBOL_ITERATOR = typeof Symbol === "function" && Symbol.iterator != null ? Symbol.iterator : "@@iterator";
var SYMBOL_ASYNC_ITERATOR = typeof Symbol === "function" && Symbol.asyncIterator != null ? Symbol.asyncIterator : "@@asyncIterator";
var SYMBOL_TO_STRING_TAG = typeof Symbol === "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";

// ../../node_modules/graphql/language/location.mjs
function getLocation2(source, position) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position + 1;
  var match;
  while ((match = lineRegexp.exec(source.body)) && match.index < position) {
    line += 1;
    column = position + 1 - (match.index + match[0].length);
  }
  return {
    line,
    column
  };
}

// ../../node_modules/graphql/language/printLocation.mjs
function printLocation(location2) {
  return printSourceLocation(location2.source, getLocation2(location2.source, location2.start));
}
function printSourceLocation(source, sourceLocation) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body3 = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = sourceLocation.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = sourceLocation.line + lineOffset;
  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = sourceLocation.column + columnOffset;
  var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
  var lines = body3.split(/\r\n|[\n\r]/g);
  var locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    var subLineIndex = Math.floor(columnNum / 80);
    var subLineColumnNum = columnNum % 80;
    var subLines = [];
    for (var i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([["".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function(subLine) {
      return ["", subLine];
    }), [[" ", whitespace(subLineColumnNum - 1) + "^"], ["", subLines[subLineIndex + 1]]]));
  }
  return locationStr + printPrefixedLines([
    ["".concat(lineNum - 1), lines[lineIndex - 1]],
    ["".concat(lineNum), locationLine],
    ["", whitespace(columnNum - 1) + "^"],
    ["".concat(lineNum + 1), lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  var existingLines = lines.filter(function(_ref2) {
    var _ = _ref2[0], line = _ref2[1];
    return line !== void 0;
  });
  var padLen = Math.max.apply(Math, existingLines.map(function(_ref2) {
    var prefix2 = _ref2[0];
    return prefix2.length;
  }));
  return existingLines.map(function(_ref3) {
    var prefix2 = _ref3[0], line = _ref3[1];
    return leftPad(padLen, prefix2) + (line ? " | " + line : " |");
  }).join("\n");
}
function whitespace(len) {
  return Array(len + 1).join(" ");
}
function leftPad(len, str) {
  return whitespace(len - str.length) + str;
}

// ../../node_modules/graphql/error/GraphQLError.mjs
function _typeof3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof3 = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof3 = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof3(obj);
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof3(call2) === "object" || typeof call2 === "function")) {
    return call2;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper2);
    }
    function Wrapper2() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper2.prototype = Object.create(Class2.prototype, {constructor: {value: Wrapper2, enumerable: false, writable: true, configurable: true}});
    return _setPrototypeOf(Wrapper2, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
var GraphQLError = /* @__PURE__ */ function(_Error) {
  _inherits(GraphQLError2, _Error);
  var _super = _createSuper(GraphQLError2);
  function GraphQLError2(message, nodes, source, positions, path3, originalError, extensions) {
    var _locations2, _source2, _positions2, _extensions2;
    var _this;
    _classCallCheck2(this, GraphQLError2);
    _this = _super.call(this, message);
    var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : void 0 : nodes ? [nodes] : void 0;
    var _source = source;
    if (!_source && _nodes) {
      var _nodes$0$loc;
      _source = (_nodes$0$loc = _nodes[0].loc) === null || _nodes$0$loc === void 0 ? void 0 : _nodes$0$loc.source;
    }
    var _positions = positions;
    if (!_positions && _nodes) {
      _positions = _nodes.reduce(function(list, node) {
        if (node.loc) {
          list.push(node.loc.start);
        }
        return list;
      }, []);
    }
    if (_positions && _positions.length === 0) {
      _positions = void 0;
    }
    var _locations;
    if (positions && source) {
      _locations = positions.map(function(pos) {
        return getLocation2(source, pos);
      });
    } else if (_nodes) {
      _locations = _nodes.reduce(function(list, node) {
        if (node.loc) {
          list.push(getLocation2(node.loc.source, node.loc.start));
        }
        return list;
      }, []);
    }
    var _extensions = extensions;
    if (_extensions == null && originalError != null) {
      var originalExtensions = originalError.extensions;
      if (isObjectLike(originalExtensions)) {
        _extensions = originalExtensions;
      }
    }
    Object.defineProperties(_assertThisInitialized(_this), {
      name: {
        value: "GraphQLError"
      },
      message: {
        value: message,
        enumerable: true,
        writable: true
      },
      locations: {
        value: (_locations2 = _locations) !== null && _locations2 !== void 0 ? _locations2 : void 0,
        enumerable: _locations != null
      },
      path: {
        value: path3 !== null && path3 !== void 0 ? path3 : void 0,
        enumerable: path3 != null
      },
      nodes: {
        value: _nodes !== null && _nodes !== void 0 ? _nodes : void 0
      },
      source: {
        value: (_source2 = _source) !== null && _source2 !== void 0 ? _source2 : void 0
      },
      positions: {
        value: (_positions2 = _positions) !== null && _positions2 !== void 0 ? _positions2 : void 0
      },
      originalError: {
        value: originalError
      },
      extensions: {
        value: (_extensions2 = _extensions) !== null && _extensions2 !== void 0 ? _extensions2 : void 0,
        enumerable: _extensions != null
      }
    });
    if (originalError === null || originalError === void 0 ? void 0 : originalError.stack) {
      Object.defineProperty(_assertThisInitialized(_this), "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
      return _possibleConstructorReturn(_this);
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), GraphQLError2);
    } else {
      Object.defineProperty(_assertThisInitialized(_this), "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
    return _this;
  }
  _createClass2(GraphQLError2, [{
    key: "toString",
    value: function toString5() {
      return printError(this);
    }
  }, {
    key: SYMBOL_TO_STRING_TAG,
    get: function get() {
      return "Object";
    }
  }]);
  return GraphQLError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function printError(error) {
  var output = error.message;
  if (error.nodes) {
    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {
      var node = _error$nodes2[_i2];
      if (node.loc) {
        output += "\n\n" + printLocation(node.loc);
      }
    }
  } else if (error.source && error.locations) {
    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {
      var location2 = _error$locations2[_i4];
      output += "\n\n" + printSourceLocation(error.source, location2);
    }
  }
  return output;
}

// ../../node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError("Syntax Error: ".concat(description), void 0, source, [position]);
}

// ../../node_modules/graphql/language/kinds.mjs
var Kind = Object.freeze({
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType",
  SCHEMA_DEFINITION: "SchemaDefinition",
  OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
  SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
  OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
  FIELD_DEFINITION: "FieldDefinition",
  INPUT_VALUE_DEFINITION: "InputValueDefinition",
  INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
  UNION_TYPE_DEFINITION: "UnionTypeDefinition",
  ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
  ENUM_VALUE_DEFINITION: "EnumValueDefinition",
  INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
  DIRECTIVE_DEFINITION: "DirectiveDefinition",
  SCHEMA_EXTENSION: "SchemaExtension",
  SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
  OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
  INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
  UNION_TYPE_EXTENSION: "UnionTypeExtension",
  ENUM_TYPE_EXTENSION: "EnumTypeExtension",
  INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
});

// ../../node_modules/graphql/language/tokenKind.mjs
var TokenKind = Object.freeze({
  SOF: "<SOF>",
  EOF: "<EOF>",
  BANG: "!",
  DOLLAR: "$",
  AMP: "&",
  PAREN_L: "(",
  PAREN_R: ")",
  SPREAD: "...",
  COLON: ":",
  EQUALS: "=",
  AT: "@",
  BRACKET_L: "[",
  BRACKET_R: "]",
  BRACE_L: "{",
  PIPE: "|",
  BRACE_R: "}",
  NAME: "Name",
  INT: "Int",
  FLOAT: "Float",
  STRING: "String",
  BLOCK_STRING: "BlockString",
  COMMENT: "Comment"
});

// ../../node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  var booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// ../../node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf_default = true ? function instanceOf(value, constructor) {
  return value instanceof constructor;
} : function instanceOf2(value, constructor) {
  if (value instanceof constructor) {
    return true;
  }
  if (value) {
    var valueClass = value.constructor;
    var className = constructor.name;
    if (className && valueClass && valueClass.name === className) {
      throw new Error("Cannot use ".concat(className, ' "').concat(value, '" from another module or realm.\n\nEnsure that there is only one instance of "graphql" in the node_modules\ndirectory. If different versions of "graphql" are the dependencies of other\nrelied on modules, use "resolutions" to ensure only one version is installed.\n\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\n\nDuplicate "graphql" modules cannot be used at the same time since different\nversions may have different capabilities and behavior. The data from one\nversion used in the function from another could produce confusing and\nspurious results.'));
    }
  }
  return false;
};

// ../../node_modules/graphql/language/source.mjs
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  return Constructor;
}
var Source = /* @__PURE__ */ function() {
  function Source2(body3) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request";
    var locationOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      line: 1,
      column: 1
    };
    typeof body3 === "string" || devAssert(0, "Body must be a string. Received: ".concat(inspect(body3), "."));
    this.body = body3;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(0, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(0, "column in locationOffset is 1-indexed and must be positive.");
  }
  _createClass3(Source2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get() {
      return "Source";
    }
  }]);
  return Source2;
}();
function isSource(source) {
  return instanceOf_default(source, Source);
}

// ../../node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation = Object.freeze({
  QUERY: "QUERY",
  MUTATION: "MUTATION",
  SUBSCRIPTION: "SUBSCRIPTION",
  FIELD: "FIELD",
  FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
  FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
  INLINE_FRAGMENT: "INLINE_FRAGMENT",
  VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
  SCHEMA: "SCHEMA",
  SCALAR: "SCALAR",
  OBJECT: "OBJECT",
  FIELD_DEFINITION: "FIELD_DEFINITION",
  ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
  INTERFACE: "INTERFACE",
  UNION: "UNION",
  ENUM: "ENUM",
  ENUM_VALUE: "ENUM_VALUE",
  INPUT_OBJECT: "INPUT_OBJECT",
  INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
});

// ../../node_modules/graphql/language/lexer.mjs
var Lexer = /* @__PURE__ */ function() {
  function Lexer2(source) {
    var startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0, null);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  var _proto = Lexer2.prototype;
  _proto.advance = function advance() {
    this.lastToken = this.token;
    var token = this.token = this.lookahead();
    return token;
  };
  _proto.lookahead = function lookahead() {
    var token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        var _token$next;
        token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  };
  return Lexer2;
}();
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function printCharCode(code3) {
  return isNaN(code3) ? TokenKind.EOF : code3 < 127 ? JSON.stringify(String.fromCharCode(code3)) : '"\\u'.concat(("00" + code3.toString(16).toUpperCase()).slice(-4), '"');
}
function readToken(lexer, prev) {
  var source = lexer.source;
  var body3 = source.body;
  var bodyLength = body3.length;
  var pos = prev.end;
  while (pos < bodyLength) {
    var code3 = body3.charCodeAt(pos);
    var _line = lexer.line;
    var _col = 1 + pos - lexer.lineStart;
    switch (code3) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++pos;
        continue;
      case 10:
        ++pos;
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 13:
        if (body3.charCodeAt(pos + 1) === 10) {
          pos += 2;
        } else {
          ++pos;
        }
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 33:
        return new Token(TokenKind.BANG, pos, pos + 1, _line, _col, prev);
      case 35:
        return readComment(source, pos, _line, _col, prev);
      case 36:
        return new Token(TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev);
      case 38:
        return new Token(TokenKind.AMP, pos, pos + 1, _line, _col, prev);
      case 40:
        return new Token(TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev);
      case 41:
        return new Token(TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev);
      case 46:
        if (body3.charCodeAt(pos + 1) === 46 && body3.charCodeAt(pos + 2) === 46) {
          return new Token(TokenKind.SPREAD, pos, pos + 3, _line, _col, prev);
        }
        break;
      case 58:
        return new Token(TokenKind.COLON, pos, pos + 1, _line, _col, prev);
      case 61:
        return new Token(TokenKind.EQUALS, pos, pos + 1, _line, _col, prev);
      case 64:
        return new Token(TokenKind.AT, pos, pos + 1, _line, _col, prev);
      case 91:
        return new Token(TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev);
      case 93:
        return new Token(TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev);
      case 123:
        return new Token(TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev);
      case 124:
        return new Token(TokenKind.PIPE, pos, pos + 1, _line, _col, prev);
      case 125:
        return new Token(TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev);
      case 34:
        if (body3.charCodeAt(pos + 1) === 34 && body3.charCodeAt(pos + 2) === 34) {
          return readBlockString(source, pos, _line, _col, prev, lexer);
        }
        return readString(source, pos, _line, _col, prev);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return readNumber(source, pos, code3, _line, _col, prev);
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 95:
      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
        return readName(source, pos, _line, _col, prev);
    }
    throw syntaxError(source, pos, unexpectedCharacterMessage(code3));
  }
  var line = lexer.line;
  var col = 1 + pos - lexer.lineStart;
  return new Token(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
}
function unexpectedCharacterMessage(code3) {
  if (code3 < 32 && code3 !== 9 && code3 !== 10 && code3 !== 13) {
    return "Cannot contain the invalid character ".concat(printCharCode(code3), ".");
  }
  if (code3 === 39) {
    return `Unexpected single quote character ('), did you mean to use a double quote (")?`;
  }
  return "Cannot parse the unexpected character ".concat(printCharCode(code3), ".");
}
function readComment(source, start, line, col, prev) {
  var body3 = source.body;
  var code3;
  var position = start;
  do {
    code3 = body3.charCodeAt(++position);
  } while (!isNaN(code3) && (code3 > 31 || code3 === 9));
  return new Token(TokenKind.COMMENT, start, position, line, col, prev, body3.slice(start + 1, position));
}
function readNumber(source, start, firstCode, line, col, prev) {
  var body3 = source.body;
  var code3 = firstCode;
  var position = start;
  var isFloat = false;
  if (code3 === 45) {
    code3 = body3.charCodeAt(++position);
  }
  if (code3 === 48) {
    code3 = body3.charCodeAt(++position);
    if (code3 >= 48 && code3 <= 57) {
      throw syntaxError(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code3), "."));
    }
  } else {
    position = readDigits(source, position, code3);
    code3 = body3.charCodeAt(position);
  }
  if (code3 === 46) {
    isFloat = true;
    code3 = body3.charCodeAt(++position);
    position = readDigits(source, position, code3);
    code3 = body3.charCodeAt(position);
  }
  if (code3 === 69 || code3 === 101) {
    isFloat = true;
    code3 = body3.charCodeAt(++position);
    if (code3 === 43 || code3 === 45) {
      code3 = body3.charCodeAt(++position);
    }
    position = readDigits(source, position, code3);
    code3 = body3.charCodeAt(position);
  }
  if (code3 === 46 || isNameStart(code3)) {
    throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code3), "."));
  }
  return new Token(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body3.slice(start, position));
}
function readDigits(source, start, firstCode) {
  var body3 = source.body;
  var position = start;
  var code3 = firstCode;
  if (code3 >= 48 && code3 <= 57) {
    do {
      code3 = body3.charCodeAt(++position);
    } while (code3 >= 48 && code3 <= 57);
    return position;
  }
  throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code3), "."));
}
function readString(source, start, line, col, prev) {
  var body3 = source.body;
  var position = start + 1;
  var chunkStart = position;
  var code3 = 0;
  var value = "";
  while (position < body3.length && !isNaN(code3 = body3.charCodeAt(position)) && code3 !== 10 && code3 !== 13) {
    if (code3 === 34) {
      value += body3.slice(chunkStart, position);
      return new Token(TokenKind.STRING, start, position + 1, line, col, prev, value);
    }
    if (code3 < 32 && code3 !== 9) {
      throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code3), "."));
    }
    ++position;
    if (code3 === 92) {
      value += body3.slice(chunkStart, position - 1);
      code3 = body3.charCodeAt(position);
      switch (code3) {
        case 34:
          value += '"';
          break;
        case 47:
          value += "/";
          break;
        case 92:
          value += "\\";
          break;
        case 98:
          value += "\b";
          break;
        case 102:
          value += "\f";
          break;
        case 110:
          value += "\n";
          break;
        case 114:
          value += "\r";
          break;
        case 116:
          value += "	";
          break;
        case 117: {
          var charCode = uniCharCode(body3.charCodeAt(position + 1), body3.charCodeAt(position + 2), body3.charCodeAt(position + 3), body3.charCodeAt(position + 4));
          if (charCode < 0) {
            var invalidSequence = body3.slice(position + 1, position + 5);
            throw syntaxError(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
          }
          value += String.fromCharCode(charCode);
          position += 4;
          break;
        }
        default:
          throw syntaxError(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code3), "."));
      }
      ++position;
      chunkStart = position;
    }
  }
  throw syntaxError(source, position, "Unterminated string.");
}
function readBlockString(source, start, line, col, prev, lexer) {
  var body3 = source.body;
  var position = start + 3;
  var chunkStart = position;
  var code3 = 0;
  var rawValue = "";
  while (position < body3.length && !isNaN(code3 = body3.charCodeAt(position))) {
    if (code3 === 34 && body3.charCodeAt(position + 1) === 34 && body3.charCodeAt(position + 2) === 34) {
      rawValue += body3.slice(chunkStart, position);
      return new Token(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));
    }
    if (code3 < 32 && code3 !== 9 && code3 !== 10 && code3 !== 13) {
      throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code3), "."));
    }
    if (code3 === 10) {
      ++position;
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code3 === 13) {
      if (body3.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code3 === 92 && body3.charCodeAt(position + 1) === 34 && body3.charCodeAt(position + 2) === 34 && body3.charCodeAt(position + 3) === 34) {
      rawValue += body3.slice(chunkStart, position) + '"""';
      position += 4;
      chunkStart = position;
    } else {
      ++position;
    }
  }
  throw syntaxError(source, position, "Unterminated string.");
}
function uniCharCode(a, b, c, d) {
  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
}
function char2hex(a) {
  return a >= 48 && a <= 57 ? a - 48 : a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : -1;
}
function readName(source, start, line, col, prev) {
  var body3 = source.body;
  var bodyLength = body3.length;
  var position = start + 1;
  var code3 = 0;
  while (position !== bodyLength && !isNaN(code3 = body3.charCodeAt(position)) && (code3 === 95 || code3 >= 48 && code3 <= 57 || code3 >= 65 && code3 <= 90 || code3 >= 97 && code3 <= 122)) {
    ++position;
  }
  return new Token(TokenKind.NAME, start, position, line, col, prev, body3.slice(start, position));
}
function isNameStart(code3) {
  return code3 === 95 || code3 >= 65 && code3 <= 90 || code3 >= 97 && code3 <= 122;
}

// ../../node_modules/graphql/language/index.mjs
var import_printer = __toModule(require_printer());

// src/state/graphql-api-types.ts
var import_graphql_tag = __toModule(require_src());
var Branch_Constraint;
(function(Branch_Constraint2) {
  Branch_Constraint2["BranchNameKey"] = "Branch_name_key";
  Branch_Constraint2["BranchPkey"] = "branch_pkey";
})(Branch_Constraint || (Branch_Constraint = {}));
var Branch_Select_Column;
(function(Branch_Select_Column2) {
  Branch_Select_Column2["CreatedAt"] = "created_at";
  Branch_Select_Column2["HasMerged"] = "has_merged";
  Branch_Select_Column2["Name"] = "name";
  Branch_Select_Column2["Protected"] = "protected";
})(Branch_Select_Column || (Branch_Select_Column = {}));
var Branch_Update_Column;
(function(Branch_Update_Column2) {
  Branch_Update_Column2["CreatedAt"] = "created_at";
  Branch_Update_Column2["HasMerged"] = "has_merged";
  Branch_Update_Column2["Name"] = "name";
  Branch_Update_Column2["Protected"] = "protected";
})(Branch_Update_Column || (Branch_Update_Column = {}));
var File_Constraint;
(function(File_Constraint2) {
  File_Constraint2["FilePathModuleVersionModuleNameModuleScopeBranchNameE"] = "file_path_module_version_module_name_module_scope_branch_name_e";
  File_Constraint2["FilePkey"] = "file_pkey";
})(File_Constraint || (File_Constraint = {}));
var File_Select_Column;
(function(File_Select_Column2) {
  File_Select_Column2["BaseFileId"] = "base_file_id";
  File_Select_Column2["BranchName"] = "branch_name";
  File_Select_Column2["CompileErrors"] = "compile_errors";
  File_Select_Column2["Contents"] = "contents";
  File_Select_Column2["CreatedAt"] = "created_at";
  File_Select_Column2["Dts"] = "dts";
  File_Select_Column2["Ext"] = "ext";
  File_Select_Column2["Id"] = "id";
  File_Select_Column2["Js"] = "js";
  File_Select_Column2["Map"] = "map";
  File_Select_Column2["MarkDeleted"] = "mark_deleted";
  File_Select_Column2["ModuleName"] = "module_name";
  File_Select_Column2["ModuleScope"] = "module_scope";
  File_Select_Column2["ModuleVersion"] = "module_version";
  File_Select_Column2["Path"] = "path";
})(File_Select_Column || (File_Select_Column = {}));
var File_Update_Column;
(function(File_Update_Column2) {
  File_Update_Column2["BaseFileId"] = "base_file_id";
  File_Update_Column2["BranchName"] = "branch_name";
  File_Update_Column2["CompileErrors"] = "compile_errors";
  File_Update_Column2["Contents"] = "contents";
  File_Update_Column2["CreatedAt"] = "created_at";
  File_Update_Column2["Dts"] = "dts";
  File_Update_Column2["Ext"] = "ext";
  File_Update_Column2["Id"] = "id";
  File_Update_Column2["Js"] = "js";
  File_Update_Column2["Map"] = "map";
  File_Update_Column2["MarkDeleted"] = "mark_deleted";
  File_Update_Column2["ModuleName"] = "module_name";
  File_Update_Column2["ModuleScope"] = "module_scope";
  File_Update_Column2["ModuleVersion"] = "module_version";
  File_Update_Column2["Path"] = "path";
})(File_Update_Column || (File_Update_Column = {}));
var Module_Constraint;
(function(Module_Constraint2) {
  Module_Constraint2["ModulePkey"] = "module_pkey";
})(Module_Constraint || (Module_Constraint = {}));
var Module_Select_Column;
(function(Module_Select_Column2) {
  Module_Select_Column2["BranchName"] = "branch_name";
  Module_Select_Column2["CreatedAt"] = "created_at";
  Module_Select_Column2["Name"] = "name";
  Module_Select_Column2["Scope"] = "scope";
})(Module_Select_Column || (Module_Select_Column = {}));
var Module_Update_Column;
(function(Module_Update_Column2) {
  Module_Update_Column2["BranchName"] = "branch_name";
  Module_Update_Column2["CreatedAt"] = "created_at";
  Module_Update_Column2["Name"] = "name";
  Module_Update_Column2["Scope"] = "scope";
})(Module_Update_Column || (Module_Update_Column = {}));
var Module_Version_Constraint;
(function(Module_Version_Constraint2) {
  Module_Version_Constraint2["ModuleVersionPkey"] = "module_version_pkey";
})(Module_Version_Constraint || (Module_Version_Constraint = {}));
var Module_Version_Select_Column;
(function(Module_Version_Select_Column2) {
  Module_Version_Select_Column2["BranchName"] = "branch_name";
  Module_Version_Select_Column2["CreatedAt"] = "created_at";
  Module_Version_Select_Column2["ModuleName"] = "module_name";
  Module_Version_Select_Column2["ModuleScope"] = "module_scope";
  Module_Version_Select_Column2["Version"] = "version";
})(Module_Version_Select_Column || (Module_Version_Select_Column = {}));
var Module_Version_Update_Column;
(function(Module_Version_Update_Column2) {
  Module_Version_Update_Column2["BranchName"] = "branch_name";
  Module_Version_Update_Column2["CreatedAt"] = "created_at";
  Module_Version_Update_Column2["ModuleName"] = "module_name";
  Module_Version_Update_Column2["ModuleScope"] = "module_scope";
  Module_Version_Update_Column2["Version"] = "version";
})(Module_Version_Update_Column || (Module_Version_Update_Column = {}));
var Order_By;
(function(Order_By2) {
  Order_By2["Asc"] = "asc";
  Order_By2["AscNullsFirst"] = "asc_nulls_first";
  Order_By2["AscNullsLast"] = "asc_nulls_last";
  Order_By2["Desc"] = "desc";
  Order_By2["DescNullsFirst"] = "desc_nulls_first";
  Order_By2["DescNullsLast"] = "desc_nulls_last";
})(Order_By || (Order_By = {}));
var Tenant_Constraint;
(function(Tenant_Constraint2) {
  Tenant_Constraint2["TenantPkey"] = "tenant_pkey";
})(Tenant_Constraint || (Tenant_Constraint = {}));
var Tenant_Select_Column;
(function(Tenant_Select_Column2) {
  Tenant_Select_Column2["CreatedAt"] = "created_at";
  Tenant_Select_Column2["Name"] = "name";
  Tenant_Select_Column2["Type"] = "type";
})(Tenant_Select_Column || (Tenant_Select_Column = {}));
var Tenant_Update_Column;
(function(Tenant_Update_Column2) {
  Tenant_Update_Column2["CreatedAt"] = "created_at";
  Tenant_Update_Column2["Name"] = "name";
  Tenant_Update_Column2["Type"] = "type";
})(Tenant_Update_Column || (Tenant_Update_Column = {}));
var User_Constraint;
(function(User_Constraint2) {
  User_Constraint2["UserPkey"] = "user_pkey";
})(User_Constraint || (User_Constraint = {}));
var User_Preference_Constraint;
(function(User_Preference_Constraint2) {
  User_Preference_Constraint2["UserPreferencePkey"] = "user_preference_pkey";
})(User_Preference_Constraint || (User_Preference_Constraint = {}));
var User_Preference_Select_Column;
(function(User_Preference_Select_Column2) {
  User_Preference_Select_Column2["DarkMode"] = "dark_mode";
  User_Preference_Select_Column2["Email"] = "email";
})(User_Preference_Select_Column || (User_Preference_Select_Column = {}));
var User_Preference_Update_Column;
(function(User_Preference_Update_Column2) {
  User_Preference_Update_Column2["DarkMode"] = "dark_mode";
  User_Preference_Update_Column2["Email"] = "email";
})(User_Preference_Update_Column || (User_Preference_Update_Column = {}));
var User_Select_Column;
(function(User_Select_Column2) {
  User_Select_Column2["Active"] = "active";
  User_Select_Column2["Avatar"] = "avatar";
  User_Select_Column2["CreatedAt"] = "created_at";
  User_Select_Column2["Email"] = "email";
  User_Select_Column2["OpaqueId"] = "opaque_id";
  User_Select_Column2["Role"] = "role";
  User_Select_Column2["SessionLastUpdated"] = "session_last_updated";
  User_Select_Column2["Username"] = "username";
})(User_Select_Column || (User_Select_Column = {}));
var User_Update_Column;
(function(User_Update_Column2) {
  User_Update_Column2["Active"] = "active";
  User_Update_Column2["Avatar"] = "avatar";
  User_Update_Column2["CreatedAt"] = "created_at";
  User_Update_Column2["Email"] = "email";
  User_Update_Column2["OpaqueId"] = "opaque_id";
  User_Update_Column2["Role"] = "role";
  User_Update_Column2["SessionLastUpdated"] = "session_last_updated";
  User_Update_Column2["Username"] = "username";
})(User_Update_Column || (User_Update_Column = {}));
var CreateBranchDocument = import_graphql_tag.default`
  mutation CreateBranch($name: String!) {
    insert_branch_one(object: { name: $name }) {
      name
    }
  }
`;
var DeleteBranchDocument = import_graphql_tag.default`
  mutation DeleteBranch($name: String!) {
    delete_branch_by_pk(name: $name) {
      name
    }
  }
`;
var SubscribeToBranchesDocument = import_graphql_tag.default`
  subscription SubscribeToBranches {
    branch {
      name
      created_at
      protected
    }
  }
`;
var GetCompiledOutputDocument = import_graphql_tag.default`
  query GetCompiledOutput($id: uuid!) {
    file_by_pk(id: $id) {
      js
      dts
      map
      compile_errors
    }
  }
`;
var GetFileDocument = import_graphql_tag.default`
  query GetFile($id: uuid!) {
    file_by_pk(id: $id) {
      id
      ext
      path
      module_name
      module_scope
      module_version
      created_at
      branch_name
      base_file_id
      mark_deleted
      contents
    }
  }
`;
var GetFileIdDocument = import_graphql_tag.default`
  query GetFileId(
    $branch: String
    $module: String
    $scope: String
    $version: String
    $path: String
  ) {
    file(
      where: {
        _or: [
          {
            branch_name: { _eq: $branch }
            module_name: { _eq: $module }
            module_scope: { _eq: $scope }
            module_version: { _eq: $version }
            path: { _eq: $path }
          }
          {
            branch_name: { _eq: "main" }
            module_name: { _eq: $module }
            module_scope: { _eq: $scope }
            module_version: { _eq: $version }
            path: { _eq: $path }
          }
        ]
      }
    ) {
      id
      branch_name
    }
  }
`;
var SubscribeToBranchFilesDocument = import_graphql_tag.default`
  subscription SubscribeToBranchFiles($branch: String!) {
    branch_by_pk(name: $branch) {
      files {
        id
        path
        module_name
        module_scope
        module_version
        mark_deleted
        contents
      }
    }
  }
`;
var UpdateContentsDocument = import_graphql_tag.default`
  mutation UpdateContents(
    $id: uuid!
    $contents: String!
    $js: String!
    $dts: String!
    $map: String!
    $errors: jsonb!
  ) {
    update_file_by_pk(
      pk_columns: { id: $id }
      _set: {
        contents: $contents
        js: $js
        dts: $dts
        map: $map
        compile_errors: $errors
      }
    ) {
      id
    }
  }
`;
var CreateModuleDocument = import_graphql_tag.default`
  mutation CreateModule(
    $name: String!
    $scope: String!
    $branch: String!
    $version: String!
    $files: [file_insert_input!]!
  ) {
    insert_module_one(
      object: { name: $name, scope: $scope, branch_name: $branch }
    ) {
      created_at
    }
    insert_module_version(
      objects: [
        {
          module_name: $name
          module_scope: $scope
          branch_name: $branch
          version: $version
        }
        {
          module_name: $name
          module_scope: $scope
          branch_name: $branch
          version: "latest"
        }
      ]
    ) {
      returning {
        created_at
      }
    }
    insert_file(objects: $files) {
      returning {
        id
      }
    }
  }
`;
var GetModuleDocument = import_graphql_tag.default`
  query GetModule($name: String!, $scope: String!, $branch: String!) {
    module_by_pk(branch_name: $branch, name: $name, scope: $scope) {
      created_at
    }
    branch_by_pk(name: $branch) {
      protected
    }
  }
`;
var SubscribeToModulesDocument = import_graphql_tag.default`
  subscription SubscribeToModules {
    module {
      name
      scope
      created_at
      branch_name
    }
  }
`;
var CreateVersionedFilesDocument = import_graphql_tag.default`
  mutation CreateVersionedFiles(
    $name: String!
    $scope: String!
    $branch: String!
    $version: String!
    $files: [file_insert_input!]!
  ) {
    insert_module_version(
      objects: [
        {
          module_name: $name
          module_scope: $scope
          branch_name: $branch
          version: $version
        }
      ]
    ) {
      returning {
        created_at
      }
    }
    insert_file(objects: $files) {
      returning {
        id
      }
    }
  }
`;
var GetModuleVersionFilesDocument = import_graphql_tag.default`
  query GetModuleVersionFiles(
    $branch: String
    $name: String
    $scope: String
    $version: String
  ) {
    file(
      where: {
        _and: {
          branch_name: { _eq: $branch }
          module_version: { _eq: $version }
          module_scope: { _eq: $scope }
          module_name: { _eq: $name }
        }
      }
    ) {
      id
      ext
      path
      module_name
      module_scope
      module_version
      created_at
      branch_name
      base_file_id
      mark_deleted
      contents
    }
    module_version(
      limit: 1
      order_by: { created_at: desc }
      where: {
        _and: {
          branch_name: { _eq: $branch }
          module_scope: { _eq: $scope }
          module_name: { _eq: $name }
        }
      }
    ) {
      version
    }
  }
`;
var SubscribeToModuleVersionsDocument = import_graphql_tag.default`
  subscription SubscribeToModuleVersions {
    module_version {
      version
      module_name
      module_scope
      created_at
      branch_name
    }
  }
`;
var CreateTenantsDocument = import_graphql_tag.default`
  mutation CreateTenants($tenants: [tenant_insert_input!]!) {
    insert_tenant(objects: $tenants) {
      returning {
        name
      }
    }
  }
`;
var DeleteTenantDocument = import_graphql_tag.default`
  mutation DeleteTenant($name: String!) {
    delete_tenant_by_pk(name: $name) {
      name
    }
  }
`;
var GetTenantsDocument = import_graphql_tag.default`
  query GetTenants {
    tenant {
      name
      created_at
      type
    }
  }
`;
var SubscribeToTenantListDocument = import_graphql_tag.default`
  subscription SubscribeToTenantList {
    tenant {
      name
      created_at
      type
    }
  }
`;
var CreateUserDocument = import_graphql_tag.default`
  mutation CreateUser($email: String!, $username: String!, $avatar: String!) {
    insert_user_preference_one(
      object: {
        dark_mode: true
        user: { data: { avatar: $avatar, email: $email, username: $username } }
      }
    ) {
      email
    }
  }
`;
var DeleteUserDocument = import_graphql_tag.default`
  mutation DeleteUser($email: String!) {
    update_user_by_pk(_set: { active: false }, pk_columns: { email: $email }) {
      email
      opaque_id
    }
  }
`;
var GetCurrentUserDocument = import_graphql_tag.default`
  query GetCurrentUser {
    user {
      email
      avatar
      username
      active
      preference {
        dark_mode
      }
    }
  }
`;
var GetUserDocument = import_graphql_tag.default`
  query GetUser($email: String!) {
    user_by_pk(email: $email) {
      email
      avatar
      username
      active
    }
    user_aggregate(where: { active: { _eq: true } }) {
      aggregate {
        count
      }
    }
  }
`;
var ReactivateUserDocument = import_graphql_tag.default`
  mutation ReactivateUser($email: String!) {
    update_user_by_pk(_set: { active: true }, pk_columns: { email: $email }) {
      email
      opaque_id
    }
  }
`;
var SetDarkModeDocument = import_graphql_tag.default`
  mutation SetDarkMode($email: String!, $darkMode: Boolean!) {
    update_user_preference_by_pk(
      pk_columns: { email: $email }
      _set: { dark_mode: $darkMode }
    ) {
      dark_mode
    }
  }
`;
var SubscribeToUserListDocument = import_graphql_tag.default`
  subscription SubscribeToUserList {
    user {
      role
      email
      avatar
      active
      username
      session_last_updated
      created_at
      opaque_id
      preference {
        dark_mode
      }
    }
  }
`;
var UpdateUserDocument = import_graphql_tag.default`
  mutation UpdateUser(
    $email: String!
    $username: String!
    $avatar: String!
    $time: timestamptz!
  ) {
    update_user_by_pk(
      _set: {
        username: $username
        email: $email
        avatar: $avatar
        session_last_updated: $time
      }
      pk_columns: { email: $email }
    ) {
      email
      opaque_id
    }
  }
`;
var defaultWrapper = (sdkFunction) => sdkFunction();
function getSdk(client2, withWrapper = defaultWrapper) {
  return {
    CreateBranch(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(CreateBranchDocument), variables));
    },
    DeleteBranch(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(DeleteBranchDocument), variables));
    },
    SubscribeToBranches(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(SubscribeToBranchesDocument), variables));
    },
    GetCompiledOutput(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(GetCompiledOutputDocument), variables));
    },
    GetFile(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(GetFileDocument), variables));
    },
    GetFileId(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(GetFileIdDocument), variables));
    },
    SubscribeToBranchFiles(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(SubscribeToBranchFilesDocument), variables));
    },
    UpdateContents(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(UpdateContentsDocument), variables));
    },
    CreateModule(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(CreateModuleDocument), variables));
    },
    GetModule(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(GetModuleDocument), variables));
    },
    SubscribeToModules(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(SubscribeToModulesDocument), variables));
    },
    CreateVersionedFiles(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(CreateVersionedFilesDocument), variables));
    },
    GetModuleVersionFiles(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(GetModuleVersionFilesDocument), variables));
    },
    SubscribeToModuleVersions(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(SubscribeToModuleVersionsDocument), variables));
    },
    CreateTenants(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(CreateTenantsDocument), variables));
    },
    DeleteTenant(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(DeleteTenantDocument), variables));
    },
    GetTenants(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(GetTenantsDocument), variables));
    },
    SubscribeToTenantList(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(SubscribeToTenantListDocument), variables));
    },
    CreateUser(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(CreateUserDocument), variables));
    },
    DeleteUser(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(DeleteUserDocument), variables));
    },
    GetCurrentUser(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(GetCurrentUserDocument), variables));
    },
    GetUser(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(GetUserDocument), variables));
    },
    ReactivateUser(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(ReactivateUserDocument), variables));
    },
    SetDarkMode(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(SetDarkModeDocument), variables));
    },
    SubscribeToUserList(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(SubscribeToUserListDocument), variables));
    },
    UpdateUser(variables) {
      return withWrapper(() => client2.rawRequest(import_printer.print(UpdateUserDocument), variables));
    }
  };
}

// src/state/clients/graphqlClient/index.ts
var endpoint = typeof window !== "undefined" && `${window.location.protocol}//${window.location.host}/_/graphql`;
if (!endpoint) {
  throw Error("Must specify GRAPHQL_ENDPOINT env var");
}
var adminSecret = "";
var client = adminSecret ? new import_graphql_request.GraphQLClient(endpoint, {
  headers: {
    "x-hasura-admin-secret": adminSecret
  }
}) : new import_graphql_request.GraphQLClient(endpoint, {
  headers: {}
});
var graphqlClient_default = getSdk(client);

// ../../node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter36(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body3) {
  var _ = {label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: []}, f, y, t, g;
  return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {value: op[1], done: false};
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body3.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {value: op[0] ? op[1] : void 0, done: true};
  }
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}

// ../../node_modules/@apollo/client/link/ws/index.js
var import_subscriptions_transport_ws = __toModule(require_client());

// ../../node_modules/@ungap/global-this/esm/index.js
(function(Object2) {
  typeof globalThis !== "object" && (this ? get() : (Object2.defineProperty(Object2.prototype, "_T_", {
    configurable: true,
    get
  }), _T_));
  function get() {
    var global2 = this || self;
    global2.globalThis = global2;
    delete Object2.prototype._T_;
  }
})(Object);
var esm_default2 = globalThis;

// ../../node_modules/ts-invariant/lib/invariant.esm.js
var genericMessage = "Invariant Violation";
var _a2 = Object.setPrototypeOf;
var setPrototypeOf = _a2 === void 0 ? function(obj, proto) {
  obj.__proto__ = proto;
  return obj;
} : _a2;
var InvariantError = function(_super) {
  __extends(InvariantError2, _super);
  function InvariantError2(message) {
    if (message === void 0) {
      message = genericMessage;
    }
    var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
    _this.framesToPop = 1;
    _this.name = genericMessage;
    setPrototypeOf(_this, InvariantError2.prototype);
    return _this;
  }
  return InvariantError2;
}(Error);
function invariant3(condition, message) {
  if (!condition) {
    throw new InvariantError(message);
  }
}
var verbosityLevels = ["log", "warn", "error", "silent"];
var verbosityLevel = verbosityLevels.indexOf("log");
function wrapConsoleMethod(method) {
  return function() {
    if (verbosityLevels.indexOf(method) >= verbosityLevel) {
      return console[method].apply(console, arguments);
    }
  };
}
(function(invariant4) {
  invariant4.log = wrapConsoleMethod("log");
  invariant4.warn = wrapConsoleMethod("warn");
  invariant4.error = wrapConsoleMethod("error");
})(invariant3 || (invariant3 = {}));
var processStub = esm_default2.process || {env: {}};
if (!esm_default2.process)
  try {
    Object.defineProperty(esm_default2, "process", {
      value: processStub
    });
  } catch (_b2) {
  }

// ../../node_modules/@apollo/client/utilities/graphql/directives.js
function shouldInclude(_a5, variables) {
  var directives = _a5.directives;
  if (!directives || !directives.length) {
    return true;
  }
  return getInclusionDirectives(directives).every(function(_a6) {
    var directive = _a6.directive, ifArgument = _a6.ifArgument;
    var evaledValue = false;
    if (ifArgument.value.kind === "Variable") {
      evaledValue = variables && variables[ifArgument.value.name.value];
      true ? invariant3(evaledValue !== void 0, 38) : invariant3(evaledValue !== void 0, "Invalid variable referenced in @" + directive.name.value + " directive.");
    } else {
      evaledValue = ifArgument.value.value;
    }
    return directive.name.value === "skip" ? !evaledValue : evaledValue;
  });
}
function getDirectiveNames(root) {
  var names = [];
  visit(root, {
    Directive: function(node) {
      names.push(node.name.value);
    }
  });
  return names;
}
function hasDirectives(names, root) {
  return getDirectiveNames(root).some(function(name) {
    return names.indexOf(name) > -1;
  });
}
function hasClientExports(document2) {
  return document2 && hasDirectives(["client"], document2) && hasDirectives(["export"], document2);
}
function isInclusionDirective(_a5) {
  var value = _a5.name.value;
  return value === "skip" || value === "include";
}
function getInclusionDirectives(directives) {
  var result = [];
  if (directives && directives.length) {
    directives.forEach(function(directive) {
      if (!isInclusionDirective(directive))
        return;
      var directiveArguments = directive.arguments;
      var directiveName = directive.name.value;
      true ? invariant3(directiveArguments && directiveArguments.length === 1, 39) : invariant3(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @" + directiveName + " directive.");
      var ifArgument = directiveArguments[0];
      true ? invariant3(ifArgument.name && ifArgument.name.value === "if", 40) : invariant3(ifArgument.name && ifArgument.name.value === "if", "Invalid argument for the @" + directiveName + " directive.");
      var ifValue = ifArgument.value;
      true ? invariant3(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 41) : invariant3(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), "Argument for the @" + directiveName + " directive must be a variable or a boolean value.");
      result.push({directive, ifArgument});
    });
  }
  return result;
}

// ../../node_modules/@apollo/client/utilities/graphql/fragments.js
function getFragmentQueryDocument(document2, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document2.definitions.forEach(function(definition) {
    if (definition.kind === "OperationDefinition") {
      throw true ? new InvariantError(42) : new InvariantError("Found a " + definition.operation + " operation" + (definition.name ? " named '" + definition.name.value + "'" : "") + ". No operations are allowed when using a fragment as a query. Only fragments are allowed.");
    }
    if (definition.kind === "FragmentDefinition") {
      fragments.push(definition);
    }
  });
  if (typeof actualFragmentName === "undefined") {
    true ? invariant3(fragments.length === 1, 43) : invariant3(fragments.length === 1, "Found " + fragments.length + " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.");
    actualFragmentName = fragments[0].name.value;
  }
  var query = __assign(__assign({}, document2), {definitions: __spreadArrays([
    {
      kind: "OperationDefinition",
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: actualFragmentName
            }
          }
        ]
      }
    }
  ], document2.definitions)});
  return query;
}
function createFragmentMap(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }
  var symTable = {};
  fragments.forEach(function(fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}
function getFragmentFromSelection(selection, fragmentMap) {
  switch (selection.kind) {
    case "InlineFragment":
      return selection;
    case "FragmentSpread": {
      var fragment = fragmentMap && fragmentMap[selection.name.value];
      true ? invariant3(fragment, 44) : invariant3(fragment, "No fragment named " + selection.name.value + ".");
      return fragment;
    }
    default:
      return null;
  }
}

// ../../node_modules/@apollo/client/utilities/graphql/storeUtils.js
var import_fast_json_stable_stringify = __toModule(require_fast_json_stable_stringify());
function makeReference(id) {
  return {__ref: String(id)};
}
function isReference(obj) {
  return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
}
function isStringValue(value) {
  return value.kind === "StringValue";
}
function isBooleanValue(value) {
  return value.kind === "BooleanValue";
}
function isIntValue(value) {
  return value.kind === "IntValue";
}
function isFloatValue(value) {
  return value.kind === "FloatValue";
}
function isVariable(value) {
  return value.kind === "Variable";
}
function isObjectValue(value) {
  return value.kind === "ObjectValue";
}
function isListValue(value) {
  return value.kind === "ListValue";
}
function isEnumValue(value) {
  return value.kind === "EnumValue";
}
function isNullValue(value) {
  return value.kind === "NullValue";
}
function valueToObjectRepresentation(argObj, name, value, variables) {
  if (isIntValue(value) || isFloatValue(value)) {
    argObj[name.value] = Number(value.value);
  } else if (isBooleanValue(value) || isStringValue(value)) {
    argObj[name.value] = value.value;
  } else if (isObjectValue(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function(obj) {
      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name.value] = nestedArgObj_1;
  } else if (isVariable(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name.value] = variableValue;
  } else if (isListValue(value)) {
    argObj[name.value] = value.values.map(function(listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
      return nestedArgArrayObj[name.value];
    });
  } else if (isEnumValue(value)) {
    argObj[name.value] = value.value;
  } else if (isNullValue(value)) {
    argObj[name.value] = null;
  } else {
    throw true ? new InvariantError(53) : new InvariantError('The inline argument "' + name.value + '" of kind "' + value.kind + '"is not supported. Use variables instead of inline arguments to overcome this limitation.');
  }
}
function storeKeyNameFromField(field, variables) {
  var directivesObj = null;
  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function(directive) {
      directivesObj[directive.name.value] = {};
      if (directive.arguments) {
        directive.arguments.forEach(function(_a5) {
          var name = _a5.name, value = _a5.value;
          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
        });
      }
    });
  }
  var argObj = null;
  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function(_a5) {
      var name = _a5.name, value = _a5.value;
      return valueToObjectRepresentation(argObj, name, value, variables);
    });
  }
  return getStoreKeyName(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export"
];
function getStoreKeyName(fieldName, args, directives) {
  if (args && directives && directives["connection"] && directives["connection"]["key"]) {
    if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
      var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
      filterKeys.sort();
      var filteredArgs_1 = {};
      filterKeys.forEach(function(key) {
        filteredArgs_1[key] = args[key];
      });
      return directives["connection"]["key"] + "(" + JSON.stringify(filteredArgs_1) + ")";
    } else {
      return directives["connection"]["key"];
    }
  }
  var completeFieldName = fieldName;
  if (args) {
    var stringifiedArgs = import_fast_json_stable_stringify.default(args);
    completeFieldName += "(" + stringifiedArgs + ")";
  }
  if (directives) {
    Object.keys(directives).forEach(function(key) {
      if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
        return;
      if (directives[key] && Object.keys(directives[key]).length) {
        completeFieldName += "@" + key + "(" + JSON.stringify(directives[key]) + ")";
      } else {
        completeFieldName += "@" + key;
      }
    });
  }
  return completeFieldName;
}
function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function(_a5) {
      var name = _a5.name, value = _a5.value;
      return valueToObjectRepresentation(argObj_1, name, value, variables);
    });
    return argObj_1;
  }
  return null;
}
function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}
function getTypenameFromResult(result, selectionSet, fragmentMap) {
  if (typeof result.__typename === "string") {
    return result.__typename;
  }
  for (var _i = 0, _a5 = selectionSet.selections; _i < _a5.length; _i++) {
    var selection = _a5[_i];
    if (isField(selection)) {
      if (selection.name.value === "__typename") {
        return result[resultKeyNameFromField(selection)];
      }
    } else {
      var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
      if (typeof typename === "string") {
        return typename;
      }
    }
  }
}
function isField(selection) {
  return selection.kind === "Field";
}
function isInlineFragment(selection) {
  return selection.kind === "InlineFragment";
}

// ../../node_modules/@apollo/client/utilities/graphql/getFromAST.js
function checkDocument(doc) {
  true ? invariant3(doc && doc.kind === "Document", 45) : invariant3(doc && doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql');
  var operations = doc.definitions.filter(function(d) {
    return d.kind !== "FragmentDefinition";
  }).map(function(definition) {
    if (definition.kind !== "OperationDefinition") {
      throw true ? new InvariantError(46) : new InvariantError('Schema type definitions not allowed in queries. Found: "' + definition.kind + '"');
    }
    return definition;
  });
  true ? invariant3(operations.length <= 1, 47) : invariant3(operations.length <= 1, "Ambiguous GraphQL document: contains " + operations.length + " operations");
  return doc;
}
function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition";
  })[0];
}
function getOperationName(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition" && definition.name;
  }).map(function(x) {
    return x.name.value;
  })[0] || null;
}
function getFragmentDefinitions(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "FragmentDefinition";
  });
}
function getQueryDefinition(doc) {
  var queryDef = getOperationDefinition(doc);
  true ? invariant3(queryDef && queryDef.operation === "query", 48) : invariant3(queryDef && queryDef.operation === "query", "Must contain a query definition.");
  return queryDef;
}
function getFragmentDefinition(doc) {
  true ? invariant3(doc.kind === "Document", 49) : invariant3(doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql');
  true ? invariant3(doc.definitions.length <= 1, 50) : invariant3(doc.definitions.length <= 1, "Fragment must have exactly one definition.");
  var fragmentDef = doc.definitions[0];
  true ? invariant3(fragmentDef.kind === "FragmentDefinition", 51) : invariant3(fragmentDef.kind === "FragmentDefinition", "Must be a fragment definition.");
  return fragmentDef;
}
function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  var fragmentDefinition;
  for (var _i = 0, _a5 = queryDoc.definitions; _i < _a5.length; _i++) {
    var definition = _a5[_i];
    if (definition.kind === "OperationDefinition") {
      var operation = definition.operation;
      if (operation === "query" || operation === "mutation" || operation === "subscription") {
        return definition;
      }
    }
    if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }
  if (fragmentDefinition) {
    return fragmentDefinition;
  }
  throw true ? new InvariantError(52) : new InvariantError("Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.");
}
function getDefaultValues(definition) {
  var defaultValues = Object.create(null);
  var defs = definition && definition.variableDefinitions;
  if (defs && defs.length) {
    defs.forEach(function(def) {
      if (def.defaultValue) {
        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
      }
    });
  }
  return defaultValues;
}

// ../../node_modules/@apollo/client/utilities/common/filterInPlace.js
function filterInPlace(array4, test, context2) {
  var target = 0;
  array4.forEach(function(elem, i) {
    if (test.call(this, elem, i, array4)) {
      array4[target++] = elem;
    }
  }, context2);
  array4.length = target;
  return array4;
}

// ../../node_modules/@apollo/client/utilities/graphql/transform.js
var TYPENAME_FIELD = {
  kind: "Field",
  name: {
    kind: "Name",
    value: "__typename"
  }
};
function isEmpty(op, fragments) {
  return op.selectionSet.selections.every(function(selection) {
    return selection.kind === "FragmentSpread" && isEmpty(fragments[selection.name.value], fragments);
  });
}
function nullIfDocIsEmpty(doc) {
  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
}
function getDirectiveMatcher(directives) {
  return function directiveMatcher(directive) {
    return directives.some(function(dir) {
      return dir.name && dir.name === directive.name.value || dir.test && dir.test(directive);
    });
  };
}
function removeDirectivesFromDocument(directives, doc) {
  var variablesInUse = Object.create(null);
  var variablesToRemove = [];
  var fragmentSpreadsInUse = Object.create(null);
  var fragmentSpreadsToRemove = [];
  var modifiedDoc = nullIfDocIsEmpty(visit(doc, {
    Variable: {
      enter: function(node, _key, parent2) {
        if (parent2.kind !== "VariableDefinition") {
          variablesInUse[node.name.value] = true;
        }
      }
    },
    Field: {
      enter: function(node) {
        if (directives && node.directives) {
          var shouldRemoveField = directives.some(function(directive) {
            return directive.remove;
          });
          if (shouldRemoveField && node.directives && node.directives.some(getDirectiveMatcher(directives))) {
            if (node.arguments) {
              node.arguments.forEach(function(arg) {
                if (arg.value.kind === "Variable") {
                  variablesToRemove.push({
                    name: arg.value.name.value
                  });
                }
              });
            }
            if (node.selectionSet) {
              getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function(frag) {
                fragmentSpreadsToRemove.push({
                  name: frag.name.value
                });
              });
            }
            return null;
          }
        }
      }
    },
    FragmentSpread: {
      enter: function(node) {
        fragmentSpreadsInUse[node.name.value] = true;
      }
    },
    Directive: {
      enter: function(node) {
        if (getDirectiveMatcher(directives)(node)) {
          return null;
        }
      }
    }
  }));
  if (modifiedDoc && filterInPlace(variablesToRemove, function(v) {
    return !!v.name && !variablesInUse[v.name];
  }).length) {
    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
  }
  if (modifiedDoc && filterInPlace(fragmentSpreadsToRemove, function(fs) {
    return !!fs.name && !fragmentSpreadsInUse[fs.name];
  }).length) {
    modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
  }
  return modifiedDoc;
}
function addTypenameToDocument(doc) {
  return visit(checkDocument(doc), {
    SelectionSet: {
      enter: function(node, _key, parent2) {
        if (parent2 && parent2.kind === "OperationDefinition") {
          return;
        }
        var selections = node.selections;
        if (!selections) {
          return;
        }
        var skip = selections.some(function(selection) {
          return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
        });
        if (skip) {
          return;
        }
        var field = parent2;
        if (isField(field) && field.directives && field.directives.some(function(d) {
          return d.name.value === "export";
        })) {
          return;
        }
        return __assign(__assign({}, node), {selections: __spreadArrays(selections, [TYPENAME_FIELD])});
      }
    }
  });
}
addTypenameToDocument.added = function(field) {
  return field === TYPENAME_FIELD;
};
var connectionRemoveConfig = {
  test: function(directive) {
    var willRemove = directive.name.value === "connection";
    if (willRemove) {
      if (!directive.arguments || !directive.arguments.some(function(arg) {
        return arg.name.value === "key";
      })) {
        true;
      }
    }
    return willRemove;
  }
};
function removeConnectionDirectiveFromDocument(doc) {
  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
}
function getArgumentMatcher(config) {
  return function argumentMatcher(argument) {
    return config.some(function(aConfig) {
      return argument.value && argument.value.kind === "Variable" && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
    });
  };
}
function removeArgumentsFromDocument(config, doc) {
  var argMatcher = getArgumentMatcher(config);
  return nullIfDocIsEmpty(visit(doc, {
    OperationDefinition: {
      enter: function(node) {
        return __assign(__assign({}, node), {variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {
          return !config.some(function(arg) {
            return arg.name === varDef.variable.name.value;
          });
        }) : []});
      }
    },
    Field: {
      enter: function(node) {
        var shouldRemoveField = config.some(function(argConfig) {
          return argConfig.remove;
        });
        if (shouldRemoveField) {
          var argMatchCount_1 = 0;
          if (node.arguments) {
            node.arguments.forEach(function(arg) {
              if (argMatcher(arg)) {
                argMatchCount_1 += 1;
              }
            });
          }
          if (argMatchCount_1 === 1) {
            return null;
          }
        }
      }
    },
    Argument: {
      enter: function(node) {
        if (argMatcher(node)) {
          return null;
        }
      }
    }
  }));
}
function removeFragmentSpreadFromDocument(config, doc) {
  function enter(node) {
    if (config.some(function(def) {
      return def.name === node.name.value;
    })) {
      return null;
    }
  }
  return nullIfDocIsEmpty(visit(doc, {
    FragmentSpread: {enter},
    FragmentDefinition: {enter}
  }));
}
function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
  var allFragments = [];
  selectionSet.selections.forEach(function(selection) {
    if ((isField(selection) || isInlineFragment(selection)) && selection.selectionSet) {
      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function(frag) {
        return allFragments.push(frag);
      });
    } else if (selection.kind === "FragmentSpread") {
      allFragments.push(selection);
    }
  });
  return allFragments;
}
function buildQueryFromSelectionSet(document2) {
  var definition = getMainDefinition(document2);
  var definitionOperation = definition.operation;
  if (definitionOperation === "query") {
    return document2;
  }
  var modifiedDoc = visit(document2, {
    OperationDefinition: {
      enter: function(node) {
        return __assign(__assign({}, node), {operation: "query"});
      }
    }
  });
  return modifiedDoc;
}
function removeClientSetsFromDocument(document2) {
  checkDocument(document2);
  var modifiedDoc = removeDirectivesFromDocument([
    {
      test: function(directive) {
        return directive.name.value === "client";
      },
      remove: true
    }
  ], document2);
  if (modifiedDoc) {
    modifiedDoc = visit(modifiedDoc, {
      FragmentDefinition: {
        enter: function(node) {
          if (node.selectionSet) {
            var isTypenameOnly = node.selectionSet.selections.every(function(selection) {
              return isField(selection) && selection.name.value === "__typename";
            });
            if (isTypenameOnly) {
              return null;
            }
          }
        }
      }
    });
  }
  return modifiedDoc;
}

// ../../node_modules/@apollo/client/utilities/common/mergeDeep.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
function mergeDeep() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  return mergeDeepArray(sources);
}
function mergeDeepArray(sources) {
  var target = sources[0] || {};
  var count = sources.length;
  if (count > 1) {
    var merger = new DeepMerger();
    for (var i = 1; i < count; ++i) {
      target = merger.merge(target, sources[i]);
    }
  }
  return target;
}
function isObject2(obj) {
  return obj !== null && typeof obj === "object";
}
var defaultReconciler = function(target, source, property) {
  return this.merge(target[property], source[property]);
};
var DeepMerger = function() {
  function DeepMerger2(reconciler) {
    if (reconciler === void 0) {
      reconciler = defaultReconciler;
    }
    this.reconciler = reconciler;
    this.isObject = isObject2;
    this.pastCopies = new Set();
  }
  DeepMerger2.prototype.merge = function(target, source) {
    var _this = this;
    var context2 = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      context2[_i - 2] = arguments[_i];
    }
    if (isObject2(source) && isObject2(target)) {
      Object.keys(source).forEach(function(sourceKey) {
        if (hasOwnProperty.call(target, sourceKey)) {
          var targetValue = target[sourceKey];
          if (source[sourceKey] !== targetValue) {
            var result = _this.reconciler.apply(_this, __spreadArrays([target, source, sourceKey], context2));
            if (result !== targetValue) {
              target = _this.shallowCopyForMerge(target);
              target[sourceKey] = result;
            }
          }
        } else {
          target = _this.shallowCopyForMerge(target);
          target[sourceKey] = source[sourceKey];
        }
      });
      return target;
    }
    return source;
  };
  DeepMerger2.prototype.shallowCopyForMerge = function(value) {
    if (isObject2(value) && !this.pastCopies.has(value)) {
      if (Array.isArray(value)) {
        value = value.slice(0);
      } else {
        value = __assign({__proto__: Object.getPrototypeOf(value)}, value);
      }
      this.pastCopies.add(value);
    }
    return value;
  };
  return DeepMerger2;
}();

// ../../node_modules/@apollo/client/utilities/observables/Observable.js
var import_zen_observable = __toModule(require_zen_observable());

// ../../node_modules/@apollo/client/node_modules/symbol-observable/es/ponyfill.js
function symbolObservablePonyfill(root) {
  var result;
  var Symbol2 = root.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result = Symbol2.observable;
    } else {
      result = Symbol2.for("https://github.com/benlesh/symbol-observable");
      try {
        Symbol2.observable = result;
      } catch (err) {
      }
    }
  } else {
    result = "@@observable";
  }
  return result;
}

// ../../node_modules/@apollo/client/utilities/observables/Observable.js
var import_symbol_observable = __toModule(require_es());
import_zen_observable.default.prototype["@@observable"] = function() {
  return this;
};

// ../../node_modules/@apollo/client/utilities/common/cloneDeep.js
var toString3 = Object.prototype.toString;
function cloneDeep(value) {
  return cloneDeepHelper(value);
}
function cloneDeepHelper(val, seen) {
  switch (toString3.call(val)) {
    case "[object Array]": {
      seen = seen || new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_1 = val.slice(0);
      seen.set(val, copy_1);
      copy_1.forEach(function(child, i) {
        copy_1[i] = cloneDeepHelper(child, seen);
      });
      return copy_1;
    }
    case "[object Object]": {
      seen = seen || new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_2 = Object.create(Object.getPrototypeOf(val));
      seen.set(val, copy_2);
      Object.keys(val).forEach(function(key) {
        copy_2[key] = cloneDeepHelper(val[key], seen);
      });
      return copy_2;
    }
    default:
      return val;
  }
}

// ../../node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js
function maybeDeepFreeze(obj) {
  if (false) {
    deepFreeze(obj);
  }
  return obj;
}

// ../../node_modules/@apollo/client/utilities/observables/iteration.js
function iterateObserversSafely(observers, method, argument) {
  var observersWithMethod = [];
  observers.forEach(function(obs) {
    return obs[method] && observersWithMethod.push(obs);
  });
  observersWithMethod.forEach(function(obs) {
    return obs[method](argument);
  });
}

// ../../node_modules/@apollo/client/utilities/observables/asyncMap.js
function asyncMap(observable, mapFn, catchFn) {
  return new import_zen_observable.default(function(observer) {
    var next = observer.next, error = observer.error, complete = observer.complete;
    var activeCallbackCount = 0;
    var completed = false;
    function makeCallback(examiner, delegate) {
      if (examiner) {
        return function(arg) {
          ++activeCallbackCount;
          new Promise(function(resolve) {
            return resolve(examiner(arg));
          }).then(function(result) {
            --activeCallbackCount;
            next && next.call(observer, result);
            if (completed) {
              handler.complete();
            }
          }, function(e) {
            --activeCallbackCount;
            error && error.call(observer, e);
          });
        };
      } else {
        return function(arg) {
          return delegate && delegate.call(observer, arg);
        };
      }
    }
    var handler = {
      next: makeCallback(mapFn, next),
      error: makeCallback(catchFn, error),
      complete: function() {
        completed = true;
        if (!activeCallbackCount) {
          complete && complete.call(observer);
        }
      }
    };
    var sub = observable.subscribe(handler);
    return function() {
      return sub.unsubscribe();
    };
  });
}

// ../../node_modules/@apollo/client/utilities/observables/Concast.js
function isPromiseLike(value) {
  return value && typeof value.then === "function";
}
var Concast = function(_super) {
  __extends(Concast2, _super);
  function Concast2(sources) {
    var _this = _super.call(this, function(observer) {
      _this.addObserver(observer);
      return function() {
        return _this.removeObserver(observer);
      };
    }) || this;
    _this.observers = new Set();
    _this.addCount = 0;
    _this.promise = new Promise(function(resolve, reject) {
      _this.resolve = resolve;
      _this.reject = reject;
    });
    _this.handlers = {
      next: function(result) {
        if (_this.sub !== null) {
          _this.latest = ["next", result];
          iterateObserversSafely(_this.observers, "next", result);
        }
      },
      error: function(error) {
        var sub = _this.sub;
        if (sub !== null) {
          if (sub)
            Promise.resolve().then(function() {
              return sub.unsubscribe();
            });
          _this.sub = null;
          _this.latest = ["error", error];
          _this.reject(error);
          iterateObserversSafely(_this.observers, "error", error);
        }
      },
      complete: function() {
        if (_this.sub !== null) {
          var value = _this.sources.shift();
          if (!value) {
            _this.sub = null;
            if (_this.latest && _this.latest[0] === "next") {
              _this.resolve(_this.latest[1]);
            } else {
              _this.resolve();
            }
            iterateObserversSafely(_this.observers, "complete");
          } else if (isPromiseLike(value)) {
            value.then(function(obs) {
              return _this.sub = obs.subscribe(_this.handlers);
            });
          } else {
            _this.sub = value.subscribe(_this.handlers);
          }
        }
      }
    };
    _this.cancel = function(reason) {
      _this.reject(reason);
      _this.sources = [];
      _this.handlers.complete();
    };
    _this.promise.catch(function(_) {
    });
    if (isPromiseLike(sources)) {
      sources.then(function(iterable) {
        return _this.start(iterable);
      }, _this.handlers.error);
    } else {
      _this.start(sources);
    }
    return _this;
  }
  Concast2.prototype.start = function(sources) {
    if (this.sub !== void 0)
      return;
    this.sources = Array.from(sources);
    this.handlers.complete();
  };
  Concast2.prototype.deliverLastMessage = function(observer) {
    if (this.latest) {
      var nextOrError = this.latest[0];
      var method = observer[nextOrError];
      if (method) {
        method.call(observer, this.latest[1]);
      }
      if (this.sub === null && nextOrError === "next" && observer.complete) {
        observer.complete();
      }
    }
  };
  Concast2.prototype.addObserver = function(observer) {
    if (!this.observers.has(observer)) {
      this.deliverLastMessage(observer);
      this.observers.add(observer);
      ++this.addCount;
    }
  };
  Concast2.prototype.removeObserver = function(observer, quietly) {
    if (this.observers.delete(observer) && --this.addCount < 1 && !quietly) {
      this.handlers.error(new Error("Observable cancelled prematurely"));
    }
  };
  Concast2.prototype.cleanup = function(callback) {
    var _this = this;
    var called = false;
    var once3 = function() {
      if (!called) {
        called = true;
        _this.observers.delete(observer);
        callback();
      }
    };
    var observer = {
      next: once3,
      error: once3,
      complete: once3
    };
    var count = this.addCount;
    this.addObserver(observer);
    this.addCount = count;
  };
  return Concast2;
}(import_zen_observable.default);
if (typeof Symbol === "function" && Symbol.species) {
  Object.defineProperty(Concast, Symbol.species, {
    value: import_zen_observable.default
  });
}

// ../../node_modules/@apollo/client/utilities/common/arrays.js
function isNonEmptyArray2(value) {
  return Array.isArray(value) && value.length > 0;
}

// ../../node_modules/@apollo/client/utilities/common/errorHandling.js
function graphQLResultHasError(result) {
  return result.errors && result.errors.length > 0 || false;
}

// ../../node_modules/@apollo/client/utilities/common/canUse.js
var canUseWeakMap = typeof WeakMap === "function" && !(typeof navigator === "object" && navigator.product === "ReactNative");

// ../../node_modules/@apollo/client/utilities/common/compact.js
function compact() {
  var objects4 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    objects4[_i] = arguments[_i];
  }
  var result = Object.create(null);
  objects4.forEach(function(obj) {
    if (!obj)
      return;
    Object.keys(obj).forEach(function(key) {
      var value = obj[key];
      if (value !== void 0) {
        result[key] = value;
      }
    });
  });
  return result;
}

// ../../node_modules/@apollo/client/link/utils/fromError.js
function fromError(errorValue) {
  return new import_zen_observable.default(function(observer) {
    observer.error(errorValue);
  });
}

// ../../node_modules/@apollo/client/link/utils/throwServerError.js
var throwServerError = function(response, result, message) {
  var error = new Error(message);
  error.name = "ServerError";
  error.response = response;
  error.statusCode = response.status;
  error.result = result;
  throw error;
};

// ../../node_modules/@apollo/client/link/utils/validateOperation.js
function validateOperation(operation) {
  var OPERATION_FIELDS = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ];
  for (var _i = 0, _a5 = Object.keys(operation); _i < _a5.length; _i++) {
    var key = _a5[_i];
    if (OPERATION_FIELDS.indexOf(key) < 0) {
      throw true ? new InvariantError(26) : new InvariantError("illegal argument: " + key);
    }
  }
  return operation;
}

// ../../node_modules/@apollo/client/link/utils/createOperation.js
function createOperation(starting, operation) {
  var context2 = __assign({}, starting);
  var setContext2 = function(next) {
    if (typeof next === "function") {
      context2 = __assign(__assign({}, context2), next(context2));
    } else {
      context2 = __assign(__assign({}, context2), next);
    }
  };
  var getContext2 = function() {
    return __assign({}, context2);
  };
  Object.defineProperty(operation, "setContext", {
    enumerable: false,
    value: setContext2
  });
  Object.defineProperty(operation, "getContext", {
    enumerable: false,
    value: getContext2
  });
  return operation;
}

// ../../node_modules/@apollo/client/link/utils/transformOperation.js
function transformOperation(operation) {
  var transformedOperation = {
    variables: operation.variables || {},
    extensions: operation.extensions || {},
    operationName: operation.operationName,
    query: operation.query
  };
  if (!transformedOperation.operationName) {
    transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) || void 0 : "";
  }
  return transformedOperation;
}

// ../../node_modules/@apollo/client/link/core/ApolloLink.js
function passthrough(op, forward) {
  return forward ? forward(op) : import_zen_observable.default.of();
}
function toLink(handler) {
  return typeof handler === "function" ? new ApolloLink(handler) : handler;
}
function isTerminating(link) {
  return link.request.length <= 1;
}
var LinkError = function(_super) {
  __extends(LinkError2, _super);
  function LinkError2(message, link) {
    var _this = _super.call(this, message) || this;
    _this.link = link;
    return _this;
  }
  return LinkError2;
}(Error);
var ApolloLink = function() {
  function ApolloLink2(request) {
    if (request)
      this.request = request;
  }
  ApolloLink2.empty = function() {
    return new ApolloLink2(function() {
      return import_zen_observable.default.of();
    });
  };
  ApolloLink2.from = function(links) {
    if (links.length === 0)
      return ApolloLink2.empty();
    return links.map(toLink).reduce(function(x, y) {
      return x.concat(y);
    });
  };
  ApolloLink2.split = function(test, left, right) {
    var leftLink = toLink(left);
    var rightLink = toLink(right || new ApolloLink2(passthrough));
    if (isTerminating(leftLink) && isTerminating(rightLink)) {
      return new ApolloLink2(function(operation) {
        return test(operation) ? leftLink.request(operation) || import_zen_observable.default.of() : rightLink.request(operation) || import_zen_observable.default.of();
      });
    } else {
      return new ApolloLink2(function(operation, forward) {
        return test(operation) ? leftLink.request(operation, forward) || import_zen_observable.default.of() : rightLink.request(operation, forward) || import_zen_observable.default.of();
      });
    }
  };
  ApolloLink2.execute = function(link, operation) {
    return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || import_zen_observable.default.of();
  };
  ApolloLink2.concat = function(first2, second) {
    var firstLink = toLink(first2);
    if (isTerminating(firstLink)) {
      true;
      return firstLink;
    }
    var nextLink = toLink(second);
    if (isTerminating(nextLink)) {
      return new ApolloLink2(function(operation) {
        return firstLink.request(operation, function(op) {
          return nextLink.request(op) || import_zen_observable.default.of();
        }) || import_zen_observable.default.of();
      });
    } else {
      return new ApolloLink2(function(operation, forward) {
        return firstLink.request(operation, function(op) {
          return nextLink.request(op, forward) || import_zen_observable.default.of();
        }) || import_zen_observable.default.of();
      });
    }
  };
  ApolloLink2.prototype.split = function(test, left, right) {
    return this.concat(ApolloLink2.split(test, left, right || new ApolloLink2(passthrough)));
  };
  ApolloLink2.prototype.concat = function(next) {
    return ApolloLink2.concat(this, next);
  };
  ApolloLink2.prototype.request = function(operation, forward) {
    throw true ? new InvariantError(21) : new InvariantError("request is not implemented");
  };
  ApolloLink2.prototype.onError = function(error, observer) {
    if (observer && observer.error) {
      observer.error(error);
      return false;
    }
    throw error;
  };
  ApolloLink2.prototype.setOnError = function(fn) {
    this.onError = fn;
    return this;
  };
  return ApolloLink2;
}();

// ../../node_modules/@apollo/client/link/core/empty.js
var empty = ApolloLink.empty;

// ../../node_modules/@apollo/client/link/core/from.js
var from = ApolloLink.from;

// ../../node_modules/@apollo/client/link/core/split.js
var split = ApolloLink.split;

// ../../node_modules/@apollo/client/link/core/concat.js
var concat = ApolloLink.concat;

// ../../node_modules/@apollo/client/link/core/execute.js
var execute = ApolloLink.execute;

// ../../node_modules/@apollo/client/link/ws/index.js
var WebSocketLink = function(_super) {
  __extends(WebSocketLink2, _super);
  function WebSocketLink2(paramsOrClient) {
    var _this = _super.call(this) || this;
    if (paramsOrClient instanceof import_subscriptions_transport_ws.SubscriptionClient) {
      _this.subscriptionClient = paramsOrClient;
    } else {
      _this.subscriptionClient = new import_subscriptions_transport_ws.SubscriptionClient(paramsOrClient.uri, paramsOrClient.options, paramsOrClient.webSocketImpl);
    }
    return _this;
  }
  WebSocketLink2.prototype.request = function(operation) {
    return this.subscriptionClient.request(operation);
  };
  return WebSocketLink2;
}(ApolloLink);

// ../../node_modules/@apollo/client/link/error/index.js
function onError(errorHandler2) {
  return new ApolloLink(function(operation, forward) {
    return new import_zen_observable.default(function(observer) {
      var sub;
      var retriedSub;
      var retriedResult;
      try {
        sub = forward(operation).subscribe({
          next: function(result) {
            if (result.errors) {
              retriedResult = errorHandler2({
                graphQLErrors: result.errors,
                response: result,
                operation,
                forward
              });
              if (retriedResult) {
                retriedSub = retriedResult.subscribe({
                  next: observer.next.bind(observer),
                  error: observer.error.bind(observer),
                  complete: observer.complete.bind(observer)
                });
                return;
              }
            }
            observer.next(result);
          },
          error: function(networkError) {
            retriedResult = errorHandler2({
              operation,
              networkError,
              graphQLErrors: networkError && networkError.result && networkError.result.errors,
              forward
            });
            if (retriedResult) {
              retriedSub = retriedResult.subscribe({
                next: observer.next.bind(observer),
                error: observer.error.bind(observer),
                complete: observer.complete.bind(observer)
              });
              return;
            }
            observer.error(networkError);
          },
          complete: function() {
            if (!retriedResult) {
              observer.complete.bind(observer)();
            }
          }
        });
      } catch (e) {
        errorHandler2({networkError: e, operation, forward});
        observer.error(e);
      }
      return function() {
        if (sub)
          sub.unsubscribe();
        if (retriedSub)
          sub.unsubscribe();
      };
    });
  });
}
var ErrorLink = function(_super) {
  __extends(ErrorLink2, _super);
  function ErrorLink2(errorHandler2) {
    var _this = _super.call(this) || this;
    _this.link = onError(errorHandler2);
    return _this;
  }
  ErrorLink2.prototype.request = function(operation, forward) {
    return this.link.request(operation, forward);
  };
  return ErrorLink2;
}(ApolloLink);

// ../../node_modules/@apollo/client/version.js
var version = "3.3.7";

// ../../node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
function parseAndCheckHttpResponse(operations) {
  return function(response) {
    return response.text().then(function(bodyText) {
      try {
        return JSON.parse(bodyText);
      } catch (err) {
        var parseError = err;
        parseError.name = "ServerParseError";
        parseError.response = response;
        parseError.statusCode = response.status;
        parseError.bodyText = bodyText;
        throw parseError;
      }
    }).then(function(result) {
      if (response.status >= 300) {
        throwServerError(response, result, "Response not successful: Received status code " + response.status);
      }
      if (!Array.isArray(result) && !hasOwnProperty2.call(result, "data") && !hasOwnProperty2.call(result, "errors")) {
        throwServerError(response, result, "Server response was missing for query '" + (Array.isArray(operations) ? operations.map(function(op) {
          return op.operationName;
        }) : operations.operationName) + "'.");
      }
      return result;
    });
  };
}

// ../../node_modules/@apollo/client/link/http/serializeFetchParameter.js
var serializeFetchParameter = function(p, label) {
  var serialized;
  try {
    serialized = JSON.stringify(p);
  } catch (e) {
    var parseError = true ? new InvariantError(23) : new InvariantError("Network request failed. " + label + " is not serializable: " + e.message);
    parseError.parseError = e;
    throw parseError;
  }
  return serialized;
};

// ../../node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js
var defaultHttpOptions = {
  includeQuery: true,
  includeExtensions: false
};
var defaultHeaders = {
  accept: "*/*",
  "content-type": "application/json"
};
var defaultOptions3 = {
  method: "POST"
};
var fallbackHttpConfig = {
  http: defaultHttpOptions,
  headers: defaultHeaders,
  options: defaultOptions3
};
var selectHttpOptionsAndBody = function(operation, fallbackConfig) {
  var configs = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    configs[_i - 2] = arguments[_i];
  }
  var options = __assign(__assign({}, fallbackConfig.options), {headers: fallbackConfig.headers, credentials: fallbackConfig.credentials});
  var http = fallbackConfig.http || {};
  configs.forEach(function(config) {
    options = __assign(__assign(__assign({}, options), config.options), {headers: __assign(__assign({}, options.headers), config.headers)});
    if (config.credentials)
      options.credentials = config.credentials;
    http = __assign(__assign({}, http), config.http);
  });
  var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
  var body3 = {operationName, variables};
  if (http.includeExtensions)
    body3.extensions = extensions;
  if (http.includeQuery)
    body3.query = import_printer.print(query);
  return {
    options,
    body: body3
  };
};

// ../../node_modules/@apollo/client/link/http/checkFetcher.js
var checkFetcher = function(fetcher) {
  if (!fetcher && typeof fetch === "undefined") {
    throw true ? new InvariantError(22) : new InvariantError(`
"fetch" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:

import fetch from 'cross-fetch';
import { ApolloClient, HttpLink } from '@apollo/client';
const client = new ApolloClient({
  link: new HttpLink({ uri: '/graphql', fetch })
});
    `);
  }
};

// ../../node_modules/@apollo/client/link/http/createSignalIfSupported.js
var createSignalIfSupported = function() {
  if (typeof AbortController === "undefined")
    return {controller: false, signal: false};
  var controller = new AbortController();
  var signal = controller.signal;
  return {controller, signal};
};

// ../../node_modules/@apollo/client/link/http/selectURI.js
var selectURI = function(operation, fallbackURI) {
  var context2 = operation.getContext();
  var contextURI = context2.uri;
  if (contextURI) {
    return contextURI;
  } else if (typeof fallbackURI === "function") {
    return fallbackURI(operation);
  } else {
    return fallbackURI || "/graphql";
  }
};

// ../../node_modules/@apollo/client/link/http/rewriteURIForGET.js
function rewriteURIForGET(chosenURI, body3) {
  var queryParams = [];
  var addQueryParam = function(key, value) {
    queryParams.push(key + "=" + encodeURIComponent(value));
  };
  if ("query" in body3) {
    addQueryParam("query", body3.query);
  }
  if (body3.operationName) {
    addQueryParam("operationName", body3.operationName);
  }
  if (body3.variables) {
    var serializedVariables = void 0;
    try {
      serializedVariables = serializeFetchParameter(body3.variables, "Variables map");
    } catch (parseError) {
      return {parseError};
    }
    addQueryParam("variables", serializedVariables);
  }
  if (body3.extensions) {
    var serializedExtensions = void 0;
    try {
      serializedExtensions = serializeFetchParameter(body3.extensions, "Extensions map");
    } catch (parseError) {
      return {parseError};
    }
    addQueryParam("extensions", serializedExtensions);
  }
  var fragment = "", preFragment = chosenURI;
  var fragmentStart = chosenURI.indexOf("#");
  if (fragmentStart !== -1) {
    fragment = chosenURI.substr(fragmentStart);
    preFragment = chosenURI.substr(0, fragmentStart);
  }
  var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
  var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
  return {newURI};
}

// ../../node_modules/@apollo/client/link/http/createHttpLink.js
var createHttpLink = function(linkOptions) {
  if (linkOptions === void 0) {
    linkOptions = {};
  }
  var _a5 = linkOptions.uri, uri = _a5 === void 0 ? "/graphql" : _a5, fetcher = linkOptions.fetch, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, _b2 = linkOptions.includeUnusedVariables, includeUnusedVariables = _b2 === void 0 ? false : _b2, requestOptions = __rest(linkOptions, ["uri", "fetch", "includeExtensions", "useGETForQueries", "includeUnusedVariables"]);
  checkFetcher(fetcher);
  if (!fetcher) {
    fetcher = fetch;
  }
  var linkConfig = {
    http: {includeExtensions},
    options: requestOptions.fetchOptions,
    credentials: requestOptions.credentials,
    headers: requestOptions.headers
  };
  return new ApolloLink(function(operation) {
    var chosenURI = selectURI(operation, uri);
    var context2 = operation.getContext();
    var clientAwarenessHeaders = {};
    if (context2.clientAwareness) {
      var _a6 = context2.clientAwareness, name_1 = _a6.name, version2 = _a6.version;
      if (name_1) {
        clientAwarenessHeaders["apollographql-client-name"] = name_1;
      }
      if (version2) {
        clientAwarenessHeaders["apollographql-client-version"] = version2;
      }
    }
    var contextHeaders = __assign(__assign({}, clientAwarenessHeaders), context2.headers);
    var contextConfig = {
      http: context2.http,
      options: context2.fetchOptions,
      credentials: context2.credentials,
      headers: contextHeaders
    };
    var _b3 = selectHttpOptionsAndBody(operation, fallbackHttpConfig, linkConfig, contextConfig), options = _b3.options, body3 = _b3.body;
    if (body3.variables && !includeUnusedVariables) {
      var unusedNames_1 = new Set(Object.keys(body3.variables));
      visit(operation.query, {
        Variable: function(node, _key, parent2) {
          if (parent2 && parent2.kind !== "VariableDefinition") {
            unusedNames_1.delete(node.name.value);
          }
        }
      });
      if (unusedNames_1.size) {
        body3.variables = __assign({}, body3.variables);
        unusedNames_1.forEach(function(name) {
          delete body3.variables[name];
        });
      }
    }
    var controller;
    if (!options.signal) {
      var _c2 = createSignalIfSupported(), _controller = _c2.controller, signal = _c2.signal;
      controller = _controller;
      if (controller)
        options.signal = signal;
    }
    var definitionIsMutation = function(d) {
      return d.kind === "OperationDefinition" && d.operation === "mutation";
    };
    if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
      options.method = "GET";
    }
    if (options.method === "GET") {
      var _d2 = rewriteURIForGET(chosenURI, body3), newURI = _d2.newURI, parseError = _d2.parseError;
      if (parseError) {
        return fromError(parseError);
      }
      chosenURI = newURI;
    } else {
      try {
        options.body = serializeFetchParameter(body3, "Payload");
      } catch (parseError2) {
        return fromError(parseError2);
      }
    }
    return new import_zen_observable.default(function(observer) {
      fetcher(chosenURI, options).then(function(response) {
        operation.setContext({response});
        return response;
      }).then(parseAndCheckHttpResponse(operation)).then(function(result) {
        observer.next(result);
        observer.complete();
        return result;
      }).catch(function(err) {
        if (err.name === "AbortError")
          return;
        if (err.result && err.result.errors && err.result.data) {
          observer.next(err.result);
        }
        observer.error(err);
      });
      return function() {
        if (controller)
          controller.abort();
      };
    });
  });
};

// ../../node_modules/@apollo/client/link/http/HttpLink.js
var HttpLink = function(_super) {
  __extends(HttpLink2, _super);
  function HttpLink2(options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this, createHttpLink(options).request) || this;
    _this.options = options;
    return _this;
  }
  return HttpLink2;
}(ApolloLink);

// ../../node_modules/@wry/equality/lib/equality.esm.js
var _a3 = Object.prototype;
var toString4 = _a3.toString;
var hasOwnProperty3 = _a3.hasOwnProperty;
var fnToStr = Function.prototype.toString;
var previousComparisons = new Map();
function equal(a, b) {
  try {
    return check2(a, b);
  } finally {
    previousComparisons.clear();
  }
}
function check2(a, b) {
  if (a === b) {
    return true;
  }
  var aTag = toString4.call(a);
  var bTag = toString4.call(b);
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case "[object Array]":
      if (a.length !== b.length)
        return false;
    case "[object Object]": {
      if (previouslyCompared(a, b))
        return true;
      var aKeys = definedKeys(a);
      var bKeys = definedKeys(b);
      var keyCount = aKeys.length;
      if (keyCount !== bKeys.length)
        return false;
      for (var k = 0; k < keyCount; ++k) {
        if (!hasOwnProperty3.call(b, aKeys[k])) {
          return false;
        }
      }
      for (var k = 0; k < keyCount; ++k) {
        var key = aKeys[k];
        if (!check2(a[key], b[key])) {
          return false;
        }
      }
      return true;
    }
    case "[object Error]":
      return a.name === b.name && a.message === b.message;
    case "[object Number]":
      if (a !== a)
        return b !== b;
    case "[object Boolean]":
    case "[object Date]":
      return +a === +b;
    case "[object RegExp]":
    case "[object String]":
      return a == "" + b;
    case "[object Map]":
    case "[object Set]": {
      if (a.size !== b.size)
        return false;
      if (previouslyCompared(a, b))
        return true;
      var aIterator = a.entries();
      var isMap = aTag === "[object Map]";
      while (true) {
        var info = aIterator.next();
        if (info.done)
          break;
        var _a5 = info.value, aKey = _a5[0], aValue = _a5[1];
        if (!b.has(aKey)) {
          return false;
        }
        if (isMap && !check2(aValue, b.get(aKey))) {
          return false;
        }
      }
      return true;
    }
    case "[object Function]": {
      var aCode = fnToStr.call(a);
      if (aCode !== fnToStr.call(b)) {
        return false;
      }
      return !endsWith(aCode, nativeCodeSuffix);
    }
  }
  return false;
}
function definedKeys(obj) {
  return Object.keys(obj).filter(isDefinedKey, obj);
}
function isDefinedKey(key) {
  return this[key] !== void 0;
}
var nativeCodeSuffix = "{ [native code] }";
function endsWith(full, suffix) {
  var fromIndex = full.length - suffix.length;
  return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
}
function previouslyCompared(a, b) {
  var bSet = previousComparisons.get(a);
  if (bSet) {
    if (bSet.has(b))
      return true;
  } else {
    previousComparisons.set(a, bSet = new Set());
  }
  bSet.add(b);
  return false;
}

// ../../node_modules/@apollo/client/errors/index.js
function isApolloError(err) {
  return err.hasOwnProperty("graphQLErrors");
}
var generateErrorMessage = function(err) {
  var message = "";
  if (isNonEmptyArray2(err.graphQLErrors)) {
    err.graphQLErrors.forEach(function(graphQLError) {
      var errorMessage = graphQLError ? graphQLError.message : "Error message not found.";
      message += errorMessage + "\n";
    });
  }
  if (err.networkError) {
    message += err.networkError.message + "\n";
  }
  message = message.replace(/\n$/, "");
  return message;
};
var ApolloError = function(_super) {
  __extends(ApolloError2, _super);
  function ApolloError2(_a5) {
    var graphQLErrors = _a5.graphQLErrors, networkError = _a5.networkError, errorMessage = _a5.errorMessage, extraInfo = _a5.extraInfo;
    var _this = _super.call(this, errorMessage) || this;
    _this.graphQLErrors = graphQLErrors || [];
    _this.networkError = networkError || null;
    _this.message = errorMessage || generateErrorMessage(_this);
    _this.extraInfo = extraInfo;
    _this.__proto__ = ApolloError2.prototype;
    return _this;
  }
  return ApolloError2;
}(Error);

// ../../node_modules/@apollo/client/core/networkStatus.js
var NetworkStatus;
(function(NetworkStatus2) {
  NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
  NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
  NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
  NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
  NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
  NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
  NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
  return networkStatus ? networkStatus < 7 : false;
}

// ../../node_modules/@apollo/client/core/Reobserver.js
var Reobserver = function() {
  function Reobserver2(observer, options, fetch2, shouldFetch) {
    this.observer = observer;
    this.options = options;
    this.fetch = fetch2;
    this.shouldFetch = shouldFetch;
  }
  Reobserver2.prototype.reobserve = function(newOptions, newNetworkStatus) {
    if (newOptions) {
      this.updateOptions(newOptions);
    } else {
      this.updatePolling();
    }
    var concast = this.fetch(this.options, newNetworkStatus);
    if (this.concast) {
      this.concast.removeObserver(this.observer, true);
    }
    concast.addObserver(this.observer);
    return (this.concast = concast).promise;
  };
  Reobserver2.prototype.updateOptions = function(newOptions) {
    Object.assign(this.options, compact(newOptions));
    this.updatePolling();
    return this;
  };
  Reobserver2.prototype.stop = function() {
    if (this.concast) {
      this.concast.removeObserver(this.observer);
      delete this.concast;
    }
    if (this.pollingInfo) {
      clearTimeout(this.pollingInfo.timeout);
      this.options.pollInterval = 0;
      this.updatePolling();
    }
  };
  Reobserver2.prototype.updatePolling = function() {
    var _this = this;
    var _a5 = this, pollingInfo = _a5.pollingInfo, pollInterval = _a5.options.pollInterval;
    if (!pollInterval) {
      if (pollingInfo) {
        clearTimeout(pollingInfo.timeout);
        delete this.pollingInfo;
      }
      return;
    }
    if (pollingInfo && pollingInfo.interval === pollInterval) {
      return;
    }
    true ? invariant3(pollInterval, 20) : invariant3(pollInterval, "Attempted to start a polling query without a polling interval.");
    if (this.shouldFetch === false) {
      return;
    }
    var info = pollingInfo || (this.pollingInfo = {});
    info.interval = pollInterval;
    var maybeFetch = function() {
      if (_this.pollingInfo) {
        if (_this.shouldFetch && _this.shouldFetch()) {
          _this.reobserve({
            fetchPolicy: "network-only",
            nextFetchPolicy: _this.options.fetchPolicy || "cache-first"
          }, NetworkStatus.poll).then(poll, poll);
        } else {
          poll();
        }
      }
      ;
    };
    var poll = function() {
      var info2 = _this.pollingInfo;
      if (info2) {
        clearTimeout(info2.timeout);
        info2.timeout = setTimeout(maybeFetch, info2.interval);
      }
    };
    poll();
  };
  return Reobserver2;
}();

// ../../node_modules/@apollo/client/core/ObservableQuery.js
var warnedAboutUpdateQuery = false;
var ObservableQuery = function(_super) {
  __extends(ObservableQuery2, _super);
  function ObservableQuery2(_a5) {
    var queryManager = _a5.queryManager, queryInfo = _a5.queryInfo, options = _a5.options;
    var _this = _super.call(this, function(observer) {
      return _this.onSubscribe(observer);
    }) || this;
    _this.observers = new Set();
    _this.subscriptions = new Set();
    _this.observer = {
      next: function(result) {
        if (_this.lastError || _this.isDifferentFromLastResult(result)) {
          _this.updateLastResult(result);
          iterateObserversSafely(_this.observers, "next", result);
        }
      },
      error: function(error) {
        _this.updateLastResult(__assign(__assign({}, _this.lastResult), {error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false}));
        iterateObserversSafely(_this.observers, "error", _this.lastError = error);
      }
    };
    _this.isTornDown = false;
    _this.options = options;
    _this.queryId = queryManager.generateQueryId();
    var opDef = getOperationDefinition(options.query);
    _this.queryName = opDef && opDef.name && opDef.name.value;
    _this.queryManager = queryManager;
    _this.queryInfo = queryInfo;
    return _this;
  }
  Object.defineProperty(ObservableQuery2.prototype, "variables", {
    get: function() {
      return this.options.variables;
    },
    enumerable: false,
    configurable: true
  });
  ObservableQuery2.prototype.result = function() {
    var _this = this;
    return new Promise(function(resolve, reject) {
      var observer = {
        next: function(result) {
          resolve(result);
          _this.observers.delete(observer);
          if (!_this.observers.size) {
            _this.queryManager.removeQuery(_this.queryId);
          }
          setTimeout(function() {
            subscription.unsubscribe();
          }, 0);
        },
        error: reject
      };
      var subscription = _this.subscribe(observer);
    });
  };
  ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
    if (saveAsLastResult === void 0) {
      saveAsLastResult = true;
    }
    var lastResult = this.lastResult;
    var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;
    var result = __assign(__assign({}, lastResult), {loading: isNetworkRequestInFlight(networkStatus), networkStatus});
    if (this.isTornDown) {
      return result;
    }
    var _a5 = this.options.fetchPolicy, fetchPolicy = _a5 === void 0 ? "cache-first" : _a5;
    if (fetchPolicy === "no-cache" || fetchPolicy === "network-only") {
      delete result.partial;
    } else if (!result.data || !this.queryManager.transform(this.options.query).hasForcedResolvers) {
      var diff = this.queryInfo.getDiff();
      result.data = diff.complete || this.options.returnPartialData ? diff.result : void 0;
      if (diff.complete) {
        if (result.networkStatus === NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
          result.networkStatus = NetworkStatus.ready;
          result.loading = false;
        }
        delete result.partial;
      } else {
        result.partial = true;
      }
    }
    if (saveAsLastResult) {
      this.updateLastResult(result);
    }
    return result;
  };
  ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult) {
    return !equal(this.lastResultSnapshot, newResult);
  };
  ObservableQuery2.prototype.getLastResult = function() {
    return this.lastResult;
  };
  ObservableQuery2.prototype.getLastError = function() {
    return this.lastError;
  };
  ObservableQuery2.prototype.resetLastResults = function() {
    delete this.lastResult;
    delete this.lastResultSnapshot;
    delete this.lastError;
    this.isTornDown = false;
  };
  ObservableQuery2.prototype.resetQueryStoreErrors = function() {
    this.queryManager.resetErrors(this.queryId);
  };
  ObservableQuery2.prototype.refetch = function(variables) {
    var reobserveOptions = {
      pollInterval: 0
    };
    var fetchPolicy = this.options.fetchPolicy;
    if (fetchPolicy !== "no-cache" && fetchPolicy !== "cache-and-network") {
      reobserveOptions.fetchPolicy = "network-only";
      reobserveOptions.nextFetchPolicy = fetchPolicy || "cache-first";
    }
    if (variables && !equal(this.options.variables, variables)) {
      reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);
    }
    return this.newReobserver(false).reobserve(reobserveOptions, NetworkStatus.refetch);
  };
  ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
    var _this = this;
    var combinedOptions = __assign(__assign({}, fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign({}, this.options), fetchMoreOptions), {variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables)})), {fetchPolicy: "no-cache"});
    var qid = this.queryManager.generateQueryId();
    if (combinedOptions.notifyOnNetworkStatusChange) {
      this.queryInfo.networkStatus = NetworkStatus.fetchMore;
      this.observe();
    }
    return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {
      var data = fetchMoreResult.data;
      var updateQuery = fetchMoreOptions.updateQuery;
      if (updateQuery) {
        if (false) {
          true;
          warnedAboutUpdateQuery = true;
        }
        _this.updateQuery(function(previous) {
          return updateQuery(previous, {
            fetchMoreResult: data,
            variables: combinedOptions.variables
          });
        });
      } else {
        _this.queryManager.cache.writeQuery({
          query: combinedOptions.query,
          variables: combinedOptions.variables,
          data
        });
      }
      return fetchMoreResult;
    }).finally(function() {
      _this.queryManager.stopQuery(qid);
      _this.reobserve();
    });
  };
  ObservableQuery2.prototype.subscribeToMore = function(options) {
    var _this = this;
    var subscription = this.queryManager.startGraphQLSubscription({
      query: options.document,
      variables: options.variables,
      context: options.context
    }).subscribe({
      next: function(subscriptionData) {
        var updateQuery = options.updateQuery;
        if (updateQuery) {
          _this.updateQuery(function(previous, _a5) {
            var variables = _a5.variables;
            return updateQuery(previous, {
              subscriptionData,
              variables
            });
          });
        }
      },
      error: function(err) {
        if (options.onError) {
          options.onError(err);
          return;
        }
        true;
      }
    });
    this.subscriptions.add(subscription);
    return function() {
      if (_this.subscriptions.delete(subscription)) {
        subscription.unsubscribe();
      }
    };
  };
  ObservableQuery2.prototype.setOptions = function(newOptions) {
    return this.reobserve(newOptions);
  };
  ObservableQuery2.prototype.setVariables = function(variables) {
    if (equal(this.variables, variables)) {
      return this.observers.size ? this.result() : Promise.resolve();
    }
    this.options.variables = variables;
    if (!this.observers.size) {
      return Promise.resolve();
    }
    var _a5 = this.options.fetchPolicy, fetchPolicy = _a5 === void 0 ? "cache-first" : _a5;
    var reobserveOptions = {
      fetchPolicy,
      variables
    };
    if (fetchPolicy !== "cache-first" && fetchPolicy !== "no-cache" && fetchPolicy !== "network-only") {
      reobserveOptions.fetchPolicy = "cache-and-network";
      reobserveOptions.nextFetchPolicy = fetchPolicy;
    }
    return this.reobserve(reobserveOptions, NetworkStatus.setVariables);
  };
  ObservableQuery2.prototype.updateQuery = function(mapFn) {
    var _a5;
    var queryManager = this.queryManager;
    var result = queryManager.cache.diff({
      query: this.options.query,
      variables: this.variables,
      previousResult: (_a5 = this.lastResult) === null || _a5 === void 0 ? void 0 : _a5.data,
      returnPartialData: true,
      optimistic: false
    }).result;
    var newResult = mapFn(result, {
      variables: this.variables
    });
    if (newResult) {
      queryManager.cache.writeQuery({
        query: this.options.query,
        data: newResult,
        variables: this.variables
      });
      queryManager.broadcastQueries();
    }
  };
  ObservableQuery2.prototype.startPolling = function(pollInterval) {
    this.getReobserver().updateOptions({pollInterval});
  };
  ObservableQuery2.prototype.stopPolling = function() {
    if (this.reobserver) {
      this.reobserver.updateOptions({pollInterval: 0});
    }
  };
  ObservableQuery2.prototype.updateLastResult = function(newResult) {
    var previousResult = this.lastResult;
    this.lastResult = newResult;
    this.lastResultSnapshot = this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult);
    if (!isNonEmptyArray2(newResult.errors)) {
      delete this.lastError;
    }
    return previousResult;
  };
  ObservableQuery2.prototype.onSubscribe = function(observer) {
    var _this = this;
    if (observer === this.observer) {
      return function() {
      };
    }
    try {
      var subObserver = observer._subscription._observer;
      if (subObserver && !subObserver.error) {
        subObserver.error = defaultSubscriptionObserverErrorCallback;
      }
    } catch (_a5) {
    }
    var first2 = !this.observers.size;
    this.observers.add(observer);
    if (this.lastError) {
      observer.error && observer.error(this.lastError);
    } else if (this.lastResult) {
      observer.next && observer.next(this.lastResult);
    }
    if (first2) {
      this.reobserve().catch(function(_) {
      });
    }
    return function() {
      if (_this.observers.delete(observer) && !_this.observers.size) {
        _this.tearDownQuery();
      }
    };
  };
  ObservableQuery2.prototype.getReobserver = function() {
    return this.reobserver || (this.reobserver = this.newReobserver(true));
  };
  ObservableQuery2.prototype.newReobserver = function(shareOptions) {
    var _this = this;
    var _a5 = this, queryManager = _a5.queryManager, queryId = _a5.queryId;
    queryManager.setObservableQuery(this);
    return new Reobserver(this.observer, shareOptions ? this.options : __assign({}, this.options), function(currentOptions, newNetworkStatus) {
      queryManager.setObservableQuery(_this);
      return queryManager.fetchQueryObservable(queryId, currentOptions, newNetworkStatus);
    }, !queryManager.ssrMode && function() {
      return !isNetworkRequestInFlight(_this.queryInfo.networkStatus);
    });
  };
  ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
    this.isTornDown = false;
    return this.getReobserver().reobserve(newOptions, newNetworkStatus);
  };
  ObservableQuery2.prototype.observe = function() {
    this.observer.next(this.getCurrentResult(false));
  };
  ObservableQuery2.prototype.hasObservers = function() {
    return this.observers.size > 0;
  };
  ObservableQuery2.prototype.tearDownQuery = function() {
    if (this.isTornDown)
      return;
    if (this.reobserver) {
      this.reobserver.stop();
      delete this.reobserver;
    }
    delete this.options.context;
    this.subscriptions.forEach(function(sub) {
      return sub.unsubscribe();
    });
    this.subscriptions.clear();
    this.queryManager.stopQuery(this.queryId);
    this.observers.clear();
    this.isTornDown = true;
  };
  return ObservableQuery2;
}(import_zen_observable.default);
function defaultSubscriptionObserverErrorCallback(error) {
  true;
}

// ../../node_modules/@wry/trie/lib/trie.esm.js
var defaultMakeData = function() {
  return Object.create(null);
};
var _a4 = Array.prototype;
var forEach = _a4.forEach;
var slice = _a4.slice;
var Trie = function() {
  function Trie2(weakness, makeData) {
    if (weakness === void 0) {
      weakness = true;
    }
    if (makeData === void 0) {
      makeData = defaultMakeData;
    }
    this.weakness = weakness;
    this.makeData = makeData;
  }
  Trie2.prototype.lookup = function() {
    var array4 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      array4[_i] = arguments[_i];
    }
    return this.lookupArray(array4);
  };
  Trie2.prototype.lookupArray = function(array4) {
    var node = this;
    forEach.call(array4, function(key) {
      return node = node.getChildTrie(key);
    });
    return node.data || (node.data = this.makeData(slice.call(array4)));
  };
  Trie2.prototype.getChildTrie = function(key) {
    var map = this.weakness && isObjRef(key) ? this.weak || (this.weak = new WeakMap()) : this.strong || (this.strong = new Map());
    var child = map.get(key);
    if (!child)
      map.set(key, child = new Trie2(this.weakness, this.makeData));
    return child;
  };
  return Trie2;
}();
function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}

// ../../node_modules/@wry/context/lib/context.esm.js
var currentContext = null;
var MISSING_VALUE = {};
var idCounter = 1;
var makeSlotClass = function() {
  return function() {
    function Slot2() {
      this.id = [
        "slot",
        idCounter++,
        Date.now(),
        Math.random().toString(36).slice(2)
      ].join(":");
    }
    Slot2.prototype.hasValue = function() {
      for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
        if (this.id in context_1.slots) {
          var value = context_1.slots[this.id];
          if (value === MISSING_VALUE)
            break;
          if (context_1 !== currentContext) {
            currentContext.slots[this.id] = value;
          }
          return true;
        }
      }
      if (currentContext) {
        currentContext.slots[this.id] = MISSING_VALUE;
      }
      return false;
    };
    Slot2.prototype.getValue = function() {
      if (this.hasValue()) {
        return currentContext.slots[this.id];
      }
    };
    Slot2.prototype.withValue = function(value, callback, args, thisArg) {
      var _a5;
      var slots = (_a5 = {
        __proto__: null
      }, _a5[this.id] = value, _a5);
      var parent2 = currentContext;
      currentContext = {parent: parent2, slots};
      try {
        return callback.apply(thisArg, args);
      } finally {
        currentContext = parent2;
      }
    };
    Slot2.bind = function(callback) {
      var context2 = currentContext;
      return function() {
        var saved = currentContext;
        try {
          currentContext = context2;
          return callback.apply(this, arguments);
        } finally {
          currentContext = saved;
        }
      };
    };
    Slot2.noContext = function(callback, args, thisArg) {
      if (currentContext) {
        var saved = currentContext;
        try {
          currentContext = null;
          return callback.apply(thisArg, args);
        } finally {
          currentContext = saved;
        }
      } else {
        return callback.apply(thisArg, args);
      }
    };
    return Slot2;
  }();
};
var globalKey = "@wry/context:Slot";
var host = Array;
var Slot = host[globalKey] || function() {
  var Slot2 = makeSlotClass();
  try {
    Object.defineProperty(host, globalKey, {
      value: host[globalKey] = Slot2,
      enumerable: false,
      writable: false,
      configurable: false
    });
  } finally {
    return Slot2;
  }
}();
var bind = Slot.bind;
var noContext = Slot.noContext;

// ../../node_modules/optimism/lib/bundle.esm.js
function defaultDispose() {
}
var Cache = function() {
  function Cache3(max, dispose2) {
    if (max === void 0) {
      max = Infinity;
    }
    if (dispose2 === void 0) {
      dispose2 = defaultDispose;
    }
    this.max = max;
    this.dispose = dispose2;
    this.map = new Map();
    this.newest = null;
    this.oldest = null;
  }
  Cache3.prototype.has = function(key) {
    return this.map.has(key);
  };
  Cache3.prototype.get = function(key) {
    var entry = this.getEntry(key);
    return entry && entry.value;
  };
  Cache3.prototype.getEntry = function(key) {
    var entry = this.map.get(key);
    if (entry && entry !== this.newest) {
      var older = entry.older, newer = entry.newer;
      if (newer) {
        newer.older = older;
      }
      if (older) {
        older.newer = newer;
      }
      entry.older = this.newest;
      entry.older.newer = entry;
      entry.newer = null;
      this.newest = entry;
      if (entry === this.oldest) {
        this.oldest = newer;
      }
    }
    return entry;
  };
  Cache3.prototype.set = function(key, value) {
    var entry = this.getEntry(key);
    if (entry) {
      return entry.value = value;
    }
    entry = {
      key,
      value,
      newer: null,
      older: this.newest
    };
    if (this.newest) {
      this.newest.newer = entry;
    }
    this.newest = entry;
    this.oldest = this.oldest || entry;
    this.map.set(key, entry);
    return entry.value;
  };
  Cache3.prototype.clean = function() {
    while (this.oldest && this.map.size > this.max) {
      this.delete(this.oldest.key);
    }
  };
  Cache3.prototype.delete = function(key) {
    var entry = this.map.get(key);
    if (entry) {
      if (entry === this.newest) {
        this.newest = entry.older;
      }
      if (entry === this.oldest) {
        this.oldest = entry.newer;
      }
      if (entry.newer) {
        entry.newer.older = entry.older;
      }
      if (entry.older) {
        entry.older.newer = entry.newer;
      }
      this.map.delete(key);
      this.dispose(entry.value, key);
      return true;
    }
    return false;
  };
  return Cache3;
}();
var parentEntrySlot = new Slot();
function maybeUnsubscribe(entryOrDep) {
  var unsubscribe5 = entryOrDep.unsubscribe;
  if (typeof unsubscribe5 === "function") {
    entryOrDep.unsubscribe = void 0;
    unsubscribe5();
  }
}
var emptySetPool = [];
var POOL_TARGET_SIZE = 100;
function assert(condition, optionalMessage) {
  if (!condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}
function valueIs(a, b) {
  var len = a.length;
  return len > 0 && len === b.length && a[len - 1] === b[len - 1];
}
function valueGet(value) {
  switch (value.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return value[0];
    case 2:
      throw value[1];
  }
}
function valueCopy(value) {
  return value.slice(0);
}
var Entry = function() {
  function Entry2(fn) {
    this.fn = fn;
    this.parents = new Set();
    this.childValues = new Map();
    this.dirtyChildren = null;
    this.dirty = true;
    this.recomputing = false;
    this.value = [];
    this.deps = null;
    ++Entry2.count;
  }
  Entry2.prototype.peek = function() {
    if (this.value.length === 1 && !mightBeDirty(this)) {
      return this.value[0];
    }
  };
  Entry2.prototype.recompute = function(args) {
    assert(!this.recomputing, "already recomputing");
    rememberParent(this);
    return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
  };
  Entry2.prototype.setDirty = function() {
    if (this.dirty)
      return;
    this.dirty = true;
    this.value.length = 0;
    reportDirty(this);
    forgetChildren(this);
    maybeUnsubscribe(this);
  };
  Entry2.prototype.dispose = function() {
    var _this = this;
    forgetChildren(this);
    maybeUnsubscribe(this);
    this.parents.forEach(function(parent2) {
      parent2.setDirty();
      forgetChild(parent2, _this);
    });
  };
  Entry2.prototype.dependOn = function(dep2) {
    dep2.add(this);
    if (!this.deps) {
      this.deps = emptySetPool.pop() || new Set();
    }
    this.deps.add(dep2);
  };
  Entry2.prototype.forgetDeps = function() {
    var _this = this;
    if (this.deps) {
      this.deps.forEach(function(dep2) {
        return dep2.delete(_this);
      });
      this.deps.clear();
      emptySetPool.push(this.deps);
      this.deps = null;
    }
  };
  Entry2.count = 0;
  return Entry2;
}();
function rememberParent(child) {
  var parent2 = parentEntrySlot.getValue();
  if (parent2) {
    child.parents.add(parent2);
    if (!parent2.childValues.has(child)) {
      parent2.childValues.set(child, []);
    }
    if (mightBeDirty(child)) {
      reportDirtyChild(parent2, child);
    } else {
      reportCleanChild(parent2, child);
    }
    return parent2;
  }
}
function reallyRecompute(entry, args) {
  forgetChildren(entry);
  parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
  if (maybeSubscribe(entry, args)) {
    setClean(entry);
  }
  return valueGet(entry.value);
}
function recomputeNewValue(entry, args) {
  entry.recomputing = true;
  entry.value.length = 0;
  try {
    entry.value[0] = entry.fn.apply(null, args);
  } catch (e) {
    entry.value[1] = e;
  }
  entry.recomputing = false;
}
function mightBeDirty(entry) {
  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
  entry.dirty = false;
  if (mightBeDirty(entry)) {
    return;
  }
  reportClean(entry);
}
function reportDirty(child) {
  child.parents.forEach(function(parent2) {
    return reportDirtyChild(parent2, child);
  });
}
function reportClean(child) {
  child.parents.forEach(function(parent2) {
    return reportCleanChild(parent2, child);
  });
}
function reportDirtyChild(parent2, child) {
  assert(parent2.childValues.has(child));
  assert(mightBeDirty(child));
  if (!parent2.dirtyChildren) {
    parent2.dirtyChildren = emptySetPool.pop() || new Set();
  } else if (parent2.dirtyChildren.has(child)) {
    return;
  }
  parent2.dirtyChildren.add(child);
  reportDirty(parent2);
}
function reportCleanChild(parent2, child) {
  assert(parent2.childValues.has(child));
  assert(!mightBeDirty(child));
  var childValue = parent2.childValues.get(child);
  if (childValue.length === 0) {
    parent2.childValues.set(child, valueCopy(child.value));
  } else if (!valueIs(childValue, child.value)) {
    parent2.setDirty();
  }
  removeDirtyChild(parent2, child);
  if (mightBeDirty(parent2)) {
    return;
  }
  reportClean(parent2);
}
function removeDirtyChild(parent2, child) {
  var dc = parent2.dirtyChildren;
  if (dc) {
    dc.delete(child);
    if (dc.size === 0) {
      if (emptySetPool.length < POOL_TARGET_SIZE) {
        emptySetPool.push(dc);
      }
      parent2.dirtyChildren = null;
    }
  }
}
function forgetChildren(parent2) {
  if (parent2.childValues.size > 0) {
    parent2.childValues.forEach(function(_value, child) {
      forgetChild(parent2, child);
    });
  }
  parent2.forgetDeps();
  assert(parent2.dirtyChildren === null);
}
function forgetChild(parent2, child) {
  child.parents.delete(parent2);
  parent2.childValues.delete(child);
  removeDirtyChild(parent2, child);
}
function maybeSubscribe(entry, args) {
  if (typeof entry.subscribe === "function") {
    try {
      maybeUnsubscribe(entry);
      entry.unsubscribe = entry.subscribe.apply(null, args);
    } catch (e) {
      entry.setDirty();
      return false;
    }
  }
  return true;
}
function dep(options) {
  var depsByKey = new Map();
  var subscribe5 = options && options.subscribe;
  function depend(key) {
    var parent2 = parentEntrySlot.getValue();
    if (parent2) {
      var dep_1 = depsByKey.get(key);
      if (!dep_1) {
        depsByKey.set(key, dep_1 = new Set());
      }
      parent2.dependOn(dep_1);
      if (typeof subscribe5 === "function") {
        maybeUnsubscribe(dep_1);
        dep_1.unsubscribe = subscribe5(key);
      }
    }
  }
  depend.dirty = function dirty(key) {
    var dep2 = depsByKey.get(key);
    if (dep2) {
      dep2.forEach(function(entry) {
        return entry.setDirty();
      });
      depsByKey.delete(key);
      maybeUnsubscribe(dep2);
    }
  };
  return depend;
}
var keyTrie = new Trie(typeof WeakMap === "function");
function defaultMakeCacheKey() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return keyTrie.lookupArray(args);
}
var caches = new Set();
function wrap(originalFunction, options) {
  if (options === void 0) {
    options = Object.create(null);
  }
  var cache = new Cache(options.max || Math.pow(2, 16), function(entry) {
    return entry.dispose();
  });
  var keyArgs = options.keyArgs || function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return args;
  };
  var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;
  function optimistic() {
    var key = makeCacheKey.apply(null, keyArgs.apply(null, arguments));
    if (key === void 0) {
      return originalFunction.apply(null, arguments);
    }
    var entry = cache.get(key);
    if (!entry) {
      cache.set(key, entry = new Entry(originalFunction));
      entry.subscribe = options.subscribe;
    }
    var value = entry.recompute(Array.prototype.slice.call(arguments));
    cache.set(key, entry);
    caches.add(cache);
    if (!parentEntrySlot.hasValue()) {
      caches.forEach(function(cache2) {
        return cache2.clean();
      });
      caches.clear();
    }
    return value;
  }
  function lookup() {
    var key = makeCacheKey.apply(null, arguments);
    if (key !== void 0) {
      return cache.get(key);
    }
  }
  optimistic.dirty = function() {
    var entry = lookup.apply(null, arguments);
    if (entry) {
      entry.setDirty();
    }
  };
  optimistic.peek = function() {
    var entry = lookup.apply(null, arguments);
    if (entry) {
      return entry.peek();
    }
  };
  optimistic.forget = function() {
    var key = makeCacheKey.apply(null, arguments);
    return key !== void 0 && cache.delete(key);
  };
  return optimistic;
}

// ../../node_modules/@apollo/client/cache/core/cache.js
var ApolloCache = function() {
  function ApolloCache2() {
    this.getFragmentDoc = wrap(getFragmentQueryDocument);
  }
  ApolloCache2.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
    this.performTransaction(transaction, optimisticId);
  };
  ApolloCache2.prototype.transformDocument = function(document2) {
    return document2;
  };
  ApolloCache2.prototype.identify = function(object2) {
    return;
  };
  ApolloCache2.prototype.gc = function() {
    return [];
  };
  ApolloCache2.prototype.modify = function(options) {
    return false;
  };
  ApolloCache2.prototype.transformForLink = function(document2) {
    return document2;
  };
  ApolloCache2.prototype.readQuery = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = !!options.optimistic;
    }
    return this.read({
      rootId: options.id || "ROOT_QUERY",
      query: options.query,
      variables: options.variables,
      returnPartialData: options.returnPartialData,
      optimistic
    });
  };
  ApolloCache2.prototype.readFragment = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = !!options.optimistic;
    }
    return this.read({
      query: this.getFragmentDoc(options.fragment, options.fragmentName),
      variables: options.variables,
      rootId: options.id,
      returnPartialData: options.returnPartialData,
      optimistic
    });
  };
  ApolloCache2.prototype.writeQuery = function(options) {
    return this.write({
      dataId: options.id || "ROOT_QUERY",
      result: options.data,
      query: options.query,
      variables: options.variables,
      broadcast: options.broadcast
    });
  };
  ApolloCache2.prototype.writeFragment = function(options) {
    return this.write({
      dataId: options.id,
      result: options.data,
      variables: options.variables,
      query: this.getFragmentDoc(options.fragment, options.fragmentName),
      broadcast: options.broadcast
    });
  };
  return ApolloCache2;
}();

// ../../node_modules/@apollo/client/cache/core/types/Cache.js
var Cache2;
(function(Cache3) {
})(Cache2 || (Cache2 = {}));

// ../../node_modules/@apollo/client/cache/core/types/common.js
var MissingFieldError = function() {
  function MissingFieldError2(message, path3, query, clientOnly, variables) {
    this.message = message;
    this.path = path3;
    this.query = query;
    this.clientOnly = clientOnly;
    this.variables = variables;
  }
  return MissingFieldError2;
}();

// ../../node_modules/@apollo/client/cache/inmemory/helpers.js
var hasOwn = Object.prototype.hasOwnProperty;
var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
function fieldNameFromStoreName(storeFieldName) {
  var match = storeFieldName.match(TypeOrFieldNameRegExp);
  return match ? match[0] : storeFieldName;
}
function selectionSetMatchesResult(selectionSet, result, variables) {
  if (result && typeof result === "object") {
    return Array.isArray(result) ? result.every(function(item) {
      return selectionSetMatchesResult(selectionSet, item, variables);
    }) : selectionSet.selections.every(function(field) {
      if (isField(field) && shouldInclude(field, variables)) {
        var key = resultKeyNameFromField(field);
        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));
      }
      return true;
    });
  }
  return false;
}
function storeValueIsStoreObject(value) {
  return value !== null && typeof value === "object" && !isReference(value) && !Array.isArray(value);
}
function makeProcessedFieldsMerger() {
  return new DeepMerger();
}

// ../../node_modules/@apollo/client/cache/inmemory/entityStore.js
var DELETE = Object.create(null);
var delModifier = function() {
  return DELETE;
};
var INVALIDATE = Object.create(null);
var EntityStore = function() {
  function EntityStore2(policies, group) {
    var _this = this;
    this.policies = policies;
    this.group = group;
    this.data = Object.create(null);
    this.rootIds = Object.create(null);
    this.refs = Object.create(null);
    this.getFieldValue = function(objectOrReference, storeFieldName) {
      return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
    };
    this.canRead = function(objOrRef) {
      return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
    };
    this.toReference = function(objOrIdOrRef, mergeIntoStore) {
      if (typeof objOrIdOrRef === "string") {
        return makeReference(objOrIdOrRef);
      }
      if (isReference(objOrIdOrRef)) {
        return objOrIdOrRef;
      }
      var id = _this.policies.identify(objOrIdOrRef)[0];
      if (id) {
        var ref = makeReference(id);
        if (mergeIntoStore) {
          _this.merge(id, objOrIdOrRef);
        }
        return ref;
      }
    };
  }
  EntityStore2.prototype.toObject = function() {
    return __assign({}, this.data);
  };
  EntityStore2.prototype.has = function(dataId) {
    return this.lookup(dataId, true) !== void 0;
  };
  EntityStore2.prototype.get = function(dataId, fieldName) {
    this.group.depend(dataId, fieldName);
    if (hasOwn.call(this.data, dataId)) {
      var storeObject = this.data[dataId];
      if (storeObject && hasOwn.call(storeObject, fieldName)) {
        return storeObject[fieldName];
      }
    }
    if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
      return this.policies.rootTypenamesById[dataId];
    }
    if (this instanceof Layer) {
      return this.parent.get(dataId, fieldName);
    }
  };
  EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
    if (dependOnExistence)
      this.group.depend(dataId, "__exists");
    if (hasOwn.call(this.data, dataId)) {
      return this.data[dataId];
    }
    if (this instanceof Layer) {
      return this.parent.lookup(dataId, dependOnExistence);
    }
    if (this.policies.rootTypenamesById[dataId]) {
      return Object.create(null);
    }
  };
  EntityStore2.prototype.merge = function(dataId, incoming) {
    var _this = this;
    var existing = this.lookup(dataId);
    var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
    this.data[dataId] = merged;
    if (merged !== existing) {
      delete this.refs[dataId];
      if (this.group.caching) {
        var fieldsToDirty_1 = Object.create(null);
        if (!existing)
          fieldsToDirty_1.__exists = 1;
        Object.keys(incoming).forEach(function(storeFieldName) {
          if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
            fieldsToDirty_1[storeFieldName] = 1;
            var fieldName = fieldNameFromStoreName(storeFieldName);
            if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
              fieldsToDirty_1[fieldName] = 1;
            }
            if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
              delete merged[storeFieldName];
            }
          }
        });
        Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
          return _this.group.dirty(dataId, fieldName);
        });
      }
    }
  };
  EntityStore2.prototype.modify = function(dataId, fields) {
    var _this = this;
    var storeObject = this.lookup(dataId);
    if (storeObject) {
      var changedFields_1 = Object.create(null);
      var needToMerge_1 = false;
      var allDeleted_1 = true;
      var sharedDetails_1 = {
        DELETE,
        INVALIDATE,
        isReference,
        toReference: this.toReference,
        canRead: this.canRead,
        readField: function(fieldNameOrOptions, from2) {
          return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
            fieldName: fieldNameOrOptions,
            from: from2 || makeReference(dataId)
          } : fieldNameOrOptions, {store: _this});
        }
      };
      Object.keys(storeObject).forEach(function(storeFieldName) {
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var fieldValue = storeObject[storeFieldName];
        if (fieldValue === void 0)
          return;
        var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
        if (modify) {
          var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), {
            fieldName,
            storeFieldName,
            storage: _this.getStorage(dataId, storeFieldName)
          }));
          if (newValue === INVALIDATE) {
            _this.group.dirty(dataId, storeFieldName);
          } else {
            if (newValue === DELETE)
              newValue = void 0;
            if (newValue !== fieldValue) {
              changedFields_1[storeFieldName] = newValue;
              needToMerge_1 = true;
              fieldValue = newValue;
            }
          }
        }
        if (fieldValue !== void 0) {
          allDeleted_1 = false;
        }
      });
      if (needToMerge_1) {
        this.merge(dataId, changedFields_1);
        if (allDeleted_1) {
          if (this instanceof Layer) {
            this.data[dataId] = void 0;
          } else {
            delete this.data[dataId];
          }
          this.group.dirty(dataId, "__exists");
        }
        return true;
      }
    }
    return false;
  };
  EntityStore2.prototype.delete = function(dataId, fieldName, args) {
    var _a5;
    var storeObject = this.lookup(dataId);
    if (storeObject) {
      var typename = this.getFieldValue(storeObject, "__typename");
      var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({typename, fieldName, args}) : fieldName;
      return this.modify(dataId, storeFieldName ? (_a5 = {}, _a5[storeFieldName] = delModifier, _a5) : delModifier);
    }
    return false;
  };
  EntityStore2.prototype.evict = function(options) {
    var evicted = false;
    if (options.id) {
      if (hasOwn.call(this.data, options.id)) {
        evicted = this.delete(options.id, options.fieldName, options.args);
      }
      if (this instanceof Layer) {
        evicted = this.parent.evict(options) || evicted;
      }
      if (options.fieldName || evicted) {
        this.group.dirty(options.id, options.fieldName || "__exists");
      }
    }
    return evicted;
  };
  EntityStore2.prototype.clear = function() {
    this.replace(null);
  };
  EntityStore2.prototype.extract = function() {
    var _this = this;
    var obj = this.toObject();
    var extraRootIds = [];
    this.getRootIdSet().forEach(function(id) {
      if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {
        extraRootIds.push(id);
      }
    });
    if (extraRootIds.length) {
      obj.__META = {extraRootIds: extraRootIds.sort()};
    }
    return obj;
  };
  EntityStore2.prototype.replace = function(newData) {
    var _this = this;
    Object.keys(this.data).forEach(function(dataId) {
      if (!(newData && hasOwn.call(newData, dataId))) {
        _this.delete(dataId);
      }
    });
    if (newData) {
      var __META = newData.__META, rest_1 = __rest(newData, ["__META"]);
      Object.keys(rest_1).forEach(function(dataId) {
        _this.merge(dataId, rest_1[dataId]);
      });
      if (__META) {
        __META.extraRootIds.forEach(this.retain, this);
      }
    }
  };
  EntityStore2.prototype.retain = function(rootId) {
    return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
  };
  EntityStore2.prototype.release = function(rootId) {
    if (this.rootIds[rootId] > 0) {
      var count = --this.rootIds[rootId];
      if (!count)
        delete this.rootIds[rootId];
      return count;
    }
    return 0;
  };
  EntityStore2.prototype.getRootIdSet = function(ids2) {
    if (ids2 === void 0) {
      ids2 = new Set();
    }
    Object.keys(this.rootIds).forEach(ids2.add, ids2);
    if (this instanceof Layer) {
      this.parent.getRootIdSet(ids2);
    } else {
      Object.keys(this.policies.rootTypenamesById).forEach(ids2.add, ids2);
    }
    return ids2;
  };
  EntityStore2.prototype.gc = function() {
    var _this = this;
    var ids2 = this.getRootIdSet();
    var snapshot = this.toObject();
    ids2.forEach(function(id) {
      if (hasOwn.call(snapshot, id)) {
        Object.keys(_this.findChildRefIds(id)).forEach(ids2.add, ids2);
        delete snapshot[id];
      }
    });
    var idsToRemove = Object.keys(snapshot);
    if (idsToRemove.length) {
      var root_1 = this;
      while (root_1 instanceof Layer)
        root_1 = root_1.parent;
      idsToRemove.forEach(function(id) {
        return root_1.delete(id);
      });
    }
    return idsToRemove;
  };
  EntityStore2.prototype.findChildRefIds = function(dataId) {
    if (!hasOwn.call(this.refs, dataId)) {
      var found_1 = this.refs[dataId] = Object.create(null);
      var workSet_1 = new Set([this.data[dataId]]);
      var canTraverse_1 = function(obj) {
        return obj !== null && typeof obj === "object";
      };
      workSet_1.forEach(function(obj) {
        if (isReference(obj)) {
          found_1[obj.__ref] = true;
        } else if (canTraverse_1(obj)) {
          Object.values(obj).filter(canTraverse_1).forEach(workSet_1.add, workSet_1);
        }
      });
    }
    return this.refs[dataId];
  };
  EntityStore2.prototype.makeCacheKey = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return this.group.keyMaker.lookupArray(args);
  };
  return EntityStore2;
}();
var CacheGroup = function() {
  function CacheGroup2(caching) {
    this.caching = caching;
    this.d = null;
    this.keyMaker = new Trie(canUseWeakMap);
    this.d = caching ? dep() : null;
  }
  CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
    if (this.d) {
      this.d(makeDepKey(dataId, storeFieldName));
      var fieldName = fieldNameFromStoreName(storeFieldName);
      if (fieldName !== storeFieldName) {
        this.d(makeDepKey(dataId, fieldName));
      }
    }
  };
  CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
    if (this.d) {
      this.d.dirty(makeDepKey(dataId, storeFieldName));
    }
  };
  return CacheGroup2;
}();
function makeDepKey(dataId, storeFieldName) {
  return storeFieldName + "#" + dataId;
}
(function(EntityStore2) {
  var Root = function(_super) {
    __extends(Root2, _super);
    function Root2(_a5) {
      var policies = _a5.policies, _b2 = _a5.resultCaching, resultCaching = _b2 === void 0 ? true : _b2, seed = _a5.seed;
      var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
      _this.storageTrie = new Trie(canUseWeakMap);
      _this.sharedLayerGroup = new CacheGroup(resultCaching);
      if (seed)
        _this.replace(seed);
      return _this;
    }
    Root2.prototype.addLayer = function(layerId, replay) {
      return new Layer(layerId, this, replay, this.sharedLayerGroup);
    };
    Root2.prototype.removeLayer = function() {
      return this;
    };
    Root2.prototype.getStorage = function() {
      return this.storageTrie.lookupArray(arguments);
    };
    return Root2;
  }(EntityStore2);
  EntityStore2.Root = Root;
})(EntityStore || (EntityStore = {}));
var Layer = function(_super) {
  __extends(Layer2, _super);
  function Layer2(id, parent2, replay, group) {
    var _this = _super.call(this, parent2.policies, group) || this;
    _this.id = id;
    _this.parent = parent2;
    _this.replay = replay;
    _this.group = group;
    replay(_this);
    return _this;
  }
  Layer2.prototype.addLayer = function(layerId, replay) {
    return new Layer2(layerId, this, replay, this.group);
  };
  Layer2.prototype.removeLayer = function(layerId) {
    var _this = this;
    var parent2 = this.parent.removeLayer(layerId);
    if (layerId === this.id) {
      if (this.group.caching) {
        Object.keys(this.data).forEach(function(dataId) {
          if (_this.data[dataId] !== parent2.lookup(dataId)) {
            _this.delete(dataId);
          }
        });
      }
      return parent2;
    }
    if (parent2 === this.parent)
      return this;
    return parent2.addLayer(this.id, this.replay);
  };
  Layer2.prototype.toObject = function() {
    return __assign(__assign({}, this.parent.toObject()), this.data);
  };
  Layer2.prototype.findChildRefIds = function(dataId) {
    var fromParent = this.parent.findChildRefIds(dataId);
    return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
  };
  Layer2.prototype.getStorage = function() {
    var p = this.parent;
    while (p.parent)
      p = p.parent;
    return p.getStorage.apply(p, arguments);
  };
  return Layer2;
}(EntityStore);
function storeObjectReconciler(existingObject, incomingObject, property) {
  var existingValue = existingObject[property];
  var incomingValue = incomingObject[property];
  return equal(existingValue, incomingValue) ? existingValue : incomingValue;
}
function supportsResultCaching(store) {
  return !!(store instanceof EntityStore && store.group.caching);
}

// ../../node_modules/@apollo/client/cache/inmemory/readFromStore.js
function missingFromInvariant(err, context2) {
  return new MissingFieldError(err.message, context2.path.slice(), context2.query, context2.clientOnly, context2.variables);
}
var StoreReader = function() {
  function StoreReader2(config) {
    var _this = this;
    this.config = config;
    this.executeSelectionSet = wrap(function(options) {
      return _this.execSelectionSetImpl(options);
    }, {
      keyArgs: function(options) {
        return [
          options.selectionSet,
          options.objectOrReference,
          options.context
        ];
      },
      makeCacheKey: function(selectionSet, parent2, context2) {
        if (supportsResultCaching(context2.store)) {
          return context2.store.makeCacheKey(selectionSet, isReference(parent2) ? parent2.__ref : parent2, context2.varString);
        }
      }
    });
    this.knownResults = new WeakMap();
    this.executeSubSelectedArray = wrap(function(options) {
      return _this.execSubSelectedArrayImpl(options);
    }, {
      makeCacheKey: function(_a5) {
        var field = _a5.field, array4 = _a5.array, context2 = _a5.context;
        if (supportsResultCaching(context2.store)) {
          return context2.store.makeCacheKey(field, array4, context2.varString);
        }
      }
    });
    this.config = __assign({addTypename: true}, config);
  }
  StoreReader2.prototype.diffQueryAgainstStore = function(_a5) {
    var store = _a5.store, query = _a5.query, _b2 = _a5.rootId, rootId = _b2 === void 0 ? "ROOT_QUERY" : _b2, variables = _a5.variables, _c2 = _a5.returnPartialData, returnPartialData = _c2 === void 0 ? true : _c2;
    var policies = this.config.cache.policies;
    variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);
    var execResult = this.executeSelectionSet({
      selectionSet: getMainDefinition(query).selectionSet,
      objectOrReference: makeReference(rootId),
      context: {
        store,
        query,
        policies,
        variables,
        varString: JSON.stringify(variables),
        fragmentMap: createFragmentMap(getFragmentDefinitions(query)),
        path: [],
        clientOnly: false
      }
    });
    var hasMissingFields = execResult.missing && execResult.missing.length > 0;
    if (hasMissingFields && !returnPartialData) {
      throw execResult.missing[0];
    }
    return {
      result: execResult.result,
      missing: execResult.missing,
      complete: !hasMissingFields
    };
  };
  StoreReader2.prototype.isFresh = function(result, parent2, selectionSet, context2) {
    if (supportsResultCaching(context2.store) && this.knownResults.get(result) === selectionSet) {
      var latest = this.executeSelectionSet.peek(selectionSet, parent2, context2);
      if (latest && result === latest.result) {
        return true;
      }
    }
    return false;
  };
  StoreReader2.prototype.execSelectionSetImpl = function(_a5) {
    var _this = this;
    var selectionSet = _a5.selectionSet, objectOrReference = _a5.objectOrReference, context2 = _a5.context;
    if (isReference(objectOrReference) && !context2.policies.rootTypenamesById[objectOrReference.__ref] && !context2.store.has(objectOrReference.__ref)) {
      return {
        result: {},
        missing: [missingFromInvariant(true ? new InvariantError(4) : new InvariantError("Dangling reference to missing " + objectOrReference.__ref + " object"), context2)]
      };
    }
    var variables = context2.variables, policies = context2.policies, store = context2.store;
    var objectsToMerge = [];
    var finalResult = {result: null};
    var typename = store.getFieldValue(objectOrReference, "__typename");
    if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
      objectsToMerge.push({__typename: typename});
    }
    function getMissing() {
      return finalResult.missing || (finalResult.missing = []);
    }
    function handleMissing(result) {
      var _a6;
      if (result.missing)
        (_a6 = getMissing()).push.apply(_a6, result.missing);
      return result.result;
    }
    var workSet = new Set(selectionSet.selections);
    workSet.forEach(function(selection) {
      var _a6;
      if (!shouldInclude(selection, variables))
        return;
      if (isField(selection)) {
        var fieldValue = policies.readField({
          fieldName: selection.name.value,
          field: selection,
          variables: context2.variables,
          from: objectOrReference
        }, context2);
        var resultName = resultKeyNameFromField(selection);
        context2.path.push(resultName);
        var wasClientOnly = context2.clientOnly;
        context2.clientOnly = wasClientOnly || !!(selection.directives && selection.directives.some(function(d) {
          return d.name.value === "client";
        }));
        if (fieldValue === void 0) {
          if (!addTypenameToDocument.added(selection)) {
            getMissing().push(missingFromInvariant(true ? new InvariantError(5) : new InvariantError("Can't find field '" + selection.name.value + "' on " + (isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2))), context2));
          }
        } else if (Array.isArray(fieldValue)) {
          fieldValue = handleMissing(_this.executeSubSelectedArray({
            field: selection,
            array: fieldValue,
            context: context2
          }));
        } else if (!selection.selectionSet) {
          if (false) {
            assertSelectionSetForIdValue(context2.store, selection, fieldValue);
            maybeDeepFreeze(fieldValue);
          }
        } else if (fieldValue != null) {
          fieldValue = handleMissing(_this.executeSelectionSet({
            selectionSet: selection.selectionSet,
            objectOrReference: fieldValue,
            context: context2
          }));
        }
        if (fieldValue !== void 0) {
          objectsToMerge.push((_a6 = {}, _a6[resultName] = fieldValue, _a6));
        }
        context2.clientOnly = wasClientOnly;
        invariant3(context2.path.pop() === resultName);
      } else {
        var fragment = getFragmentFromSelection(selection, context2.fragmentMap);
        if (fragment && policies.fragmentMatches(fragment, typename)) {
          fragment.selectionSet.selections.forEach(workSet.add, workSet);
        }
      }
    });
    finalResult.result = mergeDeepArray(objectsToMerge);
    if (false) {
      Object.freeze(finalResult.result);
    }
    this.knownResults.set(finalResult.result, selectionSet);
    return finalResult;
  };
  StoreReader2.prototype.execSubSelectedArrayImpl = function(_a5) {
    var _this = this;
    var field = _a5.field, array4 = _a5.array, context2 = _a5.context;
    var missing;
    function handleMissing(childResult, i) {
      if (childResult.missing) {
        missing = missing || [];
        missing.push.apply(missing, childResult.missing);
      }
      invariant3(context2.path.pop() === i);
      return childResult.result;
    }
    if (field.selectionSet) {
      array4 = array4.filter(context2.store.canRead);
    }
    array4 = array4.map(function(item, i) {
      if (item === null) {
        return null;
      }
      context2.path.push(i);
      if (Array.isArray(item)) {
        return handleMissing(_this.executeSubSelectedArray({
          field,
          array: item,
          context: context2
        }), i);
      }
      if (field.selectionSet) {
        return handleMissing(_this.executeSelectionSet({
          selectionSet: field.selectionSet,
          objectOrReference: item,
          context: context2
        }), i);
      }
      if (false) {
        assertSelectionSetForIdValue(context2.store, field, item);
      }
      invariant3(context2.path.pop() === i);
      return item;
    });
    if (false) {
      Object.freeze(array4);
    }
    return {result: array4, missing};
  };
  return StoreReader2;
}();

// ../../node_modules/@apollo/client/cache/inmemory/writeToStore.js
var StoreWriter = function() {
  function StoreWriter2(cache, reader) {
    this.cache = cache;
    this.reader = reader;
  }
  StoreWriter2.prototype.writeToStore = function(_a5) {
    var query = _a5.query, result = _a5.result, dataId = _a5.dataId, store = _a5.store, variables = _a5.variables;
    var operationDefinition = getOperationDefinition(query);
    var merger = makeProcessedFieldsMerger();
    variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);
    var ref = this.processSelectionSet({
      result: result || Object.create(null),
      dataId,
      selectionSet: operationDefinition.selectionSet,
      mergeTree: {map: new Map()},
      context: {
        store,
        written: Object.create(null),
        merge: function(existing, incoming) {
          return merger.merge(existing, incoming);
        },
        variables,
        varString: JSON.stringify(variables),
        fragmentMap: createFragmentMap(getFragmentDefinitions(query))
      }
    });
    if (!isReference(ref)) {
      throw true ? new InvariantError(7) : new InvariantError("Could not identify object " + JSON.stringify(result));
    }
    store.retain(ref.__ref);
    return ref;
  };
  StoreWriter2.prototype.processSelectionSet = function(_a5) {
    var _this = this;
    var dataId = _a5.dataId, result = _a5.result, selectionSet = _a5.selectionSet, context2 = _a5.context, mergeTree = _a5.mergeTree;
    var policies = this.cache.policies;
    var _b2 = policies.identify(result, selectionSet, context2.fragmentMap), id = _b2[0], keyObject = _b2[1];
    dataId = dataId || id;
    if (typeof dataId === "string") {
      var sets = context2.written[dataId] || (context2.written[dataId] = []);
      var ref = makeReference(dataId);
      if (sets.indexOf(selectionSet) >= 0)
        return ref;
      sets.push(selectionSet);
      if (this.reader && this.reader.isFresh(result, ref, selectionSet, context2)) {
        return ref;
      }
    }
    var incomingFields = Object.create(null);
    if (keyObject) {
      incomingFields = context2.merge(incomingFields, keyObject);
    }
    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context2.fragmentMap) || dataId && context2.store.get(dataId, "__typename");
    if (typeof typename === "string") {
      incomingFields.__typename = typename;
    }
    var workSet = new Set(selectionSet.selections);
    workSet.forEach(function(selection) {
      var _a6;
      if (!shouldInclude(selection, context2.variables))
        return;
      if (isField(selection)) {
        var resultFieldKey = resultKeyNameFromField(selection);
        var value = result[resultFieldKey];
        if (typeof value !== "undefined") {
          var storeFieldName = policies.getStoreFieldName({
            typename,
            fieldName: selection.name.value,
            field: selection,
            variables: context2.variables
          });
          var childTree = getChildMergeTree(mergeTree, storeFieldName);
          var incomingValue = _this.processFieldValue(value, selection, context2, childTree);
          var childTypename = selection.selectionSet && context2.store.getFieldValue(incomingValue, "__typename") || void 0;
          var merge = policies.getMergeFunction(typename, selection.name.value, childTypename);
          if (merge) {
            childTree.info = {
              field: selection,
              typename,
              merge
            };
          } else {
            maybeRecycleChildMergeTree(mergeTree, storeFieldName);
          }
          incomingFields = context2.merge(incomingFields, (_a6 = {}, _a6[storeFieldName] = incomingValue, _a6));
        } else if (policies.usingPossibleTypes && !hasDirectives(["defer", "client"], selection)) {
          throw true ? new InvariantError(8) : new InvariantError("Missing field '" + resultFieldKey + "' in " + JSON.stringify(result, null, 2).substring(0, 100));
        }
      } else {
        var fragment = getFragmentFromSelection(selection, context2.fragmentMap);
        if (fragment && policies.fragmentMatches(fragment, typename, result, context2.variables)) {
          fragment.selectionSet.selections.forEach(workSet.add, workSet);
        }
      }
    });
    if (typeof dataId === "string") {
      var entityRef_1 = makeReference(dataId);
      if (mergeTree.map.size) {
        incomingFields = this.applyMerges(mergeTree, entityRef_1, incomingFields, context2);
      }
      if (false) {
        var hasSelectionSet_1 = function(storeFieldName) {
          return fieldsWithSelectionSets_1.has(fieldNameFromStoreName(storeFieldName));
        };
        var fieldsWithSelectionSets_1 = new Set();
        workSet.forEach(function(selection) {
          if (isField(selection) && selection.selectionSet) {
            fieldsWithSelectionSets_1.add(selection.name.value);
          }
        });
        var hasMergeFunction_1 = function(storeFieldName) {
          var childTree = mergeTree.map.get(storeFieldName);
          return Boolean(childTree && childTree.info && childTree.info.merge);
        };
        Object.keys(incomingFields).forEach(function(storeFieldName) {
          if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
            warnAboutDataLoss(entityRef_1, incomingFields, storeFieldName, context2.store);
          }
        });
      }
      context2.store.merge(dataId, incomingFields);
      return entityRef_1;
    }
    return incomingFields;
  };
  StoreWriter2.prototype.processFieldValue = function(value, field, context2, mergeTree) {
    var _this = this;
    if (!field.selectionSet || value === null) {
      return true ? value : cloneDeep(value);
    }
    if (Array.isArray(value)) {
      return value.map(function(item, i) {
        var value2 = _this.processFieldValue(item, field, context2, getChildMergeTree(mergeTree, i));
        maybeRecycleChildMergeTree(mergeTree, i);
        return value2;
      });
    }
    return this.processSelectionSet({
      result: value,
      selectionSet: field.selectionSet,
      context: context2,
      mergeTree
    });
  };
  StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context2, getStorageArgs) {
    var _a5;
    var _this = this;
    if (mergeTree.map.size && !isReference(incoming)) {
      var e_1 = !Array.isArray(incoming) && (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;
      var i_1 = incoming;
      if (e_1 && !getStorageArgs) {
        getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];
      }
      var changedFields_1;
      var getValue_1 = function(from2, name) {
        return Array.isArray(from2) ? typeof name === "number" ? from2[name] : void 0 : context2.store.getFieldValue(from2, String(name));
      };
      mergeTree.map.forEach(function(childTree, storeFieldName) {
        if (getStorageArgs) {
          getStorageArgs.push(storeFieldName);
        }
        var eVal = getValue_1(e_1, storeFieldName);
        var iVal = getValue_1(i_1, storeFieldName);
        var aVal = _this.applyMerges(childTree, eVal, iVal, context2, getStorageArgs);
        if (aVal !== iVal) {
          changedFields_1 = changedFields_1 || new Map();
          changedFields_1.set(storeFieldName, aVal);
        }
        if (getStorageArgs) {
          invariant3(getStorageArgs.pop() === storeFieldName);
        }
      });
      if (changedFields_1) {
        incoming = Array.isArray(i_1) ? i_1.slice(0) : __assign({}, i_1);
        changedFields_1.forEach(function(value, name) {
          incoming[name] = value;
        });
      }
    }
    if (mergeTree.info) {
      return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context2, getStorageArgs && (_a5 = context2.store).getStorage.apply(_a5, getStorageArgs));
    }
    return incoming;
  };
  return StoreWriter2;
}();
var emptyMergeTreePool = [];
function getChildMergeTree(_a5, name) {
  var map = _a5.map;
  if (!map.has(name)) {
    map.set(name, emptyMergeTreePool.pop() || {map: new Map()});
  }
  return map.get(name);
}
function maybeRecycleChildMergeTree(_a5, name) {
  var map = _a5.map;
  var childTree = map.get(name);
  if (childTree && !childTree.info && !childTree.map.size) {
    emptyMergeTreePool.push(childTree);
    map.delete(name);
  }
}
var warnings = new Set();

// ../../node_modules/@apollo/client/cache/inmemory/reactiveVars.js
var varDep = dep();
var cacheSlot = new Slot();
function consumeAndIterate(set5, callback) {
  if (set5.size) {
    var items_1 = [];
    set5.forEach(function(item) {
      return items_1.push(item);
    });
    set5.clear();
    items_1.forEach(callback);
  }
}
var varsByCache = new WeakMap();
function forgetCache(cache) {
  var vars = varsByCache.get(cache);
  if (vars) {
    consumeAndIterate(vars, function(rv) {
      return rv.forgetCache(cache);
    });
    varsByCache.delete(cache);
  }
}
function makeVar(value) {
  var caches2 = new Set();
  var listeners = new Set();
  var rv = function(newValue) {
    if (arguments.length > 0) {
      if (value !== newValue) {
        value = newValue;
        varDep.dirty(rv);
        caches2.forEach(broadcast);
        consumeAndIterate(listeners, function(listener) {
          return listener(value);
        });
      }
    } else {
      var cache = cacheSlot.getValue();
      if (cache)
        attach(cache);
      varDep(rv);
    }
    return value;
  };
  rv.onNextChange = function(listener) {
    listeners.add(listener);
    return function() {
      listeners.delete(listener);
    };
  };
  var attach = rv.attachCache = function(cache) {
    caches2.add(cache);
    var vars = varsByCache.get(cache);
    if (!vars)
      varsByCache.set(cache, vars = new Set());
    vars.add(rv);
    return rv;
  };
  rv.forgetCache = function(cache) {
    var deleted = caches2.delete(cache);
    if (deleted) {
      var vars = varsByCache.get(cache);
      if (vars)
        vars.delete(rv);
    }
    return deleted;
  };
  return rv;
}
function broadcast(cache) {
  if (cache.broadcastWatches) {
    cache.broadcastWatches();
  }
}

// ../../node_modules/@apollo/client/cache/inmemory/policies.js
function argsFromFieldSpecifier(spec) {
  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;
}
var defaultDataIdFromObject = function(_a5, context2) {
  var __typename = _a5.__typename, id = _a5.id, _id = _a5._id;
  if (typeof __typename === "string") {
    if (context2) {
      context2.keyObject = id !== void 0 ? {id} : _id !== void 0 ? {_id} : void 0;
    }
    if (id === void 0)
      id = _id;
    if (id !== void 0) {
      return __typename + ":" + (typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id));
    }
  }
};
var nullKeyFieldsFn = function() {
  return void 0;
};
var simpleKeyArgsFn = function(_args, context2) {
  return context2.fieldName;
};
var mergeTrueFn = function(existing, incoming, _a5) {
  var mergeObjects = _a5.mergeObjects;
  return mergeObjects(existing, incoming);
};
var mergeFalseFn = function(_, incoming) {
  return incoming;
};
var Policies = function() {
  function Policies2(config) {
    this.config = config;
    this.typePolicies = Object.create(null);
    this.toBeAdded = Object.create(null);
    this.supertypeMap = new Map();
    this.fuzzySubtypes = new Map();
    this.rootIdsByTypename = Object.create(null);
    this.rootTypenamesById = Object.create(null);
    this.usingPossibleTypes = false;
    this.config = __assign({dataIdFromObject: defaultDataIdFromObject}, config);
    this.cache = this.config.cache;
    this.setRootTypename("Query");
    this.setRootTypename("Mutation");
    this.setRootTypename("Subscription");
    if (config.possibleTypes) {
      this.addPossibleTypes(config.possibleTypes);
    }
    if (config.typePolicies) {
      this.addTypePolicies(config.typePolicies);
    }
  }
  Policies2.prototype.identify = function(object2, selectionSet, fragmentMap) {
    var typename = selectionSet && fragmentMap ? getTypenameFromResult(object2, selectionSet, fragmentMap) : object2.__typename;
    if (typename === this.rootTypenamesById.ROOT_QUERY) {
      return ["ROOT_QUERY"];
    }
    var context2 = {
      typename,
      selectionSet,
      fragmentMap
    };
    var id;
    var policy = typename && this.getTypePolicy(typename);
    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
    while (keyFn) {
      var specifierOrId = keyFn(object2, context2);
      if (Array.isArray(specifierOrId)) {
        keyFn = keyFieldsFnFromSpecifier(specifierOrId);
      } else {
        id = specifierOrId;
        break;
      }
    }
    id = id && String(id);
    return context2.keyObject ? [id, context2.keyObject] : [id];
  };
  Policies2.prototype.addTypePolicies = function(typePolicies) {
    var _this = this;
    Object.keys(typePolicies).forEach(function(typename) {
      var _a5 = typePolicies[typename], queryType = _a5.queryType, mutationType = _a5.mutationType, subscriptionType = _a5.subscriptionType, incoming = __rest(_a5, ["queryType", "mutationType", "subscriptionType"]);
      if (queryType)
        _this.setRootTypename("Query", typename);
      if (mutationType)
        _this.setRootTypename("Mutation", typename);
      if (subscriptionType)
        _this.setRootTypename("Subscription", typename);
      if (hasOwn.call(_this.toBeAdded, typename)) {
        _this.toBeAdded[typename].push(incoming);
      } else {
        _this.toBeAdded[typename] = [incoming];
      }
    });
  };
  Policies2.prototype.updateTypePolicy = function(typename, incoming) {
    var _this = this;
    var existing = this.getTypePolicy(typename);
    var keyFields = incoming.keyFields, fields = incoming.fields;
    function setMerge(existing2, merge) {
      existing2.merge = typeof merge === "function" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing2.merge;
    }
    setMerge(existing, incoming.merge);
    existing.keyFn = keyFields === false ? nullKeyFieldsFn : Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
    if (fields) {
      Object.keys(fields).forEach(function(fieldName) {
        var existing2 = _this.getFieldPolicy(typename, fieldName, true);
        var incoming2 = fields[fieldName];
        if (typeof incoming2 === "function") {
          existing2.read = incoming2;
        } else {
          var keyArgs = incoming2.keyArgs, read = incoming2.read, merge = incoming2.merge;
          existing2.keyFn = keyArgs === false ? simpleKeyArgsFn : Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
          if (typeof read === "function") {
            existing2.read = read;
          }
          setMerge(existing2, merge);
        }
        if (existing2.read && existing2.merge) {
          existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
        }
      });
    }
  };
  Policies2.prototype.setRootTypename = function(which, typename) {
    if (typename === void 0) {
      typename = which;
    }
    var rootId = "ROOT_" + which.toUpperCase();
    var old = this.rootTypenamesById[rootId];
    if (typename !== old) {
      true ? invariant3(!old || old === which, 1) : invariant3(!old || old === which, "Cannot change root " + which + " __typename more than once");
      if (old)
        delete this.rootIdsByTypename[old];
      this.rootIdsByTypename[typename] = rootId;
      this.rootTypenamesById[rootId] = typename;
    }
  };
  Policies2.prototype.addPossibleTypes = function(possibleTypes) {
    var _this = this;
    this.usingPossibleTypes = true;
    Object.keys(possibleTypes).forEach(function(supertype) {
      _this.getSupertypeSet(supertype, true);
      possibleTypes[supertype].forEach(function(subtype) {
        _this.getSupertypeSet(subtype, true).add(supertype);
        var match = subtype.match(TypeOrFieldNameRegExp);
        if (!match || match[0] !== subtype) {
          _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
        }
      });
    });
  };
  Policies2.prototype.getTypePolicy = function(typename) {
    var _this = this;
    if (!hasOwn.call(this.typePolicies, typename)) {
      var policy_1 = this.typePolicies[typename] = Object.create(null);
      policy_1.fields = Object.create(null);
      var supertypes = this.supertypeMap.get(typename);
      if (supertypes && supertypes.size) {
        supertypes.forEach(function(supertype) {
          var _a5 = _this.getTypePolicy(supertype), fields = _a5.fields, rest = __rest(_a5, ["fields"]);
          Object.assign(policy_1, rest);
          Object.assign(policy_1.fields, fields);
        });
      }
    }
    var inbox = this.toBeAdded[typename];
    if (inbox && inbox.length) {
      this.updateTypePolicy(typename, compact.apply(void 0, inbox.splice(0)));
    }
    return this.typePolicies[typename];
  };
  Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
    if (typename) {
      var fieldPolicies = this.getTypePolicy(typename).fields;
      return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));
    }
  };
  Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
    var supertypeSet = this.supertypeMap.get(subtype);
    if (!supertypeSet && createIfMissing) {
      this.supertypeMap.set(subtype, supertypeSet = new Set());
    }
    return supertypeSet;
  };
  Policies2.prototype.fragmentMatches = function(fragment, typename, result, variables) {
    var _this = this;
    if (!fragment.typeCondition)
      return true;
    if (!typename)
      return false;
    var supertype = fragment.typeCondition.name.value;
    if (typename === supertype)
      return true;
    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
      var typenameSupertypeSet = this.getSupertypeSet(typename, true);
      var workQueue_1 = [typenameSupertypeSet];
      var maybeEnqueue_1 = function(subtype) {
        var supertypeSet2 = _this.getSupertypeSet(subtype, false);
        if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
          workQueue_1.push(supertypeSet2);
        }
      };
      var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
      var checkingFuzzySubtypes = false;
      for (var i = 0; i < workQueue_1.length; ++i) {
        var supertypeSet = workQueue_1[i];
        if (supertypeSet.has(supertype)) {
          if (!typenameSupertypeSet.has(supertype)) {
            if (checkingFuzzySubtypes) {
              true;
            }
            typenameSupertypeSet.add(supertype);
          }
          return true;
        }
        supertypeSet.forEach(maybeEnqueue_1);
        if (needToCheckFuzzySubtypes && i === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
          needToCheckFuzzySubtypes = false;
          checkingFuzzySubtypes = true;
          this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
            var match = typename.match(regExp);
            if (match && match[0] === typename) {
              maybeEnqueue_1(fuzzyString);
            }
          });
        }
      }
    }
    return false;
  };
  Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
    var policy = this.getFieldPolicy(typename, fieldName, false);
    return !!(policy && policy.keyFn);
  };
  Policies2.prototype.getStoreFieldName = function(fieldSpec) {
    var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
    var policy = this.getFieldPolicy(typename, fieldName, false);
    var storeFieldName;
    var keyFn = policy && policy.keyFn;
    if (keyFn && typename) {
      var context2 = {
        typename,
        fieldName,
        field: fieldSpec.field || null,
        variables: fieldSpec.variables
      };
      var args = argsFromFieldSpecifier(fieldSpec);
      while (keyFn) {
        var specifierOrString = keyFn(args, context2);
        if (Array.isArray(specifierOrString)) {
          keyFn = keyArgsFnFromSpecifier(specifierOrString);
        } else {
          storeFieldName = specifierOrString || fieldName;
          break;
        }
      }
    }
    if (storeFieldName === void 0) {
      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
    }
    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
  };
  Policies2.prototype.readField = function(options, context2) {
    var objectOrReference = options.from;
    if (!objectOrReference)
      return;
    var nameOrField = options.field || options.fieldName;
    if (!nameOrField)
      return;
    if (options.typename === void 0) {
      var typename = context2.store.getFieldValue(objectOrReference, "__typename");
      if (typename)
        options.typename = typename;
    }
    var storeFieldName = this.getStoreFieldName(options);
    var fieldName = fieldNameFromStoreName(storeFieldName);
    var existing = context2.store.getFieldValue(objectOrReference, storeFieldName);
    var policy = this.getFieldPolicy(options.typename, fieldName, false);
    var read = policy && policy.read;
    if (read) {
      var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context2, context2.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
      return cacheSlot.withValue(this.cache, read, [existing, readOptions]);
    }
    return existing;
  };
  Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
    var policy = this.getFieldPolicy(parentTypename, fieldName, false);
    var merge = policy && policy.merge;
    if (!merge && childTypename) {
      policy = this.getTypePolicy(childTypename);
      merge = policy && policy.merge;
    }
    return merge;
  };
  Policies2.prototype.runMergeFunction = function(existing, incoming, _a5, context2, storage) {
    var field = _a5.field, typename = _a5.typename, merge = _a5.merge;
    if (merge === mergeTrueFn) {
      return makeMergeObjectsFunction(context2.store.getFieldValue)(existing, incoming);
    }
    if (merge === mergeFalseFn) {
      return incoming;
    }
    return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, {typename, fieldName: field.name.value, field, variables: context2.variables}, context2, storage || Object.create(null)));
  };
  return Policies2;
}();
function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context2, storage) {
  var storeFieldName = policies.getStoreFieldName(fieldSpec);
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var variables = fieldSpec.variables || context2.variables;
  var _a5 = context2.store, getFieldValue = _a5.getFieldValue, toReference = _a5.toReference, canRead = _a5.canRead;
  return {
    args: argsFromFieldSpecifier(fieldSpec),
    field: fieldSpec.field || null,
    fieldName,
    storeFieldName,
    variables,
    isReference,
    toReference,
    storage,
    cache: policies.cache,
    canRead,
    readField: function(fieldNameOrOptions, from2) {
      var options = typeof fieldNameOrOptions === "string" ? {
        fieldName: fieldNameOrOptions,
        from: from2
      } : __assign({}, fieldNameOrOptions);
      if (options.from === void 0) {
        options.from = objectOrReference;
      }
      if (options.variables === void 0) {
        options.variables = variables;
      }
      return policies.readField(options, context2);
    },
    mergeObjects: makeMergeObjectsFunction(getFieldValue)
  };
}
function makeMergeObjectsFunction(getFieldValue) {
  return function mergeObjects(existing, incoming) {
    if (Array.isArray(existing) || Array.isArray(incoming)) {
      throw true ? new InvariantError(2) : new InvariantError("Cannot automatically merge arrays");
    }
    if (existing && typeof existing === "object" && incoming && typeof incoming === "object") {
      var eType = getFieldValue(existing, "__typename");
      var iType = getFieldValue(incoming, "__typename");
      var typesDiffer = eType && iType && eType !== iType;
      if (typesDiffer || !storeValueIsStoreObject(existing) || !storeValueIsStoreObject(incoming)) {
        return incoming;
      }
      return __assign(__assign({}, existing), incoming);
    }
    return incoming;
  };
}
function keyArgsFnFromSpecifier(specifier) {
  return function(args, context2) {
    return args ? context2.fieldName + ":" + JSON.stringify(computeKeyObject(args, specifier, false)) : context2.fieldName;
  };
}
function keyFieldsFnFromSpecifier(specifier) {
  var trie = new Trie(canUseWeakMap);
  return function(object2, context2) {
    var aliasMap;
    if (context2.selectionSet && context2.fragmentMap) {
      var info = trie.lookupArray([
        context2.selectionSet,
        context2.fragmentMap
      ]);
      aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context2.selectionSet, context2.fragmentMap));
    }
    var keyObject = context2.keyObject = computeKeyObject(object2, specifier, true, aliasMap);
    return context2.typename + ":" + JSON.stringify(keyObject);
  };
}
function makeAliasMap(selectionSet, fragmentMap) {
  var map = Object.create(null);
  var workQueue = new Set([selectionSet]);
  workQueue.forEach(function(selectionSet2) {
    selectionSet2.selections.forEach(function(selection) {
      if (isField(selection)) {
        if (selection.alias) {
          var responseKey = selection.alias.value;
          var storeKey = selection.name.value;
          if (storeKey !== responseKey) {
            var aliases = map.aliases || (map.aliases = Object.create(null));
            aliases[storeKey] = responseKey;
          }
        }
        if (selection.selectionSet) {
          var subsets = map.subsets || (map.subsets = Object.create(null));
          subsets[selection.name.value] = makeAliasMap(selection.selectionSet, fragmentMap);
        }
      } else {
        var fragment = getFragmentFromSelection(selection, fragmentMap);
        if (fragment) {
          workQueue.add(fragment.selectionSet);
        }
      }
    });
  });
  return map;
}
function computeKeyObject(response, specifier, strict, aliasMap) {
  var keyObj = Object.create(null);
  var prevKey;
  specifier.forEach(function(s) {
    if (Array.isArray(s)) {
      if (typeof prevKey === "string") {
        var subsets = aliasMap && aliasMap.subsets;
        var subset = subsets && subsets[prevKey];
        keyObj[prevKey] = computeKeyObject(response[prevKey], s, strict, subset);
      }
    } else {
      var aliases = aliasMap && aliasMap.aliases;
      var responseName = aliases && aliases[s] || s;
      if (hasOwn.call(response, responseName)) {
        keyObj[prevKey = s] = response[responseName];
      } else {
        true ? invariant3(!strict, 3) : invariant3(!strict, "Missing field '" + responseName + "' while computing key fields");
        prevKey = void 0;
      }
    }
  });
  return keyObj;
}

// ../../node_modules/@apollo/client/cache/inmemory/inMemoryCache.js
var defaultConfig = {
  dataIdFromObject: defaultDataIdFromObject,
  addTypename: true,
  resultCaching: true,
  typePolicies: {}
};
var InMemoryCache = function(_super) {
  __extends(InMemoryCache2, _super);
  function InMemoryCache2(config) {
    if (config === void 0) {
      config = {};
    }
    var _this = _super.call(this) || this;
    _this.watches = new Set();
    _this.typenameDocumentCache = new Map();
    _this.makeVar = makeVar;
    _this.txCount = 0;
    _this.maybeBroadcastWatch = wrap(function(c, fromOptimisticTransaction) {
      return _this.broadcastWatch.call(_this, c, !!fromOptimisticTransaction);
    }, {
      makeCacheKey: function(c) {
        var store = c.optimistic ? _this.optimisticData : _this.data;
        if (supportsResultCaching(store)) {
          var optimistic = c.optimistic, rootId = c.rootId, variables = c.variables;
          return store.makeCacheKey(c.query, c.callback, JSON.stringify({optimistic, rootId, variables}));
        }
      }
    });
    _this.watchDep = dep();
    _this.config = __assign(__assign({}, defaultConfig), config);
    _this.addTypename = !!_this.config.addTypename;
    _this.policies = new Policies({
      cache: _this,
      dataIdFromObject: _this.config.dataIdFromObject,
      possibleTypes: _this.config.possibleTypes,
      typePolicies: _this.config.typePolicies
    });
    _this.data = new EntityStore.Root({
      policies: _this.policies,
      resultCaching: _this.config.resultCaching
    });
    _this.optimisticData = _this.data;
    _this.storeWriter = new StoreWriter(_this, _this.storeReader = new StoreReader({
      cache: _this,
      addTypename: _this.addTypename
    }));
    return _this;
  }
  InMemoryCache2.prototype.restore = function(data) {
    if (data)
      this.data.replace(data);
    return this;
  };
  InMemoryCache2.prototype.extract = function(optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return (optimistic ? this.optimisticData : this.data).extract();
  };
  InMemoryCache2.prototype.read = function(options) {
    var _a5 = options.returnPartialData, returnPartialData = _a5 === void 0 ? false : _a5;
    try {
      return this.storeReader.diffQueryAgainstStore({
        store: options.optimistic ? this.optimisticData : this.data,
        query: options.query,
        variables: options.variables,
        rootId: options.rootId,
        config: this.config,
        returnPartialData
      }).result || null;
    } catch (e) {
      if (e instanceof MissingFieldError) {
        return null;
      }
      throw e;
    }
  };
  InMemoryCache2.prototype.write = function(options) {
    try {
      ++this.txCount;
      return this.storeWriter.writeToStore({
        store: this.data,
        query: options.query,
        result: options.result,
        dataId: options.dataId,
        variables: options.variables
      });
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  };
  InMemoryCache2.prototype.modify = function(options) {
    if (hasOwn.call(options, "id") && !options.id) {
      return false;
    }
    var store = options.optimistic ? this.optimisticData : this.data;
    try {
      ++this.txCount;
      return store.modify(options.id || "ROOT_QUERY", options.fields);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  };
  InMemoryCache2.prototype.diff = function(options) {
    return this.storeReader.diffQueryAgainstStore({
      store: options.optimistic ? this.optimisticData : this.data,
      rootId: options.id || "ROOT_QUERY",
      query: options.query,
      variables: options.variables,
      returnPartialData: options.returnPartialData,
      config: this.config
    });
  };
  InMemoryCache2.prototype.watch = function(watch) {
    var _this = this;
    this.watches.add(watch);
    if (watch.immediate) {
      this.maybeBroadcastWatch(watch);
    }
    return function() {
      if (_this.watches.delete(watch) && !_this.watches.size) {
        forgetCache(_this);
      }
      _this.watchDep.dirty(watch);
      _this.maybeBroadcastWatch.forget(watch);
    };
  };
  InMemoryCache2.prototype.gc = function() {
    return this.optimisticData.gc();
  };
  InMemoryCache2.prototype.retain = function(rootId, optimistic) {
    return (optimistic ? this.optimisticData : this.data).retain(rootId);
  };
  InMemoryCache2.prototype.release = function(rootId, optimistic) {
    return (optimistic ? this.optimisticData : this.data).release(rootId);
  };
  InMemoryCache2.prototype.identify = function(object2) {
    return isReference(object2) ? object2.__ref : this.policies.identify(object2)[0];
  };
  InMemoryCache2.prototype.evict = function(options) {
    if (!options.id) {
      if (hasOwn.call(options, "id")) {
        return false;
      }
      options = __assign(__assign({}, options), {id: "ROOT_QUERY"});
    }
    try {
      ++this.txCount;
      return this.optimisticData.evict(options);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  };
  InMemoryCache2.prototype.reset = function() {
    this.data.clear();
    this.optimisticData = this.data;
    this.broadcastWatches();
    return Promise.resolve();
  };
  InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
    var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
    if (newOptimisticData !== this.optimisticData) {
      this.optimisticData = newOptimisticData;
      this.broadcastWatches();
    }
  };
  InMemoryCache2.prototype.performTransaction = function(transaction, optimisticId) {
    var _this = this;
    var perform = function(layer) {
      var _a5 = _this, data = _a5.data, optimisticData = _a5.optimisticData;
      ++_this.txCount;
      if (layer) {
        _this.data = _this.optimisticData = layer;
      }
      try {
        transaction(_this);
      } finally {
        --_this.txCount;
        _this.data = data;
        _this.optimisticData = optimisticData;
      }
    };
    var fromOptimisticTransaction = false;
    if (typeof optimisticId === "string") {
      this.optimisticData = this.optimisticData.addLayer(optimisticId, perform);
      fromOptimisticTransaction = true;
    } else if (optimisticId === null) {
      perform(this.data);
    } else {
      perform();
    }
    this.broadcastWatches(fromOptimisticTransaction);
  };
  InMemoryCache2.prototype.transformDocument = function(document2) {
    if (this.addTypename) {
      var result = this.typenameDocumentCache.get(document2);
      if (!result) {
        result = addTypenameToDocument(document2);
        this.typenameDocumentCache.set(document2, result);
        this.typenameDocumentCache.set(result, result);
      }
      return result;
    }
    return document2;
  };
  InMemoryCache2.prototype.broadcastWatches = function(fromOptimisticTransaction) {
    var _this = this;
    if (!this.txCount) {
      this.watches.forEach(function(c) {
        return _this.maybeBroadcastWatch(c, fromOptimisticTransaction);
      });
    }
  };
  InMemoryCache2.prototype.broadcastWatch = function(c, fromOptimisticTransaction) {
    this.watchDep.dirty(c);
    this.watchDep(c);
    var diff = this.diff({
      query: c.query,
      variables: c.variables,
      optimistic: c.optimistic
    });
    if (c.optimistic && fromOptimisticTransaction) {
      diff.fromOptimisticTransaction = true;
    }
    c.callback(diff);
  };
  return InMemoryCache2;
}(ApolloCache);

// ../../node_modules/@apollo/client/core/LocalState.js
var LocalState = function() {
  function LocalState2(_a5) {
    var cache = _a5.cache, client2 = _a5.client, resolvers = _a5.resolvers, fragmentMatcher = _a5.fragmentMatcher;
    this.cache = cache;
    if (client2) {
      this.client = client2;
    }
    if (resolvers) {
      this.addResolvers(resolvers);
    }
    if (fragmentMatcher) {
      this.setFragmentMatcher(fragmentMatcher);
    }
  }
  LocalState2.prototype.addResolvers = function(resolvers) {
    var _this = this;
    this.resolvers = this.resolvers || {};
    if (Array.isArray(resolvers)) {
      resolvers.forEach(function(resolverGroup) {
        _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
      });
    } else {
      this.resolvers = mergeDeep(this.resolvers, resolvers);
    }
  };
  LocalState2.prototype.setResolvers = function(resolvers) {
    this.resolvers = {};
    this.addResolvers(resolvers);
  };
  LocalState2.prototype.getResolvers = function() {
    return this.resolvers || {};
  };
  LocalState2.prototype.runResolvers = function(_a5) {
    var document2 = _a5.document, remoteResult = _a5.remoteResult, context2 = _a5.context, variables = _a5.variables, _b2 = _a5.onlyRunForcedResolvers, onlyRunForcedResolvers = _b2 === void 0 ? false : _b2;
    return __awaiter36(this, void 0, void 0, function() {
      return __generator(this, function(_c2) {
        if (document2) {
          return [2, this.resolveDocument(document2, remoteResult.data, context2, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
            return __assign(__assign({}, remoteResult), {data: localResult.result});
          })];
        }
        return [2, remoteResult];
      });
    });
  };
  LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
    this.fragmentMatcher = fragmentMatcher;
  };
  LocalState2.prototype.getFragmentMatcher = function() {
    return this.fragmentMatcher;
  };
  LocalState2.prototype.clientQuery = function(document2) {
    if (hasDirectives(["client"], document2)) {
      if (this.resolvers) {
        return document2;
      }
    }
    return null;
  };
  LocalState2.prototype.serverQuery = function(document2) {
    return removeClientSetsFromDocument(document2);
  };
  LocalState2.prototype.prepareContext = function(context2) {
    var cache = this.cache;
    return __assign(__assign({}, context2), {
      cache,
      getCacheKey: function(obj) {
        return cache.identify(obj);
      }
    });
  };
  LocalState2.prototype.addExportedVariables = function(document2, variables, context2) {
    if (variables === void 0) {
      variables = {};
    }
    if (context2 === void 0) {
      context2 = {};
    }
    return __awaiter36(this, void 0, void 0, function() {
      return __generator(this, function(_a5) {
        if (document2) {
          return [2, this.resolveDocument(document2, this.buildRootValueFromCache(document2, variables) || {}, this.prepareContext(context2), variables).then(function(data) {
            return __assign(__assign({}, variables), data.exportedVariables);
          })];
        }
        return [2, __assign({}, variables)];
      });
    });
  };
  LocalState2.prototype.shouldForceResolvers = function(document2) {
    var forceResolvers = false;
    visit(document2, {
      Directive: {
        enter: function(node) {
          if (node.name.value === "client" && node.arguments) {
            forceResolvers = node.arguments.some(function(arg) {
              return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
            });
            if (forceResolvers) {
              return BREAK;
            }
          }
        }
      }
    });
    return forceResolvers;
  };
  LocalState2.prototype.buildRootValueFromCache = function(document2, variables) {
    return this.cache.diff({
      query: buildQueryFromSelectionSet(document2),
      variables,
      returnPartialData: true,
      optimistic: false
    }).result;
  };
  LocalState2.prototype.resolveDocument = function(document2, rootValue, context2, variables, fragmentMatcher, onlyRunForcedResolvers) {
    if (context2 === void 0) {
      context2 = {};
    }
    if (variables === void 0) {
      variables = {};
    }
    if (fragmentMatcher === void 0) {
      fragmentMatcher = function() {
        return true;
      };
    }
    if (onlyRunForcedResolvers === void 0) {
      onlyRunForcedResolvers = false;
    }
    return __awaiter36(this, void 0, void 0, function() {
      var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a5, cache, client2, execContext;
      return __generator(this, function(_b2) {
        mainDefinition = getMainDefinition(document2);
        fragments = getFragmentDefinitions(document2);
        fragmentMap = createFragmentMap(fragments);
        definitionOperation = mainDefinition.operation;
        defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
        _a5 = this, cache = _a5.cache, client2 = _a5.client;
        execContext = {
          fragmentMap,
          context: __assign(__assign({}, context2), {
            cache,
            client: client2
          }),
          variables,
          fragmentMatcher,
          defaultOperationType,
          exportedVariables: {},
          onlyRunForcedResolvers
        };
        return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function(result) {
          return {
            result,
            exportedVariables: execContext.exportedVariables
          };
        })];
      });
    });
  };
  LocalState2.prototype.resolveSelectionSet = function(selectionSet, rootValue, execContext) {
    return __awaiter36(this, void 0, void 0, function() {
      var fragmentMap, context2, variables, resultsToMerge, execute2;
      var _this = this;
      return __generator(this, function(_a5) {
        fragmentMap = execContext.fragmentMap, context2 = execContext.context, variables = execContext.variables;
        resultsToMerge = [rootValue];
        execute2 = function(selection) {
          return __awaiter36(_this, void 0, void 0, function() {
            var fragment, typeCondition;
            return __generator(this, function(_a6) {
              if (!shouldInclude(selection, variables)) {
                return [2];
              }
              if (isField(selection)) {
                return [2, this.resolveField(selection, rootValue, execContext).then(function(fieldResult) {
                  var _a7;
                  if (typeof fieldResult !== "undefined") {
                    resultsToMerge.push((_a7 = {}, _a7[resultKeyNameFromField(selection)] = fieldResult, _a7));
                  }
                })];
              }
              if (isInlineFragment(selection)) {
                fragment = selection;
              } else {
                fragment = fragmentMap[selection.name.value];
                true ? invariant3(fragment, 11) : invariant3(fragment, "No fragment named " + selection.name.value);
              }
              if (fragment && fragment.typeCondition) {
                typeCondition = fragment.typeCondition.name.value;
                if (execContext.fragmentMatcher(rootValue, typeCondition, context2)) {
                  return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function(fragmentResult) {
                    resultsToMerge.push(fragmentResult);
                  })];
                }
              }
              return [2];
            });
          });
        };
        return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
          return mergeDeepArray(resultsToMerge);
        })];
      });
    });
  };
  LocalState2.prototype.resolveField = function(field, rootValue, execContext) {
    return __awaiter36(this, void 0, void 0, function() {
      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
      var _this = this;
      return __generator(this, function(_a5) {
        variables = execContext.variables;
        fieldName = field.name.value;
        aliasedFieldName = resultKeyNameFromField(field);
        aliasUsed = fieldName !== aliasedFieldName;
        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
        resultPromise = Promise.resolve(defaultResult);
        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
          resolverType = rootValue.__typename || execContext.defaultOperationType;
          resolverMap = this.resolvers && this.resolvers[resolverType];
          if (resolverMap) {
            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
            if (resolve) {
              resultPromise = Promise.resolve(cacheSlot.withValue(this.cache, resolve, [
                rootValue,
                argumentsObjectFromField(field, variables),
                execContext.context,
                {field, fragmentMap: execContext.fragmentMap}
              ]));
            }
          }
        }
        return [2, resultPromise.then(function(result) {
          if (result === void 0) {
            result = defaultResult;
          }
          if (field.directives) {
            field.directives.forEach(function(directive) {
              if (directive.name.value === "export" && directive.arguments) {
                directive.arguments.forEach(function(arg) {
                  if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                    execContext.exportedVariables[arg.value.value] = result;
                  }
                });
              }
            });
          }
          if (!field.selectionSet) {
            return result;
          }
          if (result == null) {
            return result;
          }
          if (Array.isArray(result)) {
            return _this.resolveSubSelectedArray(field, result, execContext);
          }
          if (field.selectionSet) {
            return _this.resolveSelectionSet(field.selectionSet, result, execContext);
          }
        })];
      });
    });
  };
  LocalState2.prototype.resolveSubSelectedArray = function(field, result, execContext) {
    var _this = this;
    return Promise.all(result.map(function(item) {
      if (item === null) {
        return null;
      }
      if (Array.isArray(item)) {
        return _this.resolveSubSelectedArray(field, item, execContext);
      }
      if (field.selectionSet) {
        return _this.resolveSelectionSet(field.selectionSet, item, execContext);
      }
    }));
  };
  return LocalState2;
}();

// ../../node_modules/@apollo/client/core/QueryInfo.js
var destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();
function wrapDestructiveCacheMethod(cache, methodName) {
  var original = cache[methodName];
  if (typeof original === "function") {
    cache[methodName] = function() {
      destructiveMethodCounts.set(cache, (destructiveMethodCounts.get(cache) + 1) % 1e15);
      return original.apply(this, arguments);
    };
  }
}
function cancelNotifyTimeout(info) {
  if (info["notifyTimeout"]) {
    clearTimeout(info["notifyTimeout"]);
    info["notifyTimeout"] = void 0;
  }
}
var QueryInfo = function() {
  function QueryInfo2(cache) {
    this.cache = cache;
    this.listeners = new Set();
    this.document = null;
    this.lastRequestId = 1;
    this.subscriptions = new Set();
    this.stopped = false;
    this.dirty = false;
    this.diff = null;
    this.observableQuery = null;
    if (!destructiveMethodCounts.has(cache)) {
      destructiveMethodCounts.set(cache, 0);
      wrapDestructiveCacheMethod(cache, "evict");
      wrapDestructiveCacheMethod(cache, "modify");
      wrapDestructiveCacheMethod(cache, "reset");
    }
  }
  QueryInfo2.prototype.init = function(query) {
    var networkStatus = query.networkStatus || NetworkStatus.loading;
    if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal(this.variables, query.variables)) {
      networkStatus = NetworkStatus.setVariables;
    }
    if (!equal(query.variables, this.variables)) {
      this.diff = null;
    }
    Object.assign(this, {
      document: query.document,
      variables: query.variables,
      networkError: null,
      graphQLErrors: this.graphQLErrors || [],
      networkStatus
    });
    if (query.observableQuery) {
      this.setObservableQuery(query.observableQuery);
    }
    if (query.lastRequestId) {
      this.lastRequestId = query.lastRequestId;
    }
    return this;
  };
  QueryInfo2.prototype.getDiff = function(variables) {
    if (variables === void 0) {
      variables = this.variables;
    }
    if (this.diff && equal(variables, this.variables)) {
      return this.diff;
    }
    this.updateWatch(this.variables = variables);
    return this.diff = this.cache.diff({
      query: this.document,
      variables,
      returnPartialData: true,
      optimistic: true
    });
  };
  QueryInfo2.prototype.setDiff = function(diff) {
    var _this = this;
    var oldDiff = this.diff;
    this.diff = diff;
    if (!this.dirty && (diff && diff.result) !== (oldDiff && oldDiff.result)) {
      this.dirty = true;
      if (!this.notifyTimeout) {
        this.notifyTimeout = setTimeout(function() {
          return _this.notify();
        }, 0);
      }
    }
  };
  QueryInfo2.prototype.setObservableQuery = function(oq) {
    var _this = this;
    if (oq === this.observableQuery)
      return;
    if (this.oqListener) {
      this.listeners.delete(this.oqListener);
    }
    this.observableQuery = oq;
    if (oq) {
      oq["queryInfo"] = this;
      this.listeners.add(this.oqListener = function() {
        if (_this.getDiff().fromOptimisticTransaction) {
          oq["observe"]();
        } else {
          oq.reobserve();
        }
      });
    } else {
      delete this.oqListener;
    }
  };
  QueryInfo2.prototype.notify = function() {
    var _this = this;
    cancelNotifyTimeout(this);
    if (this.shouldNotify()) {
      this.listeners.forEach(function(listener) {
        return listener(_this);
      });
    }
    this.dirty = false;
  };
  QueryInfo2.prototype.shouldNotify = function() {
    if (!this.dirty || !this.listeners.size) {
      return false;
    }
    if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
      var fetchPolicy = this.observableQuery.options.fetchPolicy;
      if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
        return false;
      }
    }
    return true;
  };
  QueryInfo2.prototype.stop = function() {
    if (!this.stopped) {
      this.stopped = true;
      this.cancel();
      delete this.cancel;
      this.subscriptions.forEach(function(sub) {
        return sub.unsubscribe();
      });
      var oq = this.observableQuery;
      if (oq)
        oq.stopPolling();
    }
  };
  QueryInfo2.prototype.cancel = function() {
  };
  QueryInfo2.prototype.updateWatch = function(variables) {
    var _this = this;
    if (variables === void 0) {
      variables = this.variables;
    }
    var oq = this.observableQuery;
    if (oq && oq.options.fetchPolicy === "no-cache") {
      return;
    }
    if (!this.lastWatch || this.lastWatch.query !== this.document || !equal(variables, this.lastWatch.variables)) {
      this.cancel();
      this.cancel = this.cache.watch(this.lastWatch = {
        query: this.document,
        variables,
        optimistic: true,
        callback: function(diff) {
          return _this.setDiff(diff);
        }
      });
    }
  };
  QueryInfo2.prototype.shouldWrite = function(result, variables) {
    var lastWrite = this.lastWrite;
    return !(lastWrite && lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result.data, lastWrite.result.data));
  };
  QueryInfo2.prototype.markResult = function(result, options, allowCacheWrite) {
    var _this = this;
    this.graphQLErrors = isNonEmptyArray2(result.errors) ? result.errors : [];
    cancelNotifyTimeout(this);
    if (options.fetchPolicy === "no-cache") {
      this.diff = {result: result.data, complete: true};
    } else if (allowCacheWrite) {
      if (shouldWriteResult(result, options.errorPolicy)) {
        this.cache.performTransaction(function(cache) {
          if (_this.shouldWrite(result, options.variables)) {
            cache.writeQuery({
              query: _this.document,
              data: result.data,
              variables: options.variables
            });
            _this.lastWrite = {
              result,
              variables: options.variables,
              dmCount: destructiveMethodCounts.get(_this.cache)
            };
          } else {
            if (_this.diff && _this.diff.complete) {
              result.data = _this.diff.result;
              return;
            }
          }
          var diff = cache.diff({
            query: _this.document,
            variables: options.variables,
            returnPartialData: true,
            optimistic: true
          });
          if (!_this.stopped) {
            _this.updateWatch(options.variables);
          }
          _this.diff = diff;
          if (diff.complete) {
            result.data = diff.result;
          }
        });
      } else {
        this.lastWrite = void 0;
      }
    }
  };
  QueryInfo2.prototype.markReady = function() {
    this.networkError = null;
    return this.networkStatus = NetworkStatus.ready;
  };
  QueryInfo2.prototype.markError = function(error) {
    this.networkStatus = NetworkStatus.error;
    this.lastWrite = void 0;
    cancelNotifyTimeout(this);
    if (error.graphQLErrors) {
      this.graphQLErrors = error.graphQLErrors;
    }
    if (error.networkError) {
      this.networkError = error.networkError;
    }
    return error;
  };
  return QueryInfo2;
}();
function shouldWriteResult(result, errorPolicy) {
  if (errorPolicy === void 0) {
    errorPolicy = "none";
  }
  var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
  var writeWithErrors = !graphQLResultHasError(result);
  if (!writeWithErrors && ignoreErrors && result.data) {
    writeWithErrors = true;
  }
  return writeWithErrors;
}

// ../../node_modules/@apollo/client/core/QueryManager.js
var hasOwnProperty4 = Object.prototype.hasOwnProperty;
var QueryManager = function() {
  function QueryManager2(_a5) {
    var cache = _a5.cache, link = _a5.link, _b2 = _a5.queryDeduplication, queryDeduplication = _b2 === void 0 ? false : _b2, onBroadcast = _a5.onBroadcast, _c2 = _a5.ssrMode, ssrMode = _c2 === void 0 ? false : _c2, _d2 = _a5.clientAwareness, clientAwareness = _d2 === void 0 ? {} : _d2, localState = _a5.localState, assumeImmutableResults = _a5.assumeImmutableResults;
    this.clientAwareness = {};
    this.queries = new Map();
    this.fetchCancelFns = new Map();
    this.transformCache = new (canUseWeakMap ? WeakMap : Map)();
    this.queryIdCounter = 1;
    this.requestIdCounter = 1;
    this.mutationIdCounter = 1;
    this.inFlightLinkObservables = new Map();
    this.cache = cache;
    this.link = link;
    this.queryDeduplication = queryDeduplication;
    this.clientAwareness = clientAwareness;
    this.localState = localState || new LocalState({cache});
    this.ssrMode = ssrMode;
    this.assumeImmutableResults = !!assumeImmutableResults;
    if (this.onBroadcast = onBroadcast) {
      this.mutationStore = Object.create(null);
    }
  }
  QueryManager2.prototype.stop = function() {
    var _this = this;
    this.queries.forEach(function(_info, queryId) {
      _this.stopQueryNoBroadcast(queryId);
    });
    this.cancelPendingFetches(true ? new InvariantError(12) : new InvariantError("QueryManager stopped while query was in flight"));
  };
  QueryManager2.prototype.cancelPendingFetches = function(error) {
    this.fetchCancelFns.forEach(function(cancel2) {
      return cancel2(error);
    });
    this.fetchCancelFns.clear();
  };
  QueryManager2.prototype.mutate = function(_a5) {
    var mutation = _a5.mutation, variables = _a5.variables, optimisticResponse = _a5.optimisticResponse, updateQueries = _a5.updateQueries, _b2 = _a5.refetchQueries, refetchQueries = _b2 === void 0 ? [] : _b2, _c2 = _a5.awaitRefetchQueries, awaitRefetchQueries = _c2 === void 0 ? false : _c2, updateWithProxyFn = _a5.update, _d2 = _a5.errorPolicy, errorPolicy = _d2 === void 0 ? "none" : _d2, fetchPolicy = _a5.fetchPolicy, _e2 = _a5.context, context2 = _e2 === void 0 ? {} : _e2;
    return __awaiter36(this, void 0, void 0, function() {
      var mutationId, mutationStoreValue, self2;
      return __generator(this, function(_f2) {
        switch (_f2.label) {
          case 0:
            true ? invariant3(mutation, 13) : invariant3(mutation, "mutation option is required. You must specify your GraphQL document in the mutation option.");
            true ? invariant3(!fetchPolicy || fetchPolicy === "no-cache", 14) : invariant3(!fetchPolicy || fetchPolicy === "no-cache", "Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.");
            mutationId = this.generateMutationId();
            mutation = this.transform(mutation).document;
            variables = this.getVariables(mutation, variables);
            if (!this.transform(mutation).hasClientExports)
              return [3, 2];
            return [4, this.localState.addExportedVariables(mutation, variables, context2)];
          case 1:
            variables = _f2.sent();
            _f2.label = 2;
          case 2:
            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
              mutation,
              variables,
              loading: true,
              error: null
            });
            if (optimisticResponse) {
              this.markMutationOptimistic(optimisticResponse, {
                mutationId,
                document: mutation,
                variables,
                errorPolicy,
                updateQueries,
                update: updateWithProxyFn
              });
            }
            this.broadcastQueries();
            self2 = this;
            return [2, new Promise(function(resolve, reject) {
              var storeResult;
              var error;
              self2.getObservableFromLink(mutation, __assign(__assign({}, context2), {optimisticResponse}), variables, false).subscribe({
                next: function(result) {
                  if (graphQLResultHasError(result) && errorPolicy === "none") {
                    error = new ApolloError({
                      graphQLErrors: result.errors
                    });
                    return;
                  }
                  if (mutationStoreValue) {
                    mutationStoreValue.loading = false;
                    mutationStoreValue.error = null;
                  }
                  if (fetchPolicy !== "no-cache") {
                    try {
                      self2.markMutationResult({
                        mutationId,
                        result,
                        document: mutation,
                        variables,
                        errorPolicy,
                        updateQueries,
                        update: updateWithProxyFn
                      });
                    } catch (e) {
                      error = new ApolloError({
                        networkError: e
                      });
                      return;
                    }
                  }
                  storeResult = result;
                },
                error: function(err) {
                  if (mutationStoreValue) {
                    mutationStoreValue.loading = false;
                    mutationStoreValue.error = err;
                  }
                  if (optimisticResponse) {
                    self2.cache.removeOptimistic(mutationId);
                  }
                  self2.broadcastQueries();
                  reject(new ApolloError({
                    networkError: err
                  }));
                },
                complete: function() {
                  if (error && mutationStoreValue) {
                    mutationStoreValue.loading = false;
                    mutationStoreValue.error = error;
                  }
                  if (optimisticResponse) {
                    self2.cache.removeOptimistic(mutationId);
                  }
                  self2.broadcastQueries();
                  if (error) {
                    reject(error);
                    return;
                  }
                  if (typeof refetchQueries === "function") {
                    refetchQueries = refetchQueries(storeResult);
                  }
                  var refetchQueryPromises = [];
                  if (isNonEmptyArray2(refetchQueries)) {
                    refetchQueries.forEach(function(refetchQuery) {
                      if (typeof refetchQuery === "string") {
                        self2.queries.forEach(function(_a6) {
                          var observableQuery = _a6.observableQuery;
                          if (observableQuery && observableQuery.queryName === refetchQuery) {
                            refetchQueryPromises.push(observableQuery.refetch());
                          }
                        });
                      } else {
                        var queryOptions = {
                          query: refetchQuery.query,
                          variables: refetchQuery.variables,
                          fetchPolicy: "network-only"
                        };
                        if (refetchQuery.context) {
                          queryOptions.context = refetchQuery.context;
                        }
                        refetchQueryPromises.push(self2.query(queryOptions));
                      }
                    });
                  }
                  Promise.all(awaitRefetchQueries ? refetchQueryPromises : []).then(function() {
                    if (errorPolicy === "ignore" && storeResult && graphQLResultHasError(storeResult)) {
                      delete storeResult.errors;
                    }
                    resolve(storeResult);
                  }, reject);
                }
              });
            })];
        }
      });
    });
  };
  QueryManager2.prototype.markMutationResult = function(mutation, cache) {
    var _this = this;
    if (cache === void 0) {
      cache = this.cache;
    }
    if (shouldWriteResult(mutation.result, mutation.errorPolicy)) {
      var cacheWrites_1 = [{
        result: mutation.result.data,
        dataId: "ROOT_MUTATION",
        query: mutation.document,
        variables: mutation.variables
      }];
      var updateQueries_1 = mutation.updateQueries;
      if (updateQueries_1) {
        this.queries.forEach(function(_a5, queryId) {
          var observableQuery = _a5.observableQuery;
          var queryName = observableQuery && observableQuery.queryName;
          if (!queryName || !hasOwnProperty4.call(updateQueries_1, queryName)) {
            return;
          }
          var updater = updateQueries_1[queryName];
          var _b2 = _this.queries.get(queryId), document2 = _b2.document, variables = _b2.variables;
          var _c2 = cache.diff({
            query: document2,
            variables,
            returnPartialData: true,
            optimistic: false
          }), currentQueryResult = _c2.result, complete = _c2.complete;
          if (complete && currentQueryResult) {
            var nextQueryResult = updater(currentQueryResult, {
              mutationResult: mutation.result,
              queryName: document2 && getOperationName(document2) || void 0,
              queryVariables: variables
            });
            if (nextQueryResult) {
              cacheWrites_1.push({
                result: nextQueryResult,
                dataId: "ROOT_QUERY",
                query: document2,
                variables
              });
            }
          }
        });
      }
      cache.performTransaction(function(c) {
        cacheWrites_1.forEach(function(write) {
          return c.write(write);
        });
        var update = mutation.update;
        if (update) {
          update(c, mutation.result);
        }
      }, null);
    }
  };
  QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
    var _this = this;
    var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables) : optimisticResponse;
    return this.cache.recordOptimisticTransaction(function(cache) {
      try {
        _this.markMutationResult(__assign(__assign({}, mutation), {result: {data}}), cache);
      } catch (error) {
        true;
      }
    }, mutation.mutationId);
  };
  QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {
    return this.fetchQueryObservable(queryId, options, networkStatus).promise;
  };
  QueryManager2.prototype.getQueryStore = function() {
    var store = Object.create(null);
    this.queries.forEach(function(info, queryId) {
      store[queryId] = {
        variables: info.variables,
        networkStatus: info.networkStatus,
        networkError: info.networkError,
        graphQLErrors: info.graphQLErrors
      };
    });
    return store;
  };
  QueryManager2.prototype.resetErrors = function(queryId) {
    var queryInfo = this.queries.get(queryId);
    if (queryInfo) {
      queryInfo.networkError = void 0;
      queryInfo.graphQLErrors = [];
    }
  };
  QueryManager2.prototype.transform = function(document2) {
    var transformCache = this.transformCache;
    if (!transformCache.has(document2)) {
      var transformed = this.cache.transformDocument(document2);
      var forLink = removeConnectionDirectiveFromDocument(this.cache.transformForLink(transformed));
      var clientQuery = this.localState.clientQuery(transformed);
      var serverQuery = forLink && this.localState.serverQuery(forLink);
      var cacheEntry_1 = {
        document: transformed,
        hasClientExports: hasClientExports(transformed),
        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
        clientQuery,
        serverQuery,
        defaultVars: getDefaultValues(getOperationDefinition(transformed))
      };
      var add = function(doc) {
        if (doc && !transformCache.has(doc)) {
          transformCache.set(doc, cacheEntry_1);
        }
      };
      add(document2);
      add(transformed);
      add(clientQuery);
      add(serverQuery);
    }
    return transformCache.get(document2);
  };
  QueryManager2.prototype.getVariables = function(document2, variables) {
    return __assign(__assign({}, this.transform(document2).defaultVars), variables);
  };
  QueryManager2.prototype.watchQuery = function(options) {
    options = __assign(__assign({}, options), {variables: this.getVariables(options.query, options.variables)});
    if (typeof options.notifyOnNetworkStatusChange === "undefined") {
      options.notifyOnNetworkStatusChange = false;
    }
    var queryInfo = new QueryInfo(this.cache);
    var observable = new ObservableQuery({
      queryManager: this,
      queryInfo,
      options
    });
    this.queries.set(observable.queryId, queryInfo);
    queryInfo.init({
      document: options.query,
      observableQuery: observable,
      variables: options.variables
    });
    return observable;
  };
  QueryManager2.prototype.query = function(options) {
    var _this = this;
    true ? invariant3(options.query, 15) : invariant3(options.query, "query option is required. You must specify your GraphQL document in the query option.");
    true ? invariant3(options.query.kind === "Document", 16) : invariant3(options.query.kind === "Document", 'You must wrap the query string in a "gql" tag.');
    true ? invariant3(!options.returnPartialData, 17) : invariant3(!options.returnPartialData, "returnPartialData option only supported on watchQuery.");
    true ? invariant3(!options.pollInterval, 18) : invariant3(!options.pollInterval, "pollInterval option only supported on watchQuery.");
    var queryId = this.generateQueryId();
    return this.fetchQuery(queryId, options).finally(function() {
      return _this.stopQuery(queryId);
    });
  };
  QueryManager2.prototype.generateQueryId = function() {
    return String(this.queryIdCounter++);
  };
  QueryManager2.prototype.generateRequestId = function() {
    return this.requestIdCounter++;
  };
  QueryManager2.prototype.generateMutationId = function() {
    return String(this.mutationIdCounter++);
  };
  QueryManager2.prototype.stopQueryInStore = function(queryId) {
    this.stopQueryInStoreNoBroadcast(queryId);
    this.broadcastQueries();
  };
  QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
    var queryInfo = this.queries.get(queryId);
    if (queryInfo)
      queryInfo.stop();
  };
  QueryManager2.prototype.clearStore = function() {
    this.cancelPendingFetches(true ? new InvariantError(19) : new InvariantError("Store reset while query was in flight (not completed in link chain)"));
    this.queries.forEach(function(queryInfo) {
      if (queryInfo.observableQuery) {
        queryInfo.networkStatus = NetworkStatus.loading;
      } else {
        queryInfo.stop();
      }
    });
    if (this.mutationStore) {
      this.mutationStore = Object.create(null);
    }
    return this.cache.reset();
  };
  QueryManager2.prototype.resetStore = function() {
    var _this = this;
    return this.clearStore().then(function() {
      return _this.reFetchObservableQueries();
    });
  };
  QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
    var _this = this;
    if (includeStandby === void 0) {
      includeStandby = false;
    }
    var observableQueryPromises = [];
    this.queries.forEach(function(_a5, queryId) {
      var observableQuery = _a5.observableQuery;
      if (observableQuery && observableQuery.hasObservers()) {
        var fetchPolicy = observableQuery.options.fetchPolicy;
        observableQuery.resetLastResults();
        if (fetchPolicy !== "cache-only" && (includeStandby || fetchPolicy !== "standby")) {
          observableQueryPromises.push(observableQuery.refetch());
        }
        _this.getQuery(queryId).setDiff(null);
      }
    });
    this.broadcastQueries();
    return Promise.all(observableQueryPromises);
  };
  QueryManager2.prototype.setObservableQuery = function(observableQuery) {
    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
  };
  QueryManager2.prototype.startGraphQLSubscription = function(_a5) {
    var _this = this;
    var query = _a5.query, fetchPolicy = _a5.fetchPolicy, errorPolicy = _a5.errorPolicy, variables = _a5.variables, _b2 = _a5.context, context2 = _b2 === void 0 ? {} : _b2;
    query = this.transform(query).document;
    variables = this.getVariables(query, variables);
    var makeObservable = function(variables2) {
      return _this.getObservableFromLink(query, context2, variables2, false).map(function(result) {
        if (fetchPolicy !== "no-cache") {
          if (shouldWriteResult(result, errorPolicy)) {
            _this.cache.write({
              query,
              result: result.data,
              dataId: "ROOT_SUBSCRIPTION",
              variables: variables2
            });
          }
          _this.broadcastQueries();
        }
        if (graphQLResultHasError(result)) {
          throw new ApolloError({
            graphQLErrors: result.errors
          });
        }
        return result;
      });
    };
    if (this.transform(query).hasClientExports) {
      var observablePromise_1 = this.localState.addExportedVariables(query, variables, context2).then(makeObservable);
      return new import_zen_observable.default(function(observer) {
        var sub = null;
        observablePromise_1.then(function(observable) {
          return sub = observable.subscribe(observer);
        }, observer.error);
        return function() {
          return sub && sub.unsubscribe();
        };
      });
    }
    return makeObservable(variables);
  };
  QueryManager2.prototype.stopQuery = function(queryId) {
    this.stopQueryNoBroadcast(queryId);
    this.broadcastQueries();
  };
  QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
    this.stopQueryInStoreNoBroadcast(queryId);
    this.removeQuery(queryId);
  };
  QueryManager2.prototype.removeQuery = function(queryId) {
    this.fetchCancelFns.delete(queryId);
    this.getQuery(queryId).stop();
    this.queries.delete(queryId);
  };
  QueryManager2.prototype.broadcastQueries = function() {
    if (this.onBroadcast)
      this.onBroadcast();
    this.queries.forEach(function(info) {
      return info.notify();
    });
  };
  QueryManager2.prototype.getLocalState = function() {
    return this.localState;
  };
  QueryManager2.prototype.getObservableFromLink = function(query, context2, variables, deduplication) {
    var _this = this;
    var _a5;
    if (deduplication === void 0) {
      deduplication = (_a5 = context2 === null || context2 === void 0 ? void 0 : context2.queryDeduplication) !== null && _a5 !== void 0 ? _a5 : this.queryDeduplication;
    }
    var observable;
    var serverQuery = this.transform(query).serverQuery;
    if (serverQuery) {
      var _b2 = this, inFlightLinkObservables_1 = _b2.inFlightLinkObservables, link = _b2.link;
      var operation = {
        query: serverQuery,
        variables,
        operationName: getOperationName(serverQuery) || void 0,
        context: this.prepareContext(__assign(__assign({}, context2), {forceFetch: !deduplication}))
      };
      context2 = operation.context;
      if (deduplication) {
        var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();
        inFlightLinkObservables_1.set(serverQuery, byVariables_1);
        var varJson_1 = JSON.stringify(variables);
        observable = byVariables_1.get(varJson_1);
        if (!observable) {
          var concast = new Concast([
            execute(link, operation)
          ]);
          byVariables_1.set(varJson_1, observable = concast);
          concast.cleanup(function() {
            if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {
              inFlightLinkObservables_1.delete(serverQuery);
            }
          });
        }
      } else {
        observable = new Concast([
          execute(link, operation)
        ]);
      }
    } else {
      observable = new Concast([
        import_zen_observable.default.of({data: {}})
      ]);
      context2 = this.prepareContext(context2);
    }
    var clientQuery = this.transform(query).clientQuery;
    if (clientQuery) {
      observable = asyncMap(observable, function(result) {
        return _this.localState.runResolvers({
          document: clientQuery,
          remoteResult: result,
          context: context2,
          variables
        });
      });
    }
    return observable;
  };
  QueryManager2.prototype.getResultsFromLink = function(queryInfo, allowCacheWrite, options) {
    var lastRequestId = queryInfo.lastRequestId;
    return asyncMap(this.getObservableFromLink(queryInfo.document, options.context, options.variables), function(result) {
      var hasErrors = isNonEmptyArray2(result.errors);
      if (lastRequestId >= queryInfo.lastRequestId) {
        if (hasErrors && options.errorPolicy === "none") {
          throw queryInfo.markError(new ApolloError({
            graphQLErrors: result.errors
          }));
        }
        queryInfo.markResult(result, options, allowCacheWrite);
        queryInfo.markReady();
      }
      var aqr = {
        data: result.data,
        loading: false,
        networkStatus: queryInfo.networkStatus || NetworkStatus.ready
      };
      if (hasErrors && options.errorPolicy !== "ignore") {
        aqr.errors = result.errors;
      }
      return aqr;
    }, function(networkError) {
      var error = isApolloError(networkError) ? networkError : new ApolloError({networkError});
      if (lastRequestId >= queryInfo.lastRequestId) {
        queryInfo.markError(error);
      }
      throw error;
    });
  };
  QueryManager2.prototype.fetchQueryObservable = function(queryId, options, networkStatus) {
    var _this = this;
    if (networkStatus === void 0) {
      networkStatus = NetworkStatus.loading;
    }
    var query = this.transform(options.query).document;
    var variables = this.getVariables(query, options.variables);
    var queryInfo = this.getQuery(queryId);
    var oldNetworkStatus = queryInfo.networkStatus;
    var _a5 = options.fetchPolicy, fetchPolicy = _a5 === void 0 ? "cache-first" : _a5, _b2 = options.errorPolicy, errorPolicy = _b2 === void 0 ? "none" : _b2, _c2 = options.returnPartialData, returnPartialData = _c2 === void 0 ? false : _c2, _d2 = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d2 === void 0 ? false : _d2, _e2 = options.context, context2 = _e2 === void 0 ? {} : _e2;
    var mightUseNetwork = fetchPolicy === "cache-first" || fetchPolicy === "cache-and-network" || fetchPolicy === "network-only" || fetchPolicy === "no-cache";
    if (mightUseNetwork && notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus)) {
      if (fetchPolicy !== "cache-first") {
        fetchPolicy = "cache-and-network";
      }
      returnPartialData = true;
    }
    var normalized = Object.assign({}, options, {
      query,
      variables,
      fetchPolicy,
      errorPolicy,
      returnPartialData,
      notifyOnNetworkStatusChange,
      context: context2
    });
    var fromVariables = function(variables2) {
      normalized.variables = variables2;
      return _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
    };
    this.fetchCancelFns.set(queryId, function(reason) {
      Promise.resolve().then(function() {
        return concast.cancel(reason);
      });
    });
    var concast = new Concast(this.transform(normalized.query).hasClientExports ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables) : fromVariables(normalized.variables));
    concast.cleanup(function() {
      _this.fetchCancelFns.delete(queryId);
      var nextFetchPolicy = options.nextFetchPolicy;
      if (nextFetchPolicy) {
        options.nextFetchPolicy = void 0;
        options.fetchPolicy = typeof nextFetchPolicy === "function" ? nextFetchPolicy.call(options, options.fetchPolicy || "cache-first") : nextFetchPolicy;
      }
    });
    return concast;
  };
  QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, options, networkStatus) {
    var _this = this;
    var query = options.query, variables = options.variables, fetchPolicy = options.fetchPolicy, errorPolicy = options.errorPolicy, returnPartialData = options.returnPartialData, context2 = options.context;
    queryInfo.init({
      document: query,
      variables,
      lastRequestId: this.generateRequestId(),
      networkStatus
    });
    var readCache = function() {
      return queryInfo.getDiff(variables);
    };
    var resultsFromCache = function(diff2, networkStatus2) {
      if (networkStatus2 === void 0) {
        networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;
      }
      var data = diff2.result;
      if (false) {
        true;
      }
      var fromData = function(data2) {
        return import_zen_observable.default.of(__assign({data: data2, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2}, diff2.complete ? null : {partial: true}));
      };
      if (_this.transform(query).hasForcedResolvers) {
        return _this.localState.runResolvers({
          document: query,
          remoteResult: {data},
          context: context2,
          variables,
          onlyRunForcedResolvers: true
        }).then(function(resolved) {
          return fromData(resolved.data);
        });
      }
      return fromData(data);
    };
    var resultsFromLink = function(allowCacheWrite) {
      return _this.getResultsFromLink(queryInfo, allowCacheWrite, {
        variables,
        context: context2,
        fetchPolicy,
        errorPolicy
      });
    };
    switch (fetchPolicy) {
      default:
      case "cache-first": {
        var diff = readCache();
        if (diff.complete) {
          return [
            resultsFromCache(diff, queryInfo.markReady())
          ];
        }
        if (returnPartialData) {
          return [
            resultsFromCache(diff),
            resultsFromLink(true)
          ];
        }
        return [
          resultsFromLink(true)
        ];
      }
      case "cache-and-network": {
        var diff = readCache();
        if (diff.complete || returnPartialData) {
          return [
            resultsFromCache(diff),
            resultsFromLink(true)
          ];
        }
        return [
          resultsFromLink(true)
        ];
      }
      case "cache-only":
        return [
          resultsFromCache(readCache(), queryInfo.markReady())
        ];
      case "network-only":
        return [resultsFromLink(true)];
      case "no-cache":
        return [resultsFromLink(false)];
      case "standby":
        return [];
    }
  };
  QueryManager2.prototype.getQuery = function(queryId) {
    if (queryId && !this.queries.has(queryId)) {
      this.queries.set(queryId, new QueryInfo(this.cache));
    }
    return this.queries.get(queryId);
  };
  QueryManager2.prototype.prepareContext = function(context2) {
    if (context2 === void 0) {
      context2 = {};
    }
    var newContext = this.localState.prepareContext(context2);
    return __assign(__assign({}, newContext), {clientAwareness: this.clientAwareness});
  };
  return QueryManager2;
}();

// ../../node_modules/@apollo/client/core/ApolloClient.js
var hasSuggestedDevtools = false;
function mergeOptions(defaults, options) {
  return compact(defaults, options, options.variables && {
    variables: __assign(__assign({}, defaults.variables), options.variables)
  });
}
var ApolloClient = function() {
  function ApolloClient2(options) {
    var _this = this;
    this.defaultOptions = {};
    this.resetStoreCallbacks = [];
    this.clearStoreCallbacks = [];
    var uri = options.uri, credentials = options.credentials, headers2 = options.headers, cache = options.cache, _a5 = options.ssrMode, ssrMode = _a5 === void 0 ? false : _a5, _b2 = options.ssrForceFetchDelay, ssrForceFetchDelay = _b2 === void 0 ? 0 : _b2, _c2 = options.connectToDevTools, connectToDevTools = _c2 === void 0 ? typeof window === "object" && !window.__APOLLO_CLIENT__ && false : _c2, _d2 = options.queryDeduplication, queryDeduplication = _d2 === void 0 ? true : _d2, defaultOptions4 = options.defaultOptions, _e2 = options.assumeImmutableResults, assumeImmutableResults = _e2 === void 0 ? false : _e2, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
    var link = options.link;
    if (!link) {
      link = uri ? new HttpLink({uri, credentials, headers: headers2}) : ApolloLink.empty();
    }
    if (!cache) {
      throw true ? new InvariantError(9) : new InvariantError("To initialize Apollo Client, you must specify a 'cache' property in the options object. \nFor more information, please visit: https://go.apollo.dev/c/docs");
    }
    this.link = link;
    this.cache = cache;
    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
    this.queryDeduplication = queryDeduplication;
    this.defaultOptions = defaultOptions4 || {};
    this.typeDefs = typeDefs;
    if (ssrForceFetchDelay) {
      setTimeout(function() {
        return _this.disableNetworkFetches = false;
      }, ssrForceFetchDelay);
    }
    this.watchQuery = this.watchQuery.bind(this);
    this.query = this.query.bind(this);
    this.mutate = this.mutate.bind(this);
    this.resetStore = this.resetStore.bind(this);
    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
    if (connectToDevTools && typeof window === "object") {
      window.__APOLLO_CLIENT__ = this;
    }
    if (!hasSuggestedDevtools && false) {
      hasSuggestedDevtools = true;
      if (typeof window !== "undefined" && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
        var nav = window.navigator;
        var ua = nav && nav.userAgent;
        var url = void 0;
        if (typeof ua === "string") {
          if (ua.indexOf("Chrome/") > -1) {
            url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
          } else if (ua.indexOf("Firefox/") > -1) {
            url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
          }
        }
        if (url) {
          invariant3.log("Download the Apollo DevTools for a better development experience: " + url);
        }
      }
    }
    this.version = version;
    this.localState = new LocalState({
      cache,
      client: this,
      resolvers,
      fragmentMatcher
    });
    this.queryManager = new QueryManager({
      cache: this.cache,
      link: this.link,
      queryDeduplication,
      ssrMode,
      clientAwareness: {
        name: clientAwarenessName,
        version: clientAwarenessVersion
      },
      localState: this.localState,
      assumeImmutableResults,
      onBroadcast: connectToDevTools ? function() {
        if (_this.devToolsHookCb) {
          _this.devToolsHookCb({
            action: {},
            state: {
              queries: _this.queryManager.getQueryStore(),
              mutations: _this.queryManager.mutationStore || {}
            },
            dataWithOptimisticResults: _this.cache.extract(true)
          });
        }
      } : void 0
    });
  }
  ApolloClient2.prototype.stop = function() {
    this.queryManager.stop();
  };
  ApolloClient2.prototype.watchQuery = function(options) {
    if (this.defaultOptions.watchQuery) {
      options = mergeOptions(this.defaultOptions.watchQuery, options);
    }
    if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
      options = __assign(__assign({}, options), {fetchPolicy: "cache-first"});
    }
    return this.queryManager.watchQuery(options);
  };
  ApolloClient2.prototype.query = function(options) {
    if (this.defaultOptions.query) {
      options = mergeOptions(this.defaultOptions.query, options);
    }
    true ? invariant3(options.fetchPolicy !== "cache-and-network", 10) : invariant3(options.fetchPolicy !== "cache-and-network", "The cache-and-network fetchPolicy does not work with client.query, because client.query can only return a single result. Please use client.watchQuery to receive multiple results from the cache and the network, or consider using a different fetchPolicy, such as cache-first or network-only.");
    if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
      options = __assign(__assign({}, options), {fetchPolicy: "cache-first"});
    }
    return this.queryManager.query(options);
  };
  ApolloClient2.prototype.mutate = function(options) {
    if (this.defaultOptions.mutate) {
      options = mergeOptions(this.defaultOptions.mutate, options);
    }
    return this.queryManager.mutate(options);
  };
  ApolloClient2.prototype.subscribe = function(options) {
    return this.queryManager.startGraphQLSubscription(options);
  };
  ApolloClient2.prototype.readQuery = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return this.cache.readQuery(options, optimistic);
  };
  ApolloClient2.prototype.readFragment = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return this.cache.readFragment(options, optimistic);
  };
  ApolloClient2.prototype.writeQuery = function(options) {
    this.cache.writeQuery(options);
    this.queryManager.broadcastQueries();
  };
  ApolloClient2.prototype.writeFragment = function(options) {
    this.cache.writeFragment(options);
    this.queryManager.broadcastQueries();
  };
  ApolloClient2.prototype.__actionHookForDevTools = function(cb) {
    this.devToolsHookCb = cb;
  };
  ApolloClient2.prototype.__requestRaw = function(payload) {
    return execute(this.link, payload);
  };
  ApolloClient2.prototype.resetStore = function() {
    var _this = this;
    return Promise.resolve().then(function() {
      return _this.queryManager.clearStore();
    }).then(function() {
      return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
        return fn();
      }));
    }).then(function() {
      return _this.reFetchObservableQueries();
    });
  };
  ApolloClient2.prototype.clearStore = function() {
    var _this = this;
    return Promise.resolve().then(function() {
      return _this.queryManager.clearStore();
    }).then(function() {
      return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
        return fn();
      }));
    });
  };
  ApolloClient2.prototype.onResetStore = function(cb) {
    var _this = this;
    this.resetStoreCallbacks.push(cb);
    return function() {
      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
        return c !== cb;
      });
    };
  };
  ApolloClient2.prototype.onClearStore = function(cb) {
    var _this = this;
    this.clearStoreCallbacks.push(cb);
    return function() {
      _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
        return c !== cb;
      });
    };
  };
  ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
    return this.queryManager.reFetchObservableQueries(includeStandby);
  };
  ApolloClient2.prototype.extract = function(optimistic) {
    return this.cache.extract(optimistic);
  };
  ApolloClient2.prototype.restore = function(serializedState) {
    return this.cache.restore(serializedState);
  };
  ApolloClient2.prototype.addResolvers = function(resolvers) {
    this.localState.addResolvers(resolvers);
  };
  ApolloClient2.prototype.setResolvers = function(resolvers) {
    this.localState.setResolvers(resolvers);
  };
  ApolloClient2.prototype.getResolvers = function() {
    return this.localState.getResolvers();
  };
  ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
    this.localState.setFragmentMatcher(fragmentMatcher);
  };
  ApolloClient2.prototype.setLink = function(newLink) {
    this.link = this.queryManager.link = newLink;
  };
  return ApolloClient2;
}();

// src/state/clients/graphqlClient/subscriptionClient.ts
var headers = "" ? {
  "x-hasura-admin-secret": ""
} : {};
var subscriptionErrorLink = onError(({graphQLErrors, networkError}) => {
  if (graphQLErrors) {
    graphQLErrors.map(({message, locations, path: path3}) => console.warn(`[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path3}`));
  }
  if (networkError) {
    console.error(`[Network error]: ${networkError}`);
  }
});
var subscriptionClient = () => {
  const endpoint2 = `${window.location.protocol === "https:" ? "wss" : "ws"}://${window.location.host}/_/graphql`;
  const wsLink = new WebSocketLink({
    uri: endpoint2,
    options: {
      reconnect: false,
      lazy: true,
      connectionParams: {
        headers
      }
    }
  });
  return new ApolloClient({
    cache: new InMemoryCache({
      resultCaching: false
    }),
    link: from([subscriptionErrorLink, wsLink])
  });
};
var subscriptionClient_default = subscriptionClient();

// src/state/branch/sagas/subscription.ts
function* executeActionsChannel(channel4) {
  const chan = channel4;
  try {
    while (true) {
      const action = yield take(chan);
      yield put(action);
    }
  } finally {
    if (yield cancelled()) {
      chan.close();
    }
  }
}
function* branchSubscriptionManager() {
  let activeSubscription;
  const subscribers2 = new Set();
  yield takeEvery$1(subscribe, function* (action) {
    subscribers2.add(action.payload);
    if (activeSubscription) {
      return;
    }
    const channel4 = yield call(branchSubscriptionEventChannel);
    activeSubscription = yield fork(executeActionsChannel, channel4);
  });
  yield takeEvery$1(unsubscribe, function* (action) {
    subscribers2.delete(action.payload);
    if (activeSubscription && subscribers2.size === 0) {
      yield cancel(activeSubscription);
      activeSubscription = void 0;
    }
  });
}
function branchSubscriptionEventChannel() {
  return eventChannel((emitter) => {
    const subscription = subscriptionClient_default.subscribe({
      query: SubscribeToBranchesDocument
    }).subscribe({
      next: (res) => {
        if (res.data?.branch) {
          emitter(set(res.data?.branch));
        }
      }
    });
    return () => subscription.unsubscribe();
  });
}

// src/state/branch/utils/navigation.ts
function navigateToBranch(branch, history) {
  const parts = history.location.pathname.replace(/^\//, "").split("/").filter((p) => p.length);
  const tab = parts.length && parts.shift() || "module";
  if (parts.length) {
    parts.shift();
  }
  history.push({
    ...history.location,
    pathname: `/${tab}/${branch}${parts.length ? `/${parts.join("/")}` : ""}`
  });
}

// src/state/file/hooks/useFiles.ts
import {useEffect as useEffect13} from "https://cdn.skypack.dev/react";

// src/state/branch/hooks/useBranches.ts
import {useEffect as useEffect12} from "https://cdn.skypack.dev/react";
var getCurrentBranchName = (state) => state.branches.currentBranchName;
var getBranches = createSelector((state) => state.branches.branches, (branches) => branches);
var getCurrentBranch = createSelector((state) => state.branches.loading, getBranches, getCurrentBranchName, (loading, branches, currentBranchName) => {
  if (loading) {
    return void 0;
  }
  const branch = branches.find((b) => b.name === currentBranchName);
  return branch || null;
});

// src/state/file/hooks/useFiles.ts
var getFiles = createSelector((state) => state.files.filesByBranch, (files) => files);
var getOpenFiles = createSelector((state) => state.files.openFiles, (openFiles) => openFiles);
var getOpenFileParams = createSelector((state) => state.files, (fileState) => ({
  requestedModuleName: fileState.selectedModuleName,
  requestedModuleScope: fileState.selectedModuleScope,
  requestedModuleVersion: fileState.selectedModuleVersion,
  requestedFilePath: fileState.selectedFilePath,
  requestOpenFilePending: fileState.requestOpenFilePending
}));
var getCurrentlySelectedFileId = (state) => state.files.selectedFileId;
var getLoadingState = (state) => state.files.loaded;
var hasBranchLoaded = createSelector(getLoadingState, getCurrentBranch, (loadedBranches, currentBranch) => currentBranch?.name && loadedBranches["main"] && loadedBranches[currentBranch.name]);
var getCurrentlySelectedFile = createSelector(hasBranchLoaded, getOpenFiles, getCurrentlySelectedFileId, (loaded, openFiles, selectedFileId) => {
  if (!loaded) {
    return void 0;
  }
  return openFiles.find((f) => f.file.id === selectedFileId) || null;
});
var getCurrentBranchFiles = createSelector(hasBranchLoaded, getFiles, getCurrentBranch, (loaded, files, currentBranch) => {
  if (!loaded || currentBranch === void 0) {
    return void 0;
  }
  if (currentBranch === null) {
    return null;
  }
  const branchFiles = files[currentBranch.name];
  if (currentBranch.name === "main") {
    return Object.values(branchFiles);
  }
  return Object.values(branchFiles).concat(Object.values(files["main"]));
});

// src/state/branch/sagas/index.ts
function* branchTaskManager() {
  const sagas = [
    branchSubscriptionManager,
    branchChangeListener,
    createBranchListener,
    deleteBranchListener
  ];
  yield all(sagas.map((saga) => spawn(function* () {
    while (true) {
      try {
        yield call(saga);
        break;
      } catch (e) {
        console.error(e);
      }
    }
  })));
}
function* branchChangeListener() {
  yield takeEvery$1(setCurrentBranch, changeBranch);
}
function* changeBranch(action) {
  const state = yield select();
  if (action.payload.name === state.branches.currentBranchName) {
    return;
  }
  navigateToBranch(action.payload.name, action.payload.history);
  const selectedFileParams = getOpenFileParams(state);
  if (!(selectedFileParams.requestedModuleName && selectedFileParams.requestedModuleScope && selectedFileParams.requestedFilePath)) {
    return;
  }
  yield put(requestOpenFileWithParams({
    history: action.payload.history,
    params: {
      selectedFilePath: selectedFileParams.requestedFilePath,
      selectedModuleName: selectedFileParams.requestedModuleName,
      selectedModuleScope: selectedFileParams.requestedModuleScope,
      selectedModuleVersion: "latest"
    }
  }));
}
function* createBranchListener() {
  yield takeEvery$1(createBranch, createBranch2);
}
function* createBranch2(action) {
  try {
    yield graphqlClient_default.CreateBranch({
      name: action.payload.name
    });
    navigateToBranch(action.payload.name, action.payload.history);
  } catch (err) {
    console.error(err);
  }
}
function* deleteBranchListener() {
  yield takeEvery$1(deleteBranch, deleteBranch2);
}
function* deleteBranch2(action) {
  try {
    yield graphqlClient_default.DeleteBranch({
      name: action.payload.name
    });
  } catch (err) {
    console.error(err);
  }
}

// src/state/module/sagas/subscription.ts
function* executeActionsChannel2(channel4) {
  const chan = channel4;
  try {
    while (true) {
      const action = yield take(chan);
      yield put(action);
    }
  } finally {
    if (yield cancelled()) {
      chan.close();
    }
  }
}
function* moduleSubscriptionManager() {
  let activeSubscription;
  const subscribers2 = new Set();
  yield takeEvery$1(subscribe2, function* (action) {
    subscribers2.add(action.payload);
    if (activeSubscription) {
      return;
    }
    const channel4 = yield call(moduleSubscriptionEventChannel);
    activeSubscription = yield fork(executeActionsChannel2, channel4);
  });
  yield takeEvery$1(unsubscribe2, function* (action) {
    subscribers2.delete(action.payload);
    if (activeSubscription && subscribers2.size === 0) {
      yield cancel(activeSubscription);
      activeSubscription = void 0;
    }
  });
}
function moduleSubscriptionEventChannel() {
  return eventChannel((emitter) => {
    const subscription = subscriptionClient_default.subscribe({
      query: SubscribeToModulesDocument
    }).subscribe({
      next: (res) => {
        if (res.data?.module) {
          emitter(set2(res.data?.module));
        }
      }
    });
    return () => subscription.unsubscribe();
  });
}

// src/state/module/sagas/index.ts
function* moduleTaskManager() {
  const sagas = [moduleSubscriptionManager, createModuleListener];
  yield all(sagas.map((saga) => spawn(function* () {
    while (true) {
      try {
        yield call(saga);
        break;
      } catch (e) {
        console.error(e);
      }
    }
  })));
}
function* createModuleListener() {
  yield takeEvery$1(createModule, createModule2);
}
function* createModule2(action) {
  try {
    const state = yield select();
    const scope = "";
    const branch = state.branches.currentBranchName;
    const name = action.payload.name;
    const initialfileVersion = "0.0.1";
    const mainFileContents = `/**
* ###################
* 
* Main \u2B07\uFE0F
* 
* ###################
*/

// Always export a default function
export default function main() {
  return "I'm new";
}
`;
    yield call(graphqlClient_default.CreateModule, {
      name,
      scope,
      branch,
      version: initialfileVersion,
      files: [
        {
          path: "main",
          module_version: "latest",
          branch_name: branch,
          module_name: name,
          module_scope: scope,
          contents: mainFileContents
        },
        {
          path: "main",
          module_version: initialfileVersion,
          branch_name: branch,
          module_name: name,
          module_scope: scope,
          contents: mainFileContents
        }
      ]
    });
    yield put(requestOpenFileWithParams({
      history: action.payload.history,
      params: {
        selectedFilePath: "main",
        selectedModuleName: action.payload.name,
        selectedModuleScope: scope,
        selectedModuleVersion: "latest"
      }
    }));
  } catch (err) {
    console.error(err);
  }
}

// src/state/moduleVersion/sagas/subscription.ts
function* executeActionsChannel3(channel4) {
  const chan = channel4;
  try {
    while (true) {
      const action = yield take(chan);
      yield put(action);
    }
  } finally {
    if (yield cancelled()) {
      chan.close();
    }
  }
}
function* moduleVersionsSubscriptionManager() {
  let activeSubscription;
  const subscribers2 = new Set();
  yield takeEvery$1(subscribe3, function* (action) {
    subscribers2.add(action.payload);
    if (activeSubscription) {
      return;
    }
    const channel4 = yield call(moduleSubscriptionEventChannel2);
    activeSubscription = yield fork(executeActionsChannel3, channel4);
  });
  yield takeEvery$1(unsubscribe3, function* (action) {
    subscribers2.delete(action.payload);
    if (activeSubscription && subscribers2.size === 0) {
      yield cancel(activeSubscription);
      activeSubscription = void 0;
    }
  });
}
function moduleSubscriptionEventChannel2() {
  return eventChannel((emitter) => {
    const subscription = subscriptionClient_default.subscribe({
      query: SubscribeToModuleVersionsDocument
    }).subscribe({
      next: (res) => {
        if (res.data?.module_version) {
          emitter(set3(res.data?.module_version));
        }
      }
    });
    return () => subscription.unsubscribe();
  });
}

// src/state/moduleVersion/sagas/index.ts
function* moduleVersionTaskManager() {
  yield all([moduleVersionsSubscriptionManager()]);
}

// ../../node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}

// ../../node_modules/date-fns/esm/toDate/index.js
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}

// ../../node_modules/date-fns/esm/isBefore/index.js
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}

// ../../node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

// ../../node_modules/date-fns/esm/addMilliseconds/index.js
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

// src/state/file/sagas/subscription.ts
function* executeActionsChannel4(channel4) {
  const chan = channel4;
  try {
    while (true) {
      const action = yield take(chan);
      yield put(action);
    }
  } finally {
    if (yield cancelled()) {
      chan.close();
    }
  }
}
function getSubId({
  branch,
  subId
}) {
  return `${branch}|${subId}`;
}
function* fileSubscriptionManager() {
  let activeSubscriptions = new Map();
  const subscribers2 = new Set();
  yield takeEvery$1(subscribe4, function* (action) {
    subscribers2.add(getSubId(action.payload));
    if (activeSubscriptions.get(action.payload.branch)) {
      return;
    }
    const channel4 = yield call(fileSubscriptionEventChannel, action.payload.branch);
    activeSubscriptions.set(action.payload.branch, yield fork(executeActionsChannel4, channel4));
  });
  yield takeEvery$1(unsubscribe4, function* (action) {
    subscribers2.delete(getSubId(action.payload));
    const activeSubscription = activeSubscriptions.get(action.payload.branch);
    if (activeSubscription && [...subscribers2].filter((s) => s.startsWith(action.payload.branch)).length === 0) {
      yield cancel(activeSubscription);
      activeSubscriptions.delete(action.payload.branch);
    }
  });
}
function fileSubscriptionEventChannel(branch) {
  return eventChannel((emitter) => {
    const subscription = subscriptionClient_default.subscribe({
      query: SubscribeToBranchFilesDocument,
      variables: {
        branch
      }
    }).subscribe({
      next: (res) => {
        if (res.data?.branch_by_pk?.files) {
          emitter(set4({branch, files: res.data?.branch_by_pk?.files}));
        }
      }
    });
    return () => subscription.unsubscribe();
  });
}

// src/state/file/utils/navigation.ts
function navigateToFile(file, history, overrideWithBranch, latest) {
  const parts = history.location.pathname.replace(/^\//, "").split("/");
  const tab = parts.length && parts.shift() || "module";
  history.push({
    ...history.location,
    pathname: `/${tab}/${getFileUri(file, {
      branch: overrideWithBranch || file.branch_name,
      useLatest: latest
    })}`
  });
}

// src/state/file/sagas/index.ts
function* fileOpenerRequestHandler() {
  yield takeLatest$1(requestOpenFileWithParams, fileOpener);
}
function* fileOpener(action) {
  try {
    const resolveTimeout = addMilliseconds(new Date(), 2e3);
    let currentBranchName = "main";
    while (isBefore(new Date(), resolveTimeout)) {
      const state = yield select();
      const files = getCurrentBranchFiles(state);
      const currentBranch = getCurrentBranch(state);
      if (files === void 0) {
        yield delay(10);
        continue;
      }
      currentBranchName = currentBranch?.name || "main";
      const {
        selectedModuleName,
        selectedModuleScope,
        selectedModuleVersion,
        selectedFilePath
      } = action.payload.params;
      if (!files || !selectedModuleName || !selectedModuleVersion) {
        return;
      }
      const moduleFiles = files.filter((f) => f.file.module_name === selectedModuleName && f.file.module_scope === selectedModuleScope);
      const fileToOpen = moduleFiles.find((model) => {
        const match = model.file.module_name === selectedModuleName && sanitizeScope(model.file.module_scope) === sanitizeScope(selectedModuleScope) && model.file.module_version === selectedModuleVersion && sanitizeFilePath(model.file.path) === sanitizeFilePath(selectedFilePath);
        return match;
      });
      if (!fileToOpen) {
        yield delay(10);
        continue;
      } else {
        yield putResolve(openFile(fileToOpen));
        yield call(navigateToFile, fileToOpen.file, action.payload.history, currentBranch?.name);
        return;
      }
    }
    console.error("file does not exist");
    yield call(action.payload.history.push, `/module/${currentBranchName}`);
  } finally {
    if (yield cancelled()) {
      if (false) {
        console.info("canceled fileOpen due to new request");
      }
    }
  }
}
function* fileTaskManager() {
  const sagas = [fileSubscriptionManager, fileOpenerRequestHandler];
  yield all(sagas.map((saga) => spawn(function* () {
    while (true) {
      try {
        yield call(saga);
        break;
      } catch (e) {
        console.error(e);
      }
    }
  })));
}

// src/state/user/sagas/userListSubscription.ts
function* executeActionsChannel5(channel4) {
  const chan = channel4;
  try {
    while (true) {
      const action = yield take(chan);
      yield put(action);
    }
  } finally {
    if (yield cancelled()) {
      chan.close();
    }
  }
}
function* userListSubscriptionManager() {
  let activeSubscription;
  const subscribers2 = new Set();
  yield takeEvery$1(subscribeToUserList, function* (action) {
    if (true) {
      return;
    }
    subscribers2.add(action.payload);
    if (activeSubscription) {
      return;
    }
    const channel4 = yield call(userListSubscriptionEventChannel);
    activeSubscription = yield fork(executeActionsChannel5, channel4);
  });
  yield takeEvery$1(unsubscribeFromUserList, function* (action) {
    subscribers2.delete(action.payload);
    if (activeSubscription && subscribers2.size === 0) {
      yield cancel(activeSubscription);
      activeSubscription = void 0;
    }
  });
}
function userListSubscriptionEventChannel() {
  return eventChannel((emitter) => {
    const subscription = subscriptionClient_default.subscribe({
      query: SubscribeToUserListDocument
    }).subscribe({
      next: (res) => {
        if (res.data?.user && res.data.user.length > 0) {
          emitter(setUserList(res.data?.user));
        }
      }
    });
    return () => subscription.unsubscribe();
  });
}

// src/state/user/sagas/index.ts
function* userTaskManager() {
  const sagas = [
    userListSubscriptionManager,
    persistDarkModePreference,
    addUserListener,
    deleteUserListener
  ];
  yield all(sagas.map((saga) => spawn(function* () {
    while (true) {
      try {
        yield call(saga);
        break;
      } catch (e) {
        console.error(e);
      }
    }
  })));
}
function* addUserListener() {
  yield takeEvery$1(addUser, addUser2);
}
function* addUser2(action) {
  try {
    const state = yield select();
    const registeredUsers = getUserList(state);
    const existingDeactivatedUser = registeredUsers.find((user) => user.email === action.payload && !user.active);
    if (existingDeactivatedUser) {
      yield graphqlClient_default.ReactivateUser({
        email: action.payload
      });
    } else {
      yield graphqlClient_default.CreateUser({
        email: action.payload,
        avatar: "",
        username: action.payload
      });
    }
  } catch (err) {
    console.error(err);
  }
}
function* deleteUserListener() {
  yield takeEvery$1(deleteUser, deleteUser2);
}
function* deleteUser2(action) {
  try {
    yield graphqlClient_default.DeleteUser({
      email: action.payload
    });
  } catch (err) {
    console.error(err);
  }
}
function* persistDarkModePreference() {
  while (true) {
    const action = yield take(setDarkMode);
    const user = yield select(getCurrentUser);
    if (!user?.email) {
      return;
    }
    try {
      yield graphqlClient_default.SetDarkMode({
        email: user.email,
        darkMode: action.payload
      });
    } catch (err) {
      console.error(err);
    }
  }
}

// src/state/tenant/sagas/tenantListSubscription.ts
function* executeActionsChannel6(channel4) {
  const chan = channel4;
  try {
    while (true) {
      const action = yield take(chan);
      yield put(action);
    }
  } finally {
    if (yield cancelled()) {
      chan.close();
    }
  }
}
function* tenantListSubscriptionManager() {
  let activeSubscription;
  const subscribers2 = new Set();
  yield takeEvery$1(subscribeToTenantList, function* (action) {
    subscribers2.add(action.payload);
    if (activeSubscription) {
      return;
    }
    const channel4 = yield call(tenantListSubscriptionEventChannel);
    activeSubscription = yield fork(executeActionsChannel6, channel4);
  });
  yield takeEvery$1(unsubscribeFromTenantList, function* (action) {
    subscribers2.delete(action.payload);
    if (activeSubscription && subscribers2.size === 0) {
      yield cancel(activeSubscription);
      activeSubscription = void 0;
    }
  });
}
function tenantListSubscriptionEventChannel() {
  return eventChannel((emitter) => {
    const subscription = subscriptionClient_default.subscribe({
      query: SubscribeToTenantListDocument
    }).subscribe({
      next: (res) => {
        if (res.data?.tenant && res.data.tenant.length > 0) {
          emitter(setTenantList(res.data?.tenant));
        }
      }
    });
    return () => subscription.unsubscribe();
  });
}

// src/state/tenant/sagas/index.ts
function* tenantTaskManager() {
  const sagas = [
    tenantListSubscriptionManager,
    addTenantListener,
    deleteTenantListener
  ];
  yield all(sagas.map((saga) => spawn(function* () {
    while (true) {
      try {
        yield call(saga);
        break;
      } catch (e) {
        console.error(e);
      }
    }
  })));
}
function* addTenantListener() {
  yield takeEvery$1(addTenant, addTenant2);
}
function* addTenant2(action) {
  try {
    yield graphqlClient_default.CreateTenants({
      tenants: [
        {
          name: action.payload
        }
      ]
    });
  } catch (err) {
    console.error(err);
  }
}
function* deleteTenantListener() {
  yield takeEvery$1(deleteTenant, deleteTenant2);
}
function* deleteTenant2(action) {
  try {
    yield graphqlClient_default.DeleteTenant({
      name: action.payload
    });
  } catch (err) {
    console.error(err);
  }
}

// src/state/sandbox/sagas/sync.ts
var import_typesafe_actions19 = __toModule(require_typesafe_actions_umd_production());

// src/state/sandbox/hooks/useSandboxState.ts
var getSandbox = (state) => state.sandbox;
function useSandboxState() {
  const sandbox = useSelector(getSandbox);
  return sandbox;
}

// src/state/sandbox/sagas/sync.ts
var isAllowedSandboxAction = import_typesafe_actions19.isActionOf(Object.values(actions_exports));
function* executeActionsChannel7(channel4) {
  const chan = channel4;
  try {
    while (true) {
      const action = yield take(chan);
      if (!action.type || !isAllowedSandboxAction(action)) {
        continue;
      }
      yield put(action);
    }
  } finally {
    if (yield cancelled()) {
      chan.close();
    }
  }
}
function send(action, client2) {
  action.payload.origin = getOrigin();
  if ("client" in action.payload) {
    delete action.payload.client;
  }
  client2?.postMessage(action, "*");
}
function* sandboxManager() {
  const channel4 = yield call(sandboxEventListenerChannel);
  yield fork(executeActionsChannel7, channel4);
  const requestChan = yield actionChannel((action) => isAllowedSandboxAction(action));
  if (true) {
    yield put(sandboxReady({}));
  }
  let client2 = true ? parent : void 0;
  while (true) {
    const action = yield take(requestChan);
    if (action.payload.origin && action.payload.origin !== getOrigin()) {
      if (false) {
        const sandboxState = yield select2(getSandbox2);
        if (!sandboxState.moduleUri) {
          continue;
        }
        yield send(initSandbox({uri: sandboxState.moduleUri}), client2);
      }
      continue;
    }
    if (import_typesafe_actions19.isActionOf(initSandbox, action) && false) {
      client2 = action.payload.client;
    }
    if (import_typesafe_actions19.isActionOf(disposeSandbox, action)) {
      client2 = void 0;
      continue;
    }
    send(action, client2);
  }
}
function getOrigin() {
  return true ? "sandbox" : "parent";
}
function sandboxEventListenerChannel() {
  return eventChannel((emitter) => {
    const handler = (ev) => {
      const action = ev.data;
      emitter(action);
    };
    self.addEventListener("message", handler);
    return () => {
      self.removeEventListener("message", handler);
    };
  });
}

// src/state/sandbox/sagas/index.ts
function* sandboxTaskManager() {
  const sagas = [sandboxManager];
  yield all(sagas.map((saga) => spawn(function* () {
    while (true) {
      try {
        yield call(saga);
        break;
      } catch (e) {
        console.error(e);
      }
    }
  })));
}

// src/state/sagas.ts
function* main() {
  const sagas = [
    branchTaskManager,
    moduleTaskManager,
    moduleVersionTaskManager,
    fileTaskManager,
    userTaskManager,
    tenantTaskManager,
    sandboxTaskManager
  ];
  yield all(sagas.map((saga) => spawn(function* () {
    while (true) {
      try {
        yield call(saga);
        break;
      } catch (e) {
        console.error(e);
      }
    }
  })));
}

// src/state/store.ts
var _store;
function getStore() {
  if (!_store) {
    _store = createMainStore();
  }
  return _store;
}
function createMainStore() {
  const sagaMiddleware = redux_saga_core_npm_proxy_esm_default();
  const middlewares = [sagaMiddleware];
  const middlewareEnhancer = import_redux3.applyMiddleware(...middlewares);
  const enhancers = [middlewareEnhancer];
  const store = import_redux3.createStore(mainReducer, false ? composeWithDevTools(...enhancers) : middlewareEnhancer);
  sagaMiddleware.run(main);
  return store;
}

// src/state/provider.tsx
function StoreProvider({children}) {
  const store = useRef9(getStore());
  return /* @__PURE__ */ React46.createElement(Provider_default, {
    store: store.current
  }, children);
}

// src/client/themes/Provider.tsx
var GlobalStyle = createGlobalStyle3`
  body {
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    padding: 0px !important;
    background-color: ${(props) => props.theme.palette.background.default};
    
    &::backdrop {
      background-color: ${(props) => props.theme.palette.background.default};
    }
  }
`;
var ThemeProvider2 = class extends React47.PureComponent {
  render() {
    const {children, theme: theme6} = this.props;
    if (theme6.palette.type === "dark") {
      editor.setTheme(MONACO_DARK_THEME);
    } else {
      editor.setTheme(MONACO_LIGHT_THEME);
    }
    return /* @__PURE__ */ React47.createElement(StylesProvider, {
      injectFirst: true
    }, /* @__PURE__ */ React47.createElement(ThemeProvider_default, {
      theme: theme6
    }, /* @__PURE__ */ React47.createElement(StyledThemeProvider, {
      theme: theme6
    }, /* @__PURE__ */ React47.createElement(CssBaseline_default, null), /* @__PURE__ */ React47.createElement(GlobalStyle, null), children)));
  }
};
function ThemeSwitcher({children}) {
  const currentUser = useCurrentUser();
  const darkMode = currentUser?.preference?.dark_mode === false ? false : true;
  return /* @__PURE__ */ React47.createElement(ThemeProvider2, {
    theme: darkMode ? dark_default : light_default
  }, children);
}
function ThemeCommands({children}) {
  const currentUser = useCurrentUser();
  const darkMode = currentUser?.preference?.dark_mode === false ? false : true;
  const dispatch2 = useDispatch();
  const setDarkModePreference = useCallback8((darkMode2) => {
    dispatch2(setDarkMode(darkMode2));
  }, [dispatch2]);
  useCommandService({
    id: "toggle-dark-mode",
    description: darkMode ? "Turn dark mode off" : "Turn dark mode on",
    handler: () => {
      setDarkModePreference(!darkMode);
    }
  }, [darkMode]);
  return /* @__PURE__ */ React47.createElement(React47.Fragment, null, children);
}
var Provider_default2 = ThemeProvider2;

// src/client/themes/index.ts
var theme5 = {
  light: light_default,
  dark: dark_default,
  Provider: Provider_default2,
  ThemeSwitcher
};
var themes_default = theme5;

// src/client/services/index.tsx
import React71 from "https://cdn.skypack.dev/react";

// src/client/services/Notification/NotificationService.tsx
import React69, {useContext as useContext8, useEffect as useEffect18} from "https://cdn.skypack.dev/react";

// src/client/services/Notification/reducer.ts
var import_typesafe_actions20 = __toModule(require_typesafe_actions_umd_production());
var actions23 = {
  register: import_typesafe_actions20.createAction("REGISTER_NOTIFICATION")(),
  unregister: import_typesafe_actions20.createAction("UNREGISTER_NOTIFICATION")(),
  unregisterAll: import_typesafe_actions20.createAction("UNREGISTER_ALL")(),
  changeVisibility: import_typesafe_actions20.createAction("CHANGE_VISIBILITY")()
};
function removeNotification(notifications, notification) {
  return notifications.filter((n) => n.id !== notification.id);
}
function findNotification(notifications, notification) {
  return notifications.find((n) => n.id === notification.id);
}
var initialState3 = {
  notifications: [],
  visibility: false
};
var notificationServiceReducer = import_typesafe_actions20.createReducer(initialState3).handleAction(actions23.register, (state, action) => {
  if (findNotification(state.notifications, action.payload)) {
    return state;
  }
  const notifications = [action.payload].concat(state.notifications);
  return {
    ...state,
    visibility: true,
    notifications
  };
}).handleAction(actions23.unregister, (state, action) => {
  const notifications = removeNotification(state.notifications, action.payload);
  return {
    ...state,
    notifications
  };
}).handleAction(actions23.unregisterAll, (state, _) => ({
  ...state,
  notifications: []
})).handleAction(actions23.changeVisibility, (state, _) => ({
  ...state,
  visibility: !state.visibility
}));

// src/client/components/NotificationsList/NotificationsList.tsx
import React68, {useEffect as useEffect17} from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/core/esm/Snackbar/Snackbar.js
var import_prop_types29 = __toModule(require_prop_types());
import {
  createElement as createElement25,
  forwardRef as forwardRef21,
  useCallback as useCallback10,
  useEffect as useEffect16,
  useRef as useRef12,
  useState as useState6
} from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/core/esm/ClickAwayListener/ClickAwayListener.js
var import_prop_types26 = __toModule(require_prop_types());
import {
  Fragment as Fragment4,
  cloneElement as cloneElement5,
  createElement as createElement22,
  useCallback as useCallback9,
  useEffect as useEffect14,
  useRef as useRef10
} from "https://cdn.skypack.dev/react";
import {
  findDOMNode as findDOMNode4
} from "https://cdn.skypack.dev/react-dom";
function mapEventPropToEvent(eventProp) {
  return eventProp.substring(2).toLowerCase();
}
function clickedRootScrollbar(event) {
  return document.documentElement.clientWidth < event.clientX || document.documentElement.clientHeight < event.clientY;
}
function ClickAwayListener(props) {
  var children = props.children, _props$disableReactTr = props.disableReactTree, disableReactTree = _props$disableReactTr === void 0 ? false : _props$disableReactTr, _props$mouseEvent = props.mouseEvent, mouseEvent = _props$mouseEvent === void 0 ? "onClick" : _props$mouseEvent, onClickAway = props.onClickAway, _props$touchEvent = props.touchEvent, touchEvent = _props$touchEvent === void 0 ? "onTouchEnd" : _props$touchEvent;
  var movedRef = useRef10(false);
  var nodeRef = useRef10(null);
  var activatedRef = useRef10(false);
  var syntheticEventRef = useRef10(false);
  useEffect14(function() {
    setTimeout(function() {
      activatedRef.current = true;
    }, 0);
    return function() {
      activatedRef.current = false;
    };
  }, []);
  var handleOwnRef = useCallback9(function(instance) {
    nodeRef.current = findDOMNode4(instance);
  }, []);
  var handleRef = useForkRef(children.ref, handleOwnRef);
  var handleClickAway = useEventCallback(function(event) {
    var insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    if (!activatedRef.current || !nodeRef.current || clickedRootScrollbar(event)) {
      return;
    }
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    var insideDOM;
    if (event.composedPath) {
      insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
    } else {
      var doc = ownerDocument(nodeRef.current);
      insideDOM = !doc.documentElement.contains(event.target) || nodeRef.current.contains(event.target);
    }
    if (!insideDOM && (disableReactTree || !insideReactTree)) {
      onClickAway(event);
    }
  });
  var createHandleSynthetic = function createHandleSynthetic2(handlerName) {
    return function(event) {
      syntheticEventRef.current = true;
      var childrenPropsHandler = children.props[handlerName];
      if (childrenPropsHandler) {
        childrenPropsHandler(event);
      }
    };
  };
  var childrenProps = {
    ref: handleRef
  };
  if (touchEvent !== false) {
    childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
  }
  useEffect14(function() {
    if (touchEvent !== false) {
      var mappedTouchEvent = mapEventPropToEvent(touchEvent);
      var doc = ownerDocument(nodeRef.current);
      var handleTouchMove = function handleTouchMove2() {
        movedRef.current = true;
      };
      doc.addEventListener(mappedTouchEvent, handleClickAway);
      doc.addEventListener("touchmove", handleTouchMove);
      return function() {
        doc.removeEventListener(mappedTouchEvent, handleClickAway);
        doc.removeEventListener("touchmove", handleTouchMove);
      };
    }
    return void 0;
  }, [handleClickAway, touchEvent]);
  if (mouseEvent !== false) {
    childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
  }
  useEffect14(function() {
    if (mouseEvent !== false) {
      var mappedMouseEvent = mapEventPropToEvent(mouseEvent);
      var doc = ownerDocument(nodeRef.current);
      doc.addEventListener(mappedMouseEvent, handleClickAway);
      return function() {
        doc.removeEventListener(mappedMouseEvent, handleClickAway);
      };
    }
    return void 0;
  }, [handleClickAway, mouseEvent]);
  return /* @__PURE__ */ createElement22(Fragment4, null, /* @__PURE__ */ cloneElement5(children, childrenProps));
}
false ? ClickAwayListener.propTypes = {
  children: elementAcceptingRef_default.isRequired,
  disableReactTree: import_prop_types26.default.bool,
  mouseEvent: import_prop_types26.default.oneOf(["onClick", "onMouseDown", "onMouseUp", false]),
  onClickAway: import_prop_types26.default.func.isRequired,
  touchEvent: import_prop_types26.default.oneOf(["onTouchEnd", "onTouchStart", false])
} : void 0;
if (false) {
  ClickAwayListener["propTypes"] = exactProp(ClickAwayListener.propTypes);
}
var ClickAwayListener_default = ClickAwayListener;

// node_modules/@material-ui/core/esm/Grow/Grow.js
var import_prop_types27 = __toModule(require_prop_types());
import {
  cloneElement as cloneElement6,
  createElement as createElement23,
  forwardRef as forwardRef19,
  useEffect as useEffect15,
  useRef as useRef11
} from "https://cdn.skypack.dev/react";
function getScale(value) {
  return "scale(".concat(value, ", ").concat(Math.pow(value, 2), ")");
}
var styles26 = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
var Grow = /* @__PURE__ */ forwardRef19(function Grow2(props, ref) {
  var children = props.children, _props$disableStrictM = props.disableStrictModeCompat, disableStrictModeCompat = _props$disableStrictM === void 0 ? false : _props$disableStrictM, inProp = props.in, onEnter = props.onEnter, onEntered = props.onEntered, onEntering = props.onEntering, onExit = props.onExit, onExited = props.onExited, onExiting = props.onExiting, style = props.style, _props$timeout = props.timeout, timeout3 = _props$timeout === void 0 ? "auto" : _props$timeout, _props$TransitionComp = props.TransitionComponent, TransitionComponent = _props$TransitionComp === void 0 ? Transition_default : _props$TransitionComp, other = _objectWithoutProperties(props, ["children", "disableStrictModeCompat", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"]);
  var timer = useRef11();
  var autoTimeout = useRef11();
  var theme6 = useTheme2();
  var enableStrictModeCompat = theme6.unstable_strictMode && !disableStrictModeCompat;
  var nodeRef = useRef11(null);
  var foreignRef = useForkRef(children.ref, ref);
  var handleRef = useForkRef(enableStrictModeCompat ? nodeRef : void 0, foreignRef);
  var normalizedTransitionCallback = function normalizedTransitionCallback2(callback) {
    return function(nodeOrAppearing, maybeAppearing) {
      if (callback) {
        var _ref2 = enableStrictModeCompat ? [nodeRef.current, nodeOrAppearing] : [nodeOrAppearing, maybeAppearing], _ref22 = _slicedToArray(_ref2, 2), node = _ref22[0], isAppearing = _ref22[1];
        if (isAppearing === void 0) {
          callback(node);
        } else {
          callback(node, isAppearing);
        }
      }
    };
  };
  var handleEntering = normalizedTransitionCallback(onEntering);
  var handleEnter = normalizedTransitionCallback(function(node, isAppearing) {
    reflow(node);
    var _getTransitionProps = getTransitionProps({
      style,
      timeout: timeout3
    }, {
      mode: "enter"
    }), transitionDuration = _getTransitionProps.duration, delay2 = _getTransitionProps.delay;
    var duration2;
    if (timeout3 === "auto") {
      duration2 = theme6.transitions.getAutoHeightDuration(node.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node.style.transition = [theme6.transitions.create("opacity", {
      duration: duration2,
      delay: delay2
    }), theme6.transitions.create("transform", {
      duration: duration2 * 0.666,
      delay: delay2
    })].join(",");
    if (onEnter) {
      onEnter(node, isAppearing);
    }
  });
  var handleEntered = normalizedTransitionCallback(onEntered);
  var handleExiting = normalizedTransitionCallback(onExiting);
  var handleExit = normalizedTransitionCallback(function(node) {
    var _getTransitionProps2 = getTransitionProps({
      style,
      timeout: timeout3
    }, {
      mode: "exit"
    }), transitionDuration = _getTransitionProps2.duration, delay2 = _getTransitionProps2.delay;
    var duration2;
    if (timeout3 === "auto") {
      duration2 = theme6.transitions.getAutoHeightDuration(node.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node.style.transition = [theme6.transitions.create("opacity", {
      duration: duration2,
      delay: delay2
    }), theme6.transitions.create("transform", {
      duration: duration2 * 0.666,
      delay: delay2 || duration2 * 0.333
    })].join(",");
    node.style.opacity = "0";
    node.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node);
    }
  });
  var handleExited = normalizedTransitionCallback(onExited);
  var addEndListener = function addEndListener2(nodeOrNext, maybeNext) {
    var next = enableStrictModeCompat ? nodeOrNext : maybeNext;
    if (timeout3 === "auto") {
      timer.current = setTimeout(next, autoTimeout.current || 0);
    }
  };
  useEffect15(function() {
    return function() {
      clearTimeout(timer.current);
    };
  }, []);
  return /* @__PURE__ */ createElement23(TransitionComponent, _extends({
    appear: true,
    in: inProp,
    nodeRef: enableStrictModeCompat ? nodeRef : void 0,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener,
    timeout: timeout3 === "auto" ? null : timeout3
  }, other), function(state, childProps) {
    return /* @__PURE__ */ cloneElement6(children, _extends({
      style: _extends({
        opacity: 0,
        transform: getScale(0.75),
        visibility: state === "exited" && !inProp ? "hidden" : void 0
      }, styles26[state], style, children.props.style),
      ref: handleRef
    }, childProps));
  });
});
false ? Grow.propTypes = {
  children: import_prop_types27.default.element,
  disableStrictModeCompat: import_prop_types27.default.bool,
  in: import_prop_types27.default.bool,
  onEnter: import_prop_types27.default.func,
  onEntered: import_prop_types27.default.func,
  onEntering: import_prop_types27.default.func,
  onExit: import_prop_types27.default.func,
  onExited: import_prop_types27.default.func,
  onExiting: import_prop_types27.default.func,
  style: import_prop_types27.default.object,
  timeout: import_prop_types27.default.oneOfType([import_prop_types27.default.oneOf(["auto"]), import_prop_types27.default.number, import_prop_types27.default.shape({
    appear: import_prop_types27.default.number,
    enter: import_prop_types27.default.number,
    exit: import_prop_types27.default.number
  })])
} : void 0;
Grow.muiSupportAuto = true;
var Grow_default = Grow;

// node_modules/@material-ui/core/esm/SnackbarContent/SnackbarContent.js
var import_prop_types28 = __toModule(require_prop_types());
import {
  createElement as createElement24,
  forwardRef as forwardRef20
} from "https://cdn.skypack.dev/react";
var styles27 = function styles28(theme6) {
  var emphasis = theme6.palette.type === "light" ? 0.8 : 0.98;
  var backgroundColor = emphasize(theme6.palette.background.default, emphasis);
  return {
    root: _extends({}, theme6.typography.body2, _defineProperty({
      color: theme6.palette.getContrastText(backgroundColor),
      backgroundColor,
      display: "flex",
      alignItems: "center",
      flexWrap: "wrap",
      padding: "6px 16px",
      borderRadius: theme6.shape.borderRadius,
      flexGrow: 1
    }, theme6.breakpoints.up("sm"), {
      flexGrow: "initial",
      minWidth: 288
    })),
    message: {
      padding: "8px 0"
    },
    action: {
      display: "flex",
      alignItems: "center",
      marginLeft: "auto",
      paddingLeft: 16,
      marginRight: -8
    }
  };
};
var SnackbarContent = /* @__PURE__ */ forwardRef20(function SnackbarContent2(props, ref) {
  var action = props.action, classes = props.classes, className = props.className, message = props.message, _props$role = props.role, role = _props$role === void 0 ? "alert" : _props$role, other = _objectWithoutProperties(props, ["action", "classes", "className", "message", "role"]);
  return /* @__PURE__ */ createElement24(Paper_default, _extends({
    role,
    square: true,
    elevation: 6,
    className: clsx_m_default(classes.root, className),
    ref
  }, other), /* @__PURE__ */ createElement24("div", {
    className: classes.message
  }, message), action ? /* @__PURE__ */ createElement24("div", {
    className: classes.action
  }, action) : null);
});
false ? SnackbarContent.propTypes = {
  action: import_prop_types28.default.node,
  classes: import_prop_types28.default.object,
  className: import_prop_types28.default.string,
  message: import_prop_types28.default.node,
  role: import_prop_types28.default.string
} : void 0;
var SnackbarContent_default = withStyles_default(styles27, {
  name: "MuiSnackbarContent"
})(SnackbarContent);

// node_modules/@material-ui/core/esm/Snackbar/Snackbar.js
var styles29 = function styles30(theme6) {
  var top1 = {
    top: 8
  };
  var bottom1 = {
    bottom: 8
  };
  var right = {
    justifyContent: "flex-end"
  };
  var left = {
    justifyContent: "flex-start"
  };
  var top3 = {
    top: 24
  };
  var bottom3 = {
    bottom: 24
  };
  var right3 = {
    right: 24
  };
  var left3 = {
    left: 24
  };
  var center = {
    left: "50%",
    right: "auto",
    transform: "translateX(-50%)"
  };
  return {
    root: {
      zIndex: theme6.zIndex.snackbar,
      position: "fixed",
      display: "flex",
      left: 8,
      right: 8,
      justifyContent: "center",
      alignItems: "center"
    },
    anchorOriginTopCenter: _extends({}, top1, _defineProperty({}, theme6.breakpoints.up("sm"), _extends({}, top3, center))),
    anchorOriginBottomCenter: _extends({}, bottom1, _defineProperty({}, theme6.breakpoints.up("sm"), _extends({}, bottom3, center))),
    anchorOriginTopRight: _extends({}, top1, right, _defineProperty({}, theme6.breakpoints.up("sm"), _extends({
      left: "auto"
    }, top3, right3))),
    anchorOriginBottomRight: _extends({}, bottom1, right, _defineProperty({}, theme6.breakpoints.up("sm"), _extends({
      left: "auto"
    }, bottom3, right3))),
    anchorOriginTopLeft: _extends({}, top1, left, _defineProperty({}, theme6.breakpoints.up("sm"), _extends({
      right: "auto"
    }, top3, left3))),
    anchorOriginBottomLeft: _extends({}, bottom1, left, _defineProperty({}, theme6.breakpoints.up("sm"), _extends({
      right: "auto"
    }, bottom3, left3)))
  };
};
var Snackbar = /* @__PURE__ */ forwardRef21(function Snackbar2(props, ref) {
  var action = props.action, _props$anchorOrigin = props.anchorOrigin;
  _props$anchorOrigin = _props$anchorOrigin === void 0 ? {
    vertical: "bottom",
    horizontal: "center"
  } : _props$anchorOrigin;
  var vertical = _props$anchorOrigin.vertical, horizontal = _props$anchorOrigin.horizontal, _props$autoHideDurati = props.autoHideDuration, autoHideDuration = _props$autoHideDurati === void 0 ? null : _props$autoHideDurati, children = props.children, classes = props.classes, className = props.className, ClickAwayListenerProps = props.ClickAwayListenerProps, ContentProps = props.ContentProps, _props$disableWindowB = props.disableWindowBlurListener, disableWindowBlurListener = _props$disableWindowB === void 0 ? false : _props$disableWindowB, message = props.message, onClose = props.onClose, onEnter = props.onEnter, onEntered = props.onEntered, onEntering = props.onEntering, onExit = props.onExit, onExited = props.onExited, onExiting = props.onExiting, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, open = props.open, resumeHideDuration = props.resumeHideDuration, _props$TransitionComp = props.TransitionComponent, TransitionComponent = _props$TransitionComp === void 0 ? Grow_default : _props$TransitionComp, _props$transitionDura = props.transitionDuration, transitionDuration = _props$transitionDura === void 0 ? {
    enter: duration.enteringScreen,
    exit: duration.leavingScreen
  } : _props$transitionDura, TransitionProps = props.TransitionProps, other = _objectWithoutProperties(props, ["action", "anchorOrigin", "autoHideDuration", "children", "classes", "className", "ClickAwayListenerProps", "ContentProps", "disableWindowBlurListener", "message", "onClose", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "onMouseEnter", "onMouseLeave", "open", "resumeHideDuration", "TransitionComponent", "transitionDuration", "TransitionProps"]);
  var timerAutoHide = useRef12();
  var _React$useState = useState6(true), exited = _React$useState[0], setExited = _React$useState[1];
  var handleClose = useEventCallback(function() {
    if (onClose) {
      onClose.apply(void 0, arguments);
    }
  });
  var setAutoHideTimer = useEventCallback(function(autoHideDurationParam) {
    if (!onClose || autoHideDurationParam == null) {
      return;
    }
    clearTimeout(timerAutoHide.current);
    timerAutoHide.current = setTimeout(function() {
      handleClose(null, "timeout");
    }, autoHideDurationParam);
  });
  useEffect16(function() {
    if (open) {
      setAutoHideTimer(autoHideDuration);
    }
    return function() {
      clearTimeout(timerAutoHide.current);
    };
  }, [open, autoHideDuration, setAutoHideTimer]);
  var handlePause = function handlePause2() {
    clearTimeout(timerAutoHide.current);
  };
  var handleResume = useCallback10(function() {
    if (autoHideDuration != null) {
      setAutoHideTimer(resumeHideDuration != null ? resumeHideDuration : autoHideDuration * 0.5);
    }
  }, [autoHideDuration, resumeHideDuration, setAutoHideTimer]);
  var handleMouseEnter = function handleMouseEnter2(event) {
    if (onMouseEnter) {
      onMouseEnter(event);
    }
    handlePause();
  };
  var handleMouseLeave = function handleMouseLeave2(event) {
    if (onMouseLeave) {
      onMouseLeave(event);
    }
    handleResume();
  };
  var handleClickAway = function handleClickAway2(event) {
    if (onClose) {
      onClose(event, "clickaway");
    }
  };
  var handleExited = function handleExited2() {
    setExited(true);
  };
  var handleEnter = function handleEnter2() {
    setExited(false);
  };
  useEffect16(function() {
    if (!disableWindowBlurListener && open) {
      window.addEventListener("focus", handleResume);
      window.addEventListener("blur", handlePause);
      return function() {
        window.removeEventListener("focus", handleResume);
        window.removeEventListener("blur", handlePause);
      };
    }
    return void 0;
  }, [disableWindowBlurListener, handleResume, open]);
  if (!open && exited) {
    return null;
  }
  return /* @__PURE__ */ createElement25(ClickAwayListener_default, _extends({
    onClickAway: handleClickAway
  }, ClickAwayListenerProps), /* @__PURE__ */ createElement25("div", _extends({
    className: clsx_m_default(classes.root, classes["anchorOrigin".concat(capitalize(vertical)).concat(capitalize(horizontal))], className),
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    ref
  }, other), /* @__PURE__ */ createElement25(TransitionComponent, _extends({
    appear: true,
    in: open,
    onEnter: createChainedFunction(handleEnter, onEnter),
    onEntered,
    onEntering,
    onExit,
    onExited: createChainedFunction(handleExited, onExited),
    onExiting,
    timeout: transitionDuration,
    direction: vertical === "top" ? "down" : "up"
  }, TransitionProps), children || /* @__PURE__ */ createElement25(SnackbarContent_default, _extends({
    message,
    action
  }, ContentProps)))));
});
false ? Snackbar.propTypes = {
  action: import_prop_types29.default.node,
  anchorOrigin: import_prop_types29.default.shape({
    horizontal: import_prop_types29.default.oneOf(["center", "left", "right"]).isRequired,
    vertical: import_prop_types29.default.oneOf(["bottom", "top"]).isRequired
  }),
  autoHideDuration: import_prop_types29.default.number,
  children: import_prop_types29.default.element,
  classes: import_prop_types29.default.object,
  className: import_prop_types29.default.string,
  ClickAwayListenerProps: import_prop_types29.default.object,
  ContentProps: import_prop_types29.default.object,
  disableWindowBlurListener: import_prop_types29.default.bool,
  key: import_prop_types29.default.any,
  message: import_prop_types29.default.node,
  onClose: import_prop_types29.default.func,
  onEnter: import_prop_types29.default.func,
  onEntered: import_prop_types29.default.func,
  onEntering: import_prop_types29.default.func,
  onExit: import_prop_types29.default.func,
  onExited: import_prop_types29.default.func,
  onExiting: import_prop_types29.default.func,
  onMouseEnter: import_prop_types29.default.func,
  onMouseLeave: import_prop_types29.default.func,
  open: import_prop_types29.default.bool,
  resumeHideDuration: import_prop_types29.default.number,
  TransitionComponent: import_prop_types29.default.elementType,
  transitionDuration: import_prop_types29.default.oneOfType([import_prop_types29.default.number, import_prop_types29.default.shape({
    appear: import_prop_types29.default.number,
    enter: import_prop_types29.default.number,
    exit: import_prop_types29.default.number
  })]),
  TransitionProps: import_prop_types29.default.object
} : void 0;
var Snackbar_default = withStyles_default(styles29, {
  flip: false,
  name: "MuiSnackbar"
})(Snackbar);

// node_modules/@material-ui/core/esm/List/List.js
var import_prop_types30 = __toModule(require_prop_types());
import {
  createElement as createElement26,
  forwardRef as forwardRef22,
  useMemo as useMemo7
} from "https://cdn.skypack.dev/react";
var styles31 = {
  root: {
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative"
  },
  padding: {
    paddingTop: 8,
    paddingBottom: 8
  },
  dense: {},
  subheader: {
    paddingTop: 0
  }
};
var List2 = /* @__PURE__ */ forwardRef22(function List3(props, ref) {
  var children = props.children, classes = props.classes, className = props.className, _props$component = props.component, Component5 = _props$component === void 0 ? "ul" : _props$component, _props$dense = props.dense, dense = _props$dense === void 0 ? false : _props$dense, _props$disablePadding = props.disablePadding, disablePadding = _props$disablePadding === void 0 ? false : _props$disablePadding, subheader = props.subheader, other = _objectWithoutProperties(props, ["children", "classes", "className", "component", "dense", "disablePadding", "subheader"]);
  var context2 = useMemo7(function() {
    return {
      dense
    };
  }, [dense]);
  return /* @__PURE__ */ createElement26(ListContext_default.Provider, {
    value: context2
  }, /* @__PURE__ */ createElement26(Component5, _extends({
    className: clsx_m_default(classes.root, className, dense && classes.dense, !disablePadding && classes.padding, subheader && classes.subheader),
    ref
  }, other), subheader, children));
});
false ? List2.propTypes = {
  children: import_prop_types30.default.node,
  classes: import_prop_types30.default.object.isRequired,
  className: import_prop_types30.default.string,
  component: import_prop_types30.default.elementType,
  dense: import_prop_types30.default.bool,
  disablePadding: import_prop_types30.default.bool,
  subheader: import_prop_types30.default.node
} : void 0;
var List_default2 = withStyles_default(styles31, {
  name: "MuiList"
})(List2);

// src/client/components/NotificationsList/NotificationItem.tsx
import React64 from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/lab/esm/Alert/Alert.js
var import_prop_types33 = __toModule(require_prop_types());
import {
  createElement as createElement34,
  forwardRef as forwardRef25
} from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/lab/esm/internal/svg-icons/SuccessOutlined.js
import {
  createElement as createElement28
} from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/core/esm/utils/createSvgIcon.js
import React54 from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/core/esm/SvgIcon/SvgIcon.js
var import_prop_types31 = __toModule(require_prop_types());
import {
  createElement as createElement27,
  forwardRef as forwardRef23
} from "https://cdn.skypack.dev/react";
var styles32 = function styles33(theme6) {
  return {
    root: {
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      fill: "currentColor",
      flexShrink: 0,
      fontSize: theme6.typography.pxToRem(24),
      transition: theme6.transitions.create("fill", {
        duration: theme6.transitions.duration.shorter
      })
    },
    colorPrimary: {
      color: theme6.palette.primary.main
    },
    colorSecondary: {
      color: theme6.palette.secondary.main
    },
    colorAction: {
      color: theme6.palette.action.active
    },
    colorError: {
      color: theme6.palette.error.main
    },
    colorDisabled: {
      color: theme6.palette.action.disabled
    },
    fontSizeInherit: {
      fontSize: "inherit"
    },
    fontSizeSmall: {
      fontSize: theme6.typography.pxToRem(20)
    },
    fontSizeLarge: {
      fontSize: theme6.typography.pxToRem(35)
    }
  };
};
var SvgIcon = /* @__PURE__ */ forwardRef23(function SvgIcon2(props, ref) {
  var children = props.children, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "inherit" : _props$color, _props$component = props.component, Component5 = _props$component === void 0 ? "svg" : _props$component, _props$fontSize = props.fontSize, fontSize = _props$fontSize === void 0 ? "default" : _props$fontSize, htmlColor = props.htmlColor, titleAccess = props.titleAccess, _props$viewBox = props.viewBox, viewBox = _props$viewBox === void 0 ? "0 0 24 24" : _props$viewBox, other = _objectWithoutProperties(props, ["children", "classes", "className", "color", "component", "fontSize", "htmlColor", "titleAccess", "viewBox"]);
  return /* @__PURE__ */ createElement27(Component5, _extends({
    className: clsx_m_default(classes.root, className, color !== "inherit" && classes["color".concat(capitalize(color))], fontSize !== "default" && classes["fontSize".concat(capitalize(fontSize))]),
    focusable: "false",
    viewBox,
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref
  }, other), children, titleAccess ? /* @__PURE__ */ createElement27("title", null, titleAccess) : null);
});
false ? SvgIcon.propTypes = {
  children: import_prop_types31.default.node,
  classes: import_prop_types31.default.object,
  className: import_prop_types31.default.string,
  color: import_prop_types31.default.oneOf(["action", "disabled", "error", "inherit", "primary", "secondary"]),
  component: import_prop_types31.default.elementType,
  fontSize: import_prop_types31.default.oneOf(["default", "inherit", "large", "small"]),
  htmlColor: import_prop_types31.default.string,
  shapeRendering: import_prop_types31.default.string,
  titleAccess: import_prop_types31.default.string,
  viewBox: import_prop_types31.default.string
} : void 0;
SvgIcon.muiName = "SvgIcon";
var SvgIcon_default = withStyles_default(styles32, {
  name: "MuiSvgIcon"
})(SvgIcon);

// node_modules/@material-ui/core/esm/utils/createSvgIcon.js
function createSvgIcon(path3, displayName) {
  var Component5 = function Component6(props, ref) {
    return /* @__PURE__ */ React54.createElement(SvgIcon_default, _extends({
      ref
    }, props), path3);
  };
  if (false) {
    Component5.displayName = "".concat(displayName, "Icon");
  }
  Component5.muiName = SvgIcon_default.muiName;
  return /* @__PURE__ */ React54.memo(/* @__PURE__ */ React54.forwardRef(Component5));
}

// node_modules/@material-ui/lab/esm/internal/svg-icons/SuccessOutlined.js
var SuccessOutlined_default = createSvgIcon(/* @__PURE__ */ createElement28("path", {
  d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
}), "SuccessOutlined");

// node_modules/@material-ui/lab/esm/internal/svg-icons/ReportProblemOutlined.js
import {
  createElement as createElement29
} from "https://cdn.skypack.dev/react";
var ReportProblemOutlined_default = createSvgIcon(/* @__PURE__ */ createElement29("path", {
  d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
}), "ReportProblemOutlined");

// node_modules/@material-ui/lab/esm/internal/svg-icons/ErrorOutline.js
import {
  createElement as createElement30
} from "https://cdn.skypack.dev/react";
var ErrorOutline_default = createSvgIcon(/* @__PURE__ */ createElement30("path", {
  d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "ErrorOutline");

// node_modules/@material-ui/lab/esm/internal/svg-icons/InfoOutlined.js
import {
  createElement as createElement31
} from "https://cdn.skypack.dev/react";
var InfoOutlined_default = createSvgIcon(/* @__PURE__ */ createElement31("path", {
  d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
}), "InfoOutlined");

// node_modules/@material-ui/lab/esm/internal/svg-icons/Close.js
import {
  createElement as createElement32
} from "https://cdn.skypack.dev/react";
var Close_default = createSvgIcon(/* @__PURE__ */ createElement32("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");

// node_modules/@material-ui/core/esm/IconButton/IconButton.js
var import_prop_types32 = __toModule(require_prop_types());
import {
  Children,
  createElement as createElement33,
  forwardRef as forwardRef24,
  isValidElement as isValidElement2
} from "https://cdn.skypack.dev/react";
var styles34 = function styles35(theme6) {
  return {
    root: {
      textAlign: "center",
      flex: "0 0 auto",
      fontSize: theme6.typography.pxToRem(24),
      padding: 12,
      borderRadius: "50%",
      overflow: "visible",
      color: theme6.palette.action.active,
      transition: theme6.transitions.create("background-color", {
        duration: theme6.transitions.duration.shortest
      }),
      "&:hover": {
        backgroundColor: fade(theme6.palette.action.active, theme6.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      "&$disabled": {
        backgroundColor: "transparent",
        color: theme6.palette.action.disabled
      }
    },
    edgeStart: {
      marginLeft: -12,
      "$sizeSmall&": {
        marginLeft: -3
      }
    },
    edgeEnd: {
      marginRight: -12,
      "$sizeSmall&": {
        marginRight: -3
      }
    },
    colorInherit: {
      color: "inherit"
    },
    colorPrimary: {
      color: theme6.palette.primary.main,
      "&:hover": {
        backgroundColor: fade(theme6.palette.primary.main, theme6.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    },
    colorSecondary: {
      color: theme6.palette.secondary.main,
      "&:hover": {
        backgroundColor: fade(theme6.palette.secondary.main, theme6.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    },
    disabled: {},
    sizeSmall: {
      padding: 3,
      fontSize: theme6.typography.pxToRem(18)
    },
    label: {
      width: "100%",
      display: "flex",
      alignItems: "inherit",
      justifyContent: "inherit"
    }
  };
};
var IconButton = /* @__PURE__ */ forwardRef24(function IconButton2(props, ref) {
  var _props$edge = props.edge, edge = _props$edge === void 0 ? false : _props$edge, children = props.children, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "default" : _props$color, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disableFocusRi = props.disableFocusRipple, disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi, _props$size = props.size, size = _props$size === void 0 ? "medium" : _props$size, other = _objectWithoutProperties(props, ["edge", "children", "classes", "className", "color", "disabled", "disableFocusRipple", "size"]);
  return /* @__PURE__ */ createElement33(ButtonBase_default, _extends({
    className: clsx_m_default(classes.root, className, color !== "default" && classes["color".concat(capitalize(color))], disabled && classes.disabled, size === "small" && classes["size".concat(capitalize(size))], {
      start: classes.edgeStart,
      end: classes.edgeEnd
    }[edge]),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    ref
  }, other), /* @__PURE__ */ createElement33("span", {
    className: classes.label
  }, children));
});
false ? IconButton.propTypes = {
  children: chainPropTypes(import_prop_types32.default.node, function(props) {
    var found = Children.toArray(props.children).some(function(child) {
      return /* @__PURE__ */ isValidElement2(child) && child.props.onClick;
    });
    if (found) {
      return new Error(["Material-UI: You are providing an onClick event listener to a child of a button element.", "Firefox will never trigger the event.", "You should move the onClick listener to the parent button element.", "https://github.com/mui-org/material-ui/issues/13957"].join("\n"));
    }
    return null;
  }),
  classes: import_prop_types32.default.object.isRequired,
  className: import_prop_types32.default.string,
  color: import_prop_types32.default.oneOf(["default", "inherit", "primary", "secondary"]),
  disabled: import_prop_types32.default.bool,
  disableFocusRipple: import_prop_types32.default.bool,
  disableRipple: import_prop_types32.default.bool,
  edge: import_prop_types32.default.oneOf(["start", "end", false]),
  size: import_prop_types32.default.oneOf(["small", "medium"])
} : void 0;
var IconButton_default = withStyles_default(styles34, {
  name: "MuiIconButton"
})(IconButton);

// node_modules/@material-ui/lab/esm/Alert/Alert.js
var styles36 = function styles37(theme6) {
  var getColor = theme6.palette.type === "light" ? darken : lighten;
  var getBackgroundColor = theme6.palette.type === "light" ? lighten : darken;
  return {
    root: _extends({}, theme6.typography.body2, {
      borderRadius: theme6.shape.borderRadius,
      backgroundColor: "transparent",
      display: "flex",
      padding: "6px 16px"
    }),
    standardSuccess: {
      color: getColor(theme6.palette.success.main, 0.6),
      backgroundColor: getBackgroundColor(theme6.palette.success.main, 0.9),
      "& $icon": {
        color: theme6.palette.success.main
      }
    },
    standardInfo: {
      color: getColor(theme6.palette.info.main, 0.6),
      backgroundColor: getBackgroundColor(theme6.palette.info.main, 0.9),
      "& $icon": {
        color: theme6.palette.info.main
      }
    },
    standardWarning: {
      color: getColor(theme6.palette.warning.main, 0.6),
      backgroundColor: getBackgroundColor(theme6.palette.warning.main, 0.9),
      "& $icon": {
        color: theme6.palette.warning.main
      }
    },
    standardError: {
      color: getColor(theme6.palette.error.main, 0.6),
      backgroundColor: getBackgroundColor(theme6.palette.error.main, 0.9),
      "& $icon": {
        color: theme6.palette.error.main
      }
    },
    outlinedSuccess: {
      color: getColor(theme6.palette.success.main, 0.6),
      border: "1px solid ".concat(theme6.palette.success.main),
      "& $icon": {
        color: theme6.palette.success.main
      }
    },
    outlinedInfo: {
      color: getColor(theme6.palette.info.main, 0.6),
      border: "1px solid ".concat(theme6.palette.info.main),
      "& $icon": {
        color: theme6.palette.info.main
      }
    },
    outlinedWarning: {
      color: getColor(theme6.palette.warning.main, 0.6),
      border: "1px solid ".concat(theme6.palette.warning.main),
      "& $icon": {
        color: theme6.palette.warning.main
      }
    },
    outlinedError: {
      color: getColor(theme6.palette.error.main, 0.6),
      border: "1px solid ".concat(theme6.palette.error.main),
      "& $icon": {
        color: theme6.palette.error.main
      }
    },
    filledSuccess: {
      color: "#fff",
      fontWeight: theme6.typography.fontWeightMedium,
      backgroundColor: theme6.palette.success.main
    },
    filledInfo: {
      color: "#fff",
      fontWeight: theme6.typography.fontWeightMedium,
      backgroundColor: theme6.palette.info.main
    },
    filledWarning: {
      color: "#fff",
      fontWeight: theme6.typography.fontWeightMedium,
      backgroundColor: theme6.palette.warning.main
    },
    filledError: {
      color: "#fff",
      fontWeight: theme6.typography.fontWeightMedium,
      backgroundColor: theme6.palette.error.main
    },
    icon: {
      marginRight: 12,
      padding: "7px 0",
      display: "flex",
      fontSize: 22,
      opacity: 0.9
    },
    message: {
      padding: "8px 0"
    },
    action: {
      display: "flex",
      alignItems: "center",
      marginLeft: "auto",
      paddingLeft: 16,
      marginRight: -8
    }
  };
};
var defaultIconMapping = {
  success: /* @__PURE__ */ createElement34(SuccessOutlined_default, {
    fontSize: "inherit"
  }),
  warning: /* @__PURE__ */ createElement34(ReportProblemOutlined_default, {
    fontSize: "inherit"
  }),
  error: /* @__PURE__ */ createElement34(ErrorOutline_default, {
    fontSize: "inherit"
  }),
  info: /* @__PURE__ */ createElement34(InfoOutlined_default, {
    fontSize: "inherit"
  })
};
var _ref = /* @__PURE__ */ createElement34(Close_default, {
  fontSize: "small"
});
var Alert = /* @__PURE__ */ forwardRef25(function Alert2(props, ref) {
  var action = props.action, children = props.children, classes = props.classes, className = props.className, _props$closeText = props.closeText, closeText = _props$closeText === void 0 ? "Close" : _props$closeText, color = props.color, icon = props.icon, _props$iconMapping = props.iconMapping, iconMapping = _props$iconMapping === void 0 ? defaultIconMapping : _props$iconMapping, onClose = props.onClose, _props$role = props.role, role = _props$role === void 0 ? "alert" : _props$role, _props$severity = props.severity, severity = _props$severity === void 0 ? "success" : _props$severity, _props$variant = props.variant, variant = _props$variant === void 0 ? "standard" : _props$variant, other = _objectWithoutProperties(props, ["action", "children", "classes", "className", "closeText", "color", "icon", "iconMapping", "onClose", "role", "severity", "variant"]);
  return /* @__PURE__ */ createElement34(Paper_default, _extends({
    role,
    square: true,
    elevation: 0,
    className: clsx_m_default(classes.root, classes["".concat(variant).concat(capitalize(color || severity))], className),
    ref
  }, other), icon !== false ? /* @__PURE__ */ createElement34("div", {
    className: classes.icon
  }, icon || iconMapping[severity] || defaultIconMapping[severity]) : null, /* @__PURE__ */ createElement34("div", {
    className: classes.message
  }, children), action != null ? /* @__PURE__ */ createElement34("div", {
    className: classes.action
  }, action) : null, action == null && onClose ? /* @__PURE__ */ createElement34("div", {
    className: classes.action
  }, /* @__PURE__ */ createElement34(IconButton_default, {
    size: "small",
    "aria-label": closeText,
    title: closeText,
    color: "inherit",
    onClick: onClose
  }, _ref)) : null);
});
false ? Alert.propTypes = {
  action: import_prop_types33.default.node,
  children: import_prop_types33.default.node,
  classes: import_prop_types33.default.object,
  className: import_prop_types33.default.string,
  closeText: import_prop_types33.default.string,
  color: import_prop_types33.default.oneOf(["error", "info", "success", "warning"]),
  icon: import_prop_types33.default.node,
  iconMapping: import_prop_types33.default.shape({
    error: import_prop_types33.default.node,
    info: import_prop_types33.default.node,
    success: import_prop_types33.default.node,
    warning: import_prop_types33.default.node
  }),
  onClose: import_prop_types33.default.func,
  role: import_prop_types33.default.string,
  severity: import_prop_types33.default.oneOf(["error", "info", "success", "warning"]),
  variant: import_prop_types33.default.oneOf(["filled", "outlined", "standard"])
} : void 0;
var Alert_default = withStyles_default(styles36, {
  name: "MuiAlert"
})(Alert);

// node_modules/@material-ui/lab/esm/AlertTitle/AlertTitle.js
var import_prop_types34 = __toModule(require_prop_types());
import {
  createElement as createElement35,
  forwardRef as forwardRef26
} from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/core/esm/index.js
/** @license Material-UI v4.11.2
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// node_modules/@material-ui/lab/esm/AlertTitle/AlertTitle.js
var styles38 = function styles39(theme6) {
  return {
    root: {
      fontWeight: theme6.typography.fontWeightMedium,
      marginTop: -2
    }
  };
};
var AlertTitle = /* @__PURE__ */ forwardRef26(function AlertTitle2(props, ref) {
  var classes = props.classes, className = props.className, other = _objectWithoutProperties(props, ["classes", "className"]);
  return /* @__PURE__ */ createElement35(Typography_default, _extends({
    gutterBottom: true,
    component: "div",
    ref,
    className: clsx_m_default(classes.root, className)
  }, other));
});
false ? AlertTitle.propTypes = {
  children: import_prop_types34.default.node,
  classes: import_prop_types34.default.object,
  className: import_prop_types34.default.string
} : void 0;
var AlertTitle_default = withStyles_default(styles38, {
  name: "MuiAlertTitle"
})(AlertTitle);

// src/client/components/NotificationsList/NotificationsActions.tsx
import React63 from "https://cdn.skypack.dev/react";
var NotificationsActions = ({actions: actions25}) => {
  return /* @__PURE__ */ React63.createElement(Box_default, {
    ml: -1
  }, /* @__PURE__ */ React63.createElement(CardActions_default2, null, actions25.map((item) => /* @__PURE__ */ React63.createElement(Button_default, {
    variant: "outlined",
    onClick: item.handler,
    key: item.name
  }, item.name))));
};
var NotificationsActions_default = NotificationsActions;

// src/client/components/NotificationsList/NotificationItem.tsx
var NotificationItem = ({handleClose, children, title, state, actions: actions25}) => {
  return /* @__PURE__ */ React64.createElement(Alert_default, {
    severity: state || "info",
    onClose: handleClose
  }, title ? /* @__PURE__ */ React64.createElement(AlertTitle_default, null, title) : null, children, actions25 ? /* @__PURE__ */ React64.createElement(NotificationsActions_default, {
    actions: actions25
  }) : null);
};
var NotificationItem_default = NotificationItem;

// src/client/components/NotificationsList/NotificationsListHeader.tsx
import React67 from "https://cdn.skypack.dev/react";

// node_modules/@material-ui/icons/esm/Close.js
import {
  createElement as createElement36
} from "https://cdn.skypack.dev/react";
var Close_default2 = createSvgIcon(/* @__PURE__ */ createElement36("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");

// node_modules/@material-ui/icons/esm/ExpandMore.js
import {
  createElement as createElement37
} from "https://cdn.skypack.dev/react";
var ExpandMore_default = createSvgIcon(/* @__PURE__ */ createElement37("path", {
  d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), "ExpandMore");

// src/client/components/NotificationsList/NotificationsListHeader.tsx
var NotificationsListHeader = ({onClose, onDeleteAll, counter}) => {
  return /* @__PURE__ */ React67.createElement(Box_default, {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    bgcolor: "grey.600",
    p: 1
  }, counter ? `Notifications (${counter})` : "No notifications", /* @__PURE__ */ React67.createElement(Box_default, null, /* @__PURE__ */ React67.createElement(IconButton_default, {
    title: "Hide notifications",
    size: "small",
    onClick: onClose
  }, /* @__PURE__ */ React67.createElement(ExpandMore_default, {
    fontSize: "small"
  })), /* @__PURE__ */ React67.createElement(IconButton_default, {
    disabled: !counter,
    title: "Clear all notifications",
    size: "small",
    onClick: onDeleteAll
  }, /* @__PURE__ */ React67.createElement(Close_default2, {
    fontSize: "small"
  }))));
};
var NotificationsListHeader_default = NotificationsListHeader;

// src/client/components/NotificationsList/NotificationsList.tsx
var useStyles = makeStyles_default((theme6) => ({
  item: {
    padding: 0,
    display: "block"
  }
}));
var NotificationsList = ({isOpen, items, onClose, onDeleteAll}) => {
  const classes = useStyles();
  const listNode = React68.useRef();
  const [height, setHeight] = React68.useState(0);
  useEffect17(() => {
    setHeight(listNode.current?.clientHeight + 45);
  }, [items]);
  return /* @__PURE__ */ React68.createElement(Snackbar_default, {
    open: isOpen,
    anchorOrigin: {vertical: "bottom", horizontal: "right"},
    disableWindowBlurListener: true
  }, /* @__PURE__ */ React68.createElement(Box_default, {
    height,
    width: 400,
    maxHeight: 500
  }, /* @__PURE__ */ React68.createElement(NotificationsListHeader_default, {
    counter: items.length,
    onDeleteAll,
    onClose
  }), /* @__PURE__ */ React68.createElement(Scrollable_default, null, /* @__PURE__ */ React68.createElement(List_default2, {
    ref: listNode,
    disablePadding: true
  }, items.map((data) => /* @__PURE__ */ React68.createElement(ListItem_default, {
    key: data.id,
    classes: {root: classes.item}
  }, /* @__PURE__ */ React68.createElement(NotificationItem_default, {
    ...data
  }, data.information)))))));
};
var NotificationsList_default = NotificationsList;

// src/client/services/Notification/NotificationService.tsx
var notificationServiceContext = React69.createContext(null);
function NotificationService({children}) {
  const [
    state,
    {register, unregister, unregisterAll, changeVisibility}
  ] = useTypesafeReducer(notificationServiceReducer, initialState3, actions23);
  const notificationService = {
    register,
    unregister,
    unregisterAll,
    changeVisibility
  };
  return /* @__PURE__ */ React69.createElement(React69.Fragment, null, /* @__PURE__ */ React69.createElement(notificationServiceContext.Provider, {
    value: notificationService
  }, children), /* @__PURE__ */ React69.createElement(NotificationsList_default, {
    isOpen: state.visibility,
    items: state.notifications,
    onDeleteAll: notificationService.unregisterAll,
    onClose: changeVisibility
  }));
}
var NotificationService_default = React69.memo(NotificationService);

// src/client/services/Display/DisplayService.tsx
import React70 from "https://cdn.skypack.dev/react";

// src/client/services/Display/reducer.ts
var import_typesafe_actions21 = __toModule(require_typesafe_actions_umd_production());
var actions24 = {
  setSidebarVisible: import_typesafe_actions21.createAction("DISPLAY_SET_SIDEBAR_VISIBLE")(),
  setSidebarWidth: import_typesafe_actions21.createAction("DISPLAY_SET_SIDEBAR_WIDTH")()
};
var initialState4 = {
  sidebarVisible: true,
  sidebarWidth: void 0
};
var displayServiceReducer = import_typesafe_actions21.createReducer(initialState4).handleAction(actions24.setSidebarVisible, (state, action) => {
  return {
    ...state,
    sidebarVisible: action.payload
  };
}).handleAction(actions24.setSidebarWidth, (state, action) => {
  return {
    ...state,
    sidebarWidth: action.payload
  };
});

// src/client/services/Display/DisplayService.tsx
var displayService = React70.createContext(null);
var DisplayServiceProviderChildren = class extends React70.PureComponent {
  render() {
    return this.props.children;
  }
};
function DisplayService({children}) {
  const [state, {setSidebarVisible, setSidebarWidth}] = useTypesafeReducer(displayServiceReducer, initialState4, actions24);
  const api = {
    state,
    setSidebarVisible,
    setSidebarWidth
  };
  return /* @__PURE__ */ React70.createElement(displayService.Provider, {
    value: api
  }, /* @__PURE__ */ React70.createElement(DisplayServiceProviderChildren, null, children));
}
var DisplayService_default = React70.memo(DisplayService);

// src/client/services/index.tsx
var Services = ({children}) => {
  return /* @__PURE__ */ React71.createElement(PickerService_default, null, /* @__PURE__ */ React71.createElement(CommandService_default, null, /* @__PURE__ */ React71.createElement(ThemeCommands, null, /* @__PURE__ */ React71.createElement(NotificationService_default, null, /* @__PURE__ */ React71.createElement(DisplayService_default, null, children)))));
};
var services_default = React71.memo(Services);

// src/sdk/_runtime.tsx
window.React = React72;
var intervalTimers = [];
var timeoutTimers = [];
var _originalSetInterval = window.setInterval;
var _originalSetTimeout = window.setTimeout;
window.setInterval = (handler, timeout3) => {
  const timer = _originalSetInterval(handler, timeout3);
  intervalTimers.push(timer);
  return timer;
};
window.setTimeout = (handler, timeout3) => {
  const timer = _originalSetTimeout(handler, timeout3);
  timeoutTimers.push(timer);
  return timer;
};
function disposeTimers() {
  intervalTimers.forEach((timer) => {
    try {
      clearInterval(timer);
    } catch (e) {
    }
  });
  timeoutTimers.forEach((timer) => {
    try {
      clearTimeout(timer);
    } catch (e) {
    }
  });
  intervalTimers = [];
  timeoutTimers = [];
}
var GlobalErrorComponent = (props) => {
  const error = props.error;
  const errorDetail = error ? `${error.stack}` : `No error information available`;
  return /* @__PURE__ */ React72.createElement(View_default, {
    title: error?.message || "An Error Occurred",
    subheader: "",
    emoji: "\u{1F62D}",
    maxWidth: 800,
    error: props.error,
    errorInfo: props.errorInfo,
    actions: null
  }, /* @__PURE__ */ React72.createElement(Typography_default2, null, errorDetail));
};
var GeneralSkeleton = () => /* @__PURE__ */ React72.createElement(Skeleton_default, {
  variant: "rect",
  width: "100%",
  height: "100%"
});
var RuntimeRenderer = (props) => {
  const loading = /* @__PURE__ */ React72.createElement(Layout_default, null, /* @__PURE__ */ React72.createElement(Row_default, null, /* @__PURE__ */ React72.createElement(GeneralSkeleton, null), /* @__PURE__ */ React72.createElement(GeneralSkeleton, null)), /* @__PURE__ */ React72.createElement(Row_default, null, /* @__PURE__ */ React72.createElement(Column_default, null, /* @__PURE__ */ React72.createElement(GeneralSkeleton, null)), /* @__PURE__ */ React72.createElement(Column_default, null, /* @__PURE__ */ React72.createElement(GeneralSkeleton, null))));
  const MainModule = useMemo8(() => {
    if (props.error) {
      return /* @__PURE__ */ React72.createElement(GlobalErrorComponent, {
        error: props.error
      });
    }
    if (!props.mod) {
      return loading;
    }
    if (typeof props.mod !== "function") {
      return /* @__PURE__ */ React72.createElement(GlobalErrorComponent, null);
    }
    return props.mod;
  }, [props.error, props.mod]);
  return /* @__PURE__ */ React72.createElement("div", {
    style: {width: "100vw", height: "100vh"}
  }, /* @__PURE__ */ React72.createElement(Box_default, {
    position: "absolute",
    width: "100%",
    height: "100%",
    className: "RuntimeWrapper"
  }, MainModule));
};
var Runtime = () => {
  const [state, setState] = useState7({error: null, module: null});
  const {moduleUri, refreshRequestId} = useSandboxState();
  useEffect19(() => {
    if (!moduleUri) {
      return;
    }
    const loadModule = async () => {
      try {
        disposeTimers();
        const module = await import(moduleUri + "?mtime=" + refreshRequestId);
        if (!module.default) {
          throw Error("module does not export a default function");
        }
        setState({module: module.default, error: null});
      } catch (err) {
        setState({module: null, error: err});
      }
    };
    loadModule();
  }, [moduleUri, refreshRequestId]);
  return /* @__PURE__ */ React72.createElement(Boundary_default, {
    fullPage: true,
    errorComponent: GlobalErrorComponent,
    key: state.module?.toString()
  }, /* @__PURE__ */ React72.createElement(RuntimeRenderer, {
    mod: state.module,
    error: state.error
  }));
};
ReactDOM6.render(/* @__PURE__ */ React72.createElement(BrowserRouter, null, /* @__PURE__ */ React72.createElement(StoreProvider, null, /* @__PURE__ */ React72.createElement(themes_default.ThemeSwitcher, null, /* @__PURE__ */ React72.createElement(Boundary_default, {
  fullPage: true,
  errorComponent: GlobalErrorComponent
}, /* @__PURE__ */ React72.createElement(services_default, null, /* @__PURE__ */ React72.createElement(Switch, null, /* @__PURE__ */ React72.createElement(Route, {
  key: "*",
  path: "*",
  component: Runtime
}))))))), document.getElementById("root"));
//# sourceMappingURL=_runtime.js.map
