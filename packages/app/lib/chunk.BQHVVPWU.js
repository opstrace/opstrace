// ../../node_modules/monaco-editor/esm/vs/nls.js
function _format(message, args) {
  let result;
  if (args.length === 0) {
    result = message;
  } else {
    result = message.replace(/\{(\d+)\}/g, function(match2, rest) {
      const index = rest[0];
      return typeof args[index] !== "undefined" ? args[index] : match2;
    });
  }
  return result;
}
function localize(data, message, ...args) {
  return _format(message, args);
}

// ../../node_modules/monaco-editor/esm/vs/base/common/platform.js
var LANGUAGE_DEFAULT = "en";
var _isWindows = false;
var _isMacintosh = false;
var _isLinux = false;
var _isNative = false;
var _isWeb = false;
var _isIOS = false;
var _locale = void 0;
var _language = LANGUAGE_DEFAULT;
var _translationsConfigFile = void 0;
var _userAgent = void 0;
var isElectronRenderer = typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.electron !== "undefined" && process.type === "renderer";
if (typeof navigator === "object" && !isElectronRenderer) {
  _userAgent = navigator.userAgent;
  _isWindows = _userAgent.indexOf("Windows") >= 0;
  _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
  _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
  _isLinux = _userAgent.indexOf("Linux") >= 0;
  _isWeb = true;
  _locale = navigator.language;
  _language = _locale;
} else if (typeof process === "object") {
  _isWindows = process.platform === "win32";
  _isMacintosh = process.platform === "darwin";
  _isLinux = process.platform === "linux";
  _locale = LANGUAGE_DEFAULT;
  _language = LANGUAGE_DEFAULT;
  const rawNlsConfig = process.env["VSCODE_NLS_CONFIG"];
  if (rawNlsConfig) {
    try {
      const nlsConfig = JSON.parse(rawNlsConfig);
      const resolved = nlsConfig.availableLanguages["*"];
      _locale = nlsConfig.locale;
      _language = resolved ? resolved : LANGUAGE_DEFAULT;
      _translationsConfigFile = nlsConfig._translationsConfigFile;
    } catch (e) {
    }
  }
  _isNative = true;
}
var _platform = 0;
if (_isMacintosh) {
  _platform = 1;
} else if (_isWindows) {
  _platform = 3;
} else if (_isLinux) {
  _platform = 2;
}
var isWindows = _isWindows;
var isMacintosh = _isMacintosh;
var isLinux = _isLinux;
var isNative = _isNative;
var isWeb = _isWeb;
var isIOS = _isIOS;
var _globals = typeof self === "object" ? self : typeof self === "object" ? self : {};
var globals = _globals;
var setImmediate = function defineSetImmediate() {
  if (globals.setImmediate) {
    return globals.setImmediate.bind(globals);
  }
  if (typeof globals.postMessage === "function" && !globals.importScripts) {
    let pending = [];
    globals.addEventListener("message", (e) => {
      if (e.data && e.data.vscodeSetImmediateId) {
        for (let i = 0, len = pending.length; i < len; i++) {
          const candidate = pending[i];
          if (candidate.id === e.data.vscodeSetImmediateId) {
            pending.splice(i, 1);
            candidate.callback();
            return;
          }
        }
      }
    });
    let lastId = 0;
    return (callback) => {
      const myId = ++lastId;
      pending.push({
        id: myId,
        callback
      });
      globals.postMessage({vscodeSetImmediateId: myId}, "*");
    };
  }
  if (typeof process !== "undefined" && typeof process.nextTick === "function") {
    return process.nextTick.bind(process);
  }
  const _promise = Promise.resolve();
  return (callback) => _promise.then(callback);
}();
var OS = _isMacintosh || _isIOS ? 2 : _isWindows ? 1 : 3;
var _isLittleEndian = true;
var _isLittleEndianComputed = false;
function isLittleEndian() {
  if (!_isLittleEndianComputed) {
    _isLittleEndianComputed = true;
    const test = new Uint8Array(2);
    test[0] = 1;
    test[1] = 2;
    const view = new Uint16Array(test.buffer);
    _isLittleEndian = view[0] === (2 << 8) + 1;
  }
  return _isLittleEndian;
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js
var USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function createWordRegExp(allowInWords = "") {
  let source = "(-?\\d*\\.\\d\\w*)|([^";
  for (const sep2 of USUAL_WORD_SEPARATORS) {
    if (allowInWords.indexOf(sep2) >= 0) {
      continue;
    }
    source += "\\" + sep2;
  }
  source += "\\s]+)";
  return new RegExp(source, "g");
}
var DEFAULT_WORD_REGEXP = createWordRegExp();
function ensureValidWordDefinition(wordDefinition) {
  let result = DEFAULT_WORD_REGEXP;
  if (wordDefinition && wordDefinition instanceof RegExp) {
    if (!wordDefinition.global) {
      let flags = "g";
      if (wordDefinition.ignoreCase) {
        flags += "i";
      }
      if (wordDefinition.multiline) {
        flags += "m";
      }
      if (wordDefinition.unicode) {
        flags += "u";
      }
      result = new RegExp(wordDefinition.source, flags);
    } else {
      result = wordDefinition;
    }
  }
  result.lastIndex = 0;
  return result;
}
var _defaultConfig = {
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
};
function getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {
  if (text.length > config.maxLen) {
    let start = column - config.maxLen / 2;
    if (start < 0) {
      textOffset += column;
      start = 0;
    } else {
      textOffset += start;
    }
    text = text.substring(start, column + config.maxLen / 2);
    return getWordAtText(column, wordDefinition, text, textOffset, config);
  }
  const t1 = Date.now();
  const pos = column - 1 - textOffset;
  let prevRegexIndex = -1;
  let match2 = null;
  for (let i = 1; ; i++) {
    if (Date.now() - t1 >= config.timeBudget) {
    }
    const regexIndex = pos - config.windowSize * i;
    wordDefinition.lastIndex = Math.max(0, regexIndex);
    const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
    if (!thisMatch && match2) {
      break;
    }
    match2 = thisMatch;
    if (regexIndex <= 0) {
      break;
    }
    prevRegexIndex = regexIndex;
  }
  if (match2) {
    let result = {
      word: match2[0],
      startColumn: textOffset + 1 + match2.index,
      endColumn: textOffset + 1 + match2.index + match2[0].length
    };
    wordDefinition.lastIndex = 0;
    return result;
  }
  return null;
}
function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
  let match2;
  while (match2 = wordDefinition.exec(text)) {
    const matchIndex = match2.index || 0;
    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
      return match2;
    } else if (stopPos > 0 && matchIndex > stopPos) {
      return null;
    }
  }
  return null;
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/config/editorOptions.js
var MINIMAP_GUTTER_WIDTH = 8;
var ConfigurationChangedEvent = class {
  constructor(values) {
    this._values = values;
  }
  hasChanged(id) {
    return this._values[id];
  }
};
var ValidatedEditorOptions = class {
  constructor() {
    this._values = [];
  }
  _read(option) {
    return this._values[option];
  }
  get(id) {
    return this._values[id];
  }
  _write(option, value) {
    this._values[option] = value;
  }
};
var ComputeOptionsMemory = class {
  constructor() {
    this.stableMinimapLayoutInput = null;
    this.stableFitMaxMinimapScale = 0;
    this.stableFitRemainingWidth = 0;
  }
};
var BaseEditorOption = class {
  constructor(id, name, defaultValue, schema) {
    this.id = id;
    this.name = name;
    this.defaultValue = defaultValue;
    this.schema = schema;
  }
  compute(env2, options, value) {
    return value;
  }
};
var ComputedEditorOption = class {
  constructor(id, deps = null) {
    this.schema = void 0;
    this.id = id;
    this.name = "_never_";
    this.defaultValue = void 0;
    this.deps = deps;
  }
  validate(input) {
    return this.defaultValue;
  }
};
var SimpleEditorOption = class {
  constructor(id, name, defaultValue, schema) {
    this.id = id;
    this.name = name;
    this.defaultValue = defaultValue;
    this.schema = schema;
  }
  validate(input) {
    if (typeof input === "undefined") {
      return this.defaultValue;
    }
    return input;
  }
  compute(env2, options, value) {
    return value;
  }
};
var EditorBooleanOption = class extends SimpleEditorOption {
  static boolean(value, defaultValue) {
    if (typeof value === "undefined") {
      return defaultValue;
    }
    if (value === "false") {
      return false;
    }
    return Boolean(value);
  }
  constructor(id, name, defaultValue, schema = void 0) {
    if (typeof schema !== "undefined") {
      schema.type = "boolean";
      schema.default = defaultValue;
    }
    super(id, name, defaultValue, schema);
  }
  validate(input) {
    return EditorBooleanOption.boolean(input, this.defaultValue);
  }
};
var EditorIntOption = class extends SimpleEditorOption {
  constructor(id, name, defaultValue, minimum, maximum, schema = void 0) {
    if (typeof schema !== "undefined") {
      schema.type = "integer";
      schema.default = defaultValue;
      schema.minimum = minimum;
      schema.maximum = maximum;
    }
    super(id, name, defaultValue, schema);
    this.minimum = minimum;
    this.maximum = maximum;
  }
  static clampedInt(value, defaultValue, minimum, maximum) {
    if (typeof value === "undefined") {
      return defaultValue;
    }
    let r = parseInt(value, 10);
    if (isNaN(r)) {
      return defaultValue;
    }
    r = Math.max(minimum, r);
    r = Math.min(maximum, r);
    return r | 0;
  }
  validate(input) {
    return EditorIntOption.clampedInt(input, this.defaultValue, this.minimum, this.maximum);
  }
};
var EditorFloatOption = class extends SimpleEditorOption {
  constructor(id, name, defaultValue, validationFn, schema) {
    if (typeof schema !== "undefined") {
      schema.type = "number";
      schema.default = defaultValue;
    }
    super(id, name, defaultValue, schema);
    this.validationFn = validationFn;
  }
  static clamp(n, min, max) {
    if (n < min) {
      return min;
    }
    if (n > max) {
      return max;
    }
    return n;
  }
  static float(value, defaultValue) {
    if (typeof value === "number") {
      return value;
    }
    if (typeof value === "undefined") {
      return defaultValue;
    }
    const r = parseFloat(value);
    return isNaN(r) ? defaultValue : r;
  }
  validate(input) {
    return this.validationFn(EditorFloatOption.float(input, this.defaultValue));
  }
};
var EditorStringOption = class extends SimpleEditorOption {
  static string(value, defaultValue) {
    if (typeof value !== "string") {
      return defaultValue;
    }
    return value;
  }
  constructor(id, name, defaultValue, schema = void 0) {
    if (typeof schema !== "undefined") {
      schema.type = "string";
      schema.default = defaultValue;
    }
    super(id, name, defaultValue, schema);
  }
  validate(input) {
    return EditorStringOption.string(input, this.defaultValue);
  }
};
var EditorStringEnumOption = class extends SimpleEditorOption {
  constructor(id, name, defaultValue, allowedValues, schema = void 0) {
    if (typeof schema !== "undefined") {
      schema.type = "string";
      schema.enum = allowedValues;
      schema.default = defaultValue;
    }
    super(id, name, defaultValue, schema);
    this._allowedValues = allowedValues;
  }
  static stringSet(value, defaultValue, allowedValues) {
    if (typeof value !== "string") {
      return defaultValue;
    }
    if (allowedValues.indexOf(value) === -1) {
      return defaultValue;
    }
    return value;
  }
  validate(input) {
    return EditorStringEnumOption.stringSet(input, this.defaultValue, this._allowedValues);
  }
};
var EditorEnumOption = class extends BaseEditorOption {
  constructor(id, name, defaultValue, defaultStringValue, allowedValues, convert, schema = void 0) {
    if (typeof schema !== "undefined") {
      schema.type = "string";
      schema.enum = allowedValues;
      schema.default = defaultStringValue;
    }
    super(id, name, defaultValue, schema);
    this._allowedValues = allowedValues;
    this._convert = convert;
  }
  validate(input) {
    if (typeof input !== "string") {
      return this.defaultValue;
    }
    if (this._allowedValues.indexOf(input) === -1) {
      return this.defaultValue;
    }
    return this._convert(input);
  }
};
function _autoIndentFromString(autoIndent) {
  switch (autoIndent) {
    case "none":
      return 0;
    case "keep":
      return 1;
    case "brackets":
      return 2;
    case "advanced":
      return 3;
    case "full":
      return 4;
  }
}
var EditorAccessibilitySupport = class extends BaseEditorOption {
  constructor() {
    super(2, "accessibilitySupport", 0, {
      type: "string",
      enum: ["auto", "on", "off"],
      enumDescriptions: [
        localize("accessibilitySupport.auto", "The editor will use platform APIs to detect when a Screen Reader is attached."),
        localize("accessibilitySupport.on", "The editor will be permanently optimized for usage with a Screen Reader."),
        localize("accessibilitySupport.off", "The editor will never be optimized for usage with a Screen Reader.")
      ],
      default: "auto",
      description: localize("accessibilitySupport", "Controls whether the editor should run in a mode where it is optimized for screen readers.")
    });
  }
  validate(input) {
    switch (input) {
      case "auto":
        return 0;
      case "off":
        return 1;
      case "on":
        return 2;
    }
    return this.defaultValue;
  }
  compute(env2, options, value) {
    if (value === 0) {
      return env2.accessibilitySupport;
    }
    return value;
  }
};
var EditorComments = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      insertSpace: true,
      ignoreEmptyLines: true
    };
    super(14, "comments", defaults, {
      "editor.comments.insertSpace": {
        type: "boolean",
        default: defaults.insertSpace,
        description: localize("comments.insertSpace", "Controls whether a space character is inserted when commenting.")
      },
      "editor.comments.ignoreEmptyLines": {
        type: "boolean",
        default: defaults.ignoreEmptyLines,
        description: localize("comments.ignoreEmptyLines", "Controls if empty lines should be ignored with toggle, add or remove actions for line comments.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      insertSpace: EditorBooleanOption.boolean(input.insertSpace, this.defaultValue.insertSpace),
      ignoreEmptyLines: EditorBooleanOption.boolean(input.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
    };
  }
};
function _cursorBlinkingStyleFromString(cursorBlinkingStyle) {
  switch (cursorBlinkingStyle) {
    case "blink":
      return 1;
    case "smooth":
      return 2;
    case "phase":
      return 3;
    case "expand":
      return 4;
    case "solid":
      return 5;
  }
}
var TextEditorCursorStyle;
(function(TextEditorCursorStyle3) {
  TextEditorCursorStyle3[TextEditorCursorStyle3["Line"] = 1] = "Line";
  TextEditorCursorStyle3[TextEditorCursorStyle3["Block"] = 2] = "Block";
  TextEditorCursorStyle3[TextEditorCursorStyle3["Underline"] = 3] = "Underline";
  TextEditorCursorStyle3[TextEditorCursorStyle3["LineThin"] = 4] = "LineThin";
  TextEditorCursorStyle3[TextEditorCursorStyle3["BlockOutline"] = 5] = "BlockOutline";
  TextEditorCursorStyle3[TextEditorCursorStyle3["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
function _cursorStyleFromString(cursorStyle) {
  switch (cursorStyle) {
    case "line":
      return TextEditorCursorStyle.Line;
    case "block":
      return TextEditorCursorStyle.Block;
    case "underline":
      return TextEditorCursorStyle.Underline;
    case "line-thin":
      return TextEditorCursorStyle.LineThin;
    case "block-outline":
      return TextEditorCursorStyle.BlockOutline;
    case "underline-thin":
      return TextEditorCursorStyle.UnderlineThin;
  }
}
var EditorClassName = class extends ComputedEditorOption {
  constructor() {
    super(114, [57, 27]);
  }
  compute(env2, options, _) {
    const classNames = ["monaco-editor"];
    if (options.get(27)) {
      classNames.push(options.get(27));
    }
    if (env2.extraEditorClassName) {
      classNames.push(env2.extraEditorClassName);
    }
    if (options.get(57) === "default") {
      classNames.push("mouse-default");
    } else if (options.get(57) === "copy") {
      classNames.push("mouse-copy");
    }
    if (options.get(92)) {
      classNames.push("showUnused");
    }
    if (options.get(113)) {
      classNames.push("showDeprecated");
    }
    return classNames.join(" ");
  }
};
var EditorEmptySelectionClipboard = class extends EditorBooleanOption {
  constructor() {
    super(26, "emptySelectionClipboard", true, {description: localize("emptySelectionClipboard", "Controls whether copying without a selection copies the current line.")});
  }
  compute(env2, options, value) {
    return value && env2.emptySelectionClipboard;
  }
};
var EditorFind = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      cursorMoveOnType: true,
      seedSearchStringFromSelection: true,
      autoFindInSelection: "never",
      globalFindClipboard: false,
      addExtraSpaceOnTop: true,
      loop: true
    };
    super(29, "find", defaults, {
      "editor.find.cursorMoveOnType": {
        type: "boolean",
        default: defaults.cursorMoveOnType,
        description: localize("find.cursorMoveOnType", "Controls whether the cursor should jump to find matches while typing.")
      },
      "editor.find.seedSearchStringFromSelection": {
        type: "boolean",
        default: defaults.seedSearchStringFromSelection,
        description: localize("find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection.")
      },
      "editor.find.autoFindInSelection": {
        type: "string",
        enum: ["never", "always", "multiline"],
        default: defaults.autoFindInSelection,
        enumDescriptions: [
          localize("editor.find.autoFindInSelection.never", "Never turn on Find in selection automatically (default)"),
          localize("editor.find.autoFindInSelection.always", "Always turn on Find in selection automatically"),
          localize("editor.find.autoFindInSelection.multiline", "Turn on Find in selection automatically when multiple lines of content are selected.")
        ],
        description: localize("find.autoFindInSelection", "Controls the condition for turning on find in selection automatically.")
      },
      "editor.find.globalFindClipboard": {
        type: "boolean",
        default: defaults.globalFindClipboard,
        description: localize("find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
        included: isMacintosh
      },
      "editor.find.addExtraSpaceOnTop": {
        type: "boolean",
        default: defaults.addExtraSpaceOnTop,
        description: localize("find.addExtraSpaceOnTop", "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
      },
      "editor.find.loop": {
        type: "boolean",
        default: defaults.loop,
        description: localize("find.loop", "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      cursorMoveOnType: EditorBooleanOption.boolean(input.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
      seedSearchStringFromSelection: EditorBooleanOption.boolean(input.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection),
      autoFindInSelection: typeof _input.autoFindInSelection === "boolean" ? _input.autoFindInSelection ? "always" : "never" : EditorStringEnumOption.stringSet(input.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
      globalFindClipboard: EditorBooleanOption.boolean(input.globalFindClipboard, this.defaultValue.globalFindClipboard),
      addExtraSpaceOnTop: EditorBooleanOption.boolean(input.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
      loop: EditorBooleanOption.boolean(input.loop, this.defaultValue.loop)
    };
  }
};
var EditorFontLigatures = class extends BaseEditorOption {
  constructor() {
    super(37, "fontLigatures", EditorFontLigatures.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: localize("fontLigatures", "Enables/Disables font ligatures.")
        },
        {
          type: "string",
          description: localize("fontFeatureSettings", "Explicit font-feature-settings.")
        }
      ],
      description: localize("fontLigaturesGeneral", "Configures font ligatures or font features."),
      default: false
    });
  }
  validate(input) {
    if (typeof input === "undefined") {
      return this.defaultValue;
    }
    if (typeof input === "string") {
      if (input === "false") {
        return EditorFontLigatures.OFF;
      }
      if (input === "true") {
        return EditorFontLigatures.ON;
      }
      return input;
    }
    if (Boolean(input)) {
      return EditorFontLigatures.ON;
    }
    return EditorFontLigatures.OFF;
  }
};
EditorFontLigatures.OFF = '"liga" off, "calt" off';
EditorFontLigatures.ON = '"liga" on, "calt" on';
var EditorFontInfo = class extends ComputedEditorOption {
  constructor() {
    super(36);
  }
  compute(env2, options, _) {
    return env2.fontInfo;
  }
};
var EditorFontSize = class extends SimpleEditorOption {
  constructor() {
    super(38, "fontSize", EDITOR_FONT_DEFAULTS.fontSize, {
      type: "number",
      minimum: 6,
      maximum: 100,
      default: EDITOR_FONT_DEFAULTS.fontSize,
      description: localize("fontSize", "Controls the font size in pixels.")
    });
  }
  validate(input) {
    let r = EditorFloatOption.float(input, this.defaultValue);
    if (r === 0) {
      return EDITOR_FONT_DEFAULTS.fontSize;
    }
    return EditorFloatOption.clamp(r, 6, 100);
  }
  compute(env2, options, value) {
    return env2.fontInfo.fontSize;
  }
};
var EditorFontWeight = class extends BaseEditorOption {
  constructor() {
    super(39, "fontWeight", EDITOR_FONT_DEFAULTS.fontWeight, {
      anyOf: [
        {
          type: "number",
          minimum: EditorFontWeight.MINIMUM_VALUE,
          maximum: EditorFontWeight.MAXIMUM_VALUE,
          errorMessage: localize("fontWeightErrorMessage", 'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.')
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: EditorFontWeight.SUGGESTION_VALUES
        }
      ],
      default: EDITOR_FONT_DEFAULTS.fontWeight,
      description: localize("fontWeight", 'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.')
    });
  }
  validate(input) {
    if (input === "normal" || input === "bold") {
      return input;
    }
    return String(EditorIntOption.clampedInt(input, EDITOR_FONT_DEFAULTS.fontWeight, EditorFontWeight.MINIMUM_VALUE, EditorFontWeight.MAXIMUM_VALUE));
  }
};
EditorFontWeight.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
EditorFontWeight.MINIMUM_VALUE = 1;
EditorFontWeight.MAXIMUM_VALUE = 1e3;
var EditorGoToLocation = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      multiple: "peek",
      multipleDefinitions: "peek",
      multipleTypeDefinitions: "peek",
      multipleDeclarations: "peek",
      multipleImplementations: "peek",
      multipleReferences: "peek",
      alternativeDefinitionCommand: "editor.action.goToReferences",
      alternativeTypeDefinitionCommand: "editor.action.goToReferences",
      alternativeDeclarationCommand: "editor.action.goToReferences",
      alternativeImplementationCommand: "",
      alternativeReferenceCommand: ""
    };
    const jsonSubset = {
      type: "string",
      enum: ["peek", "gotoAndPeek", "goto"],
      default: defaults.multiple,
      enumDescriptions: [
        localize("editor.gotoLocation.multiple.peek", "Show peek view of the results (default)"),
        localize("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a peek view"),
        localize("editor.gotoLocation.multiple.goto", "Go to the primary result and enable peek-less navigation to others")
      ]
    };
    super(43, "gotoLocation", defaults, {
      "editor.gotoLocation.multiple": {
        deprecationMessage: localize("editor.gotoLocation.multiple.deprecated", "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.")
      },
      "editor.gotoLocation.multipleDefinitions": Object.assign({description: localize("editor.editor.gotoLocation.multipleDefinitions", "Controls the behavior the 'Go to Definition'-command when multiple target locations exist.")}, jsonSubset),
      "editor.gotoLocation.multipleTypeDefinitions": Object.assign({description: localize("editor.editor.gotoLocation.multipleTypeDefinitions", "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.")}, jsonSubset),
      "editor.gotoLocation.multipleDeclarations": Object.assign({description: localize("editor.editor.gotoLocation.multipleDeclarations", "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.")}, jsonSubset),
      "editor.gotoLocation.multipleImplementations": Object.assign({description: localize("editor.editor.gotoLocation.multipleImplemenattions", "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.")}, jsonSubset),
      "editor.gotoLocation.multipleReferences": Object.assign({description: localize("editor.editor.gotoLocation.multipleReferences", "Controls the behavior the 'Go to References'-command when multiple target locations exist.")}, jsonSubset),
      "editor.gotoLocation.alternativeDefinitionCommand": {
        type: "string",
        default: defaults.alternativeDefinitionCommand,
        description: localize("alternativeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeTypeDefinitionCommand": {
        type: "string",
        default: defaults.alternativeTypeDefinitionCommand,
        description: localize("alternativeTypeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeDeclarationCommand": {
        type: "string",
        default: defaults.alternativeDeclarationCommand,
        description: localize("alternativeDeclarationCommand", "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
      },
      "editor.gotoLocation.alternativeImplementationCommand": {
        type: "string",
        default: defaults.alternativeImplementationCommand,
        description: localize("alternativeImplementationCommand", "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
      },
      "editor.gotoLocation.alternativeReferenceCommand": {
        type: "string",
        default: defaults.alternativeReferenceCommand,
        description: localize("alternativeReferenceCommand", "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
      }
    });
  }
  validate(_input) {
    var _a, _b, _c, _d, _e;
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      multiple: EditorStringEnumOption.stringSet(input.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
      multipleDefinitions: (_a = input.multipleDefinitions) !== null && _a !== void 0 ? _a : EditorStringEnumOption.stringSet(input.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTypeDefinitions: (_b = input.multipleTypeDefinitions) !== null && _b !== void 0 ? _b : EditorStringEnumOption.stringSet(input.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleDeclarations: (_c = input.multipleDeclarations) !== null && _c !== void 0 ? _c : EditorStringEnumOption.stringSet(input.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleImplementations: (_d = input.multipleImplementations) !== null && _d !== void 0 ? _d : EditorStringEnumOption.stringSet(input.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleReferences: (_e = input.multipleReferences) !== null && _e !== void 0 ? _e : EditorStringEnumOption.stringSet(input.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
      alternativeDefinitionCommand: EditorStringOption.string(input.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
      alternativeTypeDefinitionCommand: EditorStringOption.string(input.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
      alternativeDeclarationCommand: EditorStringOption.string(input.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
      alternativeImplementationCommand: EditorStringOption.string(input.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
      alternativeReferenceCommand: EditorStringOption.string(input.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand)
    };
  }
};
var EditorHover = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: true,
      delay: 300,
      sticky: true
    };
    super(46, "hover", defaults, {
      "editor.hover.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize("hover.enabled", "Controls whether the hover is shown.")
      },
      "editor.hover.delay": {
        type: "number",
        default: defaults.delay,
        description: localize("hover.delay", "Controls the delay in milliseconds after which the hover is shown.")
      },
      "editor.hover.sticky": {
        type: "boolean",
        default: defaults.sticky,
        description: localize("hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: EditorBooleanOption.boolean(input.enabled, this.defaultValue.enabled),
      delay: EditorIntOption.clampedInt(input.delay, this.defaultValue.delay, 0, 1e4),
      sticky: EditorBooleanOption.boolean(input.sticky, this.defaultValue.sticky)
    };
  }
};
var EditorLayoutInfoComputer = class extends ComputedEditorOption {
  constructor() {
    super(117, [
      42,
      50,
      31,
      56,
      84,
      52,
      53,
      86,
      106,
      109,
      110,
      2
    ]);
  }
  compute(env2, options, _) {
    return EditorLayoutInfoComputer.computeLayout(options, {
      memory: env2.memory,
      outerWidth: env2.outerWidth,
      outerHeight: env2.outerHeight,
      isDominatedByLongLines: env2.isDominatedByLongLines,
      lineHeight: env2.fontInfo.lineHeight,
      viewLineCount: env2.viewLineCount,
      lineNumbersDigitCount: env2.lineNumbersDigitCount,
      typicalHalfwidthCharacterWidth: env2.fontInfo.typicalHalfwidthCharacterWidth,
      maxDigitWidth: env2.fontInfo.maxDigitWidth,
      pixelRatio: env2.pixelRatio
    });
  }
  static computeContainedMinimapLineCount(input) {
    const typicalViewportLineCount = input.height / input.lineHeight;
    const extraLinesBeyondLastLine = input.scrollBeyondLastLine ? typicalViewportLineCount - 1 : 0;
    const desiredRatio = (input.viewLineCount + extraLinesBeyondLastLine) / (input.pixelRatio * input.height);
    const minimapLineCount = Math.floor(input.viewLineCount / desiredRatio);
    return {typicalViewportLineCount, extraLinesBeyondLastLine, desiredRatio, minimapLineCount};
  }
  static _computeMinimapLayout(input, memory) {
    const outerWidth = input.outerWidth;
    const outerHeight = input.outerHeight;
    const pixelRatio = input.pixelRatio;
    if (!input.minimap.enabled) {
      return {
        renderMinimap: 0,
        minimapLeft: 0,
        minimapWidth: 0,
        minimapHeightIsEditorHeight: false,
        minimapIsSampling: false,
        minimapScale: 1,
        minimapLineHeight: 1,
        minimapCanvasInnerWidth: 0,
        minimapCanvasInnerHeight: Math.floor(pixelRatio * outerHeight),
        minimapCanvasOuterWidth: 0,
        minimapCanvasOuterHeight: outerHeight
      };
    }
    const stableMinimapLayoutInput = memory.stableMinimapLayoutInput;
    const couldUseMemory = stableMinimapLayoutInput && input.outerHeight === stableMinimapLayoutInput.outerHeight && input.lineHeight === stableMinimapLayoutInput.lineHeight && input.typicalHalfwidthCharacterWidth === stableMinimapLayoutInput.typicalHalfwidthCharacterWidth && input.pixelRatio === stableMinimapLayoutInput.pixelRatio && input.scrollBeyondLastLine === stableMinimapLayoutInput.scrollBeyondLastLine && input.minimap.enabled === stableMinimapLayoutInput.minimap.enabled && input.minimap.side === stableMinimapLayoutInput.minimap.side && input.minimap.size === stableMinimapLayoutInput.minimap.size && input.minimap.showSlider === stableMinimapLayoutInput.minimap.showSlider && input.minimap.renderCharacters === stableMinimapLayoutInput.minimap.renderCharacters && input.minimap.maxColumn === stableMinimapLayoutInput.minimap.maxColumn && input.minimap.scale === stableMinimapLayoutInput.minimap.scale && input.verticalScrollbarWidth === stableMinimapLayoutInput.verticalScrollbarWidth && input.isViewportWrapping === stableMinimapLayoutInput.isViewportWrapping;
    const lineHeight = input.lineHeight;
    const typicalHalfwidthCharacterWidth = input.typicalHalfwidthCharacterWidth;
    const scrollBeyondLastLine = input.scrollBeyondLastLine;
    const minimapRenderCharacters = input.minimap.renderCharacters;
    let minimapScale = pixelRatio >= 2 ? Math.round(input.minimap.scale * 2) : input.minimap.scale;
    const minimapMaxColumn = input.minimap.maxColumn;
    const minimapSize = input.minimap.size;
    const minimapSide = input.minimap.side;
    const verticalScrollbarWidth = input.verticalScrollbarWidth;
    const viewLineCount = input.viewLineCount;
    const remainingWidth = input.remainingWidth;
    const isViewportWrapping = input.isViewportWrapping;
    const baseCharHeight = minimapRenderCharacters ? 2 : 3;
    let minimapCanvasInnerHeight = Math.floor(pixelRatio * outerHeight);
    const minimapCanvasOuterHeight = minimapCanvasInnerHeight / pixelRatio;
    let minimapHeightIsEditorHeight = false;
    let minimapIsSampling = false;
    let minimapLineHeight = baseCharHeight * minimapScale;
    let minimapCharWidth = minimapScale / pixelRatio;
    let minimapWidthMultiplier = 1;
    if (minimapSize === "fill" || minimapSize === "fit") {
      const {typicalViewportLineCount, extraLinesBeyondLastLine, desiredRatio, minimapLineCount} = EditorLayoutInfoComputer.computeContainedMinimapLineCount({
        viewLineCount,
        scrollBeyondLastLine,
        height: outerHeight,
        lineHeight,
        pixelRatio
      });
      const ratio = viewLineCount / minimapLineCount;
      if (ratio > 1) {
        minimapHeightIsEditorHeight = true;
        minimapIsSampling = true;
        minimapScale = 1;
        minimapLineHeight = 1;
        minimapCharWidth = minimapScale / pixelRatio;
      } else {
        let fitBecomesFill = false;
        let maxMinimapScale = minimapScale + 1;
        if (minimapSize === "fit") {
          const effectiveMinimapHeight = Math.ceil((viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);
          if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {
            fitBecomesFill = true;
            maxMinimapScale = memory.stableFitMaxMinimapScale;
          } else {
            fitBecomesFill = effectiveMinimapHeight > minimapCanvasInnerHeight;
            if (isViewportWrapping && fitBecomesFill) {
              memory.stableMinimapLayoutInput = input;
              memory.stableFitRemainingWidth = remainingWidth;
            } else {
              memory.stableMinimapLayoutInput = null;
              memory.stableFitRemainingWidth = 0;
            }
          }
        }
        if (minimapSize === "fill" || fitBecomesFill) {
          minimapHeightIsEditorHeight = true;
          const configuredMinimapScale = minimapScale;
          minimapLineHeight = Math.min(lineHeight * pixelRatio, Math.max(1, Math.floor(1 / desiredRatio)));
          minimapScale = Math.min(maxMinimapScale, Math.max(1, Math.floor(minimapLineHeight / baseCharHeight)));
          if (minimapScale > configuredMinimapScale) {
            minimapWidthMultiplier = Math.min(2, minimapScale / configuredMinimapScale);
          }
          minimapCharWidth = minimapScale / pixelRatio / minimapWidthMultiplier;
          minimapCanvasInnerHeight = Math.ceil(Math.max(typicalViewportLineCount, viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);
          if (isViewportWrapping && fitBecomesFill) {
            memory.stableFitMaxMinimapScale = minimapScale;
          }
        }
      }
    }
    const minimapMaxWidth = Math.floor(minimapMaxColumn * minimapCharWidth);
    const minimapWidth = Math.min(minimapMaxWidth, Math.max(0, Math.floor((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth / (typicalHalfwidthCharacterWidth + minimapCharWidth))) + MINIMAP_GUTTER_WIDTH);
    let minimapCanvasInnerWidth = Math.floor(pixelRatio * minimapWidth);
    const minimapCanvasOuterWidth = minimapCanvasInnerWidth / pixelRatio;
    minimapCanvasInnerWidth = Math.floor(minimapCanvasInnerWidth * minimapWidthMultiplier);
    const renderMinimap = minimapRenderCharacters ? 1 : 2;
    const minimapLeft = minimapSide === "left" ? 0 : outerWidth - minimapWidth - verticalScrollbarWidth;
    return {
      renderMinimap,
      minimapLeft,
      minimapWidth,
      minimapHeightIsEditorHeight,
      minimapIsSampling,
      minimapScale,
      minimapLineHeight,
      minimapCanvasInnerWidth,
      minimapCanvasInnerHeight,
      minimapCanvasOuterWidth,
      minimapCanvasOuterHeight
    };
  }
  static computeLayout(options, env2) {
    const outerWidth = env2.outerWidth | 0;
    const outerHeight = env2.outerHeight | 0;
    const lineHeight = env2.lineHeight | 0;
    const lineNumbersDigitCount = env2.lineNumbersDigitCount | 0;
    const typicalHalfwidthCharacterWidth = env2.typicalHalfwidthCharacterWidth;
    const maxDigitWidth = env2.maxDigitWidth;
    const pixelRatio = env2.pixelRatio;
    const viewLineCount = env2.viewLineCount;
    const wordWrap = options.get(106);
    const wordWrapColumn = options.get(109);
    const wordWrapMinified = options.get(110);
    const accessibilitySupport = options.get(2);
    const isDominatedByLongLines = env2.isDominatedByLongLines;
    const showGlyphMargin = options.get(42);
    const showLineNumbers = options.get(52).renderType !== 0;
    const lineNumbersMinChars = options.get(53);
    const scrollBeyondLastLine = options.get(86);
    const minimap = options.get(56);
    const scrollbar = options.get(84);
    const verticalScrollbarWidth = scrollbar.verticalScrollbarSize;
    const verticalScrollbarHasArrows = scrollbar.verticalHasArrows;
    const scrollbarArrowSize = scrollbar.arrowSize;
    const horizontalScrollbarHeight = scrollbar.horizontalScrollbarSize;
    const rawLineDecorationsWidth = options.get(50);
    const folding = options.get(31);
    let lineDecorationsWidth;
    if (typeof rawLineDecorationsWidth === "string" && /^\d+(\.\d+)?ch$/.test(rawLineDecorationsWidth)) {
      const multiple = parseFloat(rawLineDecorationsWidth.substr(0, rawLineDecorationsWidth.length - 2));
      lineDecorationsWidth = EditorIntOption.clampedInt(multiple * typicalHalfwidthCharacterWidth, 0, 0, 1e3);
    } else {
      lineDecorationsWidth = EditorIntOption.clampedInt(rawLineDecorationsWidth, 0, 0, 1e3);
    }
    if (folding) {
      lineDecorationsWidth += 16;
    }
    let lineNumbersWidth = 0;
    if (showLineNumbers) {
      const digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);
      lineNumbersWidth = Math.round(digitCount * maxDigitWidth);
    }
    let glyphMarginWidth = 0;
    if (showGlyphMargin) {
      glyphMarginWidth = lineHeight;
    }
    let glyphMarginLeft = 0;
    let lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;
    let decorationsLeft = lineNumbersLeft + lineNumbersWidth;
    let contentLeft = decorationsLeft + lineDecorationsWidth;
    const remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;
    let isWordWrapMinified = false;
    let isViewportWrapping = false;
    let wrappingColumn = -1;
    if (accessibilitySupport !== 2) {
      if (wordWrapMinified && isDominatedByLongLines) {
        isWordWrapMinified = true;
        isViewportWrapping = true;
      } else if (wordWrap === "on" || wordWrap === "bounded") {
        isViewportWrapping = true;
      } else if (wordWrap === "wordWrapColumn") {
        wrappingColumn = wordWrapColumn;
      }
    }
    const minimapLayout = EditorLayoutInfoComputer._computeMinimapLayout({
      outerWidth,
      outerHeight,
      lineHeight,
      typicalHalfwidthCharacterWidth,
      pixelRatio,
      scrollBeyondLastLine,
      minimap,
      verticalScrollbarWidth,
      viewLineCount,
      remainingWidth,
      isViewportWrapping
    }, env2.memory || new ComputeOptionsMemory());
    if (minimapLayout.renderMinimap !== 0 && minimapLayout.minimapLeft === 0) {
      glyphMarginLeft += minimapLayout.minimapWidth;
      lineNumbersLeft += minimapLayout.minimapWidth;
      decorationsLeft += minimapLayout.minimapWidth;
      contentLeft += minimapLayout.minimapWidth;
    }
    const contentWidth = remainingWidth - minimapLayout.minimapWidth;
    const viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));
    const verticalArrowSize = verticalScrollbarHasArrows ? scrollbarArrowSize : 0;
    if (isViewportWrapping) {
      wrappingColumn = Math.max(1, viewportColumn);
      if (wordWrap === "bounded") {
        wrappingColumn = Math.min(wrappingColumn, wordWrapColumn);
      }
    }
    return {
      width: outerWidth,
      height: outerHeight,
      glyphMarginLeft,
      glyphMarginWidth,
      lineNumbersLeft,
      lineNumbersWidth,
      decorationsLeft,
      decorationsWidth: lineDecorationsWidth,
      contentLeft,
      contentWidth,
      minimap: minimapLayout,
      viewportColumn,
      isWordWrapMinified,
      isViewportWrapping,
      wrappingColumn,
      verticalScrollbarWidth,
      horizontalScrollbarHeight,
      overviewRuler: {
        top: verticalArrowSize,
        width: verticalScrollbarWidth,
        height: outerHeight - 2 * verticalArrowSize,
        right: 0
      }
    };
  }
};
var EditorLightbulb = class extends BaseEditorOption {
  constructor() {
    const defaults = {enabled: true};
    super(49, "lightbulb", defaults, {
      "editor.lightbulb.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize("codeActions", "Enables the code action lightbulb in the editor.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: EditorBooleanOption.boolean(input.enabled, this.defaultValue.enabled)
    };
  }
};
var EditorLineHeight = class extends EditorIntOption {
  constructor() {
    super(51, "lineHeight", EDITOR_FONT_DEFAULTS.lineHeight, 0, 150, {description: localize("lineHeight", "Controls the line height. Use 0 to compute the line height from the font size.")});
  }
  compute(env2, options, value) {
    return env2.fontInfo.lineHeight;
  }
};
var EditorMinimap = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: true,
      size: "proportional",
      side: "right",
      showSlider: "mouseover",
      renderCharacters: true,
      maxColumn: 120,
      scale: 1
    };
    super(56, "minimap", defaults, {
      "editor.minimap.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize("minimap.enabled", "Controls whether the minimap is shown.")
      },
      "editor.minimap.size": {
        type: "string",
        enum: ["proportional", "fill", "fit"],
        enumDescriptions: [
          localize("minimap.size.proportional", "The minimap has the same size as the editor contents (and might scroll)."),
          localize("minimap.size.fill", "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
          localize("minimap.size.fit", "The minimap will shrink as necessary to never be larger than the editor (no scrolling).")
        ],
        default: defaults.size,
        description: localize("minimap.size", "Controls the size of the minimap.")
      },
      "editor.minimap.side": {
        type: "string",
        enum: ["left", "right"],
        default: defaults.side,
        description: localize("minimap.side", "Controls the side where to render the minimap.")
      },
      "editor.minimap.showSlider": {
        type: "string",
        enum: ["always", "mouseover"],
        default: defaults.showSlider,
        description: localize("minimap.showSlider", "Controls when the minimap slider is shown.")
      },
      "editor.minimap.scale": {
        type: "number",
        default: defaults.scale,
        minimum: 1,
        maximum: 3,
        enum: [1, 2, 3],
        description: localize("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3.")
      },
      "editor.minimap.renderCharacters": {
        type: "boolean",
        default: defaults.renderCharacters,
        description: localize("minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks.")
      },
      "editor.minimap.maxColumn": {
        type: "number",
        default: defaults.maxColumn,
        description: localize("minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: EditorBooleanOption.boolean(input.enabled, this.defaultValue.enabled),
      size: EditorStringEnumOption.stringSet(input.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
      side: EditorStringEnumOption.stringSet(input.side, this.defaultValue.side, ["right", "left"]),
      showSlider: EditorStringEnumOption.stringSet(input.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
      renderCharacters: EditorBooleanOption.boolean(input.renderCharacters, this.defaultValue.renderCharacters),
      scale: EditorIntOption.clampedInt(input.scale, 1, 1, 3),
      maxColumn: EditorIntOption.clampedInt(input.maxColumn, this.defaultValue.maxColumn, 1, 1e4)
    };
  }
};
function _multiCursorModifierFromString(multiCursorModifier) {
  if (multiCursorModifier === "ctrlCmd") {
    return isMacintosh ? "metaKey" : "ctrlKey";
  }
  return "altKey";
}
var EditorPadding = class extends BaseEditorOption {
  constructor() {
    super(66, "padding", {top: 0, bottom: 0}, {
      "editor.padding.top": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: localize("padding.top", "Controls the amount of space between the top edge of the editor and the first line.")
      },
      "editor.padding.bottom": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: localize("padding.bottom", "Controls the amount of space between the bottom edge of the editor and the last line.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      top: EditorIntOption.clampedInt(input.top, 0, 0, 1e3),
      bottom: EditorIntOption.clampedInt(input.bottom, 0, 0, 1e3)
    };
  }
};
var EditorParameterHints = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: true,
      cycle: false
    };
    super(67, "parameterHints", defaults, {
      "editor.parameterHints.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize("parameterHints.enabled", "Enables a pop-up that shows parameter documentation and type information as you type.")
      },
      "editor.parameterHints.cycle": {
        type: "boolean",
        default: defaults.cycle,
        description: localize("parameterHints.cycle", "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: EditorBooleanOption.boolean(input.enabled, this.defaultValue.enabled),
      cycle: EditorBooleanOption.boolean(input.cycle, this.defaultValue.cycle)
    };
  }
};
var EditorPixelRatio = class extends ComputedEditorOption {
  constructor() {
    super(115);
  }
  compute(env2, options, _) {
    return env2.pixelRatio;
  }
};
var EditorQuickSuggestions = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      other: true,
      comments: false,
      strings: false
    };
    super(70, "quickSuggestions", defaults, {
      anyOf: [
        {
          type: "boolean"
        },
        {
          type: "object",
          properties: {
            strings: {
              type: "boolean",
              default: defaults.strings,
              description: localize("quickSuggestions.strings", "Enable quick suggestions inside strings.")
            },
            comments: {
              type: "boolean",
              default: defaults.comments,
              description: localize("quickSuggestions.comments", "Enable quick suggestions inside comments.")
            },
            other: {
              type: "boolean",
              default: defaults.other,
              description: localize("quickSuggestions.other", "Enable quick suggestions outside of strings and comments.")
            }
          }
        }
      ],
      default: defaults,
      description: localize("quickSuggestions", "Controls whether suggestions should automatically show up while typing.")
    });
    this.defaultValue = defaults;
  }
  validate(_input) {
    if (typeof _input === "boolean") {
      return _input;
    }
    if (_input && typeof _input === "object") {
      const input = _input;
      const opts = {
        other: EditorBooleanOption.boolean(input.other, this.defaultValue.other),
        comments: EditorBooleanOption.boolean(input.comments, this.defaultValue.comments),
        strings: EditorBooleanOption.boolean(input.strings, this.defaultValue.strings)
      };
      if (opts.other && opts.comments && opts.strings) {
        return true;
      } else if (!opts.other && !opts.comments && !opts.strings) {
        return false;
      } else {
        return opts;
      }
    }
    return this.defaultValue;
  }
};
var EditorRenderLineNumbersOption = class extends BaseEditorOption {
  constructor() {
    super(52, "lineNumbers", {renderType: 1, renderFn: null}, {
      type: "string",
      enum: ["off", "on", "relative", "interval"],
      enumDescriptions: [
        localize("lineNumbers.off", "Line numbers are not rendered."),
        localize("lineNumbers.on", "Line numbers are rendered as absolute number."),
        localize("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
        localize("lineNumbers.interval", "Line numbers are rendered every 10 lines.")
      ],
      default: "on",
      description: localize("lineNumbers", "Controls the display of line numbers.")
    });
  }
  validate(lineNumbers) {
    let renderType = this.defaultValue.renderType;
    let renderFn = this.defaultValue.renderFn;
    if (typeof lineNumbers !== "undefined") {
      if (typeof lineNumbers === "function") {
        renderType = 4;
        renderFn = lineNumbers;
      } else if (lineNumbers === "interval") {
        renderType = 3;
      } else if (lineNumbers === "relative") {
        renderType = 2;
      } else if (lineNumbers === "on") {
        renderType = 1;
      } else {
        renderType = 0;
      }
    }
    return {
      renderType,
      renderFn
    };
  }
};
function filterValidationDecorations(options) {
  const renderValidationDecorations = options.get(79);
  if (renderValidationDecorations === "editable") {
    return options.get(72);
  }
  return renderValidationDecorations === "on" ? false : true;
}
var EditorRulers = class extends BaseEditorOption {
  constructor() {
    const defaults = [];
    const columnSchema = {type: "number", description: localize("rulers.size", "Number of monospace characters at which this editor ruler will render.")};
    super(83, "rulers", defaults, {
      type: "array",
      items: {
        anyOf: [
          columnSchema,
          {
            type: [
              "object"
            ],
            properties: {
              column: columnSchema,
              color: {
                type: "string",
                description: localize("rulers.color", "Color of this editor ruler."),
                format: "color-hex"
              }
            }
          }
        ]
      },
      default: defaults,
      description: localize("rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
    });
  }
  validate(input) {
    if (Array.isArray(input)) {
      let rulers = [];
      for (let _element of input) {
        if (typeof _element === "number") {
          rulers.push({
            column: EditorIntOption.clampedInt(_element, 0, 0, 1e4),
            color: null
          });
        } else if (_element && typeof _element === "object") {
          const element = _element;
          rulers.push({
            column: EditorIntOption.clampedInt(element.column, 0, 0, 1e4),
            color: element.color
          });
        }
      }
      rulers.sort((a, b) => a.column - b.column);
      return rulers;
    }
    return this.defaultValue;
  }
};
function _scrollbarVisibilityFromString(visibility, defaultValue) {
  if (typeof visibility !== "string") {
    return defaultValue;
  }
  switch (visibility) {
    case "hidden":
      return 2;
    case "visible":
      return 3;
    default:
      return 1;
  }
}
var EditorScrollbar = class extends BaseEditorOption {
  constructor() {
    super(84, "scrollbar", {
      vertical: 1,
      horizontal: 1,
      arrowSize: 11,
      useShadows: true,
      verticalHasArrows: false,
      horizontalHasArrows: false,
      horizontalScrollbarSize: 12,
      horizontalSliderSize: 12,
      verticalScrollbarSize: 14,
      verticalSliderSize: 14,
      handleMouseWheel: true,
      alwaysConsumeMouseWheel: true
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    const horizontalScrollbarSize = EditorIntOption.clampedInt(input.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3);
    const verticalScrollbarSize = EditorIntOption.clampedInt(input.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
    return {
      arrowSize: EditorIntOption.clampedInt(input.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
      vertical: _scrollbarVisibilityFromString(input.vertical, this.defaultValue.vertical),
      horizontal: _scrollbarVisibilityFromString(input.horizontal, this.defaultValue.horizontal),
      useShadows: EditorBooleanOption.boolean(input.useShadows, this.defaultValue.useShadows),
      verticalHasArrows: EditorBooleanOption.boolean(input.verticalHasArrows, this.defaultValue.verticalHasArrows),
      horizontalHasArrows: EditorBooleanOption.boolean(input.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
      handleMouseWheel: EditorBooleanOption.boolean(input.handleMouseWheel, this.defaultValue.handleMouseWheel),
      alwaysConsumeMouseWheel: EditorBooleanOption.boolean(input.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
      horizontalScrollbarSize,
      horizontalSliderSize: EditorIntOption.clampedInt(input.horizontalSliderSize, horizontalScrollbarSize, 0, 1e3),
      verticalScrollbarSize,
      verticalSliderSize: EditorIntOption.clampedInt(input.verticalSliderSize, verticalScrollbarSize, 0, 1e3)
    };
  }
};
var EditorSuggest = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      insertMode: "insert",
      filterGraceful: true,
      snippetsPreventQuickSuggestions: true,
      localityBonus: false,
      shareSuggestSelections: false,
      showIcons: true,
      maxVisibleSuggestions: 12,
      showMethods: true,
      showFunctions: true,
      showConstructors: true,
      showFields: true,
      showVariables: true,
      showClasses: true,
      showStructs: true,
      showInterfaces: true,
      showModules: true,
      showProperties: true,
      showEvents: true,
      showOperators: true,
      showUnits: true,
      showValues: true,
      showConstants: true,
      showEnums: true,
      showEnumMembers: true,
      showKeywords: true,
      showWords: true,
      showColors: true,
      showFiles: true,
      showReferences: true,
      showFolders: true,
      showTypeParameters: true,
      showSnippets: true,
      showUsers: true,
      showIssues: true,
      statusBar: {
        visible: false
      }
    };
    super(96, "suggest", defaults, {
      "editor.suggest.insertMode": {
        type: "string",
        enum: ["insert", "replace"],
        enumDescriptions: [
          localize("suggest.insertMode.insert", "Insert suggestion without overwriting text right of the cursor."),
          localize("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor.")
        ],
        default: defaults.insertMode,
        description: localize("suggest.insertMode", "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
      },
      "editor.suggest.filterGraceful": {
        type: "boolean",
        default: defaults.filterGraceful,
        description: localize("suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos.")
      },
      "editor.suggest.localityBonus": {
        type: "boolean",
        default: defaults.localityBonus,
        description: localize("suggest.localityBonus", "Controls whether sorting favours words that appear close to the cursor.")
      },
      "editor.suggest.shareSuggestSelections": {
        type: "boolean",
        default: defaults.shareSuggestSelections,
        markdownDescription: localize("suggest.shareSuggestSelections", "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
      },
      "editor.suggest.snippetsPreventQuickSuggestions": {
        type: "boolean",
        default: defaults.snippetsPreventQuickSuggestions,
        description: localize("suggest.snippetsPreventQuickSuggestions", "Controls whether an active snippet prevents quick suggestions.")
      },
      "editor.suggest.showIcons": {
        type: "boolean",
        default: defaults.showIcons,
        description: localize("suggest.showIcons", "Controls whether to show or hide icons in suggestions.")
      },
      "editor.suggest.maxVisibleSuggestions": {
        type: "number",
        default: defaults.maxVisibleSuggestions,
        minimum: 1,
        maximum: 15,
        description: localize("suggest.maxVisibleSuggestions", "Controls how many suggestions IntelliSense will show before showing a scrollbar (maximum 15).")
      },
      "editor.suggest.filteredTypes": {
        type: "object",
        deprecationMessage: localize("deprecated", "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
      },
      "editor.suggest.showMethods": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showMethods", "When enabled IntelliSense shows `method`-suggestions.")
      },
      "editor.suggest.showFunctions": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showFunctions", "When enabled IntelliSense shows `function`-suggestions.")
      },
      "editor.suggest.showConstructors": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showConstructors", "When enabled IntelliSense shows `constructor`-suggestions.")
      },
      "editor.suggest.showFields": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showFields", "When enabled IntelliSense shows `field`-suggestions.")
      },
      "editor.suggest.showVariables": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showVariables", "When enabled IntelliSense shows `variable`-suggestions.")
      },
      "editor.suggest.showClasses": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showClasss", "When enabled IntelliSense shows `class`-suggestions.")
      },
      "editor.suggest.showStructs": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showStructs", "When enabled IntelliSense shows `struct`-suggestions.")
      },
      "editor.suggest.showInterfaces": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showInterfaces", "When enabled IntelliSense shows `interface`-suggestions.")
      },
      "editor.suggest.showModules": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showModules", "When enabled IntelliSense shows `module`-suggestions.")
      },
      "editor.suggest.showProperties": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showPropertys", "When enabled IntelliSense shows `property`-suggestions.")
      },
      "editor.suggest.showEvents": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showEvents", "When enabled IntelliSense shows `event`-suggestions.")
      },
      "editor.suggest.showOperators": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showOperators", "When enabled IntelliSense shows `operator`-suggestions.")
      },
      "editor.suggest.showUnits": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showUnits", "When enabled IntelliSense shows `unit`-suggestions.")
      },
      "editor.suggest.showValues": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showValues", "When enabled IntelliSense shows `value`-suggestions.")
      },
      "editor.suggest.showConstants": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showConstants", "When enabled IntelliSense shows `constant`-suggestions.")
      },
      "editor.suggest.showEnums": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showEnums", "When enabled IntelliSense shows `enum`-suggestions.")
      },
      "editor.suggest.showEnumMembers": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showEnumMembers", "When enabled IntelliSense shows `enumMember`-suggestions.")
      },
      "editor.suggest.showKeywords": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showKeywords", "When enabled IntelliSense shows `keyword`-suggestions.")
      },
      "editor.suggest.showWords": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showTexts", "When enabled IntelliSense shows `text`-suggestions.")
      },
      "editor.suggest.showColors": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showColors", "When enabled IntelliSense shows `color`-suggestions.")
      },
      "editor.suggest.showFiles": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showFiles", "When enabled IntelliSense shows `file`-suggestions.")
      },
      "editor.suggest.showReferences": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showReferences", "When enabled IntelliSense shows `reference`-suggestions.")
      },
      "editor.suggest.showCustomcolors": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showCustomcolors", "When enabled IntelliSense shows `customcolor`-suggestions.")
      },
      "editor.suggest.showFolders": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showFolders", "When enabled IntelliSense shows `folder`-suggestions.")
      },
      "editor.suggest.showTypeParameters": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showTypeParameters", "When enabled IntelliSense shows `typeParameter`-suggestions.")
      },
      "editor.suggest.showSnippets": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showSnippets", "When enabled IntelliSense shows `snippet`-suggestions.")
      },
      "editor.suggest.showUsers": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showUsers", "When enabled IntelliSense shows `user`-suggestions.")
      },
      "editor.suggest.showIssues": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showIssues", "When enabled IntelliSense shows `issues`-suggestions.")
      },
      "editor.suggest.statusBar.visible": {
        type: "boolean",
        default: false,
        markdownDescription: localize("editor.suggest.statusBar.visible", "Controls the visibility of the status bar at the bottom of the suggest widget.")
      }
    });
  }
  validate(_input) {
    var _a;
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      insertMode: EditorStringEnumOption.stringSet(input.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
      filterGraceful: EditorBooleanOption.boolean(input.filterGraceful, this.defaultValue.filterGraceful),
      snippetsPreventQuickSuggestions: EditorBooleanOption.boolean(input.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
      localityBonus: EditorBooleanOption.boolean(input.localityBonus, this.defaultValue.localityBonus),
      shareSuggestSelections: EditorBooleanOption.boolean(input.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
      showIcons: EditorBooleanOption.boolean(input.showIcons, this.defaultValue.showIcons),
      maxVisibleSuggestions: EditorIntOption.clampedInt(input.maxVisibleSuggestions, this.defaultValue.maxVisibleSuggestions, 1, 15),
      showMethods: EditorBooleanOption.boolean(input.showMethods, this.defaultValue.showMethods),
      showFunctions: EditorBooleanOption.boolean(input.showFunctions, this.defaultValue.showFunctions),
      showConstructors: EditorBooleanOption.boolean(input.showConstructors, this.defaultValue.showConstructors),
      showFields: EditorBooleanOption.boolean(input.showFields, this.defaultValue.showFields),
      showVariables: EditorBooleanOption.boolean(input.showVariables, this.defaultValue.showVariables),
      showClasses: EditorBooleanOption.boolean(input.showClasses, this.defaultValue.showClasses),
      showStructs: EditorBooleanOption.boolean(input.showStructs, this.defaultValue.showStructs),
      showInterfaces: EditorBooleanOption.boolean(input.showInterfaces, this.defaultValue.showInterfaces),
      showModules: EditorBooleanOption.boolean(input.showModules, this.defaultValue.showModules),
      showProperties: EditorBooleanOption.boolean(input.showProperties, this.defaultValue.showProperties),
      showEvents: EditorBooleanOption.boolean(input.showEvents, this.defaultValue.showEvents),
      showOperators: EditorBooleanOption.boolean(input.showOperators, this.defaultValue.showOperators),
      showUnits: EditorBooleanOption.boolean(input.showUnits, this.defaultValue.showUnits),
      showValues: EditorBooleanOption.boolean(input.showValues, this.defaultValue.showValues),
      showConstants: EditorBooleanOption.boolean(input.showConstants, this.defaultValue.showConstants),
      showEnums: EditorBooleanOption.boolean(input.showEnums, this.defaultValue.showEnums),
      showEnumMembers: EditorBooleanOption.boolean(input.showEnumMembers, this.defaultValue.showEnumMembers),
      showKeywords: EditorBooleanOption.boolean(input.showKeywords, this.defaultValue.showKeywords),
      showWords: EditorBooleanOption.boolean(input.showWords, this.defaultValue.showWords),
      showColors: EditorBooleanOption.boolean(input.showColors, this.defaultValue.showColors),
      showFiles: EditorBooleanOption.boolean(input.showFiles, this.defaultValue.showFiles),
      showReferences: EditorBooleanOption.boolean(input.showReferences, this.defaultValue.showReferences),
      showFolders: EditorBooleanOption.boolean(input.showFolders, this.defaultValue.showFolders),
      showTypeParameters: EditorBooleanOption.boolean(input.showTypeParameters, this.defaultValue.showTypeParameters),
      showSnippets: EditorBooleanOption.boolean(input.showSnippets, this.defaultValue.showSnippets),
      showUsers: EditorBooleanOption.boolean(input.showUsers, this.defaultValue.showUsers),
      showIssues: EditorBooleanOption.boolean(input.showIssues, this.defaultValue.showIssues),
      statusBar: {
        visible: EditorBooleanOption.boolean((_a = input.statusBar) === null || _a === void 0 ? void 0 : _a.visible, !!this.defaultValue.statusBar.visible)
      }
    };
  }
};
var EditorTabFocusMode = class extends ComputedEditorOption {
  constructor() {
    super(116, [72]);
  }
  compute(env2, options, _) {
    const readOnly = options.get(72);
    return readOnly ? true : env2.tabFocusMode;
  }
};
function _wrappingIndentFromString(wrappingIndent) {
  switch (wrappingIndent) {
    case "none":
      return 0;
    case "same":
      return 1;
    case "indent":
      return 2;
    case "deepIndent":
      return 3;
  }
}
var EditorWrappingInfoComputer = class extends ComputedEditorOption {
  constructor() {
    super(118, [117]);
  }
  compute(env2, options, _) {
    const layoutInfo = options.get(117);
    return {
      isDominatedByLongLines: env2.isDominatedByLongLines,
      isWordWrapMinified: layoutInfo.isWordWrapMinified,
      isViewportWrapping: layoutInfo.isViewportWrapping,
      wrappingColumn: layoutInfo.wrappingColumn
    };
  }
};
var DEFAULT_WINDOWS_FONT_FAMILY = "Consolas, 'Courier New', monospace";
var DEFAULT_MAC_FONT_FAMILY = "Menlo, Monaco, 'Courier New', monospace";
var DEFAULT_LINUX_FONT_FAMILY = "'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Fallback'";
var EDITOR_FONT_DEFAULTS = {
  fontFamily: isMacintosh ? DEFAULT_MAC_FONT_FAMILY : isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY,
  fontWeight: "normal",
  fontSize: isMacintosh ? 12 : 14,
  lineHeight: 0,
  letterSpacing: 0
};
var EDITOR_MODEL_DEFAULTS = {
  tabSize: 4,
  indentSize: 4,
  insertSpaces: true,
  detectIndentation: true,
  trimAutoWhitespace: true,
  largeFileOptimizations: true
};
var editorOptionsRegistry = [];
function register(option) {
  editorOptionsRegistry[option.id] = option;
  return option;
}
var EditorOptions = {
  acceptSuggestionOnCommitCharacter: register(new EditorBooleanOption(0, "acceptSuggestionOnCommitCharacter", true, {markdownDescription: localize("acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.")})),
  acceptSuggestionOnEnter: register(new EditorStringEnumOption(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
    markdownEnumDescriptions: [
      "",
      localize("acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change."),
      ""
    ],
    markdownDescription: localize("acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
  })),
  accessibilitySupport: register(new EditorAccessibilitySupport()),
  accessibilityPageSize: register(new EditorIntOption(3, "accessibilityPageSize", 10, 1, 1073741824, {description: localize("accessibilityPageSize", "Controls the number of lines in the editor that can be read out by a screen reader. Warning: this has a performance implication for numbers larger than the default.")})),
  ariaLabel: register(new EditorStringOption(4, "ariaLabel", localize("editorViewAccessibleLabel", "Editor content"))),
  autoClosingBrackets: register(new EditorStringEnumOption(5, "autoClosingBrackets", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      localize("editor.autoClosingBrackets.languageDefined", "Use language configurations to determine when to autoclose brackets."),
      localize("editor.autoClosingBrackets.beforeWhitespace", "Autoclose brackets only when the cursor is to the left of whitespace."),
      ""
    ],
    description: localize("autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
  })),
  autoClosingOvertype: register(new EditorStringEnumOption(6, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      localize("editor.autoClosingOvertype.auto", "Type over closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: localize("autoClosingOvertype", "Controls whether the editor should type over closing quotes or brackets.")
  })),
  autoClosingQuotes: register(new EditorStringEnumOption(7, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      localize("editor.autoClosingQuotes.languageDefined", "Use language configurations to determine when to autoclose quotes."),
      localize("editor.autoClosingQuotes.beforeWhitespace", "Autoclose quotes only when the cursor is to the left of whitespace."),
      ""
    ],
    description: localize("autoClosingQuotes", "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
  })),
  autoIndent: register(new EditorEnumOption(8, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], _autoIndentFromString, {
    enumDescriptions: [
      localize("editor.autoIndent.none", "The editor will not insert indentation automatically."),
      localize("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
      localize("editor.autoIndent.brackets", "The editor will keep the current line's indentation and honor language defined brackets."),
      localize("editor.autoIndent.advanced", "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
      localize("editor.autoIndent.full", "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.")
    ],
    description: localize("autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
  })),
  automaticLayout: register(new EditorBooleanOption(9, "automaticLayout", false)),
  autoSurround: register(new EditorStringEnumOption(10, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
    enumDescriptions: [
      localize("editor.autoSurround.languageDefined", "Use language configurations to determine when to automatically surround selections."),
      localize("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
      localize("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
      ""
    ],
    description: localize("autoSurround", "Controls whether the editor should automatically surround selections.")
  })),
  codeLens: register(new EditorBooleanOption(11, "codeLens", true, {description: localize("codeLens", "Controls whether the editor shows CodeLens.")})),
  colorDecorators: register(new EditorBooleanOption(12, "colorDecorators", true, {description: localize("colorDecorators", "Controls whether the editor should render the inline color decorators and color picker.")})),
  columnSelection: register(new EditorBooleanOption(13, "columnSelection", false, {description: localize("columnSelection", "Enable that the selection with the mouse and keys is doing column selection.")})),
  comments: register(new EditorComments()),
  contextmenu: register(new EditorBooleanOption(15, "contextmenu", true)),
  copyWithSyntaxHighlighting: register(new EditorBooleanOption(16, "copyWithSyntaxHighlighting", true, {description: localize("copyWithSyntaxHighlighting", "Controls whether syntax highlighting should be copied into the clipboard.")})),
  cursorBlinking: register(new EditorEnumOption(17, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], _cursorBlinkingStyleFromString, {description: localize("cursorBlinking", "Control the cursor animation style.")})),
  cursorSmoothCaretAnimation: register(new EditorBooleanOption(18, "cursorSmoothCaretAnimation", false, {description: localize("cursorSmoothCaretAnimation", "Controls whether the smooth caret animation should be enabled.")})),
  cursorStyle: register(new EditorEnumOption(19, "cursorStyle", TextEditorCursorStyle.Line, "line", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], _cursorStyleFromString, {description: localize("cursorStyle", "Controls the cursor style.")})),
  cursorSurroundingLines: register(new EditorIntOption(20, "cursorSurroundingLines", 0, 0, 1073741824, {description: localize("cursorSurroundingLines", "Controls the minimal number of visible leading and trailing lines surrounding the cursor. Known as 'scrollOff' or `scrollOffset` in some other editors.")})),
  cursorSurroundingLinesStyle: register(new EditorStringEnumOption(21, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
    enumDescriptions: [
      localize("cursorSurroundingLinesStyle.default", "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
      localize("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always.")
    ],
    description: localize("cursorSurroundingLinesStyle", "Controls when `cursorSurroundingLines` should be enforced.")
  })),
  cursorWidth: register(new EditorIntOption(22, "cursorWidth", 0, 0, 1073741824, {markdownDescription: localize("cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.")})),
  disableLayerHinting: register(new EditorBooleanOption(23, "disableLayerHinting", false)),
  disableMonospaceOptimizations: register(new EditorBooleanOption(24, "disableMonospaceOptimizations", false)),
  dragAndDrop: register(new EditorBooleanOption(25, "dragAndDrop", true, {description: localize("dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop.")})),
  emptySelectionClipboard: register(new EditorEmptySelectionClipboard()),
  extraEditorClassName: register(new EditorStringOption(27, "extraEditorClassName", "")),
  fastScrollSensitivity: register(new EditorFloatOption(28, "fastScrollSensitivity", 5, (x) => x <= 0 ? 5 : x, {markdownDescription: localize("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`.")})),
  find: register(new EditorFind()),
  fixedOverflowWidgets: register(new EditorBooleanOption(30, "fixedOverflowWidgets", false)),
  folding: register(new EditorBooleanOption(31, "folding", true, {description: localize("folding", "Controls whether the editor has code folding enabled.")})),
  foldingStrategy: register(new EditorStringEnumOption(32, "foldingStrategy", "auto", ["auto", "indentation"], {
    enumDescriptions: [
      localize("foldingStrategy.auto", "Use a language-specific folding strategy if available, else the indentation-based one."),
      localize("foldingStrategy.indentation", "Use the indentation-based folding strategy.")
    ],
    description: localize("foldingStrategy", "Controls the strategy for computing folding ranges.")
  })),
  foldingHighlight: register(new EditorBooleanOption(33, "foldingHighlight", true, {description: localize("foldingHighlight", "Controls whether the editor should highlight folded ranges.")})),
  unfoldOnClickAfterEndOfLine: register(new EditorBooleanOption(34, "unfoldOnClickAfterEndOfLine", false, {description: localize("unfoldOnClickAfterEndOfLine", "Controls whether clicking on the empty content after a folded line will unfold the line.")})),
  fontFamily: register(new EditorStringOption(35, "fontFamily", EDITOR_FONT_DEFAULTS.fontFamily, {description: localize("fontFamily", "Controls the font family.")})),
  fontInfo: register(new EditorFontInfo()),
  fontLigatures2: register(new EditorFontLigatures()),
  fontSize: register(new EditorFontSize()),
  fontWeight: register(new EditorFontWeight()),
  formatOnPaste: register(new EditorBooleanOption(40, "formatOnPaste", false, {description: localize("formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.")})),
  formatOnType: register(new EditorBooleanOption(41, "formatOnType", false, {description: localize("formatOnType", "Controls whether the editor should automatically format the line after typing.")})),
  glyphMargin: register(new EditorBooleanOption(42, "glyphMargin", true, {description: localize("glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.")})),
  gotoLocation: register(new EditorGoToLocation()),
  hideCursorInOverviewRuler: register(new EditorBooleanOption(44, "hideCursorInOverviewRuler", false, {description: localize("hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler.")})),
  highlightActiveIndentGuide: register(new EditorBooleanOption(45, "highlightActiveIndentGuide", true, {description: localize("highlightActiveIndentGuide", "Controls whether the editor should highlight the active indent guide.")})),
  hover: register(new EditorHover()),
  inDiffEditor: register(new EditorBooleanOption(47, "inDiffEditor", false)),
  letterSpacing: register(new EditorFloatOption(48, "letterSpacing", EDITOR_FONT_DEFAULTS.letterSpacing, (x) => EditorFloatOption.clamp(x, -5, 20), {description: localize("letterSpacing", "Controls the letter spacing in pixels.")})),
  lightbulb: register(new EditorLightbulb()),
  lineDecorationsWidth: register(new SimpleEditorOption(50, "lineDecorationsWidth", 10)),
  lineHeight: register(new EditorLineHeight()),
  lineNumbers: register(new EditorRenderLineNumbersOption()),
  lineNumbersMinChars: register(new EditorIntOption(53, "lineNumbersMinChars", 5, 1, 300)),
  links: register(new EditorBooleanOption(54, "links", true, {description: localize("links", "Controls whether the editor should detect links and make them clickable.")})),
  matchBrackets: register(new EditorStringEnumOption(55, "matchBrackets", "always", ["always", "near", "never"], {description: localize("matchBrackets", "Highlight matching brackets.")})),
  minimap: register(new EditorMinimap()),
  mouseStyle: register(new EditorStringEnumOption(57, "mouseStyle", "text", ["text", "default", "copy"])),
  mouseWheelScrollSensitivity: register(new EditorFloatOption(58, "mouseWheelScrollSensitivity", 1, (x) => x === 0 ? 1 : x, {markdownDescription: localize("mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.")})),
  mouseWheelZoom: register(new EditorBooleanOption(59, "mouseWheelZoom", false, {markdownDescription: localize("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.")})),
  multiCursorMergeOverlapping: register(new EditorBooleanOption(60, "multiCursorMergeOverlapping", true, {description: localize("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping.")})),
  multiCursorModifier: register(new EditorEnumOption(61, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], _multiCursorModifierFromString, {
    markdownEnumDescriptions: [
      localize("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
      localize("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
    ],
    markdownDescription: localize({
      key: "multiCursorModifier",
      comment: [
        "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
        "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
      ]
    }, "The modifier to be used to add multiple cursors with the mouse. The Go To Definition and Open Link mouse gestures will adapt such that they do not conflict with the multicursor modifier. [Read more](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).")
  })),
  multiCursorPaste: register(new EditorStringEnumOption(62, "multiCursorPaste", "spread", ["spread", "full"], {
    markdownEnumDescriptions: [
      localize("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
      localize("multiCursorPaste.full", "Each cursor pastes the full text.")
    ],
    markdownDescription: localize("multiCursorPaste", "Controls pasting when the line count of the pasted text matches the cursor count.")
  })),
  occurrencesHighlight: register(new EditorBooleanOption(63, "occurrencesHighlight", true, {description: localize("occurrencesHighlight", "Controls whether the editor should highlight semantic symbol occurrences.")})),
  overviewRulerBorder: register(new EditorBooleanOption(64, "overviewRulerBorder", true, {description: localize("overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler.")})),
  overviewRulerLanes: register(new EditorIntOption(65, "overviewRulerLanes", 3, 0, 3)),
  padding: register(new EditorPadding()),
  parameterHints: register(new EditorParameterHints()),
  peekWidgetDefaultFocus: register(new EditorStringEnumOption(68, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
    enumDescriptions: [
      localize("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
      localize("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek")
    ],
    description: localize("peekWidgetDefaultFocus", "Controls whether to focus the inline editor or the tree in the peek widget.")
  })),
  definitionLinkOpensInPeek: register(new EditorBooleanOption(69, "definitionLinkOpensInPeek", false, {description: localize("definitionLinkOpensInPeek", "Controls whether the Go to Definition mouse gesture always opens the peek widget.")})),
  quickSuggestions: register(new EditorQuickSuggestions()),
  quickSuggestionsDelay: register(new EditorIntOption(71, "quickSuggestionsDelay", 10, 0, 1073741824, {description: localize("quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up.")})),
  readOnly: register(new EditorBooleanOption(72, "readOnly", false)),
  renameOnType: register(new EditorBooleanOption(73, "renameOnType", false, {description: localize("renameOnType", "Controls whether the editor auto renames on type.")})),
  renderControlCharacters: register(new EditorBooleanOption(74, "renderControlCharacters", false, {description: localize("renderControlCharacters", "Controls whether the editor should render control characters.")})),
  renderIndentGuides: register(new EditorBooleanOption(75, "renderIndentGuides", true, {description: localize("renderIndentGuides", "Controls whether the editor should render indent guides.")})),
  renderFinalNewline: register(new EditorBooleanOption(76, "renderFinalNewline", true, {description: localize("renderFinalNewline", "Render last line number when the file ends with a newline.")})),
  renderLineHighlight: register(new EditorStringEnumOption(77, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
    enumDescriptions: [
      "",
      "",
      "",
      localize("renderLineHighlight.all", "Highlights both the gutter and the current line.")
    ],
    description: localize("renderLineHighlight", "Controls how the editor should render the current line highlight.")
  })),
  renderLineHighlightOnlyWhenFocus: register(new EditorBooleanOption(78, "renderLineHighlightOnlyWhenFocus", false, {description: localize("renderLineHighlightOnlyWhenFocus", "Controls if the editor should render the current line highlight only when the editor is focused")})),
  renderValidationDecorations: register(new EditorStringEnumOption(79, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
  renderWhitespace: register(new EditorStringEnumOption(80, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
    enumDescriptions: [
      "",
      localize("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
      localize("renderWhitespace.selection", "Render whitespace characters only on selected text."),
      localize("renderWhitespace.trailing", "Render only trailing whitespace characters"),
      ""
    ],
    description: localize("renderWhitespace", "Controls how the editor should render whitespace characters.")
  })),
  revealHorizontalRightPadding: register(new EditorIntOption(81, "revealHorizontalRightPadding", 30, 0, 1e3)),
  roundedSelection: register(new EditorBooleanOption(82, "roundedSelection", true, {description: localize("roundedSelection", "Controls whether selections should have rounded corners.")})),
  rulers: register(new EditorRulers()),
  scrollbar: register(new EditorScrollbar()),
  scrollBeyondLastColumn: register(new EditorIntOption(85, "scrollBeyondLastColumn", 5, 0, 1073741824, {description: localize("scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally.")})),
  scrollBeyondLastLine: register(new EditorBooleanOption(86, "scrollBeyondLastLine", true, {description: localize("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line.")})),
  scrollPredominantAxis: register(new EditorBooleanOption(87, "scrollPredominantAxis", true, {description: localize("scrollPredominantAxis", "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.")})),
  selectionClipboard: register(new EditorBooleanOption(88, "selectionClipboard", true, {
    description: localize("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
    included: isLinux
  })),
  selectionHighlight: register(new EditorBooleanOption(89, "selectionHighlight", true, {description: localize("selectionHighlight", "Controls whether the editor should highlight matches similar to the selection.")})),
  selectOnLineNumbers: register(new EditorBooleanOption(90, "selectOnLineNumbers", true)),
  showFoldingControls: register(new EditorStringEnumOption(91, "showFoldingControls", "mouseover", ["always", "mouseover"], {
    enumDescriptions: [
      localize("showFoldingControls.always", "Always show the folding controls."),
      localize("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter.")
    ],
    description: localize("showFoldingControls", "Controls when the folding controls on the gutter are shown.")
  })),
  showUnused: register(new EditorBooleanOption(92, "showUnused", true, {description: localize("showUnused", "Controls fading out of unused code.")})),
  showDeprecated: register(new EditorBooleanOption(113, "showDeprecated", true, {description: localize("showDeprecated", "Controls strikethrough deprecated variables.")})),
  snippetSuggestions: register(new EditorStringEnumOption(93, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
    enumDescriptions: [
      localize("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
      localize("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
      localize("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
      localize("snippetSuggestions.none", "Do not show snippet suggestions.")
    ],
    description: localize("snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted.")
  })),
  smoothScrolling: register(new EditorBooleanOption(94, "smoothScrolling", false, {description: localize("smoothScrolling", "Controls whether the editor will scroll using an animation.")})),
  stopRenderingLineAfter: register(new EditorIntOption(95, "stopRenderingLineAfter", 1e4, -1, 1073741824)),
  suggest: register(new EditorSuggest()),
  suggestFontSize: register(new EditorIntOption(97, "suggestFontSize", 0, 0, 1e3, {markdownDescription: localize("suggestFontSize", "Font size for the suggest widget. When set to `0`, the value of `#editor.fontSize#` is used.")})),
  suggestLineHeight: register(new EditorIntOption(98, "suggestLineHeight", 0, 0, 1e3, {markdownDescription: localize("suggestLineHeight", "Line height for the suggest widget. When set to `0`, the value of `#editor.lineHeight#` is used.")})),
  suggestOnTriggerCharacters: register(new EditorBooleanOption(99, "suggestOnTriggerCharacters", true, {description: localize("suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters.")})),
  suggestSelection: register(new EditorStringEnumOption(100, "suggestSelection", "recentlyUsed", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
    markdownEnumDescriptions: [
      localize("suggestSelection.first", "Always select the first suggestion."),
      localize("suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
      localize("suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.")
    ],
    description: localize("suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list.")
  })),
  tabCompletion: register(new EditorStringEnumOption(101, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
    enumDescriptions: [
      localize("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
      localize("tabCompletion.off", "Disable tab completions."),
      localize("tabCompletion.onlySnippets", "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.")
    ],
    description: localize("tabCompletion", "Enables tab completions.")
  })),
  tabIndex: register(new EditorIntOption(102, "tabIndex", 0, -1, 1073741824)),
  unusualLineTerminators: register(new EditorStringEnumOption(103, "unusualLineTerminators", "prompt", ["off", "prompt", "auto"], {
    enumDescriptions: [
      localize("unusualLineTerminators.off", "Unusual line terminators are ignored."),
      localize("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed."),
      localize("unusualLineTerminators.auto", "Unusual line terminators are automatically removed.")
    ],
    description: localize("unusualLineTerminators", "Remove unusual line terminators that might cause problems.")
  })),
  useTabStops: register(new EditorBooleanOption(104, "useTabStops", true, {description: localize("useTabStops", "Inserting and deleting whitespace follows tab stops.")})),
  wordSeparators: register(new EditorStringOption(105, "wordSeparators", USUAL_WORD_SEPARATORS, {description: localize("wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations.")})),
  wordWrap: register(new EditorStringEnumOption(106, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
    markdownEnumDescriptions: [
      localize("wordWrap.off", "Lines will never wrap."),
      localize("wordWrap.on", "Lines will wrap at the viewport width."),
      localize({
        key: "wordWrap.wordWrapColumn",
        comment: [
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at `#editor.wordWrapColumn#`."),
      localize({
        key: "wordWrap.bounded",
        comment: [
          "- viewport means the edge of the visible window size.",
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.")
    ],
    description: localize({
      key: "wordWrap",
      comment: [
        "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
        "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
      ]
    }, "Controls how lines should wrap.")
  })),
  wordWrapBreakAfterCharacters: register(new EditorStringOption(107, "wordWrapBreakAfterCharacters", " 	})]?|/&.,;\xA2\xB0\u2032\u2033\u2030\u2103\u3001\u3002\uFF61\uFF64\uFFE0\uFF0C\uFF0E\uFF1A\uFF1B\uFF1F\uFF01\uFF05\u30FB\uFF65\u309D\u309E\u30FD\u30FE\u30FC\u30A1\u30A3\u30A5\u30A7\u30A9\u30C3\u30E3\u30E5\u30E7\u30EE\u30F5\u30F6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308E\u3095\u3096\u31F0\u31F1\u31F2\u31F3\u31F4\u31F5\u31F6\u31F7\u31F8\u31F9\u31FA\u31FB\u31FC\u31FD\u31FE\u31FF\u3005\u303B\uFF67\uFF68\uFF69\uFF6A\uFF6B\uFF6C\uFF6D\uFF6E\uFF6F\uFF70\u201D\u3009\u300B\u300D\u300F\u3011\u3015\uFF09\uFF3D\uFF5D\uFF63")),
  wordWrapBreakBeforeCharacters: register(new EditorStringOption(108, "wordWrapBreakBeforeCharacters", "([{\u2018\u201C\u3008\u300A\u300C\u300E\u3010\u3014\uFF08\uFF3B\uFF5B\uFF62\xA3\xA5\uFF04\uFFE1\uFFE5+\uFF0B")),
  wordWrapColumn: register(new EditorIntOption(109, "wordWrapColumn", 80, 1, 1073741824, {
    markdownDescription: localize({
      key: "wordWrapColumn",
      comment: [
        "- `editor.wordWrap` refers to a different setting and should not be localized.",
        "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized."
      ]
    }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.")
  })),
  wordWrapMinified: register(new EditorBooleanOption(110, "wordWrapMinified", true)),
  wrappingIndent: register(new EditorEnumOption(111, "wrappingIndent", 1, "same", ["none", "same", "indent", "deepIndent"], _wrappingIndentFromString, {
    enumDescriptions: [
      localize("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
      localize("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
      localize("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
      localize("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent.")
    ],
    description: localize("wrappingIndent", "Controls the indentation of wrapped lines.")
  })),
  wrappingStrategy: register(new EditorStringEnumOption(112, "wrappingStrategy", "simple", ["simple", "advanced"], {
    enumDescriptions: [
      localize("wrappingStrategy.simple", "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
      localize("wrappingStrategy.advanced", "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
    ],
    description: localize("wrappingStrategy", "Controls the algorithm that computes wrapping points.")
  })),
  editorClassName: register(new EditorClassName()),
  pixelRatio: register(new EditorPixelRatio()),
  tabFocusMode: register(new EditorTabFocusMode()),
  layoutInfo: register(new EditorLayoutInfoComputer()),
  wrappingInfo: register(new EditorWrappingInfoComputer())
};

// ../../node_modules/monaco-editor/esm/vs/base/common/errors.js
var ErrorHandler = class {
  constructor() {
    this.listeners = [];
    this.unexpectedErrorHandler = function(e) {
      setTimeout(() => {
        if (e.stack) {
          throw new Error(e.message + "\n\n" + e.stack);
        }
        throw e;
      }, 0);
    };
  }
  emit(e) {
    this.listeners.forEach((listener) => {
      listener(e);
    });
  }
  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e);
    this.emit(e);
  }
  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }
};
var errorHandler = new ErrorHandler();
function onUnexpectedError(e) {
  if (!isPromiseCanceledError(e)) {
    errorHandler.onUnexpectedError(e);
  }
  return void 0;
}
function transformErrorForSerialization(error) {
  if (error instanceof Error) {
    let {name, message} = error;
    const stack = error.stacktrace || error.stack;
    return {
      $isError: true,
      name,
      message,
      stack
    };
  }
  return error;
}
var canceledName = "Canceled";
function isPromiseCanceledError(error) {
  return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
function canceled() {
  const error = new Error(canceledName);
  error.name = error.message;
  return error;
}
function illegalArgument(name) {
  if (name) {
    return new Error(`Illegal argument: ${name}`);
  } else {
    return new Error("Illegal argument");
  }
}
function illegalState(name) {
  if (name) {
    return new Error(`Illegal state: ${name}`);
  } else {
    return new Error("Illegal state");
  }
}

// ../../node_modules/monaco-editor/esm/vs/base/common/iterator.js
var Iterable;
(function(Iterable2) {
  function is(thing) {
    return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
  }
  Iterable2.is = is;
  const _empty2 = Object.freeze([]);
  function empty2() {
    return _empty2;
  }
  Iterable2.empty = empty2;
  function* single(element) {
    yield element;
  }
  Iterable2.single = single;
  function from(iterable) {
    return iterable || _empty2;
  }
  Iterable2.from = from;
  function first2(iterable) {
    return iterable[Symbol.iterator]().next().value;
  }
  Iterable2.first = first2;
  function some(iterable, predicate) {
    for (const element of iterable) {
      if (predicate(element)) {
        return true;
      }
    }
    return false;
  }
  Iterable2.some = some;
  function* filter(iterable, predicate) {
    for (const element of iterable) {
      if (predicate(element)) {
        yield element;
      }
    }
  }
  Iterable2.filter = filter;
  function* map(iterable, fn) {
    for (const element of iterable) {
      yield fn(element);
    }
  }
  Iterable2.map = map;
  function* concat2(...iterables) {
    for (const iterable of iterables) {
      for (const element of iterable) {
        yield element;
      }
    }
  }
  Iterable2.concat = concat2;
  function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
    const consumed = [];
    if (atMost === 0) {
      return [consumed, iterable];
    }
    const iterator = iterable[Symbol.iterator]();
    for (let i = 0; i < atMost; i++) {
      const next = iterator.next();
      if (next.done) {
        return [consumed, Iterable2.empty()];
      }
      consumed.push(next.value);
    }
    return [consumed, {[Symbol.iterator]() {
      return iterator;
    }}];
  }
  Iterable2.consume = consume;
})(Iterable || (Iterable = {}));

// ../../node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
var TRACK_DISPOSABLES = false;
var __is_disposable_tracked__ = "__is_disposable_tracked__";
function markTracked(x) {
  if (!TRACK_DISPOSABLES) {
    return;
  }
  if (x && x !== Disposable.None) {
    try {
      x[__is_disposable_tracked__] = true;
    } catch (_a) {
    }
  }
}
function trackDisposable(x) {
  if (!TRACK_DISPOSABLES) {
    return x;
  }
  const stack = new Error("Potentially leaked disposable").stack;
  setTimeout(() => {
    if (!x[__is_disposable_tracked__]) {
      console.log(stack);
    }
  }, 3e3);
  return x;
}
var MultiDisposeError = class extends Error {
  constructor(errors3) {
    super(`Encounter errors while disposing of store. Errors: [${errors3.join(", ")}]`);
    this.errors = errors3;
  }
};
function isDisposable(thing) {
  return typeof thing.dispose === "function" && thing.dispose.length === 0;
}
function dispose(arg) {
  if (Iterable.is(arg)) {
    let errors3 = [];
    for (const d of arg) {
      if (d) {
        markTracked(d);
        try {
          d.dispose();
        } catch (e) {
          errors3.push(e);
        }
      }
    }
    if (errors3.length === 1) {
      throw errors3[0];
    } else if (errors3.length > 1) {
      throw new MultiDisposeError(errors3);
    }
    return Array.isArray(arg) ? [] : arg;
  } else if (arg) {
    markTracked(arg);
    arg.dispose();
    return arg;
  }
}
function combinedDisposable(...disposables) {
  disposables.forEach(markTracked);
  return trackDisposable({dispose: () => dispose(disposables)});
}
function toDisposable(fn) {
  const self2 = trackDisposable({
    dispose: () => {
      markTracked(self2);
      fn();
    }
  });
  return self2;
}
var DisposableStore = class {
  constructor() {
    this._toDispose = new Set();
    this._isDisposed = false;
  }
  dispose() {
    if (this._isDisposed) {
      return;
    }
    markTracked(this);
    this._isDisposed = true;
    this.clear();
  }
  clear() {
    try {
      dispose(this._toDispose.values());
    } finally {
      this._toDispose.clear();
    }
  }
  add(t) {
    if (!t) {
      return t;
    }
    if (t === this) {
      throw new Error("Cannot register a disposable on itself!");
    }
    markTracked(t);
    if (this._isDisposed) {
      if (!DisposableStore.DISABLE_DISPOSED_WARNING) {
        console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
      }
    } else {
      this._toDispose.add(t);
    }
    return t;
  }
};
DisposableStore.DISABLE_DISPOSED_WARNING = false;
var Disposable = class {
  constructor() {
    this._store = new DisposableStore();
    trackDisposable(this);
  }
  dispose() {
    markTracked(this);
    this._store.dispose();
  }
  _register(t) {
    if (t === this) {
      throw new Error("Cannot register a disposable on itself!");
    }
    return this._store.add(t);
  }
};
Disposable.None = Object.freeze({dispose() {
}});
var ImmortalReference = class {
  constructor(object) {
    this.object = object;
  }
  dispose() {
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/linkedList.js
var Node2 = class {
  constructor(element) {
    this.element = element;
    this.next = Node2.Undefined;
    this.prev = Node2.Undefined;
  }
};
Node2.Undefined = new Node2(void 0);
var LinkedList = class {
  constructor() {
    this._first = Node2.Undefined;
    this._last = Node2.Undefined;
    this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === Node2.Undefined;
  }
  clear() {
    this._first = Node2.Undefined;
    this._last = Node2.Undefined;
    this._size = 0;
  }
  unshift(element) {
    return this._insert(element, false);
  }
  push(element) {
    return this._insert(element, true);
  }
  _insert(element, atTheEnd) {
    const newNode = new Node2(element);
    if (this._first === Node2.Undefined) {
      this._first = newNode;
      this._last = newNode;
    } else if (atTheEnd) {
      const oldLast = this._last;
      this._last = newNode;
      newNode.prev = oldLast;
      oldLast.next = newNode;
    } else {
      const oldFirst = this._first;
      this._first = newNode;
      newNode.next = oldFirst;
      oldFirst.prev = newNode;
    }
    this._size += 1;
    let didRemove = false;
    return () => {
      if (!didRemove) {
        didRemove = true;
        this._remove(newNode);
      }
    };
  }
  shift() {
    if (this._first === Node2.Undefined) {
      return void 0;
    } else {
      const res = this._first.element;
      this._remove(this._first);
      return res;
    }
  }
  pop() {
    if (this._last === Node2.Undefined) {
      return void 0;
    } else {
      const res = this._last.element;
      this._remove(this._last);
      return res;
    }
  }
  _remove(node) {
    if (node.prev !== Node2.Undefined && node.next !== Node2.Undefined) {
      const anchor = node.prev;
      anchor.next = node.next;
      node.next.prev = anchor;
    } else if (node.prev === Node2.Undefined && node.next === Node2.Undefined) {
      this._first = Node2.Undefined;
      this._last = Node2.Undefined;
    } else if (node.next === Node2.Undefined) {
      this._last = this._last.prev;
      this._last.next = Node2.Undefined;
    } else if (node.prev === Node2.Undefined) {
      this._first = this._first.next;
      this._first.prev = Node2.Undefined;
    }
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let node = this._first;
    while (node !== Node2.Undefined) {
      yield node.element;
      node = node.next;
    }
  }
  toArray() {
    const result = [];
    for (let node = this._first; node !== Node2.Undefined; node = node.next) {
      result.push(node.element);
    }
    return result;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/event.js
var Event;
(function(Event2) {
  Event2.None = () => Disposable.None;
  function once3(event) {
    return (listener, thisArgs = null, disposables) => {
      let didFire = false;
      let result;
      result = event((e) => {
        if (didFire) {
          return;
        } else if (result) {
          result.dispose();
        } else {
          didFire = true;
        }
        return listener.call(thisArgs, e);
      }, null, disposables);
      if (didFire) {
        result.dispose();
      }
      return result;
    };
  }
  Event2.once = once3;
  function map(event, map2) {
    return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map2(i)), null, disposables));
  }
  Event2.map = map;
  function forEach2(event, each) {
    return snapshot((listener, thisArgs = null, disposables) => event((i) => {
      each(i);
      listener.call(thisArgs, i);
    }, null, disposables));
  }
  Event2.forEach = forEach2;
  function filter(event, filter2) {
    return snapshot((listener, thisArgs = null, disposables) => event((e) => filter2(e) && listener.call(thisArgs, e), null, disposables));
  }
  Event2.filter = filter;
  function signal(event) {
    return event;
  }
  Event2.signal = signal;
  function any(...events) {
    return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e), null, disposables)));
  }
  Event2.any = any;
  function reduce(event, merge, initial) {
    let output = initial;
    return map(event, (e) => {
      output = merge(output, e);
      return output;
    });
  }
  Event2.reduce = reduce;
  function snapshot(event) {
    let listener;
    const emitter = new Emitter({
      onFirstListenerAdd() {
        listener = event(emitter.fire, emitter);
      },
      onLastListenerRemove() {
        listener.dispose();
      }
    });
    return emitter.event;
  }
  Event2.snapshot = snapshot;
  function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold) {
    let subscription;
    let output = void 0;
    let handle = void 0;
    let numDebouncedCalls = 0;
    const emitter = new Emitter({
      leakWarningThreshold,
      onFirstListenerAdd() {
        subscription = event((cur) => {
          numDebouncedCalls++;
          output = merge(output, cur);
          if (leading && !handle) {
            emitter.fire(output);
            output = void 0;
          }
          clearTimeout(handle);
          handle = setTimeout(() => {
            const _output = output;
            output = void 0;
            handle = void 0;
            if (!leading || numDebouncedCalls > 1) {
              emitter.fire(_output);
            }
            numDebouncedCalls = 0;
          }, delay);
        });
      },
      onLastListenerRemove() {
        subscription.dispose();
      }
    });
    return emitter.event;
  }
  Event2.debounce = debounce;
  function stopwatch(event) {
    const start = new Date().getTime();
    return map(once3(event), (_) => new Date().getTime() - start);
  }
  Event2.stopwatch = stopwatch;
  function latch(event) {
    let firstCall = true;
    let cache;
    return filter(event, (value) => {
      const shouldEmit = firstCall || value !== cache;
      firstCall = false;
      cache = value;
      return shouldEmit;
    });
  }
  Event2.latch = latch;
  function buffer4(event, nextTick = false, _buffer = []) {
    let buffer5 = _buffer.slice();
    let listener = event((e) => {
      if (buffer5) {
        buffer5.push(e);
      } else {
        emitter.fire(e);
      }
    });
    const flush = () => {
      if (buffer5) {
        buffer5.forEach((e) => emitter.fire(e));
      }
      buffer5 = null;
    };
    const emitter = new Emitter({
      onFirstListenerAdd() {
        if (!listener) {
          listener = event((e) => emitter.fire(e));
        }
      },
      onFirstListenerDidAdd() {
        if (buffer5) {
          if (nextTick) {
            setTimeout(flush);
          } else {
            flush();
          }
        }
      },
      onLastListenerRemove() {
        if (listener) {
          listener.dispose();
        }
        listener = null;
      }
    });
    return emitter.event;
  }
  Event2.buffer = buffer4;
  class ChainableEvent {
    constructor(event) {
      this.event = event;
    }
    map(fn) {
      return new ChainableEvent(map(this.event, fn));
    }
    forEach(fn) {
      return new ChainableEvent(forEach2(this.event, fn));
    }
    filter(fn) {
      return new ChainableEvent(filter(this.event, fn));
    }
    reduce(merge, initial) {
      return new ChainableEvent(reduce(this.event, merge, initial));
    }
    latch() {
      return new ChainableEvent(latch(this.event));
    }
    debounce(merge, delay = 100, leading = false, leakWarningThreshold) {
      return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));
    }
    on(listener, thisArgs, disposables) {
      return this.event(listener, thisArgs, disposables);
    }
    once(listener, thisArgs, disposables) {
      return once3(this.event)(listener, thisArgs, disposables);
    }
  }
  function chain(event) {
    return new ChainableEvent(event);
  }
  Event2.chain = chain;
  function fromNodeEventEmitter(emitter, eventName, map2 = (id) => id) {
    const fn = (...args) => result.fire(map2(...args));
    const onFirstListenerAdd = () => emitter.on(eventName, fn);
    const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
    const result = new Emitter({onFirstListenerAdd, onLastListenerRemove});
    return result.event;
  }
  Event2.fromNodeEventEmitter = fromNodeEventEmitter;
  function fromDOMEventEmitter(emitter, eventName, map2 = (id) => id) {
    const fn = (...args) => result.fire(map2(...args));
    const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
    const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
    const result = new Emitter({onFirstListenerAdd, onLastListenerRemove});
    return result.event;
  }
  Event2.fromDOMEventEmitter = fromDOMEventEmitter;
  function fromPromise(promise) {
    const emitter = new Emitter();
    let shouldEmit = false;
    promise.then(void 0, () => null).then(() => {
      if (!shouldEmit) {
        setTimeout(() => emitter.fire(void 0), 0);
      } else {
        emitter.fire(void 0);
      }
    });
    shouldEmit = true;
    return emitter.event;
  }
  Event2.fromPromise = fromPromise;
  function toPromise(event) {
    return new Promise((c) => once3(event)(c));
  }
  Event2.toPromise = toPromise;
})(Event || (Event = {}));
var _globalLeakWarningThreshold = -1;
var LeakageMonitor = class {
  constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {
    this.customThreshold = customThreshold;
    this.name = name;
    this._warnCountdown = 0;
  }
  dispose() {
    if (this._stacks) {
      this._stacks.clear();
    }
  }
  check(listenerCount) {
    let threshold = _globalLeakWarningThreshold;
    if (typeof this.customThreshold === "number") {
      threshold = this.customThreshold;
    }
    if (threshold <= 0 || listenerCount < threshold) {
      return void 0;
    }
    if (!this._stacks) {
      this._stacks = new Map();
    }
    const stack = new Error().stack.split("\n").slice(3).join("\n");
    const count = this._stacks.get(stack) || 0;
    this._stacks.set(stack, count + 1);
    this._warnCountdown -= 1;
    if (this._warnCountdown <= 0) {
      this._warnCountdown = threshold * 0.5;
      let topStack;
      let topCount = 0;
      for (const [stack2, count2] of this._stacks) {
        if (!topStack || topCount < count2) {
          topStack = stack2;
          topCount = count2;
        }
      }
      console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
      console.warn(topStack);
    }
    return () => {
      const count2 = this._stacks.get(stack) || 0;
      this._stacks.set(stack, count2 - 1);
    };
  }
};
var Emitter = class {
  constructor(options) {
    this._disposed = false;
    this._options = options;
    this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : void 0;
  }
  get event() {
    if (!this._event) {
      this._event = (listener, thisArgs, disposables) => {
        if (!this._listeners) {
          this._listeners = new LinkedList();
        }
        const firstListener = this._listeners.isEmpty();
        if (firstListener && this._options && this._options.onFirstListenerAdd) {
          this._options.onFirstListenerAdd(this);
        }
        const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);
        if (firstListener && this._options && this._options.onFirstListenerDidAdd) {
          this._options.onFirstListenerDidAdd(this);
        }
        if (this._options && this._options.onListenerDidAdd) {
          this._options.onListenerDidAdd(this, listener, thisArgs);
        }
        let removeMonitor;
        if (this._leakageMon) {
          removeMonitor = this._leakageMon.check(this._listeners.size);
        }
        let result;
        result = {
          dispose: () => {
            if (removeMonitor) {
              removeMonitor();
            }
            result.dispose = Emitter._noop;
            if (!this._disposed) {
              remove();
              if (this._options && this._options.onLastListenerRemove) {
                const hasListeners = this._listeners && !this._listeners.isEmpty();
                if (!hasListeners) {
                  this._options.onLastListenerRemove(this);
                }
              }
            }
          }
        };
        if (disposables instanceof DisposableStore) {
          disposables.add(result);
        } else if (Array.isArray(disposables)) {
          disposables.push(result);
        }
        return result;
      };
    }
    return this._event;
  }
  fire(event) {
    if (this._listeners) {
      if (!this._deliveryQueue) {
        this._deliveryQueue = new LinkedList();
      }
      for (let listener of this._listeners) {
        this._deliveryQueue.push([listener, event]);
      }
      while (this._deliveryQueue.size > 0) {
        const [listener, event2] = this._deliveryQueue.shift();
        try {
          if (typeof listener === "function") {
            listener.call(void 0, event2);
          } else {
            listener[0].call(listener[1], event2);
          }
        } catch (e) {
          onUnexpectedError(e);
        }
      }
    }
  }
  dispose() {
    if (this._listeners) {
      this._listeners.clear();
    }
    if (this._deliveryQueue) {
      this._deliveryQueue.clear();
    }
    if (this._leakageMon) {
      this._leakageMon.dispose();
    }
    this._disposed = true;
  }
};
Emitter._noop = function() {
};
var PauseableEmitter = class extends Emitter {
  constructor(options) {
    super(options);
    this._isPaused = 0;
    this._eventQueue = new LinkedList();
    this._mergeFn = options && options.merge;
  }
  pause() {
    this._isPaused++;
  }
  resume() {
    if (this._isPaused !== 0 && --this._isPaused === 0) {
      if (this._mergeFn) {
        const events = this._eventQueue.toArray();
        this._eventQueue.clear();
        super.fire(this._mergeFn(events));
      } else {
        while (!this._isPaused && this._eventQueue.size !== 0) {
          super.fire(this._eventQueue.shift());
        }
      }
    }
  }
  fire(event) {
    if (this._listeners) {
      if (this._isPaused !== 0) {
        this._eventQueue.push(event);
      } else {
        super.fire(event);
      }
    }
  }
};
var EventBufferer = class {
  constructor() {
    this.buffers = [];
  }
  wrapEvent(event) {
    return (listener, thisArgs, disposables) => {
      return event((i) => {
        const buffer4 = this.buffers[this.buffers.length - 1];
        if (buffer4) {
          buffer4.push(() => listener.call(thisArgs, i));
        } else {
          listener.call(thisArgs, i);
        }
      }, void 0, disposables);
    };
  }
  bufferEvents(fn) {
    const buffer4 = [];
    this.buffers.push(buffer4);
    const r = fn();
    this.buffers.pop();
    buffer4.forEach((flush) => flush());
    return r;
  }
};
var Relay = class {
  constructor() {
    this.listening = false;
    this.inputEvent = Event.None;
    this.inputEventListener = Disposable.None;
    this.emitter = new Emitter({
      onFirstListenerDidAdd: () => {
        this.listening = true;
        this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
      },
      onLastListenerRemove: () => {
        this.listening = false;
        this.inputEventListener.dispose();
      }
    });
    this.event = this.emitter.event;
  }
  set input(event) {
    this.inputEvent = event;
    if (this.listening) {
      this.inputEventListener.dispose();
      this.inputEventListener = event(this.emitter.fire, this.emitter);
    }
  }
  dispose() {
    this.inputEventListener.dispose();
    this.emitter.dispose();
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/cancellation.js
var shortcutEvent = Object.freeze(function(callback, context) {
  const handle = setTimeout(callback.bind(context), 0);
  return {dispose() {
    clearTimeout(handle);
  }};
});
var CancellationToken;
(function(CancellationToken2) {
  function isCancellationToken(thing) {
    if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
      return true;
    }
    if (thing instanceof MutableToken) {
      return true;
    }
    if (!thing || typeof thing !== "object") {
      return false;
    }
    return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
  }
  CancellationToken2.isCancellationToken = isCancellationToken;
  CancellationToken2.None = Object.freeze({
    isCancellationRequested: false,
    onCancellationRequested: Event.None
  });
  CancellationToken2.Cancelled = Object.freeze({
    isCancellationRequested: true,
    onCancellationRequested: shortcutEvent
  });
})(CancellationToken || (CancellationToken = {}));
var MutableToken = class {
  constructor() {
    this._isCancelled = false;
    this._emitter = null;
  }
  cancel() {
    if (!this._isCancelled) {
      this._isCancelled = true;
      if (this._emitter) {
        this._emitter.fire(void 0);
        this.dispose();
      }
    }
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    if (this._isCancelled) {
      return shortcutEvent;
    }
    if (!this._emitter) {
      this._emitter = new Emitter();
    }
    return this._emitter.event;
  }
  dispose() {
    if (this._emitter) {
      this._emitter.dispose();
      this._emitter = null;
    }
  }
};
var CancellationTokenSource = class {
  constructor(parent) {
    this._token = void 0;
    this._parentListener = void 0;
    this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
  }
  get token() {
    if (!this._token) {
      this._token = new MutableToken();
    }
    return this._token;
  }
  cancel() {
    if (!this._token) {
      this._token = CancellationToken.Cancelled;
    } else if (this._token instanceof MutableToken) {
      this._token.cancel();
    }
  }
  dispose(cancel = false) {
    if (cancel) {
      this.cancel();
    }
    if (this._parentListener) {
      this._parentListener.dispose();
    }
    if (!this._token) {
      this._token = CancellationToken.None;
    } else if (this._token instanceof MutableToken) {
      this._token.dispose();
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/keyCodes.js
var KeyCodeStrMap = class {
  constructor() {
    this._keyCodeToStr = [];
    this._strToKeyCode = Object.create(null);
  }
  define(keyCode, str) {
    this._keyCodeToStr[keyCode] = str;
    this._strToKeyCode[str.toLowerCase()] = keyCode;
  }
  keyCodeToStr(keyCode) {
    return this._keyCodeToStr[keyCode];
  }
  strToKeyCode(str) {
    return this._strToKeyCode[str.toLowerCase()] || 0;
  }
};
var uiMap = new KeyCodeStrMap();
var userSettingsUSMap = new KeyCodeStrMap();
var userSettingsGeneralMap = new KeyCodeStrMap();
(function() {
  function define(keyCode, uiLabel, usUserSettingsLabel = uiLabel, generalUserSettingsLabel = usUserSettingsLabel) {
    uiMap.define(keyCode, uiLabel);
    userSettingsUSMap.define(keyCode, usUserSettingsLabel);
    userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel);
  }
  define(0, "unknown");
  define(1, "Backspace");
  define(2, "Tab");
  define(3, "Enter");
  define(4, "Shift");
  define(5, "Ctrl");
  define(6, "Alt");
  define(7, "PauseBreak");
  define(8, "CapsLock");
  define(9, "Escape");
  define(10, "Space");
  define(11, "PageUp");
  define(12, "PageDown");
  define(13, "End");
  define(14, "Home");
  define(15, "LeftArrow", "Left");
  define(16, "UpArrow", "Up");
  define(17, "RightArrow", "Right");
  define(18, "DownArrow", "Down");
  define(19, "Insert");
  define(20, "Delete");
  define(21, "0");
  define(22, "1");
  define(23, "2");
  define(24, "3");
  define(25, "4");
  define(26, "5");
  define(27, "6");
  define(28, "7");
  define(29, "8");
  define(30, "9");
  define(31, "A");
  define(32, "B");
  define(33, "C");
  define(34, "D");
  define(35, "E");
  define(36, "F");
  define(37, "G");
  define(38, "H");
  define(39, "I");
  define(40, "J");
  define(41, "K");
  define(42, "L");
  define(43, "M");
  define(44, "N");
  define(45, "O");
  define(46, "P");
  define(47, "Q");
  define(48, "R");
  define(49, "S");
  define(50, "T");
  define(51, "U");
  define(52, "V");
  define(53, "W");
  define(54, "X");
  define(55, "Y");
  define(56, "Z");
  define(57, "Meta");
  define(58, "ContextMenu");
  define(59, "F1");
  define(60, "F2");
  define(61, "F3");
  define(62, "F4");
  define(63, "F5");
  define(64, "F6");
  define(65, "F7");
  define(66, "F8");
  define(67, "F9");
  define(68, "F10");
  define(69, "F11");
  define(70, "F12");
  define(71, "F13");
  define(72, "F14");
  define(73, "F15");
  define(74, "F16");
  define(75, "F17");
  define(76, "F18");
  define(77, "F19");
  define(78, "NumLock");
  define(79, "ScrollLock");
  define(80, ";", ";", "OEM_1");
  define(81, "=", "=", "OEM_PLUS");
  define(82, ",", ",", "OEM_COMMA");
  define(83, "-", "-", "OEM_MINUS");
  define(84, ".", ".", "OEM_PERIOD");
  define(85, "/", "/", "OEM_2");
  define(86, "`", "`", "OEM_3");
  define(110, "ABNT_C1");
  define(111, "ABNT_C2");
  define(87, "[", "[", "OEM_4");
  define(88, "\\", "\\", "OEM_5");
  define(89, "]", "]", "OEM_6");
  define(90, "'", "'", "OEM_7");
  define(91, "OEM_8");
  define(92, "OEM_102");
  define(93, "NumPad0");
  define(94, "NumPad1");
  define(95, "NumPad2");
  define(96, "NumPad3");
  define(97, "NumPad4");
  define(98, "NumPad5");
  define(99, "NumPad6");
  define(100, "NumPad7");
  define(101, "NumPad8");
  define(102, "NumPad9");
  define(103, "NumPad_Multiply");
  define(104, "NumPad_Add");
  define(105, "NumPad_Separator");
  define(106, "NumPad_Subtract");
  define(107, "NumPad_Decimal");
  define(108, "NumPad_Divide");
})();
var KeyCodeUtils;
(function(KeyCodeUtils2) {
  function toString(keyCode) {
    return uiMap.keyCodeToStr(keyCode);
  }
  KeyCodeUtils2.toString = toString;
  function fromString(key) {
    return uiMap.strToKeyCode(key);
  }
  KeyCodeUtils2.fromString = fromString;
  function toUserSettingsUS(keyCode) {
    return userSettingsUSMap.keyCodeToStr(keyCode);
  }
  KeyCodeUtils2.toUserSettingsUS = toUserSettingsUS;
  function toUserSettingsGeneral(keyCode) {
    return userSettingsGeneralMap.keyCodeToStr(keyCode);
  }
  KeyCodeUtils2.toUserSettingsGeneral = toUserSettingsGeneral;
  function fromUserSettings(key) {
    return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
  }
  KeyCodeUtils2.fromUserSettings = fromUserSettings;
})(KeyCodeUtils || (KeyCodeUtils = {}));
function KeyChord(firstPart, secondPart) {
  const chordPart = (secondPart & 65535) << 16 >>> 0;
  return (firstPart | chordPart) >>> 0;
}
function createKeybinding(keybinding, OS2) {
  if (keybinding === 0) {
    return null;
  }
  const firstPart = (keybinding & 65535) >>> 0;
  const chordPart = (keybinding & 4294901760) >>> 16;
  if (chordPart !== 0) {
    return new ChordKeybinding([
      createSimpleKeybinding(firstPart, OS2),
      createSimpleKeybinding(chordPart, OS2)
    ]);
  }
  return new ChordKeybinding([createSimpleKeybinding(firstPart, OS2)]);
}
function createSimpleKeybinding(keybinding, OS2) {
  const ctrlCmd = keybinding & 2048 ? true : false;
  const winCtrl = keybinding & 256 ? true : false;
  const ctrlKey = OS2 === 2 ? winCtrl : ctrlCmd;
  const shiftKey = keybinding & 1024 ? true : false;
  const altKey = keybinding & 512 ? true : false;
  const metaKey = OS2 === 2 ? ctrlCmd : winCtrl;
  const keyCode = keybinding & 255;
  return new SimpleKeybinding(ctrlKey, shiftKey, altKey, metaKey, keyCode);
}
var SimpleKeybinding = class {
  constructor(ctrlKey, shiftKey, altKey, metaKey, keyCode) {
    this.ctrlKey = ctrlKey;
    this.shiftKey = shiftKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    this.keyCode = keyCode;
  }
  equals(other) {
    return this.ctrlKey === other.ctrlKey && this.shiftKey === other.shiftKey && this.altKey === other.altKey && this.metaKey === other.metaKey && this.keyCode === other.keyCode;
  }
  isModifierKey() {
    return this.keyCode === 0 || this.keyCode === 5 || this.keyCode === 57 || this.keyCode === 6 || this.keyCode === 4;
  }
  toChord() {
    return new ChordKeybinding([this]);
  }
  isDuplicateModifierCase() {
    return this.ctrlKey && this.keyCode === 5 || this.shiftKey && this.keyCode === 4 || this.altKey && this.keyCode === 6 || this.metaKey && this.keyCode === 57;
  }
};
var ChordKeybinding = class {
  constructor(parts) {
    if (parts.length === 0) {
      throw illegalArgument(`parts`);
    }
    this.parts = parts;
  }
};
var ResolvedKeybindingPart = class {
  constructor(ctrlKey, shiftKey, altKey, metaKey, kbLabel, kbAriaLabel) {
    this.ctrlKey = ctrlKey;
    this.shiftKey = shiftKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    this.keyLabel = kbLabel;
    this.keyAriaLabel = kbAriaLabel;
  }
};
var ResolvedKeybinding = class {
};

// ../../node_modules/monaco-editor/esm/vs/base/common/process.js
var safeProcess = typeof process === "undefined" ? {
  cwd() {
    return "/";
  },
  env: Object.create(null),
  get platform() {
    return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
  },
  nextTick(callback) {
    return setImmediate(callback);
  }
} : process;
var cwd = safeProcess.cwd;
var env = safeProcess.env;
var platform2 = safeProcess.platform;

// ../../node_modules/monaco-editor/esm/vs/base/common/path.js
var CHAR_UPPERCASE_A = 65;
var CHAR_LOWERCASE_A = 97;
var CHAR_UPPERCASE_Z = 90;
var CHAR_LOWERCASE_Z = 122;
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_COLON = 58;
var CHAR_QUESTION_MARK = 63;
var ErrorInvalidArgType = class extends Error {
  constructor(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && expected.indexOf("not ") === 0) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    const type = name.indexOf(".") !== -1 ? "property" : "argument";
    let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
    msg += `. Received type ${typeof actual}`;
    super(msg);
    this.code = "ERR_INVALID_ARG_TYPE";
  }
};
function validateString(value, name) {
  if (typeof value !== "string") {
    throw new ErrorInvalidArgType(name, "string", value);
  }
}
function isPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
}
function isPosixPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH;
}
function isWindowsDeviceRoot(code) {
  return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator2) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = 0;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (isPathSeparator2(code)) {
      break;
    } else {
      code = CHAR_FORWARD_SLASH;
    }
    if (isPathSeparator2(code)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length !== 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? `${separator}..` : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `${separator}${path.slice(lastSlash + 1, i)}`;
        } else {
          res = path.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format2(sep2, pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new ErrorInvalidArgType("pathObject", "Object", pathObject);
  }
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
  if (!dir) {
    return base;
  }
  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;
}
var win32 = {
  resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for (let i = pathSegments.length - 1; i >= -1; i--) {
      let path;
      if (i >= 0) {
        path = pathSegments[i];
        validateString(path, "path");
        if (path.length === 0) {
          continue;
        }
      } else if (resolvedDevice.length === 0) {
        path = cwd();
      } else {
        path = env[`=${resolvedDevice}`] || cwd();
        if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
          path = `${resolvedDevice}\\`;
        }
      }
      const len = path.length;
      let rootEnd = 0;
      let device = "";
      let isAbsolute = false;
      const code = path.charCodeAt(0);
      if (len === 1) {
        if (isPathSeparator(code)) {
          rootEnd = 1;
          isAbsolute = true;
        }
      } else if (isPathSeparator(code)) {
        isAbsolute = true;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            const firstPart = path.slice(last, j);
            last = j;
            while (j < len && isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j === len || j !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
        device = path.slice(0, 2);
        rootEnd = 2;
        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
          isAbsolute = true;
          rootEnd = 3;
        }
      }
      if (device.length > 0) {
        if (resolvedDevice.length > 0) {
          if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
          }
        } else {
          resolvedDevice = device;
        }
      }
      if (resolvedAbsolute) {
        if (resolvedDevice.length > 0) {
          break;
        }
      } else {
        resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
        resolvedAbsolute = isAbsolute;
        if (isAbsolute && resolvedDevice.length > 0) {
          break;
        }
      }
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
  },
  normalize(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return ".";
    }
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len === 1) {
      return isPosixPathSeparator(code) ? "\\" : path;
    }
    if (isPathSeparator(code)) {
      isAbsolute = true;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          const firstPart = path.slice(last, j);
          last = j;
          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path.slice(last)}\\`;
            }
            if (j !== last) {
              device = `\\\\${firstPart}\\${path.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
      device = path.slice(0, 2);
      rootEnd = 2;
      if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
        isAbsolute = true;
        rootEnd = 3;
      }
    }
    let tail3 = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator) : "";
    if (tail3.length === 0 && !isAbsolute) {
      tail3 = ".";
    }
    if (tail3.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
      tail3 += "\\";
    }
    if (device === void 0) {
      return isAbsolute ? `\\${tail3}` : tail3;
    }
    return isAbsolute ? `${device}\\${tail3}` : `${device}${tail3}`;
  },
  isAbsolute(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return false;
    }
    const code = path.charCodeAt(0);
    return isPathSeparator(code) || len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
  },
  join(...paths4) {
    if (paths4.length === 0) {
      return ".";
    }
    let joined;
    let firstPart;
    for (let i = 0; i < paths4.length; ++i) {
      const arg = paths4[i];
      validateString(arg, "path");
      if (arg.length > 0) {
        if (joined === void 0) {
          joined = firstPart = arg;
        } else {
          joined += `\\${arg}`;
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    let needsReplace = true;
    let slashCount = 0;
    if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
      ++slashCount;
      const firstLen = firstPart.length;
      if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2))) {
            ++slashCount;
          } else {
            needsReplace = false;
          }
        }
      }
    }
    if (needsReplace) {
      while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
        slashCount++;
      }
      if (slashCount >= 2) {
        joined = `\\${joined.slice(slashCount)}`;
      }
    }
    return win32.normalize(joined);
  },
  relative(from, to) {
    validateString(from, "from");
    validateString(to, "to");
    if (from === to) {
      return "";
    }
    const fromOrig = win32.resolve(from);
    const toOrig = win32.resolve(to);
    if (fromOrig === toOrig) {
      return "";
    }
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) {
      return "";
    }
    let fromStart = 0;
    while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
      fromStart++;
    }
    let fromEnd = from.length;
    while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
      fromEnd--;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
      toStart++;
    }
    let toEnd = to.length;
    while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
      toEnd--;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);
      if (fromCode !== to.charCodeAt(toStart + i)) {
        break;
      } else if (fromCode === CHAR_BACKWARD_SLASH) {
        lastCommonSep = i;
      }
    }
    if (i !== length) {
      if (lastCommonSep === -1) {
        return toOrig;
      }
    } else {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
          return toOrig.slice(toStart + i + 1);
        }
        if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      if (lastCommonSep === -1) {
        lastCommonSep = 0;
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
        out += out.length === 0 ? ".." : "\\..";
      }
    }
    toStart += lastCommonSep;
    if (out.length > 0) {
      return `${out}${toOrig.slice(toStart, toEnd)}`;
    }
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
      ++toStart;
    }
    return toOrig.slice(toStart, toEnd);
  },
  toNamespacedPath(path) {
    if (typeof path !== "string") {
      return path;
    }
    if (path.length === 0) {
      return "";
    }
    const resolvedPath = win32.resolve(path);
    if (resolvedPath.length <= 2) {
      return path;
    }
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
        const code = resolvedPath.charCodeAt(2);
        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
      return `\\\\?\\${resolvedPath}`;
    }
    return path;
  },
  dirname(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return ".";
    }
    let rootEnd = -1;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len === 1) {
      return isPathSeparator(code) ? path : ".";
    }
    if (isPathSeparator(code)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          last = j;
          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              return path;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
      rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
      offset = rootEnd;
    }
    let end = -1;
    let matchedSlash = true;
    for (let i = len - 1; i >= offset; --i) {
      if (isPathSeparator(path.charCodeAt(i))) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1) {
      if (rootEnd === -1) {
        return ".";
      }
      end = rootEnd;
    }
    return path.slice(0, end);
  },
  basename(path, ext) {
    if (ext !== void 0) {
      validateString(ext, "ext");
    }
    validateString(path, "path");
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
      start = 2;
    }
    if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
      if (ext === path) {
        return "";
      }
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= start; --i) {
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end === -1) {
        end = path.length;
      }
      return path.slice(start, end);
    }
    for (i = path.length - 1; i >= start; --i) {
      if (isPathSeparator(path.charCodeAt(i))) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1) {
      return "";
    }
    return path.slice(start, end);
  },
  extname(path) {
    validateString(path, "path");
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
      start = startPart = 2;
    }
    for (let i = path.length - 1; i >= start; --i) {
      const code = path.charCodeAt(i);
      if (isPathSeparator(code)) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end);
  },
  format: _format2.bind(null, "\\"),
  parse(path) {
    validateString(path, "path");
    const ret = {root: "", dir: "", base: "", ext: "", name: ""};
    if (path.length === 0) {
      return ret;
    }
    const len = path.length;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len === 1) {
      if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        return ret;
      }
      ret.base = ret.name = path;
      return ret;
    }
    if (isPathSeparator(code)) {
      rootEnd = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          last = j;
          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
      if (len <= 2) {
        ret.root = ret.dir = path;
        return ret;
      }
      rootEnd = 2;
      if (isPathSeparator(path.charCodeAt(2))) {
        if (len === 3) {
          ret.root = ret.dir = path;
          return ret;
        }
        rootEnd = 3;
      }
    }
    if (rootEnd > 0) {
      ret.root = path.slice(0, rootEnd);
    }
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (; i >= rootEnd; --i) {
      code = path.charCodeAt(i);
      if (isPathSeparator(code)) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (end !== -1) {
      if (startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        ret.base = ret.name = path.slice(startPart, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
      }
    }
    if (startPart > 0 && startPart !== rootEnd) {
      ret.dir = path.slice(0, startPart - 1);
    } else {
      ret.dir = ret.root;
    }
    return ret;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
};
var posix = {
  resolve(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      const path = i >= 0 ? pathSegments[i] : cwd();
      validateString(path, "path");
      if (path.length === 0) {
        continue;
      }
      resolvedPath = `${path}/${resolvedPath}`;
      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
      return `/${resolvedPath}`;
    }
    return resolvedPath.length > 0 ? resolvedPath : ".";
  },
  normalize(path) {
    validateString(path, "path");
    if (path.length === 0) {
      return ".";
    }
    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0) {
      if (isAbsolute) {
        return "/";
      }
      return trailingSeparator ? "./" : ".";
    }
    if (trailingSeparator) {
      path += "/";
    }
    return isAbsolute ? `/${path}` : path;
  },
  isAbsolute(path) {
    validateString(path, "path");
    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
  },
  join(...paths4) {
    if (paths4.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0; i < paths4.length; ++i) {
      const arg = paths4[i];
      validateString(arg, "path");
      if (arg.length > 0) {
        if (joined === void 0) {
          joined = arg;
        } else {
          joined += `/${arg}`;
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return posix.normalize(joined);
  },
  relative(from, to) {
    validateString(from, "from");
    validateString(to, "to");
    if (from === to) {
      return "";
    }
    from = posix.resolve(from);
    to = posix.resolve(to);
    if (from === to) {
      return "";
    }
    const fromStart = 1;
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    const toStart = 1;
    const toLen = to.length - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);
      if (fromCode !== to.charCodeAt(toStart + i)) {
        break;
      } else if (fromCode === CHAR_FORWARD_SLASH) {
        lastCommonSep = i;
      }
    }
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
          return to.slice(toStart + i + 1);
        }
        if (i === 0) {
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        out += out.length === 0 ? ".." : "/..";
      }
    }
    return `${out}${to.slice(toStart + lastCommonSep)}`;
  },
  toNamespacedPath(path) {
    return path;
  },
  dirname(path) {
    validateString(path, "path");
    if (path.length === 0) {
      return ".";
    }
    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let end = -1;
    let matchedSlash = true;
    for (let i = path.length - 1; i >= 1; --i) {
      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1) {
      return hasRoot ? "/" : ".";
    }
    if (hasRoot && end === 1) {
      return "//";
    }
    return path.slice(0, end);
  },
  basename(path, ext) {
    if (ext !== void 0) {
      validateString(ext, "ext");
    }
    validateString(path, "path");
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
      if (ext === path) {
        return "";
      }
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        const code = path.charCodeAt(i);
        if (code === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end === -1) {
        end = path.length;
      }
      return path.slice(start, end);
    }
    for (i = path.length - 1; i >= 0; --i) {
      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1) {
      return "";
    }
    return path.slice(start, end);
  },
  extname(path) {
    validateString(path, "path");
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path.length - 1; i >= 0; --i) {
      const code = path.charCodeAt(i);
      if (code === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end);
  },
  format: _format2.bind(null, "/"),
  parse(path) {
    validateString(path, "path");
    const ret = {root: "", dir: "", base: "", ext: "", name: ""};
    if (path.length === 0) {
      return ret;
    }
    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let start;
    if (isAbsolute) {
      ret.root = "/";
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (; i >= start; --i) {
      const code = path.charCodeAt(i);
      if (code === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (end !== -1) {
      const start2 = startPart === 0 && isAbsolute ? 1 : startPart;
      if (startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        ret.base = ret.name = path.slice(start2, end);
      } else {
        ret.name = path.slice(start2, startDot);
        ret.base = path.slice(start2, end);
        ret.ext = path.slice(startDot, end);
      }
    }
    if (startPart > 0) {
      ret.dir = path.slice(0, startPart - 1);
    } else if (isAbsolute) {
      ret.dir = "/";
    }
    return ret;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
posix.win32 = win32.win32 = win32;
posix.posix = win32.posix = posix;
var normalize = platform2 === "win32" ? win32.normalize : posix.normalize;
var resolve = platform2 === "win32" ? win32.resolve : posix.resolve;
var relative = platform2 === "win32" ? win32.relative : posix.relative;
var dirname = platform2 === "win32" ? win32.dirname : posix.dirname;
var basename = platform2 === "win32" ? win32.basename : posix.basename;
var extname = platform2 === "win32" ? win32.extname : posix.extname;
var sep = platform2 === "win32" ? win32.sep : posix.sep;

// ../../node_modules/monaco-editor/esm/vs/base/common/uri.js
var _schemePattern = /^\w[\w\d+.-]*$/;
var _singleSlashStart = /^\//;
var _doubleSlashStart = /^\/\//;
function _validateUri(ret, _strict) {
  if (!ret.scheme && _strict) {
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
  }
  if (ret.scheme && !_schemePattern.test(ret.scheme)) {
    throw new Error("[UriError]: Scheme contains illegal characters.");
  }
  if (ret.path) {
    if (ret.authority) {
      if (!_singleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      }
    } else {
      if (_doubleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
  }
}
function _schemeFix(scheme, _strict) {
  if (!scheme && !_strict) {
    return "file";
  }
  return scheme;
}
function _referenceResolution(scheme, path) {
  switch (scheme) {
    case "https":
    case "http":
    case "file":
      if (!path) {
        path = _slash;
      } else if (path[0] !== _slash) {
        path = _slash + path;
      }
      break;
  }
  return path;
}
var _empty = "";
var _slash = "/";
var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
var URI = class {
  constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
    if (typeof schemeOrData === "object") {
      this.scheme = schemeOrData.scheme || _empty;
      this.authority = schemeOrData.authority || _empty;
      this.path = schemeOrData.path || _empty;
      this.query = schemeOrData.query || _empty;
      this.fragment = schemeOrData.fragment || _empty;
    } else {
      this.scheme = _schemeFix(schemeOrData, _strict);
      this.authority = authority || _empty;
      this.path = _referenceResolution(this.scheme, path || _empty);
      this.query = query || _empty;
      this.fragment = fragment || _empty;
      _validateUri(this, _strict);
    }
  }
  static isUri(thing) {
    if (thing instanceof URI) {
      return true;
    }
    if (!thing) {
      return false;
    }
    return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "function" && typeof thing.with === "function" && typeof thing.toString === "function";
  }
  get fsPath() {
    return uriToFsPath(this, false);
  }
  with(change) {
    if (!change) {
      return this;
    }
    let {scheme, authority, path, query, fragment} = change;
    if (scheme === void 0) {
      scheme = this.scheme;
    } else if (scheme === null) {
      scheme = _empty;
    }
    if (authority === void 0) {
      authority = this.authority;
    } else if (authority === null) {
      authority = _empty;
    }
    if (path === void 0) {
      path = this.path;
    } else if (path === null) {
      path = _empty;
    }
    if (query === void 0) {
      query = this.query;
    } else if (query === null) {
      query = _empty;
    }
    if (fragment === void 0) {
      fragment = this.fragment;
    } else if (fragment === null) {
      fragment = _empty;
    }
    if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
      return this;
    }
    return new Uri(scheme, authority, path, query, fragment);
  }
  static parse(value, _strict = false) {
    const match2 = _regexp.exec(value);
    if (!match2) {
      return new Uri(_empty, _empty, _empty, _empty, _empty);
    }
    return new Uri(match2[2] || _empty, percentDecode(match2[4] || _empty), percentDecode(match2[5] || _empty), percentDecode(match2[7] || _empty), percentDecode(match2[9] || _empty), _strict);
  }
  static file(path) {
    let authority = _empty;
    if (isWindows) {
      path = path.replace(/\\/g, _slash);
    }
    if (path[0] === _slash && path[1] === _slash) {
      const idx = path.indexOf(_slash, 2);
      if (idx === -1) {
        authority = path.substring(2);
        path = _slash;
      } else {
        authority = path.substring(2, idx);
        path = path.substring(idx) || _slash;
      }
    }
    return new Uri("file", authority, path, _empty, _empty);
  }
  static from(components) {
    return new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);
  }
  static joinPath(uri, ...pathFragment) {
    if (!uri.path) {
      throw new Error(`[UriError]: cannot call joinPaths on URI without path`);
    }
    let newPath;
    if (isWindows && uri.scheme === "file") {
      newPath = URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
    } else {
      newPath = posix.join(uri.path, ...pathFragment);
    }
    return uri.with({path: newPath});
  }
  toString(skipEncoding = false) {
    return _asFormatted(this, skipEncoding);
  }
  toJSON() {
    return this;
  }
  static revive(data) {
    if (!data) {
      return data;
    } else if (data instanceof URI) {
      return data;
    } else {
      const result = new Uri(data);
      result._formatted = data.external;
      result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
      return result;
    }
  }
};
var _pathSepMarker = isWindows ? 1 : void 0;
var Uri = class extends URI {
  constructor() {
    super(...arguments);
    this._formatted = null;
    this._fsPath = null;
  }
  get fsPath() {
    if (!this._fsPath) {
      this._fsPath = uriToFsPath(this, false);
    }
    return this._fsPath;
  }
  toString(skipEncoding = false) {
    if (!skipEncoding) {
      if (!this._formatted) {
        this._formatted = _asFormatted(this, false);
      }
      return this._formatted;
    } else {
      return _asFormatted(this, true);
    }
  }
  toJSON() {
    const res = {
      $mid: 1
    };
    if (this._fsPath) {
      res.fsPath = this._fsPath;
      res._sep = _pathSepMarker;
    }
    if (this._formatted) {
      res.external = this._formatted;
    }
    if (this.path) {
      res.path = this.path;
    }
    if (this.scheme) {
      res.scheme = this.scheme;
    }
    if (this.authority) {
      res.authority = this.authority;
    }
    if (this.query) {
      res.query = this.query;
    }
    if (this.fragment) {
      res.fragment = this.fragment;
    }
    return res;
  }
};
var encodeTable = {
  [58]: "%3A",
  [47]: "%2F",
  [63]: "%3F",
  [35]: "%23",
  [91]: "%5B",
  [93]: "%5D",
  [64]: "%40",
  [33]: "%21",
  [36]: "%24",
  [38]: "%26",
  [39]: "%27",
  [40]: "%28",
  [41]: "%29",
  [42]: "%2A",
  [43]: "%2B",
  [44]: "%2C",
  [59]: "%3B",
  [61]: "%3D",
  [32]: "%20"
};
function encodeURIComponentFast(uriComponent, allowSlash) {
  let res = void 0;
  let nativeEncodePos = -1;
  for (let pos = 0; pos < uriComponent.length; pos++) {
    const code = uriComponent.charCodeAt(pos);
    if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || allowSlash && code === 47) {
      if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
        nativeEncodePos = -1;
      }
      if (res !== void 0) {
        res += uriComponent.charAt(pos);
      }
    } else {
      if (res === void 0) {
        res = uriComponent.substr(0, pos);
      }
      const escaped = encodeTable[code];
      if (escaped !== void 0) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        res += escaped;
      } else if (nativeEncodePos === -1) {
        nativeEncodePos = pos;
      }
    }
  }
  if (nativeEncodePos !== -1) {
    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
  }
  return res !== void 0 ? res : uriComponent;
}
function encodeURIComponentMinimal(path) {
  let res = void 0;
  for (let pos = 0; pos < path.length; pos++) {
    const code = path.charCodeAt(pos);
    if (code === 35 || code === 63) {
      if (res === void 0) {
        res = path.substr(0, pos);
      }
      res += encodeTable[code];
    } else {
      if (res !== void 0) {
        res += path[pos];
      }
    }
  }
  return res !== void 0 ? res : path;
}
function uriToFsPath(uri, keepDriveLetterCasing) {
  let value;
  if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
    value = `//${uri.authority}${uri.path}`;
  } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
    if (!keepDriveLetterCasing) {
      value = uri.path[1].toLowerCase() + uri.path.substr(2);
    } else {
      value = uri.path.substr(1);
    }
  } else {
    value = uri.path;
  }
  if (isWindows) {
    value = value.replace(/\//g, "\\");
  }
  return value;
}
function _asFormatted(uri, skipEncoding) {
  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
  let res = "";
  let {scheme, authority, path, query, fragment} = uri;
  if (scheme) {
    res += scheme;
    res += ":";
  }
  if (authority || scheme === "file") {
    res += _slash;
    res += _slash;
  }
  if (authority) {
    let idx = authority.indexOf("@");
    if (idx !== -1) {
      const userinfo = authority.substr(0, idx);
      authority = authority.substr(idx + 1);
      idx = userinfo.indexOf(":");
      if (idx === -1) {
        res += encoder(userinfo, false);
      } else {
        res += encoder(userinfo.substr(0, idx), false);
        res += ":";
        res += encoder(userinfo.substr(idx + 1), false);
      }
      res += "@";
    }
    authority = authority.toLowerCase();
    idx = authority.indexOf(":");
    if (idx === -1) {
      res += encoder(authority, false);
    } else {
      res += encoder(authority.substr(0, idx), false);
      res += authority.substr(idx);
    }
  }
  if (path) {
    if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
      const code = path.charCodeAt(1);
      if (code >= 65 && code <= 90) {
        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`;
      }
    } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
      const code = path.charCodeAt(0);
      if (code >= 65 && code <= 90) {
        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`;
      }
    }
    res += encoder(path, true);
  }
  if (query) {
    res += "?";
    res += encoder(query, false);
  }
  if (fragment) {
    res += "#";
    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
  }
  return res;
}
function decodeURIComponentGraceful(str) {
  try {
    return decodeURIComponent(str);
  } catch (_a) {
    if (str.length > 3) {
      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
    } else {
      return str;
    }
  }
}
var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function percentDecode(str) {
  if (!str.match(_rEncodedAsHex)) {
    return str;
  }
  return str.replace(_rEncodedAsHex, (match2) => decodeURIComponentGraceful(match2));
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/core/position.js
var Position = class {
  constructor(lineNumber, column) {
    this.lineNumber = lineNumber;
    this.column = column;
  }
  with(newLineNumber = this.lineNumber, newColumn = this.column) {
    if (newLineNumber === this.lineNumber && newColumn === this.column) {
      return this;
    } else {
      return new Position(newLineNumber, newColumn);
    }
  }
  delta(deltaLineNumber = 0, deltaColumn = 0) {
    return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
  }
  equals(other) {
    return Position.equals(this, other);
  }
  static equals(a, b) {
    if (!a && !b) {
      return true;
    }
    return !!a && !!b && a.lineNumber === b.lineNumber && a.column === b.column;
  }
  isBefore(other) {
    return Position.isBefore(this, other);
  }
  static isBefore(a, b) {
    if (a.lineNumber < b.lineNumber) {
      return true;
    }
    if (b.lineNumber < a.lineNumber) {
      return false;
    }
    return a.column < b.column;
  }
  isBeforeOrEqual(other) {
    return Position.isBeforeOrEqual(this, other);
  }
  static isBeforeOrEqual(a, b) {
    if (a.lineNumber < b.lineNumber) {
      return true;
    }
    if (b.lineNumber < a.lineNumber) {
      return false;
    }
    return a.column <= b.column;
  }
  static compare(a, b) {
    let aLineNumber = a.lineNumber | 0;
    let bLineNumber = b.lineNumber | 0;
    if (aLineNumber === bLineNumber) {
      let aColumn = a.column | 0;
      let bColumn = b.column | 0;
      return aColumn - bColumn;
    }
    return aLineNumber - bLineNumber;
  }
  clone() {
    return new Position(this.lineNumber, this.column);
  }
  toString() {
    return "(" + this.lineNumber + "," + this.column + ")";
  }
  static lift(pos) {
    return new Position(pos.lineNumber, pos.column);
  }
  static isIPosition(obj) {
    return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/core/range.js
var Range = class {
  constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
    if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
      this.startLineNumber = endLineNumber;
      this.startColumn = endColumn;
      this.endLineNumber = startLineNumber;
      this.endColumn = startColumn;
    } else {
      this.startLineNumber = startLineNumber;
      this.startColumn = startColumn;
      this.endLineNumber = endLineNumber;
      this.endColumn = endColumn;
    }
  }
  isEmpty() {
    return Range.isEmpty(this);
  }
  static isEmpty(range2) {
    return range2.startLineNumber === range2.endLineNumber && range2.startColumn === range2.endColumn;
  }
  containsPosition(position) {
    return Range.containsPosition(this, position);
  }
  static containsPosition(range2, position) {
    if (position.lineNumber < range2.startLineNumber || position.lineNumber > range2.endLineNumber) {
      return false;
    }
    if (position.lineNumber === range2.startLineNumber && position.column < range2.startColumn) {
      return false;
    }
    if (position.lineNumber === range2.endLineNumber && position.column > range2.endColumn) {
      return false;
    }
    return true;
  }
  containsRange(range2) {
    return Range.containsRange(this, range2);
  }
  static containsRange(range2, otherRange) {
    if (otherRange.startLineNumber < range2.startLineNumber || otherRange.endLineNumber < range2.startLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber > range2.endLineNumber || otherRange.endLineNumber > range2.endLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber === range2.startLineNumber && otherRange.startColumn < range2.startColumn) {
      return false;
    }
    if (otherRange.endLineNumber === range2.endLineNumber && otherRange.endColumn > range2.endColumn) {
      return false;
    }
    return true;
  }
  strictContainsRange(range2) {
    return Range.strictContainsRange(this, range2);
  }
  static strictContainsRange(range2, otherRange) {
    if (otherRange.startLineNumber < range2.startLineNumber || otherRange.endLineNumber < range2.startLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber > range2.endLineNumber || otherRange.endLineNumber > range2.endLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber === range2.startLineNumber && otherRange.startColumn <= range2.startColumn) {
      return false;
    }
    if (otherRange.endLineNumber === range2.endLineNumber && otherRange.endColumn >= range2.endColumn) {
      return false;
    }
    return true;
  }
  plusRange(range2) {
    return Range.plusRange(this, range2);
  }
  static plusRange(a, b) {
    let startLineNumber;
    let startColumn;
    let endLineNumber;
    let endColumn;
    if (b.startLineNumber < a.startLineNumber) {
      startLineNumber = b.startLineNumber;
      startColumn = b.startColumn;
    } else if (b.startLineNumber === a.startLineNumber) {
      startLineNumber = b.startLineNumber;
      startColumn = Math.min(b.startColumn, a.startColumn);
    } else {
      startLineNumber = a.startLineNumber;
      startColumn = a.startColumn;
    }
    if (b.endLineNumber > a.endLineNumber) {
      endLineNumber = b.endLineNumber;
      endColumn = b.endColumn;
    } else if (b.endLineNumber === a.endLineNumber) {
      endLineNumber = b.endLineNumber;
      endColumn = Math.max(b.endColumn, a.endColumn);
    } else {
      endLineNumber = a.endLineNumber;
      endColumn = a.endColumn;
    }
    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
  }
  intersectRanges(range2) {
    return Range.intersectRanges(this, range2);
  }
  static intersectRanges(a, b) {
    let resultStartLineNumber = a.startLineNumber;
    let resultStartColumn = a.startColumn;
    let resultEndLineNumber = a.endLineNumber;
    let resultEndColumn = a.endColumn;
    let otherStartLineNumber = b.startLineNumber;
    let otherStartColumn = b.startColumn;
    let otherEndLineNumber = b.endLineNumber;
    let otherEndColumn = b.endColumn;
    if (resultStartLineNumber < otherStartLineNumber) {
      resultStartLineNumber = otherStartLineNumber;
      resultStartColumn = otherStartColumn;
    } else if (resultStartLineNumber === otherStartLineNumber) {
      resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
    }
    if (resultEndLineNumber > otherEndLineNumber) {
      resultEndLineNumber = otherEndLineNumber;
      resultEndColumn = otherEndColumn;
    } else if (resultEndLineNumber === otherEndLineNumber) {
      resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
    }
    if (resultStartLineNumber > resultEndLineNumber) {
      return null;
    }
    if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
      return null;
    }
    return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
  }
  equalsRange(other) {
    return Range.equalsRange(this, other);
  }
  static equalsRange(a, b) {
    return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;
  }
  getEndPosition() {
    return Range.getEndPosition(this);
  }
  static getEndPosition(range2) {
    return new Position(range2.endLineNumber, range2.endColumn);
  }
  getStartPosition() {
    return Range.getStartPosition(this);
  }
  static getStartPosition(range2) {
    return new Position(range2.startLineNumber, range2.startColumn);
  }
  toString() {
    return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
  }
  setEndPosition(endLineNumber, endColumn) {
    return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
  }
  setStartPosition(startLineNumber, startColumn) {
    return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
  }
  collapseToStart() {
    return Range.collapseToStart(this);
  }
  static collapseToStart(range2) {
    return new Range(range2.startLineNumber, range2.startColumn, range2.startLineNumber, range2.startColumn);
  }
  static fromPositions(start, end = start) {
    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
  }
  static lift(range2) {
    if (!range2) {
      return null;
    }
    return new Range(range2.startLineNumber, range2.startColumn, range2.endLineNumber, range2.endColumn);
  }
  static isIRange(obj) {
    return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
  }
  static areIntersectingOrTouching(a, b) {
    if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {
      return false;
    }
    if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {
      return false;
    }
    return true;
  }
  static areIntersecting(a, b) {
    if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {
      return false;
    }
    if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {
      return false;
    }
    return true;
  }
  static compareRangesUsingStarts(a, b) {
    if (a && b) {
      const aStartLineNumber = a.startLineNumber | 0;
      const bStartLineNumber = b.startLineNumber | 0;
      if (aStartLineNumber === bStartLineNumber) {
        const aStartColumn = a.startColumn | 0;
        const bStartColumn = b.startColumn | 0;
        if (aStartColumn === bStartColumn) {
          const aEndLineNumber = a.endLineNumber | 0;
          const bEndLineNumber = b.endLineNumber | 0;
          if (aEndLineNumber === bEndLineNumber) {
            const aEndColumn = a.endColumn | 0;
            const bEndColumn = b.endColumn | 0;
            return aEndColumn - bEndColumn;
          }
          return aEndLineNumber - bEndLineNumber;
        }
        return aStartColumn - bStartColumn;
      }
      return aStartLineNumber - bStartLineNumber;
    }
    const aExists = a ? 1 : 0;
    const bExists = b ? 1 : 0;
    return aExists - bExists;
  }
  static compareRangesUsingEnds(a, b) {
    if (a.endLineNumber === b.endLineNumber) {
      if (a.endColumn === b.endColumn) {
        if (a.startLineNumber === b.startLineNumber) {
          return a.startColumn - b.startColumn;
        }
        return a.startLineNumber - b.startLineNumber;
      }
      return a.endColumn - b.endColumn;
    }
    return a.endLineNumber - b.endLineNumber;
  }
  static spansMultipleLines(range2) {
    return range2.endLineNumber > range2.startLineNumber;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/core/selection.js
var Selection = class extends Range {
  constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
    super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
    this.selectionStartLineNumber = selectionStartLineNumber;
    this.selectionStartColumn = selectionStartColumn;
    this.positionLineNumber = positionLineNumber;
    this.positionColumn = positionColumn;
  }
  toString() {
    return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
  }
  equalsSelection(other) {
    return Selection.selectionsEqual(this, other);
  }
  static selectionsEqual(a, b) {
    return a.selectionStartLineNumber === b.selectionStartLineNumber && a.selectionStartColumn === b.selectionStartColumn && a.positionLineNumber === b.positionLineNumber && a.positionColumn === b.positionColumn;
  }
  getDirection() {
    if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
      return 0;
    }
    return 1;
  }
  setEndPosition(endLineNumber, endColumn) {
    if (this.getDirection() === 0) {
      return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
    }
    return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
  }
  getPosition() {
    return new Position(this.positionLineNumber, this.positionColumn);
  }
  setStartPosition(startLineNumber, startColumn) {
    if (this.getDirection() === 0) {
      return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
    }
    return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
  }
  static fromPositions(start, end = start) {
    return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);
  }
  static liftSelection(sel) {
    return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
  }
  static selectionsArrEqual(a, b) {
    if (a && !b || !a && b) {
      return false;
    }
    if (!a && !b) {
      return true;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0, len = a.length; i < len; i++) {
      if (!this.selectionsEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  static isISelection(obj) {
    return obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
  }
  static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
    if (direction === 0) {
      return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/core/token.js
var Token = class {
  constructor(offset, type, language) {
    this.offset = offset | 0;
    this.type = type;
    this.language = language;
  }
  toString() {
    return "(" + this.offset + ", " + this.type + ")";
  }
};
var TokenizationResult = class {
  constructor(tokens, endState) {
    this.tokens = tokens;
    this.endState = endState;
  }
};
var TokenizationResult2 = class {
  constructor(tokens, endState) {
    this.tokens = tokens;
    this.endState = endState;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js
var AccessibilitySupport;
(function(AccessibilitySupport2) {
  AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
  AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
  AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
})(AccessibilitySupport || (AccessibilitySupport = {}));
var CompletionItemInsertTextRule;
(function(CompletionItemInsertTextRule2) {
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
var CompletionItemKind;
(function(CompletionItemKind2) {
  CompletionItemKind2[CompletionItemKind2["Method"] = 0] = "Method";
  CompletionItemKind2[CompletionItemKind2["Function"] = 1] = "Function";
  CompletionItemKind2[CompletionItemKind2["Constructor"] = 2] = "Constructor";
  CompletionItemKind2[CompletionItemKind2["Field"] = 3] = "Field";
  CompletionItemKind2[CompletionItemKind2["Variable"] = 4] = "Variable";
  CompletionItemKind2[CompletionItemKind2["Class"] = 5] = "Class";
  CompletionItemKind2[CompletionItemKind2["Struct"] = 6] = "Struct";
  CompletionItemKind2[CompletionItemKind2["Interface"] = 7] = "Interface";
  CompletionItemKind2[CompletionItemKind2["Module"] = 8] = "Module";
  CompletionItemKind2[CompletionItemKind2["Property"] = 9] = "Property";
  CompletionItemKind2[CompletionItemKind2["Event"] = 10] = "Event";
  CompletionItemKind2[CompletionItemKind2["Operator"] = 11] = "Operator";
  CompletionItemKind2[CompletionItemKind2["Unit"] = 12] = "Unit";
  CompletionItemKind2[CompletionItemKind2["Value"] = 13] = "Value";
  CompletionItemKind2[CompletionItemKind2["Constant"] = 14] = "Constant";
  CompletionItemKind2[CompletionItemKind2["Enum"] = 15] = "Enum";
  CompletionItemKind2[CompletionItemKind2["EnumMember"] = 16] = "EnumMember";
  CompletionItemKind2[CompletionItemKind2["Keyword"] = 17] = "Keyword";
  CompletionItemKind2[CompletionItemKind2["Text"] = 18] = "Text";
  CompletionItemKind2[CompletionItemKind2["Color"] = 19] = "Color";
  CompletionItemKind2[CompletionItemKind2["File"] = 20] = "File";
  CompletionItemKind2[CompletionItemKind2["Reference"] = 21] = "Reference";
  CompletionItemKind2[CompletionItemKind2["Customcolor"] = 22] = "Customcolor";
  CompletionItemKind2[CompletionItemKind2["Folder"] = 23] = "Folder";
  CompletionItemKind2[CompletionItemKind2["TypeParameter"] = 24] = "TypeParameter";
  CompletionItemKind2[CompletionItemKind2["User"] = 25] = "User";
  CompletionItemKind2[CompletionItemKind2["Issue"] = 26] = "Issue";
  CompletionItemKind2[CompletionItemKind2["Snippet"] = 27] = "Snippet";
})(CompletionItemKind || (CompletionItemKind = {}));
var CompletionItemTag;
(function(CompletionItemTag2) {
  CompletionItemTag2[CompletionItemTag2["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag || (CompletionItemTag = {}));
var CompletionTriggerKind;
(function(CompletionTriggerKind2) {
  CompletionTriggerKind2[CompletionTriggerKind2["Invoke"] = 0] = "Invoke";
  CompletionTriggerKind2[CompletionTriggerKind2["TriggerCharacter"] = 1] = "TriggerCharacter";
  CompletionTriggerKind2[CompletionTriggerKind2["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind || (CompletionTriggerKind = {}));
var ContentWidgetPositionPreference;
(function(ContentWidgetPositionPreference2) {
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["EXACT"] = 0] = "EXACT";
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["ABOVE"] = 1] = "ABOVE";
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["BELOW"] = 2] = "BELOW";
})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
var CursorChangeReason;
(function(CursorChangeReason2) {
  CursorChangeReason2[CursorChangeReason2["NotSet"] = 0] = "NotSet";
  CursorChangeReason2[CursorChangeReason2["ContentFlush"] = 1] = "ContentFlush";
  CursorChangeReason2[CursorChangeReason2["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
  CursorChangeReason2[CursorChangeReason2["Explicit"] = 3] = "Explicit";
  CursorChangeReason2[CursorChangeReason2["Paste"] = 4] = "Paste";
  CursorChangeReason2[CursorChangeReason2["Undo"] = 5] = "Undo";
  CursorChangeReason2[CursorChangeReason2["Redo"] = 6] = "Redo";
})(CursorChangeReason || (CursorChangeReason = {}));
var DefaultEndOfLine;
(function(DefaultEndOfLine2) {
  DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
  DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
})(DefaultEndOfLine || (DefaultEndOfLine = {}));
var DocumentHighlightKind;
(function(DocumentHighlightKind3) {
  DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
  DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
  DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
var EditorAutoIndentStrategy;
(function(EditorAutoIndentStrategy2) {
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
var EditorOption;
(function(EditorOption2) {
  EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
  EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
  EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
  EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
  EditorOption2[EditorOption2["ariaLabel"] = 4] = "ariaLabel";
  EditorOption2[EditorOption2["autoClosingBrackets"] = 5] = "autoClosingBrackets";
  EditorOption2[EditorOption2["autoClosingOvertype"] = 6] = "autoClosingOvertype";
  EditorOption2[EditorOption2["autoClosingQuotes"] = 7] = "autoClosingQuotes";
  EditorOption2[EditorOption2["autoIndent"] = 8] = "autoIndent";
  EditorOption2[EditorOption2["automaticLayout"] = 9] = "automaticLayout";
  EditorOption2[EditorOption2["autoSurround"] = 10] = "autoSurround";
  EditorOption2[EditorOption2["codeLens"] = 11] = "codeLens";
  EditorOption2[EditorOption2["colorDecorators"] = 12] = "colorDecorators";
  EditorOption2[EditorOption2["columnSelection"] = 13] = "columnSelection";
  EditorOption2[EditorOption2["comments"] = 14] = "comments";
  EditorOption2[EditorOption2["contextmenu"] = 15] = "contextmenu";
  EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 16] = "copyWithSyntaxHighlighting";
  EditorOption2[EditorOption2["cursorBlinking"] = 17] = "cursorBlinking";
  EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 18] = "cursorSmoothCaretAnimation";
  EditorOption2[EditorOption2["cursorStyle"] = 19] = "cursorStyle";
  EditorOption2[EditorOption2["cursorSurroundingLines"] = 20] = "cursorSurroundingLines";
  EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 21] = "cursorSurroundingLinesStyle";
  EditorOption2[EditorOption2["cursorWidth"] = 22] = "cursorWidth";
  EditorOption2[EditorOption2["disableLayerHinting"] = 23] = "disableLayerHinting";
  EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 24] = "disableMonospaceOptimizations";
  EditorOption2[EditorOption2["dragAndDrop"] = 25] = "dragAndDrop";
  EditorOption2[EditorOption2["emptySelectionClipboard"] = 26] = "emptySelectionClipboard";
  EditorOption2[EditorOption2["extraEditorClassName"] = 27] = "extraEditorClassName";
  EditorOption2[EditorOption2["fastScrollSensitivity"] = 28] = "fastScrollSensitivity";
  EditorOption2[EditorOption2["find"] = 29] = "find";
  EditorOption2[EditorOption2["fixedOverflowWidgets"] = 30] = "fixedOverflowWidgets";
  EditorOption2[EditorOption2["folding"] = 31] = "folding";
  EditorOption2[EditorOption2["foldingStrategy"] = 32] = "foldingStrategy";
  EditorOption2[EditorOption2["foldingHighlight"] = 33] = "foldingHighlight";
  EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 34] = "unfoldOnClickAfterEndOfLine";
  EditorOption2[EditorOption2["fontFamily"] = 35] = "fontFamily";
  EditorOption2[EditorOption2["fontInfo"] = 36] = "fontInfo";
  EditorOption2[EditorOption2["fontLigatures"] = 37] = "fontLigatures";
  EditorOption2[EditorOption2["fontSize"] = 38] = "fontSize";
  EditorOption2[EditorOption2["fontWeight"] = 39] = "fontWeight";
  EditorOption2[EditorOption2["formatOnPaste"] = 40] = "formatOnPaste";
  EditorOption2[EditorOption2["formatOnType"] = 41] = "formatOnType";
  EditorOption2[EditorOption2["glyphMargin"] = 42] = "glyphMargin";
  EditorOption2[EditorOption2["gotoLocation"] = 43] = "gotoLocation";
  EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 44] = "hideCursorInOverviewRuler";
  EditorOption2[EditorOption2["highlightActiveIndentGuide"] = 45] = "highlightActiveIndentGuide";
  EditorOption2[EditorOption2["hover"] = 46] = "hover";
  EditorOption2[EditorOption2["inDiffEditor"] = 47] = "inDiffEditor";
  EditorOption2[EditorOption2["letterSpacing"] = 48] = "letterSpacing";
  EditorOption2[EditorOption2["lightbulb"] = 49] = "lightbulb";
  EditorOption2[EditorOption2["lineDecorationsWidth"] = 50] = "lineDecorationsWidth";
  EditorOption2[EditorOption2["lineHeight"] = 51] = "lineHeight";
  EditorOption2[EditorOption2["lineNumbers"] = 52] = "lineNumbers";
  EditorOption2[EditorOption2["lineNumbersMinChars"] = 53] = "lineNumbersMinChars";
  EditorOption2[EditorOption2["links"] = 54] = "links";
  EditorOption2[EditorOption2["matchBrackets"] = 55] = "matchBrackets";
  EditorOption2[EditorOption2["minimap"] = 56] = "minimap";
  EditorOption2[EditorOption2["mouseStyle"] = 57] = "mouseStyle";
  EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 58] = "mouseWheelScrollSensitivity";
  EditorOption2[EditorOption2["mouseWheelZoom"] = 59] = "mouseWheelZoom";
  EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 60] = "multiCursorMergeOverlapping";
  EditorOption2[EditorOption2["multiCursorModifier"] = 61] = "multiCursorModifier";
  EditorOption2[EditorOption2["multiCursorPaste"] = 62] = "multiCursorPaste";
  EditorOption2[EditorOption2["occurrencesHighlight"] = 63] = "occurrencesHighlight";
  EditorOption2[EditorOption2["overviewRulerBorder"] = 64] = "overviewRulerBorder";
  EditorOption2[EditorOption2["overviewRulerLanes"] = 65] = "overviewRulerLanes";
  EditorOption2[EditorOption2["padding"] = 66] = "padding";
  EditorOption2[EditorOption2["parameterHints"] = 67] = "parameterHints";
  EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 68] = "peekWidgetDefaultFocus";
  EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 69] = "definitionLinkOpensInPeek";
  EditorOption2[EditorOption2["quickSuggestions"] = 70] = "quickSuggestions";
  EditorOption2[EditorOption2["quickSuggestionsDelay"] = 71] = "quickSuggestionsDelay";
  EditorOption2[EditorOption2["readOnly"] = 72] = "readOnly";
  EditorOption2[EditorOption2["renameOnType"] = 73] = "renameOnType";
  EditorOption2[EditorOption2["renderControlCharacters"] = 74] = "renderControlCharacters";
  EditorOption2[EditorOption2["renderIndentGuides"] = 75] = "renderIndentGuides";
  EditorOption2[EditorOption2["renderFinalNewline"] = 76] = "renderFinalNewline";
  EditorOption2[EditorOption2["renderLineHighlight"] = 77] = "renderLineHighlight";
  EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 78] = "renderLineHighlightOnlyWhenFocus";
  EditorOption2[EditorOption2["renderValidationDecorations"] = 79] = "renderValidationDecorations";
  EditorOption2[EditorOption2["renderWhitespace"] = 80] = "renderWhitespace";
  EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 81] = "revealHorizontalRightPadding";
  EditorOption2[EditorOption2["roundedSelection"] = 82] = "roundedSelection";
  EditorOption2[EditorOption2["rulers"] = 83] = "rulers";
  EditorOption2[EditorOption2["scrollbar"] = 84] = "scrollbar";
  EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 85] = "scrollBeyondLastColumn";
  EditorOption2[EditorOption2["scrollBeyondLastLine"] = 86] = "scrollBeyondLastLine";
  EditorOption2[EditorOption2["scrollPredominantAxis"] = 87] = "scrollPredominantAxis";
  EditorOption2[EditorOption2["selectionClipboard"] = 88] = "selectionClipboard";
  EditorOption2[EditorOption2["selectionHighlight"] = 89] = "selectionHighlight";
  EditorOption2[EditorOption2["selectOnLineNumbers"] = 90] = "selectOnLineNumbers";
  EditorOption2[EditorOption2["showFoldingControls"] = 91] = "showFoldingControls";
  EditorOption2[EditorOption2["showUnused"] = 92] = "showUnused";
  EditorOption2[EditorOption2["snippetSuggestions"] = 93] = "snippetSuggestions";
  EditorOption2[EditorOption2["smoothScrolling"] = 94] = "smoothScrolling";
  EditorOption2[EditorOption2["stopRenderingLineAfter"] = 95] = "stopRenderingLineAfter";
  EditorOption2[EditorOption2["suggest"] = 96] = "suggest";
  EditorOption2[EditorOption2["suggestFontSize"] = 97] = "suggestFontSize";
  EditorOption2[EditorOption2["suggestLineHeight"] = 98] = "suggestLineHeight";
  EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 99] = "suggestOnTriggerCharacters";
  EditorOption2[EditorOption2["suggestSelection"] = 100] = "suggestSelection";
  EditorOption2[EditorOption2["tabCompletion"] = 101] = "tabCompletion";
  EditorOption2[EditorOption2["tabIndex"] = 102] = "tabIndex";
  EditorOption2[EditorOption2["unusualLineTerminators"] = 103] = "unusualLineTerminators";
  EditorOption2[EditorOption2["useTabStops"] = 104] = "useTabStops";
  EditorOption2[EditorOption2["wordSeparators"] = 105] = "wordSeparators";
  EditorOption2[EditorOption2["wordWrap"] = 106] = "wordWrap";
  EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 107] = "wordWrapBreakAfterCharacters";
  EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 108] = "wordWrapBreakBeforeCharacters";
  EditorOption2[EditorOption2["wordWrapColumn"] = 109] = "wordWrapColumn";
  EditorOption2[EditorOption2["wordWrapMinified"] = 110] = "wordWrapMinified";
  EditorOption2[EditorOption2["wrappingIndent"] = 111] = "wrappingIndent";
  EditorOption2[EditorOption2["wrappingStrategy"] = 112] = "wrappingStrategy";
  EditorOption2[EditorOption2["showDeprecated"] = 113] = "showDeprecated";
  EditorOption2[EditorOption2["editorClassName"] = 114] = "editorClassName";
  EditorOption2[EditorOption2["pixelRatio"] = 115] = "pixelRatio";
  EditorOption2[EditorOption2["tabFocusMode"] = 116] = "tabFocusMode";
  EditorOption2[EditorOption2["layoutInfo"] = 117] = "layoutInfo";
  EditorOption2[EditorOption2["wrappingInfo"] = 118] = "wrappingInfo";
})(EditorOption || (EditorOption = {}));
var EndOfLinePreference;
(function(EndOfLinePreference2) {
  EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
  EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
  EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
})(EndOfLinePreference || (EndOfLinePreference = {}));
var EndOfLineSequence;
(function(EndOfLineSequence2) {
  EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
  EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
})(EndOfLineSequence || (EndOfLineSequence = {}));
var IndentAction;
(function(IndentAction3) {
  IndentAction3[IndentAction3["None"] = 0] = "None";
  IndentAction3[IndentAction3["Indent"] = 1] = "Indent";
  IndentAction3[IndentAction3["IndentOutdent"] = 2] = "IndentOutdent";
  IndentAction3[IndentAction3["Outdent"] = 3] = "Outdent";
})(IndentAction || (IndentAction = {}));
var KeyCode;
(function(KeyCode3) {
  KeyCode3[KeyCode3["Unknown"] = 0] = "Unknown";
  KeyCode3[KeyCode3["Backspace"] = 1] = "Backspace";
  KeyCode3[KeyCode3["Tab"] = 2] = "Tab";
  KeyCode3[KeyCode3["Enter"] = 3] = "Enter";
  KeyCode3[KeyCode3["Shift"] = 4] = "Shift";
  KeyCode3[KeyCode3["Ctrl"] = 5] = "Ctrl";
  KeyCode3[KeyCode3["Alt"] = 6] = "Alt";
  KeyCode3[KeyCode3["PauseBreak"] = 7] = "PauseBreak";
  KeyCode3[KeyCode3["CapsLock"] = 8] = "CapsLock";
  KeyCode3[KeyCode3["Escape"] = 9] = "Escape";
  KeyCode3[KeyCode3["Space"] = 10] = "Space";
  KeyCode3[KeyCode3["PageUp"] = 11] = "PageUp";
  KeyCode3[KeyCode3["PageDown"] = 12] = "PageDown";
  KeyCode3[KeyCode3["End"] = 13] = "End";
  KeyCode3[KeyCode3["Home"] = 14] = "Home";
  KeyCode3[KeyCode3["LeftArrow"] = 15] = "LeftArrow";
  KeyCode3[KeyCode3["UpArrow"] = 16] = "UpArrow";
  KeyCode3[KeyCode3["RightArrow"] = 17] = "RightArrow";
  KeyCode3[KeyCode3["DownArrow"] = 18] = "DownArrow";
  KeyCode3[KeyCode3["Insert"] = 19] = "Insert";
  KeyCode3[KeyCode3["Delete"] = 20] = "Delete";
  KeyCode3[KeyCode3["KEY_0"] = 21] = "KEY_0";
  KeyCode3[KeyCode3["KEY_1"] = 22] = "KEY_1";
  KeyCode3[KeyCode3["KEY_2"] = 23] = "KEY_2";
  KeyCode3[KeyCode3["KEY_3"] = 24] = "KEY_3";
  KeyCode3[KeyCode3["KEY_4"] = 25] = "KEY_4";
  KeyCode3[KeyCode3["KEY_5"] = 26] = "KEY_5";
  KeyCode3[KeyCode3["KEY_6"] = 27] = "KEY_6";
  KeyCode3[KeyCode3["KEY_7"] = 28] = "KEY_7";
  KeyCode3[KeyCode3["KEY_8"] = 29] = "KEY_8";
  KeyCode3[KeyCode3["KEY_9"] = 30] = "KEY_9";
  KeyCode3[KeyCode3["KEY_A"] = 31] = "KEY_A";
  KeyCode3[KeyCode3["KEY_B"] = 32] = "KEY_B";
  KeyCode3[KeyCode3["KEY_C"] = 33] = "KEY_C";
  KeyCode3[KeyCode3["KEY_D"] = 34] = "KEY_D";
  KeyCode3[KeyCode3["KEY_E"] = 35] = "KEY_E";
  KeyCode3[KeyCode3["KEY_F"] = 36] = "KEY_F";
  KeyCode3[KeyCode3["KEY_G"] = 37] = "KEY_G";
  KeyCode3[KeyCode3["KEY_H"] = 38] = "KEY_H";
  KeyCode3[KeyCode3["KEY_I"] = 39] = "KEY_I";
  KeyCode3[KeyCode3["KEY_J"] = 40] = "KEY_J";
  KeyCode3[KeyCode3["KEY_K"] = 41] = "KEY_K";
  KeyCode3[KeyCode3["KEY_L"] = 42] = "KEY_L";
  KeyCode3[KeyCode3["KEY_M"] = 43] = "KEY_M";
  KeyCode3[KeyCode3["KEY_N"] = 44] = "KEY_N";
  KeyCode3[KeyCode3["KEY_O"] = 45] = "KEY_O";
  KeyCode3[KeyCode3["KEY_P"] = 46] = "KEY_P";
  KeyCode3[KeyCode3["KEY_Q"] = 47] = "KEY_Q";
  KeyCode3[KeyCode3["KEY_R"] = 48] = "KEY_R";
  KeyCode3[KeyCode3["KEY_S"] = 49] = "KEY_S";
  KeyCode3[KeyCode3["KEY_T"] = 50] = "KEY_T";
  KeyCode3[KeyCode3["KEY_U"] = 51] = "KEY_U";
  KeyCode3[KeyCode3["KEY_V"] = 52] = "KEY_V";
  KeyCode3[KeyCode3["KEY_W"] = 53] = "KEY_W";
  KeyCode3[KeyCode3["KEY_X"] = 54] = "KEY_X";
  KeyCode3[KeyCode3["KEY_Y"] = 55] = "KEY_Y";
  KeyCode3[KeyCode3["KEY_Z"] = 56] = "KEY_Z";
  KeyCode3[KeyCode3["Meta"] = 57] = "Meta";
  KeyCode3[KeyCode3["ContextMenu"] = 58] = "ContextMenu";
  KeyCode3[KeyCode3["F1"] = 59] = "F1";
  KeyCode3[KeyCode3["F2"] = 60] = "F2";
  KeyCode3[KeyCode3["F3"] = 61] = "F3";
  KeyCode3[KeyCode3["F4"] = 62] = "F4";
  KeyCode3[KeyCode3["F5"] = 63] = "F5";
  KeyCode3[KeyCode3["F6"] = 64] = "F6";
  KeyCode3[KeyCode3["F7"] = 65] = "F7";
  KeyCode3[KeyCode3["F8"] = 66] = "F8";
  KeyCode3[KeyCode3["F9"] = 67] = "F9";
  KeyCode3[KeyCode3["F10"] = 68] = "F10";
  KeyCode3[KeyCode3["F11"] = 69] = "F11";
  KeyCode3[KeyCode3["F12"] = 70] = "F12";
  KeyCode3[KeyCode3["F13"] = 71] = "F13";
  KeyCode3[KeyCode3["F14"] = 72] = "F14";
  KeyCode3[KeyCode3["F15"] = 73] = "F15";
  KeyCode3[KeyCode3["F16"] = 74] = "F16";
  KeyCode3[KeyCode3["F17"] = 75] = "F17";
  KeyCode3[KeyCode3["F18"] = 76] = "F18";
  KeyCode3[KeyCode3["F19"] = 77] = "F19";
  KeyCode3[KeyCode3["NumLock"] = 78] = "NumLock";
  KeyCode3[KeyCode3["ScrollLock"] = 79] = "ScrollLock";
  KeyCode3[KeyCode3["US_SEMICOLON"] = 80] = "US_SEMICOLON";
  KeyCode3[KeyCode3["US_EQUAL"] = 81] = "US_EQUAL";
  KeyCode3[KeyCode3["US_COMMA"] = 82] = "US_COMMA";
  KeyCode3[KeyCode3["US_MINUS"] = 83] = "US_MINUS";
  KeyCode3[KeyCode3["US_DOT"] = 84] = "US_DOT";
  KeyCode3[KeyCode3["US_SLASH"] = 85] = "US_SLASH";
  KeyCode3[KeyCode3["US_BACKTICK"] = 86] = "US_BACKTICK";
  KeyCode3[KeyCode3["US_OPEN_SQUARE_BRACKET"] = 87] = "US_OPEN_SQUARE_BRACKET";
  KeyCode3[KeyCode3["US_BACKSLASH"] = 88] = "US_BACKSLASH";
  KeyCode3[KeyCode3["US_CLOSE_SQUARE_BRACKET"] = 89] = "US_CLOSE_SQUARE_BRACKET";
  KeyCode3[KeyCode3["US_QUOTE"] = 90] = "US_QUOTE";
  KeyCode3[KeyCode3["OEM_8"] = 91] = "OEM_8";
  KeyCode3[KeyCode3["OEM_102"] = 92] = "OEM_102";
  KeyCode3[KeyCode3["NUMPAD_0"] = 93] = "NUMPAD_0";
  KeyCode3[KeyCode3["NUMPAD_1"] = 94] = "NUMPAD_1";
  KeyCode3[KeyCode3["NUMPAD_2"] = 95] = "NUMPAD_2";
  KeyCode3[KeyCode3["NUMPAD_3"] = 96] = "NUMPAD_3";
  KeyCode3[KeyCode3["NUMPAD_4"] = 97] = "NUMPAD_4";
  KeyCode3[KeyCode3["NUMPAD_5"] = 98] = "NUMPAD_5";
  KeyCode3[KeyCode3["NUMPAD_6"] = 99] = "NUMPAD_6";
  KeyCode3[KeyCode3["NUMPAD_7"] = 100] = "NUMPAD_7";
  KeyCode3[KeyCode3["NUMPAD_8"] = 101] = "NUMPAD_8";
  KeyCode3[KeyCode3["NUMPAD_9"] = 102] = "NUMPAD_9";
  KeyCode3[KeyCode3["NUMPAD_MULTIPLY"] = 103] = "NUMPAD_MULTIPLY";
  KeyCode3[KeyCode3["NUMPAD_ADD"] = 104] = "NUMPAD_ADD";
  KeyCode3[KeyCode3["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
  KeyCode3[KeyCode3["NUMPAD_SUBTRACT"] = 106] = "NUMPAD_SUBTRACT";
  KeyCode3[KeyCode3["NUMPAD_DECIMAL"] = 107] = "NUMPAD_DECIMAL";
  KeyCode3[KeyCode3["NUMPAD_DIVIDE"] = 108] = "NUMPAD_DIVIDE";
  KeyCode3[KeyCode3["KEY_IN_COMPOSITION"] = 109] = "KEY_IN_COMPOSITION";
  KeyCode3[KeyCode3["ABNT_C1"] = 110] = "ABNT_C1";
  KeyCode3[KeyCode3["ABNT_C2"] = 111] = "ABNT_C2";
  KeyCode3[KeyCode3["MAX_VALUE"] = 112] = "MAX_VALUE";
})(KeyCode || (KeyCode = {}));
var MarkerSeverity;
(function(MarkerSeverity4) {
  MarkerSeverity4[MarkerSeverity4["Hint"] = 1] = "Hint";
  MarkerSeverity4[MarkerSeverity4["Info"] = 2] = "Info";
  MarkerSeverity4[MarkerSeverity4["Warning"] = 4] = "Warning";
  MarkerSeverity4[MarkerSeverity4["Error"] = 8] = "Error";
})(MarkerSeverity || (MarkerSeverity = {}));
var MarkerTag;
(function(MarkerTag3) {
  MarkerTag3[MarkerTag3["Unnecessary"] = 1] = "Unnecessary";
  MarkerTag3[MarkerTag3["Deprecated"] = 2] = "Deprecated";
})(MarkerTag || (MarkerTag = {}));
var MinimapPosition;
(function(MinimapPosition3) {
  MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
  MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
})(MinimapPosition || (MinimapPosition = {}));
var MouseTargetType;
(function(MouseTargetType2) {
  MouseTargetType2[MouseTargetType2["UNKNOWN"] = 0] = "UNKNOWN";
  MouseTargetType2[MouseTargetType2["TEXTAREA"] = 1] = "TEXTAREA";
  MouseTargetType2[MouseTargetType2["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
  MouseTargetType2[MouseTargetType2["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
  MouseTargetType2[MouseTargetType2["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
  MouseTargetType2[MouseTargetType2["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
  MouseTargetType2[MouseTargetType2["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
  MouseTargetType2[MouseTargetType2["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
  MouseTargetType2[MouseTargetType2["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
  MouseTargetType2[MouseTargetType2["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
  MouseTargetType2[MouseTargetType2["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
  MouseTargetType2[MouseTargetType2["SCROLLBAR"] = 11] = "SCROLLBAR";
  MouseTargetType2[MouseTargetType2["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
  MouseTargetType2[MouseTargetType2["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
})(MouseTargetType || (MouseTargetType = {}));
var OverlayWidgetPositionPreference;
(function(OverlayWidgetPositionPreference2) {
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_CENTER"] = 2] = "TOP_CENTER";
})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
var OverviewRulerLane;
(function(OverviewRulerLane3) {
  OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
  OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
  OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
  OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
})(OverviewRulerLane || (OverviewRulerLane = {}));
var RenderLineNumbersType;
(function(RenderLineNumbersType2) {
  RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
  RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
  RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
  RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
  RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
})(RenderLineNumbersType || (RenderLineNumbersType = {}));
var RenderMinimap;
(function(RenderMinimap2) {
  RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
  RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
  RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
})(RenderMinimap || (RenderMinimap = {}));
var ScrollType;
(function(ScrollType2) {
  ScrollType2[ScrollType2["Smooth"] = 0] = "Smooth";
  ScrollType2[ScrollType2["Immediate"] = 1] = "Immediate";
})(ScrollType || (ScrollType = {}));
var ScrollbarVisibility;
(function(ScrollbarVisibility2) {
  ScrollbarVisibility2[ScrollbarVisibility2["Auto"] = 1] = "Auto";
  ScrollbarVisibility2[ScrollbarVisibility2["Hidden"] = 2] = "Hidden";
  ScrollbarVisibility2[ScrollbarVisibility2["Visible"] = 3] = "Visible";
})(ScrollbarVisibility || (ScrollbarVisibility = {}));
var SelectionDirection;
(function(SelectionDirection3) {
  SelectionDirection3[SelectionDirection3["LTR"] = 0] = "LTR";
  SelectionDirection3[SelectionDirection3["RTL"] = 1] = "RTL";
})(SelectionDirection || (SelectionDirection = {}));
var SignatureHelpTriggerKind;
(function(SignatureHelpTriggerKind3) {
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
var SymbolKind;
(function(SymbolKind2) {
  SymbolKind2[SymbolKind2["File"] = 0] = "File";
  SymbolKind2[SymbolKind2["Module"] = 1] = "Module";
  SymbolKind2[SymbolKind2["Namespace"] = 2] = "Namespace";
  SymbolKind2[SymbolKind2["Package"] = 3] = "Package";
  SymbolKind2[SymbolKind2["Class"] = 4] = "Class";
  SymbolKind2[SymbolKind2["Method"] = 5] = "Method";
  SymbolKind2[SymbolKind2["Property"] = 6] = "Property";
  SymbolKind2[SymbolKind2["Field"] = 7] = "Field";
  SymbolKind2[SymbolKind2["Constructor"] = 8] = "Constructor";
  SymbolKind2[SymbolKind2["Enum"] = 9] = "Enum";
  SymbolKind2[SymbolKind2["Interface"] = 10] = "Interface";
  SymbolKind2[SymbolKind2["Function"] = 11] = "Function";
  SymbolKind2[SymbolKind2["Variable"] = 12] = "Variable";
  SymbolKind2[SymbolKind2["Constant"] = 13] = "Constant";
  SymbolKind2[SymbolKind2["String"] = 14] = "String";
  SymbolKind2[SymbolKind2["Number"] = 15] = "Number";
  SymbolKind2[SymbolKind2["Boolean"] = 16] = "Boolean";
  SymbolKind2[SymbolKind2["Array"] = 17] = "Array";
  SymbolKind2[SymbolKind2["Object"] = 18] = "Object";
  SymbolKind2[SymbolKind2["Key"] = 19] = "Key";
  SymbolKind2[SymbolKind2["Null"] = 20] = "Null";
  SymbolKind2[SymbolKind2["EnumMember"] = 21] = "EnumMember";
  SymbolKind2[SymbolKind2["Struct"] = 22] = "Struct";
  SymbolKind2[SymbolKind2["Event"] = 23] = "Event";
  SymbolKind2[SymbolKind2["Operator"] = 24] = "Operator";
  SymbolKind2[SymbolKind2["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function(SymbolTag2) {
  SymbolTag2[SymbolTag2["Deprecated"] = 1] = "Deprecated";
})(SymbolTag || (SymbolTag = {}));
var TextEditorCursorBlinkingStyle;
(function(TextEditorCursorBlinkingStyle2) {
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
var TextEditorCursorStyle2;
(function(TextEditorCursorStyle3) {
  TextEditorCursorStyle3[TextEditorCursorStyle3["Line"] = 1] = "Line";
  TextEditorCursorStyle3[TextEditorCursorStyle3["Block"] = 2] = "Block";
  TextEditorCursorStyle3[TextEditorCursorStyle3["Underline"] = 3] = "Underline";
  TextEditorCursorStyle3[TextEditorCursorStyle3["LineThin"] = 4] = "LineThin";
  TextEditorCursorStyle3[TextEditorCursorStyle3["BlockOutline"] = 5] = "BlockOutline";
  TextEditorCursorStyle3[TextEditorCursorStyle3["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle2 || (TextEditorCursorStyle2 = {}));
var TrackedRangeStickiness;
(function(TrackedRangeStickiness2) {
  TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
  TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
  TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
  TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
var WrappingIndent;
(function(WrappingIndent2) {
  WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
  WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
  WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
  WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
})(WrappingIndent || (WrappingIndent = {}));

// ../../node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneBase.js
var KeyMod = class {
  static chord(firstPart, secondPart) {
    return KeyChord(firstPart, secondPart);
  }
};
KeyMod.CtrlCmd = 2048;
KeyMod.Shift = 1024;
KeyMod.Alt = 512;
KeyMod.WinCtrl = 256;
function createMonacoBaseAPI() {
  return {
    editor: void 0,
    languages: void 0,
    CancellationTokenSource,
    Emitter,
    KeyCode,
    KeyMod,
    Position,
    Range,
    Selection,
    SelectionDirection,
    MarkerSeverity,
    MarkerTag,
    Uri: URI,
    Token
  };
}

// ../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js
var _util;
(function(_util2) {
  _util2.serviceIds = new Map();
  _util2.DI_TARGET = "$di$target";
  _util2.DI_DEPENDENCIES = "$di$dependencies";
  function getServiceDependencies(ctor) {
    return ctor[_util2.DI_DEPENDENCIES] || [];
  }
  _util2.getServiceDependencies = getServiceDependencies;
})(_util || (_util = {}));
var IInstantiationService = createDecorator("instantiationService");
function storeServiceDependency(id, target, index, optional2) {
  if (target[_util.DI_TARGET] === target) {
    target[_util.DI_DEPENDENCIES].push({id, index, optional: optional2});
  } else {
    target[_util.DI_DEPENDENCIES] = [{id, index, optional: optional2}];
    target[_util.DI_TARGET] = target;
  }
}
function createDecorator(serviceId) {
  if (_util.serviceIds.has(serviceId)) {
    return _util.serviceIds.get(serviceId);
  }
  const id = function(target, key, index) {
    if (arguments.length !== 3) {
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    }
    storeServiceDependency(id, target, index, false);
  };
  id.toString = () => serviceId;
  _util.serviceIds.set(serviceId, id);
  return id;
}
function optional(serviceIdentifier) {
  return function(target, key, index) {
    if (arguments.length !== 3) {
      throw new Error("@optional-decorator can only be used to decorate a parameter");
    }
    storeServiceDependency(serviceIdentifier, target, index, true);
  };
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/services/codeEditorService.js
var ICodeEditorService = createDecorator("codeEditorService");

// ../../node_modules/monaco-editor/esm/vs/base/browser/browser.js
var WindowManager = class {
  constructor() {
    this._zoomLevel = 0;
    this._lastZoomLevelChangeTime = 0;
    this._onDidChangeZoomLevel = new Emitter();
    this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
    this._zoomFactor = 1;
  }
  getZoomLevel() {
    return this._zoomLevel;
  }
  getTimeSinceLastZoomLevelChanged() {
    return Date.now() - this._lastZoomLevelChangeTime;
  }
  getZoomFactor() {
    return this._zoomFactor;
  }
  getPixelRatio() {
    let ctx = document.createElement("canvas").getContext("2d");
    let dpr = window.devicePixelRatio || 1;
    let bsr = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
    return dpr / bsr;
  }
};
WindowManager.INSTANCE = new WindowManager();
function getZoomLevel() {
  return WindowManager.INSTANCE.getZoomLevel();
}
function getTimeSinceLastZoomLevelChanged() {
  return WindowManager.INSTANCE.getTimeSinceLastZoomLevelChanged();
}
function onDidChangeZoomLevel(callback) {
  return WindowManager.INSTANCE.onDidChangeZoomLevel(callback);
}
function getZoomFactor() {
  return WindowManager.INSTANCE.getZoomFactor();
}
function getPixelRatio() {
  return WindowManager.INSTANCE.getPixelRatio();
}
var userAgent = navigator.userAgent;
var isEdge = userAgent.indexOf("Edge/") >= 0;
var isFirefox = userAgent.indexOf("Firefox") >= 0;
var isWebKit = userAgent.indexOf("AppleWebKit") >= 0;
var isChrome = userAgent.indexOf("Chrome") >= 0;
var isSafari = !isChrome && userAgent.indexOf("Safari") >= 0;
var isWebkitWebView = !isChrome && !isSafari && isWebKit;
var isIPad = userAgent.indexOf("iPad") >= 0 || isSafari && navigator.maxTouchPoints > 0;
var isEdgeWebView = isEdge && userAgent.indexOf("WebView/") >= 0;
var isStandalone = window.matchMedia && window.matchMedia("(display-mode: standalone)").matches;

// ../../node_modules/monaco-editor/esm/vs/base/browser/event.js
var domEvent = (element, type, useCapture) => {
  const fn = (e) => emitter.fire(e);
  const emitter = new Emitter({
    onFirstListenerAdd: () => {
      element.addEventListener(type, fn, useCapture);
    },
    onLastListenerRemove: () => {
      element.removeEventListener(type, fn, useCapture);
    }
  });
  return emitter.event;
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/keyboardEvent.js
var KEY_CODE_MAP = new Array(230);
var INVERSE_KEY_CODE_MAP = new Array(112);
(function() {
  for (let i = 0; i < INVERSE_KEY_CODE_MAP.length; i++) {
    INVERSE_KEY_CODE_MAP[i] = -1;
  }
  function define(code, keyCode) {
    KEY_CODE_MAP[code] = keyCode;
    INVERSE_KEY_CODE_MAP[keyCode] = code;
  }
  define(3, 7);
  define(8, 1);
  define(9, 2);
  define(13, 3);
  define(16, 4);
  define(17, 5);
  define(18, 6);
  define(19, 7);
  define(20, 8);
  define(27, 9);
  define(32, 10);
  define(33, 11);
  define(34, 12);
  define(35, 13);
  define(36, 14);
  define(37, 15);
  define(38, 16);
  define(39, 17);
  define(40, 18);
  define(45, 19);
  define(46, 20);
  define(48, 21);
  define(49, 22);
  define(50, 23);
  define(51, 24);
  define(52, 25);
  define(53, 26);
  define(54, 27);
  define(55, 28);
  define(56, 29);
  define(57, 30);
  define(65, 31);
  define(66, 32);
  define(67, 33);
  define(68, 34);
  define(69, 35);
  define(70, 36);
  define(71, 37);
  define(72, 38);
  define(73, 39);
  define(74, 40);
  define(75, 41);
  define(76, 42);
  define(77, 43);
  define(78, 44);
  define(79, 45);
  define(80, 46);
  define(81, 47);
  define(82, 48);
  define(83, 49);
  define(84, 50);
  define(85, 51);
  define(86, 52);
  define(87, 53);
  define(88, 54);
  define(89, 55);
  define(90, 56);
  define(93, 58);
  define(96, 93);
  define(97, 94);
  define(98, 95);
  define(99, 96);
  define(100, 97);
  define(101, 98);
  define(102, 99);
  define(103, 100);
  define(104, 101);
  define(105, 102);
  define(106, 103);
  define(107, 104);
  define(108, 105);
  define(109, 106);
  define(110, 107);
  define(111, 108);
  define(112, 59);
  define(113, 60);
  define(114, 61);
  define(115, 62);
  define(116, 63);
  define(117, 64);
  define(118, 65);
  define(119, 66);
  define(120, 67);
  define(121, 68);
  define(122, 69);
  define(123, 70);
  define(124, 71);
  define(125, 72);
  define(126, 73);
  define(127, 74);
  define(128, 75);
  define(129, 76);
  define(130, 77);
  define(144, 78);
  define(145, 79);
  define(186, 80);
  define(187, 81);
  define(188, 82);
  define(189, 83);
  define(190, 84);
  define(191, 85);
  define(192, 86);
  define(193, 110);
  define(194, 111);
  define(219, 87);
  define(220, 88);
  define(221, 89);
  define(222, 90);
  define(223, 91);
  define(226, 92);
  define(229, 109);
  if (isFirefox) {
    define(59, 80);
    define(107, 81);
    define(109, 83);
    if (isMacintosh) {
      define(224, 57);
    }
  } else if (isWebKit) {
    define(91, 57);
    if (isMacintosh) {
      define(93, 57);
    } else {
      define(92, 57);
    }
  }
})();
function extractKeyCode(e) {
  if (e.charCode) {
    let char = String.fromCharCode(e.charCode).toUpperCase();
    return KeyCodeUtils.fromString(char);
  }
  return KEY_CODE_MAP[e.keyCode] || 0;
}
var ctrlKeyMod = isMacintosh ? 256 : 2048;
var altKeyMod = 512;
var shiftKeyMod = 1024;
var metaKeyMod = isMacintosh ? 2048 : 256;
var StandardKeyboardEvent = class {
  constructor(source) {
    this._standardKeyboardEventBrand = true;
    let e = source;
    this.browserEvent = e;
    this.target = e.target;
    this.ctrlKey = e.ctrlKey;
    this.shiftKey = e.shiftKey;
    this.altKey = e.altKey;
    this.metaKey = e.metaKey;
    this.keyCode = extractKeyCode(e);
    this.code = e.code;
    this.ctrlKey = this.ctrlKey || this.keyCode === 5;
    this.altKey = this.altKey || this.keyCode === 6;
    this.shiftKey = this.shiftKey || this.keyCode === 4;
    this.metaKey = this.metaKey || this.keyCode === 57;
    this._asKeybinding = this._computeKeybinding();
    this._asRuntimeKeybinding = this._computeRuntimeKeybinding();
  }
  preventDefault() {
    if (this.browserEvent && this.browserEvent.preventDefault) {
      this.browserEvent.preventDefault();
    }
  }
  stopPropagation() {
    if (this.browserEvent && this.browserEvent.stopPropagation) {
      this.browserEvent.stopPropagation();
    }
  }
  toKeybinding() {
    return this._asRuntimeKeybinding;
  }
  equals(other) {
    return this._asKeybinding === other;
  }
  _computeKeybinding() {
    let key = 0;
    if (this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57) {
      key = this.keyCode;
    }
    let result = 0;
    if (this.ctrlKey) {
      result |= ctrlKeyMod;
    }
    if (this.altKey) {
      result |= altKeyMod;
    }
    if (this.shiftKey) {
      result |= shiftKeyMod;
    }
    if (this.metaKey) {
      result |= metaKeyMod;
    }
    result |= key;
    return result;
  }
  _computeRuntimeKeybinding() {
    let key = 0;
    if (this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57) {
      key = this.keyCode;
    }
    return new SimpleKeybinding(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, key);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/iframe.js
var hasDifferentOriginAncestorFlag = false;
var sameOriginWindowChainCache = null;
function getParentWindowIfSameOrigin(w) {
  if (!w.parent || w.parent === w) {
    return null;
  }
  try {
    let location = w.location;
    let parentLocation = w.parent.location;
    if (location.origin !== "null" && parentLocation.origin !== "null") {
      if (location.protocol !== parentLocation.protocol || location.hostname !== parentLocation.hostname || location.port !== parentLocation.port) {
        hasDifferentOriginAncestorFlag = true;
        return null;
      }
    }
  } catch (e) {
    hasDifferentOriginAncestorFlag = true;
    return null;
  }
  return w.parent;
}
var IframeUtils = class {
  static getSameOriginWindowChain() {
    if (!sameOriginWindowChainCache) {
      sameOriginWindowChainCache = [];
      let w = window;
      let parent;
      do {
        parent = getParentWindowIfSameOrigin(w);
        if (parent) {
          sameOriginWindowChainCache.push({
            window: w,
            iframeElement: w.frameElement || null
          });
        } else {
          sameOriginWindowChainCache.push({
            window: w,
            iframeElement: null
          });
        }
        w = parent;
      } while (w);
    }
    return sameOriginWindowChainCache.slice(0);
  }
  static hasDifferentOriginAncestor() {
    if (!sameOriginWindowChainCache) {
      this.getSameOriginWindowChain();
    }
    return hasDifferentOriginAncestorFlag;
  }
  static getPositionOfChildWindowRelativeToAncestorWindow(childWindow, ancestorWindow) {
    if (!ancestorWindow || childWindow === ancestorWindow) {
      return {
        top: 0,
        left: 0
      };
    }
    let top = 0, left = 0;
    let windowChain = this.getSameOriginWindowChain();
    for (const windowChainEl of windowChain) {
      top += windowChainEl.window.scrollY;
      left += windowChainEl.window.scrollX;
      if (windowChainEl.window === ancestorWindow) {
        break;
      }
      if (!windowChainEl.iframeElement) {
        break;
      }
      let boundingRect = windowChainEl.iframeElement.getBoundingClientRect();
      top += boundingRect.top;
      left += boundingRect.left;
    }
    return {
      top,
      left
    };
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/mouseEvent.js
var StandardMouseEvent = class {
  constructor(e) {
    this.timestamp = Date.now();
    this.browserEvent = e;
    this.leftButton = e.button === 0;
    this.middleButton = e.button === 1;
    this.rightButton = e.button === 2;
    this.buttons = e.buttons;
    this.target = e.target;
    this.detail = e.detail || 1;
    if (e.type === "dblclick") {
      this.detail = 2;
    }
    this.ctrlKey = e.ctrlKey;
    this.shiftKey = e.shiftKey;
    this.altKey = e.altKey;
    this.metaKey = e.metaKey;
    if (typeof e.pageX === "number") {
      this.posx = e.pageX;
      this.posy = e.pageY;
    } else {
      this.posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
      this.posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }
    let iframeOffsets = IframeUtils.getPositionOfChildWindowRelativeToAncestorWindow(self, e.view);
    this.posx -= iframeOffsets.left;
    this.posy -= iframeOffsets.top;
  }
  preventDefault() {
    this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent.stopPropagation();
  }
};
var StandardWheelEvent = class {
  constructor(e, deltaX = 0, deltaY = 0) {
    this.browserEvent = e || null;
    this.target = e ? e.target || e.targetNode || e.srcElement : null;
    this.deltaY = deltaY;
    this.deltaX = deltaX;
    if (e) {
      let e1 = e;
      let e2 = e;
      if (typeof e1.wheelDeltaY !== "undefined") {
        this.deltaY = e1.wheelDeltaY / 120;
      } else if (typeof e2.VERTICAL_AXIS !== "undefined" && e2.axis === e2.VERTICAL_AXIS) {
        this.deltaY = -e2.detail / 3;
      } else if (e.type === "wheel") {
        const ev = e;
        if (ev.deltaMode === ev.DOM_DELTA_LINE) {
          if (isFirefox && !isMacintosh) {
            this.deltaY = -e.deltaY / 3;
          } else {
            this.deltaY = -e.deltaY;
          }
        } else {
          this.deltaY = -e.deltaY / 40;
        }
      }
      if (typeof e1.wheelDeltaX !== "undefined") {
        if (isSafari && isWindows) {
          this.deltaX = -(e1.wheelDeltaX / 120);
        } else {
          this.deltaX = e1.wheelDeltaX / 120;
        }
      } else if (typeof e2.HORIZONTAL_AXIS !== "undefined" && e2.axis === e2.HORIZONTAL_AXIS) {
        this.deltaX = -e.detail / 3;
      } else if (e.type === "wheel") {
        const ev = e;
        if (ev.deltaMode === ev.DOM_DELTA_LINE) {
          if (isFirefox && !isMacintosh) {
            this.deltaX = -e.deltaX / 3;
          } else {
            this.deltaX = -e.deltaX;
          }
        } else {
          this.deltaX = -e.deltaX / 40;
        }
      }
      if (this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta) {
        this.deltaY = e.wheelDelta / 120;
      }
    }
  }
  preventDefault() {
    if (this.browserEvent) {
      this.browserEvent.preventDefault();
    }
  }
  stopPropagation() {
    if (this.browserEvent) {
      this.browserEvent.stopPropagation();
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/async.js
function isThenable(obj) {
  return obj && typeof obj.then === "function";
}
function createCancelablePromise(callback) {
  const source = new CancellationTokenSource();
  const thenable = callback(source.token);
  const promise = new Promise((resolve2, reject) => {
    source.token.onCancellationRequested(() => {
      reject(canceled());
    });
    Promise.resolve(thenable).then((value) => {
      source.dispose();
      resolve2(value);
    }, (err) => {
      source.dispose();
      reject(err);
    });
  });
  return new class {
    cancel() {
      source.cancel();
    }
    then(resolve2, reject) {
      return promise.then(resolve2, reject);
    }
    catch(reject) {
      return this.then(void 0, reject);
    }
    finally(onfinally) {
      return promise.finally(onfinally);
    }
  }();
}
var Delayer = class {
  constructor(defaultDelay) {
    this.defaultDelay = defaultDelay;
    this.timeout = null;
    this.completionPromise = null;
    this.doResolve = null;
    this.doReject = null;
    this.task = null;
  }
  trigger(task, delay = this.defaultDelay) {
    this.task = task;
    this.cancelTimeout();
    if (!this.completionPromise) {
      this.completionPromise = new Promise((c, e) => {
        this.doResolve = c;
        this.doReject = e;
      }).then(() => {
        this.completionPromise = null;
        this.doResolve = null;
        if (this.task) {
          const task2 = this.task;
          this.task = null;
          return task2();
        }
        return void 0;
      });
    }
    this.timeout = setTimeout(() => {
      this.timeout = null;
      if (this.doResolve) {
        this.doResolve(null);
      }
    }, delay);
    return this.completionPromise;
  }
  isTriggered() {
    return this.timeout !== null;
  }
  cancel() {
    this.cancelTimeout();
    if (this.completionPromise) {
      if (this.doReject) {
        this.doReject(canceled());
      }
      this.completionPromise = null;
    }
  }
  cancelTimeout() {
    if (this.timeout !== null) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
  }
  dispose() {
    this.cancelTimeout();
  }
};
function timeout(millis, token) {
  if (!token) {
    return createCancelablePromise((token2) => timeout(millis, token2));
  }
  return new Promise((resolve2, reject) => {
    const handle = setTimeout(resolve2, millis);
    token.onCancellationRequested(() => {
      clearTimeout(handle);
      reject(canceled());
    });
  });
}
function disposableTimeout(handler, timeout2 = 0) {
  const timer = setTimeout(handler, timeout2);
  return toDisposable(() => clearTimeout(timer));
}
var TimeoutTimer = class {
  constructor(runner, timeout2) {
    this._token = -1;
    if (typeof runner === "function" && typeof timeout2 === "number") {
      this.setIfNotSet(runner, timeout2);
    }
  }
  dispose() {
    this.cancel();
  }
  cancel() {
    if (this._token !== -1) {
      clearTimeout(this._token);
      this._token = -1;
    }
  }
  cancelAndSet(runner, timeout2) {
    this.cancel();
    this._token = setTimeout(() => {
      this._token = -1;
      runner();
    }, timeout2);
  }
  setIfNotSet(runner, timeout2) {
    if (this._token !== -1) {
      return;
    }
    this._token = setTimeout(() => {
      this._token = -1;
      runner();
    }, timeout2);
  }
};
var IntervalTimer = class {
  constructor() {
    this._token = -1;
  }
  dispose() {
    this.cancel();
  }
  cancel() {
    if (this._token !== -1) {
      clearInterval(this._token);
      this._token = -1;
    }
  }
  cancelAndSet(runner, interval) {
    this.cancel();
    this._token = setInterval(() => {
      runner();
    }, interval);
  }
};
var RunOnceScheduler = class {
  constructor(runner, timeout2) {
    this.timeoutToken = -1;
    this.runner = runner;
    this.timeout = timeout2;
    this.timeoutHandler = this.onTimeout.bind(this);
  }
  dispose() {
    this.cancel();
    this.runner = null;
  }
  cancel() {
    if (this.isScheduled()) {
      clearTimeout(this.timeoutToken);
      this.timeoutToken = -1;
    }
  }
  schedule(delay = this.timeout) {
    this.cancel();
    this.timeoutToken = setTimeout(this.timeoutHandler, delay);
  }
  isScheduled() {
    return this.timeoutToken !== -1;
  }
  onTimeout() {
    this.timeoutToken = -1;
    if (this.runner) {
      this.doRun();
    }
  }
  doRun() {
    if (this.runner) {
      this.runner();
    }
  }
};
var runWhenIdle;
(function() {
  if (typeof requestIdleCallback !== "function" || typeof cancelIdleCallback !== "function") {
    const dummyIdle = Object.freeze({
      didTimeout: true,
      timeRemaining() {
        return 15;
      }
    });
    runWhenIdle = (runner) => {
      const handle = setTimeout(() => runner(dummyIdle));
      let disposed = false;
      return {
        dispose() {
          if (disposed) {
            return;
          }
          disposed = true;
          clearTimeout(handle);
        }
      };
    };
  } else {
    runWhenIdle = (runner, timeout2) => {
      const handle = requestIdleCallback(runner, typeof timeout2 === "number" ? {timeout: timeout2} : void 0);
      let disposed = false;
      return {
        dispose() {
          if (disposed) {
            return;
          }
          disposed = true;
          cancelIdleCallback(handle);
        }
      };
    };
  }
})();
var IdleValue = class {
  constructor(executor) {
    this._didRun = false;
    this._executor = () => {
      try {
        this._value = executor();
      } catch (err) {
        this._error = err;
      } finally {
        this._didRun = true;
      }
    };
    this._handle = runWhenIdle(() => this._executor());
  }
  dispose() {
    this._handle.dispose();
  }
  get value() {
    if (!this._didRun) {
      this._handle.dispose();
      this._executor();
    }
    if (this._error) {
      throw this._error;
    }
    return this._value;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/arrays.js
function tail(array, n = 0) {
  return array[array.length - (1 + n)];
}
function tail2(arr) {
  if (arr.length === 0) {
    throw new Error("Invalid tail call");
  }
  return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
}
function equals(one, other, itemEquals = (a, b) => a === b) {
  if (one === other) {
    return true;
  }
  if (!one || !other) {
    return false;
  }
  if (one.length !== other.length) {
    return false;
  }
  for (let i = 0, len = one.length; i < len; i++) {
    if (!itemEquals(one[i], other[i])) {
      return false;
    }
  }
  return true;
}
function binarySearch(array, key, comparator) {
  let low = 0, high = array.length - 1;
  while (low <= high) {
    const mid = (low + high) / 2 | 0;
    const comp = comparator(array[mid], key);
    if (comp < 0) {
      low = mid + 1;
    } else if (comp > 0) {
      high = mid - 1;
    } else {
      return mid;
    }
  }
  return -(low + 1);
}
function mergeSort(data, compare2) {
  _sort(data, compare2, 0, data.length - 1, []);
  return data;
}
function _merge(a, compare2, lo, mid, hi, aux) {
  let leftIdx = lo, rightIdx = mid + 1;
  for (let i = lo; i <= hi; i++) {
    aux[i] = a[i];
  }
  for (let i = lo; i <= hi; i++) {
    if (leftIdx > mid) {
      a[i] = aux[rightIdx++];
    } else if (rightIdx > hi) {
      a[i] = aux[leftIdx++];
    } else if (compare2(aux[rightIdx], aux[leftIdx]) < 0) {
      a[i] = aux[rightIdx++];
    } else {
      a[i] = aux[leftIdx++];
    }
  }
}
function _sort(a, compare2, lo, hi, aux) {
  if (hi <= lo) {
    return;
  }
  const mid = lo + (hi - lo) / 2 | 0;
  _sort(a, compare2, lo, mid, aux);
  _sort(a, compare2, mid + 1, hi, aux);
  if (compare2(a[mid], a[mid + 1]) <= 0) {
    return;
  }
  _merge(a, compare2, lo, mid, hi, aux);
}
function coalesce(array) {
  return array.filter((e) => !!e);
}
function isFalsyOrEmpty(obj) {
  return !Array.isArray(obj) || obj.length === 0;
}
function isNonEmptyArray(obj) {
  return Array.isArray(obj) && obj.length > 0;
}
function distinct(array, keyFn) {
  if (!keyFn) {
    return array.filter((element, position) => {
      return array.indexOf(element) === position;
    });
  }
  const seen = Object.create(null);
  return array.filter((elem) => {
    const key = keyFn(elem);
    if (seen[key]) {
      return false;
    }
    seen[key] = true;
    return true;
  });
}
function distinctES6(array) {
  const seen = new Set();
  return array.filter((element) => {
    if (seen.has(element)) {
      return false;
    }
    seen.add(element);
    return true;
  });
}
function firstIndex(array, fn) {
  for (let i = 0; i < array.length; i++) {
    const element = array[i];
    if (fn(element)) {
      return i;
    }
  }
  return -1;
}
function first(array, fn, notFoundValue = void 0) {
  const index = firstIndex(array, fn);
  return index < 0 ? notFoundValue : array[index];
}
function firstOrDefault(array, notFoundValue) {
  return array.length > 0 ? array[0] : notFoundValue;
}
function range(arg, to) {
  let from = typeof to === "number" ? arg : 0;
  if (typeof to === "number") {
    from = arg;
  } else {
    from = 0;
    to = arg;
  }
  const result = [];
  if (from <= to) {
    for (let i = from; i < to; i++) {
      result.push(i);
    }
  } else {
    for (let i = from; i > to; i--) {
      result.push(i);
    }
  }
  return result;
}
function arrayInsert(target, insertIndex, insertArr) {
  const before = target.slice(0, insertIndex);
  const after = target.slice(insertIndex);
  return before.concat(insertArr, after);
}

// ../../node_modules/monaco-editor/esm/vs/base/common/network.js
var Schemas;
(function(Schemas2) {
  Schemas2.inMemory = "inmemory";
  Schemas2.vscode = "vscode";
  Schemas2.internal = "private";
  Schemas2.walkThrough = "walkThrough";
  Schemas2.walkThroughSnippet = "walkThroughSnippet";
  Schemas2.http = "http";
  Schemas2.https = "https";
  Schemas2.file = "file";
  Schemas2.mailto = "mailto";
  Schemas2.untitled = "untitled";
  Schemas2.data = "data";
  Schemas2.command = "command";
  Schemas2.vscodeRemote = "vscode-remote";
  Schemas2.vscodeRemoteResource = "vscode-remote-resource";
  Schemas2.userData = "vscode-userdata";
  Schemas2.vscodeCustomEditor = "vscode-custom-editor";
  Schemas2.vscodeNotebook = "vscode-notebook";
  Schemas2.vscodeNotebookCell = "vscode-notebook-cell";
  Schemas2.vscodeSettings = "vscode-settings";
  Schemas2.webviewPanel = "webview-panel";
  Schemas2.vscodeWebview = "vscode-webview";
  Schemas2.vscodeWebviewResource = "vscode-webview-resource";
  Schemas2.extension = "extension";
})(Schemas || (Schemas = {}));
var RemoteAuthoritiesImpl = class {
  constructor() {
    this._hosts = Object.create(null);
    this._ports = Object.create(null);
    this._connectionTokens = Object.create(null);
    this._preferredWebSchema = "http";
    this._delegate = null;
  }
  setPreferredWebSchema(schema) {
    this._preferredWebSchema = schema;
  }
  rewrite(uri) {
    if (this._delegate) {
      return this._delegate(uri);
    }
    const authority = uri.authority;
    let host = this._hosts[authority];
    if (host && host.indexOf(":") !== -1) {
      host = `[${host}]`;
    }
    const port = this._ports[authority];
    const connectionToken = this._connectionTokens[authority];
    let query = `path=${encodeURIComponent(uri.path)}`;
    if (typeof connectionToken === "string") {
      query += `&tkn=${encodeURIComponent(connectionToken)}`;
    }
    return URI.from({
      scheme: isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,
      authority: `${host}:${port}`,
      path: `/vscode-remote-resource`,
      query
    });
  }
};
var RemoteAuthorities = new RemoteAuthoritiesImpl();

// ../../node_modules/monaco-editor/esm/vs/base/browser/canIUse.js
var BrowserFeatures = {
  clipboard: {
    writeText: isNative || document.queryCommandSupported && document.queryCommandSupported("copy") || !!(navigator && navigator.clipboard && navigator.clipboard.writeText),
    readText: isNative || !!(navigator && navigator.clipboard && navigator.clipboard.readText),
    richText: (() => {
      if (isEdge) {
        let index = navigator.userAgent.indexOf("Edge/");
        let version = parseInt(navigator.userAgent.substring(index + 5, navigator.userAgent.indexOf(".", index)), 10);
        if (!version || version >= 12 && version <= 16) {
          return false;
        }
      }
      return true;
    })()
  },
  keyboard: (() => {
    if (isNative || isStandalone) {
      return 0;
    }
    if (navigator.keyboard || isSafari) {
      return 1;
    }
    return 2;
  })(),
  touch: "ontouchstart" in window || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0,
  pointerEvents: window.PointerEvent && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0 || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0)
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/dom.js
function clearNode(node) {
  while (node.firstChild) {
    node.removeChild(node.firstChild);
  }
}
function removeNode(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function isInDOM(node) {
  while (node) {
    if (node === document.body) {
      return true;
    }
    node = node.parentNode || node.host;
  }
  return false;
}
var _classList = new class {
  hasClass(node, className) {
    return Boolean(className) && node.classList && node.classList.contains(className);
  }
  addClasses(node, ...classNames) {
    classNames.forEach((nameValue) => nameValue.split(" ").forEach((name) => this.addClass(node, name)));
  }
  addClass(node, className) {
    if (className && node.classList) {
      node.classList.add(className);
    }
  }
  removeClass(node, className) {
    if (className && node.classList) {
      node.classList.remove(className);
    }
  }
  removeClasses(node, ...classNames) {
    classNames.forEach((nameValue) => nameValue.split(" ").forEach((name) => this.removeClass(node, name)));
  }
  toggleClass(node, className, shouldHaveIt) {
    if (node.classList) {
      node.classList.toggle(className, shouldHaveIt);
    }
  }
}();
var hasClass = _classList.hasClass.bind(_classList);
var addClass = _classList.addClass.bind(_classList);
var addClasses = _classList.addClasses.bind(_classList);
var removeClass = _classList.removeClass.bind(_classList);
var removeClasses = _classList.removeClasses.bind(_classList);
var toggleClass = _classList.toggleClass.bind(_classList);
var DomListener = class {
  constructor(node, type, handler, options) {
    this._node = node;
    this._type = type;
    this._handler = handler;
    this._options = options || false;
    this._node.addEventListener(this._type, this._handler, this._options);
  }
  dispose() {
    if (!this._handler) {
      return;
    }
    this._node.removeEventListener(this._type, this._handler, this._options);
    this._node = null;
    this._handler = null;
  }
};
function addDisposableListener(node, type, handler, useCaptureOrOptions) {
  return new DomListener(node, type, handler, useCaptureOrOptions);
}
function _wrapAsStandardMouseEvent(handler) {
  return function(e) {
    return handler(new StandardMouseEvent(e));
  };
}
function _wrapAsStandardKeyboardEvent(handler) {
  return function(e) {
    return handler(new StandardKeyboardEvent(e));
  };
}
var addStandardDisposableListener = function addStandardDisposableListener2(node, type, handler, useCapture) {
  let wrapHandler = handler;
  if (type === "click" || type === "mousedown") {
    wrapHandler = _wrapAsStandardMouseEvent(handler);
  } else if (type === "keydown" || type === "keypress" || type === "keyup") {
    wrapHandler = _wrapAsStandardKeyboardEvent(handler);
  }
  return addDisposableListener(node, type, wrapHandler, useCapture);
};
function addDisposableNonBubblingMouseOutListener(node, handler) {
  return addDisposableListener(node, "mouseout", (e) => {
    let toElement = e.relatedTarget;
    while (toElement && toElement !== node) {
      toElement = toElement.parentNode;
    }
    if (toElement === node) {
      return;
    }
    handler(e);
  });
}
function addDisposableNonBubblingPointerOutListener(node, handler) {
  return addDisposableListener(node, "pointerout", (e) => {
    let toElement = e.relatedTarget;
    while (toElement && toElement !== node) {
      toElement = toElement.parentNode;
    }
    if (toElement === node) {
      return;
    }
    handler(e);
  });
}
var _animationFrame = null;
function doRequestAnimationFrame(callback) {
  if (!_animationFrame) {
    const emulatedRequestAnimationFrame = (callback2) => {
      return setTimeout(() => callback2(new Date().getTime()), 0);
    };
    _animationFrame = self.requestAnimationFrame || self.msRequestAnimationFrame || self.webkitRequestAnimationFrame || self.mozRequestAnimationFrame || self.oRequestAnimationFrame || emulatedRequestAnimationFrame;
  }
  return _animationFrame.call(self, callback);
}
var runAtThisOrScheduleAtNextAnimationFrame;
var scheduleAtNextAnimationFrame;
var AnimationFrameQueueItem = class {
  constructor(runner, priority = 0) {
    this._runner = runner;
    this.priority = priority;
    this._canceled = false;
  }
  dispose() {
    this._canceled = true;
  }
  execute() {
    if (this._canceled) {
      return;
    }
    try {
      this._runner();
    } catch (e) {
      onUnexpectedError(e);
    }
  }
  static sort(a, b) {
    return b.priority - a.priority;
  }
};
(function() {
  let NEXT_QUEUE = [];
  let CURRENT_QUEUE = null;
  let animFrameRequested = false;
  let inAnimationFrameRunner = false;
  let animationFrameRunner = () => {
    animFrameRequested = false;
    CURRENT_QUEUE = NEXT_QUEUE;
    NEXT_QUEUE = [];
    inAnimationFrameRunner = true;
    while (CURRENT_QUEUE.length > 0) {
      CURRENT_QUEUE.sort(AnimationFrameQueueItem.sort);
      let top = CURRENT_QUEUE.shift();
      top.execute();
    }
    inAnimationFrameRunner = false;
  };
  scheduleAtNextAnimationFrame = (runner, priority = 0) => {
    let item = new AnimationFrameQueueItem(runner, priority);
    NEXT_QUEUE.push(item);
    if (!animFrameRequested) {
      animFrameRequested = true;
      doRequestAnimationFrame(animationFrameRunner);
    }
    return item;
  };
  runAtThisOrScheduleAtNextAnimationFrame = (runner, priority) => {
    if (inAnimationFrameRunner) {
      let item = new AnimationFrameQueueItem(runner, priority);
      CURRENT_QUEUE.push(item);
      return item;
    } else {
      return scheduleAtNextAnimationFrame(runner, priority);
    }
  };
})();
var MINIMUM_TIME_MS = 16;
var DEFAULT_EVENT_MERGER = function(lastEvent, currentEvent) {
  return currentEvent;
};
var TimeoutThrottledDomListener = class extends Disposable {
  constructor(node, type, handler, eventMerger = DEFAULT_EVENT_MERGER, minimumTimeMs = MINIMUM_TIME_MS) {
    super();
    let lastEvent = null;
    let lastHandlerTime = 0;
    let timeout2 = this._register(new TimeoutTimer());
    let invokeHandler = () => {
      lastHandlerTime = new Date().getTime();
      handler(lastEvent);
      lastEvent = null;
    };
    this._register(addDisposableListener(node, type, (e) => {
      lastEvent = eventMerger(lastEvent, e);
      let elapsedTime = new Date().getTime() - lastHandlerTime;
      if (elapsedTime >= minimumTimeMs) {
        timeout2.cancel();
        invokeHandler();
      } else {
        timeout2.setIfNotSet(invokeHandler, minimumTimeMs - elapsedTime);
      }
    }));
  }
};
function addDisposableThrottledListener(node, type, handler, eventMerger, minimumTimeMs) {
  return new TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs);
}
function getComputedStyle2(el) {
  return document.defaultView.getComputedStyle(el, null);
}
function getClientArea(element) {
  if (element !== document.body) {
    return new Dimension(element.clientWidth, element.clientHeight);
  }
  if (isIOS && window.visualViewport) {
    const width = window.visualViewport.width;
    const height = window.visualViewport.height - (isStandalone ? 20 + 4 : 0);
    return new Dimension(width, height);
  }
  if (window.innerWidth && window.innerHeight) {
    return new Dimension(window.innerWidth, window.innerHeight);
  }
  if (document.body && document.body.clientWidth && document.body.clientHeight) {
    return new Dimension(document.body.clientWidth, document.body.clientHeight);
  }
  if (document.documentElement && document.documentElement.clientWidth && document.documentElement.clientHeight) {
    return new Dimension(document.documentElement.clientWidth, document.documentElement.clientHeight);
  }
  throw new Error("Unable to figure out browser width and height");
}
var SizeUtils = class {
  static convertToPixels(element, value) {
    return parseFloat(value) || 0;
  }
  static getDimension(element, cssPropertyName, jsPropertyName) {
    let computedStyle = getComputedStyle2(element);
    let value = "0";
    if (computedStyle) {
      if (computedStyle.getPropertyValue) {
        value = computedStyle.getPropertyValue(cssPropertyName);
      } else {
        value = computedStyle.getAttribute(jsPropertyName);
      }
    }
    return SizeUtils.convertToPixels(element, value);
  }
  static getBorderLeftWidth(element) {
    return SizeUtils.getDimension(element, "border-left-width", "borderLeftWidth");
  }
  static getBorderRightWidth(element) {
    return SizeUtils.getDimension(element, "border-right-width", "borderRightWidth");
  }
  static getBorderTopWidth(element) {
    return SizeUtils.getDimension(element, "border-top-width", "borderTopWidth");
  }
  static getBorderBottomWidth(element) {
    return SizeUtils.getDimension(element, "border-bottom-width", "borderBottomWidth");
  }
  static getPaddingLeft(element) {
    return SizeUtils.getDimension(element, "padding-left", "paddingLeft");
  }
  static getPaddingRight(element) {
    return SizeUtils.getDimension(element, "padding-right", "paddingRight");
  }
  static getPaddingTop(element) {
    return SizeUtils.getDimension(element, "padding-top", "paddingTop");
  }
  static getPaddingBottom(element) {
    return SizeUtils.getDimension(element, "padding-bottom", "paddingBottom");
  }
  static getMarginLeft(element) {
    return SizeUtils.getDimension(element, "margin-left", "marginLeft");
  }
  static getMarginTop(element) {
    return SizeUtils.getDimension(element, "margin-top", "marginTop");
  }
  static getMarginRight(element) {
    return SizeUtils.getDimension(element, "margin-right", "marginRight");
  }
  static getMarginBottom(element) {
    return SizeUtils.getDimension(element, "margin-bottom", "marginBottom");
  }
};
var Dimension = class {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }
};
function getTopLeftOffset(element) {
  let offsetParent = element.offsetParent;
  let top = element.offsetTop;
  let left = element.offsetLeft;
  while ((element = element.parentNode) !== null && element !== document.body && element !== document.documentElement) {
    top -= element.scrollTop;
    const c = isShadowRoot(element) ? null : getComputedStyle2(element);
    if (c) {
      left -= c.direction !== "rtl" ? element.scrollLeft : -element.scrollLeft;
    }
    if (element === offsetParent) {
      left += SizeUtils.getBorderLeftWidth(element);
      top += SizeUtils.getBorderTopWidth(element);
      top += element.offsetTop;
      left += element.offsetLeft;
      offsetParent = element.offsetParent;
    }
  }
  return {
    left,
    top
  };
}
function getDomNodePagePosition(domNode) {
  let bb = domNode.getBoundingClientRect();
  return {
    left: bb.left + StandardWindow.scrollX,
    top: bb.top + StandardWindow.scrollY,
    width: bb.width,
    height: bb.height
  };
}
var StandardWindow = new class {
  get scrollX() {
    if (typeof window.scrollX === "number") {
      return window.scrollX;
    } else {
      return document.body.scrollLeft + document.documentElement.scrollLeft;
    }
  }
  get scrollY() {
    if (typeof window.scrollY === "number") {
      return window.scrollY;
    } else {
      return document.body.scrollTop + document.documentElement.scrollTop;
    }
  }
}();
function getTotalWidth(element) {
  let margin = SizeUtils.getMarginLeft(element) + SizeUtils.getMarginRight(element);
  return element.offsetWidth + margin;
}
function getContentWidth(element) {
  let border = SizeUtils.getBorderLeftWidth(element) + SizeUtils.getBorderRightWidth(element);
  let padding = SizeUtils.getPaddingLeft(element) + SizeUtils.getPaddingRight(element);
  return element.offsetWidth - border - padding;
}
function getContentHeight(element) {
  let border = SizeUtils.getBorderTopWidth(element) + SizeUtils.getBorderBottomWidth(element);
  let padding = SizeUtils.getPaddingTop(element) + SizeUtils.getPaddingBottom(element);
  return element.offsetHeight - border - padding;
}
function getTotalHeight(element) {
  let margin = SizeUtils.getMarginTop(element) + SizeUtils.getMarginBottom(element);
  return element.offsetHeight + margin;
}
function isAncestor(testChild, testAncestor) {
  while (testChild) {
    if (testChild === testAncestor) {
      return true;
    }
    testChild = testChild.parentNode;
  }
  return false;
}
function findParentWithClass(node, clazz, stopAtClazzOrNode) {
  while (node && node.nodeType === node.ELEMENT_NODE) {
    if (hasClass(node, clazz)) {
      return node;
    }
    if (stopAtClazzOrNode) {
      if (typeof stopAtClazzOrNode === "string") {
        if (hasClass(node, stopAtClazzOrNode)) {
          return null;
        }
      } else {
        if (node === stopAtClazzOrNode) {
          return null;
        }
      }
    }
    node = node.parentNode;
  }
  return null;
}
function hasParentWithClass(node, clazz, stopAtClazzOrNode) {
  return !!findParentWithClass(node, clazz, stopAtClazzOrNode);
}
function isShadowRoot(node) {
  return node && !!node.host && !!node.mode;
}
function isInShadowDOM(domNode) {
  return !!getShadowRoot(domNode);
}
function getShadowRoot(domNode) {
  while (domNode.parentNode) {
    if (domNode === document.body) {
      return null;
    }
    domNode = domNode.parentNode;
  }
  return isShadowRoot(domNode) ? domNode : null;
}
function getActiveElement() {
  let result = document.activeElement;
  while (result === null || result === void 0 ? void 0 : result.shadowRoot) {
    result = result.shadowRoot.activeElement;
  }
  return result;
}
function createStyleSheet(container = document.getElementsByTagName("head")[0]) {
  let style = document.createElement("style");
  style.type = "text/css";
  style.media = "screen";
  container.appendChild(style);
  return style;
}
var _sharedStyleSheet = null;
function getSharedStyleSheet() {
  if (!_sharedStyleSheet) {
    _sharedStyleSheet = createStyleSheet();
  }
  return _sharedStyleSheet;
}
function getDynamicStyleSheetRules(style) {
  if (style && style.sheet && style.sheet.rules) {
    return style.sheet.rules;
  }
  if (style && style.sheet && style.sheet.cssRules) {
    return style.sheet.cssRules;
  }
  return [];
}
function createCSSRule(selector, cssText, style = getSharedStyleSheet()) {
  if (!style || !cssText) {
    return;
  }
  style.sheet.insertRule(selector + "{" + cssText + "}", 0);
}
function removeCSSRulesContainingSelector(ruleName, style = getSharedStyleSheet()) {
  if (!style) {
    return;
  }
  let rules = getDynamicStyleSheetRules(style);
  let toDelete = [];
  for (let i = 0; i < rules.length; i++) {
    let rule = rules[i];
    if (rule.selectorText.indexOf(ruleName) !== -1) {
      toDelete.push(i);
    }
  }
  for (let i = toDelete.length - 1; i >= 0; i--) {
    style.sheet.deleteRule(toDelete[i]);
  }
}
function isHTMLElement(o) {
  if (typeof HTMLElement === "object") {
    return o instanceof HTMLElement;
  }
  return o && typeof o === "object" && o.nodeType === 1 && typeof o.nodeName === "string";
}
var EventType = {
  CLICK: "click",
  AUXCLICK: "auxclick",
  DBLCLICK: "dblclick",
  MOUSE_UP: "mouseup",
  MOUSE_DOWN: "mousedown",
  MOUSE_OVER: "mouseover",
  MOUSE_MOVE: "mousemove",
  MOUSE_OUT: "mouseout",
  MOUSE_ENTER: "mouseenter",
  MOUSE_LEAVE: "mouseleave",
  MOUSE_WHEEL: isEdge ? "mousewheel" : "wheel",
  POINTER_UP: "pointerup",
  POINTER_DOWN: "pointerdown",
  POINTER_MOVE: "pointermove",
  CONTEXT_MENU: "contextmenu",
  WHEEL: "wheel",
  KEY_DOWN: "keydown",
  KEY_PRESS: "keypress",
  KEY_UP: "keyup",
  LOAD: "load",
  BEFORE_UNLOAD: "beforeunload",
  UNLOAD: "unload",
  ABORT: "abort",
  ERROR: "error",
  RESIZE: "resize",
  SCROLL: "scroll",
  FULLSCREEN_CHANGE: "fullscreenchange",
  WK_FULLSCREEN_CHANGE: "webkitfullscreenchange",
  SELECT: "select",
  CHANGE: "change",
  SUBMIT: "submit",
  RESET: "reset",
  FOCUS: "focus",
  FOCUS_IN: "focusin",
  FOCUS_OUT: "focusout",
  BLUR: "blur",
  INPUT: "input",
  STORAGE: "storage",
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "drop",
  DRAG_END: "dragend",
  ANIMATION_START: isWebKit ? "webkitAnimationStart" : "animationstart",
  ANIMATION_END: isWebKit ? "webkitAnimationEnd" : "animationend",
  ANIMATION_ITERATION: isWebKit ? "webkitAnimationIteration" : "animationiteration"
};
var EventHelper = {
  stop: function(e, cancelBubble) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
    if (cancelBubble) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }
    }
  }
};
function saveParentsScrollTop(node) {
  let r = [];
  for (let i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
    r[i] = node.scrollTop;
    node = node.parentNode;
  }
  return r;
}
function restoreParentsScrollTop(node, state) {
  for (let i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
    if (node.scrollTop !== state[i]) {
      node.scrollTop = state[i];
    }
    node = node.parentNode;
  }
}
var FocusTracker = class extends Disposable {
  constructor(element) {
    super();
    this._onDidFocus = this._register(new Emitter());
    this.onDidFocus = this._onDidFocus.event;
    this._onDidBlur = this._register(new Emitter());
    this.onDidBlur = this._onDidBlur.event;
    let hasFocus = isAncestor(document.activeElement, element);
    let loosingFocus = false;
    const onFocus = () => {
      loosingFocus = false;
      if (!hasFocus) {
        hasFocus = true;
        this._onDidFocus.fire();
      }
    };
    const onBlur = () => {
      if (hasFocus) {
        loosingFocus = true;
        window.setTimeout(() => {
          if (loosingFocus) {
            loosingFocus = false;
            hasFocus = false;
            this._onDidBlur.fire();
          }
        }, 0);
      }
    };
    this._refreshStateHandler = () => {
      let currentNodeHasFocus = isAncestor(document.activeElement, element);
      if (currentNodeHasFocus !== hasFocus) {
        if (hasFocus) {
          onBlur();
        } else {
          onFocus();
        }
      }
    };
    this._register(domEvent(element, EventType.FOCUS, true)(onFocus));
    this._register(domEvent(element, EventType.BLUR, true)(onBlur));
  }
};
function trackFocus(element) {
  return new FocusTracker(element);
}
function append(parent, ...children) {
  children.forEach((child) => parent.appendChild(child));
  return children[children.length - 1];
}
var SELECTOR_REGEX = /([\w\-]+)?(#([\w\-]+))?((\.([\w\-]+))*)/;
function reset(parent, ...children) {
  parent.innerText = "";
  coalesce(children).forEach((child) => {
    if (child instanceof Node) {
      parent.appendChild(child);
    } else {
      parent.appendChild(document.createTextNode(child));
    }
  });
}
var Namespace;
(function(Namespace2) {
  Namespace2["HTML"] = "http://www.w3.org/1999/xhtml";
  Namespace2["SVG"] = "http://www.w3.org/2000/svg";
})(Namespace || (Namespace = {}));
function _$(namespace, description, attrs, ...children) {
  let match2 = SELECTOR_REGEX.exec(description);
  if (!match2) {
    throw new Error("Bad use of emmet");
  }
  attrs = Object.assign({}, attrs || {});
  let tagName = match2[1] || "div";
  let result;
  if (namespace !== Namespace.HTML) {
    result = document.createElementNS(namespace, tagName);
  } else {
    result = document.createElement(tagName);
  }
  if (match2[3]) {
    result.id = match2[3];
  }
  if (match2[4]) {
    result.className = match2[4].replace(/\./g, " ").trim();
  }
  Object.keys(attrs).forEach((name) => {
    const value = attrs[name];
    if (typeof value === "undefined") {
      return;
    }
    if (/^on\w+$/.test(name)) {
      result[name] = value;
    } else if (name === "selected") {
      if (value) {
        result.setAttribute(name, "true");
      }
    } else {
      result.setAttribute(name, value);
    }
  });
  coalesce(children).forEach((child) => {
    if (child instanceof Node) {
      result.appendChild(child);
    } else {
      result.appendChild(document.createTextNode(child));
    }
  });
  return result;
}
function $(description, attrs, ...children) {
  return _$(Namespace.HTML, description, attrs, ...children);
}
$.SVG = function(description, attrs, ...children) {
  return _$(Namespace.SVG, description, attrs, ...children);
};
function show(...elements) {
  for (let element of elements) {
    element.style.display = "";
    element.removeAttribute("aria-hidden");
  }
}
function hide(...elements) {
  for (let element of elements) {
    element.style.display = "none";
    element.setAttribute("aria-hidden", "true");
  }
}
function findParentWithAttribute(node, attribute) {
  while (node && node.nodeType === node.ELEMENT_NODE) {
    if (node instanceof HTMLElement && node.hasAttribute(attribute)) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
}
function removeTabIndexAndUpdateFocus(node) {
  if (!node || !node.hasAttribute("tabIndex")) {
    return;
  }
  if (document.activeElement === node) {
    let parentFocusable = findParentWithAttribute(node.parentElement, "tabIndex");
    if (parentFocusable) {
      parentFocusable.focus();
    }
  }
  node.removeAttribute("tabindex");
}
function getElementsByTagName(tag) {
  return Array.prototype.slice.call(document.getElementsByTagName(tag), 0);
}
function computeScreenAwareSize(cssPx) {
  const screenPx = window.devicePixelRatio * cssPx;
  return Math.max(1, Math.floor(screenPx)) / window.devicePixelRatio;
}
function windowOpenNoOpener(url) {
  if (isNative || isEdgeWebView) {
    window.open(url);
  } else {
    let newTab = window.open();
    if (newTab) {
      newTab.opener = null;
      newTab.location.href = url;
    }
  }
}
function animate(fn) {
  const step = () => {
    fn();
    stepDisposable = scheduleAtNextAnimationFrame(step);
  };
  let stepDisposable = scheduleAtNextAnimationFrame(step);
  return toDisposable(() => stepDisposable.dispose());
}
RemoteAuthorities.setPreferredWebSchema(/^https:/.test(window.location.href) ? "https" : "http");
function asDomUri(uri) {
  if (!uri) {
    return uri;
  }
  if (Schemas.vscodeRemote === uri.scheme) {
    return RemoteAuthorities.rewrite(uri);
  }
  return uri;
}
function asCSSUrl(uri) {
  if (!uri) {
    return `url('')`;
  }
  return `url('${asDomUri(uri).toString(true).replace(/'/g, "%27")}')`;
}

// ../../node_modules/monaco-editor/esm/vs/base/common/strings.js
function isFalsyOrWhitespace(str) {
  if (!str || typeof str !== "string") {
    return true;
  }
  return str.trim().length === 0;
}
var _formatRegexp = /{(\d+)}/g;
function format(value, ...args) {
  if (args.length === 0) {
    return value;
  }
  return value.replace(_formatRegexp, function(match2, group) {
    const idx = parseInt(group, 10);
    return isNaN(idx) || idx < 0 || idx >= args.length ? match2 : args[idx];
  });
}
function escape(html) {
  return html.replace(/[<>&]/g, function(match2) {
    switch (match2) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      default:
        return match2;
    }
  });
}
function escapeRegExpCharacters(value) {
  return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function ltrim(haystack, needle) {
  if (!haystack || !needle) {
    return haystack;
  }
  const needleLen = needle.length;
  if (needleLen === 0 || haystack.length === 0) {
    return haystack;
  }
  let offset = 0;
  while (haystack.indexOf(needle, offset) === offset) {
    offset = offset + needleLen;
  }
  return haystack.substring(offset);
}
function rtrim(haystack, needle) {
  if (!haystack || !needle) {
    return haystack;
  }
  const needleLen = needle.length, haystackLen = haystack.length;
  if (needleLen === 0 || haystackLen === 0) {
    return haystack;
  }
  let offset = haystackLen, idx = -1;
  while (true) {
    idx = haystack.lastIndexOf(needle, offset - 1);
    if (idx === -1 || idx + needleLen !== offset) {
      break;
    }
    if (idx === 0) {
      return "";
    }
    offset = idx;
  }
  return haystack.substring(0, offset);
}
function convertSimple2RegExpPattern(pattern) {
  return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&").replace(/[\*]/g, ".*");
}
function startsWith(haystack, needle) {
  if (haystack.length < needle.length) {
    return false;
  }
  if (haystack === needle) {
    return true;
  }
  for (let i = 0; i < needle.length; i++) {
    if (haystack[i] !== needle[i]) {
      return false;
    }
  }
  return true;
}
function endsWith(haystack, needle) {
  const diff = haystack.length - needle.length;
  if (diff > 0) {
    return haystack.indexOf(needle, diff) === diff;
  } else if (diff === 0) {
    return haystack === needle;
  } else {
    return false;
  }
}
function createRegExp(searchString, isRegex, options = {}) {
  if (!searchString) {
    throw new Error("Cannot create regex from empty string");
  }
  if (!isRegex) {
    searchString = escapeRegExpCharacters(searchString);
  }
  if (options.wholeWord) {
    if (!/\B/.test(searchString.charAt(0))) {
      searchString = "\\b" + searchString;
    }
    if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
      searchString = searchString + "\\b";
    }
  }
  let modifiers = "";
  if (options.global) {
    modifiers += "g";
  }
  if (!options.matchCase) {
    modifiers += "i";
  }
  if (options.multiline) {
    modifiers += "m";
  }
  if (options.unicode) {
    modifiers += "u";
  }
  return new RegExp(searchString, modifiers);
}
function regExpLeadsToEndlessLoop(regexp) {
  if (regexp.source === "^" || regexp.source === "^$" || regexp.source === "$" || regexp.source === "^\\s*$") {
    return false;
  }
  const match2 = regexp.exec("");
  return !!(match2 && regexp.lastIndex === 0);
}
function regExpFlags(regexp) {
  return (regexp.global ? "g" : "") + (regexp.ignoreCase ? "i" : "") + (regexp.multiline ? "m" : "") + (regexp.unicode ? "u" : "");
}
function firstNonWhitespaceIndex(str) {
  for (let i = 0, len = str.length; i < len; i++) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 && chCode !== 9) {
      return i;
    }
  }
  return -1;
}
function getLeadingWhitespace(str, start = 0, end = str.length) {
  for (let i = start; i < end; i++) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 && chCode !== 9) {
      return str.substring(start, i);
    }
  }
  return str.substring(start, end);
}
function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
  for (let i = startIndex; i >= 0; i--) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 && chCode !== 9) {
      return i;
    }
  }
  return -1;
}
function compare(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}
function isLowerAsciiLetter(code) {
  return code >= 97 && code <= 122;
}
function isUpperAsciiLetter(code) {
  return code >= 65 && code <= 90;
}
function isAsciiLetter(code) {
  return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);
}
function equalsIgnoreCase(a, b) {
  return a.length === b.length && doEqualsIgnoreCase(a, b);
}
function doEqualsIgnoreCase(a, b, stopAt = a.length) {
  for (let i = 0; i < stopAt; i++) {
    const codeA = a.charCodeAt(i);
    const codeB = b.charCodeAt(i);
    if (codeA === codeB) {
      continue;
    }
    if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {
      const diff = Math.abs(codeA - codeB);
      if (diff !== 0 && diff !== 32) {
        return false;
      }
    } else {
      if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {
        return false;
      }
    }
  }
  return true;
}
function startsWithIgnoreCase(str, candidate) {
  const candidateLength = candidate.length;
  if (candidate.length > str.length) {
    return false;
  }
  return doEqualsIgnoreCase(str, candidate, candidateLength);
}
function commonPrefixLength(a, b) {
  let i, len = Math.min(a.length, b.length);
  for (i = 0; i < len; i++) {
    if (a.charCodeAt(i) !== b.charCodeAt(i)) {
      return i;
    }
  }
  return len;
}
function commonSuffixLength(a, b) {
  let i, len = Math.min(a.length, b.length);
  const aLastIndex = a.length - 1;
  const bLastIndex = b.length - 1;
  for (i = 0; i < len; i++) {
    if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
      return i;
    }
  }
  return len;
}
function isHighSurrogate(charCode) {
  return 55296 <= charCode && charCode <= 56319;
}
function isLowSurrogate(charCode) {
  return 56320 <= charCode && charCode <= 57343;
}
function computeCodePoint(highSurrogate, lowSurrogate) {
  return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
}
function getNextCodePoint(str, len, offset) {
  const charCode = str.charCodeAt(offset);
  if (isHighSurrogate(charCode) && offset + 1 < len) {
    const nextCharCode = str.charCodeAt(offset + 1);
    if (isLowSurrogate(nextCharCode)) {
      return computeCodePoint(charCode, nextCharCode);
    }
  }
  return charCode;
}
function getPrevCodePoint(str, offset) {
  const charCode = str.charCodeAt(offset - 1);
  if (isLowSurrogate(charCode) && offset > 1) {
    const prevCharCode = str.charCodeAt(offset - 2);
    if (isHighSurrogate(prevCharCode)) {
      return computeCodePoint(prevCharCode, charCode);
    }
  }
  return charCode;
}
function nextCharLength(str, offset) {
  const graphemeBreakTree = GraphemeBreakTree.getInstance();
  const initialOffset = offset;
  const len = str.length;
  const initialCodePoint = getNextCodePoint(str, len, offset);
  offset += initialCodePoint >= 65536 ? 2 : 1;
  let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(initialCodePoint);
  while (offset < len) {
    const nextCodePoint = getNextCodePoint(str, len, offset);
    const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(nextCodePoint);
    if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
      break;
    }
    offset += nextCodePoint >= 65536 ? 2 : 1;
    graphemeBreakType = nextGraphemeBreakType;
  }
  return offset - initialOffset;
}
function prevCharLength(str, offset) {
  const graphemeBreakTree = GraphemeBreakTree.getInstance();
  const initialOffset = offset;
  const initialCodePoint = getPrevCodePoint(str, offset);
  offset -= initialCodePoint >= 65536 ? 2 : 1;
  let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(initialCodePoint);
  while (offset > 0) {
    const prevCodePoint = getPrevCodePoint(str, offset);
    const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(prevCodePoint);
    if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {
      break;
    }
    offset -= prevCodePoint >= 65536 ? 2 : 1;
    graphemeBreakType = prevGraphemeBreakType;
  }
  return initialOffset - offset;
}
function decodeUTF8(buffer4) {
  const len = buffer4.byteLength;
  const result = [];
  let offset = 0;
  while (offset < len) {
    const v0 = buffer4[offset];
    let codePoint;
    if (v0 >= 240 && offset + 3 < len) {
      codePoint = (buffer4[offset++] & 7) << 18 >>> 0 | (buffer4[offset++] & 63) << 12 >>> 0 | (buffer4[offset++] & 63) << 6 >>> 0 | (buffer4[offset++] & 63) << 0 >>> 0;
    } else if (v0 >= 224 && offset + 2 < len) {
      codePoint = (buffer4[offset++] & 15) << 12 >>> 0 | (buffer4[offset++] & 63) << 6 >>> 0 | (buffer4[offset++] & 63) << 0 >>> 0;
    } else if (v0 >= 192 && offset + 1 < len) {
      codePoint = (buffer4[offset++] & 31) << 6 >>> 0 | (buffer4[offset++] & 63) << 0 >>> 0;
    } else {
      codePoint = buffer4[offset++];
    }
    if (codePoint >= 0 && codePoint <= 55295 || codePoint >= 57344 && codePoint <= 65535) {
      result.push(String.fromCharCode(codePoint));
    } else if (codePoint >= 65536 && codePoint <= 1114111) {
      const uPrime = codePoint - 65536;
      const w1 = 55296 + ((uPrime & 1047552) >>> 10);
      const w2 = 56320 + ((uPrime & 1023) >>> 0);
      result.push(String.fromCharCode(w1));
      result.push(String.fromCharCode(w2));
    } else {
      result.push(String.fromCharCode(65533));
    }
  }
  return result.join("");
}
var CONTAINS_RTL = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u08BD\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE33\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDCFF]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD50-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
function containsRTL(str) {
  return CONTAINS_RTL.test(str);
}
var CONTAINS_EMOJI = /(?:[\u231A\u231B\u23F0\u23F3\u2600-\u27BF\u2B50\u2B55]|\uD83C[\uDDE6-\uDDFF\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F\uDE80-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD00-\uDDFF\uDE70-\uDE73\uDE78-\uDE82\uDE90-\uDE95])/;
function containsEmoji(str) {
  return CONTAINS_EMOJI.test(str);
}
var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
function isBasicASCII(str) {
  return IS_BASIC_ASCII.test(str);
}
var UNUSUAL_LINE_TERMINATORS = /[\u2028\u2029]/;
function containsUnusualLineTerminators(str) {
  return UNUSUAL_LINE_TERMINATORS.test(str);
}
function containsFullWidthCharacter(str) {
  for (let i = 0, len = str.length; i < len; i++) {
    if (isFullWidthCharacter(str.charCodeAt(i))) {
      return true;
    }
  }
  return false;
}
function isFullWidthCharacter(charCode) {
  charCode = +charCode;
  return charCode >= 11904 && charCode <= 55215 || charCode >= 63744 && charCode <= 64255 || charCode >= 65281 && charCode <= 65374;
}
function isEmojiImprecise(x) {
  return x >= 127462 && x <= 127487 || x >= 9728 && x <= 10175 || x >= 127744 && x <= 128591 || x >= 128640 && x <= 128764 || x >= 128992 && x <= 129003 || x >= 129280 && x <= 129535 || x >= 129648 && x <= 129651 || x >= 129656 && x <= 129666 || x >= 129680 && x <= 129685;
}
var UTF8_BOM_CHARACTER = String.fromCharCode(65279);
function startsWithUTF8BOM(str) {
  return !!(str && str.length > 0 && str.charCodeAt(0) === 65279);
}
function singleLetterHash(n) {
  const LETTERS_CNT = 90 - 65 + 1;
  n = n % (2 * LETTERS_CNT);
  if (n < LETTERS_CNT) {
    return String.fromCharCode(97 + n);
  }
  return String.fromCharCode(65 + n - LETTERS_CNT);
}
function getGraphemeBreakType(codePoint) {
  const graphemeBreakTree = GraphemeBreakTree.getInstance();
  return graphemeBreakTree.getGraphemeBreakType(codePoint);
}
function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
  if (breakTypeA === 0) {
    return breakTypeB !== 5 && breakTypeB !== 7;
  }
  if (breakTypeA === 2) {
    if (breakTypeB === 3) {
      return false;
    }
  }
  if (breakTypeA === 4 || breakTypeA === 2 || breakTypeA === 3) {
    return true;
  }
  if (breakTypeB === 4 || breakTypeB === 2 || breakTypeB === 3) {
    return true;
  }
  if (breakTypeA === 8) {
    if (breakTypeB === 8 || breakTypeB === 9 || breakTypeB === 11 || breakTypeB === 12) {
      return false;
    }
  }
  if (breakTypeA === 11 || breakTypeA === 9) {
    if (breakTypeB === 9 || breakTypeB === 10) {
      return false;
    }
  }
  if (breakTypeA === 12 || breakTypeA === 10) {
    if (breakTypeB === 10) {
      return false;
    }
  }
  if (breakTypeB === 5 || breakTypeB === 13) {
    return false;
  }
  if (breakTypeB === 7) {
    return false;
  }
  if (breakTypeA === 1) {
    return false;
  }
  if (breakTypeA === 13 && breakTypeB === 14) {
    return false;
  }
  if (breakTypeA === 6 && breakTypeB === 6) {
    return false;
  }
  return true;
}
var GraphemeBreakTree = class {
  constructor() {
    this._data = getGraphemeBreakRawData();
  }
  static getInstance() {
    if (!GraphemeBreakTree._INSTANCE) {
      GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();
    }
    return GraphemeBreakTree._INSTANCE;
  }
  getGraphemeBreakType(codePoint) {
    if (codePoint < 32) {
      if (codePoint === 10) {
        return 3;
      }
      if (codePoint === 13) {
        return 2;
      }
      return 4;
    }
    if (codePoint < 127) {
      return 0;
    }
    const data = this._data;
    const nodeCount = data.length / 3;
    let nodeIndex = 1;
    while (nodeIndex <= nodeCount) {
      if (codePoint < data[3 * nodeIndex]) {
        nodeIndex = 2 * nodeIndex;
      } else if (codePoint > data[3 * nodeIndex + 1]) {
        nodeIndex = 2 * nodeIndex + 1;
      } else {
        return data[3 * nodeIndex + 2];
      }
    }
    return 0;
  }
};
GraphemeBreakTree._INSTANCE = null;
function getGraphemeBreakRawData() {
  return JSON.parse("[0,0,0,51592,51592,11,44424,44424,11,72251,72254,5,7150,7150,7,48008,48008,11,55176,55176,11,128420,128420,14,3276,3277,5,9979,9980,14,46216,46216,11,49800,49800,11,53384,53384,11,70726,70726,5,122915,122916,5,129320,129327,14,2558,2558,5,5906,5908,5,9762,9763,14,43360,43388,8,45320,45320,11,47112,47112,11,48904,48904,11,50696,50696,11,52488,52488,11,54280,54280,11,70082,70083,1,71350,71350,7,73111,73111,5,127892,127893,14,128726,128727,14,129473,129474,14,2027,2035,5,2901,2902,5,3784,3789,5,6754,6754,5,8418,8420,5,9877,9877,14,11088,11088,14,44008,44008,5,44872,44872,11,45768,45768,11,46664,46664,11,47560,47560,11,48456,48456,11,49352,49352,11,50248,50248,11,51144,51144,11,52040,52040,11,52936,52936,11,53832,53832,11,54728,54728,11,69811,69814,5,70459,70460,5,71096,71099,7,71998,71998,5,72874,72880,5,119149,119149,7,127374,127374,14,128335,128335,14,128482,128482,14,128765,128767,14,129399,129400,14,129680,129685,14,1476,1477,5,2377,2380,7,2759,2760,5,3137,3140,7,3458,3459,7,4153,4154,5,6432,6434,5,6978,6978,5,7675,7679,5,9723,9726,14,9823,9823,14,9919,9923,14,10035,10036,14,42736,42737,5,43596,43596,5,44200,44200,11,44648,44648,11,45096,45096,11,45544,45544,11,45992,45992,11,46440,46440,11,46888,46888,11,47336,47336,11,47784,47784,11,48232,48232,11,48680,48680,11,49128,49128,11,49576,49576,11,50024,50024,11,50472,50472,11,50920,50920,11,51368,51368,11,51816,51816,11,52264,52264,11,52712,52712,11,53160,53160,11,53608,53608,11,54056,54056,11,54504,54504,11,54952,54952,11,68108,68111,5,69933,69940,5,70197,70197,7,70498,70499,7,70845,70845,5,71229,71229,5,71727,71735,5,72154,72155,5,72344,72345,5,73023,73029,5,94095,94098,5,121403,121452,5,126981,127182,14,127538,127546,14,127990,127990,14,128391,128391,14,128445,128449,14,128500,128505,14,128752,128752,14,129160,129167,14,129356,129356,14,129432,129442,14,129648,129651,14,129751,131069,14,173,173,4,1757,1757,1,2274,2274,1,2494,2494,5,2641,2641,5,2876,2876,5,3014,3016,7,3262,3262,7,3393,3396,5,3570,3571,7,3968,3972,5,4228,4228,7,6086,6086,5,6679,6680,5,6912,6915,5,7080,7081,5,7380,7392,5,8252,8252,14,9096,9096,14,9748,9749,14,9784,9786,14,9833,9850,14,9890,9894,14,9938,9938,14,9999,9999,14,10085,10087,14,12349,12349,14,43136,43137,7,43454,43456,7,43755,43755,7,44088,44088,11,44312,44312,11,44536,44536,11,44760,44760,11,44984,44984,11,45208,45208,11,45432,45432,11,45656,45656,11,45880,45880,11,46104,46104,11,46328,46328,11,46552,46552,11,46776,46776,11,47000,47000,11,47224,47224,11,47448,47448,11,47672,47672,11,47896,47896,11,48120,48120,11,48344,48344,11,48568,48568,11,48792,48792,11,49016,49016,11,49240,49240,11,49464,49464,11,49688,49688,11,49912,49912,11,50136,50136,11,50360,50360,11,50584,50584,11,50808,50808,11,51032,51032,11,51256,51256,11,51480,51480,11,51704,51704,11,51928,51928,11,52152,52152,11,52376,52376,11,52600,52600,11,52824,52824,11,53048,53048,11,53272,53272,11,53496,53496,11,53720,53720,11,53944,53944,11,54168,54168,11,54392,54392,11,54616,54616,11,54840,54840,11,55064,55064,11,65438,65439,5,69633,69633,5,69837,69837,1,70018,70018,7,70188,70190,7,70368,70370,7,70465,70468,7,70712,70719,5,70835,70840,5,70850,70851,5,71132,71133,5,71340,71340,7,71458,71461,5,71985,71989,7,72002,72002,7,72193,72202,5,72281,72283,5,72766,72766,7,72885,72886,5,73104,73105,5,92912,92916,5,113824,113827,4,119173,119179,5,121505,121519,5,125136,125142,5,127279,127279,14,127489,127490,14,127570,127743,14,127900,127901,14,128254,128254,14,128369,128370,14,128400,128400,14,128425,128432,14,128468,128475,14,128489,128494,14,128715,128720,14,128745,128745,14,128759,128760,14,129004,129023,14,129296,129304,14,129340,129342,14,129388,129392,14,129404,129407,14,129454,129455,14,129485,129487,14,129659,129663,14,129719,129727,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2363,2363,7,2402,2403,5,2507,2508,7,2622,2624,7,2691,2691,7,2786,2787,5,2881,2884,5,3006,3006,5,3072,3072,5,3170,3171,5,3267,3268,7,3330,3331,7,3406,3406,1,3538,3540,5,3655,3662,5,3897,3897,5,4038,4038,5,4184,4185,5,4352,4447,8,6068,6069,5,6155,6157,5,6448,6449,7,6742,6742,5,6783,6783,5,6966,6970,5,7042,7042,7,7143,7143,7,7212,7219,5,7412,7412,5,8206,8207,4,8294,8303,4,8596,8601,14,9410,9410,14,9742,9742,14,9757,9757,14,9770,9770,14,9794,9794,14,9828,9828,14,9855,9855,14,9882,9882,14,9900,9903,14,9929,9933,14,9963,9967,14,9987,9988,14,10006,10006,14,10062,10062,14,10175,10175,14,11744,11775,5,42607,42607,5,43043,43044,7,43263,43263,5,43444,43445,7,43569,43570,5,43698,43700,5,43766,43766,5,44032,44032,11,44144,44144,11,44256,44256,11,44368,44368,11,44480,44480,11,44592,44592,11,44704,44704,11,44816,44816,11,44928,44928,11,45040,45040,11,45152,45152,11,45264,45264,11,45376,45376,11,45488,45488,11,45600,45600,11,45712,45712,11,45824,45824,11,45936,45936,11,46048,46048,11,46160,46160,11,46272,46272,11,46384,46384,11,46496,46496,11,46608,46608,11,46720,46720,11,46832,46832,11,46944,46944,11,47056,47056,11,47168,47168,11,47280,47280,11,47392,47392,11,47504,47504,11,47616,47616,11,47728,47728,11,47840,47840,11,47952,47952,11,48064,48064,11,48176,48176,11,48288,48288,11,48400,48400,11,48512,48512,11,48624,48624,11,48736,48736,11,48848,48848,11,48960,48960,11,49072,49072,11,49184,49184,11,49296,49296,11,49408,49408,11,49520,49520,11,49632,49632,11,49744,49744,11,49856,49856,11,49968,49968,11,50080,50080,11,50192,50192,11,50304,50304,11,50416,50416,11,50528,50528,11,50640,50640,11,50752,50752,11,50864,50864,11,50976,50976,11,51088,51088,11,51200,51200,11,51312,51312,11,51424,51424,11,51536,51536,11,51648,51648,11,51760,51760,11,51872,51872,11,51984,51984,11,52096,52096,11,52208,52208,11,52320,52320,11,52432,52432,11,52544,52544,11,52656,52656,11,52768,52768,11,52880,52880,11,52992,52992,11,53104,53104,11,53216,53216,11,53328,53328,11,53440,53440,11,53552,53552,11,53664,53664,11,53776,53776,11,53888,53888,11,54000,54000,11,54112,54112,11,54224,54224,11,54336,54336,11,54448,54448,11,54560,54560,11,54672,54672,11,54784,54784,11,54896,54896,11,55008,55008,11,55120,55120,11,64286,64286,5,66272,66272,5,68900,68903,5,69762,69762,7,69817,69818,5,69927,69931,5,70003,70003,5,70070,70078,5,70094,70094,7,70194,70195,7,70206,70206,5,70400,70401,5,70463,70463,7,70475,70477,7,70512,70516,5,70722,70724,5,70832,70832,5,70842,70842,5,70847,70848,5,71088,71089,7,71102,71102,7,71219,71226,5,71231,71232,5,71342,71343,7,71453,71455,5,71463,71467,5,71737,71738,5,71995,71996,5,72000,72000,7,72145,72147,7,72160,72160,5,72249,72249,7,72273,72278,5,72330,72342,5,72752,72758,5,72850,72871,5,72882,72883,5,73018,73018,5,73031,73031,5,73109,73109,5,73461,73462,7,94031,94031,5,94192,94193,7,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,126976,126979,14,127184,127231,14,127344,127345,14,127405,127461,14,127514,127514,14,127561,127567,14,127778,127779,14,127896,127896,14,127985,127986,14,127995,127999,5,128326,128328,14,128360,128366,14,128378,128378,14,128394,128397,14,128405,128406,14,128422,128423,14,128435,128443,14,128453,128464,14,128479,128480,14,128484,128487,14,128496,128498,14,128640,128709,14,128723,128724,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129096,129103,14,129292,129292,14,129311,129311,14,129329,129330,14,129344,129349,14,129360,129374,14,129394,129394,14,129402,129402,14,129413,129425,14,129445,129450,14,129466,129471,14,129483,129483,14,129511,129535,14,129653,129655,14,129667,129670,14,129705,129711,14,129731,129743,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2307,2307,7,2366,2368,7,2382,2383,7,2434,2435,7,2497,2500,5,2519,2519,5,2563,2563,7,2631,2632,5,2677,2677,5,2750,2752,7,2763,2764,7,2817,2817,5,2879,2879,5,2891,2892,7,2914,2915,5,3008,3008,5,3021,3021,5,3076,3076,5,3146,3149,5,3202,3203,7,3264,3265,7,3271,3272,7,3298,3299,5,3390,3390,5,3402,3404,7,3426,3427,5,3535,3535,5,3544,3550,7,3635,3635,7,3763,3763,7,3893,3893,5,3953,3966,5,3981,3991,5,4145,4145,7,4157,4158,5,4209,4212,5,4237,4237,5,4520,4607,10,5970,5971,5,6071,6077,5,6089,6099,5,6277,6278,5,6439,6440,5,6451,6456,7,6683,6683,5,6744,6750,5,6765,6770,7,6846,6846,5,6964,6964,5,6972,6972,5,7019,7027,5,7074,7077,5,7083,7085,5,7146,7148,7,7154,7155,7,7222,7223,5,7394,7400,5,7416,7417,5,8204,8204,5,8233,8233,4,8288,8292,4,8413,8416,5,8482,8482,14,8986,8987,14,9193,9203,14,9654,9654,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9775,14,9792,9792,14,9800,9811,14,9825,9826,14,9831,9831,14,9852,9853,14,9872,9873,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9936,9936,14,9941,9960,14,9974,9974,14,9982,9985,14,9992,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10145,10145,14,11013,11015,14,11503,11505,5,12334,12335,5,12951,12951,14,42612,42621,5,43014,43014,5,43047,43047,7,43204,43205,5,43335,43345,5,43395,43395,7,43450,43451,7,43561,43566,5,43573,43574,5,43644,43644,5,43710,43711,5,43758,43759,7,44005,44005,5,44012,44012,7,44060,44060,11,44116,44116,11,44172,44172,11,44228,44228,11,44284,44284,11,44340,44340,11,44396,44396,11,44452,44452,11,44508,44508,11,44564,44564,11,44620,44620,11,44676,44676,11,44732,44732,11,44788,44788,11,44844,44844,11,44900,44900,11,44956,44956,11,45012,45012,11,45068,45068,11,45124,45124,11,45180,45180,11,45236,45236,11,45292,45292,11,45348,45348,11,45404,45404,11,45460,45460,11,45516,45516,11,45572,45572,11,45628,45628,11,45684,45684,11,45740,45740,11,45796,45796,11,45852,45852,11,45908,45908,11,45964,45964,11,46020,46020,11,46076,46076,11,46132,46132,11,46188,46188,11,46244,46244,11,46300,46300,11,46356,46356,11,46412,46412,11,46468,46468,11,46524,46524,11,46580,46580,11,46636,46636,11,46692,46692,11,46748,46748,11,46804,46804,11,46860,46860,11,46916,46916,11,46972,46972,11,47028,47028,11,47084,47084,11,47140,47140,11,47196,47196,11,47252,47252,11,47308,47308,11,47364,47364,11,47420,47420,11,47476,47476,11,47532,47532,11,47588,47588,11,47644,47644,11,47700,47700,11,47756,47756,11,47812,47812,11,47868,47868,11,47924,47924,11,47980,47980,11,48036,48036,11,48092,48092,11,48148,48148,11,48204,48204,11,48260,48260,11,48316,48316,11,48372,48372,11,48428,48428,11,48484,48484,11,48540,48540,11,48596,48596,11,48652,48652,11,48708,48708,11,48764,48764,11,48820,48820,11,48876,48876,11,48932,48932,11,48988,48988,11,49044,49044,11,49100,49100,11,49156,49156,11,49212,49212,11,49268,49268,11,49324,49324,11,49380,49380,11,49436,49436,11,49492,49492,11,49548,49548,11,49604,49604,11,49660,49660,11,49716,49716,11,49772,49772,11,49828,49828,11,49884,49884,11,49940,49940,11,49996,49996,11,50052,50052,11,50108,50108,11,50164,50164,11,50220,50220,11,50276,50276,11,50332,50332,11,50388,50388,11,50444,50444,11,50500,50500,11,50556,50556,11,50612,50612,11,50668,50668,11,50724,50724,11,50780,50780,11,50836,50836,11,50892,50892,11,50948,50948,11,51004,51004,11,51060,51060,11,51116,51116,11,51172,51172,11,51228,51228,11,51284,51284,11,51340,51340,11,51396,51396,11,51452,51452,11,51508,51508,11,51564,51564,11,51620,51620,11,51676,51676,11,51732,51732,11,51788,51788,11,51844,51844,11,51900,51900,11,51956,51956,11,52012,52012,11,52068,52068,11,52124,52124,11,52180,52180,11,52236,52236,11,52292,52292,11,52348,52348,11,52404,52404,11,52460,52460,11,52516,52516,11,52572,52572,11,52628,52628,11,52684,52684,11,52740,52740,11,52796,52796,11,52852,52852,11,52908,52908,11,52964,52964,11,53020,53020,11,53076,53076,11,53132,53132,11,53188,53188,11,53244,53244,11,53300,53300,11,53356,53356,11,53412,53412,11,53468,53468,11,53524,53524,11,53580,53580,11,53636,53636,11,53692,53692,11,53748,53748,11,53804,53804,11,53860,53860,11,53916,53916,11,53972,53972,11,54028,54028,11,54084,54084,11,54140,54140,11,54196,54196,11,54252,54252,11,54308,54308,11,54364,54364,11,54420,54420,11,54476,54476,11,54532,54532,11,54588,54588,11,54644,54644,11,54700,54700,11,54756,54756,11,54812,54812,11,54868,54868,11,54924,54924,11,54980,54980,11,55036,55036,11,55092,55092,11,55148,55148,11,55216,55238,9,65056,65071,5,65529,65531,4,68097,68099,5,68159,68159,5,69446,69456,5,69688,69702,5,69808,69810,7,69815,69816,7,69821,69821,1,69888,69890,5,69932,69932,7,69957,69958,7,70016,70017,5,70067,70069,7,70079,70080,7,70089,70092,5,70095,70095,5,70191,70193,5,70196,70196,5,70198,70199,5,70367,70367,5,70371,70378,5,70402,70403,7,70462,70462,5,70464,70464,5,70471,70472,7,70487,70487,5,70502,70508,5,70709,70711,7,70720,70721,7,70725,70725,7,70750,70750,5,70833,70834,7,70841,70841,7,70843,70844,7,70846,70846,7,70849,70849,7,71087,71087,5,71090,71093,5,71100,71101,5,71103,71104,5,71216,71218,7,71227,71228,7,71230,71230,7,71339,71339,5,71341,71341,5,71344,71349,5,71351,71351,5,71456,71457,7,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123628,123631,5,125252,125258,5,126980,126980,14,127183,127183,14,127245,127247,14,127340,127343,14,127358,127359,14,127377,127386,14,127462,127487,6,127491,127503,14,127535,127535,14,127548,127551,14,127568,127569,14,127744,127777,14,127780,127891,14,127894,127895,14,127897,127899,14,127902,127984,14,127987,127989,14,127991,127994,14,128000,128253,14,128255,128317,14,128329,128334,14,128336,128359,14,128367,128368,14,128371,128377,14,128379,128390,14,128392,128393,14,128398,128399,14,128401,128404,14,128407,128419,14,128421,128421,14,128424,128424,14,128433,128434,14,128444,128444,14,128450,128452,14,128465,128467,14,128476,128478,14,128481,128481,14,128483,128483,14,128488,128488,14,128495,128495,14,128499,128499,14,128506,128591,14,128710,128714,14,128721,128722,14,128725,128725,14,128728,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129664,129666,14,129671,129679,14,129686,129704,14,129712,129718,14,129728,129730,14,129744,129750,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2259,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3134,3136,5,3142,3144,5,3157,3158,5,3201,3201,5,3260,3260,5,3263,3263,5,3266,3266,5,3270,3270,5,3274,3275,7,3285,3286,5,3328,3329,5,3387,3388,5,3391,3392,7,3398,3400,7,3405,3405,5,3415,3415,5,3457,3457,5,3530,3530,5,3536,3537,7,3542,3542,5,3551,3551,5,3633,3633,5,3636,3642,5,3761,3761,5,3764,3772,5,3864,3865,5,3895,3895,5,3902,3903,7,3967,3967,7,3974,3975,5,3993,4028,5,4141,4144,5,4146,4151,5,4155,4156,7,4182,4183,7,4190,4192,5,4226,4226,5,4229,4230,5,4253,4253,5,4448,4519,9,4957,4959,5,5938,5940,5,6002,6003,5,6070,6070,7,6078,6085,7,6087,6088,7,6109,6109,5,6158,6158,4,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6848,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7673,5,8203,8203,4,8205,8205,13,8232,8232,4,8234,8238,4,8265,8265,14,8293,8293,4,8400,8412,5,8417,8417,5,8421,8432,5,8505,8505,14,8617,8618,14,9000,9000,14,9167,9167,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9776,9783,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9935,14,9937,9937,14,9939,9940,14,9961,9962,14,9968,9973,14,9975,9978,14,9981,9981,14,9986,9986,14,9989,9989,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10084,14,10133,10135,14,10160,10160,14,10548,10549,14,11035,11036,14,11093,11093,14,11647,11647,5,12330,12333,5,12336,12336,14,12441,12442,5,12953,12953,14,42608,42610,5,42654,42655,5,43010,43010,5,43019,43019,5,43045,43046,5,43052,43052,5,43188,43203,7,43232,43249,5,43302,43309,5,43346,43347,7,43392,43394,5,43443,43443,5,43446,43449,5,43452,43453,5,43493,43493,5,43567,43568,7,43571,43572,7,43587,43587,5,43597,43597,7,43696,43696,5,43703,43704,5,43713,43713,5,43756,43757,5,43765,43765,7,44003,44004,7,44006,44007,7,44009,44010,7,44013,44013,5,44033,44059,12,44061,44087,12,44089,44115,12,44117,44143,12,44145,44171,12,44173,44199,12,44201,44227,12,44229,44255,12,44257,44283,12,44285,44311,12,44313,44339,12,44341,44367,12,44369,44395,12,44397,44423,12,44425,44451,12,44453,44479,12,44481,44507,12,44509,44535,12,44537,44563,12,44565,44591,12,44593,44619,12,44621,44647,12,44649,44675,12,44677,44703,12,44705,44731,12,44733,44759,12,44761,44787,12,44789,44815,12,44817,44843,12,44845,44871,12,44873,44899,12,44901,44927,12,44929,44955,12,44957,44983,12,44985,45011,12,45013,45039,12,45041,45067,12,45069,45095,12,45097,45123,12,45125,45151,12,45153,45179,12,45181,45207,12,45209,45235,12,45237,45263,12,45265,45291,12,45293,45319,12,45321,45347,12,45349,45375,12,45377,45403,12,45405,45431,12,45433,45459,12,45461,45487,12,45489,45515,12,45517,45543,12,45545,45571,12,45573,45599,12,45601,45627,12,45629,45655,12,45657,45683,12,45685,45711,12,45713,45739,12,45741,45767,12,45769,45795,12,45797,45823,12,45825,45851,12,45853,45879,12,45881,45907,12,45909,45935,12,45937,45963,12,45965,45991,12,45993,46019,12,46021,46047,12,46049,46075,12,46077,46103,12,46105,46131,12,46133,46159,12,46161,46187,12,46189,46215,12,46217,46243,12,46245,46271,12,46273,46299,12,46301,46327,12,46329,46355,12,46357,46383,12,46385,46411,12,46413,46439,12,46441,46467,12,46469,46495,12,46497,46523,12,46525,46551,12,46553,46579,12,46581,46607,12,46609,46635,12,46637,46663,12,46665,46691,12,46693,46719,12,46721,46747,12,46749,46775,12,46777,46803,12,46805,46831,12,46833,46859,12,46861,46887,12,46889,46915,12,46917,46943,12,46945,46971,12,46973,46999,12,47001,47027,12,47029,47055,12,47057,47083,12,47085,47111,12,47113,47139,12,47141,47167,12,47169,47195,12,47197,47223,12,47225,47251,12,47253,47279,12,47281,47307,12,47309,47335,12,47337,47363,12,47365,47391,12,47393,47419,12,47421,47447,12,47449,47475,12,47477,47503,12,47505,47531,12,47533,47559,12,47561,47587,12,47589,47615,12,47617,47643,12,47645,47671,12,47673,47699,12,47701,47727,12,47729,47755,12,47757,47783,12,47785,47811,12,47813,47839,12,47841,47867,12,47869,47895,12,47897,47923,12,47925,47951,12,47953,47979,12,47981,48007,12,48009,48035,12,48037,48063,12,48065,48091,12,48093,48119,12,48121,48147,12,48149,48175,12,48177,48203,12,48205,48231,12,48233,48259,12,48261,48287,12,48289,48315,12,48317,48343,12,48345,48371,12,48373,48399,12,48401,48427,12,48429,48455,12,48457,48483,12,48485,48511,12,48513,48539,12,48541,48567,12,48569,48595,12,48597,48623,12,48625,48651,12,48653,48679,12,48681,48707,12,48709,48735,12,48737,48763,12,48765,48791,12,48793,48819,12,48821,48847,12,48849,48875,12,48877,48903,12,48905,48931,12,48933,48959,12,48961,48987,12,48989,49015,12,49017,49043,12,49045,49071,12,49073,49099,12,49101,49127,12,49129,49155,12,49157,49183,12,49185,49211,12,49213,49239,12,49241,49267,12,49269,49295,12,49297,49323,12,49325,49351,12,49353,49379,12,49381,49407,12,49409,49435,12,49437,49463,12,49465,49491,12,49493,49519,12,49521,49547,12,49549,49575,12,49577,49603,12,49605,49631,12,49633,49659,12,49661,49687,12,49689,49715,12,49717,49743,12,49745,49771,12,49773,49799,12,49801,49827,12,49829,49855,12,49857,49883,12,49885,49911,12,49913,49939,12,49941,49967,12,49969,49995,12,49997,50023,12,50025,50051,12,50053,50079,12,50081,50107,12,50109,50135,12,50137,50163,12,50165,50191,12,50193,50219,12,50221,50247,12,50249,50275,12,50277,50303,12,50305,50331,12,50333,50359,12,50361,50387,12,50389,50415,12,50417,50443,12,50445,50471,12,50473,50499,12,50501,50527,12,50529,50555,12,50557,50583,12,50585,50611,12,50613,50639,12,50641,50667,12,50669,50695,12,50697,50723,12,50725,50751,12,50753,50779,12,50781,50807,12,50809,50835,12,50837,50863,12,50865,50891,12,50893,50919,12,50921,50947,12,50949,50975,12,50977,51003,12,51005,51031,12,51033,51059,12,51061,51087,12,51089,51115,12,51117,51143,12,51145,51171,12,51173,51199,12,51201,51227,12,51229,51255,12,51257,51283,12,51285,51311,12,51313,51339,12,51341,51367,12,51369,51395,12,51397,51423,12,51425,51451,12,51453,51479,12,51481,51507,12,51509,51535,12,51537,51563,12,51565,51591,12,51593,51619,12,51621,51647,12,51649,51675,12,51677,51703,12,51705,51731,12,51733,51759,12,51761,51787,12,51789,51815,12,51817,51843,12,51845,51871,12,51873,51899,12,51901,51927,12,51929,51955,12,51957,51983,12,51985,52011,12,52013,52039,12,52041,52067,12,52069,52095,12,52097,52123,12,52125,52151,12,52153,52179,12,52181,52207,12,52209,52235,12,52237,52263,12,52265,52291,12,52293,52319,12,52321,52347,12,52349,52375,12,52377,52403,12,52405,52431,12,52433,52459,12,52461,52487,12,52489,52515,12,52517,52543,12,52545,52571,12,52573,52599,12,52601,52627,12,52629,52655,12,52657,52683,12,52685,52711,12,52713,52739,12,52741,52767,12,52769,52795,12,52797,52823,12,52825,52851,12,52853,52879,12,52881,52907,12,52909,52935,12,52937,52963,12,52965,52991,12,52993,53019,12,53021,53047,12,53049,53075,12,53077,53103,12,53105,53131,12,53133,53159,12,53161,53187,12,53189,53215,12,53217,53243,12,53245,53271,12,53273,53299,12,53301,53327,12,53329,53355,12,53357,53383,12,53385,53411,12,53413,53439,12,53441,53467,12,53469,53495,12,53497,53523,12,53525,53551,12,53553,53579,12,53581,53607,12,53609,53635,12,53637,53663,12,53665,53691,12,53693,53719,12,53721,53747,12,53749,53775,12,53777,53803,12,53805,53831,12,53833,53859,12,53861,53887,12,53889,53915,12,53917,53943,12,53945,53971,12,53973,53999,12,54001,54027,12,54029,54055,12,54057,54083,12,54085,54111,12,54113,54139,12,54141,54167,12,54169,54195,12,54197,54223,12,54225,54251,12,54253,54279,12,54281,54307,12,54309,54335,12,54337,54363,12,54365,54391,12,54393,54419,12,54421,54447,12,54449,54475,12,54477,54503,12,54505,54531,12,54533,54559,12,54561,54587,12,54589,54615,12,54617,54643,12,54645,54671,12,54673,54699,12,54701,54727,12,54729,54755,12,54757,54783,12,54785,54811,12,54813,54839,12,54841,54867,12,54869,54895,12,54897,54923,12,54925,54951,12,54953,54979,12,54981,55007,12,55009,55035,12,55037,55063,12,55065,55091,12,55093,55119,12,55121,55147,12,55149,55175,12,55177,55203,12,55243,55291,10,65024,65039,5,65279,65279,4,65520,65528,4,66045,66045,5,66422,66426,5,68101,68102,5,68152,68154,5,68325,68326,5,69291,69292,5,69632,69632,7,69634,69634,7,69759,69761,5]");
}

// ../../node_modules/monaco-editor/esm/vs/base/common/buffer.js
var hasBuffer = typeof Buffer !== "undefined";
var hasTextDecoder = typeof TextDecoder !== "undefined";
var textDecoder;
var VSBuffer = class {
  constructor(buffer4) {
    this.buffer = buffer4;
    this.byteLength = this.buffer.byteLength;
  }
  toString() {
    if (hasBuffer) {
      return this.buffer.toString();
    } else if (hasTextDecoder) {
      if (!textDecoder) {
        textDecoder = new TextDecoder();
      }
      return textDecoder.decode(this.buffer);
    } else {
      return decodeUTF8(this.buffer);
    }
  }
};
function readUInt16LE(source, offset) {
  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0;
}
function writeUInt16LE(destination, value, offset) {
  destination[offset + 0] = value & 255;
  value = value >>> 8;
  destination[offset + 1] = value & 255;
}
function readUInt32BE(source, offset) {
  return source[offset] * Math.pow(2, 24) + source[offset + 1] * Math.pow(2, 16) + source[offset + 2] * Math.pow(2, 8) + source[offset + 3];
}
function writeUInt32BE(destination, value, offset) {
  destination[offset + 3] = value;
  value = value >>> 8;
  destination[offset + 2] = value;
  value = value >>> 8;
  destination[offset + 1] = value;
  value = value >>> 8;
  destination[offset] = value;
}
function readUInt8(source, offset) {
  return source[offset];
}
function writeUInt8(destination, value, offset) {
  destination[offset] = value;
}

// ../../node_modules/monaco-editor/esm/vs/base/common/marshalling.js
function parse(text) {
  let data = JSON.parse(text);
  data = revive(data);
  return data;
}
function revive(obj, depth = 0) {
  if (!obj || depth > 200) {
    return obj;
  }
  if (typeof obj === "object") {
    switch (obj.$mid) {
      case 1:
        return URI.revive(obj);
      case 2:
        return new RegExp(obj.source, obj.flags);
    }
    if (obj instanceof VSBuffer || obj instanceof Uint8Array) {
      return obj;
    }
    if (Array.isArray(obj)) {
      for (let i = 0; i < obj.length; ++i) {
        obj[i] = revive(obj[i], depth + 1);
      }
    } else {
      for (const key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) {
          obj[key] = revive(obj[key], depth + 1);
        }
      }
    }
  }
  return obj;
}

// ../../node_modules/monaco-editor/esm/vs/base/common/extpath.js
function toSlashes(osPath) {
  return osPath.replace(/[\\/]/g, posix.sep);
}
function isEqualOrParent(path, candidate, ignoreCase, separator = sep) {
  if (path === candidate) {
    return true;
  }
  if (!path || !candidate) {
    return false;
  }
  if (candidate.length > path.length) {
    return false;
  }
  if (ignoreCase) {
    const beginsWith = startsWithIgnoreCase(path, candidate);
    if (!beginsWith) {
      return false;
    }
    if (candidate.length === path.length) {
      return true;
    }
    let sepOffset = candidate.length;
    if (candidate.charAt(candidate.length - 1) === separator) {
      sepOffset--;
    }
    return path.charAt(sepOffset) === separator;
  }
  if (candidate.charAt(candidate.length - 1) !== separator) {
    candidate += separator;
  }
  return path.indexOf(candidate) === 0;
}

// ../../node_modules/monaco-editor/esm/vs/base/common/resources.js
function originalFSPath(uri) {
  return uriToFsPath(uri, true);
}
var ExtUri = class {
  constructor(_ignorePathCasing) {
    this._ignorePathCasing = _ignorePathCasing;
  }
  compare(uri1, uri2, ignoreFragment = false) {
    if (uri1 === uri2) {
      return 0;
    }
    return compare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));
  }
  isEqual(uri1, uri2, ignoreFragment = false) {
    if (uri1 === uri2) {
      return true;
    }
    if (!uri1 || !uri2) {
      return false;
    }
    return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);
  }
  getComparisonKey(uri, ignoreFragment = false) {
    return uri.with({
      path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : void 0,
      fragment: ignoreFragment ? null : void 0
    }).toString();
  }
  joinPath(resource, ...pathFragment) {
    return URI.joinPath(resource, ...pathFragment);
  }
  basenameOrAuthority(resource) {
    return basename2(resource) || resource.authority;
  }
  basename(resource) {
    return posix.basename(resource.path);
  }
  dirname(resource) {
    if (resource.path.length === 0) {
      return resource;
    }
    let dirname3;
    if (resource.scheme === Schemas.file) {
      dirname3 = URI.file(dirname(originalFSPath(resource))).path;
    } else {
      dirname3 = posix.dirname(resource.path);
      if (resource.authority && dirname3.length && dirname3.charCodeAt(0) !== 47) {
        console.error(`dirname("${resource.toString})) resulted in a relative path`);
        dirname3 = "/";
      }
    }
    return resource.with({
      path: dirname3
    });
  }
  normalizePath(resource) {
    if (!resource.path.length) {
      return resource;
    }
    let normalizedPath;
    if (resource.scheme === Schemas.file) {
      normalizedPath = URI.file(normalize(originalFSPath(resource))).path;
    } else {
      normalizedPath = posix.normalize(resource.path);
    }
    return resource.with({
      path: normalizedPath
    });
  }
  relativePath(from, to) {
    if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {
      return void 0;
    }
    if (from.scheme === Schemas.file) {
      const relativePath2 = relative(originalFSPath(from), originalFSPath(to));
      return isWindows ? toSlashes(relativePath2) : relativePath2;
    }
    let fromPath = from.path || "/", toPath = to.path || "/";
    if (this._ignorePathCasing(from)) {
      let i = 0;
      for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {
        if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {
          if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {
            break;
          }
        }
      }
      fromPath = toPath.substr(0, i) + fromPath.substr(i);
    }
    return posix.relative(fromPath, toPath);
  }
  resolvePath(base, path) {
    if (base.scheme === Schemas.file) {
      const newURI = URI.file(resolve(originalFSPath(base), path));
      return base.with({
        authority: newURI.authority,
        path: newURI.path
      });
    }
    if (path.indexOf("/") === -1) {
      path = toSlashes(path);
      if (/^[a-zA-Z]:(\/|$)/.test(path)) {
        path = "/" + path;
      }
    }
    return base.with({
      path: posix.resolve(base.path, path)
    });
  }
  isEqualAuthority(a1, a2) {
    return a1 === a2 || equalsIgnoreCase(a1, a2);
  }
};
var extUri = new ExtUri(() => false);
var isEqual = extUri.isEqual.bind(extUri);
var basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);
var basename2 = extUri.basename.bind(extUri);
var dirname2 = extUri.dirname.bind(extUri);
var joinPath = extUri.joinPath.bind(extUri);
var normalizePath = extUri.normalizePath.bind(extUri);
var relativePath = extUri.relativePath.bind(extUri);
var resolvePath = extUri.resolvePath.bind(extUri);
var isEqualAuthority = extUri.isEqualAuthority.bind(extUri);
var DataUri;
(function(DataUri2) {
  DataUri2.META_DATA_LABEL = "label";
  DataUri2.META_DATA_DESCRIPTION = "description";
  DataUri2.META_DATA_SIZE = "size";
  DataUri2.META_DATA_MIME = "mime";
  function parseMetaData(dataUri) {
    const metadata = new Map();
    const meta = dataUri.path.substring(dataUri.path.indexOf(";") + 1, dataUri.path.lastIndexOf(";"));
    meta.split(";").forEach((property) => {
      const [key, value] = property.split(":");
      if (key && value) {
        metadata.set(key, value);
      }
    });
    const mime2 = dataUri.path.substring(0, dataUri.path.indexOf(";"));
    if (mime2) {
      metadata.set(DataUri2.META_DATA_MIME, mime2);
    }
    return metadata;
  }
  DataUri2.parseMetaData = parseMetaData;
})(DataUri || (DataUri = {}));

// ../../node_modules/monaco-editor/esm/vs/base/common/types.js
function isString(str) {
  return typeof str === "string";
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
}
function isNumber(obj) {
  return typeof obj === "number" && !isNaN(obj);
}
function isBoolean(obj) {
  return obj === true || obj === false;
}
function isUndefined(obj) {
  return typeof obj === "undefined";
}
function isUndefinedOrNull(obj) {
  return isUndefined(obj) || obj === null;
}
function isFunction(obj) {
  return typeof obj === "function";
}
function validateConstraints(args, constraints) {
  const len = Math.min(args.length, constraints.length);
  for (let i = 0; i < len; i++) {
    validateConstraint(args[i], constraints[i]);
  }
}
function validateConstraint(arg, constraint) {
  if (isString(constraint)) {
    if (typeof arg !== constraint) {
      throw new Error(`argument does not match constraint: typeof ${constraint}`);
    }
  } else if (isFunction(constraint)) {
    try {
      if (arg instanceof constraint) {
        return;
      }
    } catch (_a) {
    }
    if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
      return;
    }
    if (constraint.length === 1 && constraint.call(void 0, arg) === true) {
      return;
    }
    throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);
  }
}
function getAllPropertyNames(obj) {
  let res = [];
  let proto = Object.getPrototypeOf(obj);
  while (Object.prototype !== proto) {
    res = res.concat(Object.getOwnPropertyNames(proto));
    proto = Object.getPrototypeOf(proto);
  }
  return res;
}
function getAllMethodNames(obj) {
  const methods = [];
  for (const prop of getAllPropertyNames(obj)) {
    if (typeof obj[prop] === "function") {
      methods.push(prop);
    }
  }
  return methods;
}
function createProxyObject(methodNames, invoke) {
  const createProxyMethod = (method) => {
    return function() {
      const args = Array.prototype.slice.call(arguments, 0);
      return invoke(method, args);
    };
  };
  let result = {};
  for (const methodName of methodNames) {
    result[methodName] = createProxyMethod(methodName);
  }
  return result;
}
function withNullAsUndefined(x) {
  return x === null ? void 0 : x;
}

// ../../node_modules/monaco-editor/esm/vs/platform/commands/common/commands.js
var ICommandService = createDecorator("commandService");
var CommandsRegistry = new class {
  constructor() {
    this._commands = new Map();
    this._onDidRegisterCommand = new Emitter();
    this.onDidRegisterCommand = this._onDidRegisterCommand.event;
  }
  registerCommand(idOrCommand, handler) {
    if (!idOrCommand) {
      throw new Error(`invalid command`);
    }
    if (typeof idOrCommand === "string") {
      if (!handler) {
        throw new Error(`invalid command`);
      }
      return this.registerCommand({id: idOrCommand, handler});
    }
    if (idOrCommand.description) {
      const constraints = [];
      for (let arg of idOrCommand.description.args) {
        constraints.push(arg.constraint);
      }
      const actualHandler = idOrCommand.handler;
      idOrCommand.handler = function(accessor, ...args) {
        validateConstraints(args, constraints);
        return actualHandler(accessor, ...args);
      };
    }
    const {id} = idOrCommand;
    let commands = this._commands.get(id);
    if (!commands) {
      commands = new LinkedList();
      this._commands.set(id, commands);
    }
    let removeFn = commands.unshift(idOrCommand);
    let ret = toDisposable(() => {
      removeFn();
      const command = this._commands.get(id);
      if (command === null || command === void 0 ? void 0 : command.isEmpty()) {
        this._commands.delete(id);
      }
    });
    this._onDidRegisterCommand.fire(id);
    return ret;
  }
  registerCommandAlias(oldId, newId) {
    return CommandsRegistry.registerCommand(oldId, (accessor, ...args) => accessor.get(ICommandService).executeCommand(newId, ...args));
  }
  getCommand(id) {
    const list = this._commands.get(id);
    if (!list || list.isEmpty()) {
      return void 0;
    }
    return Iterable.first(list);
  }
  getCommands() {
    const result = new Map();
    for (const key of this._commands.keys()) {
      const command = this.getCommand(key);
      if (command) {
        result.set(key, command);
      }
    }
    return result;
  }
}();

// ../../node_modules/monaco-editor/esm/vs/platform/opener/common/opener.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var IOpenerService = createDecorator("openerService");
var NullOpenerService = Object.freeze({
  _serviceBrand: void 0,
  registerOpener() {
    return Disposable.None;
  },
  registerValidator() {
    return Disposable.None;
  },
  registerExternalUriResolver() {
    return Disposable.None;
  },
  setExternalOpener() {
  },
  open() {
    return __awaiter(this, void 0, void 0, function* () {
      return false;
    });
  },
  resolveExternalUri(uri) {
    return __awaiter(this, void 0, void 0, function* () {
      return {resolved: uri, dispose() {
      }};
    });
  }
});
function matchesScheme(target, scheme) {
  if (URI.isUri(target)) {
    return equalsIgnoreCase(target.scheme, scheme);
  } else {
    return startsWithIgnoreCase(target, scheme + ":");
  }
}

// ../../node_modules/monaco-editor/esm/vs/platform/editor/common/editor.js
var EditorOpenContext;
(function(EditorOpenContext2) {
  EditorOpenContext2[EditorOpenContext2["API"] = 0] = "API";
  EditorOpenContext2[EditorOpenContext2["USER"] = 1] = "USER";
})(EditorOpenContext || (EditorOpenContext = {}));

// ../../node_modules/monaco-editor/esm/vs/editor/browser/services/openerService.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CommandOpener = class CommandOpener2 {
  constructor(_commandService) {
    this._commandService = _commandService;
  }
  open(target) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (!matchesScheme(target, Schemas.command)) {
        return false;
      }
      if (typeof target === "string") {
        target = URI.parse(target);
      }
      let args = [];
      try {
        args = parse(decodeURIComponent(target.query));
      } catch (_a) {
        try {
          args = parse(target.query);
        } catch (_b) {
        }
      }
      if (!Array.isArray(args)) {
        args = [args];
      }
      yield this._commandService.executeCommand(target.path, ...args);
      return true;
    });
  }
};
CommandOpener = __decorate([
  __param(0, ICommandService)
], CommandOpener);
var EditorOpener = class EditorOpener2 {
  constructor(_editorService) {
    this._editorService = _editorService;
  }
  open(target, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (typeof target === "string") {
        target = URI.parse(target);
      }
      let selection = void 0;
      const match2 = /^L?(\d+)(?:,(\d+))?/.exec(target.fragment);
      if (match2) {
        selection = {
          startLineNumber: parseInt(match2[1]),
          startColumn: match2[2] ? parseInt(match2[2]) : 1
        };
        target = target.with({fragment: ""});
      }
      if (target.scheme === Schemas.file) {
        target = normalizePath(target);
      }
      yield this._editorService.openCodeEditor({resource: target, options: {selection, context: (options === null || options === void 0 ? void 0 : options.fromUserGesture) ? EditorOpenContext.USER : EditorOpenContext.API}}, this._editorService.getFocusedCodeEditor(), options === null || options === void 0 ? void 0 : options.openToSide);
      return true;
    });
  }
};
EditorOpener = __decorate([
  __param(0, ICodeEditorService)
], EditorOpener);
var OpenerService = class OpenerService2 {
  constructor(editorService, commandService) {
    this._openers = new LinkedList();
    this._validators = new LinkedList();
    this._resolvers = new LinkedList();
    this._externalOpener = {
      openExternal: (href) => {
        if (matchesScheme(href, Schemas.http) || matchesScheme(href, Schemas.https)) {
          windowOpenNoOpener(href);
        } else {
          window.location.href = href;
        }
        return Promise.resolve(true);
      }
    };
    this._openers.push({
      open: (target, options) => __awaiter2(this, void 0, void 0, function* () {
        if ((options === null || options === void 0 ? void 0 : options.openExternal) || matchesScheme(target, Schemas.mailto) || matchesScheme(target, Schemas.http) || matchesScheme(target, Schemas.https)) {
          yield this._doOpenExternal(target, options);
          return true;
        }
        return false;
      })
    });
    this._openers.push(new CommandOpener(commandService));
    this._openers.push(new EditorOpener(editorService));
  }
  open(target, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      for (const validator of this._validators.toArray()) {
        if (!(yield validator.shouldOpen(target))) {
          return false;
        }
      }
      for (const opener of this._openers.toArray()) {
        const handled = yield opener.open(target, options);
        if (handled) {
          return true;
        }
      }
      return false;
    });
  }
  resolveExternalUri(resource, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      for (const resolver of this._resolvers.toArray()) {
        const result = yield resolver.resolveExternalUri(resource, options);
        if (result) {
          return result;
        }
      }
      return {resolved: resource, dispose: () => {
      }};
    });
  }
  _doOpenExternal(resource, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      const uri = typeof resource === "string" ? URI.parse(resource) : resource;
      const {resolved} = yield this.resolveExternalUri(uri, options);
      if (typeof resource === "string" && uri.toString() === resolved.toString()) {
        return this._externalOpener.openExternal(resource);
      } else {
        return this._externalOpener.openExternal(encodeURI(resolved.toString(true)));
      }
    });
  }
  dispose() {
    this._validators.clear();
  }
};
OpenerService = __decorate([
  __param(0, ICodeEditorService),
  __param(1, ICommandService)
], OpenerService);

// ../../node_modules/monaco-editor/esm/vs/base/common/assert.js
function ok(value, message) {
  if (!value) {
    throw new Error(message ? `Assertion failed (${message})` : "Assertion Failed");
  }
}

// ../../node_modules/monaco-editor/esm/vs/base/common/objects.js
function deepClone(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof RegExp) {
    return obj;
  }
  const result = Array.isArray(obj) ? [] : {};
  Object.keys(obj).forEach((key) => {
    if (obj[key] && typeof obj[key] === "object") {
      result[key] = deepClone(obj[key]);
    } else {
      result[key] = obj[key];
    }
  });
  return result;
}
function deepFreeze(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  const stack = [obj];
  while (stack.length > 0) {
    const obj2 = stack.shift();
    Object.freeze(obj2);
    for (const key in obj2) {
      if (_hasOwnProperty.call(obj2, key)) {
        const prop = obj2[key];
        if (typeof prop === "object" && !Object.isFrozen(prop)) {
          stack.push(prop);
        }
      }
    }
  }
  return obj;
}
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function mixin(destination, source, overwrite = true) {
  if (!isObject(destination)) {
    return source;
  }
  if (isObject(source)) {
    Object.keys(source).forEach((key) => {
      if (key in destination) {
        if (overwrite) {
          if (isObject(destination[key]) && isObject(source[key])) {
            mixin(destination[key], source[key], overwrite);
          } else {
            destination[key] = source[key];
          }
        }
      } else {
        destination[key] = source[key];
      }
    });
  }
  return destination;
}
function assign(destination, ...sources) {
  sources.forEach((source) => Object.keys(source).forEach((key) => destination[key] = source[key]));
  return destination;
}
function equals2(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  let i;
  let key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals2(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals2(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals2(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}
function getOrDefault(obj, fn, defaultValue) {
  const result = fn(obj);
  return typeof result === "undefined" ? defaultValue : result;
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/widget/diffNavigator.js
var defaultOptions = {
  followsCaret: true,
  ignoreCharChanges: true,
  alwaysRevealFirst: true
};
var DiffNavigator = class extends Disposable {
  constructor(editor2, options = {}) {
    super();
    this._onDidUpdate = this._register(new Emitter());
    this._editor = editor2;
    this._options = mixin(options, defaultOptions, false);
    this.disposed = false;
    this.nextIdx = -1;
    this.ranges = [];
    this.ignoreSelectionChange = false;
    this.revealFirst = Boolean(this._options.alwaysRevealFirst);
    this._register(this._editor.onDidDispose(() => this.dispose()));
    this._register(this._editor.onDidUpdateDiff(() => this._onDiffUpdated()));
    if (this._options.followsCaret) {
      this._register(this._editor.getModifiedEditor().onDidChangeCursorPosition((e) => {
        if (this.ignoreSelectionChange) {
          return;
        }
        this.nextIdx = -1;
      }));
    }
    if (this._options.alwaysRevealFirst) {
      this._register(this._editor.getModifiedEditor().onDidChangeModel((e) => {
        this.revealFirst = true;
      }));
    }
    this._init();
  }
  _init() {
    let changes = this._editor.getLineChanges();
    if (!changes) {
      return;
    }
  }
  _onDiffUpdated() {
    this._init();
    this._compute(this._editor.getLineChanges());
    if (this.revealFirst) {
      if (this._editor.getLineChanges() !== null) {
        this.revealFirst = false;
        this.nextIdx = -1;
        this.next(1);
      }
    }
  }
  _compute(lineChanges) {
    this.ranges = [];
    if (lineChanges) {
      lineChanges.forEach((lineChange) => {
        if (!this._options.ignoreCharChanges && lineChange.charChanges) {
          lineChange.charChanges.forEach((charChange) => {
            this.ranges.push({
              rhs: true,
              range: new Range(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn)
            });
          });
        } else {
          this.ranges.push({
            rhs: true,
            range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedStartLineNumber, 1)
          });
        }
      });
    }
    this.ranges.sort((left, right) => {
      if (left.range.getStartPosition().isBeforeOrEqual(right.range.getStartPosition())) {
        return -1;
      } else if (right.range.getStartPosition().isBeforeOrEqual(left.range.getStartPosition())) {
        return 1;
      } else {
        return 0;
      }
    });
    this._onDidUpdate.fire(this);
  }
  _initIdx(fwd) {
    let found = false;
    let position = this._editor.getPosition();
    if (!position) {
      this.nextIdx = 0;
      return;
    }
    for (let i = 0, len = this.ranges.length; i < len && !found; i++) {
      let range2 = this.ranges[i].range;
      if (position.isBeforeOrEqual(range2.getStartPosition())) {
        this.nextIdx = i + (fwd ? 0 : -1);
        found = true;
      }
    }
    if (!found) {
      this.nextIdx = fwd ? 0 : this.ranges.length - 1;
    }
    if (this.nextIdx < 0) {
      this.nextIdx = this.ranges.length - 1;
    }
  }
  _move(fwd, scrollType) {
    ok(!this.disposed, "Illegal State - diff navigator has been disposed");
    if (!this.canNavigate()) {
      return;
    }
    if (this.nextIdx === -1) {
      this._initIdx(fwd);
    } else if (fwd) {
      this.nextIdx += 1;
      if (this.nextIdx >= this.ranges.length) {
        this.nextIdx = 0;
      }
    } else {
      this.nextIdx -= 1;
      if (this.nextIdx < 0) {
        this.nextIdx = this.ranges.length - 1;
      }
    }
    let info = this.ranges[this.nextIdx];
    this.ignoreSelectionChange = true;
    try {
      let pos = info.range.getStartPosition();
      this._editor.setPosition(pos);
      this._editor.revealPositionInCenter(pos, scrollType);
    } finally {
      this.ignoreSelectionChange = false;
    }
  }
  canNavigate() {
    return this.ranges && this.ranges.length > 0;
  }
  next(scrollType = 0) {
    this._move(true, scrollType);
  }
  previous(scrollType = 0) {
    this._move(false, scrollType);
  }
  dispose() {
    super.dispose();
    this.ranges = [];
    this.disposed = true;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/config/editorZoom.js
var EditorZoom = new class {
  constructor() {
    this._zoomLevel = 0;
    this._onDidChangeZoomLevel = new Emitter();
    this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
  }
  getZoomLevel() {
    return this._zoomLevel;
  }
  setZoomLevel(zoomLevel) {
    zoomLevel = Math.min(Math.max(-5, zoomLevel), 20);
    if (this._zoomLevel === zoomLevel) {
      return;
    }
    this._zoomLevel = zoomLevel;
    this._onDidChangeZoomLevel.fire(this._zoomLevel);
  }
}();

// ../../node_modules/monaco-editor/esm/vs/editor/common/config/fontInfo.js
var GOLDEN_LINE_HEIGHT_RATIO = isMacintosh ? 1.5 : 1.35;
var MINIMUM_LINE_HEIGHT = 8;
var BareFontInfo = class {
  constructor(opts) {
    this.zoomLevel = opts.zoomLevel;
    this.fontFamily = String(opts.fontFamily);
    this.fontWeight = String(opts.fontWeight);
    this.fontSize = opts.fontSize;
    this.fontFeatureSettings = opts.fontFeatureSettings;
    this.lineHeight = opts.lineHeight | 0;
    this.letterSpacing = opts.letterSpacing;
  }
  static createFromValidatedSettings(options, zoomLevel, ignoreEditorZoom) {
    const fontFamily = options.get(35);
    const fontWeight = options.get(39);
    const fontSize = options.get(38);
    const fontFeatureSettings = options.get(37);
    const lineHeight = options.get(51);
    const letterSpacing = options.get(48);
    return BareFontInfo._create(fontFamily, fontWeight, fontSize, fontFeatureSettings, lineHeight, letterSpacing, zoomLevel, ignoreEditorZoom);
  }
  static _create(fontFamily, fontWeight, fontSize, fontFeatureSettings, lineHeight, letterSpacing, zoomLevel, ignoreEditorZoom) {
    if (lineHeight === 0) {
      lineHeight = Math.round(GOLDEN_LINE_HEIGHT_RATIO * fontSize);
    } else if (lineHeight < MINIMUM_LINE_HEIGHT) {
      lineHeight = MINIMUM_LINE_HEIGHT;
    }
    const editorZoomLevelMultiplier = 1 + (ignoreEditorZoom ? 0 : EditorZoom.getZoomLevel() * 0.1);
    fontSize *= editorZoomLevelMultiplier;
    lineHeight *= editorZoomLevelMultiplier;
    return new BareFontInfo({
      zoomLevel,
      fontFamily,
      fontWeight,
      fontSize,
      fontFeatureSettings,
      lineHeight,
      letterSpacing
    });
  }
  getId() {
    return this.zoomLevel + "-" + this.fontFamily + "-" + this.fontWeight + "-" + this.fontSize + "-" + this.fontFeatureSettings + "-" + this.lineHeight + "-" + this.letterSpacing;
  }
  getMassagedFontFamily() {
    if (/[,"']/.test(this.fontFamily)) {
      return this.fontFamily;
    }
    if (/[+ ]/.test(this.fontFamily)) {
      return `"${this.fontFamily}"`;
    }
    return this.fontFamily;
  }
};
var FontInfo = class extends BareFontInfo {
  constructor(opts, isTrusted) {
    super(opts);
    this.isTrusted = isTrusted;
    this.isMonospace = opts.isMonospace;
    this.typicalHalfwidthCharacterWidth = opts.typicalHalfwidthCharacterWidth;
    this.typicalFullwidthCharacterWidth = opts.typicalFullwidthCharacterWidth;
    this.canUseHalfwidthRightwardsArrow = opts.canUseHalfwidthRightwardsArrow;
    this.spaceWidth = opts.spaceWidth;
    this.middotWidth = opts.middotWidth;
    this.wsmiddotWidth = opts.wsmiddotWidth;
    this.maxDigitWidth = opts.maxDigitWidth;
  }
  equals(other) {
    return this.fontFamily === other.fontFamily && this.fontWeight === other.fontWeight && this.fontSize === other.fontSize && this.fontFeatureSettings === other.fontFeatureSettings && this.lineHeight === other.lineHeight && this.letterSpacing === other.letterSpacing && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth && this.typicalFullwidthCharacterWidth === other.typicalFullwidthCharacterWidth && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.spaceWidth === other.spaceWidth && this.middotWidth === other.middotWidth && this.wsmiddotWidth === other.wsmiddotWidth && this.maxDigitWidth === other.maxDigitWidth;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js
function isThemeColor(o) {
  return o && typeof o.id === "string";
}
var EditorType = {
  ICodeEditor: "vs.editor.ICodeEditor",
  IDiffEditor: "vs.editor.IDiffEditor"
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/model.js
var OverviewRulerLane2;
(function(OverviewRulerLane3) {
  OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
  OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
  OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
  OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
})(OverviewRulerLane2 || (OverviewRulerLane2 = {}));
var MinimapPosition2;
(function(MinimapPosition3) {
  MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
  MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
})(MinimapPosition2 || (MinimapPosition2 = {}));
var TextModelResolvedOptions = class {
  constructor(src) {
    this.tabSize = Math.max(1, src.tabSize | 0);
    this.indentSize = src.tabSize | 0;
    this.insertSpaces = Boolean(src.insertSpaces);
    this.defaultEOL = src.defaultEOL | 0;
    this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);
  }
  equals(other) {
    return this.tabSize === other.tabSize && this.indentSize === other.indentSize && this.insertSpaces === other.insertSpaces && this.defaultEOL === other.defaultEOL && this.trimAutoWhitespace === other.trimAutoWhitespace;
  }
  createChangeEvent(newOpts) {
    return {
      tabSize: this.tabSize !== newOpts.tabSize,
      indentSize: this.indentSize !== newOpts.indentSize,
      insertSpaces: this.insertSpaces !== newOpts.insertSpaces,
      trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace
    };
  }
};
var FindMatch = class {
  constructor(range2, matches) {
    this.range = range2;
    this.matches = matches;
  }
};
var ValidAnnotatedEditOperation = class {
  constructor(identifier, range2, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {
    this.identifier = identifier;
    this.range = range2;
    this.text = text;
    this.forceMoveMarkers = forceMoveMarkers;
    this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;
    this._isTracked = _isTracked;
  }
};
var ApplyEditsResult = class {
  constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {
    this.reverseEdits = reverseEdits;
    this.changes = changes;
    this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/map.js
var ResourceMap = class {
  constructor(mapOrKeyFn, toKey) {
    this[Symbol.toStringTag] = "ResourceMap";
    if (mapOrKeyFn instanceof ResourceMap) {
      this.map = new Map(mapOrKeyFn.map);
      this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;
    } else {
      this.map = new Map();
      this.toKey = mapOrKeyFn !== null && mapOrKeyFn !== void 0 ? mapOrKeyFn : ResourceMap.defaultToKey;
    }
  }
  set(resource, value) {
    this.map.set(this.toKey(resource), value);
    return this;
  }
  get(resource) {
    return this.map.get(this.toKey(resource));
  }
  has(resource) {
    return this.map.has(this.toKey(resource));
  }
  get size() {
    return this.map.size;
  }
  clear() {
    this.map.clear();
  }
  delete(resource) {
    return this.map.delete(this.toKey(resource));
  }
  forEach(clb, thisArg) {
    if (typeof thisArg !== "undefined") {
      clb = clb.bind(thisArg);
    }
    for (let [index, value] of this.map) {
      clb(value, URI.parse(index), this);
    }
  }
  values() {
    return this.map.values();
  }
  *keys() {
    for (let key of this.map.keys()) {
      yield URI.parse(key);
    }
  }
  *entries() {
    for (let tuple of this.map.entries()) {
      yield [URI.parse(tuple[0]), tuple[1]];
    }
  }
  *[Symbol.iterator]() {
    for (let item of this.map) {
      yield [URI.parse(item[0]), item[1]];
    }
  }
};
ResourceMap.defaultToKey = (resource) => resource.toString();
var LinkedMap = class {
  constructor() {
    this[Symbol.toStringTag] = "LinkedMap";
    this._map = new Map();
    this._head = void 0;
    this._tail = void 0;
    this._size = 0;
    this._state = 0;
  }
  clear() {
    this._map.clear();
    this._head = void 0;
    this._tail = void 0;
    this._size = 0;
    this._state++;
  }
  isEmpty() {
    return !this._head && !this._tail;
  }
  get size() {
    return this._size;
  }
  get first() {
    var _a;
    return (_a = this._head) === null || _a === void 0 ? void 0 : _a.value;
  }
  get last() {
    var _a;
    return (_a = this._tail) === null || _a === void 0 ? void 0 : _a.value;
  }
  has(key) {
    return this._map.has(key);
  }
  get(key, touch = 0) {
    const item = this._map.get(key);
    if (!item) {
      return void 0;
    }
    if (touch !== 0) {
      this.touch(item, touch);
    }
    return item.value;
  }
  set(key, value, touch = 0) {
    let item = this._map.get(key);
    if (item) {
      item.value = value;
      if (touch !== 0) {
        this.touch(item, touch);
      }
    } else {
      item = {key, value, next: void 0, previous: void 0};
      switch (touch) {
        case 0:
          this.addItemLast(item);
          break;
        case 1:
          this.addItemFirst(item);
          break;
        case 2:
          this.addItemLast(item);
          break;
        default:
          this.addItemLast(item);
          break;
      }
      this._map.set(key, item);
      this._size++;
    }
    return this;
  }
  delete(key) {
    return !!this.remove(key);
  }
  remove(key) {
    const item = this._map.get(key);
    if (!item) {
      return void 0;
    }
    this._map.delete(key);
    this.removeItem(item);
    this._size--;
    return item.value;
  }
  shift() {
    if (!this._head && !this._tail) {
      return void 0;
    }
    if (!this._head || !this._tail) {
      throw new Error("Invalid list");
    }
    const item = this._head;
    this._map.delete(item.key);
    this.removeItem(item);
    this._size--;
    return item.value;
  }
  forEach(callbackfn, thisArg) {
    const state = this._state;
    let current = this._head;
    while (current) {
      if (thisArg) {
        callbackfn.bind(thisArg)(current.value, current.key, this);
      } else {
        callbackfn(current.value, current.key, this);
      }
      if (this._state !== state) {
        throw new Error(`LinkedMap got modified during iteration.`);
      }
      current = current.next;
    }
  }
  keys() {
    const map = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },
      next() {
        if (map._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        if (current) {
          const result = {value: current.key, done: false};
          current = current.next;
          return result;
        } else {
          return {value: void 0, done: true};
        }
      }
    };
    return iterator;
  }
  values() {
    const map = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },
      next() {
        if (map._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        if (current) {
          const result = {value: current.value, done: false};
          current = current.next;
          return result;
        } else {
          return {value: void 0, done: true};
        }
      }
    };
    return iterator;
  }
  entries() {
    const map = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },
      next() {
        if (map._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        if (current) {
          const result = {value: [current.key, current.value], done: false};
          current = current.next;
          return result;
        } else {
          return {value: void 0, done: true};
        }
      }
    };
    return iterator;
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  trimOld(newSize) {
    if (newSize >= this.size) {
      return;
    }
    if (newSize === 0) {
      this.clear();
      return;
    }
    let current = this._head;
    let currentSize = this.size;
    while (current && currentSize > newSize) {
      this._map.delete(current.key);
      current = current.next;
      currentSize--;
    }
    this._head = current;
    this._size = currentSize;
    if (current) {
      current.previous = void 0;
    }
    this._state++;
  }
  addItemFirst(item) {
    if (!this._head && !this._tail) {
      this._tail = item;
    } else if (!this._head) {
      throw new Error("Invalid list");
    } else {
      item.next = this._head;
      this._head.previous = item;
    }
    this._head = item;
    this._state++;
  }
  addItemLast(item) {
    if (!this._head && !this._tail) {
      this._head = item;
    } else if (!this._tail) {
      throw new Error("Invalid list");
    } else {
      item.previous = this._tail;
      this._tail.next = item;
    }
    this._tail = item;
    this._state++;
  }
  removeItem(item) {
    if (item === this._head && item === this._tail) {
      this._head = void 0;
      this._tail = void 0;
    } else if (item === this._head) {
      if (!item.next) {
        throw new Error("Invalid list");
      }
      item.next.previous = void 0;
      this._head = item.next;
    } else if (item === this._tail) {
      if (!item.previous) {
        throw new Error("Invalid list");
      }
      item.previous.next = void 0;
      this._tail = item.previous;
    } else {
      const next = item.next;
      const previous = item.previous;
      if (!next || !previous) {
        throw new Error("Invalid list");
      }
      next.previous = previous;
      previous.next = next;
    }
    item.next = void 0;
    item.previous = void 0;
    this._state++;
  }
  touch(item, touch) {
    if (!this._head || !this._tail) {
      throw new Error("Invalid list");
    }
    if (touch !== 1 && touch !== 2) {
      return;
    }
    if (touch === 1) {
      if (item === this._head) {
        return;
      }
      const next = item.next;
      const previous = item.previous;
      if (item === this._tail) {
        previous.next = void 0;
        this._tail = previous;
      } else {
        next.previous = previous;
        previous.next = next;
      }
      item.previous = void 0;
      item.next = this._head;
      this._head.previous = item;
      this._head = item;
      this._state++;
    } else if (touch === 2) {
      if (item === this._tail) {
        return;
      }
      const next = item.next;
      const previous = item.previous;
      if (item === this._head) {
        next.previous = void 0;
        this._head = next;
      } else {
        next.previous = previous;
        previous.next = next;
      }
      item.next = void 0;
      item.previous = this._tail;
      this._tail.next = item;
      this._tail = item;
      this._state++;
    }
  }
  toJSON() {
    const data = [];
    this.forEach((value, key) => {
      data.push([key, value]);
    });
    return data;
  }
  fromJSON(data) {
    this.clear();
    for (const [key, value] of data) {
      this.set(key, value);
    }
  }
};
var LRUCache = class extends LinkedMap {
  constructor(limit, ratio = 1) {
    super();
    this._limit = limit;
    this._ratio = Math.min(Math.max(0, ratio), 1);
  }
  get limit() {
    return this._limit;
  }
  set limit(limit) {
    this._limit = limit;
    this.checkTrim();
  }
  get(key, touch = 2) {
    return super.get(key, touch);
  }
  peek(key) {
    return super.get(key, 0);
  }
  set(key, value) {
    super.set(key, value, 2);
    this.checkTrim();
    return this;
  }
  checkTrim() {
    if (this.size > this._limit) {
      this.trimOld(Math.round(this._limit * this._ratio));
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/glob.js
var GLOBSTAR = "**";
var GLOB_SPLIT = "/";
var PATH_REGEX = "[/\\\\]";
var NO_PATH_REGEX = "[^/\\\\]";
var ALL_FORWARD_SLASHES = /\//g;
function starsToRegExp(starCount) {
  switch (starCount) {
    case 0:
      return "";
    case 1:
      return `${NO_PATH_REGEX}*?`;
    default:
      return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;
  }
}
function splitGlobAware(pattern, splitChar) {
  if (!pattern) {
    return [];
  }
  const segments = [];
  let inBraces = false;
  let inBrackets = false;
  let curVal = "";
  for (const char of pattern) {
    switch (char) {
      case splitChar:
        if (!inBraces && !inBrackets) {
          segments.push(curVal);
          curVal = "";
          continue;
        }
        break;
      case "{":
        inBraces = true;
        break;
      case "}":
        inBraces = false;
        break;
      case "[":
        inBrackets = true;
        break;
      case "]":
        inBrackets = false;
        break;
    }
    curVal += char;
  }
  if (curVal) {
    segments.push(curVal);
  }
  return segments;
}
function parseRegExp(pattern) {
  if (!pattern) {
    return "";
  }
  let regEx = "";
  const segments = splitGlobAware(pattern, GLOB_SPLIT);
  if (segments.every((s) => s === GLOBSTAR)) {
    regEx = ".*";
  } else {
    let previousSegmentWasGlobStar = false;
    segments.forEach((segment, index) => {
      if (segment === GLOBSTAR) {
        if (!previousSegmentWasGlobStar) {
          regEx += starsToRegExp(2);
          previousSegmentWasGlobStar = true;
        }
        return;
      }
      let inBraces = false;
      let braceVal = "";
      let inBrackets = false;
      let bracketVal = "";
      for (const char of segment) {
        if (char !== "}" && inBraces) {
          braceVal += char;
          continue;
        }
        if (inBrackets && (char !== "]" || !bracketVal)) {
          let res;
          if (char === "-") {
            res = char;
          } else if ((char === "^" || char === "!") && !bracketVal) {
            res = "^";
          } else if (char === GLOB_SPLIT) {
            res = "";
          } else {
            res = escapeRegExpCharacters(char);
          }
          bracketVal += res;
          continue;
        }
        switch (char) {
          case "{":
            inBraces = true;
            continue;
          case "[":
            inBrackets = true;
            continue;
          case "}":
            const choices = splitGlobAware(braceVal, ",");
            const braceRegExp = `(?:${choices.map((c) => parseRegExp(c)).join("|")})`;
            regEx += braceRegExp;
            inBraces = false;
            braceVal = "";
            break;
          case "]":
            regEx += "[" + bracketVal + "]";
            inBrackets = false;
            bracketVal = "";
            break;
          case "?":
            regEx += NO_PATH_REGEX;
            continue;
          case "*":
            regEx += starsToRegExp(1);
            continue;
          default:
            regEx += escapeRegExpCharacters(char);
        }
      }
      if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {
        regEx += PATH_REGEX;
      }
      previousSegmentWasGlobStar = false;
    });
  }
  return regEx;
}
var T1 = /^\*\*\/\*\.[\w\.-]+$/;
var T2 = /^\*\*\/([\w\.-]+)\/?$/;
var T3 = /^{\*\*\/[\*\.]?[\w\.-]+\/?(,\*\*\/[\*\.]?[\w\.-]+\/?)*}$/;
var T3_2 = /^{\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?(,\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?)*}$/;
var T4 = /^\*\*((\/[\w\.-]+)+)\/?$/;
var T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/;
var CACHE = new LRUCache(1e4);
var FALSE = function() {
  return false;
};
var NULL = function() {
  return null;
};
function parsePattern(arg1, options) {
  if (!arg1) {
    return NULL;
  }
  let pattern;
  if (typeof arg1 !== "string") {
    pattern = arg1.pattern;
  } else {
    pattern = arg1;
  }
  pattern = pattern.trim();
  const patternKey = `${pattern}_${!!options.trimForExclusions}`;
  let parsedPattern = CACHE.get(patternKey);
  if (parsedPattern) {
    return wrapRelativePattern(parsedPattern, arg1);
  }
  let match2;
  if (T1.test(pattern)) {
    const base = pattern.substr(4);
    parsedPattern = function(path, basename3) {
      return typeof path === "string" && path.endsWith(base) ? pattern : null;
    };
  } else if (match2 = T2.exec(trimForExclusions(pattern, options))) {
    parsedPattern = trivia2(match2[1], pattern);
  } else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {
    parsedPattern = trivia3(pattern, options);
  } else if (match2 = T4.exec(trimForExclusions(pattern, options))) {
    parsedPattern = trivia4and5(match2[1].substr(1), pattern, true);
  } else if (match2 = T5.exec(trimForExclusions(pattern, options))) {
    parsedPattern = trivia4and5(match2[1], pattern, false);
  } else {
    parsedPattern = toRegExp(pattern);
  }
  CACHE.set(patternKey, parsedPattern);
  return wrapRelativePattern(parsedPattern, arg1);
}
function wrapRelativePattern(parsedPattern, arg2) {
  if (typeof arg2 === "string") {
    return parsedPattern;
  }
  return function(path, basename3) {
    if (!isEqualOrParent(path, arg2.base)) {
      return null;
    }
    return parsedPattern(relative(arg2.base, path), basename3);
  };
}
function trimForExclusions(pattern, options) {
  return options.trimForExclusions && pattern.endsWith("/**") ? pattern.substr(0, pattern.length - 2) : pattern;
}
function trivia2(base, originalPattern) {
  const slashBase = `/${base}`;
  const backslashBase = `\\${base}`;
  const parsedPattern = function(path, basename3) {
    if (typeof path !== "string") {
      return null;
    }
    if (basename3) {
      return basename3 === base ? originalPattern : null;
    }
    return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;
  };
  const basenames = [base];
  parsedPattern.basenames = basenames;
  parsedPattern.patterns = [originalPattern];
  parsedPattern.allBasenames = basenames;
  return parsedPattern;
}
function trivia3(pattern, options) {
  const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(",").map((pattern2) => parsePattern(pattern2, options)).filter((pattern2) => pattern2 !== NULL), pattern);
  const n = parsedPatterns.length;
  if (!n) {
    return NULL;
  }
  if (n === 1) {
    return parsedPatterns[0];
  }
  const parsedPattern = function(path, basename3) {
    for (let i = 0, n2 = parsedPatterns.length; i < n2; i++) {
      if (parsedPatterns[i](path, basename3)) {
        return pattern;
      }
    }
    return null;
  };
  const withBasenames = first(parsedPatterns, (pattern2) => !!pattern2.allBasenames);
  if (withBasenames) {
    parsedPattern.allBasenames = withBasenames.allBasenames;
  }
  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
  if (allPaths.length) {
    parsedPattern.allPaths = allPaths;
  }
  return parsedPattern;
}
function trivia4and5(path, pattern, matchPathEnds) {
  const nativePath = sep !== posix.sep ? path.replace(ALL_FORWARD_SLASHES, sep) : path;
  const nativePathEnd = sep + nativePath;
  const parsedPattern = matchPathEnds ? function(path2, basename3) {
    return typeof path2 === "string" && (path2 === nativePath || path2.endsWith(nativePathEnd)) ? pattern : null;
  } : function(path2, basename3) {
    return typeof path2 === "string" && path2 === nativePath ? pattern : null;
  };
  parsedPattern.allPaths = [(matchPathEnds ? "*/" : "./") + path];
  return parsedPattern;
}
function toRegExp(pattern) {
  try {
    const regExp = new RegExp(`^${parseRegExp(pattern)}$`);
    return function(path) {
      regExp.lastIndex = 0;
      return typeof path === "string" && regExp.test(path) ? pattern : null;
    };
  } catch (error) {
    return NULL;
  }
}
function match(arg1, path, hasSibling) {
  if (!arg1 || typeof path !== "string") {
    return false;
  }
  return parse2(arg1)(path, void 0, hasSibling);
}
function parse2(arg1, options = {}) {
  if (!arg1) {
    return FALSE;
  }
  if (typeof arg1 === "string" || isRelativePattern(arg1)) {
    const parsedPattern = parsePattern(arg1, options);
    if (parsedPattern === NULL) {
      return FALSE;
    }
    const resultPattern = function(path, basename3) {
      return !!parsedPattern(path, basename3);
    };
    if (parsedPattern.allBasenames) {
      resultPattern.allBasenames = parsedPattern.allBasenames;
    }
    if (parsedPattern.allPaths) {
      resultPattern.allPaths = parsedPattern.allPaths;
    }
    return resultPattern;
  }
  return parsedExpression(arg1, options);
}
function isRelativePattern(obj) {
  const rp = obj;
  return rp && typeof rp.base === "string" && typeof rp.pattern === "string";
}
function parsedExpression(expression, options) {
  const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map((pattern) => parseExpressionPattern(pattern, expression[pattern], options)).filter((pattern) => pattern !== NULL));
  const n = parsedPatterns.length;
  if (!n) {
    return NULL;
  }
  if (!parsedPatterns.some((parsedPattern) => !!parsedPattern.requiresSiblings)) {
    if (n === 1) {
      return parsedPatterns[0];
    }
    const resultExpression2 = function(path, basename3) {
      for (let i = 0, n2 = parsedPatterns.length; i < n2; i++) {
        const result = parsedPatterns[i](path, basename3);
        if (result) {
          return result;
        }
      }
      return null;
    };
    const withBasenames2 = first(parsedPatterns, (pattern) => !!pattern.allBasenames);
    if (withBasenames2) {
      resultExpression2.allBasenames = withBasenames2.allBasenames;
    }
    const allPaths2 = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
    if (allPaths2.length) {
      resultExpression2.allPaths = allPaths2;
    }
    return resultExpression2;
  }
  const resultExpression = function(path, basename3, hasSibling) {
    let name = void 0;
    for (let i = 0, n2 = parsedPatterns.length; i < n2; i++) {
      const parsedPattern = parsedPatterns[i];
      if (parsedPattern.requiresSiblings && hasSibling) {
        if (!basename3) {
          basename3 = basename(path);
        }
        if (!name) {
          name = basename3.substr(0, basename3.length - extname(path).length);
        }
      }
      const result = parsedPattern(path, basename3, name, hasSibling);
      if (result) {
        return result;
      }
    }
    return null;
  };
  const withBasenames = first(parsedPatterns, (pattern) => !!pattern.allBasenames);
  if (withBasenames) {
    resultExpression.allBasenames = withBasenames.allBasenames;
  }
  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
  if (allPaths.length) {
    resultExpression.allPaths = allPaths;
  }
  return resultExpression;
}
function parseExpressionPattern(pattern, value, options) {
  if (value === false) {
    return NULL;
  }
  const parsedPattern = parsePattern(pattern, options);
  if (parsedPattern === NULL) {
    return NULL;
  }
  if (typeof value === "boolean") {
    return parsedPattern;
  }
  if (value) {
    const when = value.when;
    if (typeof when === "string") {
      const result = (path, basename3, name, hasSibling) => {
        if (!hasSibling || !parsedPattern(path, basename3)) {
          return null;
        }
        const clausePattern = when.replace("$(basename)", name);
        const matched = hasSibling(clausePattern);
        return isThenable(matched) ? matched.then((m) => m ? pattern : null) : matched ? pattern : null;
      };
      result.requiresSiblings = true;
      return result;
    }
  }
  return parsedPattern;
}
function aggregateBasenameMatches(parsedPatterns, result) {
  const basenamePatterns = parsedPatterns.filter((parsedPattern) => !!parsedPattern.basenames);
  if (basenamePatterns.length < 2) {
    return parsedPatterns;
  }
  const basenames = basenamePatterns.reduce((all, current) => {
    const basenames2 = current.basenames;
    return basenames2 ? all.concat(basenames2) : all;
  }, []);
  let patterns;
  if (result) {
    patterns = [];
    for (let i = 0, n = basenames.length; i < n; i++) {
      patterns.push(result);
    }
  } else {
    patterns = basenamePatterns.reduce((all, current) => {
      const patterns2 = current.patterns;
      return patterns2 ? all.concat(patterns2) : all;
    }, []);
  }
  const aggregate = function(path, basename3) {
    if (typeof path !== "string") {
      return null;
    }
    if (!basename3) {
      let i;
      for (i = path.length; i > 0; i--) {
        const ch = path.charCodeAt(i - 1);
        if (ch === 47 || ch === 92) {
          break;
        }
      }
      basename3 = path.substr(i);
    }
    const index = basenames.indexOf(basename3);
    return index !== -1 ? patterns[index] : null;
  };
  aggregate.basenames = basenames;
  aggregate.patterns = patterns;
  aggregate.allBasenames = basenames;
  const aggregatedPatterns = parsedPatterns.filter((parsedPattern) => !parsedPattern.basenames);
  aggregatedPatterns.push(aggregate);
  return aggregatedPatterns;
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/languageSelector.js
function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized) {
  if (Array.isArray(selector)) {
    let ret = 0;
    for (const filter of selector) {
      const value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized);
      if (value === 10) {
        return value;
      }
      if (value > ret) {
        ret = value;
      }
    }
    return ret;
  } else if (typeof selector === "string") {
    if (!candidateIsSynchronized) {
      return 0;
    }
    if (selector === "*") {
      return 5;
    } else if (selector === candidateLanguage) {
      return 10;
    } else {
      return 0;
    }
  } else if (selector) {
    const {language, pattern, scheme, hasAccessToAllModels} = selector;
    if (!candidateIsSynchronized && !hasAccessToAllModels) {
      return 0;
    }
    let ret = 0;
    if (scheme) {
      if (scheme === candidateUri.scheme) {
        ret = 10;
      } else if (scheme === "*") {
        ret = 5;
      } else {
        return 0;
      }
    }
    if (language) {
      if (language === candidateLanguage) {
        ret = 10;
      } else if (language === "*") {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    if (pattern) {
      let normalizedPattern;
      if (typeof pattern === "string") {
        normalizedPattern = pattern;
      } else {
        normalizedPattern = Object.assign(Object.assign({}, pattern), {base: normalize(pattern.base)});
      }
      if (normalizedPattern === candidateUri.fsPath || match(normalizedPattern, candidateUri.fsPath)) {
        ret = 10;
      } else {
        return 0;
      }
    }
    return ret;
  } else {
    return 0;
  }
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js
var IModelService = createDecorator("modelService");
function shouldSynchronizeModel(model2) {
  return !model2.isTooLargeForSyncing() && !model2.isForSimpleWidget;
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/languageFeatureRegistry.js
function isExclusive(selector) {
  if (typeof selector === "string") {
    return false;
  } else if (Array.isArray(selector)) {
    return selector.every(isExclusive);
  } else {
    return !!selector.exclusive;
  }
}
var LanguageFeatureRegistry = class {
  constructor() {
    this._clock = 0;
    this._entries = [];
    this._onDidChange = new Emitter();
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  register(selector, provider) {
    let entry = {
      selector,
      provider,
      _score: -1,
      _time: this._clock++
    };
    this._entries.push(entry);
    this._lastCandidate = void 0;
    this._onDidChange.fire(this._entries.length);
    return toDisposable(() => {
      if (entry) {
        let idx = this._entries.indexOf(entry);
        if (idx >= 0) {
          this._entries.splice(idx, 1);
          this._lastCandidate = void 0;
          this._onDidChange.fire(this._entries.length);
          entry = void 0;
        }
      }
    });
  }
  has(model2) {
    return this.all(model2).length > 0;
  }
  all(model2) {
    if (!model2) {
      return [];
    }
    this._updateScores(model2);
    const result = [];
    for (let entry of this._entries) {
      if (entry._score > 0) {
        result.push(entry.provider);
      }
    }
    return result;
  }
  ordered(model2) {
    const result = [];
    this._orderedForEach(model2, (entry) => result.push(entry.provider));
    return result;
  }
  orderedGroups(model2) {
    const result = [];
    let lastBucket;
    let lastBucketScore;
    this._orderedForEach(model2, (entry) => {
      if (lastBucket && lastBucketScore === entry._score) {
        lastBucket.push(entry.provider);
      } else {
        lastBucketScore = entry._score;
        lastBucket = [entry.provider];
        result.push(lastBucket);
      }
    });
    return result;
  }
  _orderedForEach(model2, callback) {
    if (!model2) {
      return;
    }
    this._updateScores(model2);
    for (const entry of this._entries) {
      if (entry._score > 0) {
        callback(entry);
      }
    }
  }
  _updateScores(model2) {
    let candidate = {
      uri: model2.uri.toString(),
      language: model2.getLanguageIdentifier().language
    };
    if (this._lastCandidate && this._lastCandidate.language === candidate.language && this._lastCandidate.uri === candidate.uri) {
      return;
    }
    this._lastCandidate = candidate;
    for (let entry of this._entries) {
      entry._score = score(entry.selector, model2.uri, model2.getLanguageIdentifier().language, shouldSynchronizeModel(model2));
      if (isExclusive(entry.selector) && entry._score > 0) {
        for (let entry2 of this._entries) {
          entry2._score = 0;
        }
        entry._score = 1e3;
        break;
      }
    }
    this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);
  }
  static _compareByScoreAndTime(a, b) {
    if (a._score < b._score) {
      return 1;
    } else if (a._score > b._score) {
      return -1;
    } else if (a._time < b._time) {
      return 1;
    } else if (a._time > b._time) {
      return -1;
    } else {
      return 0;
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/tokenizationRegistry.js
var TokenizationRegistryImpl = class {
  constructor() {
    this._map = new Map();
    this._promises = new Map();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._colorMap = null;
  }
  fire(languages2) {
    this._onDidChange.fire({
      changedLanguages: languages2,
      changedColorMap: false
    });
  }
  register(language, support) {
    this._map.set(language, support);
    this.fire([language]);
    return toDisposable(() => {
      if (this._map.get(language) !== support) {
        return;
      }
      this._map.delete(language);
      this.fire([language]);
    });
  }
  registerPromise(language, supportPromise) {
    let registration = null;
    let isDisposed = false;
    this._promises.set(language, supportPromise.then((support) => {
      this._promises.delete(language);
      if (isDisposed || !support) {
        return;
      }
      registration = this.register(language, support);
    }));
    return toDisposable(() => {
      isDisposed = true;
      if (registration) {
        registration.dispose();
      }
    });
  }
  getPromise(language) {
    const support = this.get(language);
    if (support) {
      return Promise.resolve(support);
    }
    const promise = this._promises.get(language);
    if (promise) {
      return promise.then((_) => this.get(language));
    }
    return null;
  }
  get(language) {
    return this._map.get(language) || null;
  }
  setColorMap(colorMap) {
    this._colorMap = colorMap;
    this._onDidChange.fire({
      changedLanguages: Array.from(this._map.keys()),
      changedColorMap: true
    });
  }
  getColorMap() {
    return this._colorMap;
  }
  getDefaultBackground() {
    if (this._colorMap && this._colorMap.length > 2) {
      return this._colorMap[2];
    }
    return null;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/filters.js
function or(...filter) {
  return function(word, wordToMatchAgainst) {
    for (let i = 0, len = filter.length; i < len; i++) {
      const match2 = filter[i](word, wordToMatchAgainst);
      if (match2) {
        return match2;
      }
    }
    return null;
  };
}
var matchesPrefix = _matchesPrefix.bind(void 0, true);
function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {
    return null;
  }
  let matches;
  if (ignoreCase) {
    matches = startsWithIgnoreCase(wordToMatchAgainst, word);
  } else {
    matches = wordToMatchAgainst.indexOf(word) === 0;
  }
  if (!matches) {
    return null;
  }
  return word.length > 0 ? [{start: 0, end: word.length}] : [];
}
function matchesContiguousSubString(word, wordToMatchAgainst) {
  const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
  if (index === -1) {
    return null;
  }
  return [{start: index, end: index + word.length}];
}
function matchesSubString(word, wordToMatchAgainst) {
  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
}
function _matchesSubString(word, wordToMatchAgainst, i, j) {
  if (i === word.length) {
    return [];
  } else if (j === wordToMatchAgainst.length) {
    return null;
  } else {
    if (word[i] === wordToMatchAgainst[j]) {
      let result = null;
      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {
        return join({start: j, end: j + 1}, result);
      }
      return null;
    }
    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
  }
}
function isLower(code) {
  return 97 <= code && code <= 122;
}
function isUpper(code) {
  return 65 <= code && code <= 90;
}
function isNumber2(code) {
  return 48 <= code && code <= 57;
}
function isWhitespace(code) {
  return code === 32 || code === 9 || code === 10 || code === 13;
}
var wordSeparators = new Set();
"`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?".split("").forEach((s) => wordSeparators.add(s.charCodeAt(0)));
function isAlphanumeric(code) {
  return isLower(code) || isUpper(code) || isNumber2(code);
}
function join(head, tail3) {
  if (tail3.length === 0) {
    tail3 = [head];
  } else if (head.end === tail3[0].start) {
    tail3[0].start = head.start;
  } else {
    tail3.unshift(head);
  }
  return tail3;
}
function nextAnchor(camelCaseWord, start) {
  for (let i = start; i < camelCaseWord.length; i++) {
    const c = camelCaseWord.charCodeAt(i);
    if (isUpper(c) || isNumber2(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {
      return i;
    }
  }
  return camelCaseWord.length;
}
function _matchesCamelCase(word, camelCaseWord, i, j) {
  if (i === word.length) {
    return [];
  } else if (j === camelCaseWord.length) {
    return null;
  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {
    return null;
  } else {
    let result = null;
    let nextUpperIndex = j + 1;
    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);
    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {
      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);
      nextUpperIndex++;
    }
    return result === null ? null : join({start: j, end: j + 1}, result);
  }
}
function analyzeCamelCaseWord(word) {
  let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;
  for (let i = 0; i < word.length; i++) {
    code = word.charCodeAt(i);
    if (isUpper(code)) {
      upper++;
    }
    if (isLower(code)) {
      lower++;
    }
    if (isAlphanumeric(code)) {
      alpha++;
    }
    if (isNumber2(code)) {
      numeric++;
    }
  }
  const upperPercent = upper / word.length;
  const lowerPercent = lower / word.length;
  const alphaPercent = alpha / word.length;
  const numericPercent = numeric / word.length;
  return {upperPercent, lowerPercent, alphaPercent, numericPercent};
}
function isUpperCaseWord(analysis) {
  const {upperPercent, lowerPercent} = analysis;
  return lowerPercent === 0 && upperPercent > 0.6;
}
function isCamelCaseWord(analysis) {
  const {upperPercent, lowerPercent, alphaPercent, numericPercent} = analysis;
  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;
}
function isCamelCasePattern(word) {
  let upper = 0, lower = 0, code = 0, whitespace = 0;
  for (let i = 0; i < word.length; i++) {
    code = word.charCodeAt(i);
    if (isUpper(code)) {
      upper++;
    }
    if (isLower(code)) {
      lower++;
    }
    if (isWhitespace(code)) {
      whitespace++;
    }
  }
  if ((upper === 0 || lower === 0) && whitespace === 0) {
    return word.length <= 30;
  } else {
    return upper <= 5;
  }
}
function matchesCamelCase(word, camelCaseWord) {
  if (!camelCaseWord) {
    return null;
  }
  camelCaseWord = camelCaseWord.trim();
  if (camelCaseWord.length === 0) {
    return null;
  }
  if (!isCamelCasePattern(word)) {
    return null;
  }
  if (camelCaseWord.length > 60) {
    return null;
  }
  const analysis = analyzeCamelCaseWord(camelCaseWord);
  if (!isCamelCaseWord(analysis)) {
    if (!isUpperCaseWord(analysis)) {
      return null;
    }
    camelCaseWord = camelCaseWord.toLowerCase();
  }
  let result = null;
  let i = 0;
  word = word.toLowerCase();
  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {
    i = nextAnchor(camelCaseWord, i + 1);
  }
  return result;
}
var fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);
var fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);
var fuzzyRegExpCache = new LRUCache(1e4);
function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {
  if (typeof word !== "string" || typeof wordToMatchAgainst !== "string") {
    return null;
  }
  let regexp = fuzzyRegExpCache.get(word);
  if (!regexp) {
    regexp = new RegExp(convertSimple2RegExpPattern(word), "i");
    fuzzyRegExpCache.set(word, regexp);
  }
  const match2 = regexp.exec(wordToMatchAgainst);
  if (match2) {
    return [{start: match2.index, end: match2.index + match2[0].length}];
  }
  return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);
}
var _maxLen = 128;
function initTable() {
  const table = [];
  const row = [0];
  for (let i = 1; i <= _maxLen; i++) {
    row.push(-i);
  }
  for (let i = 0; i <= _maxLen; i++) {
    const thisRow = row.slice(0);
    thisRow[0] = -i;
    table.push(thisRow);
  }
  return table;
}
var _table = initTable();
var _scores = initTable();
var _arrows = initTable();
var _debug = false;
function printTable(table, pattern, patternLen, word, wordLen) {
  function pad(s, n, pad2 = " ") {
    while (s.length < n) {
      s = pad2 + s;
    }
    return s;
  }
  let ret = ` |   |${word.split("").map((c) => pad(c, 3)).join("|")}
`;
  for (let i = 0; i <= patternLen; i++) {
    if (i === 0) {
      ret += " |";
    } else {
      ret += `${pattern[i - 1]}|`;
    }
    ret += table[i].slice(0, wordLen + 1).map((n) => pad(n.toString(), 3)).join("|") + "\n";
  }
  return ret;
}
function printTables(pattern, patternStart, word, wordStart) {
  pattern = pattern.substr(patternStart);
  word = word.substr(wordStart);
  console.log(printTable(_table, pattern, pattern.length, word, word.length));
  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));
  console.log(printTable(_scores, pattern, pattern.length, word, word.length));
}
function isSeparatorAtPos(value, index) {
  if (index < 0 || index >= value.length) {
    return false;
  }
  const code = value.charCodeAt(index);
  switch (code) {
    case 95:
    case 45:
    case 46:
    case 32:
    case 47:
    case 92:
    case 39:
    case 34:
    case 58:
    case 36:
      return true;
    default:
      return false;
  }
}
function isWhitespaceAtPos(value, index) {
  if (index < 0 || index >= value.length) {
    return false;
  }
  const code = value.charCodeAt(index);
  switch (code) {
    case 32:
    case 9:
      return true;
    default:
      return false;
  }
}
function isUpperCaseAtPos(pos, word, wordLow) {
  return word[pos] !== wordLow[pos];
}
function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen) {
  while (patternPos < patternLen && wordPos < wordLen) {
    if (patternLow[patternPos] === wordLow[wordPos]) {
      patternPos += 1;
    }
    wordPos += 1;
  }
  return patternPos === patternLen;
}
var FuzzyScore;
(function(FuzzyScore2) {
  FuzzyScore2.Default = Object.freeze([-100, 0, 0]);
  function isDefault(score2) {
    return !score2 || score2[0] === -100 && score2[1] === 0 && score2[2] === 0;
  }
  FuzzyScore2.isDefault = isDefault;
})(FuzzyScore || (FuzzyScore = {}));
function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {
  const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;
  const wordLen = word.length > _maxLen ? _maxLen : word.length;
  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {
    return void 0;
  }
  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen)) {
    return void 0;
  }
  let row = 1;
  let column = 1;
  let patternPos = patternStart;
  let wordPos = wordStart;
  let hasStrongFirstMatch = false;
  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {
    for (column = 1, wordPos = wordStart; wordPos < wordLen; column++, wordPos++) {
      const score2 = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos);
      if (patternPos === patternStart && score2 > 1) {
        hasStrongFirstMatch = true;
      }
      _scores[row][column] = score2;
      const diag = _table[row - 1][column - 1] + (score2 > 1 ? 1 : score2);
      const top = _table[row - 1][column] + -1;
      const left = _table[row][column - 1] + -1;
      if (left >= top) {
        if (left > diag) {
          _table[row][column] = left;
          _arrows[row][column] = 4;
        } else if (left === diag) {
          _table[row][column] = left;
          _arrows[row][column] = 4 | 2;
        } else {
          _table[row][column] = diag;
          _arrows[row][column] = 2;
        }
      } else {
        if (top > diag) {
          _table[row][column] = top;
          _arrows[row][column] = 1;
        } else if (top === diag) {
          _table[row][column] = top;
          _arrows[row][column] = 1 | 2;
        } else {
          _table[row][column] = diag;
          _arrows[row][column] = 2;
        }
      }
    }
  }
  if (_debug) {
    printTables(pattern, patternStart, word, wordStart);
  }
  if (!hasStrongFirstMatch && !firstMatchCanBeWeak) {
    return void 0;
  }
  _matchesCount = 0;
  _topScore = -100;
  _wordStart = wordStart;
  _firstMatchCanBeWeak = firstMatchCanBeWeak;
  _findAllMatches2(row - 1, column - 1, patternLen === wordLen ? 1 : 0, 0, false);
  if (_matchesCount === 0) {
    return void 0;
  }
  return [_topScore, _topMatch2, wordStart];
}
function _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos) {
  if (patternLow[patternPos] !== wordLow[wordPos]) {
    return -1;
  }
  if (wordPos === patternPos - patternStart) {
    if (pattern[patternPos] === word[wordPos]) {
      return 7;
    } else {
      return 5;
    }
  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {
    if (pattern[patternPos] === word[wordPos]) {
      return 7;
    } else {
      return 5;
    }
  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {
    return 5;
  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {
    return 5;
  } else {
    return 1;
  }
}
var _matchesCount = 0;
var _topMatch2 = 0;
var _topScore = 0;
var _wordStart = 0;
var _firstMatchCanBeWeak = false;
function _findAllMatches2(row, column, total, matches, lastMatched) {
  if (_matchesCount >= 10 || total < -25) {
    return;
  }
  let simpleMatchCount = 0;
  while (row > 0 && column > 0) {
    const score2 = _scores[row][column];
    const arrow = _arrows[row][column];
    if (arrow === 4) {
      column -= 1;
      if (lastMatched) {
        total -= 5;
      } else if (matches !== 0) {
        total -= 1;
      }
      lastMatched = false;
      simpleMatchCount = 0;
    } else if (arrow & 2) {
      if (arrow & 4) {
        _findAllMatches2(row, column - 1, matches !== 0 ? total - 1 : total, matches, lastMatched);
      }
      total += score2;
      row -= 1;
      column -= 1;
      lastMatched = true;
      matches += Math.pow(2, column + _wordStart);
      if (score2 === 1) {
        simpleMatchCount += 1;
        if (row === 0 && !_firstMatchCanBeWeak) {
          return void 0;
        }
      } else {
        total += 1 + simpleMatchCount * (score2 - 1);
        simpleMatchCount = 0;
      }
    } else {
      return void 0;
    }
  }
  total -= column >= 3 ? 9 : column * 3;
  _matchesCount += 1;
  if (total > _topScore) {
    _topScore = total;
    _topMatch2 = matches;
  }
}

// ../../node_modules/monaco-editor/esm/vs/base/common/codicon.js
var codiconStartMarker = "$(";
function parseCodicons(text) {
  const firstCodiconIndex = text.indexOf(codiconStartMarker);
  if (firstCodiconIndex === -1) {
    return {text};
  }
  return doParseCodicons(text, firstCodiconIndex);
}
function doParseCodicons(text, firstCodiconIndex) {
  const codiconOffsets = [];
  let textWithoutCodicons = "";
  function appendChars(chars) {
    if (chars) {
      textWithoutCodicons += chars;
      for (const _ of chars) {
        codiconOffsets.push(codiconsOffset);
      }
    }
  }
  let currentCodiconStart = -1;
  let currentCodiconValue = "";
  let codiconsOffset = 0;
  let char;
  let nextChar;
  let offset = firstCodiconIndex;
  const length = text.length;
  appendChars(text.substr(0, firstCodiconIndex));
  while (offset < length) {
    char = text[offset];
    nextChar = text[offset + 1];
    if (char === codiconStartMarker[0] && nextChar === codiconStartMarker[1]) {
      currentCodiconStart = offset;
      appendChars(currentCodiconValue);
      currentCodiconValue = codiconStartMarker;
      offset++;
    } else if (char === ")" && currentCodiconStart !== -1) {
      const currentCodiconLength = offset - currentCodiconStart + 1;
      codiconsOffset += currentCodiconLength;
      currentCodiconStart = -1;
      currentCodiconValue = "";
    } else if (currentCodiconStart !== -1) {
      if (/^[a-z0-9\-]$/i.test(char)) {
        currentCodiconValue += char;
      } else {
        appendChars(currentCodiconValue);
        currentCodiconStart = -1;
        currentCodiconValue = "";
      }
    } else {
      appendChars(char);
    }
    offset++;
  }
  appendChars(currentCodiconValue);
  return {text: textWithoutCodicons, codiconOffsets};
}
function matchesFuzzyCodiconAware(query, target, enableSeparateSubstringMatching = false) {
  const {text, codiconOffsets} = target;
  if (!codiconOffsets || codiconOffsets.length === 0) {
    return matchesFuzzy(query, text, enableSeparateSubstringMatching);
  }
  const wordToMatchAgainstWithoutCodiconsTrimmed = ltrim(text, " ");
  const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutCodiconsTrimmed.length;
  const matches = matchesFuzzy(query, wordToMatchAgainstWithoutCodiconsTrimmed, enableSeparateSubstringMatching);
  if (matches) {
    for (const match2 of matches) {
      const codiconOffset = codiconOffsets[match2.start + leadingWhitespaceOffset] + leadingWhitespaceOffset;
      match2.start += codiconOffset;
      match2.end += codiconOffset;
    }
  }
  return matches;
}

// ../../node_modules/monaco-editor/esm/vs/base/common/codicons.js
var Registry = class {
  constructor() {
    this._icons = new Map();
    this._onDidRegister = new Emitter();
  }
  add(icon) {
    if (!this._icons.has(icon.id)) {
      this._icons.set(icon.id, icon);
      this._onDidRegister.fire(icon);
    } else {
      console.error(`Duplicate registration of codicon ${icon.id}`);
    }
  }
  get(id) {
    return this._icons.get(id);
  }
  get all() {
    return this._icons.values();
  }
  get onDidRegister() {
    return this._onDidRegister.event;
  }
};
var _registry = new Registry();
var iconRegistry = _registry;
function registerIcon(id, def, description) {
  return new Codicon(id, def);
}
var Codicon = class {
  constructor(id, definition, description) {
    this.id = id;
    this.definition = definition;
    this.description = description;
    _registry.add(this);
  }
  get classNames() {
    return "codicon codicon-" + this.id;
  }
  get cssSelector() {
    return ".codicon.codicon-" + this.id;
  }
};
(function(Codicon2) {
  Codicon2.add = new Codicon2("add", {character: "\\ea60"});
  Codicon2.plus = new Codicon2("plus", {character: "\\ea60"});
  Codicon2.gistNew = new Codicon2("gist-new", {character: "\\ea60"});
  Codicon2.repoCreate = new Codicon2("repo-create", {character: "\\ea60"});
  Codicon2.lightbulb = new Codicon2("lightbulb", {character: "\\ea61"});
  Codicon2.lightBulb = new Codicon2("light-bulb", {character: "\\ea61"});
  Codicon2.repo = new Codicon2("repo", {character: "\\ea62"});
  Codicon2.repoDelete = new Codicon2("repo-delete", {character: "\\ea62"});
  Codicon2.gistFork = new Codicon2("gist-fork", {character: "\\ea63"});
  Codicon2.repoForked = new Codicon2("repo-forked", {character: "\\ea63"});
  Codicon2.gitPullRequest = new Codicon2("git-pull-request", {character: "\\ea64"});
  Codicon2.gitPullRequestAbandoned = new Codicon2("git-pull-request-abandoned", {character: "\\ea64"});
  Codicon2.recordKeys = new Codicon2("record-keys", {character: "\\ea65"});
  Codicon2.keyboard = new Codicon2("keyboard", {character: "\\ea65"});
  Codicon2.tag = new Codicon2("tag", {character: "\\ea66"});
  Codicon2.tagAdd = new Codicon2("tag-add", {character: "\\ea66"});
  Codicon2.tagRemove = new Codicon2("tag-remove", {character: "\\ea66"});
  Codicon2.person = new Codicon2("person", {character: "\\ea67"});
  Codicon2.personAdd = new Codicon2("person-add", {character: "\\ea67"});
  Codicon2.personFollow = new Codicon2("person-follow", {character: "\\ea67"});
  Codicon2.personOutline = new Codicon2("person-outline", {character: "\\ea67"});
  Codicon2.personFilled = new Codicon2("person-filled", {character: "\\ea67"});
  Codicon2.gitBranch = new Codicon2("git-branch", {character: "\\ea68"});
  Codicon2.gitBranchCreate = new Codicon2("git-branch-create", {character: "\\ea68"});
  Codicon2.gitBranchDelete = new Codicon2("git-branch-delete", {character: "\\ea68"});
  Codicon2.sourceControl = new Codicon2("source-control", {character: "\\ea68"});
  Codicon2.mirror = new Codicon2("mirror", {character: "\\ea69"});
  Codicon2.mirrorPublic = new Codicon2("mirror-public", {character: "\\ea69"});
  Codicon2.star = new Codicon2("star", {character: "\\ea6a"});
  Codicon2.starAdd = new Codicon2("star-add", {character: "\\ea6a"});
  Codicon2.starDelete = new Codicon2("star-delete", {character: "\\ea6a"});
  Codicon2.starEmpty = new Codicon2("star-empty", {character: "\\ea6a"});
  Codicon2.comment = new Codicon2("comment", {character: "\\ea6b"});
  Codicon2.commentAdd = new Codicon2("comment-add", {character: "\\ea6b"});
  Codicon2.alert = new Codicon2("alert", {character: "\\ea6c"});
  Codicon2.warning = new Codicon2("warning", {character: "\\ea6c"});
  Codicon2.search = new Codicon2("search", {character: "\\ea6d"});
  Codicon2.searchSave = new Codicon2("search-save", {character: "\\ea6d"});
  Codicon2.logOut = new Codicon2("log-out", {character: "\\ea6e"});
  Codicon2.signOut = new Codicon2("sign-out", {character: "\\ea6e"});
  Codicon2.logIn = new Codicon2("log-in", {character: "\\ea6f"});
  Codicon2.signIn = new Codicon2("sign-in", {character: "\\ea6f"});
  Codicon2.eye = new Codicon2("eye", {character: "\\ea70"});
  Codicon2.eyeUnwatch = new Codicon2("eye-unwatch", {character: "\\ea70"});
  Codicon2.eyeWatch = new Codicon2("eye-watch", {character: "\\ea70"});
  Codicon2.circleFilled = new Codicon2("circle-filled", {character: "\\ea71"});
  Codicon2.primitiveDot = new Codicon2("primitive-dot", {character: "\\ea71"});
  Codicon2.closeDirty = new Codicon2("close-dirty", {character: "\\ea71"});
  Codicon2.debugBreakpoint = new Codicon2("debug-breakpoint", {character: "\\ea71"});
  Codicon2.debugBreakpointDisabled = new Codicon2("debug-breakpoint-disabled", {character: "\\ea71"});
  Codicon2.debugHint = new Codicon2("debug-hint", {character: "\\ea71"});
  Codicon2.primitiveSquare = new Codicon2("primitive-square", {character: "\\ea72"});
  Codicon2.edit = new Codicon2("edit", {character: "\\ea73"});
  Codicon2.pencil = new Codicon2("pencil", {character: "\\ea73"});
  Codicon2.info = new Codicon2("info", {character: "\\ea74"});
  Codicon2.issueOpened = new Codicon2("issue-opened", {character: "\\ea74"});
  Codicon2.gistPrivate = new Codicon2("gist-private", {character: "\\ea75"});
  Codicon2.gitForkPrivate = new Codicon2("git-fork-private", {character: "\\ea75"});
  Codicon2.lock = new Codicon2("lock", {character: "\\ea75"});
  Codicon2.mirrorPrivate = new Codicon2("mirror-private", {character: "\\ea75"});
  Codicon2.close = new Codicon2("close", {character: "\\ea76"});
  Codicon2.removeClose = new Codicon2("remove-close", {character: "\\ea76"});
  Codicon2.x = new Codicon2("x", {character: "\\ea76"});
  Codicon2.repoSync = new Codicon2("repo-sync", {character: "\\ea77"});
  Codicon2.sync = new Codicon2("sync", {character: "\\ea77"});
  Codicon2.clone = new Codicon2("clone", {character: "\\ea78"});
  Codicon2.desktopDownload = new Codicon2("desktop-download", {character: "\\ea78"});
  Codicon2.beaker = new Codicon2("beaker", {character: "\\ea79"});
  Codicon2.microscope = new Codicon2("microscope", {character: "\\ea79"});
  Codicon2.vm = new Codicon2("vm", {character: "\\ea7a"});
  Codicon2.deviceDesktop = new Codicon2("device-desktop", {character: "\\ea7a"});
  Codicon2.file = new Codicon2("file", {character: "\\ea7b"});
  Codicon2.fileText = new Codicon2("file-text", {character: "\\ea7b"});
  Codicon2.more = new Codicon2("more", {character: "\\ea7c"});
  Codicon2.ellipsis = new Codicon2("ellipsis", {character: "\\ea7c"});
  Codicon2.kebabHorizontal = new Codicon2("kebab-horizontal", {character: "\\ea7c"});
  Codicon2.mailReply = new Codicon2("mail-reply", {character: "\\ea7d"});
  Codicon2.reply = new Codicon2("reply", {character: "\\ea7d"});
  Codicon2.organization = new Codicon2("organization", {character: "\\ea7e"});
  Codicon2.organizationFilled = new Codicon2("organization-filled", {character: "\\ea7e"});
  Codicon2.organizationOutline = new Codicon2("organization-outline", {character: "\\ea7e"});
  Codicon2.newFile = new Codicon2("new-file", {character: "\\ea7f"});
  Codicon2.fileAdd = new Codicon2("file-add", {character: "\\ea7f"});
  Codicon2.newFolder = new Codicon2("new-folder", {character: "\\ea80"});
  Codicon2.fileDirectoryCreate = new Codicon2("file-directory-create", {character: "\\ea80"});
  Codicon2.trash = new Codicon2("trash", {character: "\\ea81"});
  Codicon2.trashcan = new Codicon2("trashcan", {character: "\\ea81"});
  Codicon2.history = new Codicon2("history", {character: "\\ea82"});
  Codicon2.clock = new Codicon2("clock", {character: "\\ea82"});
  Codicon2.folder = new Codicon2("folder", {character: "\\ea83"});
  Codicon2.fileDirectory = new Codicon2("file-directory", {character: "\\ea83"});
  Codicon2.symbolFolder = new Codicon2("symbol-folder", {character: "\\ea83"});
  Codicon2.logoGithub = new Codicon2("logo-github", {character: "\\ea84"});
  Codicon2.markGithub = new Codicon2("mark-github", {character: "\\ea84"});
  Codicon2.github = new Codicon2("github", {character: "\\ea84"});
  Codicon2.terminal = new Codicon2("terminal", {character: "\\ea85"});
  Codicon2.console = new Codicon2("console", {character: "\\ea85"});
  Codicon2.repl = new Codicon2("repl", {character: "\\ea85"});
  Codicon2.zap = new Codicon2("zap", {character: "\\ea86"});
  Codicon2.symbolEvent = new Codicon2("symbol-event", {character: "\\ea86"});
  Codicon2.error = new Codicon2("error", {character: "\\ea87"});
  Codicon2.stop = new Codicon2("stop", {character: "\\ea87"});
  Codicon2.variable = new Codicon2("variable", {character: "\\ea88"});
  Codicon2.symbolVariable = new Codicon2("symbol-variable", {character: "\\ea88"});
  Codicon2.array = new Codicon2("array", {character: "\\ea8a"});
  Codicon2.symbolArray = new Codicon2("symbol-array", {character: "\\ea8a"});
  Codicon2.symbolModule = new Codicon2("symbol-module", {character: "\\ea8b"});
  Codicon2.symbolPackage = new Codicon2("symbol-package", {character: "\\ea8b"});
  Codicon2.symbolNamespace = new Codicon2("symbol-namespace", {character: "\\ea8b"});
  Codicon2.symbolObject = new Codicon2("symbol-object", {character: "\\ea8b"});
  Codicon2.symbolMethod = new Codicon2("symbol-method", {character: "\\ea8c"});
  Codicon2.symbolFunction = new Codicon2("symbol-function", {character: "\\ea8c"});
  Codicon2.symbolConstructor = new Codicon2("symbol-constructor", {character: "\\ea8c"});
  Codicon2.symbolBoolean = new Codicon2("symbol-boolean", {character: "\\ea8f"});
  Codicon2.symbolNull = new Codicon2("symbol-null", {character: "\\ea8f"});
  Codicon2.symbolNumeric = new Codicon2("symbol-numeric", {character: "\\ea90"});
  Codicon2.symbolNumber = new Codicon2("symbol-number", {character: "\\ea90"});
  Codicon2.symbolStructure = new Codicon2("symbol-structure", {character: "\\ea91"});
  Codicon2.symbolStruct = new Codicon2("symbol-struct", {character: "\\ea91"});
  Codicon2.symbolParameter = new Codicon2("symbol-parameter", {character: "\\ea92"});
  Codicon2.symbolTypeParameter = new Codicon2("symbol-type-parameter", {character: "\\ea92"});
  Codicon2.symbolKey = new Codicon2("symbol-key", {character: "\\ea93"});
  Codicon2.symbolText = new Codicon2("symbol-text", {character: "\\ea93"});
  Codicon2.symbolReference = new Codicon2("symbol-reference", {character: "\\ea94"});
  Codicon2.goToFile = new Codicon2("go-to-file", {character: "\\ea94"});
  Codicon2.symbolEnum = new Codicon2("symbol-enum", {character: "\\ea95"});
  Codicon2.symbolValue = new Codicon2("symbol-value", {character: "\\ea95"});
  Codicon2.symbolRuler = new Codicon2("symbol-ruler", {character: "\\ea96"});
  Codicon2.symbolUnit = new Codicon2("symbol-unit", {character: "\\ea96"});
  Codicon2.activateBreakpoints = new Codicon2("activate-breakpoints", {character: "\\ea97"});
  Codicon2.archive = new Codicon2("archive", {character: "\\ea98"});
  Codicon2.arrowBoth = new Codicon2("arrow-both", {character: "\\ea99"});
  Codicon2.arrowDown = new Codicon2("arrow-down", {character: "\\ea9a"});
  Codicon2.arrowLeft = new Codicon2("arrow-left", {character: "\\ea9b"});
  Codicon2.arrowRight = new Codicon2("arrow-right", {character: "\\ea9c"});
  Codicon2.arrowSmallDown = new Codicon2("arrow-small-down", {character: "\\ea9d"});
  Codicon2.arrowSmallLeft = new Codicon2("arrow-small-left", {character: "\\ea9e"});
  Codicon2.arrowSmallRight = new Codicon2("arrow-small-right", {character: "\\ea9f"});
  Codicon2.arrowSmallUp = new Codicon2("arrow-small-up", {character: "\\eaa0"});
  Codicon2.arrowUp = new Codicon2("arrow-up", {character: "\\eaa1"});
  Codicon2.bell = new Codicon2("bell", {character: "\\eaa2"});
  Codicon2.bold = new Codicon2("bold", {character: "\\eaa3"});
  Codicon2.book = new Codicon2("book", {character: "\\eaa4"});
  Codicon2.bookmark = new Codicon2("bookmark", {character: "\\eaa5"});
  Codicon2.debugBreakpointConditionalUnverified = new Codicon2("debug-breakpoint-conditional-unverified", {character: "\\eaa6"});
  Codicon2.debugBreakpointConditional = new Codicon2("debug-breakpoint-conditional", {character: "\\eaa7"});
  Codicon2.debugBreakpointConditionalDisabled = new Codicon2("debug-breakpoint-conditional-disabled", {character: "\\eaa7"});
  Codicon2.debugBreakpointDataUnverified = new Codicon2("debug-breakpoint-data-unverified", {character: "\\eaa8"});
  Codicon2.debugBreakpointData = new Codicon2("debug-breakpoint-data", {character: "\\eaa9"});
  Codicon2.debugBreakpointDataDisabled = new Codicon2("debug-breakpoint-data-disabled", {character: "\\eaa9"});
  Codicon2.debugBreakpointLogUnverified = new Codicon2("debug-breakpoint-log-unverified", {character: "\\eaaa"});
  Codicon2.debugBreakpointLog = new Codicon2("debug-breakpoint-log", {character: "\\eaab"});
  Codicon2.debugBreakpointLogDisabled = new Codicon2("debug-breakpoint-log-disabled", {character: "\\eaab"});
  Codicon2.briefcase = new Codicon2("briefcase", {character: "\\eaac"});
  Codicon2.broadcast = new Codicon2("broadcast", {character: "\\eaad"});
  Codicon2.browser = new Codicon2("browser", {character: "\\eaae"});
  Codicon2.bug = new Codicon2("bug", {character: "\\eaaf"});
  Codicon2.calendar = new Codicon2("calendar", {character: "\\eab0"});
  Codicon2.caseSensitive = new Codicon2("case-sensitive", {character: "\\eab1"});
  Codicon2.check = new Codicon2("check", {character: "\\eab2"});
  Codicon2.checklist = new Codicon2("checklist", {character: "\\eab3"});
  Codicon2.chevronDown = new Codicon2("chevron-down", {character: "\\eab4"});
  Codicon2.chevronLeft = new Codicon2("chevron-left", {character: "\\eab5"});
  Codicon2.chevronRight = new Codicon2("chevron-right", {character: "\\eab6"});
  Codicon2.chevronUp = new Codicon2("chevron-up", {character: "\\eab7"});
  Codicon2.chromeClose = new Codicon2("chrome-close", {character: "\\eab8"});
  Codicon2.chromeMaximize = new Codicon2("chrome-maximize", {character: "\\eab9"});
  Codicon2.chromeMinimize = new Codicon2("chrome-minimize", {character: "\\eaba"});
  Codicon2.chromeRestore = new Codicon2("chrome-restore", {character: "\\eabb"});
  Codicon2.circleOutline = new Codicon2("circle-outline", {character: "\\eabc"});
  Codicon2.debugBreakpointUnverified = new Codicon2("debug-breakpoint-unverified", {character: "\\eabc"});
  Codicon2.circleSlash = new Codicon2("circle-slash", {character: "\\eabd"});
  Codicon2.circuitBoard = new Codicon2("circuit-board", {character: "\\eabe"});
  Codicon2.clearAll = new Codicon2("clear-all", {character: "\\eabf"});
  Codicon2.clippy = new Codicon2("clippy", {character: "\\eac0"});
  Codicon2.closeAll = new Codicon2("close-all", {character: "\\eac1"});
  Codicon2.cloudDownload = new Codicon2("cloud-download", {character: "\\eac2"});
  Codicon2.cloudUpload = new Codicon2("cloud-upload", {character: "\\eac3"});
  Codicon2.code = new Codicon2("code", {character: "\\eac4"});
  Codicon2.collapseAll = new Codicon2("collapse-all", {character: "\\eac5"});
  Codicon2.colorMode = new Codicon2("color-mode", {character: "\\eac6"});
  Codicon2.commentDiscussion = new Codicon2("comment-discussion", {character: "\\eac7"});
  Codicon2.compareChanges = new Codicon2("compare-changes", {character: "\\eafd"});
  Codicon2.creditCard = new Codicon2("credit-card", {character: "\\eac9"});
  Codicon2.dash = new Codicon2("dash", {character: "\\eacc"});
  Codicon2.dashboard = new Codicon2("dashboard", {character: "\\eacd"});
  Codicon2.database = new Codicon2("database", {character: "\\eace"});
  Codicon2.debugContinue = new Codicon2("debug-continue", {character: "\\eacf"});
  Codicon2.debugDisconnect = new Codicon2("debug-disconnect", {character: "\\ead0"});
  Codicon2.debugPause = new Codicon2("debug-pause", {character: "\\ead1"});
  Codicon2.debugRestart = new Codicon2("debug-restart", {character: "\\ead2"});
  Codicon2.debugStart = new Codicon2("debug-start", {character: "\\ead3"});
  Codicon2.debugStepInto = new Codicon2("debug-step-into", {character: "\\ead4"});
  Codicon2.debugStepOut = new Codicon2("debug-step-out", {character: "\\ead5"});
  Codicon2.debugStepOver = new Codicon2("debug-step-over", {character: "\\ead6"});
  Codicon2.debugStop = new Codicon2("debug-stop", {character: "\\ead7"});
  Codicon2.debug = new Codicon2("debug", {character: "\\ead8"});
  Codicon2.deviceCameraVideo = new Codicon2("device-camera-video", {character: "\\ead9"});
  Codicon2.deviceCamera = new Codicon2("device-camera", {character: "\\eada"});
  Codicon2.deviceMobile = new Codicon2("device-mobile", {character: "\\eadb"});
  Codicon2.diffAdded = new Codicon2("diff-added", {character: "\\eadc"});
  Codicon2.diffIgnored = new Codicon2("diff-ignored", {character: "\\eadd"});
  Codicon2.diffModified = new Codicon2("diff-modified", {character: "\\eade"});
  Codicon2.diffRemoved = new Codicon2("diff-removed", {character: "\\eadf"});
  Codicon2.diffRenamed = new Codicon2("diff-renamed", {character: "\\eae0"});
  Codicon2.diff = new Codicon2("diff", {character: "\\eae1"});
  Codicon2.discard = new Codicon2("discard", {character: "\\eae2"});
  Codicon2.editorLayout = new Codicon2("editor-layout", {character: "\\eae3"});
  Codicon2.emptyWindow = new Codicon2("empty-window", {character: "\\eae4"});
  Codicon2.exclude = new Codicon2("exclude", {character: "\\eae5"});
  Codicon2.extensions = new Codicon2("extensions", {character: "\\eae6"});
  Codicon2.eyeClosed = new Codicon2("eye-closed", {character: "\\eae7"});
  Codicon2.fileBinary = new Codicon2("file-binary", {character: "\\eae8"});
  Codicon2.fileCode = new Codicon2("file-code", {character: "\\eae9"});
  Codicon2.fileMedia = new Codicon2("file-media", {character: "\\eaea"});
  Codicon2.filePdf = new Codicon2("file-pdf", {character: "\\eaeb"});
  Codicon2.fileSubmodule = new Codicon2("file-submodule", {character: "\\eaec"});
  Codicon2.fileSymlinkDirectory = new Codicon2("file-symlink-directory", {character: "\\eaed"});
  Codicon2.fileSymlinkFile = new Codicon2("file-symlink-file", {character: "\\eaee"});
  Codicon2.fileZip = new Codicon2("file-zip", {character: "\\eaef"});
  Codicon2.files = new Codicon2("files", {character: "\\eaf0"});
  Codicon2.filter = new Codicon2("filter", {character: "\\eaf1"});
  Codicon2.flame = new Codicon2("flame", {character: "\\eaf2"});
  Codicon2.foldDown = new Codicon2("fold-down", {character: "\\eaf3"});
  Codicon2.foldUp = new Codicon2("fold-up", {character: "\\eaf4"});
  Codicon2.fold = new Codicon2("fold", {character: "\\eaf5"});
  Codicon2.folderActive = new Codicon2("folder-active", {character: "\\eaf6"});
  Codicon2.folderOpened = new Codicon2("folder-opened", {character: "\\eaf7"});
  Codicon2.gear = new Codicon2("gear", {character: "\\eaf8"});
  Codicon2.gift = new Codicon2("gift", {character: "\\eaf9"});
  Codicon2.gistSecret = new Codicon2("gist-secret", {character: "\\eafa"});
  Codicon2.gist = new Codicon2("gist", {character: "\\eafb"});
  Codicon2.gitCommit = new Codicon2("git-commit", {character: "\\eafc"});
  Codicon2.gitCompare = new Codicon2("git-compare", {character: "\\eafd"});
  Codicon2.gitMerge = new Codicon2("git-merge", {character: "\\eafe"});
  Codicon2.githubAction = new Codicon2("github-action", {character: "\\eaff"});
  Codicon2.githubAlt = new Codicon2("github-alt", {character: "\\eb00"});
  Codicon2.globe = new Codicon2("globe", {character: "\\eb01"});
  Codicon2.grabber = new Codicon2("grabber", {character: "\\eb02"});
  Codicon2.graph = new Codicon2("graph", {character: "\\eb03"});
  Codicon2.gripper = new Codicon2("gripper", {character: "\\eb04"});
  Codicon2.heart = new Codicon2("heart", {character: "\\eb05"});
  Codicon2.home = new Codicon2("home", {character: "\\eb06"});
  Codicon2.horizontalRule = new Codicon2("horizontal-rule", {character: "\\eb07"});
  Codicon2.hubot = new Codicon2("hubot", {character: "\\eb08"});
  Codicon2.inbox = new Codicon2("inbox", {character: "\\eb09"});
  Codicon2.issueClosed = new Codicon2("issue-closed", {character: "\\eb0a"});
  Codicon2.issueReopened = new Codicon2("issue-reopened", {character: "\\eb0b"});
  Codicon2.issues = new Codicon2("issues", {character: "\\eb0c"});
  Codicon2.italic = new Codicon2("italic", {character: "\\eb0d"});
  Codicon2.jersey = new Codicon2("jersey", {character: "\\eb0e"});
  Codicon2.json = new Codicon2("json", {character: "\\eb0f"});
  Codicon2.kebabVertical = new Codicon2("kebab-vertical", {character: "\\eb10"});
  Codicon2.key = new Codicon2("key", {character: "\\eb11"});
  Codicon2.law = new Codicon2("law", {character: "\\eb12"});
  Codicon2.lightbulbAutofix = new Codicon2("lightbulb-autofix", {character: "\\eb13"});
  Codicon2.linkExternal = new Codicon2("link-external", {character: "\\eb14"});
  Codicon2.link = new Codicon2("link", {character: "\\eb15"});
  Codicon2.listOrdered = new Codicon2("list-ordered", {character: "\\eb16"});
  Codicon2.listUnordered = new Codicon2("list-unordered", {character: "\\eb17"});
  Codicon2.liveShare = new Codicon2("live-share", {character: "\\eb18"});
  Codicon2.loading = new Codicon2("loading", {character: "\\eb19"});
  Codicon2.location = new Codicon2("location", {character: "\\eb1a"});
  Codicon2.mailRead = new Codicon2("mail-read", {character: "\\eb1b"});
  Codicon2.mail = new Codicon2("mail", {character: "\\eb1c"});
  Codicon2.markdown = new Codicon2("markdown", {character: "\\eb1d"});
  Codicon2.megaphone = new Codicon2("megaphone", {character: "\\eb1e"});
  Codicon2.mention = new Codicon2("mention", {character: "\\eb1f"});
  Codicon2.milestone = new Codicon2("milestone", {character: "\\eb20"});
  Codicon2.mortarBoard = new Codicon2("mortar-board", {character: "\\eb21"});
  Codicon2.move = new Codicon2("move", {character: "\\eb22"});
  Codicon2.multipleWindows = new Codicon2("multiple-windows", {character: "\\eb23"});
  Codicon2.mute = new Codicon2("mute", {character: "\\eb24"});
  Codicon2.noNewline = new Codicon2("no-newline", {character: "\\eb25"});
  Codicon2.note = new Codicon2("note", {character: "\\eb26"});
  Codicon2.octoface = new Codicon2("octoface", {character: "\\eb27"});
  Codicon2.openPreview = new Codicon2("open-preview", {character: "\\eb28"});
  Codicon2.package_ = new Codicon2("package", {character: "\\eb29"});
  Codicon2.paintcan = new Codicon2("paintcan", {character: "\\eb2a"});
  Codicon2.pin = new Codicon2("pin", {character: "\\eb2b"});
  Codicon2.play = new Codicon2("play", {character: "\\eb2c"});
  Codicon2.run = new Codicon2("run", {character: "\\eb2c"});
  Codicon2.plug = new Codicon2("plug", {character: "\\eb2d"});
  Codicon2.preserveCase = new Codicon2("preserve-case", {character: "\\eb2e"});
  Codicon2.preview = new Codicon2("preview", {character: "\\eb2f"});
  Codicon2.project = new Codicon2("project", {character: "\\eb30"});
  Codicon2.pulse = new Codicon2("pulse", {character: "\\eb31"});
  Codicon2.question = new Codicon2("question", {character: "\\eb32"});
  Codicon2.quote = new Codicon2("quote", {character: "\\eb33"});
  Codicon2.radioTower = new Codicon2("radio-tower", {character: "\\eb34"});
  Codicon2.reactions = new Codicon2("reactions", {character: "\\eb35"});
  Codicon2.references = new Codicon2("references", {character: "\\eb36"});
  Codicon2.refresh = new Codicon2("refresh", {character: "\\eb37"});
  Codicon2.regex = new Codicon2("regex", {character: "\\eb38"});
  Codicon2.remoteExplorer = new Codicon2("remote-explorer", {character: "\\eb39"});
  Codicon2.remote = new Codicon2("remote", {character: "\\eb3a"});
  Codicon2.remove = new Codicon2("remove", {character: "\\eb3b"});
  Codicon2.replaceAll = new Codicon2("replace-all", {character: "\\eb3c"});
  Codicon2.replace = new Codicon2("replace", {character: "\\eb3d"});
  Codicon2.repoClone = new Codicon2("repo-clone", {character: "\\eb3e"});
  Codicon2.repoForcePush = new Codicon2("repo-force-push", {character: "\\eb3f"});
  Codicon2.repoPull = new Codicon2("repo-pull", {character: "\\eb40"});
  Codicon2.repoPush = new Codicon2("repo-push", {character: "\\eb41"});
  Codicon2.report = new Codicon2("report", {character: "\\eb42"});
  Codicon2.requestChanges = new Codicon2("request-changes", {character: "\\eb43"});
  Codicon2.rocket = new Codicon2("rocket", {character: "\\eb44"});
  Codicon2.rootFolderOpened = new Codicon2("root-folder-opened", {character: "\\eb45"});
  Codicon2.rootFolder = new Codicon2("root-folder", {character: "\\eb46"});
  Codicon2.rss = new Codicon2("rss", {character: "\\eb47"});
  Codicon2.ruby = new Codicon2("ruby", {character: "\\eb48"});
  Codicon2.saveAll = new Codicon2("save-all", {character: "\\eb49"});
  Codicon2.saveAs = new Codicon2("save-as", {character: "\\eb4a"});
  Codicon2.save = new Codicon2("save", {character: "\\eb4b"});
  Codicon2.screenFull = new Codicon2("screen-full", {character: "\\eb4c"});
  Codicon2.screenNormal = new Codicon2("screen-normal", {character: "\\eb4d"});
  Codicon2.searchStop = new Codicon2("search-stop", {character: "\\eb4e"});
  Codicon2.server = new Codicon2("server", {character: "\\eb50"});
  Codicon2.settingsGear = new Codicon2("settings-gear", {character: "\\eb51"});
  Codicon2.settings = new Codicon2("settings", {character: "\\eb52"});
  Codicon2.shield = new Codicon2("shield", {character: "\\eb53"});
  Codicon2.smiley = new Codicon2("smiley", {character: "\\eb54"});
  Codicon2.sortPrecedence = new Codicon2("sort-precedence", {character: "\\eb55"});
  Codicon2.splitHorizontal = new Codicon2("split-horizontal", {character: "\\eb56"});
  Codicon2.splitVertical = new Codicon2("split-vertical", {character: "\\eb57"});
  Codicon2.squirrel = new Codicon2("squirrel", {character: "\\eb58"});
  Codicon2.starFull = new Codicon2("star-full", {character: "\\eb59"});
  Codicon2.starHalf = new Codicon2("star-half", {character: "\\eb5a"});
  Codicon2.symbolClass = new Codicon2("symbol-class", {character: "\\eb5b"});
  Codicon2.symbolColor = new Codicon2("symbol-color", {character: "\\eb5c"});
  Codicon2.symbolConstant = new Codicon2("symbol-constant", {character: "\\eb5d"});
  Codicon2.symbolEnumMember = new Codicon2("symbol-enum-member", {character: "\\eb5e"});
  Codicon2.symbolField = new Codicon2("symbol-field", {character: "\\eb5f"});
  Codicon2.symbolFile = new Codicon2("symbol-file", {character: "\\eb60"});
  Codicon2.symbolInterface = new Codicon2("symbol-interface", {character: "\\eb61"});
  Codicon2.symbolKeyword = new Codicon2("symbol-keyword", {character: "\\eb62"});
  Codicon2.symbolMisc = new Codicon2("symbol-misc", {character: "\\eb63"});
  Codicon2.symbolOperator = new Codicon2("symbol-operator", {character: "\\eb64"});
  Codicon2.symbolProperty = new Codicon2("symbol-property", {character: "\\eb65"});
  Codicon2.wrench = new Codicon2("wrench", {character: "\\eb65"});
  Codicon2.wrenchSubaction = new Codicon2("wrench-subaction", {character: "\\eb65"});
  Codicon2.symbolSnippet = new Codicon2("symbol-snippet", {character: "\\eb66"});
  Codicon2.tasklist = new Codicon2("tasklist", {character: "\\eb67"});
  Codicon2.telescope = new Codicon2("telescope", {character: "\\eb68"});
  Codicon2.textSize = new Codicon2("text-size", {character: "\\eb69"});
  Codicon2.threeBars = new Codicon2("three-bars", {character: "\\eb6a"});
  Codicon2.thumbsdown = new Codicon2("thumbsdown", {character: "\\eb6b"});
  Codicon2.thumbsup = new Codicon2("thumbsup", {character: "\\eb6c"});
  Codicon2.tools = new Codicon2("tools", {character: "\\eb6d"});
  Codicon2.triangleDown = new Codicon2("triangle-down", {character: "\\eb6e"});
  Codicon2.triangleLeft = new Codicon2("triangle-left", {character: "\\eb6f"});
  Codicon2.triangleRight = new Codicon2("triangle-right", {character: "\\eb70"});
  Codicon2.triangleUp = new Codicon2("triangle-up", {character: "\\eb71"});
  Codicon2.twitter = new Codicon2("twitter", {character: "\\eb72"});
  Codicon2.unfold = new Codicon2("unfold", {character: "\\eb73"});
  Codicon2.unlock = new Codicon2("unlock", {character: "\\eb74"});
  Codicon2.unmute = new Codicon2("unmute", {character: "\\eb75"});
  Codicon2.unverified = new Codicon2("unverified", {character: "\\eb76"});
  Codicon2.verified = new Codicon2("verified", {character: "\\eb77"});
  Codicon2.versions = new Codicon2("versions", {character: "\\eb78"});
  Codicon2.vmActive = new Codicon2("vm-active", {character: "\\eb79"});
  Codicon2.vmOutline = new Codicon2("vm-outline", {character: "\\eb7a"});
  Codicon2.vmRunning = new Codicon2("vm-running", {character: "\\eb7b"});
  Codicon2.watch = new Codicon2("watch", {character: "\\eb7c"});
  Codicon2.whitespace = new Codicon2("whitespace", {character: "\\eb7d"});
  Codicon2.wholeWord = new Codicon2("whole-word", {character: "\\eb7e"});
  Codicon2.window = new Codicon2("window", {character: "\\eb7f"});
  Codicon2.wordWrap = new Codicon2("word-wrap", {character: "\\eb80"});
  Codicon2.zoomIn = new Codicon2("zoom-in", {character: "\\eb81"});
  Codicon2.zoomOut = new Codicon2("zoom-out", {character: "\\eb82"});
  Codicon2.listFilter = new Codicon2("list-filter", {character: "\\eb83"});
  Codicon2.listFlat = new Codicon2("list-flat", {character: "\\eb84"});
  Codicon2.listSelection = new Codicon2("list-selection", {character: "\\eb85"});
  Codicon2.selection = new Codicon2("selection", {character: "\\eb85"});
  Codicon2.listTree = new Codicon2("list-tree", {character: "\\eb86"});
  Codicon2.debugBreakpointFunctionUnverified = new Codicon2("debug-breakpoint-function-unverified", {character: "\\eb87"});
  Codicon2.debugBreakpointFunction = new Codicon2("debug-breakpoint-function", {character: "\\eb88"});
  Codicon2.debugBreakpointFunctionDisabled = new Codicon2("debug-breakpoint-function-disabled", {character: "\\eb88"});
  Codicon2.debugStackframeActive = new Codicon2("debug-stackframe-active", {character: "\\eb89"});
  Codicon2.debugStackframeDot = new Codicon2("debug-stackframe-dot", {character: "\\eb8a"});
  Codicon2.debugStackframe = new Codicon2("debug-stackframe", {character: "\\eb8b"});
  Codicon2.debugStackframeFocused = new Codicon2("debug-stackframe-focused", {character: "\\eb8b"});
  Codicon2.debugBreakpointUnsupported = new Codicon2("debug-breakpoint-unsupported", {character: "\\eb8c"});
  Codicon2.symbolString = new Codicon2("symbol-string", {character: "\\eb8d"});
  Codicon2.debugReverseContinue = new Codicon2("debug-reverse-continue", {character: "\\eb8e"});
  Codicon2.debugStepBack = new Codicon2("debug-step-back", {character: "\\eb8f"});
  Codicon2.debugRestartFrame = new Codicon2("debug-restart-frame", {character: "\\eb90"});
  Codicon2.callIncoming = new Codicon2("call-incoming", {character: "\\eb92"});
  Codicon2.callOutgoing = new Codicon2("call-outgoing", {character: "\\eb93"});
  Codicon2.menu = new Codicon2("menu", {character: "\\eb94"});
  Codicon2.expandAll = new Codicon2("expand-all", {character: "\\eb95"});
  Codicon2.feedback = new Codicon2("feedback", {character: "\\eb96"});
  Codicon2.groupByRefType = new Codicon2("group-by-ref-type", {character: "\\eb97"});
  Codicon2.ungroupByRefType = new Codicon2("ungroup-by-ref-type", {character: "\\eb98"});
  Codicon2.account = new Codicon2("account", {character: "\\eb99"});
  Codicon2.bellDot = new Codicon2("bell-dot", {character: "\\eb9a"});
  Codicon2.debugConsole = new Codicon2("debug-console", {character: "\\eb9b"});
  Codicon2.library = new Codicon2("library", {character: "\\eb9c"});
  Codicon2.output = new Codicon2("output", {character: "\\eb9d"});
  Codicon2.runAll = new Codicon2("run-all", {character: "\\eb9e"});
  Codicon2.syncIgnored = new Codicon2("sync-ignored", {character: "\\eb9f"});
  Codicon2.pinned = new Codicon2("pinned", {character: "\\eba0"});
  Codicon2.githubInverted = new Codicon2("github-inverted", {character: "\\eba1"});
  Codicon2.debugAlt = new Codicon2("debug-alt", {character: "\\eb91"});
  Codicon2.serverProcess = new Codicon2("server-process", {character: "\\eba2"});
  Codicon2.serverEnvironment = new Codicon2("server-environment", {character: "\\eba3"});
  Codicon2.pass = new Codicon2("pass", {character: "\\eba4"});
  Codicon2.stopCircle = new Codicon2("stop-circle", {character: "\\eba5"});
  Codicon2.playCircle = new Codicon2("play-circle", {character: "\\eba6"});
  Codicon2.record = new Codicon2("record", {character: "\\eba7"});
  Codicon2.debugAltSmall = new Codicon2("debug-alt-small", {character: "\\eba8"});
  Codicon2.vmConnect = new Codicon2("vm-connect", {character: "\\eba9"});
  Codicon2.cloud = new Codicon2("cloud", {character: "\\ebaa"});
  Codicon2.merge = new Codicon2("merge", {character: "\\ebab"});
})(Codicon || (Codicon = {}));
var renderCodiconsRegex = /(\\)?\$\((([a-z0-9\-]+?)(?:~([a-z0-9\-]*?))?)\)/gi;
function renderCodicons(text) {
  return text.replace(renderCodiconsRegex, (_, escaped, codicon, name, animation) => {
    return escaped ? `$(${codicon})` : `<span class="codicon codicon-${name}${animation ? ` codicon-animation-${animation}` : ""}"></span>`;
  });
}
var stripCodiconsRegex = /(\s)?(\\)?\$\([a-z0-9\-]+?(?:~[a-z0-9\-]*?)?\)(\s)?/gi;
function stripCodicons(text) {
  if (text.indexOf(codiconStartMarker) === -1) {
    return text;
  }
  return text.replace(stripCodiconsRegex, (match2, preWhitespace, escaped, postWhitespace) => escaped ? match2 : preWhitespace || postWhitespace || "");
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes.js
var LanguageIdentifier = class {
  constructor(language, id) {
    this.language = language;
    this.id = id;
  }
};
var TokenMetadata = class {
  static getLanguageId(metadata) {
    return (metadata & 255) >>> 0;
  }
  static getTokenType(metadata) {
    return (metadata & 1792) >>> 8;
  }
  static getFontStyle(metadata) {
    return (metadata & 14336) >>> 11;
  }
  static getForeground(metadata) {
    return (metadata & 8372224) >>> 14;
  }
  static getBackground(metadata) {
    return (metadata & 4286578688) >>> 23;
  }
  static getClassNameFromMetadata(metadata) {
    let foreground2 = this.getForeground(metadata);
    let className = "mtk" + foreground2;
    let fontStyle = this.getFontStyle(metadata);
    if (fontStyle & 1) {
      className += " mtki";
    }
    if (fontStyle & 2) {
      className += " mtkb";
    }
    if (fontStyle & 4) {
      className += " mtku";
    }
    return className;
  }
  static getInlineStyleFromMetadata(metadata, colorMap) {
    const foreground2 = this.getForeground(metadata);
    const fontStyle = this.getFontStyle(metadata);
    let result = `color: ${colorMap[foreground2]};`;
    if (fontStyle & 1) {
      result += "font-style: italic;";
    }
    if (fontStyle & 2) {
      result += "font-weight: bold;";
    }
    if (fontStyle & 4) {
      result += "text-decoration: underline;";
    }
    return result;
  }
};
var completionKindToCssClass = function() {
  let data = Object.create(null);
  data[0] = "symbol-method";
  data[1] = "symbol-function";
  data[2] = "symbol-constructor";
  data[3] = "symbol-field";
  data[4] = "symbol-variable";
  data[5] = "symbol-class";
  data[6] = "symbol-struct";
  data[7] = "symbol-interface";
  data[8] = "symbol-module";
  data[9] = "symbol-property";
  data[10] = "symbol-event";
  data[11] = "symbol-operator";
  data[12] = "symbol-unit";
  data[13] = "symbol-value";
  data[14] = "symbol-constant";
  data[15] = "symbol-enum";
  data[16] = "symbol-enum-member";
  data[17] = "symbol-keyword";
  data[27] = "symbol-snippet";
  data[18] = "symbol-text";
  data[19] = "symbol-color";
  data[20] = "symbol-file";
  data[21] = "symbol-reference";
  data[22] = "symbol-customcolor";
  data[23] = "symbol-folder";
  data[24] = "symbol-type-parameter";
  data[25] = "account";
  data[26] = "issues";
  return function(kind) {
    const name = data[kind];
    let codicon = name && iconRegistry.get(name);
    if (!codicon) {
      console.info("No codicon found for CompletionItemKind " + kind);
      codicon = Codicon.symbolProperty;
    }
    return codicon.classNames;
  };
}();
var completionKindFromString = function() {
  let data = Object.create(null);
  data["method"] = 0;
  data["function"] = 1;
  data["constructor"] = 2;
  data["field"] = 3;
  data["variable"] = 4;
  data["class"] = 5;
  data["struct"] = 6;
  data["interface"] = 7;
  data["module"] = 8;
  data["property"] = 9;
  data["event"] = 10;
  data["operator"] = 11;
  data["unit"] = 12;
  data["value"] = 13;
  data["constant"] = 14;
  data["enum"] = 15;
  data["enum-member"] = 16;
  data["enumMember"] = 16;
  data["keyword"] = 17;
  data["snippet"] = 27;
  data["text"] = 18;
  data["color"] = 19;
  data["file"] = 20;
  data["reference"] = 21;
  data["customcolor"] = 22;
  data["folder"] = 23;
  data["type-parameter"] = 24;
  data["typeParameter"] = 24;
  data["account"] = 25;
  data["issue"] = 26;
  return function(value, strict) {
    let res = data[value];
    if (typeof res === "undefined" && !strict) {
      res = 9;
    }
    return res;
  };
}();
var SignatureHelpTriggerKind2;
(function(SignatureHelpTriggerKind3) {
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));
var DocumentHighlightKind2;
(function(DocumentHighlightKind3) {
  DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
  DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
  DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
})(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
var SymbolKinds;
(function(SymbolKinds2) {
  const byName = new Map();
  byName.set("file", 0);
  byName.set("module", 1);
  byName.set("namespace", 2);
  byName.set("package", 3);
  byName.set("class", 4);
  byName.set("method", 5);
  byName.set("property", 6);
  byName.set("field", 7);
  byName.set("constructor", 8);
  byName.set("enum", 9);
  byName.set("interface", 10);
  byName.set("function", 11);
  byName.set("variable", 12);
  byName.set("constant", 13);
  byName.set("string", 14);
  byName.set("number", 15);
  byName.set("boolean", 16);
  byName.set("array", 17);
  byName.set("object", 18);
  byName.set("key", 19);
  byName.set("null", 20);
  byName.set("enum-member", 21);
  byName.set("struct", 22);
  byName.set("event", 23);
  byName.set("operator", 24);
  byName.set("type-parameter", 25);
  const byKind = new Map();
  byKind.set(0, "file");
  byKind.set(1, "module");
  byKind.set(2, "namespace");
  byKind.set(3, "package");
  byKind.set(4, "class");
  byKind.set(5, "method");
  byKind.set(6, "property");
  byKind.set(7, "field");
  byKind.set(8, "constructor");
  byKind.set(9, "enum");
  byKind.set(10, "interface");
  byKind.set(11, "function");
  byKind.set(12, "variable");
  byKind.set(13, "constant");
  byKind.set(14, "string");
  byKind.set(15, "number");
  byKind.set(16, "boolean");
  byKind.set(17, "array");
  byKind.set(18, "object");
  byKind.set(19, "key");
  byKind.set(20, "null");
  byKind.set(21, "enum-member");
  byKind.set(22, "struct");
  byKind.set(23, "event");
  byKind.set(24, "operator");
  byKind.set(25, "type-parameter");
  function fromString(value) {
    return byName.get(value);
  }
  SymbolKinds2.fromString = fromString;
  function toString(kind) {
    return byKind.get(kind);
  }
  SymbolKinds2.toString = toString;
  function toCssClassName(kind, inline) {
    const symbolName = byKind.get(kind);
    let codicon = symbolName && iconRegistry.get("symbol-" + symbolName);
    if (!codicon) {
      console.info("No codicon found for SymbolKind " + kind);
      codicon = Codicon.symbolProperty;
    }
    return `${inline ? "inline" : "block"} ${codicon.classNames}`;
  }
  SymbolKinds2.toCssClassName = toCssClassName;
})(SymbolKinds || (SymbolKinds = {}));
var FoldingRangeKind = class {
  constructor(value) {
    this.value = value;
  }
};
FoldingRangeKind.Comment = new FoldingRangeKind("comment");
FoldingRangeKind.Imports = new FoldingRangeKind("imports");
FoldingRangeKind.Region = new FoldingRangeKind("region");
var ReferenceProviderRegistry = new LanguageFeatureRegistry();
var RenameProviderRegistry = new LanguageFeatureRegistry();
var CompletionProviderRegistry = new LanguageFeatureRegistry();
var SignatureHelpProviderRegistry = new LanguageFeatureRegistry();
var HoverProviderRegistry = new LanguageFeatureRegistry();
var DocumentSymbolProviderRegistry = new LanguageFeatureRegistry();
var DocumentHighlightProviderRegistry = new LanguageFeatureRegistry();
var OnTypeRenameProviderRegistry = new LanguageFeatureRegistry();
var DefinitionProviderRegistry = new LanguageFeatureRegistry();
var DeclarationProviderRegistry = new LanguageFeatureRegistry();
var ImplementationProviderRegistry = new LanguageFeatureRegistry();
var TypeDefinitionProviderRegistry = new LanguageFeatureRegistry();
var CodeLensProviderRegistry = new LanguageFeatureRegistry();
var CodeActionProviderRegistry = new LanguageFeatureRegistry();
var DocumentFormattingEditProviderRegistry = new LanguageFeatureRegistry();
var DocumentRangeFormattingEditProviderRegistry = new LanguageFeatureRegistry();
var OnTypeFormattingEditProviderRegistry = new LanguageFeatureRegistry();
var LinkProviderRegistry = new LanguageFeatureRegistry();
var ColorProviderRegistry = new LanguageFeatureRegistry();
var SelectionRangeRegistry = new LanguageFeatureRegistry();
var FoldingRangeProviderRegistry = new LanguageFeatureRegistry();
var DocumentSemanticTokensProviderRegistry = new LanguageFeatureRegistry();
var DocumentRangeSemanticTokensProviderRegistry = new LanguageFeatureRegistry();
var TokenizationRegistry = new TokenizationRegistryImpl();

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/nullMode.js
var NullStateImpl = class {
  clone() {
    return this;
  }
  equals(other) {
    return this === other;
  }
};
var NULL_STATE = new NullStateImpl();
var NULL_MODE_ID = "vs.editor.nullMode";
var NULL_LANGUAGE_IDENTIFIER = new LanguageIdentifier(NULL_MODE_ID, 0);
function nullTokenize(modeId, buffer4, state, deltaOffset) {
  return new TokenizationResult([new Token(deltaOffset, "", modeId)], state);
}
function nullTokenize2(languageId, buffer4, state, deltaOffset) {
  let tokens = new Uint32Array(2);
  tokens[0] = deltaOffset;
  tokens[1] = (languageId << 0 | 0 << 8 | 0 << 11 | 1 << 14 | 2 << 23) >>> 0;
  return new TokenizationResult2(tokens, state === null ? NULL_STATE : state);
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerService.js
var ID_EDITOR_WORKER_SERVICE = "editorWorkerService";
var IEditorWorkerService = createDecorator(ID_EDITOR_WORKER_SERVICE);

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js
var ITextModelService = createDecorator("textModelService");

// ../../node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js
var INITIALIZE = "$initialize";
var webWorkerWarningLogged = false;
function logOnceWebWorkerWarning(err) {
  if (!isWeb) {
    return;
  }
  if (!webWorkerWarningLogged) {
    webWorkerWarningLogged = true;
    console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/Microsoft/monaco-editor#faq");
  }
  console.warn(err.message);
}
var SimpleWorkerProtocol = class {
  constructor(handler) {
    this._workerId = -1;
    this._handler = handler;
    this._lastSentReq = 0;
    this._pendingReplies = Object.create(null);
  }
  setWorkerId(workerId) {
    this._workerId = workerId;
  }
  sendMessage(method, args) {
    let req = String(++this._lastSentReq);
    return new Promise((resolve2, reject) => {
      this._pendingReplies[req] = {
        resolve: resolve2,
        reject
      };
      this._send({
        vsWorker: this._workerId,
        req,
        method,
        args
      });
    });
  }
  handleMessage(message) {
    if (!message || !message.vsWorker) {
      return;
    }
    if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
      return;
    }
    this._handleMessage(message);
  }
  _handleMessage(msg) {
    if (msg.seq) {
      let replyMessage = msg;
      if (!this._pendingReplies[replyMessage.seq]) {
        console.warn("Got reply to unknown seq");
        return;
      }
      let reply = this._pendingReplies[replyMessage.seq];
      delete this._pendingReplies[replyMessage.seq];
      if (replyMessage.err) {
        let err = replyMessage.err;
        if (replyMessage.err.$isError) {
          err = new Error();
          err.name = replyMessage.err.name;
          err.message = replyMessage.err.message;
          err.stack = replyMessage.err.stack;
        }
        reply.reject(err);
        return;
      }
      reply.resolve(replyMessage.res);
      return;
    }
    let requestMessage = msg;
    let req = requestMessage.req;
    let result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
    result.then((r) => {
      this._send({
        vsWorker: this._workerId,
        seq: req,
        res: r,
        err: void 0
      });
    }, (e) => {
      if (e.detail instanceof Error) {
        e.detail = transformErrorForSerialization(e.detail);
      }
      this._send({
        vsWorker: this._workerId,
        seq: req,
        res: void 0,
        err: transformErrorForSerialization(e)
      });
    });
  }
  _send(msg) {
    let transfer = [];
    if (msg.req) {
      const m = msg;
      for (let i = 0; i < m.args.length; i++) {
        if (m.args[i] instanceof ArrayBuffer) {
          transfer.push(m.args[i]);
        }
      }
    } else {
      const m = msg;
      if (m.res instanceof ArrayBuffer) {
        transfer.push(m.res);
      }
    }
    this._handler.sendMessage(msg, transfer);
  }
};
var SimpleWorkerClient = class extends Disposable {
  constructor(workerFactory, moduleId, host) {
    super();
    let lazyProxyReject = null;
    this._worker = this._register(workerFactory.create("vs/base/common/worker/simpleWorker", (msg) => {
      this._protocol.handleMessage(msg);
    }, (err) => {
      if (lazyProxyReject) {
        lazyProxyReject(err);
      }
    }));
    this._protocol = new SimpleWorkerProtocol({
      sendMessage: (msg, transfer) => {
        this._worker.postMessage(msg, transfer);
      },
      handleMessage: (method, args) => {
        if (typeof host[method] !== "function") {
          return Promise.reject(new Error("Missing method " + method + " on main thread host."));
        }
        try {
          return Promise.resolve(host[method].apply(host, args));
        } catch (e) {
          return Promise.reject(e);
        }
      }
    });
    this._protocol.setWorkerId(this._worker.getId());
    let loaderConfiguration = null;
    if (typeof self.require !== "undefined" && typeof self.require.getConfig === "function") {
      loaderConfiguration = self.require.getConfig();
    } else if (typeof self.requirejs !== "undefined") {
      loaderConfiguration = self.requirejs.s.contexts._.config;
    }
    const hostMethods = getAllMethodNames(host);
    this._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [
      this._worker.getId(),
      JSON.parse(JSON.stringify(loaderConfiguration)),
      moduleId,
      hostMethods
    ]);
    const proxyMethodRequest = (method, args) => {
      return this._request(method, args);
    };
    this._lazyProxy = new Promise((resolve2, reject) => {
      lazyProxyReject = reject;
      this._onModuleLoaded.then((availableMethods) => {
        resolve2(createProxyObject(availableMethods, proxyMethodRequest));
      }, (e) => {
        reject(e);
        this._onError("Worker failed to load " + moduleId, e);
      });
    });
  }
  getProxyObject() {
    return this._lazyProxy;
  }
  _request(method, args) {
    return new Promise((resolve2, reject) => {
      this._onModuleLoaded.then(() => {
        this._protocol.sendMessage(method, args).then(resolve2, reject);
      }, reject);
    });
  }
  _onError(message, error) {
    console.error(message);
    console.info(error);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/worker/defaultWorkerFactory.js
function getWorker(workerId, label) {
  if (globals.MonacoEnvironment) {
    if (typeof globals.MonacoEnvironment.getWorker === "function") {
      return globals.MonacoEnvironment.getWorker(workerId, label);
    }
    if (typeof globals.MonacoEnvironment.getWorkerUrl === "function") {
      return new Worker(globals.MonacoEnvironment.getWorkerUrl(workerId, label));
    }
  }
  throw new Error(`You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker`);
}
function isPromiseLike(obj) {
  if (typeof obj.then === "function") {
    return true;
  }
  return false;
}
var WebWorker = class {
  constructor(moduleId, id, label, onMessageCallback, onErrorCallback) {
    this.id = id;
    const workerOrPromise = getWorker("workerMain.js", label);
    if (isPromiseLike(workerOrPromise)) {
      this.worker = workerOrPromise;
    } else {
      this.worker = Promise.resolve(workerOrPromise);
    }
    this.postMessage(moduleId, []);
    this.worker.then((w) => {
      w.onmessage = function(ev) {
        onMessageCallback(ev.data);
      };
      w.onmessageerror = onErrorCallback;
      if (typeof w.addEventListener === "function") {
        w.addEventListener("error", onErrorCallback);
      }
    });
  }
  getId() {
    return this.id;
  }
  postMessage(message, transfer) {
    if (this.worker) {
      this.worker.then((w) => w.postMessage(message, transfer));
    }
  }
  dispose() {
    if (this.worker) {
      this.worker.then((w) => w.terminate());
    }
    this.worker = null;
  }
};
var DefaultWorkerFactory = class {
  constructor(label) {
    this._label = label;
    this._webWorkerFailedBeforeError = false;
  }
  create(moduleId, onMessageCallback, onErrorCallback) {
    let workerId = ++DefaultWorkerFactory.LAST_WORKER_ID;
    if (this._webWorkerFailedBeforeError) {
      throw this._webWorkerFailedBeforeError;
    }
    return new WebWorker(moduleId, workerId, this._label || "anonymous" + workerId, onMessageCallback, (err) => {
      logOnceWebWorkerWarning(err);
      this._webWorkerFailedBeforeError = err;
      onErrorCallback(err);
    });
  }
};
DefaultWorkerFactory.LAST_WORKER_ID = 0;

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/languageConfiguration.js
var IndentAction2;
(function(IndentAction3) {
  IndentAction3[IndentAction3["None"] = 0] = "None";
  IndentAction3[IndentAction3["Indent"] = 1] = "Indent";
  IndentAction3[IndentAction3["IndentOutdent"] = 2] = "IndentOutdent";
  IndentAction3[IndentAction3["Outdent"] = 3] = "Outdent";
})(IndentAction2 || (IndentAction2 = {}));
var StandardAutoClosingPairConditional = class {
  constructor(source) {
    this.open = source.open;
    this.close = source.close;
    this._standardTokenMask = 0;
    if (Array.isArray(source.notIn)) {
      for (let i = 0, len = source.notIn.length; i < len; i++) {
        const notIn = source.notIn[i];
        switch (notIn) {
          case "string":
            this._standardTokenMask |= 2;
            break;
          case "comment":
            this._standardTokenMask |= 1;
            break;
          case "regex":
            this._standardTokenMask |= 4;
            break;
        }
      }
    }
  }
  isOK(standardToken) {
    return (this._standardTokenMask & standardToken) === 0;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports.js
function createScopedLineTokens(context, offset) {
  let tokenCount = context.getCount();
  let tokenIndex = context.findTokenIndexAtOffset(offset);
  let desiredLanguageId = context.getLanguageId(tokenIndex);
  let lastTokenIndex = tokenIndex;
  while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {
    lastTokenIndex++;
  }
  let firstTokenIndex = tokenIndex;
  while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {
    firstTokenIndex--;
  }
  return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));
}
var ScopedLineTokens = class {
  constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {
    this._actual = actual;
    this.languageId = languageId;
    this._firstTokenIndex = firstTokenIndex;
    this._lastTokenIndex = lastTokenIndex;
    this.firstCharOffset = firstCharOffset;
    this._lastCharOffset = lastCharOffset;
  }
  getLineContent() {
    const actualLineContent = this._actual.getLineContent();
    return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);
  }
  getActualLineContentBefore(offset) {
    const actualLineContent = this._actual.getLineContent();
    return actualLineContent.substring(0, this.firstCharOffset + offset);
  }
  getTokenCount() {
    return this._lastTokenIndex - this._firstTokenIndex;
  }
  findTokenIndexAtOffset(offset) {
    return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;
  }
  getStandardTokenType(tokenIndex) {
    return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);
  }
};
function ignoreBracketsInToken(standardTokenType) {
  return (standardTokenType & 7) !== 0;
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports/characterPair.js
var CharacterPairSupport = class {
  constructor(config) {
    if (config.autoClosingPairs) {
      this._autoClosingPairs = config.autoClosingPairs.map((el) => new StandardAutoClosingPairConditional(el));
    } else if (config.brackets) {
      this._autoClosingPairs = config.brackets.map((b) => new StandardAutoClosingPairConditional({open: b[0], close: b[1]}));
    } else {
      this._autoClosingPairs = [];
    }
    if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {
      const docComment = config.__electricCharacterSupport.docComment;
      this._autoClosingPairs.push(new StandardAutoClosingPairConditional({open: docComment.open, close: docComment.close || ""}));
    }
    this._autoCloseBefore = typeof config.autoCloseBefore === "string" ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;
    this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;
  }
  getAutoClosingPairs() {
    return this._autoClosingPairs;
  }
  getAutoCloseBeforeSet() {
    return this._autoCloseBefore;
  }
  static shouldAutoClosePair(autoClosingPair, context, column) {
    if (context.getTokenCount() === 0) {
      return true;
    }
    const tokenIndex = context.findTokenIndexAtOffset(column - 2);
    const standardTokenType = context.getStandardTokenType(tokenIndex);
    return autoClosingPair.isOK(standardTokenType);
  }
  getSurroundingPairs() {
    return this._surroundingPairs;
  }
};
CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED = ";:.,=}])> \n	";

// ../../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js
var _platformTextDecoder;
function getPlatformTextDecoder() {
  if (!_platformTextDecoder) {
    _platformTextDecoder = new TextDecoder(isLittleEndian() ? "UTF-16LE" : "UTF-16BE");
  }
  return _platformTextDecoder;
}
var hasTextDecoder2 = typeof TextDecoder !== "undefined";
var createStringBuilder;
var decodeUTF16LE;
if (hasTextDecoder2) {
  createStringBuilder = (capacity) => new StringBuilder(capacity);
  decodeUTF16LE = standardDecodeUTF16LE;
} else {
  createStringBuilder = (capacity) => new CompatStringBuilder();
  decodeUTF16LE = compatDecodeUTF16LE;
}
function standardDecodeUTF16LE(source, offset, len) {
  const view = new Uint16Array(source.buffer, offset, len);
  return getPlatformTextDecoder().decode(view);
}
function compatDecodeUTF16LE(source, offset, len) {
  let result = [];
  let resultLen = 0;
  for (let i = 0; i < len; i++) {
    const charCode = readUInt16LE(source, offset);
    offset += 2;
    result[resultLen++] = String.fromCharCode(charCode);
  }
  return result.join("");
}
var StringBuilder = class {
  constructor(capacity) {
    this._capacity = capacity | 0;
    this._buffer = new Uint16Array(this._capacity);
    this._completedStrings = null;
    this._bufferLength = 0;
  }
  reset() {
    this._completedStrings = null;
    this._bufferLength = 0;
  }
  build() {
    if (this._completedStrings !== null) {
      this._flushBuffer();
      return this._completedStrings.join("");
    }
    return this._buildBuffer();
  }
  _buildBuffer() {
    if (this._bufferLength === 0) {
      return "";
    }
    const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
    return getPlatformTextDecoder().decode(view);
  }
  _flushBuffer() {
    const bufferString = this._buildBuffer();
    this._bufferLength = 0;
    if (this._completedStrings === null) {
      this._completedStrings = [bufferString];
    } else {
      this._completedStrings[this._completedStrings.length] = bufferString;
    }
  }
  write1(charCode) {
    const remainingSpace = this._capacity - this._bufferLength;
    if (remainingSpace <= 1) {
      if (remainingSpace === 0 || isHighSurrogate(charCode)) {
        this._flushBuffer();
      }
    }
    this._buffer[this._bufferLength++] = charCode;
  }
  appendASCII(charCode) {
    if (this._bufferLength === this._capacity) {
      this._flushBuffer();
    }
    this._buffer[this._bufferLength++] = charCode;
  }
  appendASCIIString(str) {
    const strLen = str.length;
    if (this._bufferLength + strLen >= this._capacity) {
      this._flushBuffer();
      this._completedStrings[this._completedStrings.length] = str;
      return;
    }
    for (let i = 0; i < strLen; i++) {
      this._buffer[this._bufferLength++] = str.charCodeAt(i);
    }
  }
};
var CompatStringBuilder = class {
  constructor() {
    this._pieces = [];
    this._piecesLen = 0;
  }
  reset() {
    this._pieces = [];
    this._piecesLen = 0;
  }
  build() {
    return this._pieces.join("");
  }
  write1(charCode) {
    this._pieces[this._piecesLen++] = String.fromCharCode(charCode);
  }
  appendASCII(charCode) {
    this._pieces[this._piecesLen++] = String.fromCharCode(charCode);
  }
  appendASCIIString(str) {
    this._pieces[this._piecesLen++] = str;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports/richEditBrackets.js
var RichEditBracket = class {
  constructor(languageIdentifier, index, open, close, forwardRegex, reversedRegex) {
    this.languageIdentifier = languageIdentifier;
    this.index = index;
    this.open = open;
    this.close = close;
    this.forwardRegex = forwardRegex;
    this.reversedRegex = reversedRegex;
    this._openSet = RichEditBracket._toSet(this.open);
    this._closeSet = RichEditBracket._toSet(this.close);
  }
  isOpen(text) {
    return this._openSet.has(text);
  }
  isClose(text) {
    return this._closeSet.has(text);
  }
  static _toSet(arr) {
    const result = new Set();
    for (const element of arr) {
      result.add(element);
    }
    return result;
  }
};
function groupFuzzyBrackets(brackets) {
  const N = brackets.length;
  brackets = brackets.map((b) => [b[0].toLowerCase(), b[1].toLowerCase()]);
  const group = [];
  for (let i = 0; i < N; i++) {
    group[i] = i;
  }
  const areOverlapping = (a, b) => {
    const [aOpen, aClose] = a;
    const [bOpen, bClose] = b;
    return aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose;
  };
  const mergeGroups = (g1, g2) => {
    const newG = Math.min(g1, g2);
    const oldG = Math.max(g1, g2);
    for (let i = 0; i < N; i++) {
      if (group[i] === oldG) {
        group[i] = newG;
      }
    }
  };
  for (let i = 0; i < N; i++) {
    const a = brackets[i];
    for (let j = i + 1; j < N; j++) {
      const b = brackets[j];
      if (areOverlapping(a, b)) {
        mergeGroups(group[i], group[j]);
      }
    }
  }
  const result = [];
  for (let g = 0; g < N; g++) {
    let currentOpen = [];
    let currentClose = [];
    for (let i = 0; i < N; i++) {
      if (group[i] === g) {
        const [open, close] = brackets[i];
        currentOpen.push(open);
        currentClose.push(close);
      }
    }
    if (currentOpen.length > 0) {
      result.push({
        open: currentOpen,
        close: currentClose
      });
    }
  }
  return result;
}
var RichEditBrackets = class {
  constructor(languageIdentifier, _brackets) {
    const brackets = groupFuzzyBrackets(_brackets);
    this.brackets = brackets.map((b, index) => {
      return new RichEditBracket(languageIdentifier, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));
    });
    this.forwardRegex = getRegexForBrackets(this.brackets);
    this.reversedRegex = getReversedRegexForBrackets(this.brackets);
    this.textIsBracket = {};
    this.textIsOpenBracket = {};
    this.maxBracketLength = 0;
    for (const bracket of this.brackets) {
      for (const open of bracket.open) {
        this.textIsBracket[open] = bracket;
        this.textIsOpenBracket[open] = true;
        this.maxBracketLength = Math.max(this.maxBracketLength, open.length);
      }
      for (const close of bracket.close) {
        this.textIsBracket[close] = bracket;
        this.textIsOpenBracket[close] = false;
        this.maxBracketLength = Math.max(this.maxBracketLength, close.length);
      }
    }
  }
};
function collectSuperstrings(str, brackets, currentIndex, dest) {
  for (let i = 0, len = brackets.length; i < len; i++) {
    if (i === currentIndex) {
      continue;
    }
    const bracket = brackets[i];
    for (const open of bracket.open) {
      if (open.indexOf(str) >= 0) {
        dest.push(open);
      }
    }
    for (const close of bracket.close) {
      if (close.indexOf(str) >= 0) {
        dest.push(close);
      }
    }
  }
}
function lengthcmp(a, b) {
  return a.length - b.length;
}
function unique(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const result = [];
  const seen = new Set();
  for (const element of arr) {
    if (seen.has(element)) {
      continue;
    }
    result.push(element);
    seen.add(element);
  }
  return result;
}
function getRegexForBracketPair(open, close, brackets, currentIndex) {
  let pieces = [];
  pieces = pieces.concat(open);
  pieces = pieces.concat(close);
  for (let i = 0, len = pieces.length; i < len; i++) {
    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);
  }
  pieces = unique(pieces);
  pieces.sort(lengthcmp);
  pieces.reverse();
  return createBracketOrRegExp(pieces);
}
function getReversedRegexForBracketPair(open, close, brackets, currentIndex) {
  let pieces = [];
  pieces = pieces.concat(open);
  pieces = pieces.concat(close);
  for (let i = 0, len = pieces.length; i < len; i++) {
    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);
  }
  pieces = unique(pieces);
  pieces.sort(lengthcmp);
  pieces.reverse();
  return createBracketOrRegExp(pieces.map(toReversedString));
}
function getRegexForBrackets(brackets) {
  let pieces = [];
  for (const bracket of brackets) {
    for (const open of bracket.open) {
      pieces.push(open);
    }
    for (const close of bracket.close) {
      pieces.push(close);
    }
  }
  pieces = unique(pieces);
  return createBracketOrRegExp(pieces);
}
function getReversedRegexForBrackets(brackets) {
  let pieces = [];
  for (const bracket of brackets) {
    for (const open of bracket.open) {
      pieces.push(open);
    }
    for (const close of bracket.close) {
      pieces.push(close);
    }
  }
  pieces = unique(pieces);
  return createBracketOrRegExp(pieces.map(toReversedString));
}
function prepareBracketForRegExp(str) {
  const insertWordBoundaries = /^[\w ]+$/.test(str);
  str = escapeRegExpCharacters(str);
  return insertWordBoundaries ? `\\b${str}\\b` : str;
}
function createBracketOrRegExp(pieces) {
  let regexStr = `(${pieces.map(prepareBracketForRegExp).join(")|(")})`;
  return createRegExp(regexStr, true);
}
var toReversedString = function() {
  function reverse(str) {
    if (hasTextDecoder2) {
      const arr = new Uint16Array(str.length);
      let offset = 0;
      for (let i = str.length - 1; i >= 0; i--) {
        arr[offset++] = str.charCodeAt(i);
      }
      return getPlatformTextDecoder().decode(arr);
    } else {
      let result = [], resultLen = 0;
      for (let i = str.length - 1; i >= 0; i--) {
        result[resultLen++] = str.charAt(i);
      }
      return result.join("");
    }
  }
  let lastInput = null;
  let lastOutput = null;
  return function toReversedString2(str) {
    if (lastInput !== str) {
      lastInput = str;
      lastOutput = reverse(lastInput);
    }
    return lastOutput;
  };
}();
var BracketsUtils = class {
  static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {
    let m = reversedText.match(reversedBracketRegex);
    if (!m) {
      return null;
    }
    let matchOffset = reversedText.length - (m.index || 0);
    let matchLength = m[0].length;
    let absoluteMatchOffset = offset + matchOffset;
    return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);
  }
  static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {
    const reversedLineText = toReversedString(lineText);
    const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);
    return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);
  }
  static findNextBracketInText(bracketRegex, lineNumber, text, offset) {
    let m = text.match(bracketRegex);
    if (!m) {
      return null;
    }
    let matchOffset = m.index || 0;
    let matchLength = m[0].length;
    if (matchLength === 0) {
      return null;
    }
    let absoluteMatchOffset = offset + matchOffset;
    return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);
  }
  static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {
    const substr = lineText.substring(startOffset, endOffset);
    return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports/electricCharacter.js
var BracketElectricCharacterSupport = class {
  constructor(richEditBrackets) {
    this._richEditBrackets = richEditBrackets;
  }
  getElectricCharacters() {
    let result = [];
    if (this._richEditBrackets) {
      for (const bracket of this._richEditBrackets.brackets) {
        for (const close of bracket.close) {
          const lastChar = close.charAt(close.length - 1);
          result.push(lastChar);
        }
      }
    }
    result = result.filter((item, pos, array) => {
      return array.indexOf(item) === pos;
    });
    return result;
  }
  onElectricCharacter(character, context, column) {
    if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {
      return null;
    }
    const tokenIndex = context.findTokenIndexAtOffset(column - 1);
    if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {
      return null;
    }
    const reversedBracketRegex = this._richEditBrackets.reversedRegex;
    const text = context.getLineContent().substring(0, column - 1) + character;
    const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);
    if (!r) {
      return null;
    }
    const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
    const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];
    if (isOpen) {
      return null;
    }
    const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);
    if (!/^\s*$/.test(textBeforeBracket)) {
      return null;
    }
    return {
      matchOpenBracket: bracketText
    };
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports/indentRules.js
var IndentRulesSupport = class {
  constructor(indentationRules) {
    this._indentationRules = indentationRules;
  }
  shouldIncrease(text) {
    if (this._indentationRules) {
      if (this._indentationRules.increaseIndentPattern && this._indentationRules.increaseIndentPattern.test(text)) {
        return true;
      }
    }
    return false;
  }
  shouldDecrease(text) {
    if (this._indentationRules && this._indentationRules.decreaseIndentPattern && this._indentationRules.decreaseIndentPattern.test(text)) {
      return true;
    }
    return false;
  }
  shouldIndentNextLine(text) {
    if (this._indentationRules && this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {
      return true;
    }
    return false;
  }
  shouldIgnore(text) {
    if (this._indentationRules && this._indentationRules.unIndentedLinePattern && this._indentationRules.unIndentedLinePattern.test(text)) {
      return true;
    }
    return false;
  }
  getIndentMetadata(text) {
    let ret = 0;
    if (this.shouldIncrease(text)) {
      ret += 1;
    }
    if (this.shouldDecrease(text)) {
      ret += 2;
    }
    if (this.shouldIndentNextLine(text)) {
      ret += 4;
    }
    if (this.shouldIgnore(text)) {
      ret += 8;
    }
    return ret;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports/onEnter.js
var OnEnterSupport = class {
  constructor(opts) {
    opts = opts || {};
    opts.brackets = opts.brackets || [
      ["(", ")"],
      ["{", "}"],
      ["[", "]"]
    ];
    this._brackets = [];
    opts.brackets.forEach((bracket) => {
      const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);
      const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);
      if (openRegExp && closeRegExp) {
        this._brackets.push({
          open: bracket[0],
          openRegExp,
          close: bracket[1],
          closeRegExp
        });
      }
    });
    this._regExpRules = opts.onEnterRules || [];
  }
  onEnter(autoIndent, oneLineAboveText, beforeEnterText, afterEnterText) {
    if (autoIndent >= 3) {
      for (let i = 0, len = this._regExpRules.length; i < len; i++) {
        let rule = this._regExpRules[i];
        const regResult = [{
          reg: rule.beforeText,
          text: beforeEnterText
        }, {
          reg: rule.afterText,
          text: afterEnterText
        }, {
          reg: rule.oneLineAboveText,
          text: oneLineAboveText
        }].every((obj) => {
          return obj.reg ? obj.reg.test(obj.text) : true;
        });
        if (regResult) {
          return rule.action;
        }
      }
    }
    if (autoIndent >= 2) {
      if (beforeEnterText.length > 0 && afterEnterText.length > 0) {
        for (let i = 0, len = this._brackets.length; i < len; i++) {
          let bracket = this._brackets[i];
          if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {
            return {indentAction: IndentAction2.IndentOutdent};
          }
        }
      }
    }
    if (autoIndent >= 2) {
      if (beforeEnterText.length > 0) {
        for (let i = 0, len = this._brackets.length; i < len; i++) {
          let bracket = this._brackets[i];
          if (bracket.openRegExp.test(beforeEnterText)) {
            return {indentAction: IndentAction2.Indent};
          }
        }
      }
    }
    return null;
  }
  static _createOpenBracketRegExp(bracket) {
    let str = escapeRegExpCharacters(bracket);
    if (!/\B/.test(str.charAt(0))) {
      str = "\\b" + str;
    }
    str += "\\s*$";
    return OnEnterSupport._safeRegExp(str);
  }
  static _createCloseBracketRegExp(bracket) {
    let str = escapeRegExpCharacters(bracket);
    if (!/\B/.test(str.charAt(str.length - 1))) {
      str = str + "\\b";
    }
    str = "^\\s*" + str;
    return OnEnterSupport._safeRegExp(str);
  }
  static _safeRegExp(def) {
    try {
      return new RegExp(def);
    } catch (err) {
      onUnexpectedError(err);
      return null;
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/languageConfigurationRegistry.js
var RichEditSupport = class {
  constructor(languageIdentifier, previous, rawConf) {
    this._languageIdentifier = languageIdentifier;
    this._brackets = null;
    this._electricCharacter = null;
    let prev = null;
    if (previous) {
      prev = previous._conf;
    }
    this._conf = RichEditSupport._mergeConf(prev, rawConf);
    this._onEnterSupport = this._conf.brackets || this._conf.indentationRules || this._conf.onEnterRules ? new OnEnterSupport(this._conf) : null;
    this.comments = RichEditSupport._handleComments(this._conf);
    this.characterPair = new CharacterPairSupport(this._conf);
    this.wordDefinition = this._conf.wordPattern || DEFAULT_WORD_REGEXP;
    this.indentationRules = this._conf.indentationRules;
    if (this._conf.indentationRules) {
      this.indentRulesSupport = new IndentRulesSupport(this._conf.indentationRules);
    } else {
      this.indentRulesSupport = null;
    }
    this.foldingRules = this._conf.folding || {};
  }
  get brackets() {
    if (!this._brackets && this._conf.brackets) {
      this._brackets = new RichEditBrackets(this._languageIdentifier, this._conf.brackets);
    }
    return this._brackets;
  }
  get electricCharacter() {
    if (!this._electricCharacter) {
      this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);
    }
    return this._electricCharacter;
  }
  onEnter(autoIndent, oneLineAboveText, beforeEnterText, afterEnterText) {
    if (!this._onEnterSupport) {
      return null;
    }
    return this._onEnterSupport.onEnter(autoIndent, oneLineAboveText, beforeEnterText, afterEnterText);
  }
  static _mergeConf(prev, current) {
    return {
      comments: prev ? current.comments || prev.comments : current.comments,
      brackets: prev ? current.brackets || prev.brackets : current.brackets,
      wordPattern: prev ? current.wordPattern || prev.wordPattern : current.wordPattern,
      indentationRules: prev ? current.indentationRules || prev.indentationRules : current.indentationRules,
      onEnterRules: prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules,
      autoClosingPairs: prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs,
      surroundingPairs: prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs,
      autoCloseBefore: prev ? current.autoCloseBefore || prev.autoCloseBefore : current.autoCloseBefore,
      folding: prev ? current.folding || prev.folding : current.folding,
      __electricCharacterSupport: prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport
    };
  }
  static _handleComments(conf) {
    let commentRule = conf.comments;
    if (!commentRule) {
      return null;
    }
    let comments = {};
    if (commentRule.lineComment) {
      comments.lineCommentToken = commentRule.lineComment;
    }
    if (commentRule.blockComment) {
      let [blockStart, blockEnd] = commentRule.blockComment;
      comments.blockCommentStartToken = blockStart;
      comments.blockCommentEndToken = blockEnd;
    }
    return comments;
  }
};
var LanguageConfigurationChangeEvent = class {
  constructor(languageIdentifier) {
    this.languageIdentifier = languageIdentifier;
  }
};
var LanguageConfigurationRegistryImpl = class {
  constructor() {
    this._entries = new Map();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
  }
  register(languageIdentifier, configuration) {
    let previous = this._getRichEditSupport(languageIdentifier.id);
    let current = new RichEditSupport(languageIdentifier, previous, configuration);
    this._entries.set(languageIdentifier.id, current);
    this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));
    return toDisposable(() => {
      if (this._entries.get(languageIdentifier.id) === current) {
        this._entries.set(languageIdentifier.id, previous);
        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));
      }
    });
  }
  _getRichEditSupport(languageId) {
    return this._entries.get(languageId);
  }
  getIndentationRules(languageId) {
    const value = this._entries.get(languageId);
    if (!value) {
      return null;
    }
    return value.indentationRules || null;
  }
  _getElectricCharacterSupport(languageId) {
    let value = this._getRichEditSupport(languageId);
    if (!value) {
      return null;
    }
    return value.electricCharacter || null;
  }
  getElectricCharacters(languageId) {
    let electricCharacterSupport = this._getElectricCharacterSupport(languageId);
    if (!electricCharacterSupport) {
      return [];
    }
    return electricCharacterSupport.getElectricCharacters();
  }
  onElectricCharacter(character, context, column) {
    let scopedLineTokens = createScopedLineTokens(context, column - 1);
    let electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);
    if (!electricCharacterSupport) {
      return null;
    }
    return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);
  }
  getComments(languageId) {
    let value = this._getRichEditSupport(languageId);
    if (!value) {
      return null;
    }
    return value.comments || null;
  }
  _getCharacterPairSupport(languageId) {
    let value = this._getRichEditSupport(languageId);
    if (!value) {
      return null;
    }
    return value.characterPair || null;
  }
  getAutoClosingPairs(languageId) {
    let characterPairSupport = this._getCharacterPairSupport(languageId);
    if (!characterPairSupport) {
      return [];
    }
    return characterPairSupport.getAutoClosingPairs();
  }
  getAutoCloseBeforeSet(languageId) {
    let characterPairSupport = this._getCharacterPairSupport(languageId);
    if (!characterPairSupport) {
      return CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;
    }
    return characterPairSupport.getAutoCloseBeforeSet();
  }
  getSurroundingPairs(languageId) {
    let characterPairSupport = this._getCharacterPairSupport(languageId);
    if (!characterPairSupport) {
      return [];
    }
    return characterPairSupport.getSurroundingPairs();
  }
  shouldAutoClosePair(autoClosingPair, context, column) {
    const scopedLineTokens = createScopedLineTokens(context, column - 1);
    return CharacterPairSupport.shouldAutoClosePair(autoClosingPair, scopedLineTokens, column - scopedLineTokens.firstCharOffset);
  }
  getWordDefinition(languageId) {
    let value = this._getRichEditSupport(languageId);
    if (!value) {
      return ensureValidWordDefinition(null);
    }
    return ensureValidWordDefinition(value.wordDefinition || null);
  }
  getFoldingRules(languageId) {
    let value = this._getRichEditSupport(languageId);
    if (!value) {
      return {};
    }
    return value.foldingRules;
  }
  getIndentRulesSupport(languageId) {
    let value = this._getRichEditSupport(languageId);
    if (!value) {
      return null;
    }
    return value.indentRulesSupport || null;
  }
  getPrecedingValidLine(model2, lineNumber, indentRulesSupport) {
    let languageID = model2.getLanguageIdAtPosition(lineNumber, 0);
    if (lineNumber > 1) {
      let lastLineNumber;
      let resultLineNumber = -1;
      for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {
        if (model2.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {
          return resultLineNumber;
        }
        let text = model2.getLineContent(lastLineNumber);
        if (indentRulesSupport.shouldIgnore(text) || /^\s+$/.test(text) || text === "") {
          resultLineNumber = lastLineNumber;
          continue;
        }
        return lastLineNumber;
      }
    }
    return -1;
  }
  getInheritIndentForLine(autoIndent, model2, lineNumber, honorIntentialIndent = true) {
    if (autoIndent < 4) {
      return null;
    }
    const indentRulesSupport = this.getIndentRulesSupport(model2.getLanguageIdentifier().id);
    if (!indentRulesSupport) {
      return null;
    }
    if (lineNumber <= 1) {
      return {
        indentation: "",
        action: null
      };
    }
    const precedingUnIgnoredLine = this.getPrecedingValidLine(model2, lineNumber, indentRulesSupport);
    if (precedingUnIgnoredLine < 0) {
      return null;
    } else if (precedingUnIgnoredLine < 1) {
      return {
        indentation: "",
        action: null
      };
    }
    const precedingUnIgnoredLineContent = model2.getLineContent(precedingUnIgnoredLine);
    if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {
      return {
        indentation: getLeadingWhitespace(precedingUnIgnoredLineContent),
        action: IndentAction2.Indent,
        line: precedingUnIgnoredLine
      };
    } else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {
      return {
        indentation: getLeadingWhitespace(precedingUnIgnoredLineContent),
        action: null,
        line: precedingUnIgnoredLine
      };
    } else {
      if (precedingUnIgnoredLine === 1) {
        return {
          indentation: getLeadingWhitespace(model2.getLineContent(precedingUnIgnoredLine)),
          action: null,
          line: precedingUnIgnoredLine
        };
      }
      const previousLine = precedingUnIgnoredLine - 1;
      const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model2.getLineContent(previousLine));
      if (!(previousLineIndentMetadata & (1 | 2)) && previousLineIndentMetadata & 4) {
        let stopLine = 0;
        for (let i = previousLine - 1; i > 0; i--) {
          if (indentRulesSupport.shouldIndentNextLine(model2.getLineContent(i))) {
            continue;
          }
          stopLine = i;
          break;
        }
        return {
          indentation: getLeadingWhitespace(model2.getLineContent(stopLine + 1)),
          action: null,
          line: stopLine + 1
        };
      }
      if (honorIntentialIndent) {
        return {
          indentation: getLeadingWhitespace(model2.getLineContent(precedingUnIgnoredLine)),
          action: null,
          line: precedingUnIgnoredLine
        };
      } else {
        for (let i = precedingUnIgnoredLine; i > 0; i--) {
          const lineContent = model2.getLineContent(i);
          if (indentRulesSupport.shouldIncrease(lineContent)) {
            return {
              indentation: getLeadingWhitespace(lineContent),
              action: IndentAction2.Indent,
              line: i
            };
          } else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {
            let stopLine = 0;
            for (let j = i - 1; j > 0; j--) {
              if (indentRulesSupport.shouldIndentNextLine(model2.getLineContent(i))) {
                continue;
              }
              stopLine = j;
              break;
            }
            return {
              indentation: getLeadingWhitespace(model2.getLineContent(stopLine + 1)),
              action: null,
              line: stopLine + 1
            };
          } else if (indentRulesSupport.shouldDecrease(lineContent)) {
            return {
              indentation: getLeadingWhitespace(lineContent),
              action: null,
              line: i
            };
          }
        }
        return {
          indentation: getLeadingWhitespace(model2.getLineContent(1)),
          action: null,
          line: 1
        };
      }
    }
  }
  getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {
    if (autoIndent < 4) {
      return null;
    }
    const richEditSupport = this._getRichEditSupport(languageId);
    if (!richEditSupport) {
      return null;
    }
    const indentRulesSupport = this.getIndentRulesSupport(languageId);
    if (!indentRulesSupport) {
      return null;
    }
    const indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);
    const lineContent = virtualModel.getLineContent(lineNumber);
    if (indent) {
      const inheritLine = indent.line;
      if (inheritLine !== void 0) {
        const enterResult = richEditSupport.onEnter(autoIndent, "", virtualModel.getLineContent(inheritLine), "");
        if (enterResult) {
          let indentation = getLeadingWhitespace(virtualModel.getLineContent(inheritLine));
          if (enterResult.removeText) {
            indentation = indentation.substring(0, indentation.length - enterResult.removeText);
          }
          if (enterResult.indentAction === IndentAction2.Indent || enterResult.indentAction === IndentAction2.IndentOutdent) {
            indentation = indentConverter.shiftIndent(indentation);
          } else if (enterResult.indentAction === IndentAction2.Outdent) {
            indentation = indentConverter.unshiftIndent(indentation);
          }
          if (indentRulesSupport.shouldDecrease(lineContent)) {
            indentation = indentConverter.unshiftIndent(indentation);
          }
          if (enterResult.appendText) {
            indentation += enterResult.appendText;
          }
          return getLeadingWhitespace(indentation);
        }
      }
      if (indentRulesSupport.shouldDecrease(lineContent)) {
        if (indent.action === IndentAction2.Indent) {
          return indent.indentation;
        } else {
          return indentConverter.unshiftIndent(indent.indentation);
        }
      } else {
        if (indent.action === IndentAction2.Indent) {
          return indentConverter.shiftIndent(indent.indentation);
        } else {
          return indent.indentation;
        }
      }
    }
    return null;
  }
  getIndentForEnter(autoIndent, model2, range2, indentConverter) {
    if (autoIndent < 4) {
      return null;
    }
    model2.forceTokenization(range2.startLineNumber);
    const lineTokens = model2.getLineTokens(range2.startLineNumber);
    const scopedLineTokens = createScopedLineTokens(lineTokens, range2.startColumn - 1);
    const scopedLineText = scopedLineTokens.getLineContent();
    let embeddedLanguage = false;
    let beforeEnterText;
    if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {
      embeddedLanguage = true;
      beforeEnterText = scopedLineText.substr(0, range2.startColumn - 1 - scopedLineTokens.firstCharOffset);
    } else {
      beforeEnterText = lineTokens.getLineContent().substring(0, range2.startColumn - 1);
    }
    let afterEnterText;
    if (range2.isEmpty()) {
      afterEnterText = scopedLineText.substr(range2.startColumn - 1 - scopedLineTokens.firstCharOffset);
    } else {
      const endScopedLineTokens = this.getScopedLineTokens(model2, range2.endLineNumber, range2.endColumn);
      afterEnterText = endScopedLineTokens.getLineContent().substr(range2.endColumn - 1 - scopedLineTokens.firstCharOffset);
    }
    const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);
    if (!indentRulesSupport) {
      return null;
    }
    const beforeEnterResult = beforeEnterText;
    const beforeEnterIndent = getLeadingWhitespace(beforeEnterText);
    const virtualModel = {
      getLineTokens: (lineNumber) => {
        return model2.getLineTokens(lineNumber);
      },
      getLanguageIdentifier: () => {
        return model2.getLanguageIdentifier();
      },
      getLanguageIdAtPosition: (lineNumber, column) => {
        return model2.getLanguageIdAtPosition(lineNumber, column);
      },
      getLineContent: (lineNumber) => {
        if (lineNumber === range2.startLineNumber) {
          return beforeEnterResult;
        } else {
          return model2.getLineContent(lineNumber);
        }
      }
    };
    const currentLineIndent = getLeadingWhitespace(lineTokens.getLineContent());
    const afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range2.startLineNumber + 1);
    if (!afterEnterAction) {
      const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;
      return {
        beforeEnter,
        afterEnter: beforeEnter
      };
    }
    let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;
    if (afterEnterAction.action === IndentAction2.Indent) {
      afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);
    }
    if (indentRulesSupport.shouldDecrease(afterEnterText)) {
      afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);
    }
    return {
      beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,
      afterEnter: afterEnterIndent
    };
  }
  getIndentActionForType(autoIndent, model2, range2, ch, indentConverter) {
    if (autoIndent < 4) {
      return null;
    }
    const scopedLineTokens = this.getScopedLineTokens(model2, range2.startLineNumber, range2.startColumn);
    const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);
    if (!indentRulesSupport) {
      return null;
    }
    const scopedLineText = scopedLineTokens.getLineContent();
    const beforeTypeText = scopedLineText.substr(0, range2.startColumn - 1 - scopedLineTokens.firstCharOffset);
    let afterTypeText;
    if (range2.isEmpty()) {
      afterTypeText = scopedLineText.substr(range2.startColumn - 1 - scopedLineTokens.firstCharOffset);
    } else {
      const endScopedLineTokens = this.getScopedLineTokens(model2, range2.endLineNumber, range2.endColumn);
      afterTypeText = endScopedLineTokens.getLineContent().substr(range2.endColumn - 1 - scopedLineTokens.firstCharOffset);
    }
    if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {
      const r = this.getInheritIndentForLine(autoIndent, model2, range2.startLineNumber, false);
      if (!r) {
        return null;
      }
      let indentation = r.indentation;
      if (r.action !== IndentAction2.Indent) {
        indentation = indentConverter.unshiftIndent(indentation);
      }
      return indentation;
    }
    return null;
  }
  getIndentMetadata(model2, lineNumber) {
    const indentRulesSupport = this.getIndentRulesSupport(model2.getLanguageIdentifier().id);
    if (!indentRulesSupport) {
      return null;
    }
    if (lineNumber < 1 || lineNumber > model2.getLineCount()) {
      return null;
    }
    return indentRulesSupport.getIndentMetadata(model2.getLineContent(lineNumber));
  }
  getEnterAction(autoIndent, model2, range2) {
    const scopedLineTokens = this.getScopedLineTokens(model2, range2.startLineNumber, range2.startColumn);
    const richEditSupport = this._getRichEditSupport(scopedLineTokens.languageId);
    if (!richEditSupport) {
      return null;
    }
    const scopedLineText = scopedLineTokens.getLineContent();
    const beforeEnterText = scopedLineText.substr(0, range2.startColumn - 1 - scopedLineTokens.firstCharOffset);
    let afterEnterText;
    if (range2.isEmpty()) {
      afterEnterText = scopedLineText.substr(range2.startColumn - 1 - scopedLineTokens.firstCharOffset);
    } else {
      const endScopedLineTokens = this.getScopedLineTokens(model2, range2.endLineNumber, range2.endColumn);
      afterEnterText = endScopedLineTokens.getLineContent().substr(range2.endColumn - 1 - scopedLineTokens.firstCharOffset);
    }
    let oneLineAboveText = "";
    if (range2.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {
      const oneLineAboveScopedLineTokens = this.getScopedLineTokens(model2, range2.startLineNumber - 1);
      if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {
        oneLineAboveText = oneLineAboveScopedLineTokens.getLineContent();
      }
    }
    const enterResult = richEditSupport.onEnter(autoIndent, oneLineAboveText, beforeEnterText, afterEnterText);
    if (!enterResult) {
      return null;
    }
    const indentAction = enterResult.indentAction;
    let appendText = enterResult.appendText;
    const removeText = enterResult.removeText || 0;
    if (!appendText) {
      if (indentAction === IndentAction2.Indent || indentAction === IndentAction2.IndentOutdent) {
        appendText = "	";
      } else {
        appendText = "";
      }
    }
    let indentation = this.getIndentationAtPosition(model2, range2.startLineNumber, range2.startColumn);
    if (removeText) {
      indentation = indentation.substring(0, indentation.length - removeText);
    }
    return {
      indentAction,
      appendText,
      removeText,
      indentation
    };
  }
  getIndentationAtPosition(model2, lineNumber, column) {
    const lineText = model2.getLineContent(lineNumber);
    let indentation = getLeadingWhitespace(lineText);
    if (indentation.length > column - 1) {
      indentation = indentation.substring(0, column - 1);
    }
    return indentation;
  }
  getScopedLineTokens(model2, lineNumber, columnNumber) {
    model2.forceTokenization(lineNumber);
    const lineTokens = model2.getLineTokens(lineNumber);
    const column = typeof columnNumber === "undefined" ? model2.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1;
    return createScopedLineTokens(lineTokens, column);
  }
  getBracketsSupport(languageId) {
    const value = this._getRichEditSupport(languageId);
    if (!value) {
      return null;
    }
    return value.brackets || null;
  }
};
var LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();

// ../../node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js
var DiffChange = class {
  constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
    this.originalStart = originalStart;
    this.originalLength = originalLength;
    this.modifiedStart = modifiedStart;
    this.modifiedLength = modifiedLength;
  }
  getOriginalEnd() {
    return this.originalStart + this.originalLength;
  }
  getModifiedEnd() {
    return this.modifiedStart + this.modifiedLength;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/hash.js
function numberHash(val, initialHashVal) {
  return (initialHashVal << 5) - initialHashVal + val | 0;
}
function stringHash(s, hashVal) {
  hashVal = numberHash(149417, hashVal);
  for (let i = 0, length = s.length; i < length; i++) {
    hashVal = numberHash(s.charCodeAt(i), hashVal);
  }
  return hashVal;
}
function leftRotate(value, bits, totalBits = 32) {
  const delta = totalBits - bits;
  const mask = ~((1 << delta) - 1);
  return (value << bits | (mask & value) >>> delta) >>> 0;
}
function fill(dest, index = 0, count = dest.byteLength, value = 0) {
  for (let i = 0; i < count; i++) {
    dest[index + i] = value;
  }
}
function leftPad(value, length, char = "0") {
  while (value.length < length) {
    value = char + value;
  }
  return value;
}
function toHexString(value, bitsize = 32) {
  return leftPad((value >>> 0).toString(16), bitsize / 4);
}
var StringSHA1 = class {
  constructor() {
    this._h0 = 1732584193;
    this._h1 = 4023233417;
    this._h2 = 2562383102;
    this._h3 = 271733878;
    this._h4 = 3285377520;
    this._buff = new Uint8Array(64 + 3);
    this._buffDV = new DataView(this._buff.buffer);
    this._buffLen = 0;
    this._totalLen = 0;
    this._leftoverHighSurrogate = 0;
    this._finished = false;
  }
  update(str) {
    const strLen = str.length;
    if (strLen === 0) {
      return;
    }
    const buff = this._buff;
    let buffLen = this._buffLen;
    let leftoverHighSurrogate = this._leftoverHighSurrogate;
    let charCode;
    let offset;
    if (leftoverHighSurrogate !== 0) {
      charCode = leftoverHighSurrogate;
      offset = -1;
      leftoverHighSurrogate = 0;
    } else {
      charCode = str.charCodeAt(0);
      offset = 0;
    }
    while (true) {
      let codePoint = charCode;
      if (isHighSurrogate(charCode)) {
        if (offset + 1 < strLen) {
          const nextCharCode = str.charCodeAt(offset + 1);
          if (isLowSurrogate(nextCharCode)) {
            offset++;
            codePoint = computeCodePoint(charCode, nextCharCode);
          } else {
            codePoint = 65533;
          }
        } else {
          leftoverHighSurrogate = charCode;
          break;
        }
      } else if (isLowSurrogate(charCode)) {
        codePoint = 65533;
      }
      buffLen = this._push(buff, buffLen, codePoint);
      offset++;
      if (offset < strLen) {
        charCode = str.charCodeAt(offset);
      } else {
        break;
      }
    }
    this._buffLen = buffLen;
    this._leftoverHighSurrogate = leftoverHighSurrogate;
  }
  _push(buff, buffLen, codePoint) {
    if (codePoint < 128) {
      buff[buffLen++] = codePoint;
    } else if (codePoint < 2048) {
      buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
      buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
    } else if (codePoint < 65536) {
      buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
      buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
      buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
    } else {
      buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
      buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
      buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
      buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
    }
    if (buffLen >= 64) {
      this._step();
      buffLen -= 64;
      this._totalLen += 64;
      buff[0] = buff[64 + 0];
      buff[1] = buff[64 + 1];
      buff[2] = buff[64 + 2];
    }
    return buffLen;
  }
  digest() {
    if (!this._finished) {
      this._finished = true;
      if (this._leftoverHighSurrogate) {
        this._leftoverHighSurrogate = 0;
        this._buffLen = this._push(this._buff, this._buffLen, 65533);
      }
      this._totalLen += this._buffLen;
      this._wrapUp();
    }
    return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
  }
  _wrapUp() {
    this._buff[this._buffLen++] = 128;
    fill(this._buff, this._buffLen);
    if (this._buffLen > 56) {
      this._step();
      fill(this._buff);
    }
    const ml = 8 * this._totalLen;
    this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
    this._buffDV.setUint32(60, ml % 4294967296, false);
    this._step();
  }
  _step() {
    const bigBlock32 = StringSHA1._bigBlock32;
    const data = this._buffDV;
    for (let j = 0; j < 64; j += 4) {
      bigBlock32.setUint32(j, data.getUint32(j, false), false);
    }
    for (let j = 64; j < 320; j += 4) {
      bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);
    }
    let a = this._h0;
    let b = this._h1;
    let c = this._h2;
    let d = this._h3;
    let e = this._h4;
    let f, k;
    let temp;
    for (let j = 0; j < 80; j++) {
      if (j < 20) {
        f = b & c | ~b & d;
        k = 1518500249;
      } else if (j < 40) {
        f = b ^ c ^ d;
        k = 1859775393;
      } else if (j < 60) {
        f = b & c | b & d | c & d;
        k = 2400959708;
      } else {
        f = b ^ c ^ d;
        k = 3395469782;
      }
      temp = leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false) & 4294967295;
      e = d;
      d = c;
      c = leftRotate(b, 30);
      b = a;
      a = temp;
    }
    this._h0 = this._h0 + a & 4294967295;
    this._h1 = this._h1 + b & 4294967295;
    this._h2 = this._h2 + c & 4294967295;
    this._h3 = this._h3 + d & 4294967295;
    this._h4 = this._h4 + e & 4294967295;
  }
};
StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));

// ../../node_modules/monaco-editor/esm/vs/base/common/diff/diff.js
var StringDiffSequence = class {
  constructor(source) {
    this.source = source;
  }
  getElements() {
    const source = this.source;
    const characters = new Int32Array(source.length);
    for (let i = 0, len = source.length; i < len; i++) {
      characters[i] = source.charCodeAt(i);
    }
    return characters;
  }
};
function stringDiff(original, modified, pretty) {
  return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
}
var Debug = class {
  static Assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
};
var MyArray = class {
  static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
    }
  }
  static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
    }
  }
};
var DiffChangeHelper = class {
  constructor() {
    this.m_changes = [];
    this.m_originalStart = 1073741824;
    this.m_modifiedStart = 1073741824;
    this.m_originalCount = 0;
    this.m_modifiedCount = 0;
  }
  MarkNextChange() {
    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
      this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
    }
    this.m_originalCount = 0;
    this.m_modifiedCount = 0;
    this.m_originalStart = 1073741824;
    this.m_modifiedStart = 1073741824;
  }
  AddOriginalElement(originalIndex, modifiedIndex) {
    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
    this.m_originalCount++;
  }
  AddModifiedElement(originalIndex, modifiedIndex) {
    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
    this.m_modifiedCount++;
  }
  getChanges() {
    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
      this.MarkNextChange();
    }
    return this.m_changes;
  }
  getReverseChanges() {
    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
      this.MarkNextChange();
    }
    this.m_changes.reverse();
    return this.m_changes;
  }
};
var LcsDiff = class {
  constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
    this.ContinueProcessingPredicate = continueProcessingPredicate;
    const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);
    const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);
    this._hasStrings = originalHasStrings && modifiedHasStrings;
    this._originalStringElements = originalStringElements;
    this._originalElementsOrHash = originalElementsOrHash;
    this._modifiedStringElements = modifiedStringElements;
    this._modifiedElementsOrHash = modifiedElementsOrHash;
    this.m_forwardHistory = [];
    this.m_reverseHistory = [];
  }
  static _isStringArray(arr) {
    return arr.length > 0 && typeof arr[0] === "string";
  }
  static _getElements(sequence) {
    const elements = sequence.getElements();
    if (LcsDiff._isStringArray(elements)) {
      const hashes = new Int32Array(elements.length);
      for (let i = 0, len = elements.length; i < len; i++) {
        hashes[i] = stringHash(elements[i], 0);
      }
      return [elements, hashes, true];
    }
    if (elements instanceof Int32Array) {
      return [[], elements, false];
    }
    return [[], new Int32Array(elements), false];
  }
  ElementsAreEqual(originalIndex, newIndex) {
    if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
      return false;
    }
    return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
  }
  OriginalElementsAreEqual(index1, index2) {
    if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
      return false;
    }
    return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;
  }
  ModifiedElementsAreEqual(index1, index2) {
    if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
      return false;
    }
    return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;
  }
  ComputeDiff(pretty) {
    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
  }
  _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
    const quitEarlyArr = [false];
    let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
    if (pretty) {
      changes = this.PrettifyChanges(changes);
    }
    return {
      quitEarly: quitEarlyArr[0],
      changes
    };
  }
  ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
    quitEarlyArr[0] = false;
    while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
      originalStart++;
      modifiedStart++;
    }
    while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
      originalEnd--;
      modifiedEnd--;
    }
    if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
      let changes;
      if (modifiedStart <= modifiedEnd) {
        Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
        changes = [
          new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
        ];
      } else if (originalStart <= originalEnd) {
        Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
        changes = [
          new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
        ];
      } else {
        Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
        Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
        changes = [];
      }
      return changes;
    }
    const midOriginalArr = [0];
    const midModifiedArr = [0];
    const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
    const midOriginal = midOriginalArr[0];
    const midModified = midModifiedArr[0];
    if (result !== null) {
      return result;
    } else if (!quitEarlyArr[0]) {
      const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
      let rightChanges = [];
      if (!quitEarlyArr[0]) {
        rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
      } else {
        rightChanges = [
          new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
        ];
      }
      return this.ConcatenateChanges(leftChanges, rightChanges);
    }
    return [
      new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
    ];
  }
  WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
    let forwardChanges = null;
    let reverseChanges = null;
    let changeHelper = new DiffChangeHelper();
    let diagonalMin = diagonalForwardStart;
    let diagonalMax = diagonalForwardEnd;
    let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
    let lastOriginalIndex = -1073741824;
    let historyIndex = this.m_forwardHistory.length - 1;
    do {
      const diagonal = diagonalRelative + diagonalForwardBase;
      if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
        originalIndex = forwardPoints[diagonal + 1];
        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
        if (originalIndex < lastOriginalIndex) {
          changeHelper.MarkNextChange();
        }
        lastOriginalIndex = originalIndex;
        changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
        diagonalRelative = diagonal + 1 - diagonalForwardBase;
      } else {
        originalIndex = forwardPoints[diagonal - 1] + 1;
        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
        if (originalIndex < lastOriginalIndex) {
          changeHelper.MarkNextChange();
        }
        lastOriginalIndex = originalIndex - 1;
        changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
        diagonalRelative = diagonal - 1 - diagonalForwardBase;
      }
      if (historyIndex >= 0) {
        forwardPoints = this.m_forwardHistory[historyIndex];
        diagonalForwardBase = forwardPoints[0];
        diagonalMin = 1;
        diagonalMax = forwardPoints.length - 1;
      }
    } while (--historyIndex >= -1);
    forwardChanges = changeHelper.getReverseChanges();
    if (quitEarlyArr[0]) {
      let originalStartPoint = midOriginalArr[0] + 1;
      let modifiedStartPoint = midModifiedArr[0] + 1;
      if (forwardChanges !== null && forwardChanges.length > 0) {
        const lastForwardChange = forwardChanges[forwardChanges.length - 1];
        originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
        modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
      }
      reverseChanges = [
        new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
      ];
    } else {
      changeHelper = new DiffChangeHelper();
      diagonalMin = diagonalReverseStart;
      diagonalMax = diagonalReverseEnd;
      diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
      lastOriginalIndex = 1073741824;
      historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
      do {
        const diagonal = diagonalRelative + diagonalReverseBase;
        if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
          originalIndex = reversePoints[diagonal + 1] - 1;
          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
          if (originalIndex > lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex + 1;
          changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
          diagonalRelative = diagonal + 1 - diagonalReverseBase;
        } else {
          originalIndex = reversePoints[diagonal - 1];
          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
          if (originalIndex > lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex;
          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
          diagonalRelative = diagonal - 1 - diagonalReverseBase;
        }
        if (historyIndex >= 0) {
          reversePoints = this.m_reverseHistory[historyIndex];
          diagonalReverseBase = reversePoints[0];
          diagonalMin = 1;
          diagonalMax = reversePoints.length - 1;
        }
      } while (--historyIndex >= -1);
      reverseChanges = changeHelper.getChanges();
    }
    return this.ConcatenateChanges(forwardChanges, reverseChanges);
  }
  ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
    let originalIndex = 0, modifiedIndex = 0;
    let diagonalForwardStart = 0, diagonalForwardEnd = 0;
    let diagonalReverseStart = 0, diagonalReverseEnd = 0;
    originalStart--;
    modifiedStart--;
    midOriginalArr[0] = 0;
    midModifiedArr[0] = 0;
    this.m_forwardHistory = [];
    this.m_reverseHistory = [];
    const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
    const numDiagonals = maxDifferences + 1;
    const forwardPoints = new Int32Array(numDiagonals);
    const reversePoints = new Int32Array(numDiagonals);
    const diagonalForwardBase = modifiedEnd - modifiedStart;
    const diagonalReverseBase = originalEnd - originalStart;
    const diagonalForwardOffset = originalStart - modifiedStart;
    const diagonalReverseOffset = originalEnd - modifiedEnd;
    const delta = diagonalReverseBase - diagonalForwardBase;
    const deltaIsEven = delta % 2 === 0;
    forwardPoints[diagonalForwardBase] = originalStart;
    reversePoints[diagonalReverseBase] = originalEnd;
    quitEarlyArr[0] = false;
    for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
      let furthestOriginalIndex = 0;
      let furthestModifiedIndex = 0;
      diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
      diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
      for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
        if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
          originalIndex = forwardPoints[diagonal + 1];
        } else {
          originalIndex = forwardPoints[diagonal - 1] + 1;
        }
        modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
        const tempOriginalIndex = originalIndex;
        while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
          originalIndex++;
          modifiedIndex++;
        }
        forwardPoints[diagonal] = originalIndex;
        if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
          furthestOriginalIndex = originalIndex;
          furthestModifiedIndex = modifiedIndex;
        }
        if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
          if (originalIndex >= reversePoints[diagonal]) {
            midOriginalArr[0] = originalIndex;
            midModifiedArr[0] = modifiedIndex;
            if (tempOriginalIndex <= reversePoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
            } else {
              return null;
            }
          }
        }
      }
      const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
        quitEarlyArr[0] = true;
        midOriginalArr[0] = furthestOriginalIndex;
        midModifiedArr[0] = furthestModifiedIndex;
        if (matchLengthOfLongest > 0 && 1447 > 0 && numDifferences <= 1447 + 1) {
          return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
        } else {
          originalStart++;
          modifiedStart++;
          return [
            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
          ];
        }
      }
      diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
      diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
      for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
        if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
          originalIndex = reversePoints[diagonal + 1] - 1;
        } else {
          originalIndex = reversePoints[diagonal - 1];
        }
        modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
        const tempOriginalIndex = originalIndex;
        while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
          originalIndex--;
          modifiedIndex--;
        }
        reversePoints[diagonal] = originalIndex;
        if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
          if (originalIndex <= forwardPoints[diagonal]) {
            midOriginalArr[0] = originalIndex;
            midModifiedArr[0] = modifiedIndex;
            if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
            } else {
              return null;
            }
          }
        }
      }
      if (numDifferences <= 1447) {
        let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
        temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
        MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
        this.m_forwardHistory.push(temp);
        temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
        temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
        MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
        this.m_reverseHistory.push(temp);
      }
    }
    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
  }
  PrettifyChanges(changes) {
    for (let i = 0; i < changes.length; i++) {
      const change = changes[i];
      const originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
      const modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
      const checkOriginal = change.originalLength > 0;
      const checkModified = change.modifiedLength > 0;
      while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
        change.originalStart++;
        change.modifiedStart++;
      }
      let mergedChangeArr = [null];
      if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
        changes[i] = mergedChangeArr[0];
        changes.splice(i + 1, 1);
        i--;
        continue;
      }
    }
    for (let i = changes.length - 1; i >= 0; i--) {
      const change = changes[i];
      let originalStop = 0;
      let modifiedStop = 0;
      if (i > 0) {
        const prevChange = changes[i - 1];
        if (prevChange.originalLength > 0) {
          originalStop = prevChange.originalStart + prevChange.originalLength;
        }
        if (prevChange.modifiedLength > 0) {
          modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
        }
      }
      const checkOriginal = change.originalLength > 0;
      const checkModified = change.modifiedLength > 0;
      let bestDelta = 0;
      let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
      for (let delta = 1; ; delta++) {
        const originalStart = change.originalStart - delta;
        const modifiedStart = change.modifiedStart - delta;
        if (originalStart < originalStop || modifiedStart < modifiedStop) {
          break;
        }
        if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
          break;
        }
        if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
          break;
        }
        const score2 = this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
        if (score2 > bestScore) {
          bestScore = score2;
          bestDelta = delta;
        }
      }
      change.originalStart -= bestDelta;
      change.modifiedStart -= bestDelta;
    }
    return changes;
  }
  _OriginalIsBoundary(index) {
    if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
      return true;
    }
    return this._hasStrings && /^\s*$/.test(this._originalStringElements[index]);
  }
  _OriginalRegionIsBoundary(originalStart, originalLength) {
    if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
      return true;
    }
    if (originalLength > 0) {
      const originalEnd = originalStart + originalLength;
      if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
        return true;
      }
    }
    return false;
  }
  _ModifiedIsBoundary(index) {
    if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
      return true;
    }
    return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]);
  }
  _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
    if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
      return true;
    }
    if (modifiedLength > 0) {
      const modifiedEnd = modifiedStart + modifiedLength;
      if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
        return true;
      }
    }
    return false;
  }
  _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
    const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
    const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
    return originalScore + modifiedScore;
  }
  ConcatenateChanges(left, right) {
    let mergedChangeArr = [];
    if (left.length === 0 || right.length === 0) {
      return right.length > 0 ? right : left;
    } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
      const result = new Array(left.length + right.length - 1);
      MyArray.Copy(left, 0, result, 0, left.length - 1);
      result[left.length - 1] = mergedChangeArr[0];
      MyArray.Copy(right, 1, result, left.length, right.length - 1);
      return result;
    } else {
      const result = new Array(left.length + right.length);
      MyArray.Copy(left, 0, result, 0, left.length);
      MyArray.Copy(right, 0, result, left.length, right.length);
      return result;
    }
  }
  ChangesOverlap(left, right, mergedChangeArr) {
    Debug.Assert(left.originalStart <= right.originalStart, "Left change is not less than or equal to right change");
    Debug.Assert(left.modifiedStart <= right.modifiedStart, "Left change is not less than or equal to right change");
    if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
      const originalStart = left.originalStart;
      let originalLength = left.originalLength;
      const modifiedStart = left.modifiedStart;
      let modifiedLength = left.modifiedLength;
      if (left.originalStart + left.originalLength >= right.originalStart) {
        originalLength = right.originalStart + right.originalLength - left.originalStart;
      }
      if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
        modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
      }
      mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
      return true;
    } else {
      mergedChangeArr[0] = null;
      return false;
    }
  }
  ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
    if (diagonal >= 0 && diagonal < numDiagonals) {
      return diagonal;
    }
    const diagonalsBelow = diagonalBaseIndex;
    const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
    const diffEven = numDifferences % 2 === 0;
    if (diagonal < 0) {
      const lowerBoundEven = diagonalsBelow % 2 === 0;
      return diffEven === lowerBoundEven ? 0 : 1;
    } else {
      const upperBoundEven = diagonalsAbove % 2 === 0;
      return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js
var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
  const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
  return diffAlgo.ComputeDiff(pretty);
}
var LineSequence = class {
  constructor(lines) {
    const startColumns = [];
    const endColumns = [];
    for (let i = 0, length = lines.length; i < length; i++) {
      startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
      endColumns[i] = getLastNonBlankColumn(lines[i], 1);
    }
    this.lines = lines;
    this._startColumns = startColumns;
    this._endColumns = endColumns;
  }
  getElements() {
    const elements = [];
    for (let i = 0, len = this.lines.length; i < len; i++) {
      elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
    }
    return elements;
  }
  getStartLineNumber(i) {
    return i + 1;
  }
  getEndLineNumber(i) {
    return i + 1;
  }
  createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
    const charCodes = [];
    const lineNumbers = [];
    const columns = [];
    let len = 0;
    for (let index = startIndex; index <= endIndex; index++) {
      const lineContent = this.lines[index];
      const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;
      const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;
      for (let col = startColumn; col < endColumn; col++) {
        charCodes[len] = lineContent.charCodeAt(col - 1);
        lineNumbers[len] = index + 1;
        columns[len] = col;
        len++;
      }
    }
    return new CharSequence(charCodes, lineNumbers, columns);
  }
};
var CharSequence = class {
  constructor(charCodes, lineNumbers, columns) {
    this._charCodes = charCodes;
    this._lineNumbers = lineNumbers;
    this._columns = columns;
  }
  getElements() {
    return this._charCodes;
  }
  getStartLineNumber(i) {
    return this._lineNumbers[i];
  }
  getStartColumn(i) {
    return this._columns[i];
  }
  getEndLineNumber(i) {
    return this._lineNumbers[i];
  }
  getEndColumn(i) {
    return this._columns[i] + 1;
  }
};
var CharChange = class {
  constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
    this.originalStartLineNumber = originalStartLineNumber;
    this.originalStartColumn = originalStartColumn;
    this.originalEndLineNumber = originalEndLineNumber;
    this.originalEndColumn = originalEndColumn;
    this.modifiedStartLineNumber = modifiedStartLineNumber;
    this.modifiedStartColumn = modifiedStartColumn;
    this.modifiedEndLineNumber = modifiedEndLineNumber;
    this.modifiedEndColumn = modifiedEndColumn;
  }
  static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
    let originalStartLineNumber;
    let originalStartColumn;
    let originalEndLineNumber;
    let originalEndColumn;
    let modifiedStartLineNumber;
    let modifiedStartColumn;
    let modifiedEndLineNumber;
    let modifiedEndColumn;
    if (diffChange.originalLength === 0) {
      originalStartLineNumber = 0;
      originalStartColumn = 0;
      originalEndLineNumber = 0;
      originalEndColumn = 0;
    } else {
      originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
      originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
      originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
      originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
    }
    if (diffChange.modifiedLength === 0) {
      modifiedStartLineNumber = 0;
      modifiedStartColumn = 0;
      modifiedEndLineNumber = 0;
      modifiedEndColumn = 0;
    } else {
      modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
      modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
      modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
    }
    return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
  }
};
function postProcessCharChanges(rawChanges) {
  if (rawChanges.length <= 1) {
    return rawChanges;
  }
  const result = [rawChanges[0]];
  let prevChange = result[0];
  for (let i = 1, len = rawChanges.length; i < len; i++) {
    const currChange = rawChanges[i];
    const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
    const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
    const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
    if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
      prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
      prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
    } else {
      result.push(currChange);
      prevChange = currChange;
    }
  }
  return result;
}
var LineChange = class {
  constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
    this.originalStartLineNumber = originalStartLineNumber;
    this.originalEndLineNumber = originalEndLineNumber;
    this.modifiedStartLineNumber = modifiedStartLineNumber;
    this.modifiedEndLineNumber = modifiedEndLineNumber;
    this.charChanges = charChanges;
  }
  static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
    let originalStartLineNumber;
    let originalEndLineNumber;
    let modifiedStartLineNumber;
    let modifiedEndLineNumber;
    let charChanges = void 0;
    if (diffChange.originalLength === 0) {
      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
      originalEndLineNumber = 0;
    } else {
      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
      originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
    }
    if (diffChange.modifiedLength === 0) {
      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
      modifiedEndLineNumber = 0;
    } else {
      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
      modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
    }
    if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
      const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
      const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
      let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
      if (shouldPostProcessCharChanges) {
        rawChanges = postProcessCharChanges(rawChanges);
      }
      charChanges = [];
      for (let i = 0, length = rawChanges.length; i < length; i++) {
        charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
      }
    }
    return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
  }
};
var DiffComputer = class {
  constructor(originalLines, modifiedLines, opts) {
    this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
    this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
    this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
    this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
    this.originalLines = originalLines;
    this.modifiedLines = modifiedLines;
    this.original = new LineSequence(originalLines);
    this.modified = new LineSequence(modifiedLines);
    this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
    this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
  }
  computeDiff() {
    if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
      return {
        quitEarly: false,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: 1,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: this.modified.lines.length,
          charChanges: [{
            modifiedEndColumn: 0,
            modifiedEndLineNumber: 0,
            modifiedStartColumn: 0,
            modifiedStartLineNumber: 0,
            originalEndColumn: 0,
            originalEndLineNumber: 0,
            originalStartColumn: 0,
            originalStartLineNumber: 0
          }]
        }]
      };
    }
    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
      return {
        quitEarly: false,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: this.original.lines.length,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: 1,
          charChanges: [{
            modifiedEndColumn: 0,
            modifiedEndLineNumber: 0,
            modifiedStartColumn: 0,
            modifiedStartLineNumber: 0,
            originalEndColumn: 0,
            originalEndLineNumber: 0,
            originalStartColumn: 0,
            originalStartLineNumber: 0
          }]
        }]
      };
    }
    const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
    const rawChanges = diffResult.changes;
    const quitEarly = diffResult.quitEarly;
    if (this.shouldIgnoreTrimWhitespace) {
      const lineChanges = [];
      for (let i = 0, length = rawChanges.length; i < length; i++) {
        lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
      }
      return {
        quitEarly,
        changes: lineChanges
      };
    }
    const result = [];
    let originalLineIndex = 0;
    let modifiedLineIndex = 0;
    for (let i = -1, len = rawChanges.length; i < len; i++) {
      const nextChange = i + 1 < len ? rawChanges[i + 1] : null;
      const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
      const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
      while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
        const originalLine = this.originalLines[originalLineIndex];
        const modifiedLine = this.modifiedLines[modifiedLineIndex];
        if (originalLine !== modifiedLine) {
          {
            let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
            let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
            while (originalStartColumn > 1 && modifiedStartColumn > 1) {
              const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
              const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
              if (originalChar !== modifiedChar) {
                break;
              }
              originalStartColumn--;
              modifiedStartColumn--;
            }
            if (originalStartColumn > 1 || modifiedStartColumn > 1) {
              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
            }
          }
          {
            let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
            let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
            const originalMaxColumn = originalLine.length + 1;
            const modifiedMaxColumn = modifiedLine.length + 1;
            while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
              const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
              const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
              if (originalChar !== modifiedChar) {
                break;
              }
              originalEndColumn++;
              modifiedEndColumn++;
            }
            if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
            }
          }
        }
        originalLineIndex++;
        modifiedLineIndex++;
      }
      if (nextChange) {
        result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
        originalLineIndex += nextChange.originalLength;
        modifiedLineIndex += nextChange.modifiedLength;
      }
    }
    return {
      quitEarly,
      changes: result
    };
  }
  _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
    if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
      return;
    }
    let charChanges = void 0;
    if (this.shouldComputeCharChanges) {
      charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
    }
    result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
  }
  _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
    const len = result.length;
    if (len === 0) {
      return false;
    }
    const prevChange = result[len - 1];
    if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
      return false;
    }
    if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
      prevChange.originalEndLineNumber = originalLineNumber;
      prevChange.modifiedEndLineNumber = modifiedLineNumber;
      if (this.shouldComputeCharChanges && prevChange.charChanges) {
        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
      }
      return true;
    }
    return false;
  }
};
function getFirstNonBlankColumn(txt, defaultValue) {
  const r = firstNonWhitespaceIndex(txt);
  if (r === -1) {
    return defaultValue;
  }
  return r + 1;
}
function getLastNonBlankColumn(txt, defaultValue) {
  const r = lastNonWhitespaceIndex(txt);
  if (r === -1) {
    return defaultValue;
  }
  return r + 2;
}
function createContinueProcessingPredicate(maximumRuntime) {
  if (maximumRuntime === 0) {
    return () => true;
  }
  const startTime = Date.now();
  return () => {
    return Date.now() - startTime < maximumRuntime;
  };
}

// ../../node_modules/monaco-editor/esm/vs/base/common/uint.js
function toUint8(v) {
  if (v < 0) {
    return 0;
  }
  if (v > 255) {
    return 255;
  }
  return v | 0;
}
function toUint32(v) {
  if (v < 0) {
    return 0;
  }
  if (v > 4294967295) {
    return 4294967295;
  }
  return v | 0;
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/prefixSumComputer.js
var PrefixSumIndexOfResult = class {
  constructor(index, remainder) {
    this.index = index;
    this.remainder = remainder;
  }
};
var PrefixSumComputer = class {
  constructor(values) {
    this.values = values;
    this.prefixSum = new Uint32Array(values.length);
    this.prefixSumValidIndex = new Int32Array(1);
    this.prefixSumValidIndex[0] = -1;
  }
  insertValues(insertIndex, insertValues) {
    insertIndex = toUint32(insertIndex);
    const oldValues = this.values;
    const oldPrefixSum = this.prefixSum;
    const insertValuesLen = insertValues.length;
    if (insertValuesLen === 0) {
      return false;
    }
    this.values = new Uint32Array(oldValues.length + insertValuesLen);
    this.values.set(oldValues.subarray(0, insertIndex), 0);
    this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
    this.values.set(insertValues, insertIndex);
    if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = insertIndex - 1;
    }
    this.prefixSum = new Uint32Array(this.values.length);
    if (this.prefixSumValidIndex[0] >= 0) {
      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
    }
    return true;
  }
  changeValue(index, value) {
    index = toUint32(index);
    value = toUint32(value);
    if (this.values[index] === value) {
      return false;
    }
    this.values[index] = value;
    if (index - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = index - 1;
    }
    return true;
  }
  removeValues(startIndex, cnt) {
    startIndex = toUint32(startIndex);
    cnt = toUint32(cnt);
    const oldValues = this.values;
    const oldPrefixSum = this.prefixSum;
    if (startIndex >= oldValues.length) {
      return false;
    }
    let maxCnt = oldValues.length - startIndex;
    if (cnt >= maxCnt) {
      cnt = maxCnt;
    }
    if (cnt === 0) {
      return false;
    }
    this.values = new Uint32Array(oldValues.length - cnt);
    this.values.set(oldValues.subarray(0, startIndex), 0);
    this.values.set(oldValues.subarray(startIndex + cnt), startIndex);
    this.prefixSum = new Uint32Array(this.values.length);
    if (startIndex - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = startIndex - 1;
    }
    if (this.prefixSumValidIndex[0] >= 0) {
      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
    }
    return true;
  }
  getTotalValue() {
    if (this.values.length === 0) {
      return 0;
    }
    return this._getAccumulatedValue(this.values.length - 1);
  }
  getAccumulatedValue(index) {
    if (index < 0) {
      return 0;
    }
    index = toUint32(index);
    return this._getAccumulatedValue(index);
  }
  _getAccumulatedValue(index) {
    if (index <= this.prefixSumValidIndex[0]) {
      return this.prefixSum[index];
    }
    let startIndex = this.prefixSumValidIndex[0] + 1;
    if (startIndex === 0) {
      this.prefixSum[0] = this.values[0];
      startIndex++;
    }
    if (index >= this.values.length) {
      index = this.values.length - 1;
    }
    for (let i = startIndex; i <= index; i++) {
      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
    }
    this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
    return this.prefixSum[index];
  }
  getIndexOf(accumulatedValue) {
    accumulatedValue = Math.floor(accumulatedValue);
    this.getTotalValue();
    let low = 0;
    let high = this.values.length - 1;
    let mid = 0;
    let midStop = 0;
    let midStart = 0;
    while (low <= high) {
      mid = low + (high - low) / 2 | 0;
      midStop = this.prefixSum[mid];
      midStart = midStop - this.values[mid];
      if (accumulatedValue < midStart) {
        high = mid - 1;
      } else if (accumulatedValue >= midStop) {
        low = mid + 1;
      } else {
        break;
      }
    }
    return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
var MirrorTextModel = class {
  constructor(uri, lines, eol, versionId) {
    this._uri = uri;
    this._lines = lines;
    this._eol = eol;
    this._versionId = versionId;
    this._lineStarts = null;
    this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  getText() {
    if (this._cachedTextValue === null) {
      this._cachedTextValue = this._lines.join(this._eol);
    }
    return this._cachedTextValue;
  }
  onEvents(e) {
    if (e.eol && e.eol !== this._eol) {
      this._eol = e.eol;
      this._lineStarts = null;
    }
    const changes = e.changes;
    for (const change of changes) {
      this._acceptDeleteRange(change.range);
      this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
    }
    this._versionId = e.versionId;
    this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const eolLength = this._eol.length;
      const linesLength = this._lines.length;
      const lineStartValues = new Uint32Array(linesLength);
      for (let i = 0; i < linesLength; i++) {
        lineStartValues[i] = this._lines[i].length + eolLength;
      }
      this._lineStarts = new PrefixSumComputer(lineStartValues);
    }
  }
  _setLineText(lineIndex, newValue) {
    this._lines[lineIndex] = newValue;
    if (this._lineStarts) {
      this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
    }
  }
  _acceptDeleteRange(range2) {
    if (range2.startLineNumber === range2.endLineNumber) {
      if (range2.startColumn === range2.endColumn) {
        return;
      }
      this._setLineText(range2.startLineNumber - 1, this._lines[range2.startLineNumber - 1].substring(0, range2.startColumn - 1) + this._lines[range2.startLineNumber - 1].substring(range2.endColumn - 1));
      return;
    }
    this._setLineText(range2.startLineNumber - 1, this._lines[range2.startLineNumber - 1].substring(0, range2.startColumn - 1) + this._lines[range2.endLineNumber - 1].substring(range2.endColumn - 1));
    this._lines.splice(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
    if (this._lineStarts) {
      this._lineStarts.removeValues(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
    }
  }
  _acceptInsertText(position, insertText) {
    if (insertText.length === 0) {
      return;
    }
    let insertLines = insertText.split(/\r\n|\r|\n/);
    if (insertLines.length === 1) {
      this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));
      return;
    }
    insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
    this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]);
    let newLengths = new Uint32Array(insertLines.length - 1);
    for (let i = 1; i < insertLines.length; i++) {
      this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
      newLengths[i - 1] = insertLines[i].length + this._eol.length;
    }
    if (this._lineStarts) {
      this._lineStarts.insertValues(position.lineNumber, newLengths);
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js
var CharacterClassifier = class {
  constructor(_defaultValue) {
    let defaultValue = toUint8(_defaultValue);
    this._defaultValue = defaultValue;
    this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);
    this._map = new Map();
  }
  static _createAsciiMap(defaultValue) {
    let asciiMap = new Uint8Array(256);
    for (let i = 0; i < 256; i++) {
      asciiMap[i] = defaultValue;
    }
    return asciiMap;
  }
  set(charCode, _value) {
    let value = toUint8(_value);
    if (charCode >= 0 && charCode < 256) {
      this._asciiMap[charCode] = value;
    } else {
      this._map.set(charCode, value);
    }
  }
  get(charCode) {
    if (charCode >= 0 && charCode < 256) {
      return this._asciiMap[charCode];
    } else {
      return this._map.get(charCode) || this._defaultValue;
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/linkComputer.js
var Uint8Matrix = class {
  constructor(rows, cols, defaultValue) {
    const data = new Uint8Array(rows * cols);
    for (let i = 0, len = rows * cols; i < len; i++) {
      data[i] = defaultValue;
    }
    this._data = data;
    this.rows = rows;
    this.cols = cols;
  }
  get(row, col) {
    return this._data[row * this.cols + col];
  }
  set(row, col, value) {
    this._data[row * this.cols + col] = value;
  }
};
var StateMachine = class {
  constructor(edges) {
    let maxCharCode = 0;
    let maxState = 0;
    for (let i = 0, len = edges.length; i < len; i++) {
      let [from, chCode, to] = edges[i];
      if (chCode > maxCharCode) {
        maxCharCode = chCode;
      }
      if (from > maxState) {
        maxState = from;
      }
      if (to > maxState) {
        maxState = to;
      }
    }
    maxCharCode++;
    maxState++;
    let states = new Uint8Matrix(maxState, maxCharCode, 0);
    for (let i = 0, len = edges.length; i < len; i++) {
      let [from, chCode, to] = edges[i];
      states.set(from, chCode, to);
    }
    this._states = states;
    this._maxCharCode = maxCharCode;
  }
  nextState(currentState, chCode) {
    if (chCode < 0 || chCode >= this._maxCharCode) {
      return 0;
    }
    return this._states.get(currentState, chCode);
  }
};
var _stateMachine = null;
function getStateMachine() {
  if (_stateMachine === null) {
    _stateMachine = new StateMachine([
      [1, 104, 2],
      [1, 72, 2],
      [1, 102, 6],
      [1, 70, 6],
      [2, 116, 3],
      [2, 84, 3],
      [3, 116, 4],
      [3, 84, 4],
      [4, 112, 5],
      [4, 80, 5],
      [5, 115, 9],
      [5, 83, 9],
      [5, 58, 10],
      [6, 105, 7],
      [6, 73, 7],
      [7, 108, 8],
      [7, 76, 8],
      [8, 101, 9],
      [8, 69, 9],
      [9, 58, 10],
      [10, 47, 11],
      [11, 47, 12]
    ]);
  }
  return _stateMachine;
}
var _classifier = null;
function getClassifier() {
  if (_classifier === null) {
    _classifier = new CharacterClassifier(0);
    const FORCE_TERMINATION_CHARACTERS = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u201C\u3008\u300A\u300C\u300E\u3010\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u3011\u300F\u300D\u300B\u3009\u201D\u2019\uFF40\uFF5E\u2026`;
    for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
      _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1);
    }
    const CANNOT_END_WITH_CHARACTERS = ".,;";
    for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
      _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2);
    }
  }
  return _classifier;
}
var LinkComputer = class {
  static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
    let lastIncludedCharIndex = linkEndIndex - 1;
    do {
      const chCode = line.charCodeAt(lastIncludedCharIndex);
      const chClass = classifier.get(chCode);
      if (chClass !== 2) {
        break;
      }
      lastIncludedCharIndex--;
    } while (lastIncludedCharIndex > linkBeginIndex);
    if (linkBeginIndex > 0) {
      const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
      const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
      if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
        lastIncludedCharIndex--;
      }
    }
    return {
      range: {
        startLineNumber: lineNumber,
        startColumn: linkBeginIndex + 1,
        endLineNumber: lineNumber,
        endColumn: lastIncludedCharIndex + 2
      },
      url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
    };
  }
  static computeLinks(model2, stateMachine = getStateMachine()) {
    const classifier = getClassifier();
    let result = [];
    for (let i = 1, lineCount = model2.getLineCount(); i <= lineCount; i++) {
      const line = model2.getLineContent(i);
      const len = line.length;
      let j = 0;
      let linkBeginIndex = 0;
      let linkBeginChCode = 0;
      let state = 1;
      let hasOpenParens = false;
      let hasOpenSquareBracket = false;
      let inSquareBrackets = false;
      let hasOpenCurlyBracket = false;
      while (j < len) {
        let resetStateMachine = false;
        const chCode = line.charCodeAt(j);
        if (state === 13) {
          let chClass;
          switch (chCode) {
            case 40:
              hasOpenParens = true;
              chClass = 0;
              break;
            case 41:
              chClass = hasOpenParens ? 0 : 1;
              break;
            case 91:
              inSquareBrackets = true;
              hasOpenSquareBracket = true;
              chClass = 0;
              break;
            case 93:
              inSquareBrackets = false;
              chClass = hasOpenSquareBracket ? 0 : 1;
              break;
            case 123:
              hasOpenCurlyBracket = true;
              chClass = 0;
              break;
            case 125:
              chClass = hasOpenCurlyBracket ? 0 : 1;
              break;
            case 39:
              chClass = linkBeginChCode === 34 || linkBeginChCode === 96 ? 0 : 1;
              break;
            case 34:
              chClass = linkBeginChCode === 39 || linkBeginChCode === 96 ? 0 : 1;
              break;
            case 96:
              chClass = linkBeginChCode === 39 || linkBeginChCode === 34 ? 0 : 1;
              break;
            case 42:
              chClass = linkBeginChCode === 42 ? 1 : 0;
              break;
            case 124:
              chClass = linkBeginChCode === 124 ? 1 : 0;
              break;
            case 32:
              chClass = inSquareBrackets ? 0 : 1;
              break;
            default:
              chClass = classifier.get(chCode);
          }
          if (chClass === 1) {
            result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
            resetStateMachine = true;
          }
        } else if (state === 12) {
          let chClass;
          if (chCode === 91) {
            hasOpenSquareBracket = true;
            chClass = 0;
          } else {
            chClass = classifier.get(chCode);
          }
          if (chClass === 1) {
            resetStateMachine = true;
          } else {
            state = 13;
          }
        } else {
          state = stateMachine.nextState(state, chCode);
          if (state === 0) {
            resetStateMachine = true;
          }
        }
        if (resetStateMachine) {
          state = 1;
          hasOpenParens = false;
          hasOpenSquareBracket = false;
          hasOpenCurlyBracket = false;
          linkBeginIndex = j + 1;
          linkBeginChCode = chCode;
        }
        j++;
      }
      if (state === 13) {
        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
      }
    }
    return result;
  }
};
function computeLinks(model2) {
  if (!model2 || typeof model2.getLineCount !== "function" || typeof model2.getLineContent !== "function") {
    return [];
  }
  return LinkComputer.computeLinks(model2);
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports/inplaceReplaceSupport.js
var BasicInplaceReplace = class {
  constructor() {
    this._defaultValueSet = [
      ["true", "false"],
      ["True", "False"],
      ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
      ["public", "protected", "private"]
    ];
  }
  navigateValueSet(range1, text1, range2, text2, up) {
    if (range1 && text1) {
      let result = this.doNavigateValueSet(text1, up);
      if (result) {
        return {
          range: range1,
          value: result
        };
      }
    }
    if (range2 && text2) {
      let result = this.doNavigateValueSet(text2, up);
      if (result) {
        return {
          range: range2,
          value: result
        };
      }
    }
    return null;
  }
  doNavigateValueSet(text, up) {
    let numberResult = this.numberReplace(text, up);
    if (numberResult !== null) {
      return numberResult;
    }
    return this.textReplace(text, up);
  }
  numberReplace(value, up) {
    let precision = Math.pow(10, value.length - (value.lastIndexOf(".") + 1));
    let n1 = Number(value);
    let n2 = parseFloat(value);
    if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
      if (n1 === 0 && !up) {
        return null;
      } else {
        n1 = Math.floor(n1 * precision);
        n1 += up ? precision : -precision;
        return String(n1 / precision);
      }
    }
    return null;
  }
  textReplace(value, up) {
    return this.valueSetsReplace(this._defaultValueSet, value, up);
  }
  valueSetsReplace(valueSets, value, up) {
    let result = null;
    for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
      result = this.valueSetReplace(valueSets[i], value, up);
    }
    return result;
  }
  valueSetReplace(valueSet, value, up) {
    let idx = valueSet.indexOf(value);
    if (idx >= 0) {
      idx += up ? 1 : -1;
      if (idx < 0) {
        idx = valueSet.length - 1;
      } else {
        idx %= valueSet.length;
      }
      return valueSet[idx];
    }
    return null;
  }
};
BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MirrorModel = class extends MirrorTextModel {
  get uri() {
    return this._uri;
  }
  get version() {
    return this._versionId;
  }
  get eol() {
    return this._eol;
  }
  getValue() {
    return this.getText();
  }
  getLinesContent() {
    return this._lines.slice(0);
  }
  getLineCount() {
    return this._lines.length;
  }
  getLineContent(lineNumber) {
    return this._lines[lineNumber - 1];
  }
  getWordAtPosition(position, wordDefinition) {
    let wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);
    if (wordAtText) {
      return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
    }
    return null;
  }
  words(wordDefinition) {
    const lines = this._lines;
    const wordenize = this._wordenize.bind(this);
    let lineNumber = 0;
    let lineText = "";
    let wordRangesIdx = 0;
    let wordRanges = [];
    return {
      *[Symbol.iterator]() {
        while (true) {
          if (wordRangesIdx < wordRanges.length) {
            const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
            wordRangesIdx += 1;
            yield value;
          } else {
            if (lineNumber < lines.length) {
              lineText = lines[lineNumber];
              wordRanges = wordenize(lineText, wordDefinition);
              wordRangesIdx = 0;
              lineNumber += 1;
            } else {
              break;
            }
          }
        }
      }
    };
  }
  getLineWords(lineNumber, wordDefinition) {
    let content = this._lines[lineNumber - 1];
    let ranges = this._wordenize(content, wordDefinition);
    let words = [];
    for (const range2 of ranges) {
      words.push({
        word: content.substring(range2.start, range2.end),
        startColumn: range2.start + 1,
        endColumn: range2.end + 1
      });
    }
    return words;
  }
  _wordenize(content, wordDefinition) {
    const result = [];
    let match2;
    wordDefinition.lastIndex = 0;
    while (match2 = wordDefinition.exec(content)) {
      if (match2[0].length === 0) {
        break;
      }
      result.push({start: match2.index, end: match2.index + match2[0].length});
    }
    return result;
  }
  getValueInRange(range2) {
    range2 = this._validateRange(range2);
    if (range2.startLineNumber === range2.endLineNumber) {
      return this._lines[range2.startLineNumber - 1].substring(range2.startColumn - 1, range2.endColumn - 1);
    }
    let lineEnding = this._eol;
    let startLineIndex = range2.startLineNumber - 1;
    let endLineIndex = range2.endLineNumber - 1;
    let resultLines = [];
    resultLines.push(this._lines[startLineIndex].substring(range2.startColumn - 1));
    for (let i = startLineIndex + 1; i < endLineIndex; i++) {
      resultLines.push(this._lines[i]);
    }
    resultLines.push(this._lines[endLineIndex].substring(0, range2.endColumn - 1));
    return resultLines.join(lineEnding);
  }
  offsetAt(position) {
    position = this._validatePosition(position);
    this._ensureLineStarts();
    return this._lineStarts.getAccumulatedValue(position.lineNumber - 2) + (position.column - 1);
  }
  positionAt(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    this._ensureLineStarts();
    let out = this._lineStarts.getIndexOf(offset);
    let lineLength = this._lines[out.index].length;
    return {
      lineNumber: 1 + out.index,
      column: 1 + Math.min(out.remainder, lineLength)
    };
  }
  _validateRange(range2) {
    const start = this._validatePosition({lineNumber: range2.startLineNumber, column: range2.startColumn});
    const end = this._validatePosition({lineNumber: range2.endLineNumber, column: range2.endColumn});
    if (start.lineNumber !== range2.startLineNumber || start.column !== range2.startColumn || end.lineNumber !== range2.endLineNumber || end.column !== range2.endColumn) {
      return {
        startLineNumber: start.lineNumber,
        startColumn: start.column,
        endLineNumber: end.lineNumber,
        endColumn: end.column
      };
    }
    return range2;
  }
  _validatePosition(position) {
    if (!Position.isIPosition(position)) {
      throw new Error("bad position");
    }
    let {lineNumber, column} = position;
    let hasChanged = false;
    if (lineNumber < 1) {
      lineNumber = 1;
      column = 1;
      hasChanged = true;
    } else if (lineNumber > this._lines.length) {
      lineNumber = this._lines.length;
      column = this._lines[lineNumber - 1].length + 1;
      hasChanged = true;
    } else {
      let maxCharacter = this._lines[lineNumber - 1].length + 1;
      if (column < 1) {
        column = 1;
        hasChanged = true;
      } else if (column > maxCharacter) {
        column = maxCharacter;
        hasChanged = true;
      }
    }
    if (!hasChanged) {
      return position;
    } else {
      return {lineNumber, column};
    }
  }
};
var EditorSimpleWorker = class {
  constructor(host, foreignModuleFactory) {
    this._host = host;
    this._models = Object.create(null);
    this._foreignModuleFactory = foreignModuleFactory;
    this._foreignModule = null;
  }
  dispose() {
    this._models = Object.create(null);
  }
  _getModel(uri) {
    return this._models[uri];
  }
  _getModels() {
    let all = [];
    Object.keys(this._models).forEach((key) => all.push(this._models[key]));
    return all;
  }
  acceptNewModel(data) {
    this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);
  }
  acceptModelChanged(strURL, e) {
    if (!this._models[strURL]) {
      return;
    }
    let model2 = this._models[strURL];
    model2.onEvents(e);
  }
  acceptRemovedModel(strURL) {
    if (!this._models[strURL]) {
      return;
    }
    delete this._models[strURL];
  }
  computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {
    return __awaiter3(this, void 0, void 0, function* () {
      const original = this._getModel(originalUrl);
      const modified = this._getModel(modifiedUrl);
      if (!original || !modified) {
        return null;
      }
      const originalLines = original.getLinesContent();
      const modifiedLines = modified.getLinesContent();
      const diffComputer = new DiffComputer(originalLines, modifiedLines, {
        shouldComputeCharChanges: true,
        shouldPostProcessCharChanges: true,
        shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,
        shouldMakePrettyDiff: true,
        maxComputationTime
      });
      const diffResult = diffComputer.computeDiff();
      const identical = diffResult.changes.length > 0 ? false : this._modelsAreIdentical(original, modified);
      return {
        quitEarly: diffResult.quitEarly,
        identical,
        changes: diffResult.changes
      };
    });
  }
  _modelsAreIdentical(original, modified) {
    const originalLineCount = original.getLineCount();
    const modifiedLineCount = modified.getLineCount();
    if (originalLineCount !== modifiedLineCount) {
      return false;
    }
    for (let line = 1; line <= originalLineCount; line++) {
      const originalLine = original.getLineContent(line);
      const modifiedLine = modified.getLineContent(line);
      if (originalLine !== modifiedLine) {
        return false;
      }
    }
    return true;
  }
  computeMoreMinimalEdits(modelUrl, edits) {
    return __awaiter3(this, void 0, void 0, function* () {
      const model2 = this._getModel(modelUrl);
      if (!model2) {
        return edits;
      }
      const result = [];
      let lastEol = void 0;
      edits = mergeSort(edits, (a, b) => {
        if (a.range && b.range) {
          return Range.compareRangesUsingStarts(a.range, b.range);
        }
        let aRng = a.range ? 0 : 1;
        let bRng = b.range ? 0 : 1;
        return aRng - bRng;
      });
      for (let {range: range2, text, eol} of edits) {
        if (typeof eol === "number") {
          lastEol = eol;
        }
        if (Range.isEmpty(range2) && !text) {
          continue;
        }
        const original = model2.getValueInRange(range2);
        text = text.replace(/\r\n|\n|\r/g, model2.eol);
        if (original === text) {
          continue;
        }
        if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {
          result.push({range: range2, text});
          continue;
        }
        const changes = stringDiff(original, text, false);
        const editOffset = model2.offsetAt(Range.lift(range2).getStartPosition());
        for (const change of changes) {
          const start = model2.positionAt(editOffset + change.originalStart);
          const end = model2.positionAt(editOffset + change.originalStart + change.originalLength);
          const newEdit = {
            text: text.substr(change.modifiedStart, change.modifiedLength),
            range: {startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column}
          };
          if (model2.getValueInRange(newEdit.range) !== newEdit.text) {
            result.push(newEdit);
          }
        }
      }
      if (typeof lastEol === "number") {
        result.push({eol: lastEol, text: "", range: {startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0}});
      }
      return result;
    });
  }
  computeLinks(modelUrl) {
    return __awaiter3(this, void 0, void 0, function* () {
      let model2 = this._getModel(modelUrl);
      if (!model2) {
        return null;
      }
      return computeLinks(model2);
    });
  }
  textualSuggest(modelUrl, position, wordDef, wordDefFlags) {
    return __awaiter3(this, void 0, void 0, function* () {
      const model2 = this._getModel(modelUrl);
      if (!model2) {
        return null;
      }
      const words = [];
      const seen = new Set();
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      const wordAt = model2.getWordAtPosition(position, wordDefRegExp);
      if (wordAt) {
        seen.add(model2.getValueInRange(wordAt));
      }
      for (let word of model2.words(wordDefRegExp)) {
        if (seen.has(word)) {
          continue;
        }
        seen.add(word);
        if (!isNaN(Number(word))) {
          continue;
        }
        words.push(word);
        if (seen.size > EditorSimpleWorker._suggestionsLimit) {
          break;
        }
      }
      return words;
    });
  }
  computeWordRanges(modelUrl, range2, wordDef, wordDefFlags) {
    return __awaiter3(this, void 0, void 0, function* () {
      let model2 = this._getModel(modelUrl);
      if (!model2) {
        return Object.create(null);
      }
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      const result = Object.create(null);
      for (let line = range2.startLineNumber; line < range2.endLineNumber; line++) {
        let words = model2.getLineWords(line, wordDefRegExp);
        for (const word of words) {
          if (!isNaN(Number(word.word))) {
            continue;
          }
          let array = result[word.word];
          if (!array) {
            array = [];
            result[word.word] = array;
          }
          array.push({
            startLineNumber: line,
            startColumn: word.startColumn,
            endLineNumber: line,
            endColumn: word.endColumn
          });
        }
      }
      return result;
    });
  }
  navigateValueSet(modelUrl, range2, up, wordDef, wordDefFlags) {
    return __awaiter3(this, void 0, void 0, function* () {
      let model2 = this._getModel(modelUrl);
      if (!model2) {
        return null;
      }
      let wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      if (range2.startColumn === range2.endColumn) {
        range2 = {
          startLineNumber: range2.startLineNumber,
          startColumn: range2.startColumn,
          endLineNumber: range2.endLineNumber,
          endColumn: range2.endColumn + 1
        };
      }
      let selectionText = model2.getValueInRange(range2);
      let wordRange = model2.getWordAtPosition({lineNumber: range2.startLineNumber, column: range2.startColumn}, wordDefRegExp);
      if (!wordRange) {
        return null;
      }
      let word = model2.getValueInRange(wordRange);
      let result = BasicInplaceReplace.INSTANCE.navigateValueSet(range2, selectionText, wordRange, word, up);
      return result;
    });
  }
  loadForeignModule(moduleId, createData, foreignHostMethods) {
    const proxyMethodRequest = (method, args) => {
      return this._host.fhr(method, args);
    };
    const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
    let ctx = {
      host: foreignHost,
      getMirrorModels: () => {
        return this._getModels();
      }
    };
    if (this._foreignModuleFactory) {
      this._foreignModule = this._foreignModuleFactory(ctx, createData);
      return Promise.resolve(getAllMethodNames(this._foreignModule));
    }
    return Promise.reject(new Error(`Unexpected usage`));
  }
  fmr(method, args) {
    if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
      return Promise.reject(new Error("Missing requestHandler or method: " + method));
    }
    try {
      return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
    } catch (e) {
      return Promise.reject(e);
    }
  }
};
EditorSimpleWorker._diffLimit = 1e5;
EditorSimpleWorker._suggestionsLimit = 1e4;
if (typeof importScripts === "function") {
  globals.monaco = createMonacoBaseAPI();
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfigurationService.js
var ITextResourceConfigurationService = createDecorator("textResourceConfigurationService");
var ITextResourcePropertiesService = createDecorator("textResourcePropertiesService");

// ../../node_modules/monaco-editor/esm/vs/platform/log/common/log.js
var ILogService = createDecorator("logService");
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Trace"] = 0] = "Trace";
  LogLevel2[LogLevel2["Debug"] = 1] = "Debug";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Warning"] = 3] = "Warning";
  LogLevel2[LogLevel2["Error"] = 4] = "Error";
  LogLevel2[LogLevel2["Critical"] = 5] = "Critical";
  LogLevel2[LogLevel2["Off"] = 6] = "Off";
})(LogLevel || (LogLevel = {}));
var DEFAULT_LOG_LEVEL = LogLevel.Info;
var AbstractLogService = class extends Disposable {
  constructor() {
    super(...arguments);
    this.level = DEFAULT_LOG_LEVEL;
    this._onDidChangeLogLevel = this._register(new Emitter());
  }
  setLevel(level) {
    if (this.level !== level) {
      this.level = level;
      this._onDidChangeLogLevel.fire(this.level);
    }
  }
  getLevel() {
    return this.level;
  }
};
var ConsoleLogService = class extends AbstractLogService {
  constructor(logLevel = DEFAULT_LOG_LEVEL) {
    super();
    this.setLevel(logLevel);
  }
  trace(message, ...args) {
    if (this.getLevel() <= LogLevel.Trace) {
      console.log("%cTRACE", "color: #888", message, ...args);
    }
  }
  info(message, ...args) {
    if (this.getLevel() <= LogLevel.Info) {
      console.log("%c INFO", "color: #33f", message, ...args);
    }
  }
  error(message, ...args) {
    if (this.getLevel() <= LogLevel.Error) {
      console.log("%c  ERR", "color: #f33", message, ...args);
    }
  }
  dispose() {
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/stopwatch.js
var hasPerformanceNow = globals.performance && typeof globals.performance.now === "function";
var StopWatch = class {
  constructor(highResolution) {
    this._highResolution = hasPerformanceNow && highResolution;
    this._startTime = this._now();
    this._stopTime = -1;
  }
  static create(highResolution = true) {
    return new StopWatch(highResolution);
  }
  stop() {
    this._stopTime = this._now();
  }
  elapsed() {
    if (this._stopTime !== -1) {
      return this._stopTime - this._startTime;
    }
    return this._now() - this._startTime;
  }
  _now() {
    return this._highResolution ? globals.performance.now() : new Date().getTime();
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerServiceImpl.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1e3;
var STOP_WORKER_DELTA_TIME_MS = 5 * 60 * 1e3;
function canSyncModel(modelService, resource) {
  let model2 = modelService.getModel(resource);
  if (!model2) {
    return false;
  }
  if (model2.isTooLargeForSyncing()) {
    return false;
  }
  return true;
}
var EditorWorkerServiceImpl = class EditorWorkerServiceImpl2 extends Disposable {
  constructor(modelService, configurationService, logService) {
    super();
    this._modelService = modelService;
    this._workerManager = this._register(new WorkerManager(this._modelService));
    this._logService = logService;
    this._register(LinkProviderRegistry.register("*", {
      provideLinks: (model2, token) => {
        if (!canSyncModel(this._modelService, model2.uri)) {
          return Promise.resolve({links: []});
        }
        return this._workerManager.withWorker().then((client) => client.computeLinks(model2.uri)).then((links) => {
          return links && {links};
        });
      }
    }));
    this._register(CompletionProviderRegistry.register("*", new WordBasedCompletionItemProvider(this._workerManager, configurationService, this._modelService)));
  }
  dispose() {
    super.dispose();
  }
  canComputeDiff(original, modified) {
    return canSyncModel(this._modelService, original) && canSyncModel(this._modelService, modified);
  }
  computeDiff(original, modified, ignoreTrimWhitespace, maxComputationTime) {
    return this._workerManager.withWorker().then((client) => client.computeDiff(original, modified, ignoreTrimWhitespace, maxComputationTime));
  }
  computeMoreMinimalEdits(resource, edits) {
    if (isNonEmptyArray(edits)) {
      if (!canSyncModel(this._modelService, resource)) {
        return Promise.resolve(edits);
      }
      const sw = StopWatch.create(true);
      const result = this._workerManager.withWorker().then((client) => client.computeMoreMinimalEdits(resource, edits));
      result.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", resource.toString(true), sw.elapsed()));
      return result;
    } else {
      return Promise.resolve(void 0);
    }
  }
  canNavigateValueSet(resource) {
    return canSyncModel(this._modelService, resource);
  }
  navigateValueSet(resource, range2, up) {
    return this._workerManager.withWorker().then((client) => client.navigateValueSet(resource, range2, up));
  }
  canComputeWordRanges(resource) {
    return canSyncModel(this._modelService, resource);
  }
  computeWordRanges(resource, range2) {
    return this._workerManager.withWorker().then((client) => client.computeWordRanges(resource, range2));
  }
};
EditorWorkerServiceImpl = __decorate2([
  __param2(0, IModelService),
  __param2(1, ITextResourceConfigurationService),
  __param2(2, ILogService)
], EditorWorkerServiceImpl);
var WordBasedCompletionItemProvider = class {
  constructor(workerManager, configurationService, modelService) {
    this._debugDisplayName = "wordbasedCompletions";
    this._workerManager = workerManager;
    this._configurationService = configurationService;
    this._modelService = modelService;
  }
  provideCompletionItems(model2, position) {
    return __awaiter4(this, void 0, void 0, function* () {
      const {wordBasedSuggestions} = this._configurationService.getValue(model2.uri, position, "editor");
      if (!wordBasedSuggestions) {
        return void 0;
      }
      if (!canSyncModel(this._modelService, model2.uri)) {
        return void 0;
      }
      const word = model2.getWordAtPosition(position);
      const replace = !word ? Range.fromPositions(position) : new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
      const insert = replace.setEndPosition(position.lineNumber, position.column);
      const client = yield this._workerManager.withWorker();
      const words = yield client.textualSuggest(model2.uri, position);
      if (!words) {
        return void 0;
      }
      return {
        suggestions: words.map((word2) => {
          return {
            kind: 18,
            label: word2,
            insertText: word2,
            range: {insert, replace}
          };
        })
      };
    });
  }
};
var WorkerManager = class extends Disposable {
  constructor(modelService) {
    super();
    this._modelService = modelService;
    this._editorWorkerClient = null;
    this._lastWorkerUsedTime = new Date().getTime();
    let stopWorkerInterval = this._register(new IntervalTimer());
    stopWorkerInterval.cancelAndSet(() => this._checkStopIdleWorker(), Math.round(STOP_WORKER_DELTA_TIME_MS / 2));
    this._register(this._modelService.onModelRemoved((_) => this._checkStopEmptyWorker()));
  }
  dispose() {
    if (this._editorWorkerClient) {
      this._editorWorkerClient.dispose();
      this._editorWorkerClient = null;
    }
    super.dispose();
  }
  _checkStopEmptyWorker() {
    if (!this._editorWorkerClient) {
      return;
    }
    let models = this._modelService.getModels();
    if (models.length === 0) {
      this._editorWorkerClient.dispose();
      this._editorWorkerClient = null;
    }
  }
  _checkStopIdleWorker() {
    if (!this._editorWorkerClient) {
      return;
    }
    let timeSinceLastWorkerUsedTime = new Date().getTime() - this._lastWorkerUsedTime;
    if (timeSinceLastWorkerUsedTime > STOP_WORKER_DELTA_TIME_MS) {
      this._editorWorkerClient.dispose();
      this._editorWorkerClient = null;
    }
  }
  withWorker() {
    this._lastWorkerUsedTime = new Date().getTime();
    if (!this._editorWorkerClient) {
      this._editorWorkerClient = new EditorWorkerClient(this._modelService, false, "editorWorkerService");
    }
    return Promise.resolve(this._editorWorkerClient);
  }
};
var EditorModelManager = class extends Disposable {
  constructor(proxy, modelService, keepIdleModels) {
    super();
    this._syncedModels = Object.create(null);
    this._syncedModelsLastUsedTime = Object.create(null);
    this._proxy = proxy;
    this._modelService = modelService;
    if (!keepIdleModels) {
      let timer = new IntervalTimer();
      timer.cancelAndSet(() => this._checkStopModelSync(), Math.round(STOP_SYNC_MODEL_DELTA_TIME_MS / 2));
      this._register(timer);
    }
  }
  dispose() {
    for (let modelUrl in this._syncedModels) {
      dispose(this._syncedModels[modelUrl]);
    }
    this._syncedModels = Object.create(null);
    this._syncedModelsLastUsedTime = Object.create(null);
    super.dispose();
  }
  ensureSyncedResources(resources2) {
    for (const resource of resources2) {
      let resourceStr = resource.toString();
      if (!this._syncedModels[resourceStr]) {
        this._beginModelSync(resource);
      }
      if (this._syncedModels[resourceStr]) {
        this._syncedModelsLastUsedTime[resourceStr] = new Date().getTime();
      }
    }
  }
  _checkStopModelSync() {
    let currentTime = new Date().getTime();
    let toRemove = [];
    for (let modelUrl in this._syncedModelsLastUsedTime) {
      let elapsedTime = currentTime - this._syncedModelsLastUsedTime[modelUrl];
      if (elapsedTime > STOP_SYNC_MODEL_DELTA_TIME_MS) {
        toRemove.push(modelUrl);
      }
    }
    for (const e of toRemove) {
      this._stopModelSync(e);
    }
  }
  _beginModelSync(resource) {
    let model2 = this._modelService.getModel(resource);
    if (!model2) {
      return;
    }
    if (model2.isTooLargeForSyncing()) {
      return;
    }
    let modelUrl = resource.toString();
    this._proxy.acceptNewModel({
      url: model2.uri.toString(),
      lines: model2.getLinesContent(),
      EOL: model2.getEOL(),
      versionId: model2.getVersionId()
    });
    const toDispose = new DisposableStore();
    toDispose.add(model2.onDidChangeContent((e) => {
      this._proxy.acceptModelChanged(modelUrl.toString(), e);
    }));
    toDispose.add(model2.onWillDispose(() => {
      this._stopModelSync(modelUrl);
    }));
    toDispose.add(toDisposable(() => {
      this._proxy.acceptRemovedModel(modelUrl);
    }));
    this._syncedModels[modelUrl] = toDispose;
  }
  _stopModelSync(modelUrl) {
    let toDispose = this._syncedModels[modelUrl];
    delete this._syncedModels[modelUrl];
    delete this._syncedModelsLastUsedTime[modelUrl];
    dispose(toDispose);
  }
};
var SynchronousWorkerClient = class {
  constructor(instance) {
    this._instance = instance;
    this._proxyObj = Promise.resolve(this._instance);
  }
  dispose() {
    this._instance.dispose();
  }
  getProxyObject() {
    return this._proxyObj;
  }
};
var EditorWorkerHost = class {
  constructor(workerClient) {
    this._workerClient = workerClient;
  }
  fhr(method, args) {
    return this._workerClient.fhr(method, args);
  }
};
var EditorWorkerClient = class extends Disposable {
  constructor(modelService, keepIdleModels, label) {
    super();
    this._disposed = false;
    this._modelService = modelService;
    this._keepIdleModels = keepIdleModels;
    this._workerFactory = new DefaultWorkerFactory(label);
    this._worker = null;
    this._modelManager = null;
  }
  fhr(method, args) {
    throw new Error(`Not implemented!`);
  }
  _getOrCreateWorker() {
    if (!this._worker) {
      try {
        this._worker = this._register(new SimpleWorkerClient(this._workerFactory, "vs/editor/common/services/editorSimpleWorker", new EditorWorkerHost(this)));
      } catch (err) {
        logOnceWebWorkerWarning(err);
        this._worker = new SynchronousWorkerClient(new EditorSimpleWorker(new EditorWorkerHost(this), null));
      }
    }
    return this._worker;
  }
  _getProxy() {
    return this._getOrCreateWorker().getProxyObject().then(void 0, (err) => {
      logOnceWebWorkerWarning(err);
      this._worker = new SynchronousWorkerClient(new EditorSimpleWorker(new EditorWorkerHost(this), null));
      return this._getOrCreateWorker().getProxyObject();
    });
  }
  _getOrCreateModelManager(proxy) {
    if (!this._modelManager) {
      this._modelManager = this._register(new EditorModelManager(proxy, this._modelService, this._keepIdleModels));
    }
    return this._modelManager;
  }
  _withSyncedResources(resources2) {
    if (this._disposed) {
      return Promise.reject(canceled());
    }
    return this._getProxy().then((proxy) => {
      this._getOrCreateModelManager(proxy).ensureSyncedResources(resources2);
      return proxy;
    });
  }
  computeDiff(original, modified, ignoreTrimWhitespace, maxComputationTime) {
    return this._withSyncedResources([original, modified]).then((proxy) => {
      return proxy.computeDiff(original.toString(), modified.toString(), ignoreTrimWhitespace, maxComputationTime);
    });
  }
  computeMoreMinimalEdits(resource, edits) {
    return this._withSyncedResources([resource]).then((proxy) => {
      return proxy.computeMoreMinimalEdits(resource.toString(), edits);
    });
  }
  computeLinks(resource) {
    return this._withSyncedResources([resource]).then((proxy) => {
      return proxy.computeLinks(resource.toString());
    });
  }
  textualSuggest(resource, position) {
    return this._withSyncedResources([resource]).then((proxy) => {
      let model2 = this._modelService.getModel(resource);
      if (!model2) {
        return null;
      }
      let wordDefRegExp = LanguageConfigurationRegistry.getWordDefinition(model2.getLanguageIdentifier().id);
      let wordDef = wordDefRegExp.source;
      let wordDefFlags = regExpFlags(wordDefRegExp);
      return proxy.textualSuggest(resource.toString(), position, wordDef, wordDefFlags);
    });
  }
  computeWordRanges(resource, range2) {
    return this._withSyncedResources([resource]).then((proxy) => {
      let model2 = this._modelService.getModel(resource);
      if (!model2) {
        return Promise.resolve(null);
      }
      let wordDefRegExp = LanguageConfigurationRegistry.getWordDefinition(model2.getLanguageIdentifier().id);
      let wordDef = wordDefRegExp.source;
      let wordDefFlags = regExpFlags(wordDefRegExp);
      return proxy.computeWordRanges(resource.toString(), range2, wordDef, wordDefFlags);
    });
  }
  navigateValueSet(resource, range2, up) {
    return this._withSyncedResources([resource]).then((proxy) => {
      let model2 = this._modelService.getModel(resource);
      if (!model2) {
        return null;
      }
      let wordDefRegExp = LanguageConfigurationRegistry.getWordDefinition(model2.getLanguageIdentifier().id);
      let wordDef = wordDefRegExp.source;
      let wordDefFlags = regExpFlags(wordDefRegExp);
      return proxy.navigateValueSet(resource.toString(), range2, up, wordDef, wordDefFlags);
    });
  }
  dispose() {
    super.dispose();
    this._disposed = true;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/webWorker.js
function createWebWorker(modelService, opts) {
  return new MonacoWebWorkerImpl(modelService, opts);
}
var MonacoWebWorkerImpl = class extends EditorWorkerClient {
  constructor(modelService, opts) {
    super(modelService, opts.keepIdleModels || false, opts.label);
    this._foreignModuleId = opts.moduleId;
    this._foreignModuleCreateData = opts.createData || null;
    this._foreignModuleHost = opts.host || null;
    this._foreignProxy = null;
  }
  fhr(method, args) {
    if (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== "function") {
      return Promise.reject(new Error("Missing method " + method + " or missing main thread foreign host."));
    }
    try {
      return Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  _getForeignProxy() {
    if (!this._foreignProxy) {
      this._foreignProxy = this._getProxy().then((proxy) => {
        const foreignHostMethods = this._foreignModuleHost ? getAllMethodNames(this._foreignModuleHost) : [];
        return proxy.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then((foreignMethods) => {
          this._foreignModuleCreateData = null;
          const proxyMethodRequest = (method, args) => {
            return proxy.fmr(method, args);
          };
          const createProxyMethod = (method, proxyMethodRequest2) => {
            return function() {
              const args = Array.prototype.slice.call(arguments, 0);
              return proxyMethodRequest2(method, args);
            };
          };
          let foreignProxy = {};
          for (const foreignMethod of foreignMethods) {
            foreignProxy[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);
          }
          return foreignProxy;
        });
      });
    }
    return this._foreignProxy;
  }
  getProxy() {
    return this._getForeignProxy();
  }
  withSyncedResources(resources2) {
    return this._withSyncedResources(resources2).then((_) => this.getProxy());
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/core/lineTokens.js
var LineTokens = class {
  constructor(tokens, text) {
    this._tokens = tokens;
    this._tokensCount = this._tokens.length >>> 1;
    this._text = text;
  }
  equals(other) {
    if (other instanceof LineTokens) {
      return this.slicedEquals(other, 0, this._tokensCount);
    }
    return false;
  }
  slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {
    if (this._text !== other._text) {
      return false;
    }
    if (this._tokensCount !== other._tokensCount) {
      return false;
    }
    const from = sliceFromTokenIndex << 1;
    const to = from + (sliceTokenCount << 1);
    for (let i = from; i < to; i++) {
      if (this._tokens[i] !== other._tokens[i]) {
        return false;
      }
    }
    return true;
  }
  getLineContent() {
    return this._text;
  }
  getCount() {
    return this._tokensCount;
  }
  getStartOffset(tokenIndex) {
    if (tokenIndex > 0) {
      return this._tokens[tokenIndex - 1 << 1];
    }
    return 0;
  }
  getMetadata(tokenIndex) {
    const metadata = this._tokens[(tokenIndex << 1) + 1];
    return metadata;
  }
  getLanguageId(tokenIndex) {
    const metadata = this._tokens[(tokenIndex << 1) + 1];
    return TokenMetadata.getLanguageId(metadata);
  }
  getStandardTokenType(tokenIndex) {
    const metadata = this._tokens[(tokenIndex << 1) + 1];
    return TokenMetadata.getTokenType(metadata);
  }
  getForeground(tokenIndex) {
    const metadata = this._tokens[(tokenIndex << 1) + 1];
    return TokenMetadata.getForeground(metadata);
  }
  getClassName(tokenIndex) {
    const metadata = this._tokens[(tokenIndex << 1) + 1];
    return TokenMetadata.getClassNameFromMetadata(metadata);
  }
  getInlineStyle(tokenIndex, colorMap) {
    const metadata = this._tokens[(tokenIndex << 1) + 1];
    return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);
  }
  getEndOffset(tokenIndex) {
    return this._tokens[tokenIndex << 1];
  }
  findTokenIndexAtOffset(offset) {
    return LineTokens.findIndexInTokensArray(this._tokens, offset);
  }
  inflate() {
    return this;
  }
  sliceAndInflate(startOffset, endOffset, deltaOffset) {
    return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);
  }
  static convertToEndOffset(tokens, lineTextLength) {
    const tokenCount = tokens.length >>> 1;
    const lastTokenIndex = tokenCount - 1;
    for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {
      tokens[tokenIndex << 1] = tokens[tokenIndex + 1 << 1];
    }
    tokens[lastTokenIndex << 1] = lineTextLength;
  }
  static findIndexInTokensArray(tokens, desiredIndex) {
    if (tokens.length <= 2) {
      return 0;
    }
    let low = 0;
    let high = (tokens.length >>> 1) - 1;
    while (low < high) {
      const mid = low + Math.floor((high - low) / 2);
      const endOffset = tokens[mid << 1];
      if (endOffset === desiredIndex) {
        return mid + 1;
      } else if (endOffset < desiredIndex) {
        low = mid + 1;
      } else if (endOffset > desiredIndex) {
        high = mid;
      }
    }
    return low;
  }
};
var SlicedLineTokens = class {
  constructor(source, startOffset, endOffset, deltaOffset) {
    this._source = source;
    this._startOffset = startOffset;
    this._endOffset = endOffset;
    this._deltaOffset = deltaOffset;
    this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);
    this._tokensCount = 0;
    for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {
      const tokenStartOffset = source.getStartOffset(i);
      if (tokenStartOffset >= endOffset) {
        break;
      }
      this._tokensCount++;
    }
  }
  equals(other) {
    if (other instanceof SlicedLineTokens) {
      return this._startOffset === other._startOffset && this._endOffset === other._endOffset && this._deltaOffset === other._deltaOffset && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount);
    }
    return false;
  }
  getCount() {
    return this._tokensCount;
  }
  getForeground(tokenIndex) {
    return this._source.getForeground(this._firstTokenIndex + tokenIndex);
  }
  getEndOffset(tokenIndex) {
    const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);
    return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;
  }
  getClassName(tokenIndex) {
    return this._source.getClassName(this._firstTokenIndex + tokenIndex);
  }
  getInlineStyle(tokenIndex, colorMap) {
    return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);
  }
  findTokenIndexAtOffset(offset) {
    return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js
var LineDecoration = class {
  constructor(startColumn, endColumn, className, type) {
    this.startColumn = startColumn;
    this.endColumn = endColumn;
    this.className = className;
    this.type = type;
  }
  static _equals(a, b) {
    return a.startColumn === b.startColumn && a.endColumn === b.endColumn && a.className === b.className && a.type === b.type;
  }
  static equalsArr(a, b) {
    const aLen = a.length;
    const bLen = b.length;
    if (aLen !== bLen) {
      return false;
    }
    for (let i = 0; i < aLen; i++) {
      if (!LineDecoration._equals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {
    if (lineDecorations.length === 0) {
      return [];
    }
    let result = [], resultLen = 0;
    for (let i = 0, len = lineDecorations.length; i < len; i++) {
      const d = lineDecorations[i];
      const range2 = d.range;
      if (range2.endLineNumber < lineNumber || range2.startLineNumber > lineNumber) {
        continue;
      }
      if (range2.isEmpty() && (d.type === 0 || d.type === 3)) {
        continue;
      }
      const startColumn = range2.startLineNumber === lineNumber ? range2.startColumn : minLineColumn;
      const endColumn = range2.endLineNumber === lineNumber ? range2.endColumn : maxLineColumn;
      result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);
    }
    return result;
  }
  static _typeCompare(a, b) {
    const ORDER = [2, 0, 1, 3];
    return ORDER[a] - ORDER[b];
  }
  static compare(a, b) {
    if (a.startColumn === b.startColumn) {
      if (a.endColumn === b.endColumn) {
        const typeCmp = LineDecoration._typeCompare(a.type, b.type);
        if (typeCmp === 0) {
          if (a.className < b.className) {
            return -1;
          }
          if (a.className > b.className) {
            return 1;
          }
          return 0;
        }
        return typeCmp;
      }
      return a.endColumn - b.endColumn;
    }
    return a.startColumn - b.startColumn;
  }
};
var DecorationSegment = class {
  constructor(startOffset, endOffset, className, metadata) {
    this.startOffset = startOffset;
    this.endOffset = endOffset;
    this.className = className;
    this.metadata = metadata;
  }
};
var Stack = class {
  constructor() {
    this.stopOffsets = [];
    this.classNames = [];
    this.metadata = [];
    this.count = 0;
  }
  static _metadata(metadata) {
    let result = 0;
    for (let i = 0, len = metadata.length; i < len; i++) {
      result |= metadata[i];
    }
    return result;
  }
  consumeLowerThan(maxStopOffset, nextStartOffset, result) {
    while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {
      let i = 0;
      while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {
        i++;
      }
      result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(" "), Stack._metadata(this.metadata)));
      nextStartOffset = this.stopOffsets[i] + 1;
      this.stopOffsets.splice(0, i + 1);
      this.classNames.splice(0, i + 1);
      this.metadata.splice(0, i + 1);
      this.count -= i + 1;
    }
    if (this.count > 0 && nextStartOffset < maxStopOffset) {
      result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(" "), Stack._metadata(this.metadata)));
      nextStartOffset = maxStopOffset;
    }
    return nextStartOffset;
  }
  insert(stopOffset, className, metadata) {
    if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {
      this.stopOffsets.push(stopOffset);
      this.classNames.push(className);
      this.metadata.push(metadata);
    } else {
      for (let i = 0; i < this.count; i++) {
        if (this.stopOffsets[i] >= stopOffset) {
          this.stopOffsets.splice(i, 0, stopOffset);
          this.classNames.splice(i, 0, className);
          this.metadata.splice(i, 0, metadata);
          break;
        }
      }
    }
    this.count++;
    return;
  }
};
var LineDecorationsNormalizer = class {
  static normalize(lineContent, lineDecorations) {
    if (lineDecorations.length === 0) {
      return [];
    }
    let result = [];
    const stack = new Stack();
    let nextStartOffset = 0;
    for (let i = 0, len = lineDecorations.length; i < len; i++) {
      const d = lineDecorations[i];
      let startColumn = d.startColumn;
      let endColumn = d.endColumn;
      const className = d.className;
      const metadata = d.type === 1 ? 2 : d.type === 2 ? 4 : 0;
      if (startColumn > 1) {
        const charCodeBefore = lineContent.charCodeAt(startColumn - 2);
        if (isHighSurrogate(charCodeBefore)) {
          startColumn--;
        }
      }
      if (endColumn > 1) {
        const charCodeBefore = lineContent.charCodeAt(endColumn - 2);
        if (isHighSurrogate(charCodeBefore)) {
          endColumn--;
        }
      }
      const currentStartOffset = startColumn - 1;
      const currentEndOffset = endColumn - 2;
      nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);
      if (stack.count === 0) {
        nextStartOffset = currentStartOffset;
      }
      stack.insert(currentEndOffset, className, metadata);
    }
    stack.consumeLowerThan(1073741824, nextStartOffset, result);
    return result;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js
var LinePart = class {
  constructor(endIndex, type, metadata) {
    this.endIndex = endIndex;
    this.type = type;
    this.metadata = metadata;
  }
  isWhitespace() {
    return this.metadata & 1 ? true : false;
  }
};
var LineRange = class {
  constructor(startIndex, endIndex) {
    this.startOffset = startIndex;
    this.endOffset = endIndex;
  }
  equals(otherLineRange) {
    return this.startOffset === otherLineRange.startOffset && this.endOffset === otherLineRange.endOffset;
  }
};
var RenderLineInput = class {
  constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII2, containsRTL2, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {
    this.useMonospaceOptimizations = useMonospaceOptimizations;
    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;
    this.lineContent = lineContent;
    this.continuesWithWrappedLine = continuesWithWrappedLine;
    this.isBasicASCII = isBasicASCII2;
    this.containsRTL = containsRTL2;
    this.fauxIndentLength = fauxIndentLength;
    this.lineTokens = lineTokens;
    this.lineDecorations = lineDecorations;
    this.tabSize = tabSize;
    this.startVisibleColumn = startVisibleColumn;
    this.spaceWidth = spaceWidth;
    this.stopRenderingLineAfter = stopRenderingLineAfter;
    this.renderWhitespace = renderWhitespace === "all" ? 4 : renderWhitespace === "boundary" ? 1 : renderWhitespace === "selection" ? 2 : renderWhitespace === "trailing" ? 3 : 0;
    this.renderControlCharacters = renderControlCharacters;
    this.fontLigatures = fontLigatures;
    this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);
    const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);
    const middotDiff = Math.abs(middotWidth - spaceWidth);
    if (wsmiddotDiff < middotDiff) {
      this.renderSpaceWidth = wsmiddotWidth;
      this.renderSpaceCharCode = 11825;
    } else {
      this.renderSpaceWidth = middotWidth;
      this.renderSpaceCharCode = 183;
    }
  }
  sameSelection(otherSelections) {
    if (this.selectionsOnLine === null) {
      return otherSelections === null;
    }
    if (otherSelections === null) {
      return false;
    }
    if (otherSelections.length !== this.selectionsOnLine.length) {
      return false;
    }
    for (let i = 0; i < this.selectionsOnLine.length; i++) {
      if (!this.selectionsOnLine[i].equals(otherSelections[i])) {
        return false;
      }
    }
    return true;
  }
  equals(other) {
    return this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineContent === other.lineContent && this.continuesWithWrappedLine === other.continuesWithWrappedLine && this.isBasicASCII === other.isBasicASCII && this.containsRTL === other.containsRTL && this.fauxIndentLength === other.fauxIndentLength && this.tabSize === other.tabSize && this.startVisibleColumn === other.startVisibleColumn && this.spaceWidth === other.spaceWidth && this.renderSpaceWidth === other.renderSpaceWidth && this.renderSpaceCharCode === other.renderSpaceCharCode && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.fontLigatures === other.fontLigatures && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations) && this.lineTokens.equals(other.lineTokens) && this.sameSelection(other.selectionsOnLine);
  }
};
var CharacterMapping = class {
  constructor(length, partCount) {
    this.length = length;
    this._data = new Uint32Array(this.length);
    this._absoluteOffsets = new Uint32Array(this.length);
  }
  static getPartIndex(partData) {
    return (partData & 4294901760) >>> 16;
  }
  static getCharIndex(partData) {
    return (partData & 65535) >>> 0;
  }
  setPartData(charOffset, partIndex, charIndex, partAbsoluteOffset) {
    let partData = (partIndex << 16 | charIndex << 0) >>> 0;
    this._data[charOffset] = partData;
    this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;
  }
  getAbsoluteOffsets() {
    return this._absoluteOffsets;
  }
  charOffsetToPartData(charOffset) {
    if (this.length === 0) {
      return 0;
    }
    if (charOffset < 0) {
      return this._data[0];
    }
    if (charOffset >= this.length) {
      return this._data[this.length - 1];
    }
    return this._data[charOffset];
  }
  partDataToCharOffset(partIndex, partLength, charIndex) {
    if (this.length === 0) {
      return 0;
    }
    let searchEntry = (partIndex << 16 | charIndex << 0) >>> 0;
    let min = 0;
    let max = this.length - 1;
    while (min + 1 < max) {
      let mid = min + max >>> 1;
      let midEntry = this._data[mid];
      if (midEntry === searchEntry) {
        return mid;
      } else if (midEntry > searchEntry) {
        max = mid;
      } else {
        min = mid;
      }
    }
    if (min === max) {
      return min;
    }
    let minEntry = this._data[min];
    let maxEntry = this._data[max];
    if (minEntry === searchEntry) {
      return min;
    }
    if (maxEntry === searchEntry) {
      return max;
    }
    let minPartIndex = CharacterMapping.getPartIndex(minEntry);
    let minCharIndex = CharacterMapping.getCharIndex(minEntry);
    let maxPartIndex = CharacterMapping.getPartIndex(maxEntry);
    let maxCharIndex;
    if (minPartIndex !== maxPartIndex) {
      maxCharIndex = partLength;
    } else {
      maxCharIndex = CharacterMapping.getCharIndex(maxEntry);
    }
    let minEntryDistance = charIndex - minCharIndex;
    let maxEntryDistance = maxCharIndex - charIndex;
    if (minEntryDistance <= maxEntryDistance) {
      return min;
    }
    return max;
  }
};
var RenderLineOutput = class {
  constructor(characterMapping, containsRTL2, containsForeignElements) {
    this.characterMapping = characterMapping;
    this.containsRTL = containsRTL2;
    this.containsForeignElements = containsForeignElements;
  }
};
function renderViewLine(input, sb) {
  if (input.lineContent.length === 0) {
    let containsForeignElements = 0;
    let content = "<span><span></span></span>";
    if (input.lineDecorations.length > 0) {
      const beforeClassNames = [];
      const afterClassNames = [];
      for (let i = 0, len = input.lineDecorations.length; i < len; i++) {
        const lineDecoration = input.lineDecorations[i];
        if (lineDecoration.type === 1) {
          beforeClassNames.push(input.lineDecorations[i].className);
          containsForeignElements |= 1;
        }
        if (lineDecoration.type === 2) {
          afterClassNames.push(input.lineDecorations[i].className);
          containsForeignElements |= 2;
        }
      }
      if (containsForeignElements !== 0) {
        const beforeSpan = beforeClassNames.length > 0 ? `<span class="${beforeClassNames.join(" ")}"></span>` : ``;
        const afterSpan = afterClassNames.length > 0 ? `<span class="${afterClassNames.join(" ")}"></span>` : ``;
        content = `<span>${beforeSpan}${afterSpan}</span>`;
      }
    }
    sb.appendASCIIString(content);
    return new RenderLineOutput(new CharacterMapping(0, 0), false, containsForeignElements);
  }
  return _renderLine(resolveRenderLineInput(input), sb);
}
var RenderLineOutput2 = class {
  constructor(characterMapping, html, containsRTL2, containsForeignElements) {
    this.characterMapping = characterMapping;
    this.html = html;
    this.containsRTL = containsRTL2;
    this.containsForeignElements = containsForeignElements;
  }
};
function renderViewLine2(input) {
  let sb = createStringBuilder(1e4);
  let out = renderViewLine(input, sb);
  return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);
}
var ResolvedRenderLineInput = class {
  constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL2, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {
    this.fontIsMonospace = fontIsMonospace;
    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;
    this.lineContent = lineContent;
    this.len = len;
    this.isOverflowing = isOverflowing;
    this.parts = parts;
    this.containsForeignElements = containsForeignElements;
    this.fauxIndentLength = fauxIndentLength;
    this.tabSize = tabSize;
    this.startVisibleColumn = startVisibleColumn;
    this.containsRTL = containsRTL2;
    this.spaceWidth = spaceWidth;
    this.renderSpaceCharCode = renderSpaceCharCode;
    this.renderWhitespace = renderWhitespace;
    this.renderControlCharacters = renderControlCharacters;
  }
};
function resolveRenderLineInput(input) {
  const lineContent = input.lineContent;
  let isOverflowing;
  let len;
  if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {
    isOverflowing = true;
    len = input.stopRenderingLineAfter;
  } else {
    isOverflowing = false;
    len = lineContent.length;
  }
  let tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);
  if (input.renderWhitespace === 4 || input.renderWhitespace === 1 || input.renderWhitespace === 2 && !!input.selectionsOnLine || input.renderWhitespace === 3) {
    tokens = _applyRenderWhitespace(input, lineContent, len, tokens);
  }
  let containsForeignElements = 0;
  if (input.lineDecorations.length > 0) {
    for (let i = 0, len2 = input.lineDecorations.length; i < len2; i++) {
      const lineDecoration = input.lineDecorations[i];
      if (lineDecoration.type === 3) {
        containsForeignElements |= 1;
      } else if (lineDecoration.type === 1) {
        containsForeignElements |= 1;
      } else if (lineDecoration.type === 2) {
        containsForeignElements |= 2;
      }
    }
    tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);
  }
  if (!input.containsRTL) {
    tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);
  }
  return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);
}
function transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {
  let result = [], resultLen = 0;
  if (fauxIndentLength > 0) {
    result[resultLen++] = new LinePart(fauxIndentLength, "", 0);
  }
  for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {
    const endIndex = tokens.getEndOffset(tokenIndex);
    if (endIndex <= fauxIndentLength) {
      continue;
    }
    const type = tokens.getClassName(tokenIndex);
    if (endIndex >= len) {
      result[resultLen++] = new LinePart(len, type, 0);
      break;
    }
    result[resultLen++] = new LinePart(endIndex, type, 0);
  }
  return result;
}
function splitLargeTokens(lineContent, tokens, onlyAtSpaces) {
  let lastTokenEndIndex = 0;
  let result = [], resultLen = 0;
  if (onlyAtSpaces) {
    for (let i = 0, len = tokens.length; i < len; i++) {
      const token = tokens[i];
      const tokenEndIndex = token.endIndex;
      if (lastTokenEndIndex + 50 < tokenEndIndex) {
        const tokenType = token.type;
        const tokenMetadata = token.metadata;
        let lastSpaceOffset = -1;
        let currTokenStart = lastTokenEndIndex;
        for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {
          if (lineContent.charCodeAt(j) === 32) {
            lastSpaceOffset = j;
          }
          if (lastSpaceOffset !== -1 && j - currTokenStart >= 50) {
            result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata);
            currTokenStart = lastSpaceOffset + 1;
            lastSpaceOffset = -1;
          }
        }
        if (currTokenStart !== tokenEndIndex) {
          result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);
        }
      } else {
        result[resultLen++] = token;
      }
      lastTokenEndIndex = tokenEndIndex;
    }
  } else {
    for (let i = 0, len = tokens.length; i < len; i++) {
      const token = tokens[i];
      const tokenEndIndex = token.endIndex;
      let diff = tokenEndIndex - lastTokenEndIndex;
      if (diff > 50) {
        const tokenType = token.type;
        const tokenMetadata = token.metadata;
        const piecesCount = Math.ceil(diff / 50);
        for (let j = 1; j < piecesCount; j++) {
          let pieceEndIndex = lastTokenEndIndex + j * 50;
          result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata);
        }
        result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);
      } else {
        result[resultLen++] = token;
      }
      lastTokenEndIndex = tokenEndIndex;
    }
  }
  return result;
}
function _applyRenderWhitespace(input, lineContent, len, tokens) {
  const continuesWithWrappedLine = input.continuesWithWrappedLine;
  const fauxIndentLength = input.fauxIndentLength;
  const tabSize = input.tabSize;
  const startVisibleColumn = input.startVisibleColumn;
  const useMonospaceOptimizations = input.useMonospaceOptimizations;
  const selections = input.selectionsOnLine;
  const onlyBoundary = input.renderWhitespace === 1;
  const onlyTrailing = input.renderWhitespace === 3;
  const generateLinePartForEachWhitespace = input.renderSpaceWidth !== input.spaceWidth;
  let result = [], resultLen = 0;
  let tokenIndex = 0;
  let tokenType = tokens[tokenIndex].type;
  let tokenEndIndex = tokens[tokenIndex].endIndex;
  const tokensLength = tokens.length;
  let lineIsEmptyOrWhitespace = false;
  let firstNonWhitespaceIndex2 = firstNonWhitespaceIndex(lineContent);
  let lastNonWhitespaceIndex2;
  if (firstNonWhitespaceIndex2 === -1) {
    lineIsEmptyOrWhitespace = true;
    firstNonWhitespaceIndex2 = len;
    lastNonWhitespaceIndex2 = len;
  } else {
    lastNonWhitespaceIndex2 = lastNonWhitespaceIndex(lineContent);
  }
  let wasInWhitespace = false;
  let currentSelectionIndex = 0;
  let currentSelection = selections && selections[currentSelectionIndex];
  let tmpIndent = startVisibleColumn % tabSize;
  for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {
    const chCode = lineContent.charCodeAt(charIndex);
    if (currentSelection && charIndex >= currentSelection.endOffset) {
      currentSelectionIndex++;
      currentSelection = selections && selections[currentSelectionIndex];
    }
    let isInWhitespace;
    if (charIndex < firstNonWhitespaceIndex2 || charIndex > lastNonWhitespaceIndex2) {
      isInWhitespace = true;
    } else if (chCode === 9) {
      isInWhitespace = true;
    } else if (chCode === 32) {
      if (onlyBoundary) {
        if (wasInWhitespace) {
          isInWhitespace = true;
        } else {
          const nextChCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0;
          isInWhitespace = nextChCode === 32 || nextChCode === 9;
        }
      } else {
        isInWhitespace = true;
      }
    } else {
      isInWhitespace = false;
    }
    if (isInWhitespace && selections) {
      isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;
    }
    if (isInWhitespace && onlyTrailing) {
      isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex2;
    }
    if (wasInWhitespace) {
      if (!isInWhitespace || !useMonospaceOptimizations && tmpIndent >= tabSize) {
        if (generateLinePartForEachWhitespace) {
          const lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;
          for (let i = lastEndIndex + 1; i <= charIndex; i++) {
            result[resultLen++] = new LinePart(i, "mtkw", 1);
          }
        } else {
          result[resultLen++] = new LinePart(charIndex, "mtkw", 1);
        }
        tmpIndent = tmpIndent % tabSize;
      }
    } else {
      if (charIndex === tokenEndIndex || isInWhitespace && charIndex > fauxIndentLength) {
        result[resultLen++] = new LinePart(charIndex, tokenType, 0);
        tmpIndent = tmpIndent % tabSize;
      }
    }
    if (chCode === 9) {
      tmpIndent = tabSize;
    } else if (isFullWidthCharacter(chCode)) {
      tmpIndent += 2;
    } else {
      tmpIndent++;
    }
    wasInWhitespace = isInWhitespace;
    while (charIndex === tokenEndIndex) {
      tokenIndex++;
      if (tokenIndex < tokensLength) {
        tokenType = tokens[tokenIndex].type;
        tokenEndIndex = tokens[tokenIndex].endIndex;
      }
    }
  }
  let generateWhitespace = false;
  if (wasInWhitespace) {
    if (continuesWithWrappedLine && onlyBoundary) {
      let lastCharCode = len > 0 ? lineContent.charCodeAt(len - 1) : 0;
      let prevCharCode = len > 1 ? lineContent.charCodeAt(len - 2) : 0;
      let isSingleTrailingSpace = lastCharCode === 32 && (prevCharCode !== 32 && prevCharCode !== 9);
      if (!isSingleTrailingSpace) {
        generateWhitespace = true;
      }
    } else {
      generateWhitespace = true;
    }
  }
  if (generateWhitespace) {
    if (generateLinePartForEachWhitespace) {
      const lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;
      for (let i = lastEndIndex + 1; i <= len; i++) {
        result[resultLen++] = new LinePart(i, "mtkw", 1);
      }
    } else {
      result[resultLen++] = new LinePart(len, "mtkw", 1);
    }
  } else {
    result[resultLen++] = new LinePart(len, tokenType, 0);
  }
  return result;
}
function _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {
  _lineDecorations.sort(LineDecoration.compare);
  const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);
  const lineDecorationsLen = lineDecorations.length;
  let lineDecorationIndex = 0;
  let result = [], resultLen = 0, lastResultEndIndex = 0;
  for (let tokenIndex = 0, len2 = tokens.length; tokenIndex < len2; tokenIndex++) {
    const token = tokens[tokenIndex];
    const tokenEndIndex = token.endIndex;
    const tokenType = token.type;
    const tokenMetadata = token.metadata;
    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {
      const lineDecoration = lineDecorations[lineDecorationIndex];
      if (lineDecoration.startOffset > lastResultEndIndex) {
        lastResultEndIndex = lineDecoration.startOffset;
        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);
      }
      if (lineDecoration.endOffset + 1 <= tokenEndIndex) {
        lastResultEndIndex = lineDecoration.endOffset + 1;
        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + " " + lineDecoration.className, tokenMetadata | lineDecoration.metadata);
        lineDecorationIndex++;
      } else {
        lastResultEndIndex = tokenEndIndex;
        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + " " + lineDecoration.className, tokenMetadata | lineDecoration.metadata);
        break;
      }
    }
    if (tokenEndIndex > lastResultEndIndex) {
      lastResultEndIndex = tokenEndIndex;
      result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);
    }
  }
  const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;
  if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {
    let classNames = [];
    let metadata = 0;
    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {
      classNames.push(lineDecorations[lineDecorationIndex].className);
      metadata |= lineDecorations[lineDecorationIndex].metadata;
      lineDecorationIndex++;
    }
    result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(" "), metadata);
  }
  return result;
}
function _renderLine(input, sb) {
  const fontIsMonospace = input.fontIsMonospace;
  const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;
  const containsForeignElements = input.containsForeignElements;
  const lineContent = input.lineContent;
  const len = input.len;
  const isOverflowing = input.isOverflowing;
  const parts = input.parts;
  const fauxIndentLength = input.fauxIndentLength;
  const tabSize = input.tabSize;
  const startVisibleColumn = input.startVisibleColumn;
  const containsRTL2 = input.containsRTL;
  const spaceWidth = input.spaceWidth;
  const renderSpaceCharCode = input.renderSpaceCharCode;
  const renderWhitespace = input.renderWhitespace;
  const renderControlCharacters = input.renderControlCharacters;
  const characterMapping = new CharacterMapping(len + 1, parts.length);
  let charIndex = 0;
  let visibleColumn = startVisibleColumn;
  let charOffsetInPart = 0;
  let partDisplacement = 0;
  let prevPartContentCnt = 0;
  let partAbsoluteOffset = 0;
  if (containsRTL2) {
    sb.appendASCIIString('<span dir="ltr">');
  } else {
    sb.appendASCIIString("<span>");
  }
  for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {
    partAbsoluteOffset += prevPartContentCnt;
    const part = parts[partIndex];
    const partEndIndex = part.endIndex;
    const partType = part.type;
    const partRendersWhitespace = renderWhitespace !== 0 && part.isWhitespace();
    const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === "mtkw" || !containsForeignElements);
    const partIsEmptyAndHasPseudoAfter = charIndex === partEndIndex && part.metadata === 4;
    charOffsetInPart = 0;
    sb.appendASCIIString('<span class="');
    sb.appendASCIIString(partRendersWhitespaceWithWidth ? "mtkz" : partType);
    sb.appendASCII(34);
    if (partRendersWhitespace) {
      let partContentCnt = 0;
      {
        let _charIndex = charIndex;
        let _visibleColumn = visibleColumn;
        for (; _charIndex < partEndIndex; _charIndex++) {
          const charCode = lineContent.charCodeAt(_charIndex);
          const charWidth = (charCode === 9 ? tabSize - _visibleColumn % tabSize : 1) | 0;
          partContentCnt += charWidth;
          if (_charIndex >= fauxIndentLength) {
            _visibleColumn += charWidth;
          }
        }
      }
      if (partRendersWhitespaceWithWidth) {
        sb.appendASCIIString(' style="width:');
        sb.appendASCIIString(String(spaceWidth * partContentCnt));
        sb.appendASCIIString('px"');
      }
      sb.appendASCII(62);
      for (; charIndex < partEndIndex; charIndex++) {
        characterMapping.setPartData(charIndex, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);
        partDisplacement = 0;
        const charCode = lineContent.charCodeAt(charIndex);
        let charWidth;
        if (charCode === 9) {
          charWidth = tabSize - visibleColumn % tabSize | 0;
          if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {
            sb.write1(8594);
          } else {
            sb.write1(65515);
          }
          for (let space = 2; space <= charWidth; space++) {
            sb.write1(160);
          }
        } else {
          charWidth = 1;
          sb.write1(renderSpaceCharCode);
        }
        charOffsetInPart += charWidth;
        if (charIndex >= fauxIndentLength) {
          visibleColumn += charWidth;
        }
      }
      prevPartContentCnt = partContentCnt;
    } else {
      let partContentCnt = 0;
      sb.appendASCII(62);
      for (; charIndex < partEndIndex; charIndex++) {
        characterMapping.setPartData(charIndex, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);
        partDisplacement = 0;
        const charCode = lineContent.charCodeAt(charIndex);
        let producedCharacters = 1;
        let charWidth = 1;
        switch (charCode) {
          case 9:
            producedCharacters = tabSize - visibleColumn % tabSize;
            charWidth = producedCharacters;
            for (let space = 1; space <= producedCharacters; space++) {
              sb.write1(160);
            }
            break;
          case 32:
            sb.write1(160);
            break;
          case 60:
            sb.appendASCIIString("&lt;");
            break;
          case 62:
            sb.appendASCIIString("&gt;");
            break;
          case 38:
            sb.appendASCIIString("&amp;");
            break;
          case 0:
            sb.appendASCIIString("&#00;");
            break;
          case 65279:
          case 8232:
          case 8233:
          case 133:
            sb.write1(65533);
            break;
          default:
            if (isFullWidthCharacter(charCode)) {
              charWidth++;
            }
            if (renderControlCharacters && charCode < 32) {
              sb.write1(9216 + charCode);
            } else {
              sb.write1(charCode);
            }
        }
        charOffsetInPart += producedCharacters;
        partContentCnt += producedCharacters;
        if (charIndex >= fauxIndentLength) {
          visibleColumn += charWidth;
        }
      }
      prevPartContentCnt = partContentCnt;
    }
    if (partIsEmptyAndHasPseudoAfter) {
      partDisplacement++;
    } else {
      partDisplacement = 0;
    }
    sb.appendASCIIString("</span>");
  }
  characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);
  if (isOverflowing) {
    sb.appendASCIIString("<span>&hellip;</span>");
  }
  sb.appendASCIIString("</span>");
  return new RenderLineOutput(characterMapping, containsRTL2, containsForeignElements);
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModel.js
var Viewport = class {
  constructor(top, left, width, height) {
    this.top = top | 0;
    this.left = left | 0;
    this.width = width | 0;
    this.height = height | 0;
  }
};
var MinimapLinesRenderingData = class {
  constructor(tabSize, data) {
    this.tabSize = tabSize;
    this.data = data;
  }
};
var ViewLineData = class {
  constructor(content, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens) {
    this.content = content;
    this.continuesWithWrappedLine = continuesWithWrappedLine;
    this.minColumn = minColumn;
    this.maxColumn = maxColumn;
    this.startVisibleColumn = startVisibleColumn;
    this.tokens = tokens;
  }
};
var ViewLineRenderingData = class {
  constructor(minColumn, maxColumn, content, continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, tokens, inlineDecorations, tabSize, startVisibleColumn) {
    this.minColumn = minColumn;
    this.maxColumn = maxColumn;
    this.content = content;
    this.continuesWithWrappedLine = continuesWithWrappedLine;
    this.isBasicASCII = ViewLineRenderingData.isBasicASCII(content, mightContainNonBasicASCII);
    this.containsRTL = ViewLineRenderingData.containsRTL(content, this.isBasicASCII, mightContainRTL);
    this.tokens = tokens;
    this.inlineDecorations = inlineDecorations;
    this.tabSize = tabSize;
    this.startVisibleColumn = startVisibleColumn;
  }
  static isBasicASCII(lineContent, mightContainNonBasicASCII) {
    if (mightContainNonBasicASCII) {
      return isBasicASCII(lineContent);
    }
    return true;
  }
  static containsRTL(lineContent, isBasicASCII2, mightContainRTL) {
    if (!isBasicASCII2 && mightContainRTL) {
      return containsRTL(lineContent);
    }
    return false;
  }
};
var InlineDecoration = class {
  constructor(range2, inlineClassName, type) {
    this.range = range2;
    this.inlineClassName = inlineClassName;
    this.type = type;
  }
};
var ViewModelDecoration = class {
  constructor(range2, options) {
    this.range = range2;
    this.options = options;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCommon.js
function isFuzzyActionArr(what) {
  return Array.isArray(what);
}
function isFuzzyAction(what) {
  return !isFuzzyActionArr(what);
}
function isString2(what) {
  return typeof what === "string";
}
function isIAction(what) {
  return !isString2(what);
}
function empty(s) {
  return s ? false : true;
}
function fixCase(lexer, str) {
  return lexer.ignoreCase && str ? str.toLowerCase() : str;
}
function sanitize(s) {
  return s.replace(/[&<>'"_]/g, "-");
}
function log(lexer, msg) {
  console.log(`${lexer.languageId}: ${msg}`);
}
function createError(lexer, msg) {
  return new Error(`${lexer.languageId}: ${msg}`);
}
function substituteMatches(lexer, str, id, matches, state) {
  const re = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
  let stateMatches = null;
  return str.replace(re, function(full, sub, dollar, hash, n, s, attr, ofs, total) {
    if (!empty(dollar)) {
      return "$";
    }
    if (!empty(hash)) {
      return fixCase(lexer, id);
    }
    if (!empty(n) && n < matches.length) {
      return fixCase(lexer, matches[n]);
    }
    if (!empty(attr) && lexer && typeof lexer[attr] === "string") {
      return lexer[attr];
    }
    if (stateMatches === null) {
      stateMatches = state.split(".");
      stateMatches.unshift(state);
    }
    if (!empty(s) && s < stateMatches.length) {
      return fixCase(lexer, stateMatches[s]);
    }
    return "";
  });
}
function findRules(lexer, inState) {
  let state = inState;
  while (state && state.length > 0) {
    const rules = lexer.tokenizer[state];
    if (rules) {
      return rules;
    }
    const idx = state.lastIndexOf(".");
    if (idx < 0) {
      state = null;
    } else {
      state = state.substr(0, idx);
    }
  }
  return null;
}
function stateExists(lexer, inState) {
  let state = inState;
  while (state && state.length > 0) {
    const exist = lexer.stateNames[state];
    if (exist) {
      return true;
    }
    const idx = state.lastIndexOf(".");
    if (idx < 0) {
      state = null;
    } else {
      state = state.substr(0, idx);
    }
  }
  return false;
}

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js
var CACHE_STACK_DEPTH = 5;
var MonarchStackElementFactory = class {
  constructor(maxCacheDepth) {
    this._maxCacheDepth = maxCacheDepth;
    this._entries = Object.create(null);
  }
  static create(parent, state) {
    return this._INSTANCE.create(parent, state);
  }
  create(parent, state) {
    if (parent !== null && parent.depth >= this._maxCacheDepth) {
      return new MonarchStackElement(parent, state);
    }
    let stackElementId = MonarchStackElement.getStackElementId(parent);
    if (stackElementId.length > 0) {
      stackElementId += "|";
    }
    stackElementId += state;
    let result = this._entries[stackElementId];
    if (result) {
      return result;
    }
    result = new MonarchStackElement(parent, state);
    this._entries[stackElementId] = result;
    return result;
  }
};
MonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);
var MonarchStackElement = class {
  constructor(parent, state) {
    this.parent = parent;
    this.state = state;
    this.depth = (this.parent ? this.parent.depth : 0) + 1;
  }
  static getStackElementId(element) {
    let result = "";
    while (element !== null) {
      if (result.length > 0) {
        result += "|";
      }
      result += element.state;
      element = element.parent;
    }
    return result;
  }
  static _equals(a, b) {
    while (a !== null && b !== null) {
      if (a === b) {
        return true;
      }
      if (a.state !== b.state) {
        return false;
      }
      a = a.parent;
      b = b.parent;
    }
    if (a === null && b === null) {
      return true;
    }
    return false;
  }
  equals(other) {
    return MonarchStackElement._equals(this, other);
  }
  push(state) {
    return MonarchStackElementFactory.create(this, state);
  }
  pop() {
    return this.parent;
  }
  popall() {
    let result = this;
    while (result.parent) {
      result = result.parent;
    }
    return result;
  }
  switchTo(state) {
    return MonarchStackElementFactory.create(this.parent, state);
  }
};
var EmbeddedModeData = class {
  constructor(modeId, state) {
    this.modeId = modeId;
    this.state = state;
  }
  equals(other) {
    return this.modeId === other.modeId && this.state.equals(other.state);
  }
  clone() {
    let stateClone = this.state.clone();
    if (stateClone === this.state) {
      return this;
    }
    return new EmbeddedModeData(this.modeId, this.state);
  }
};
var MonarchLineStateFactory = class {
  constructor(maxCacheDepth) {
    this._maxCacheDepth = maxCacheDepth;
    this._entries = Object.create(null);
  }
  static create(stack, embeddedModeData) {
    return this._INSTANCE.create(stack, embeddedModeData);
  }
  create(stack, embeddedModeData) {
    if (embeddedModeData !== null) {
      return new MonarchLineState(stack, embeddedModeData);
    }
    if (stack !== null && stack.depth >= this._maxCacheDepth) {
      return new MonarchLineState(stack, embeddedModeData);
    }
    let stackElementId = MonarchStackElement.getStackElementId(stack);
    let result = this._entries[stackElementId];
    if (result) {
      return result;
    }
    result = new MonarchLineState(stack, null);
    this._entries[stackElementId] = result;
    return result;
  }
};
MonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);
var MonarchLineState = class {
  constructor(stack, embeddedModeData) {
    this.stack = stack;
    this.embeddedModeData = embeddedModeData;
  }
  clone() {
    let embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null;
    if (embeddedModeDataClone === this.embeddedModeData) {
      return this;
    }
    return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);
  }
  equals(other) {
    if (!(other instanceof MonarchLineState)) {
      return false;
    }
    if (!this.stack.equals(other.stack)) {
      return false;
    }
    if (this.embeddedModeData === null && other.embeddedModeData === null) {
      return true;
    }
    if (this.embeddedModeData === null || other.embeddedModeData === null) {
      return false;
    }
    return this.embeddedModeData.equals(other.embeddedModeData);
  }
};
var MonarchClassicTokensCollector = class {
  constructor() {
    this._tokens = [];
    this._language = null;
    this._lastTokenType = null;
    this._lastTokenLanguage = null;
  }
  enterMode(startOffset, modeId) {
    this._language = modeId;
  }
  emit(startOffset, type) {
    if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {
      return;
    }
    this._lastTokenType = type;
    this._lastTokenLanguage = this._language;
    this._tokens.push(new Token(startOffset, type, this._language));
  }
  nestedModeTokenize(embeddedModeLine, embeddedModeData, offsetDelta) {
    const nestedModeId = embeddedModeData.modeId;
    const embeddedModeState = embeddedModeData.state;
    const nestedModeTokenizationSupport = TokenizationRegistry.get(nestedModeId);
    if (!nestedModeTokenizationSupport) {
      this.enterMode(offsetDelta, nestedModeId);
      this.emit(offsetDelta, "");
      return embeddedModeState;
    }
    let nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, embeddedModeState, offsetDelta);
    this._tokens = this._tokens.concat(nestedResult.tokens);
    this._lastTokenType = null;
    this._lastTokenLanguage = null;
    this._language = null;
    return nestedResult.endState;
  }
  finalize(endState) {
    return new TokenizationResult(this._tokens, endState);
  }
};
var MonarchModernTokensCollector = class {
  constructor(modeService, theme) {
    this._modeService = modeService;
    this._theme = theme;
    this._prependTokens = null;
    this._tokens = [];
    this._currentLanguageId = 0;
    this._lastTokenMetadata = 0;
  }
  enterMode(startOffset, modeId) {
    this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;
  }
  emit(startOffset, type) {
    let metadata = this._theme.match(this._currentLanguageId, type);
    if (this._lastTokenMetadata === metadata) {
      return;
    }
    this._lastTokenMetadata = metadata;
    this._tokens.push(startOffset);
    this._tokens.push(metadata);
  }
  static _merge(a, b, c) {
    let aLen = a !== null ? a.length : 0;
    let bLen = b.length;
    let cLen = c !== null ? c.length : 0;
    if (aLen === 0 && bLen === 0 && cLen === 0) {
      return new Uint32Array(0);
    }
    if (aLen === 0 && bLen === 0) {
      return c;
    }
    if (bLen === 0 && cLen === 0) {
      return a;
    }
    let result = new Uint32Array(aLen + bLen + cLen);
    if (a !== null) {
      result.set(a);
    }
    for (let i = 0; i < bLen; i++) {
      result[aLen + i] = b[i];
    }
    if (c !== null) {
      result.set(c, aLen + bLen);
    }
    return result;
  }
  nestedModeTokenize(embeddedModeLine, embeddedModeData, offsetDelta) {
    const nestedModeId = embeddedModeData.modeId;
    const embeddedModeState = embeddedModeData.state;
    const nestedModeTokenizationSupport = TokenizationRegistry.get(nestedModeId);
    if (!nestedModeTokenizationSupport) {
      this.enterMode(offsetDelta, nestedModeId);
      this.emit(offsetDelta, "");
      return embeddedModeState;
    }
    let nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, embeddedModeState, offsetDelta);
    this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);
    this._tokens = [];
    this._currentLanguageId = 0;
    this._lastTokenMetadata = 0;
    return nestedResult.endState;
  }
  finalize(endState) {
    return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);
  }
};
var MonarchTokenizer = class {
  constructor(modeService, standaloneThemeService, modeId, lexer) {
    this._modeService = modeService;
    this._standaloneThemeService = standaloneThemeService;
    this._modeId = modeId;
    this._lexer = lexer;
    this._embeddedModes = Object.create(null);
    this.embeddedLoaded = Promise.resolve(void 0);
    let emitting = false;
    this._tokenizationRegistryListener = TokenizationRegistry.onDidChange((e) => {
      if (emitting) {
        return;
      }
      let isOneOfMyEmbeddedModes = false;
      for (let i = 0, len = e.changedLanguages.length; i < len; i++) {
        let language = e.changedLanguages[i];
        if (this._embeddedModes[language]) {
          isOneOfMyEmbeddedModes = true;
          break;
        }
      }
      if (isOneOfMyEmbeddedModes) {
        emitting = true;
        TokenizationRegistry.fire([this._modeId]);
        emitting = false;
      }
    });
  }
  dispose() {
    this._tokenizationRegistryListener.dispose();
  }
  getLoadStatus() {
    let promises = [];
    for (let nestedModeId in this._embeddedModes) {
      const tokenizationSupport = TokenizationRegistry.get(nestedModeId);
      if (tokenizationSupport) {
        if (tokenizationSupport instanceof MonarchTokenizer) {
          const nestedModeStatus = tokenizationSupport.getLoadStatus();
          if (nestedModeStatus.loaded === false) {
            promises.push(nestedModeStatus.promise);
          }
        }
        continue;
      }
      const tokenizationSupportPromise = TokenizationRegistry.getPromise(nestedModeId);
      if (tokenizationSupportPromise) {
        promises.push(tokenizationSupportPromise);
      }
    }
    if (promises.length === 0) {
      return {
        loaded: true
      };
    }
    return {
      loaded: false,
      promise: Promise.all(promises).then((_) => void 0)
    };
  }
  getInitialState() {
    let rootState = MonarchStackElementFactory.create(null, this._lexer.start);
    return MonarchLineStateFactory.create(rootState, null);
  }
  tokenize(line, lineState, offsetDelta) {
    let tokensCollector = new MonarchClassicTokensCollector();
    let endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);
    return tokensCollector.finalize(endLineState);
  }
  tokenize2(line, lineState, offsetDelta) {
    let tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getColorTheme().tokenTheme);
    let endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);
    return tokensCollector.finalize(endLineState);
  }
  _tokenize(line, lineState, offsetDelta, collector) {
    if (lineState.embeddedModeData) {
      return this._nestedTokenize(line, lineState, offsetDelta, collector);
    } else {
      return this._myTokenize(line, lineState, offsetDelta, collector);
    }
  }
  _findLeavingNestedModeOffset(line, state) {
    let rules = this._lexer.tokenizer[state.stack.state];
    if (!rules) {
      rules = findRules(this._lexer, state.stack.state);
      if (!rules) {
        throw createError(this._lexer, "tokenizer state is not defined: " + state.stack.state);
      }
    }
    let popOffset = -1;
    let hasEmbeddedPopRule = false;
    for (const rule of rules) {
      if (!isIAction(rule.action) || rule.action.nextEmbedded !== "@pop") {
        continue;
      }
      hasEmbeddedPopRule = true;
      let regex = rule.regex;
      let regexSource = rule.regex.source;
      if (regexSource.substr(0, 4) === "^(?:" && regexSource.substr(regexSource.length - 1, 1) === ")") {
        let flags = (regex.ignoreCase ? "i" : "") + (regex.unicode ? "u" : "");
        regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);
      }
      let result = line.search(regex);
      if (result === -1 || result !== 0 && rule.matchOnlyAtLineStart) {
        continue;
      }
      if (popOffset === -1 || result < popOffset) {
        popOffset = result;
      }
    }
    if (!hasEmbeddedPopRule) {
      throw createError(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + state.stack.state);
    }
    return popOffset;
  }
  _nestedTokenize(line, lineState, offsetDelta, tokensCollector) {
    let popOffset = this._findLeavingNestedModeOffset(line, lineState);
    if (popOffset === -1) {
      let nestedEndState = tokensCollector.nestedModeTokenize(line, lineState.embeddedModeData, offsetDelta);
      return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));
    }
    let nestedModeLine = line.substring(0, popOffset);
    if (nestedModeLine.length > 0) {
      tokensCollector.nestedModeTokenize(nestedModeLine, lineState.embeddedModeData, offsetDelta);
    }
    let restOfTheLine = line.substring(popOffset);
    return this._myTokenize(restOfTheLine, lineState, offsetDelta + popOffset, tokensCollector);
  }
  _safeRuleName(rule) {
    if (rule) {
      return rule.name;
    }
    return "(unknown)";
  }
  _myTokenize(line, lineState, offsetDelta, tokensCollector) {
    tokensCollector.enterMode(offsetDelta, this._modeId);
    const lineLength = line.length;
    let embeddedModeData = lineState.embeddedModeData;
    let stack = lineState.stack;
    let pos = 0;
    let groupMatching = null;
    let forceEvaluation = true;
    while (forceEvaluation || pos < lineLength) {
      const pos0 = pos;
      const stackLen0 = stack.depth;
      const groupLen0 = groupMatching ? groupMatching.groups.length : 0;
      const state = stack.state;
      let matches = null;
      let matched = null;
      let action = null;
      let rule = null;
      let enteringEmbeddedMode = null;
      if (groupMatching) {
        matches = groupMatching.matches;
        const groupEntry = groupMatching.groups.shift();
        matched = groupEntry.matched;
        action = groupEntry.action;
        rule = groupMatching.rule;
        if (groupMatching.groups.length === 0) {
          groupMatching = null;
        }
      } else {
        if (!forceEvaluation && pos >= lineLength) {
          break;
        }
        forceEvaluation = false;
        let rules = this._lexer.tokenizer[state];
        if (!rules) {
          rules = findRules(this._lexer, state);
          if (!rules) {
            throw createError(this._lexer, "tokenizer state is not defined: " + state);
          }
        }
        let restOfLine = line.substr(pos);
        for (const rule2 of rules) {
          if (pos === 0 || !rule2.matchOnlyAtLineStart) {
            matches = restOfLine.match(rule2.regex);
            if (matches) {
              matched = matches[0];
              action = rule2.action;
              break;
            }
          }
        }
      }
      if (!matches) {
        matches = [""];
        matched = "";
      }
      if (!action) {
        if (pos < lineLength) {
          matches = [line.charAt(pos)];
          matched = matches[0];
        }
        action = this._lexer.defaultToken;
      }
      if (matched === null) {
        break;
      }
      pos += matched.length;
      while (isFuzzyAction(action) && isIAction(action) && action.test) {
        action = action.test(matched, matches, state, pos === lineLength);
      }
      let result = null;
      if (typeof action === "string" || Array.isArray(action)) {
        result = action;
      } else if (action.group) {
        result = action.group;
      } else if (action.token !== null && action.token !== void 0) {
        if (action.tokenSubst) {
          result = substituteMatches(this._lexer, action.token, matched, matches, state);
        } else {
          result = action.token;
        }
        if (action.nextEmbedded) {
          if (action.nextEmbedded === "@pop") {
            if (!embeddedModeData) {
              throw createError(this._lexer, "cannot pop embedded mode if not inside one");
            }
            embeddedModeData = null;
          } else if (embeddedModeData) {
            throw createError(this._lexer, "cannot enter embedded mode from within an embedded mode");
          } else {
            enteringEmbeddedMode = substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);
          }
        }
        if (action.goBack) {
          pos = Math.max(0, pos - action.goBack);
        }
        if (action.switchTo && typeof action.switchTo === "string") {
          let nextState = substituteMatches(this._lexer, action.switchTo, matched, matches, state);
          if (nextState[0] === "@") {
            nextState = nextState.substr(1);
          }
          if (!findRules(this._lexer, nextState)) {
            throw createError(this._lexer, "trying to switch to a state '" + nextState + "' that is undefined in rule: " + this._safeRuleName(rule));
          } else {
            stack = stack.switchTo(nextState);
          }
        } else if (action.transform && typeof action.transform === "function") {
          throw createError(this._lexer, "action.transform not supported");
        } else if (action.next) {
          if (action.next === "@push") {
            if (stack.depth >= this._lexer.maxStack) {
              throw createError(this._lexer, "maximum tokenizer stack size reached: [" + stack.state + "," + stack.parent.state + ",...]");
            } else {
              stack = stack.push(state);
            }
          } else if (action.next === "@pop") {
            if (stack.depth <= 1) {
              throw createError(this._lexer, "trying to pop an empty stack in rule: " + this._safeRuleName(rule));
            } else {
              stack = stack.pop();
            }
          } else if (action.next === "@popall") {
            stack = stack.popall();
          } else {
            let nextState = substituteMatches(this._lexer, action.next, matched, matches, state);
            if (nextState[0] === "@") {
              nextState = nextState.substr(1);
            }
            if (!findRules(this._lexer, nextState)) {
              throw createError(this._lexer, "trying to set a next state '" + nextState + "' that is undefined in rule: " + this._safeRuleName(rule));
            } else {
              stack = stack.push(nextState);
            }
          }
        }
        if (action.log && typeof action.log === "string") {
          log(this._lexer, this._lexer.languageId + ": " + substituteMatches(this._lexer, action.log, matched, matches, state));
        }
      }
      if (result === null) {
        throw createError(this._lexer, "lexer rule has no well-defined action in rule: " + this._safeRuleName(rule));
      }
      const computeNewStateForEmbeddedMode = (enteringEmbeddedMode2) => {
        let enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode2);
        if (enteringEmbeddedModeId) {
          enteringEmbeddedMode2 = enteringEmbeddedModeId;
        }
        const embeddedModeData2 = this._getNestedEmbeddedModeData(enteringEmbeddedMode2);
        if (pos < lineLength) {
          const restOfLine = line.substr(pos);
          return this._nestedTokenize(restOfLine, MonarchLineStateFactory.create(stack, embeddedModeData2), offsetDelta + pos, tokensCollector);
        } else {
          return MonarchLineStateFactory.create(stack, embeddedModeData2);
        }
      };
      if (Array.isArray(result)) {
        if (groupMatching && groupMatching.groups.length > 0) {
          throw createError(this._lexer, "groups cannot be nested: " + this._safeRuleName(rule));
        }
        if (matches.length !== result.length + 1) {
          throw createError(this._lexer, "matched number of groups does not match the number of actions in rule: " + this._safeRuleName(rule));
        }
        let totalLen = 0;
        for (let i = 1; i < matches.length; i++) {
          totalLen += matches[i].length;
        }
        if (totalLen !== matched.length) {
          throw createError(this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + this._safeRuleName(rule));
        }
        groupMatching = {
          rule,
          matches,
          groups: []
        };
        for (let i = 0; i < result.length; i++) {
          groupMatching.groups[i] = {
            action: result[i],
            matched: matches[i + 1]
          };
        }
        pos -= matched.length;
        continue;
      } else {
        if (result === "@rematch") {
          pos -= matched.length;
          matched = "";
          matches = null;
          result = "";
          if (enteringEmbeddedMode !== null) {
            return computeNewStateForEmbeddedMode(enteringEmbeddedMode);
          }
        }
        if (matched.length === 0) {
          if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {
            continue;
          } else {
            throw createError(this._lexer, "no progress in tokenizer in rule: " + this._safeRuleName(rule));
          }
        }
        let tokenType = null;
        if (isString2(result) && result.indexOf("@brackets") === 0) {
          let rest = result.substr("@brackets".length);
          let bracket = findBracket(this._lexer, matched);
          if (!bracket) {
            throw createError(this._lexer, "@brackets token returned but no bracket defined as: " + matched);
          }
          tokenType = sanitize(bracket.token + rest);
        } else {
          let token = result === "" ? "" : result + this._lexer.tokenPostfix;
          tokenType = sanitize(token);
        }
        tokensCollector.emit(pos0 + offsetDelta, tokenType);
      }
      if (enteringEmbeddedMode !== null) {
        return computeNewStateForEmbeddedMode(enteringEmbeddedMode);
      }
    }
    return MonarchLineStateFactory.create(stack, embeddedModeData);
  }
  _getNestedEmbeddedModeData(mimetypeOrModeId) {
    let nestedModeId = this._locateMode(mimetypeOrModeId);
    if (nestedModeId) {
      let tokenizationSupport = TokenizationRegistry.get(nestedModeId);
      if (tokenizationSupport) {
        return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());
      }
    }
    return new EmbeddedModeData(nestedModeId || NULL_MODE_ID, NULL_STATE);
  }
  _locateMode(mimetypeOrModeId) {
    if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {
      return null;
    }
    if (mimetypeOrModeId === this._modeId) {
      return mimetypeOrModeId;
    }
    let modeId = this._modeService.getModeId(mimetypeOrModeId);
    if (modeId) {
      this._modeService.triggerMode(modeId);
      this._embeddedModes[modeId] = true;
    }
    return modeId;
  }
};
function findBracket(lexer, matched) {
  if (!matched) {
    return null;
  }
  matched = fixCase(lexer, matched);
  let brackets = lexer.brackets;
  for (const bracket of brackets) {
    if (bracket.open === matched) {
      return {token: bracket.token, bracketType: 1};
    } else if (bracket.close === matched) {
      return {token: bracket.token, bracketType: -1};
    }
  }
  return null;
}
function createTokenizationSupport(modeService, standaloneThemeService, modeId, lexer) {
  return new MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer);
}

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/colorizer.js
var Colorizer = class {
  static colorizeElement(themeService, modeService, domNode, options) {
    options = options || {};
    let theme = options.theme || "vs";
    let mimeType = options.mimeType || domNode.getAttribute("lang") || domNode.getAttribute("data-lang");
    if (!mimeType) {
      console.error("Mode not detected");
      return Promise.resolve();
    }
    themeService.setTheme(theme);
    let text = domNode.firstChild ? domNode.firstChild.nodeValue : "";
    domNode.className += " " + theme;
    let render = (str) => {
      domNode.innerHTML = str;
    };
    return this.colorize(modeService, text || "", mimeType, options).then(render, (err) => console.error(err));
  }
  static colorize(modeService, text, mimeType, options) {
    let tabSize = 4;
    if (options && typeof options.tabSize === "number") {
      tabSize = options.tabSize;
    }
    if (startsWithUTF8BOM(text)) {
      text = text.substr(1);
    }
    let lines = text.split(/\r\n|\r|\n/);
    let language = modeService.getModeId(mimeType);
    if (!language) {
      return Promise.resolve(_fakeColorize(lines, tabSize));
    }
    modeService.triggerMode(language);
    const tokenizationSupport = TokenizationRegistry.get(language);
    if (tokenizationSupport) {
      return _colorize(lines, tabSize, tokenizationSupport);
    }
    const tokenizationSupportPromise = TokenizationRegistry.getPromise(language);
    if (tokenizationSupportPromise) {
      return new Promise((resolve2, reject) => {
        tokenizationSupportPromise.then((tokenizationSupport2) => {
          _colorize(lines, tabSize, tokenizationSupport2).then(resolve2, reject);
        }, reject);
      });
    }
    return new Promise((resolve2, reject) => {
      let listener = null;
      let timeout2 = null;
      const execute = () => {
        if (listener) {
          listener.dispose();
          listener = null;
        }
        if (timeout2) {
          timeout2.dispose();
          timeout2 = null;
        }
        const tokenizationSupport2 = TokenizationRegistry.get(language);
        if (tokenizationSupport2) {
          _colorize(lines, tabSize, tokenizationSupport2).then(resolve2, reject);
          return;
        }
        resolve2(_fakeColorize(lines, tabSize));
      };
      timeout2 = new TimeoutTimer();
      timeout2.cancelAndSet(execute, 500);
      listener = TokenizationRegistry.onDidChange((e) => {
        if (e.changedLanguages.indexOf(language) >= 0) {
          execute();
        }
      });
    });
  }
  static colorizeLine(line, mightContainNonBasicASCII, mightContainRTL, tokens, tabSize = 4) {
    const isBasicASCII2 = ViewLineRenderingData.isBasicASCII(line, mightContainNonBasicASCII);
    const containsRTL2 = ViewLineRenderingData.containsRTL(line, isBasicASCII2, mightContainRTL);
    let renderResult = renderViewLine2(new RenderLineInput(false, true, line, false, isBasicASCII2, containsRTL2, 0, tokens, [], tabSize, 0, 0, 0, 0, -1, "none", false, false, null));
    return renderResult.html;
  }
  static colorizeModelLine(model2, lineNumber, tabSize = 4) {
    let content = model2.getLineContent(lineNumber);
    model2.forceTokenization(lineNumber);
    let tokens = model2.getLineTokens(lineNumber);
    let inflatedTokens = tokens.inflate();
    return this.colorizeLine(content, model2.mightContainNonBasicASCII(), model2.mightContainRTL(), inflatedTokens, tabSize);
  }
};
function _colorize(lines, tabSize, tokenizationSupport) {
  return new Promise((c, e) => {
    const execute = () => {
      const result = _actualColorize(lines, tabSize, tokenizationSupport);
      if (tokenizationSupport instanceof MonarchTokenizer) {
        const status2 = tokenizationSupport.getLoadStatus();
        if (status2.loaded === false) {
          status2.promise.then(execute, e);
          return;
        }
      }
      c(result);
    };
    execute();
  });
}
function _fakeColorize(lines, tabSize) {
  let html = [];
  const defaultMetadata = (0 << 11 | 1 << 14 | 2 << 23) >>> 0;
  const tokens = new Uint32Array(2);
  tokens[0] = 0;
  tokens[1] = defaultMetadata;
  for (let i = 0, length = lines.length; i < length; i++) {
    let line = lines[i];
    tokens[0] = line.length;
    const lineTokens = new LineTokens(tokens, line);
    const isBasicASCII2 = ViewLineRenderingData.isBasicASCII(line, true);
    const containsRTL2 = ViewLineRenderingData.containsRTL(line, isBasicASCII2, true);
    let renderResult = renderViewLine2(new RenderLineInput(false, true, line, false, isBasicASCII2, containsRTL2, 0, lineTokens, [], tabSize, 0, 0, 0, 0, -1, "none", false, false, null));
    html = html.concat(renderResult.html);
    html.push("<br/>");
  }
  return html.join("");
}
function _actualColorize(lines, tabSize, tokenizationSupport) {
  let html = [];
  let state = tokenizationSupport.getInitialState();
  for (let i = 0, length = lines.length; i < length; i++) {
    let line = lines[i];
    let tokenizeResult = tokenizationSupport.tokenize2(line, state, 0);
    LineTokens.convertToEndOffset(tokenizeResult.tokens, line.length);
    let lineTokens = new LineTokens(tokenizeResult.tokens, line);
    const isBasicASCII2 = ViewLineRenderingData.isBasicASCII(line, true);
    const containsRTL2 = ViewLineRenderingData.containsRTL(line, isBasicASCII2, true);
    let renderResult = renderViewLine2(new RenderLineInput(false, true, line, false, isBasicASCII2, containsRTL2, 0, lineTokens.inflate(), [], tabSize, 0, 0, 0, 0, -1, "none", false, false, null));
    html = html.concat(renderResult.html);
    html.push("<br/>");
    state = tokenizeResult.endState;
  }
  return html.join("");
}

// ../../node_modules/monaco-editor/esm/vs/base/common/severity.js
var Severity;
(function(Severity2) {
  Severity2[Severity2["Ignore"] = 0] = "Ignore";
  Severity2[Severity2["Info"] = 1] = "Info";
  Severity2[Severity2["Warning"] = 2] = "Warning";
  Severity2[Severity2["Error"] = 3] = "Error";
})(Severity || (Severity = {}));
(function(Severity2) {
  const _error = "error";
  const _warning = "warning";
  const _warn = "warn";
  const _info = "info";
  function fromValue(value) {
    if (!value) {
      return Severity2.Ignore;
    }
    if (equalsIgnoreCase(_error, value)) {
      return Severity2.Error;
    }
    if (equalsIgnoreCase(_warning, value) || equalsIgnoreCase(_warn, value)) {
      return Severity2.Warning;
    }
    if (equalsIgnoreCase(_info, value)) {
      return Severity2.Info;
    }
    return Severity2.Ignore;
  }
  Severity2.fromValue = fromValue;
})(Severity || (Severity = {}));
var severity_default = Severity;

// ../../node_modules/monaco-editor/esm/vs/editor/browser/editorBrowser.js
function isCodeEditor(thing) {
  if (thing && typeof thing.getEditorType === "function") {
    return thing.getEditorType() === EditorType.ICodeEditor;
  } else {
    return false;
  }
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/services/bulkEditService.js
var IBulkEditService = createDecorator("IWorkspaceEditService");
function isWorkspaceFileEdit(thing) {
  return isObject(thing) && (Boolean(thing.newUri) || Boolean(thing.oldUri));
}
function isWorkspaceTextEdit(thing) {
  return isObject(thing) && URI.isUri(thing.resource) && isObject(thing.edit);
}
var ResourceEdit = class {
  constructor(metadata) {
    this.metadata = metadata;
  }
  static convert(edit) {
    return edit.edits.map((edit2) => {
      if (isWorkspaceTextEdit(edit2)) {
        return new ResourceTextEdit(edit2.resource, edit2.edit, edit2.modelVersionId, edit2.metadata);
      }
      if (isWorkspaceFileEdit(edit2)) {
        return new ResourceFileEdit(edit2.oldUri, edit2.newUri, edit2.options, edit2.metadata);
      }
      throw new Error("Unsupported edit");
    });
  }
};
var ResourceTextEdit = class extends ResourceEdit {
  constructor(resource, textEdit, versionId, metadata) {
    super(metadata);
    this.resource = resource;
    this.textEdit = textEdit;
    this.versionId = versionId;
    this.metadata = metadata;
  }
};
var ResourceFileEdit = class extends ResourceEdit {
  constructor(oldResource, newResource, options, metadata) {
    super(metadata);
    this.oldResource = oldResource;
    this.newResource = newResource;
    this.options = options;
    this.metadata = metadata;
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/registry/common/platform.js
var RegistryImpl = class {
  constructor() {
    this.data = new Map();
  }
  add(id, data) {
    ok(isString(id));
    ok(isObject(data));
    ok(!this.data.has(id), "There is already an extension with this id");
    this.data.set(id, data);
  }
  as(id) {
    return this.data.get(id) || null;
  }
};
var Registry2 = new RegistryImpl();

// ../../node_modules/monaco-editor/esm/vs/platform/jsonschemas/common/jsonContributionRegistry.js
var Extensions = {
  JSONContribution: "base.contributions.json"
};
function normalizeId(id) {
  if (id.length > 0 && id.charAt(id.length - 1) === "#") {
    return id.substring(0, id.length - 1);
  }
  return id;
}
var JSONContributionRegistry = class {
  constructor() {
    this._onDidChangeSchema = new Emitter();
    this.schemasById = {};
  }
  registerSchema(uri, unresolvedSchemaContent) {
    this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;
    this._onDidChangeSchema.fire(uri);
  }
  notifySchemaChanged(uri) {
    this._onDidChangeSchema.fire(uri);
  }
};
var jsonContributionRegistry = new JSONContributionRegistry();
Registry2.add(Extensions.JSONContribution, jsonContributionRegistry);

// ../../node_modules/monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js
var Extensions2 = {
  Configuration: "base.contributions.configuration"
};
var allSettings = {properties: {}, patternProperties: {}};
var applicationSettings = {properties: {}, patternProperties: {}};
var machineSettings = {properties: {}, patternProperties: {}};
var machineOverridableSettings = {properties: {}, patternProperties: {}};
var windowSettings = {properties: {}, patternProperties: {}};
var resourceSettings = {properties: {}, patternProperties: {}};
var resourceLanguageSettingsSchemaId = "vscode://schemas/settings/resourceLanguage";
var contributionRegistry = Registry2.as(Extensions.JSONContribution);
var ConfigurationRegistry = class {
  constructor() {
    this.overrideIdentifiers = new Set();
    this._onDidSchemaChange = new Emitter();
    this._onDidUpdateConfiguration = new Emitter();
    this.defaultValues = {};
    this.defaultLanguageConfigurationOverridesNode = {
      id: "defaultOverrides",
      title: localize("defaultLanguageConfigurationOverrides.title", "Default Language Configuration Overrides"),
      properties: {}
    };
    this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode];
    this.resourceLanguageSettingsSchema = {properties: {}, patternProperties: {}, additionalProperties: false, errorMessage: "Unknown editor configuration setting", allowTrailingCommas: true, allowComments: true};
    this.configurationProperties = {};
    this.excludedConfigurationProperties = {};
    contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
  }
  registerConfiguration(configuration, validate = true) {
    this.registerConfigurations([configuration], validate);
  }
  registerConfigurations(configurations, validate = true) {
    const properties = [];
    configurations.forEach((configuration) => {
      properties.push(...this.validateAndRegisterProperties(configuration, validate));
      this.configurationContributors.push(configuration);
      this.registerJSONConfiguration(configuration);
    });
    contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
    this._onDidSchemaChange.fire();
    this._onDidUpdateConfiguration.fire(properties);
  }
  registerOverrideIdentifiers(overrideIdentifiers) {
    for (const overrideIdentifier of overrideIdentifiers) {
      this.overrideIdentifiers.add(overrideIdentifier);
    }
    this.updateOverridePropertyPatternKey();
  }
  validateAndRegisterProperties(configuration, validate = true, scope = 3) {
    scope = isUndefinedOrNull(configuration.scope) ? scope : configuration.scope;
    let propertyKeys = [];
    let properties = configuration.properties;
    if (properties) {
      for (let key in properties) {
        if (validate && validateProperty(key)) {
          delete properties[key];
          continue;
        }
        const property = properties[key];
        this.updatePropertyDefaultValue(key, property);
        if (OVERRIDE_PROPERTY_PATTERN.test(key)) {
          property.scope = void 0;
        } else {
          property.scope = isUndefinedOrNull(property.scope) ? scope : property.scope;
        }
        if (properties[key].hasOwnProperty("included") && !properties[key].included) {
          this.excludedConfigurationProperties[key] = properties[key];
          delete properties[key];
          continue;
        } else {
          this.configurationProperties[key] = properties[key];
        }
        if (!properties[key].deprecationMessage && properties[key].markdownDeprecationMessage) {
          properties[key].deprecationMessage = properties[key].markdownDeprecationMessage;
        }
        propertyKeys.push(key);
      }
    }
    let subNodes = configuration.allOf;
    if (subNodes) {
      for (let node of subNodes) {
        propertyKeys.push(...this.validateAndRegisterProperties(node, validate, scope));
      }
    }
    return propertyKeys;
  }
  getConfigurationProperties() {
    return this.configurationProperties;
  }
  registerJSONConfiguration(configuration) {
    const register3 = (configuration2) => {
      let properties = configuration2.properties;
      if (properties) {
        for (const key in properties) {
          this.updateSchema(key, properties[key]);
        }
      }
      let subNodes = configuration2.allOf;
      if (subNodes) {
        subNodes.forEach(register3);
      }
    };
    register3(configuration);
  }
  updateSchema(key, property) {
    allSettings.properties[key] = property;
    switch (property.scope) {
      case 1:
        applicationSettings.properties[key] = property;
        break;
      case 2:
        machineSettings.properties[key] = property;
        break;
      case 6:
        machineOverridableSettings.properties[key] = property;
        break;
      case 3:
        windowSettings.properties[key] = property;
        break;
      case 4:
        resourceSettings.properties[key] = property;
        break;
      case 5:
        resourceSettings.properties[key] = property;
        this.resourceLanguageSettingsSchema.properties[key] = property;
        break;
    }
  }
  updateOverridePropertyPatternKey() {
    for (const overrideIdentifier of this.overrideIdentifiers.values()) {
      const overrideIdentifierProperty = `[${overrideIdentifier}]`;
      const resourceLanguagePropertiesSchema = {
        type: "object",
        description: localize("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."),
        errorMessage: localize("overrideSettings.errorMessage", "This setting does not support per-language configuration."),
        $ref: resourceLanguageSettingsSchemaId
      };
      this.updatePropertyDefaultValue(overrideIdentifierProperty, resourceLanguagePropertiesSchema);
      allSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
      applicationSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
      machineSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
      machineOverridableSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
      windowSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
      resourceSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
    }
    this._onDidSchemaChange.fire();
  }
  updatePropertyDefaultValue(key, property) {
    let defaultValue = this.defaultValues[key];
    if (isUndefined(defaultValue)) {
      defaultValue = property.default;
    }
    if (isUndefined(defaultValue)) {
      defaultValue = getDefaultValue(property.type);
    }
    property.default = defaultValue;
  }
};
var OVERRIDE_PROPERTY = "\\[.*\\]$";
var OVERRIDE_PROPERTY_PATTERN = new RegExp(OVERRIDE_PROPERTY);
function overrideIdentifierFromKey(key) {
  return key.substring(1, key.length - 1);
}
function getDefaultValue(type) {
  const t = Array.isArray(type) ? type[0] : type;
  switch (t) {
    case "boolean":
      return false;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
var configurationRegistry = new ConfigurationRegistry();
Registry2.add(Extensions2.Configuration, configurationRegistry);
function validateProperty(property) {
  if (OVERRIDE_PROPERTY_PATTERN.test(property)) {
    return localize("config.property.languageDefault", "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", property);
  }
  if (configurationRegistry.getConfigurationProperties()[property] !== void 0) {
    return localize("config.property.duplicate", "Cannot register '{0}'. This property is already registered.", property);
  }
  return null;
}

// ../../node_modules/monaco-editor/esm/vs/base/common/collections.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
function forEach(from, callback) {
  for (let key in from) {
    if (hasOwnProperty.call(from, key)) {
      const result = callback({key, value: from[key]}, function() {
        delete from[key];
      });
      if (result === false) {
        return;
      }
    }
  }
}
var SetMap = class {
  constructor() {
    this.map = new Map();
  }
  add(key, value) {
    let values = this.map.get(key);
    if (!values) {
      values = new Set();
      this.map.set(key, values);
    }
    values.add(value);
  }
  delete(key, value) {
    const values = this.map.get(key);
    if (!values) {
      return;
    }
    values.delete(value);
    if (values.size === 0) {
      this.map.delete(key);
    }
  }
  forEach(key, fn) {
    const values = this.map.get(key);
    if (!values) {
      return;
    }
    values.forEach(fn);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/config/commonEditorConfig.js
var TabFocus = new class {
  constructor() {
    this._tabFocus = false;
    this._onDidChangeTabFocus = new Emitter();
    this.onDidChangeTabFocus = this._onDidChangeTabFocus.event;
  }
  getTabFocusMode() {
    return this._tabFocus;
  }
  setTabFocusMode(tabFocusMode) {
    if (this._tabFocus === tabFocusMode) {
      return;
    }
    this._tabFocus = tabFocusMode;
    this._onDidChangeTabFocus.fire(this._tabFocus);
  }
}();
var hasOwnProperty2 = Object.hasOwnProperty;
var ComputedEditorOptions = class {
  constructor() {
    this._values = [];
  }
  _read(id) {
    return this._values[id];
  }
  get(id) {
    return this._values[id];
  }
  _write(id, value) {
    this._values[id] = value;
  }
};
var RawEditorOptions = class {
  constructor() {
    this._values = [];
  }
  _read(id) {
    return this._values[id];
  }
  _write(id, value) {
    this._values[id] = value;
  }
};
var EditorConfiguration2 = class {
  static readOptions(_options) {
    const options = _options;
    const result = new RawEditorOptions();
    for (const editorOption of editorOptionsRegistry) {
      const value = editorOption.name === "_never_" ? void 0 : options[editorOption.name];
      result._write(editorOption.id, value);
    }
    return result;
  }
  static validateOptions(options) {
    const result = new ValidatedEditorOptions();
    for (const editorOption of editorOptionsRegistry) {
      result._write(editorOption.id, editorOption.validate(options._read(editorOption.id)));
    }
    return result;
  }
  static computeOptions(options, env2) {
    const result = new ComputedEditorOptions();
    for (const editorOption of editorOptionsRegistry) {
      result._write(editorOption.id, editorOption.compute(env2, result, options._read(editorOption.id)));
    }
    return result;
  }
  static _deepEquals(a, b) {
    if (typeof a !== "object" || typeof b !== "object") {
      return a === b;
    }
    if (Array.isArray(a) || Array.isArray(b)) {
      return Array.isArray(a) && Array.isArray(b) ? equals(a, b) : false;
    }
    for (let key in a) {
      if (!EditorConfiguration2._deepEquals(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  static checkEquals(a, b) {
    const result = [];
    let somethingChanged = false;
    for (const editorOption of editorOptionsRegistry) {
      const changed = !EditorConfiguration2._deepEquals(a._read(editorOption.id), b._read(editorOption.id));
      result[editorOption.id] = changed;
      if (changed) {
        somethingChanged = true;
      }
    }
    return somethingChanged ? new ConfigurationChangedEvent(result) : null;
  }
};
function migrateOptions(options) {
  const wordWrap = options.wordWrap;
  if (wordWrap === true) {
    options.wordWrap = "on";
  } else if (wordWrap === false) {
    options.wordWrap = "off";
  }
  const lineNumbers = options.lineNumbers;
  if (lineNumbers === true) {
    options.lineNumbers = "on";
  } else if (lineNumbers === false) {
    options.lineNumbers = "off";
  }
  const autoClosingBrackets = options.autoClosingBrackets;
  if (autoClosingBrackets === false) {
    options.autoClosingBrackets = "never";
    options.autoClosingQuotes = "never";
    options.autoSurround = "never";
  }
  const cursorBlinking = options.cursorBlinking;
  if (cursorBlinking === "visible") {
    options.cursorBlinking = "solid";
  }
  const renderWhitespace = options.renderWhitespace;
  if (renderWhitespace === true) {
    options.renderWhitespace = "boundary";
  } else if (renderWhitespace === false) {
    options.renderWhitespace = "none";
  }
  const renderLineHighlight = options.renderLineHighlight;
  if (renderLineHighlight === true) {
    options.renderLineHighlight = "line";
  } else if (renderLineHighlight === false) {
    options.renderLineHighlight = "none";
  }
  const acceptSuggestionOnEnter = options.acceptSuggestionOnEnter;
  if (acceptSuggestionOnEnter === true) {
    options.acceptSuggestionOnEnter = "on";
  } else if (acceptSuggestionOnEnter === false) {
    options.acceptSuggestionOnEnter = "off";
  }
  const tabCompletion = options.tabCompletion;
  if (tabCompletion === false) {
    options.tabCompletion = "off";
  } else if (tabCompletion === true) {
    options.tabCompletion = "onlySnippets";
  }
  const suggest = options.suggest;
  if (suggest && typeof suggest.filteredTypes === "object" && suggest.filteredTypes) {
    const mapping = {};
    mapping["method"] = "showMethods";
    mapping["function"] = "showFunctions";
    mapping["constructor"] = "showConstructors";
    mapping["field"] = "showFields";
    mapping["variable"] = "showVariables";
    mapping["class"] = "showClasses";
    mapping["struct"] = "showStructs";
    mapping["interface"] = "showInterfaces";
    mapping["module"] = "showModules";
    mapping["property"] = "showProperties";
    mapping["event"] = "showEvents";
    mapping["operator"] = "showOperators";
    mapping["unit"] = "showUnits";
    mapping["value"] = "showValues";
    mapping["constant"] = "showConstants";
    mapping["enum"] = "showEnums";
    mapping["enumMember"] = "showEnumMembers";
    mapping["keyword"] = "showKeywords";
    mapping["text"] = "showWords";
    mapping["color"] = "showColors";
    mapping["file"] = "showFiles";
    mapping["reference"] = "showReferences";
    mapping["folder"] = "showFolders";
    mapping["typeParameter"] = "showTypeParameters";
    mapping["snippet"] = "showSnippets";
    forEach(mapping, (entry) => {
      const value = suggest.filteredTypes[entry.key];
      if (value === false) {
        suggest[entry.value] = value;
      }
    });
  }
  const hover = options.hover;
  if (hover === true) {
    options.hover = {
      enabled: true
    };
  } else if (hover === false) {
    options.hover = {
      enabled: false
    };
  }
  const parameterHints = options.parameterHints;
  if (parameterHints === true) {
    options.parameterHints = {
      enabled: true
    };
  } else if (parameterHints === false) {
    options.parameterHints = {
      enabled: false
    };
  }
  const autoIndent = options.autoIndent;
  if (autoIndent === true) {
    options.autoIndent = "full";
  } else if (autoIndent === false) {
    options.autoIndent = "advanced";
  }
  const matchBrackets = options.matchBrackets;
  if (matchBrackets === true) {
    options.matchBrackets = "always";
  } else if (matchBrackets === false) {
    options.matchBrackets = "never";
  }
}
function deepCloneAndMigrateOptions(_options) {
  const options = deepClone(_options);
  migrateOptions(options);
  return options;
}
var CommonEditorConfiguration = class extends Disposable {
  constructor(isSimpleWidget, _options) {
    super();
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._onDidChangeFast = this._register(new Emitter());
    this.onDidChangeFast = this._onDidChangeFast.event;
    this.isSimpleWidget = isSimpleWidget;
    this._isDominatedByLongLines = false;
    this._computeOptionsMemory = new ComputeOptionsMemory();
    this._viewLineCount = 1;
    this._lineNumbersDigitCount = 1;
    this._rawOptions = deepCloneAndMigrateOptions(_options);
    this._readOptions = EditorConfiguration2.readOptions(this._rawOptions);
    this._validatedOptions = EditorConfiguration2.validateOptions(this._readOptions);
    this._register(EditorZoom.onDidChangeZoomLevel((_) => this._recomputeOptions()));
    this._register(TabFocus.onDidChangeTabFocus((_) => this._recomputeOptions()));
  }
  observeReferenceElement(dimension) {
  }
  dispose() {
    super.dispose();
  }
  _recomputeOptions() {
    const oldOptions = this.options;
    const newOptions = this._computeInternalOptions();
    if (!oldOptions) {
      this.options = newOptions;
    } else {
      const changeEvent = EditorConfiguration2.checkEquals(oldOptions, newOptions);
      if (changeEvent === null) {
        return;
      }
      this.options = newOptions;
      this._onDidChangeFast.fire(changeEvent);
      this._onDidChange.fire(changeEvent);
    }
  }
  getRawOptions() {
    return this._rawOptions;
  }
  _computeInternalOptions() {
    const partialEnv = this._getEnvConfiguration();
    const bareFontInfo = BareFontInfo.createFromValidatedSettings(this._validatedOptions, partialEnv.zoomLevel, this.isSimpleWidget);
    const env2 = {
      memory: this._computeOptionsMemory,
      outerWidth: partialEnv.outerWidth,
      outerHeight: partialEnv.outerHeight,
      fontInfo: this.readConfiguration(bareFontInfo),
      extraEditorClassName: partialEnv.extraEditorClassName,
      isDominatedByLongLines: this._isDominatedByLongLines,
      viewLineCount: this._viewLineCount,
      lineNumbersDigitCount: this._lineNumbersDigitCount,
      emptySelectionClipboard: partialEnv.emptySelectionClipboard,
      pixelRatio: partialEnv.pixelRatio,
      tabFocusMode: TabFocus.getTabFocusMode(),
      accessibilitySupport: partialEnv.accessibilitySupport
    };
    return EditorConfiguration2.computeOptions(this._validatedOptions, env2);
  }
  static _subsetEquals(base, subset) {
    for (const key in subset) {
      if (hasOwnProperty2.call(subset, key)) {
        const subsetValue = subset[key];
        const baseValue = base[key];
        if (baseValue === subsetValue) {
          continue;
        }
        if (Array.isArray(baseValue) && Array.isArray(subsetValue)) {
          if (!equals(baseValue, subsetValue)) {
            return false;
          }
          continue;
        }
        if (baseValue && typeof baseValue === "object" && subsetValue && typeof subsetValue === "object") {
          if (!this._subsetEquals(baseValue, subsetValue)) {
            return false;
          }
          continue;
        }
        return false;
      }
    }
    return true;
  }
  updateOptions(_newOptions) {
    if (typeof _newOptions === "undefined") {
      return;
    }
    const newOptions = deepCloneAndMigrateOptions(_newOptions);
    if (CommonEditorConfiguration._subsetEquals(this._rawOptions, newOptions)) {
      return;
    }
    this._rawOptions = mixin(this._rawOptions, newOptions || {});
    this._readOptions = EditorConfiguration2.readOptions(this._rawOptions);
    this._validatedOptions = EditorConfiguration2.validateOptions(this._readOptions);
    this._recomputeOptions();
  }
  setIsDominatedByLongLines(isDominatedByLongLines) {
    this._isDominatedByLongLines = isDominatedByLongLines;
    this._recomputeOptions();
  }
  setMaxLineNumber(maxLineNumber) {
    const lineNumbersDigitCount = CommonEditorConfiguration._digitCount(maxLineNumber);
    if (this._lineNumbersDigitCount === lineNumbersDigitCount) {
      return;
    }
    this._lineNumbersDigitCount = lineNumbersDigitCount;
    this._recomputeOptions();
  }
  setViewLineCount(viewLineCount) {
    if (this._viewLineCount === viewLineCount) {
      return;
    }
    this._viewLineCount = viewLineCount;
    this._recomputeOptions();
  }
  static _digitCount(n) {
    let r = 0;
    while (n) {
      n = Math.floor(n / 10);
      r++;
    }
    return r ? r : 1;
  }
};
var editorConfigurationBaseNode = Object.freeze({
  id: "editor",
  order: 5,
  type: "object",
  title: localize("editorConfigurationTitle", "Editor"),
  scope: 5
});
var configurationRegistry2 = Registry2.as(Extensions2.Configuration);
var editorConfiguration = Object.assign(Object.assign({}, editorConfigurationBaseNode), {properties: {
  "editor.tabSize": {
    type: "number",
    default: EDITOR_MODEL_DEFAULTS.tabSize,
    minimum: 1,
    markdownDescription: localize("tabSize", "The number of spaces a tab is equal to. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
  },
  "editor.insertSpaces": {
    type: "boolean",
    default: EDITOR_MODEL_DEFAULTS.insertSpaces,
    markdownDescription: localize("insertSpaces", "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
  },
  "editor.detectIndentation": {
    type: "boolean",
    default: EDITOR_MODEL_DEFAULTS.detectIndentation,
    markdownDescription: localize("detectIndentation", "Controls whether `#editor.tabSize#` and `#editor.insertSpaces#` will be automatically detected when a file is opened based on the file contents.")
  },
  "editor.trimAutoWhitespace": {
    type: "boolean",
    default: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,
    description: localize("trimAutoWhitespace", "Remove trailing auto inserted whitespace.")
  },
  "editor.largeFileOptimizations": {
    type: "boolean",
    default: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,
    description: localize("largeFileOptimizations", "Special handling for large files to disable certain memory intensive features.")
  },
  "editor.wordBasedSuggestions": {
    type: "boolean",
    default: true,
    description: localize("wordBasedSuggestions", "Controls whether completions should be computed based on words in the document.")
  },
  "editor.semanticHighlighting.enabled": {
    enum: [true, false, "configuredByTheme"],
    enumDescriptions: [
      localize("semanticHighlighting.true", "Semantic highlighting enabled for all color themes."),
      localize("semanticHighlighting.false", "Semantic highlighting disabled for all color themes."),
      localize("semanticHighlighting.configuredByTheme", "Semantic highlighting is configured by the current color theme's `semanticHighlighting` setting.")
    ],
    default: "configuredByTheme",
    description: localize("semanticHighlighting.enabled", "Controls whether the semanticHighlighting is shown for the languages that support it.")
  },
  "editor.stablePeek": {
    type: "boolean",
    default: false,
    markdownDescription: localize("stablePeek", "Keep peek editors open even when double clicking their content or when hitting `Escape`.")
  },
  "editor.maxTokenizationLineLength": {
    type: "integer",
    default: 2e4,
    description: localize("maxTokenizationLineLength", "Lines above this length will not be tokenized for performance reasons")
  },
  "diffEditor.maxComputationTime": {
    type: "number",
    default: 5e3,
    description: localize("maxComputationTime", "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
  },
  "diffEditor.renderSideBySide": {
    type: "boolean",
    default: true,
    description: localize("sideBySide", "Controls whether the diff editor shows the diff side by side or inline.")
  },
  "diffEditor.ignoreTrimWhitespace": {
    type: "boolean",
    default: true,
    description: localize("ignoreTrimWhitespace", "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
  },
  "diffEditor.renderIndicators": {
    type: "boolean",
    default: true,
    description: localize("renderIndicators", "Controls whether the diff editor shows +/- indicators for added/removed changes.")
  },
  "diffEditor.codeLens": {
    type: "boolean",
    default: false,
    description: localize("codeLens", "Controls whether the editor shows CodeLens.")
  }
}});
function isConfigurationPropertySchema(x) {
  return typeof x.type !== "undefined" || typeof x.anyOf !== "undefined";
}
for (const editorOption of editorOptionsRegistry) {
  const schema = editorOption.schema;
  if (typeof schema !== "undefined") {
    if (isConfigurationPropertySchema(schema)) {
      editorConfiguration.properties[`editor.${editorOption.name}`] = schema;
    } else {
      for (let key in schema) {
        if (hasOwnProperty2.call(schema, key)) {
          editorConfiguration.properties[key] = schema[key];
        }
      }
    }
  }
}
var cachedEditorConfigurationKeys = null;
function getEditorConfigurationKeys() {
  if (cachedEditorConfigurationKeys === null) {
    cachedEditorConfigurationKeys = Object.create(null);
    Object.keys(editorConfiguration.properties).forEach((prop) => {
      cachedEditorConfigurationKeys[prop] = true;
    });
  }
  return cachedEditorConfigurationKeys;
}
function isEditorConfigurationKey(key) {
  const editorConfigurationKeys = getEditorConfigurationKeys();
  return editorConfigurationKeys[`editor.${key}`] || false;
}
function isDiffEditorConfigurationKey(key) {
  const editorConfigurationKeys = getEditorConfigurationKeys();
  return editorConfigurationKeys[`diffEditor.${key}`] || false;
}
configurationRegistry2.registerConfiguration(editorConfiguration);

// ../../node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js
var EditOperation = class {
  static insert(position, text) {
    return {
      range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),
      text,
      forceMoveMarkers: true
    };
  }
  static delete(range2) {
    return {
      range: range2,
      text: null
    };
  }
  static replace(range2, text) {
    return {
      range: range2,
      text
    };
  }
  static replaceMove(range2, text) {
    return {
      range: range2,
      text,
      forceMoveMarkers: true
    };
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/configuration/common/configuration.js
var IConfigurationService = createDecorator("configurationService");
function toValuesTree(properties, conflictReporter) {
  const root = Object.create(null);
  for (let key in properties) {
    addToValueTree(root, key, properties[key], conflictReporter);
  }
  return root;
}
function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
  const segments = key.split(".");
  const last = segments.pop();
  let curr = settingsTreeRoot;
  for (let i = 0; i < segments.length; i++) {
    let s = segments[i];
    let obj = curr[s];
    switch (typeof obj) {
      case "undefined":
        obj = curr[s] = Object.create(null);
        break;
      case "object":
        break;
      default:
        conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join(".")} is ${JSON.stringify(obj)}`);
        return;
    }
    curr = obj;
  }
  if (typeof curr === "object" && curr !== null) {
    try {
      curr[last] = value;
    } catch (e) {
      conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
    }
  } else {
    conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
  }
}
function removeFromValueTree(valueTree, key) {
  const segments = key.split(".");
  doRemoveFromValueTree(valueTree, segments);
}
function doRemoveFromValueTree(valueTree, segments) {
  const first2 = segments.shift();
  if (segments.length === 0) {
    delete valueTree[first2];
    return;
  }
  if (Object.keys(valueTree).indexOf(first2) !== -1) {
    const value = valueTree[first2];
    if (typeof value === "object" && !Array.isArray(value)) {
      doRemoveFromValueTree(value, segments);
      if (Object.keys(value).length === 0) {
        delete valueTree[first2];
      }
    }
  }
}
function getConfigurationValue(config, settingPath, defaultValue) {
  function accessSetting(config2, path2) {
    let current = config2;
    for (const component of path2) {
      if (typeof current !== "object" || current === null) {
        return void 0;
      }
      current = current[component];
    }
    return current;
  }
  const path = settingPath.split(".");
  const result = accessSetting(config, path);
  return typeof result === "undefined" ? defaultValue : result;
}
function getConfigurationKeys() {
  const properties = Registry2.as(Extensions2.Configuration).getConfigurationProperties();
  return Object.keys(properties);
}
function getDefaultValues() {
  const valueTreeRoot = Object.create(null);
  const properties = Registry2.as(Extensions2.Configuration).getConfigurationProperties();
  for (let key in properties) {
    let value = properties[key].default;
    addToValueTree(valueTreeRoot, key, value, (message) => console.error(`Conflict in default settings: ${message}`));
  }
  return valueTreeRoot;
}

// ../../node_modules/monaco-editor/esm/vs/platform/configuration/common/configurationModels.js
var ConfigurationModel = class {
  constructor(_contents = {}, _keys = [], _overrides = []) {
    this._contents = _contents;
    this._keys = _keys;
    this._overrides = _overrides;
    this.isFrozen = false;
  }
  get contents() {
    return this.checkAndFreeze(this._contents);
  }
  get overrides() {
    return this.checkAndFreeze(this._overrides);
  }
  get keys() {
    return this.checkAndFreeze(this._keys);
  }
  isEmpty() {
    return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
  }
  getValue(section) {
    return section ? getConfigurationValue(this.contents, section) : this.contents;
  }
  override(identifier) {
    const overrideContents = this.getContentsForOverrideIdentifer(identifier);
    if (!overrideContents || typeof overrideContents !== "object" || !Object.keys(overrideContents).length) {
      return this;
    }
    let contents = {};
    for (const key of distinct([...Object.keys(this.contents), ...Object.keys(overrideContents)])) {
      let contentsForKey = this.contents[key];
      let overrideContentsForKey = overrideContents[key];
      if (overrideContentsForKey) {
        if (typeof contentsForKey === "object" && typeof overrideContentsForKey === "object") {
          contentsForKey = deepClone(contentsForKey);
          this.mergeContents(contentsForKey, overrideContentsForKey);
        } else {
          contentsForKey = overrideContentsForKey;
        }
      }
      contents[key] = contentsForKey;
    }
    return new ConfigurationModel(contents, this.keys, this.overrides);
  }
  merge(...others) {
    const contents = deepClone(this.contents);
    const overrides = deepClone(this.overrides);
    const keys = [...this.keys];
    for (const other of others) {
      this.mergeContents(contents, other.contents);
      for (const otherOverride of other.overrides) {
        const [override] = overrides.filter((o) => equals(o.identifiers, otherOverride.identifiers));
        if (override) {
          this.mergeContents(override.contents, otherOverride.contents);
        } else {
          overrides.push(deepClone(otherOverride));
        }
      }
      for (const key of other.keys) {
        if (keys.indexOf(key) === -1) {
          keys.push(key);
        }
      }
    }
    return new ConfigurationModel(contents, keys, overrides);
  }
  freeze() {
    this.isFrozen = true;
    return this;
  }
  mergeContents(source, target) {
    for (const key of Object.keys(target)) {
      if (key in source) {
        if (isObject(source[key]) && isObject(target[key])) {
          this.mergeContents(source[key], target[key]);
          continue;
        }
      }
      source[key] = deepClone(target[key]);
    }
  }
  checkAndFreeze(data) {
    if (this.isFrozen && !Object.isFrozen(data)) {
      return deepFreeze(data);
    }
    return data;
  }
  getContentsForOverrideIdentifer(identifier) {
    for (const override of this.overrides) {
      if (override.identifiers.indexOf(identifier) !== -1) {
        return override.contents;
      }
    }
    return null;
  }
  toJSON() {
    return {
      contents: this.contents,
      overrides: this.overrides,
      keys: this.keys
    };
  }
  setValue(key, value) {
    this.addKey(key);
    addToValueTree(this.contents, key, value, (e) => {
      throw new Error(e);
    });
  }
  removeValue(key) {
    if (this.removeKey(key)) {
      removeFromValueTree(this.contents, key);
    }
  }
  addKey(key) {
    let index = this.keys.length;
    for (let i = 0; i < index; i++) {
      if (key.indexOf(this.keys[i]) === 0) {
        index = i;
      }
    }
    this.keys.splice(index, 1, key);
  }
  removeKey(key) {
    let index = this.keys.indexOf(key);
    if (index !== -1) {
      this.keys.splice(index, 1);
      return true;
    }
    return false;
  }
};
var DefaultConfigurationModel = class extends ConfigurationModel {
  constructor() {
    const contents = getDefaultValues();
    const keys = getConfigurationKeys();
    const overrides = [];
    for (const key of Object.keys(contents)) {
      if (OVERRIDE_PROPERTY_PATTERN.test(key)) {
        overrides.push({
          identifiers: [overrideIdentifierFromKey(key).trim()],
          keys: Object.keys(contents[key]),
          contents: toValuesTree(contents[key], (message) => console.error(`Conflict in default settings file: ${message}`))
        });
      }
    }
    super(contents, keys, overrides);
  }
};
var Configuration = class {
  constructor(_defaultConfiguration, _localUserConfiguration, _remoteUserConfiguration = new ConfigurationModel(), _workspaceConfiguration = new ConfigurationModel(), _folderConfigurations = new ResourceMap(), _memoryConfiguration = new ConfigurationModel(), _memoryConfigurationByResource = new ResourceMap(), _freeze = true) {
    this._defaultConfiguration = _defaultConfiguration;
    this._localUserConfiguration = _localUserConfiguration;
    this._remoteUserConfiguration = _remoteUserConfiguration;
    this._workspaceConfiguration = _workspaceConfiguration;
    this._folderConfigurations = _folderConfigurations;
    this._memoryConfiguration = _memoryConfiguration;
    this._memoryConfigurationByResource = _memoryConfigurationByResource;
    this._freeze = _freeze;
    this._workspaceConsolidatedConfiguration = null;
    this._foldersConsolidatedConfigurations = new ResourceMap();
    this._userConfiguration = null;
  }
  getValue(section, overrides, workspace) {
    const consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);
    return consolidateConfigurationModel.getValue(section);
  }
  updateValue(key, value, overrides = {}) {
    let memoryConfiguration;
    if (overrides.resource) {
      memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);
      if (!memoryConfiguration) {
        memoryConfiguration = new ConfigurationModel();
        this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);
      }
    } else {
      memoryConfiguration = this._memoryConfiguration;
    }
    if (value === void 0) {
      memoryConfiguration.removeValue(key);
    } else {
      memoryConfiguration.setValue(key, value);
    }
    if (!overrides.resource) {
      this._workspaceConsolidatedConfiguration = null;
    }
  }
  get userConfiguration() {
    if (!this._userConfiguration) {
      this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration);
      if (this._freeze) {
        this._userConfiguration.freeze();
      }
    }
    return this._userConfiguration;
  }
  getConsolidateConfigurationModel(overrides, workspace) {
    let configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);
    return overrides.overrideIdentifier ? configurationModel.override(overrides.overrideIdentifier) : configurationModel;
  }
  getConsolidatedConfigurationModelForResource({resource}, workspace) {
    let consolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
    if (workspace && resource) {
      const root = workspace.getFolder(resource);
      if (root) {
        consolidateConfiguration = this.getFolderConsolidatedConfiguration(root.uri) || consolidateConfiguration;
      }
      const memoryConfigurationForResource = this._memoryConfigurationByResource.get(resource);
      if (memoryConfigurationForResource) {
        consolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);
      }
    }
    return consolidateConfiguration;
  }
  getWorkspaceConsolidatedConfiguration() {
    if (!this._workspaceConsolidatedConfiguration) {
      this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
      if (this._freeze) {
        this._workspaceConfiguration = this._workspaceConfiguration.freeze();
      }
    }
    return this._workspaceConsolidatedConfiguration;
  }
  getFolderConsolidatedConfiguration(folder) {
    let folderConsolidatedConfiguration = this._foldersConsolidatedConfigurations.get(folder);
    if (!folderConsolidatedConfiguration) {
      const workspaceConsolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
      const folderConfiguration = this._folderConfigurations.get(folder);
      if (folderConfiguration) {
        folderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);
        if (this._freeze) {
          folderConsolidatedConfiguration = folderConsolidatedConfiguration.freeze();
        }
        this._foldersConsolidatedConfigurations.set(folder, folderConsolidatedConfiguration);
      } else {
        folderConsolidatedConfiguration = workspaceConsolidateConfiguration;
      }
    }
    return folderConsolidatedConfiguration;
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents,
        overrides: this._defaultConfiguration.overrides,
        keys: this._defaultConfiguration.keys
      },
      user: {
        contents: this.userConfiguration.contents,
        overrides: this.userConfiguration.overrides,
        keys: this.userConfiguration.keys
      },
      workspace: {
        contents: this._workspaceConfiguration.contents,
        overrides: this._workspaceConfiguration.overrides,
        keys: this._workspaceConfiguration.keys
      },
      folders: [...this._folderConfigurations.keys()].reduce((result, folder) => {
        const {contents, overrides, keys} = this._folderConfigurations.get(folder);
        result.push([folder, {contents, overrides, keys}]);
        return result;
      }, [])
    };
  }
  static parse(data) {
    const defaultConfiguration = this.parseConfigurationModel(data.defaults);
    const userConfiguration = this.parseConfigurationModel(data.user);
    const workspaceConfiguration = this.parseConfigurationModel(data.workspace);
    const folders = data.folders.reduce((result, value) => {
      result.set(URI.revive(value[0]), this.parseConfigurationModel(value[1]));
      return result;
    }, new ResourceMap());
    return new Configuration(defaultConfiguration, userConfiguration, new ConfigurationModel(), workspaceConfiguration, folders, new ConfigurationModel(), new ResourceMap(), false);
  }
  static parseConfigurationModel(model2) {
    return new ConfigurationModel(model2.contents, model2.keys, model2.overrides).freeze();
  }
};
var ConfigurationChangeEvent = class {
  constructor(change, previous, currentConfiguraiton, currentWorkspace) {
    this.change = change;
    this.previous = previous;
    this.currentConfiguraiton = currentConfiguraiton;
    this.currentWorkspace = currentWorkspace;
    this._previousConfiguration = void 0;
    const keysSet = new Set();
    change.keys.forEach((key) => keysSet.add(key));
    change.overrides.forEach(([, keys]) => keys.forEach((key) => keysSet.add(key)));
    this.affectedKeys = [...keysSet.values()];
    const configurationModel = new ConfigurationModel();
    this.affectedKeys.forEach((key) => configurationModel.setValue(key, {}));
    this.affectedKeysTree = configurationModel.contents;
  }
  get previousConfiguration() {
    if (!this._previousConfiguration && this.previous) {
      this._previousConfiguration = Configuration.parse(this.previous.data);
    }
    return this._previousConfiguration;
  }
  affectsConfiguration(section, overrides) {
    var _a;
    if (this.doesAffectedKeysTreeContains(this.affectedKeysTree, section)) {
      if (overrides) {
        const value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section, overrides, (_a = this.previous) === null || _a === void 0 ? void 0 : _a.workspace) : void 0;
        const value2 = this.currentConfiguraiton.getValue(section, overrides, this.currentWorkspace);
        return !equals2(value1, value2);
      }
      return true;
    }
    return false;
  }
  doesAffectedKeysTreeContains(affectedKeysTree, section) {
    let requestedTree = toValuesTree({[section]: true}, () => {
    });
    let key;
    while (typeof requestedTree === "object" && (key = Object.keys(requestedTree)[0])) {
      affectedKeysTree = affectedKeysTree[key];
      if (!affectedKeysTree) {
        return false;
      }
      requestedTree = requestedTree[key];
    }
    return true;
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js
var AbstractKeybindingService = class extends Disposable {
  constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {
    super();
    this._contextKeyService = _contextKeyService;
    this._commandService = _commandService;
    this._telemetryService = _telemetryService;
    this._notificationService = _notificationService;
    this._logService = _logService;
    this._onDidUpdateKeybindings = this._register(new Emitter());
    this._currentChord = null;
    this._currentChordChecker = new IntervalTimer();
    this._currentChordStatusMessage = null;
    this._logging = false;
  }
  get onDidUpdateKeybindings() {
    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None;
  }
  dispose() {
    super.dispose();
  }
  _log(str) {
    if (this._logging) {
      this._logService.info(`[KeybindingService]: ${str}`);
    }
  }
  getKeybindings() {
    return this._getResolver().getKeybindings();
  }
  lookupKeybindings(commandId) {
    return coalesce(this._getResolver().lookupKeybindings(commandId).map((item) => item.resolvedKeybinding));
  }
  lookupKeybinding(commandId) {
    const result = this._getResolver().lookupPrimaryKeybinding(commandId);
    if (!result) {
      return void 0;
    }
    return result.resolvedKeybinding;
  }
  dispatchEvent(e, target) {
    return this._dispatch(e, target);
  }
  softDispatch(e, target) {
    const keybinding = this.resolveKeyboardEvent(e);
    if (keybinding.isChord()) {
      console.warn("Unexpected keyboard event mapped to a chord");
      return null;
    }
    const [firstPart] = keybinding.getDispatchParts();
    if (firstPart === null) {
      return null;
    }
    const contextValue = this._contextKeyService.getContext(target);
    const currentChord = this._currentChord ? this._currentChord.keypress : null;
    return this._getResolver().resolve(contextValue, currentChord, firstPart);
  }
  _enterChordMode(firstPart, keypressLabel) {
    this._currentChord = {
      keypress: firstPart,
      label: keypressLabel
    };
    this._currentChordStatusMessage = this._notificationService.status(localize("first.chord", "({0}) was pressed. Waiting for second key of chord...", keypressLabel));
    const chordEnterTime = Date.now();
    this._currentChordChecker.cancelAndSet(() => {
      if (!this._documentHasFocus()) {
        this._leaveChordMode();
        return;
      }
      if (Date.now() - chordEnterTime > 5e3) {
        this._leaveChordMode();
      }
    }, 500);
  }
  _leaveChordMode() {
    if (this._currentChordStatusMessage) {
      this._currentChordStatusMessage.dispose();
      this._currentChordStatusMessage = null;
    }
    this._currentChordChecker.cancel();
    this._currentChord = null;
  }
  _dispatch(e, target) {
    return this._doDispatch(this.resolveKeyboardEvent(e), target);
  }
  _doDispatch(keybinding, target) {
    let shouldPreventDefault = false;
    if (keybinding.isChord()) {
      console.warn("Unexpected keyboard event mapped to a chord");
      return false;
    }
    const [firstPart] = keybinding.getDispatchParts();
    if (firstPart === null) {
      this._log(`\\ Keyboard event cannot be dispatched.`);
      return shouldPreventDefault;
    }
    const contextValue = this._contextKeyService.getContext(target);
    const currentChord = this._currentChord ? this._currentChord.keypress : null;
    const keypressLabel = keybinding.getLabel();
    const resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);
    this._logService.trace("KeybindingService#dispatch", keypressLabel, resolveResult === null || resolveResult === void 0 ? void 0 : resolveResult.commandId);
    if (resolveResult && resolveResult.enterChord) {
      shouldPreventDefault = true;
      this._enterChordMode(firstPart, keypressLabel);
      return shouldPreventDefault;
    }
    if (this._currentChord) {
      if (!resolveResult || !resolveResult.commandId) {
        this._notificationService.status(localize("missing.chord", "The key combination ({0}, {1}) is not a command.", this._currentChord.label, keypressLabel), {hideAfter: 10 * 1e3});
        shouldPreventDefault = true;
      }
    }
    this._leaveChordMode();
    if (resolveResult && resolveResult.commandId) {
      if (!resolveResult.bubble) {
        shouldPreventDefault = true;
      }
      if (typeof resolveResult.commandArgs === "undefined") {
        this._commandService.executeCommand(resolveResult.commandId).then(void 0, (err) => this._notificationService.warn(err));
      } else {
        this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(void 0, (err) => this._notificationService.warn(err));
      }
      this._telemetryService.publicLog2("workbenchActionExecuted", {id: resolveResult.commandId, from: "keybinding"});
    }
    return shouldPreventDefault;
  }
  mightProducePrintableCharacter(event) {
    if (event.ctrlKey || event.metaKey) {
      return false;
    }
    if (event.keyCode >= 31 && event.keyCode <= 56 || event.keyCode >= 21 && event.keyCode <= 30) {
      return true;
    }
    return false;
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js
var KeybindingResolver = class {
  constructor(defaultKeybindings, overrides, log2) {
    this._log = log2;
    this._defaultKeybindings = defaultKeybindings;
    this._defaultBoundCommands = new Map();
    for (let i = 0, len = defaultKeybindings.length; i < len; i++) {
      const command = defaultKeybindings[i].command;
      if (command) {
        this._defaultBoundCommands.set(command, true);
      }
    }
    this._map = new Map();
    this._lookupMap = new Map();
    this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);
    for (let i = 0, len = this._keybindings.length; i < len; i++) {
      let k = this._keybindings[i];
      if (k.keypressParts.length === 0) {
        continue;
      }
      if (k.when && k.when.type === 0) {
        continue;
      }
      this._addKeyPress(k.keypressParts[0], k);
    }
  }
  static _isTargetedForRemoval(defaultKb, keypressFirstPart, keypressChordPart, command, when) {
    if (defaultKb.command !== command) {
      return false;
    }
    if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {
      return false;
    }
    if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {
      return false;
    }
    if (when) {
      if (!defaultKb.when) {
        return false;
      }
      if (!when.equals(defaultKb.when)) {
        return false;
      }
    }
    return true;
  }
  static combine(defaults, rawOverrides) {
    defaults = defaults.slice(0);
    let overrides = [];
    for (const override of rawOverrides) {
      if (!override.command || override.command.length === 0 || override.command.charAt(0) !== "-") {
        overrides.push(override);
        continue;
      }
      const command = override.command.substr(1);
      const keypressFirstPart = override.keypressParts[0];
      const keypressChordPart = override.keypressParts[1];
      const when = override.when;
      for (let j = defaults.length - 1; j >= 0; j--) {
        if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {
          defaults.splice(j, 1);
        }
      }
    }
    return defaults.concat(overrides);
  }
  _addKeyPress(keypress, item) {
    const conflicts = this._map.get(keypress);
    if (typeof conflicts === "undefined") {
      this._map.set(keypress, [item]);
      this._addToLookupMap(item);
      return;
    }
    for (let i = conflicts.length - 1; i >= 0; i--) {
      let conflict = conflicts[i];
      if (conflict.command === item.command) {
        continue;
      }
      const conflictIsChord = conflict.keypressParts.length > 1;
      const itemIsChord = item.keypressParts.length > 1;
      if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {
        continue;
      }
      if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {
        this._removeFromLookupMap(conflict);
      }
    }
    conflicts.push(item);
    this._addToLookupMap(item);
  }
  _addToLookupMap(item) {
    if (!item.command) {
      return;
    }
    let arr = this._lookupMap.get(item.command);
    if (typeof arr === "undefined") {
      arr = [item];
      this._lookupMap.set(item.command, arr);
    } else {
      arr.push(item);
    }
  }
  _removeFromLookupMap(item) {
    if (!item.command) {
      return;
    }
    let arr = this._lookupMap.get(item.command);
    if (typeof arr === "undefined") {
      return;
    }
    for (let i = 0, len = arr.length; i < len; i++) {
      if (arr[i] === item) {
        arr.splice(i, 1);
        return;
      }
    }
  }
  static whenIsEntirelyIncluded(a, b) {
    if (!b) {
      return true;
    }
    if (!a) {
      return false;
    }
    return this._implies(a, b);
  }
  static _implies(p, q) {
    const notP = p.negate();
    const terminals = (node) => {
      if (node.type === 9) {
        return node.expr;
      }
      return [node];
    };
    let expr = terminals(notP).concat(terminals(q));
    for (let i = 0; i < expr.length; i++) {
      const a = expr[i];
      const notA = a.negate();
      for (let j = i + 1; j < expr.length; j++) {
        const b = expr[j];
        if (notA.equals(b)) {
          return true;
        }
      }
    }
    return false;
  }
  getKeybindings() {
    return this._keybindings;
  }
  lookupKeybindings(commandId) {
    let items = this._lookupMap.get(commandId);
    if (typeof items === "undefined" || items.length === 0) {
      return [];
    }
    let result = [], resultLen = 0;
    for (let i = items.length - 1; i >= 0; i--) {
      result[resultLen++] = items[i];
    }
    return result;
  }
  lookupPrimaryKeybinding(commandId) {
    let items = this._lookupMap.get(commandId);
    if (typeof items === "undefined" || items.length === 0) {
      return null;
    }
    return items[items.length - 1];
  }
  resolve(context, currentChord, keypress) {
    this._log(`| Resolving ${keypress}${currentChord ? ` chorded from ${currentChord}` : ``}`);
    let lookupMap = null;
    if (currentChord !== null) {
      const candidates = this._map.get(currentChord);
      if (typeof candidates === "undefined") {
        this._log(`\\ No keybinding entries.`);
        return null;
      }
      lookupMap = [];
      for (let i = 0, len = candidates.length; i < len; i++) {
        let candidate = candidates[i];
        if (candidate.keypressParts[1] === keypress) {
          lookupMap.push(candidate);
        }
      }
    } else {
      const candidates = this._map.get(keypress);
      if (typeof candidates === "undefined") {
        this._log(`\\ No keybinding entries.`);
        return null;
      }
      lookupMap = candidates;
    }
    let result = this._findCommand(context, lookupMap);
    if (!result) {
      this._log(`\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);
      return null;
    }
    if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {
      this._log(`\\ From ${lookupMap.length} keybinding entries, matched chord, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);
      return {
        enterChord: true,
        leaveChord: false,
        commandId: null,
        commandArgs: null,
        bubble: false
      };
    }
    this._log(`\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);
    return {
      enterChord: false,
      leaveChord: result.keypressParts.length > 1,
      commandId: result.command,
      commandArgs: result.commandArgs,
      bubble: result.bubble
    };
  }
  _findCommand(context, matches) {
    for (let i = matches.length - 1; i >= 0; i--) {
      let k = matches[i];
      if (!KeybindingResolver.contextMatchesRules(context, k.when)) {
        continue;
      }
      return k;
    }
    return null;
  }
  static contextMatchesRules(context, rules) {
    if (!rules) {
      return true;
    }
    return rules.evaluate(context);
  }
};
function printWhenExplanation(when) {
  if (!when) {
    return `no when condition`;
  }
  return `${when.serialize()}`;
}
function printSourceExplanation(kb) {
  if (kb.isDefault) {
    if (kb.extensionId) {
      return `built-in extension ${kb.extensionId}`;
    }
    return `built-in`;
  }
  if (kb.extensionId) {
    return `user extension ${kb.extensionId}`;
  }
  return `user`;
}

// ../../node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js
var KeybindingsRegistryImpl = class {
  constructor() {
    this._coreKeybindings = [];
    this._extensionKeybindings = [];
    this._cachedMergedKeybindings = null;
  }
  static bindToCurrentPlatform(kb) {
    if (OS === 1) {
      if (kb && kb.win) {
        return kb.win;
      }
    } else if (OS === 2) {
      if (kb && kb.mac) {
        return kb.mac;
      }
    } else {
      if (kb && kb.linux) {
        return kb.linux;
      }
    }
    return kb;
  }
  registerKeybindingRule(rule) {
    const actualKb = KeybindingsRegistryImpl.bindToCurrentPlatform(rule);
    if (actualKb && actualKb.primary) {
      const kk = createKeybinding(actualKb.primary, OS);
      if (kk) {
        this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, 0, rule.when);
      }
    }
    if (actualKb && Array.isArray(actualKb.secondary)) {
      for (let i = 0, len = actualKb.secondary.length; i < len; i++) {
        const k = actualKb.secondary[i];
        const kk = createKeybinding(k, OS);
        if (kk) {
          this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, -i - 1, rule.when);
        }
      }
    }
  }
  registerCommandAndKeybindingRule(desc) {
    this.registerKeybindingRule(desc);
    CommandsRegistry.registerCommand(desc);
  }
  static _mightProduceChar(keyCode) {
    if (keyCode >= 21 && keyCode <= 30) {
      return true;
    }
    if (keyCode >= 31 && keyCode <= 56) {
      return true;
    }
    return keyCode === 80 || keyCode === 81 || keyCode === 82 || keyCode === 83 || keyCode === 84 || keyCode === 85 || keyCode === 86 || keyCode === 110 || keyCode === 111 || keyCode === 87 || keyCode === 88 || keyCode === 89 || keyCode === 90 || keyCode === 91 || keyCode === 92;
  }
  _assertNoCtrlAlt(keybinding, commandId) {
    if (keybinding.ctrlKey && keybinding.altKey && !keybinding.metaKey) {
      if (KeybindingsRegistryImpl._mightProduceChar(keybinding.keyCode)) {
        console.warn("Ctrl+Alt+ keybindings should not be used by default under Windows. Offender: ", keybinding, " for ", commandId);
      }
    }
  }
  _registerDefaultKeybinding(keybinding, commandId, commandArgs, weight1, weight2, when) {
    if (OS === 1) {
      this._assertNoCtrlAlt(keybinding.parts[0], commandId);
    }
    this._coreKeybindings.push({
      keybinding,
      command: commandId,
      commandArgs,
      when,
      weight1,
      weight2,
      extensionId: null
    });
    this._cachedMergedKeybindings = null;
  }
  getDefaultKeybindings() {
    if (!this._cachedMergedKeybindings) {
      this._cachedMergedKeybindings = [].concat(this._coreKeybindings).concat(this._extensionKeybindings);
      this._cachedMergedKeybindings.sort(sorter);
    }
    return this._cachedMergedKeybindings.slice(0);
  }
};
var KeybindingsRegistry = new KeybindingsRegistryImpl();
var Extensions3 = {
  EditorModes: "platform.keybindingsRegistry"
};
Registry2.add(Extensions3.EditorModes, KeybindingsRegistry);
function sorter(a, b) {
  if (a.weight1 !== b.weight1) {
    return a.weight1 - b.weight1;
  }
  if (a.command < b.command) {
    return -1;
  }
  if (a.command > b.command) {
    return 1;
  }
  return a.weight2 - b.weight2;
}

// ../../node_modules/monaco-editor/esm/vs/platform/keybinding/common/resolvedKeybindingItem.js
var ResolvedKeybindingItem = class {
  constructor(resolvedKeybinding, command, commandArgs, when, isDefault, extensionId) {
    this.resolvedKeybinding = resolvedKeybinding;
    this.keypressParts = resolvedKeybinding ? removeElementsAfterNulls(resolvedKeybinding.getDispatchParts()) : [];
    this.bubble = command ? command.charCodeAt(0) === 94 : false;
    this.command = this.bubble ? command.substr(1) : command;
    this.commandArgs = commandArgs;
    this.when = when;
    this.isDefault = isDefault;
    this.extensionId = extensionId;
  }
};
function removeElementsAfterNulls(arr) {
  let result = [];
  for (let i = 0, len = arr.length; i < len; i++) {
    const element = arr[i];
    if (!element) {
      return result;
    }
    result.push(element);
  }
  return result;
}

// ../../node_modules/monaco-editor/esm/vs/base/common/keybindingLabels.js
var ModifierLabelProvider = class {
  constructor(mac, windows, linux = windows) {
    this.modifierLabels = [null];
    this.modifierLabels[2] = mac;
    this.modifierLabels[1] = windows;
    this.modifierLabels[3] = linux;
  }
  toLabel(OS2, parts, keyLabelProvider) {
    if (parts.length === 0) {
      return null;
    }
    const result = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const part = parts[i];
      const keyLabel = keyLabelProvider(part);
      if (keyLabel === null) {
        return null;
      }
      result[i] = _simpleAsString(part, keyLabel, this.modifierLabels[OS2]);
    }
    return result.join(" ");
  }
};
var UILabelProvider = new ModifierLabelProvider({
  ctrlKey: "\u2303",
  shiftKey: "\u21E7",
  altKey: "\u2325",
  metaKey: "\u2318",
  separator: ""
}, {
  ctrlKey: localize({key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"]}, "Ctrl"),
  shiftKey: localize({key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"]}, "Shift"),
  altKey: localize({key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"]}, "Alt"),
  metaKey: localize({key: "windowsKey", comment: ["This is the short form for the Windows key on the keyboard"]}, "Windows"),
  separator: "+"
}, {
  ctrlKey: localize({key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"]}, "Ctrl"),
  shiftKey: localize({key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"]}, "Shift"),
  altKey: localize({key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"]}, "Alt"),
  metaKey: localize({key: "superKey", comment: ["This is the short form for the Super key on the keyboard"]}, "Super"),
  separator: "+"
});
var AriaLabelProvider = new ModifierLabelProvider({
  ctrlKey: localize({key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"]}, "Control"),
  shiftKey: localize({key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"]}, "Shift"),
  altKey: localize({key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"]}, "Alt"),
  metaKey: localize({key: "cmdKey.long", comment: ["This is the long form for the Command key on the keyboard"]}, "Command"),
  separator: "+"
}, {
  ctrlKey: localize({key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"]}, "Control"),
  shiftKey: localize({key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"]}, "Shift"),
  altKey: localize({key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"]}, "Alt"),
  metaKey: localize({key: "windowsKey.long", comment: ["This is the long form for the Windows key on the keyboard"]}, "Windows"),
  separator: "+"
}, {
  ctrlKey: localize({key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"]}, "Control"),
  shiftKey: localize({key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"]}, "Shift"),
  altKey: localize({key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"]}, "Alt"),
  metaKey: localize({key: "superKey.long", comment: ["This is the long form for the Super key on the keyboard"]}, "Super"),
  separator: "+"
});
function _simpleAsString(modifiers, key, labels) {
  if (key === null) {
    return "";
  }
  const result = [];
  if (modifiers.ctrlKey) {
    result.push(labels.ctrlKey);
  }
  if (modifiers.shiftKey) {
    result.push(labels.shiftKey);
  }
  if (modifiers.altKey) {
    result.push(labels.altKey);
  }
  if (modifiers.metaKey) {
    result.push(labels.metaKey);
  }
  if (key !== "") {
    result.push(key);
  }
  return result.join(labels.separator);
}

// ../../node_modules/monaco-editor/esm/vs/platform/keybinding/common/baseResolvedKeybinding.js
var BaseResolvedKeybinding = class extends ResolvedKeybinding {
  constructor(os, parts) {
    super();
    if (parts.length === 0) {
      throw illegalArgument(`parts`);
    }
    this._os = os;
    this._parts = parts;
  }
  getLabel() {
    return UILabelProvider.toLabel(this._os, this._parts, (keybinding) => this._getLabel(keybinding));
  }
  getAriaLabel() {
    return AriaLabelProvider.toLabel(this._os, this._parts, (keybinding) => this._getAriaLabel(keybinding));
  }
  isChord() {
    return this._parts.length > 1;
  }
  getParts() {
    return this._parts.map((keybinding) => this._getPart(keybinding));
  }
  _getPart(keybinding) {
    return new ResolvedKeybindingPart(keybinding.ctrlKey, keybinding.shiftKey, keybinding.altKey, keybinding.metaKey, this._getLabel(keybinding), this._getAriaLabel(keybinding));
  }
  getDispatchParts() {
    return this._parts.map((keybinding) => this._getDispatchPart(keybinding));
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js
var USLayoutResolvedKeybinding = class extends BaseResolvedKeybinding {
  constructor(actual, os) {
    super(os, actual.parts);
  }
  _keyCodeToUILabel(keyCode) {
    if (this._os === 2) {
      switch (keyCode) {
        case 15:
          return "\u2190";
        case 16:
          return "\u2191";
        case 17:
          return "\u2192";
        case 18:
          return "\u2193";
      }
    }
    return KeyCodeUtils.toString(keyCode);
  }
  _getLabel(keybinding) {
    if (keybinding.isDuplicateModifierCase()) {
      return "";
    }
    return this._keyCodeToUILabel(keybinding.keyCode);
  }
  _getAriaLabel(keybinding) {
    if (keybinding.isDuplicateModifierCase()) {
      return "";
    }
    return KeyCodeUtils.toString(keybinding.keyCode);
  }
  _getDispatchPart(keybinding) {
    return USLayoutResolvedKeybinding.getDispatchStr(keybinding);
  }
  static getDispatchStr(keybinding) {
    if (keybinding.isModifierKey()) {
      return null;
    }
    let result = "";
    if (keybinding.ctrlKey) {
      result += "ctrl+";
    }
    if (keybinding.shiftKey) {
      result += "shift+";
    }
    if (keybinding.altKey) {
      result += "alt+";
    }
    if (keybinding.metaKey) {
      result += "meta+";
    }
    result += KeyCodeUtils.toString(keybinding.keyCode);
    return result;
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/notification/common/notification.js
var INotificationService = createDecorator("notificationService");
var NoOpNotification = class {
};

// ../../node_modules/monaco-editor/esm/vs/platform/workspace/common/workspace.js
var IWorkspaceContextService = createDecorator("contextService");
var IWorkspace;
(function(IWorkspace2) {
  function isIWorkspace(thing) {
    return !!(thing && typeof thing === "object" && typeof thing.id === "string" && Array.isArray(thing.folders));
  }
  IWorkspace2.isIWorkspace = isIWorkspace;
})(IWorkspace || (IWorkspace = {}));
var IWorkspaceFolder;
(function(IWorkspaceFolder2) {
  function isIWorkspaceFolder(thing) {
    return !!(thing && typeof thing === "object" && URI.isUri(thing.uri) && typeof thing.name === "string" && typeof thing.toResource === "function");
  }
  IWorkspaceFolder2.isIWorkspaceFolder = isIWorkspaceFolder;
})(IWorkspaceFolder || (IWorkspaceFolder = {}));
var WorkspaceFolder = class {
  constructor(data, raw) {
    this.raw = raw;
    this.uri = data.uri;
    this.index = data.index;
    this.name = data.name;
  }
  toResource(relativePath2) {
    return joinPath(this.uri, relativePath2);
  }
  toJSON() {
    return {uri: this.uri, name: this.name, index: this.index};
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/standaloneStrings.js
var AccessibilityHelpNLS;
(function(AccessibilityHelpNLS2) {
  AccessibilityHelpNLS2.noSelection = localize("noSelection", "No selection");
  AccessibilityHelpNLS2.singleSelectionRange = localize("singleSelectionRange", "Line {0}, Column {1} ({2} selected)");
  AccessibilityHelpNLS2.singleSelection = localize("singleSelection", "Line {0}, Column {1}");
  AccessibilityHelpNLS2.multiSelectionRange = localize("multiSelectionRange", "{0} selections ({1} characters selected)");
  AccessibilityHelpNLS2.multiSelection = localize("multiSelection", "{0} selections");
  AccessibilityHelpNLS2.emergencyConfOn = localize("emergencyConfOn", "Now changing the setting `accessibilitySupport` to 'on'.");
  AccessibilityHelpNLS2.openingDocs = localize("openingDocs", "Now opening the Editor Accessibility documentation page.");
  AccessibilityHelpNLS2.readonlyDiffEditor = localize("readonlyDiffEditor", " in a read-only pane of a diff editor.");
  AccessibilityHelpNLS2.editableDiffEditor = localize("editableDiffEditor", " in a pane of a diff editor.");
  AccessibilityHelpNLS2.readonlyEditor = localize("readonlyEditor", " in a read-only code editor");
  AccessibilityHelpNLS2.editableEditor = localize("editableEditor", " in a code editor");
  AccessibilityHelpNLS2.changeConfigToOnMac = localize("changeConfigToOnMac", "To configure the editor to be optimized for usage with a Screen Reader press Command+E now.");
  AccessibilityHelpNLS2.changeConfigToOnWinLinux = localize("changeConfigToOnWinLinux", "To configure the editor to be optimized for usage with a Screen Reader press Control+E now.");
  AccessibilityHelpNLS2.auto_on = localize("auto_on", "The editor is configured to be optimized for usage with a Screen Reader.");
  AccessibilityHelpNLS2.auto_off = localize("auto_off", "The editor is configured to never be optimized for usage with a Screen Reader, which is not the case at this time.");
  AccessibilityHelpNLS2.tabFocusModeOnMsg = localize("tabFocusModeOnMsg", "Pressing Tab in the current editor will move focus to the next focusable element. Toggle this behavior by pressing {0}.");
  AccessibilityHelpNLS2.tabFocusModeOnMsgNoKb = localize("tabFocusModeOnMsgNoKb", "Pressing Tab in the current editor will move focus to the next focusable element. The command {0} is currently not triggerable by a keybinding.");
  AccessibilityHelpNLS2.tabFocusModeOffMsg = localize("tabFocusModeOffMsg", "Pressing Tab in the current editor will insert the tab character. Toggle this behavior by pressing {0}.");
  AccessibilityHelpNLS2.tabFocusModeOffMsgNoKb = localize("tabFocusModeOffMsgNoKb", "Pressing Tab in the current editor will insert the tab character. The command {0} is currently not triggerable by a keybinding.");
  AccessibilityHelpNLS2.openDocMac = localize("openDocMac", "Press Command+H now to open a browser window with more information related to editor accessibility.");
  AccessibilityHelpNLS2.openDocWinLinux = localize("openDocWinLinux", "Press Control+H now to open a browser window with more information related to editor accessibility.");
  AccessibilityHelpNLS2.outroMsg = localize("outroMsg", "You can dismiss this tooltip and return to the editor by pressing Escape or Shift+Escape.");
  AccessibilityHelpNLS2.showAccessibilityHelpAction = localize("showAccessibilityHelpAction", "Show Accessibility Help");
})(AccessibilityHelpNLS || (AccessibilityHelpNLS = {}));
var InspectTokensNLS;
(function(InspectTokensNLS2) {
  InspectTokensNLS2.inspectTokensAction = localize("inspectTokens", "Developer: Inspect Tokens");
})(InspectTokensNLS || (InspectTokensNLS = {}));
var GoToLineNLS;
(function(GoToLineNLS2) {
  GoToLineNLS2.gotoLineActionLabel = localize("gotoLineActionLabel", "Go to Line/Column...");
})(GoToLineNLS || (GoToLineNLS = {}));
var QuickHelpNLS;
(function(QuickHelpNLS2) {
  QuickHelpNLS2.helpQuickAccessActionLabel = localize("helpQuickAccess", "Show all Quick Access Providers");
})(QuickHelpNLS || (QuickHelpNLS = {}));
var QuickCommandNLS;
(function(QuickCommandNLS2) {
  QuickCommandNLS2.quickCommandActionLabel = localize("quickCommandActionLabel", "Command Palette");
  QuickCommandNLS2.quickCommandHelp = localize("quickCommandActionHelp", "Show And Run Commands");
})(QuickCommandNLS || (QuickCommandNLS = {}));
var QuickOutlineNLS;
(function(QuickOutlineNLS2) {
  QuickOutlineNLS2.quickOutlineActionLabel = localize("quickOutlineActionLabel", "Go to Symbol...");
  QuickOutlineNLS2.quickOutlineByCategoryActionLabel = localize("quickOutlineByCategoryActionLabel", "Go to Symbol by Category...");
})(QuickOutlineNLS || (QuickOutlineNLS = {}));
var StandaloneCodeEditorNLS;
(function(StandaloneCodeEditorNLS2) {
  StandaloneCodeEditorNLS2.editorViewAccessibleLabel = localize("editorViewAccessibleLabel", "Editor content");
  StandaloneCodeEditorNLS2.accessibilityHelpMessage = localize("accessibilityHelpMessage", "Press Alt+F1 for Accessibility Options.");
})(StandaloneCodeEditorNLS || (StandaloneCodeEditorNLS = {}));
var ToggleHighContrastNLS;
(function(ToggleHighContrastNLS2) {
  ToggleHighContrastNLS2.toggleHighContrast = localize("toggleHighContrast", "Toggle High Contrast Theme");
})(ToggleHighContrastNLS || (ToggleHighContrastNLS = {}));
var SimpleServicesNLS;
(function(SimpleServicesNLS2) {
  SimpleServicesNLS2.bulkEditServiceSummary = localize("bulkEditServiceSummary", "Made {0} edits in {1} files");
})(SimpleServicesNLS || (SimpleServicesNLS = {}));

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/simpleServices.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SimpleModel = class {
  constructor(model2) {
    this.disposed = false;
    this.model = model2;
    this._onDispose = new Emitter();
  }
  get textEditorModel() {
    return this.model;
  }
  dispose() {
    this.disposed = true;
    this._onDispose.fire();
  }
};
function withTypedEditor(widget, codeEditorCallback, diffEditorCallback) {
  if (isCodeEditor(widget)) {
    return codeEditorCallback(widget);
  } else {
    return diffEditorCallback(widget);
  }
}
var SimpleEditorModelResolverService = class SimpleEditorModelResolverService2 {
  constructor(modelService) {
    this.modelService = modelService;
  }
  setEditor(editor2) {
    this.editor = editor2;
  }
  createModelReference(resource) {
    let model2 = null;
    if (this.editor) {
      model2 = withTypedEditor(this.editor, (editor2) => this.findModel(editor2, resource), (diffEditor) => this.findModel(diffEditor.getOriginalEditor(), resource) || this.findModel(diffEditor.getModifiedEditor(), resource));
    }
    if (!model2) {
      return Promise.reject(new Error(`Model not found`));
    }
    return Promise.resolve(new ImmortalReference(new SimpleModel(model2)));
  }
  findModel(editor2, resource) {
    let model2 = this.modelService.getModel(resource);
    if (model2 && model2.uri.toString() !== resource.toString()) {
      return null;
    }
    return model2;
  }
};
SimpleEditorModelResolverService = __decorate3([
  __param3(0, IModelService)
], SimpleEditorModelResolverService);
var SimpleEditorProgressService = class {
  show() {
    return SimpleEditorProgressService.NULL_PROGRESS_RUNNER;
  }
  showWhile(promise, delay) {
    return Promise.resolve(void 0);
  }
};
SimpleEditorProgressService.NULL_PROGRESS_RUNNER = {
  done: () => {
  },
  total: () => {
  },
  worked: () => {
  }
};
var SimpleDialogService = class {
  confirm(confirmation) {
    return this.doConfirm(confirmation).then((confirmed) => {
      return {
        confirmed,
        checkboxChecked: false
      };
    });
  }
  doConfirm(confirmation) {
    let messageText = confirmation.message;
    if (confirmation.detail) {
      messageText = messageText + "\n\n" + confirmation.detail;
    }
    return Promise.resolve(window.confirm(messageText));
  }
  show(severity, message, buttons, options) {
    return Promise.resolve({choice: 0});
  }
};
var SimpleNotificationService = class {
  info(message) {
    return this.notify({severity: severity_default.Info, message});
  }
  warn(message) {
    return this.notify({severity: severity_default.Warning, message});
  }
  error(error) {
    return this.notify({severity: severity_default.Error, message: error});
  }
  notify(notification) {
    switch (notification.severity) {
      case severity_default.Error:
        console.error(notification.message);
        break;
      case severity_default.Warning:
        console.warn(notification.message);
        break;
      default:
        console.log(notification.message);
        break;
    }
    return SimpleNotificationService.NO_OP;
  }
  status(message, options) {
    return Disposable.None;
  }
};
SimpleNotificationService.NO_OP = new NoOpNotification();
var StandaloneCommandService = class {
  constructor(instantiationService) {
    this._onWillExecuteCommand = new Emitter();
    this._onDidExecuteCommand = new Emitter();
    this._instantiationService = instantiationService;
  }
  executeCommand(id, ...args) {
    const command = CommandsRegistry.getCommand(id);
    if (!command) {
      return Promise.reject(new Error(`command '${id}' not found`));
    }
    try {
      this._onWillExecuteCommand.fire({commandId: id, args});
      const result = this._instantiationService.invokeFunction.apply(this._instantiationService, [command.handler, ...args]);
      this._onDidExecuteCommand.fire({commandId: id, args});
      return Promise.resolve(result);
    } catch (err) {
      return Promise.reject(err);
    }
  }
};
var StandaloneKeybindingService = class extends AbstractKeybindingService {
  constructor(contextKeyService, commandService, telemetryService, notificationService, logService, domNode) {
    super(contextKeyService, commandService, telemetryService, notificationService, logService);
    this._cachedResolver = null;
    this._dynamicKeybindings = [];
    this._register(addDisposableListener(domNode, EventType.KEY_DOWN, (e) => {
      let keyEvent = new StandardKeyboardEvent(e);
      let shouldPreventDefault = this._dispatch(keyEvent, keyEvent.target);
      if (shouldPreventDefault) {
        keyEvent.preventDefault();
        keyEvent.stopPropagation();
      }
    }));
  }
  addDynamicKeybinding(commandId, _keybinding, handler, when) {
    const keybinding = createKeybinding(_keybinding, OS);
    const toDispose = new DisposableStore();
    if (keybinding) {
      this._dynamicKeybindings.push({
        keybinding,
        command: commandId,
        when,
        weight1: 1e3,
        weight2: 0,
        extensionId: null
      });
      toDispose.add(toDisposable(() => {
        for (let i = 0; i < this._dynamicKeybindings.length; i++) {
          let kb = this._dynamicKeybindings[i];
          if (kb.command === commandId) {
            this._dynamicKeybindings.splice(i, 1);
            this.updateResolver({source: 1});
            return;
          }
        }
      }));
    }
    toDispose.add(CommandsRegistry.registerCommand(commandId, handler));
    this.updateResolver({source: 1});
    return toDispose;
  }
  updateResolver(event) {
    this._cachedResolver = null;
    this._onDidUpdateKeybindings.fire(event);
  }
  _getResolver() {
    if (!this._cachedResolver) {
      const defaults = this._toNormalizedKeybindingItems(KeybindingsRegistry.getDefaultKeybindings(), true);
      const overrides = this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);
      this._cachedResolver = new KeybindingResolver(defaults, overrides, (str) => this._log(str));
    }
    return this._cachedResolver;
  }
  _documentHasFocus() {
    return document.hasFocus();
  }
  _toNormalizedKeybindingItems(items, isDefault) {
    let result = [], resultLen = 0;
    for (const item of items) {
      const when = item.when || void 0;
      const keybinding = item.keybinding;
      if (!keybinding) {
        result[resultLen++] = new ResolvedKeybindingItem(void 0, item.command, item.commandArgs, when, isDefault, null);
      } else {
        const resolvedKeybindings = this.resolveKeybinding(keybinding);
        for (const resolvedKeybinding of resolvedKeybindings) {
          result[resultLen++] = new ResolvedKeybindingItem(resolvedKeybinding, item.command, item.commandArgs, when, isDefault, null);
        }
      }
    }
    return result;
  }
  resolveKeybinding(keybinding) {
    return [new USLayoutResolvedKeybinding(keybinding, OS)];
  }
  resolveKeyboardEvent(keyboardEvent) {
    let keybinding = new SimpleKeybinding(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, keyboardEvent.keyCode).toChord();
    return new USLayoutResolvedKeybinding(keybinding, OS);
  }
};
function isConfigurationOverrides(thing) {
  return thing && typeof thing === "object" && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === "string") && (!thing.resource || thing.resource instanceof URI);
}
var SimpleConfigurationService = class {
  constructor() {
    this._onDidChangeConfiguration = new Emitter();
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this._configuration = new Configuration(new DefaultConfigurationModel(), new ConfigurationModel());
  }
  getValue(arg1, arg2) {
    const section = typeof arg1 === "string" ? arg1 : void 0;
    const overrides = isConfigurationOverrides(arg1) ? arg1 : isConfigurationOverrides(arg2) ? arg2 : {};
    return this._configuration.getValue(section, overrides, void 0);
  }
  updateValues(values) {
    const previous = {data: this._configuration.toData()};
    let changedKeys = [];
    for (const entry of values) {
      const [key, value] = entry;
      if (this.getValue(key) === value) {
        continue;
      }
      this._configuration.updateValue(key, value);
      changedKeys.push(key);
    }
    if (changedKeys.length > 0) {
      const configurationChangeEvent = new ConfigurationChangeEvent({keys: changedKeys, overrides: []}, previous, this._configuration);
      configurationChangeEvent.source = 7;
      configurationChangeEvent.sourceConfig = null;
      this._onDidChangeConfiguration.fire(configurationChangeEvent);
    }
    return Promise.resolve();
  }
};
var SimpleResourceConfigurationService = class {
  constructor(configurationService) {
    this.configurationService = configurationService;
    this._onDidChangeConfiguration = new Emitter();
    this.configurationService.onDidChangeConfiguration((e) => {
      this._onDidChangeConfiguration.fire({affectedKeys: e.affectedKeys, affectsConfiguration: (resource, configuration) => e.affectsConfiguration(configuration)});
    });
  }
  getValue(resource, arg2, arg3) {
    const position = Position.isIPosition(arg2) ? arg2 : null;
    const section = position ? typeof arg3 === "string" ? arg3 : void 0 : typeof arg2 === "string" ? arg2 : void 0;
    if (typeof section === "undefined") {
      return this.configurationService.getValue();
    }
    return this.configurationService.getValue(section);
  }
};
var SimpleResourcePropertiesService = class SimpleResourcePropertiesService2 {
  constructor(configurationService) {
    this.configurationService = configurationService;
  }
  getEOL(resource, language) {
    const eol = this.configurationService.getValue("files.eol", {overrideIdentifier: language, resource});
    if (eol && eol !== "auto") {
      return eol;
    }
    return isLinux || isMacintosh ? "\n" : "\r\n";
  }
};
SimpleResourcePropertiesService = __decorate3([
  __param3(0, IConfigurationService)
], SimpleResourcePropertiesService);
var StandaloneTelemetryService = class {
  publicLog(eventName, data) {
    return Promise.resolve(void 0);
  }
  publicLog2(eventName, data) {
    return this.publicLog(eventName, data);
  }
};
var SimpleWorkspaceContextService = class {
  constructor() {
    const resource = URI.from({scheme: SimpleWorkspaceContextService.SCHEME, authority: "model", path: "/"});
    this.workspace = {id: "4064f6ec-cb38-4ad0-af64-ee6467e63c82", folders: [new WorkspaceFolder({uri: resource, name: "", index: 0})]};
  }
  getWorkspace() {
    return this.workspace;
  }
  getWorkspaceFolder(resource) {
    return resource && resource.scheme === SimpleWorkspaceContextService.SCHEME ? this.workspace.folders[0] : null;
  }
};
SimpleWorkspaceContextService.SCHEME = "inmemory";
function applyConfigurationValues(configurationService, source, isDiffEditor) {
  if (!source) {
    return;
  }
  if (!(configurationService instanceof SimpleConfigurationService)) {
    return;
  }
  let toUpdate = [];
  Object.keys(source).forEach((key) => {
    if (isEditorConfigurationKey(key)) {
      toUpdate.push([`editor.${key}`, source[key]]);
    }
    if (isDiffEditor && isDiffEditorConfigurationKey(key)) {
      toUpdate.push([`diffEditor.${key}`, source[key]]);
    }
  });
  if (toUpdate.length > 0) {
    configurationService.updateValues(toUpdate);
  }
}
var SimpleBulkEditService = class {
  constructor(_modelService) {
    this._modelService = _modelService;
  }
  hasPreviewHandler() {
    return false;
  }
  apply(edits, _options) {
    return __awaiter5(this, void 0, void 0, function* () {
      const textEdits = new Map();
      for (let edit of edits) {
        if (!(edit instanceof ResourceTextEdit)) {
          throw new Error("bad edit - only text edits are supported");
        }
        const model2 = this._modelService.getModel(edit.resource);
        if (!model2) {
          throw new Error("bad edit - model not found");
        }
        if (typeof edit.versionId === "number" && model2.getVersionId() !== edit.versionId) {
          throw new Error("bad state - model changed in the meantime");
        }
        let array = textEdits.get(model2);
        if (!array) {
          array = [];
          textEdits.set(model2, array);
        }
        array.push(EditOperation.replaceMove(Range.lift(edit.textEdit.range), edit.textEdit.text));
      }
      let totalEdits = 0;
      let totalFiles = 0;
      for (const [model2, edits2] of textEdits) {
        model2.pushStackElement();
        model2.pushEditOperations([], edits2, () => []);
        model2.pushStackElement();
        totalFiles += 1;
        totalEdits += edits2.length;
      }
      return {
        ariaSummary: format(SimpleServicesNLS.bulkEditServiceSummary, totalEdits, totalFiles)
      };
    });
  }
};
var SimpleUriLabelService = class {
  getUriLabel(resource, options) {
    if (resource.scheme === "file") {
      return resource.fsPath;
    }
    return resource.path;
  }
};
var SimpleLayoutService = class {
  constructor(_codeEditorService, _container) {
    this._codeEditorService = _codeEditorService;
    this._container = _container;
    this.onLayout = Event.None;
  }
  get dimension() {
    if (!this._dimension) {
      this._dimension = getClientArea(window.document.body);
    }
    return this._dimension;
  }
  get container() {
    return this._container;
  }
  focus() {
    var _a;
    (_a = this._codeEditorService.getFocusedCodeEditor()) === null || _a === void 0 ? void 0 : _a.focus();
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/aria/aria.js
var MAX_MESSAGE_LENGTH = 2e4;
var ariaContainer;
var alertContainer;
var alertContainer2;
var statusContainer;
var statusContainer2;
function setARIAContainer(parent) {
  ariaContainer = document.createElement("div");
  ariaContainer.className = "monaco-aria-container";
  const createAlertContainer = () => {
    const element = document.createElement("div");
    element.className = "monaco-alert";
    element.setAttribute("role", "alert");
    element.setAttribute("aria-atomic", "true");
    ariaContainer.appendChild(element);
    return element;
  };
  alertContainer = createAlertContainer();
  alertContainer2 = createAlertContainer();
  const createStatusContainer = () => {
    const element = document.createElement("div");
    element.className = "monaco-status";
    element.setAttribute("role", "complementary");
    element.setAttribute("aria-live", "polite");
    element.setAttribute("aria-atomic", "true");
    ariaContainer.appendChild(element);
    return element;
  };
  statusContainer = createStatusContainer();
  statusContainer2 = createStatusContainer();
  parent.appendChild(ariaContainer);
}
function alert(msg) {
  if (!ariaContainer) {
    return;
  }
  if (alertContainer.textContent !== msg) {
    clearNode(alertContainer2);
    insertMessage(alertContainer, msg);
  } else {
    clearNode(alertContainer);
    insertMessage(alertContainer2, msg);
  }
}
function insertMessage(target, msg) {
  clearNode(target);
  if (msg.length > MAX_MESSAGE_LENGTH) {
    msg = msg.substr(0, MAX_MESSAGE_LENGTH);
  }
  target.textContent = msg;
  target.style.visibility = "hidden";
  target.style.visibility = "visible";
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/config/charWidthReader.js
var CharWidthRequest = class {
  constructor(chr, type) {
    this.chr = chr;
    this.type = type;
    this.width = 0;
  }
  fulfill(width) {
    this.width = width;
  }
};
var DomCharWidthReader = class {
  constructor(bareFontInfo, requests) {
    this._bareFontInfo = bareFontInfo;
    this._requests = requests;
    this._container = null;
    this._testElements = null;
  }
  read() {
    this._createDomElements();
    document.body.appendChild(this._container);
    this._readFromDomElements();
    document.body.removeChild(this._container);
    this._container = null;
    this._testElements = null;
  }
  _createDomElements() {
    const container = document.createElement("div");
    container.style.position = "absolute";
    container.style.top = "-50000px";
    container.style.width = "50000px";
    const regularDomNode = document.createElement("div");
    regularDomNode.style.fontFamily = this._bareFontInfo.getMassagedFontFamily();
    regularDomNode.style.fontWeight = this._bareFontInfo.fontWeight;
    regularDomNode.style.fontSize = this._bareFontInfo.fontSize + "px";
    regularDomNode.style.fontFeatureSettings = this._bareFontInfo.fontFeatureSettings;
    regularDomNode.style.lineHeight = this._bareFontInfo.lineHeight + "px";
    regularDomNode.style.letterSpacing = this._bareFontInfo.letterSpacing + "px";
    container.appendChild(regularDomNode);
    const boldDomNode = document.createElement("div");
    boldDomNode.style.fontFamily = this._bareFontInfo.getMassagedFontFamily();
    boldDomNode.style.fontWeight = "bold";
    boldDomNode.style.fontSize = this._bareFontInfo.fontSize + "px";
    boldDomNode.style.fontFeatureSettings = this._bareFontInfo.fontFeatureSettings;
    boldDomNode.style.lineHeight = this._bareFontInfo.lineHeight + "px";
    boldDomNode.style.letterSpacing = this._bareFontInfo.letterSpacing + "px";
    container.appendChild(boldDomNode);
    const italicDomNode = document.createElement("div");
    italicDomNode.style.fontFamily = this._bareFontInfo.getMassagedFontFamily();
    italicDomNode.style.fontWeight = this._bareFontInfo.fontWeight;
    italicDomNode.style.fontSize = this._bareFontInfo.fontSize + "px";
    italicDomNode.style.fontFeatureSettings = this._bareFontInfo.fontFeatureSettings;
    italicDomNode.style.lineHeight = this._bareFontInfo.lineHeight + "px";
    italicDomNode.style.letterSpacing = this._bareFontInfo.letterSpacing + "px";
    italicDomNode.style.fontStyle = "italic";
    container.appendChild(italicDomNode);
    const testElements = [];
    for (const request of this._requests) {
      let parent;
      if (request.type === 0) {
        parent = regularDomNode;
      }
      if (request.type === 2) {
        parent = boldDomNode;
      }
      if (request.type === 1) {
        parent = italicDomNode;
      }
      parent.appendChild(document.createElement("br"));
      const testElement = document.createElement("span");
      DomCharWidthReader._render(testElement, request);
      parent.appendChild(testElement);
      testElements.push(testElement);
    }
    this._container = container;
    this._testElements = testElements;
  }
  static _render(testElement, request) {
    if (request.chr === " ") {
      let htmlString = "\xA0";
      for (let i = 0; i < 8; i++) {
        htmlString += htmlString;
      }
      testElement.innerText = htmlString;
    } else {
      let testString = request.chr;
      for (let i = 0; i < 8; i++) {
        testString += testString;
      }
      testElement.textContent = testString;
    }
  }
  _readFromDomElements() {
    for (let i = 0, len = this._requests.length; i < len; i++) {
      const request = this._requests[i];
      const testElement = this._testElements[i];
      request.fulfill(testElement.offsetWidth / 256);
    }
  }
};
function readCharWidths(bareFontInfo, requests) {
  const reader = new DomCharWidthReader(bareFontInfo, requests);
  reader.read();
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/config/elementSizeObserver.js
var ElementSizeObserver = class extends Disposable {
  constructor(referenceDomElement, dimension, changeCallback) {
    super();
    this.referenceDomElement = referenceDomElement;
    this.changeCallback = changeCallback;
    this.width = -1;
    this.height = -1;
    this.resizeObserver = null;
    this.measureReferenceDomElementToken = -1;
    this.measureReferenceDomElement(false, dimension);
  }
  dispose() {
    this.stopObserving();
    super.dispose();
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  startObserving() {
    if (typeof ResizeObserver !== "undefined") {
      if (!this.resizeObserver && this.referenceDomElement) {
        this.resizeObserver = new ResizeObserver((entries) => {
          if (entries && entries[0] && entries[0].contentRect) {
            this.observe({width: entries[0].contentRect.width, height: entries[0].contentRect.height});
          } else {
            this.observe();
          }
        });
        this.resizeObserver.observe(this.referenceDomElement);
      }
    } else {
      if (this.measureReferenceDomElementToken === -1) {
        this.measureReferenceDomElementToken = setInterval(() => this.observe(), 100);
      }
    }
  }
  stopObserving() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
    if (this.measureReferenceDomElementToken !== -1) {
      clearInterval(this.measureReferenceDomElementToken);
      this.measureReferenceDomElementToken = -1;
    }
  }
  observe(dimension) {
    this.measureReferenceDomElement(true, dimension);
  }
  measureReferenceDomElement(callChangeCallback, dimension) {
    let observedWidth = 0;
    let observedHeight = 0;
    if (dimension) {
      observedWidth = dimension.width;
      observedHeight = dimension.height;
    } else if (this.referenceDomElement) {
      observedWidth = this.referenceDomElement.clientWidth;
      observedHeight = this.referenceDomElement.clientHeight;
    }
    observedWidth = Math.max(5, observedWidth);
    observedHeight = Math.max(5, observedHeight);
    if (this.width !== observedWidth || this.height !== observedHeight) {
      this.width = observedWidth;
      this.height = observedHeight;
      if (callChangeCallback) {
        this.changeCallback();
      }
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/config/configuration.js
var CSSBasedConfigurationCache = class {
  constructor() {
    this._keys = Object.create(null);
    this._values = Object.create(null);
  }
  has(item) {
    const itemId = item.getId();
    return !!this._values[itemId];
  }
  get(item) {
    const itemId = item.getId();
    return this._values[itemId];
  }
  put(item, value) {
    const itemId = item.getId();
    this._keys[itemId] = item;
    this._values[itemId] = value;
  }
  remove(item) {
    const itemId = item.getId();
    delete this._keys[itemId];
    delete this._values[itemId];
  }
  getValues() {
    return Object.keys(this._keys).map((id) => this._values[id]);
  }
};
function clearAllFontInfos() {
  CSSBasedConfiguration.INSTANCE.clearCache();
}
var CSSBasedConfiguration = class extends Disposable {
  constructor() {
    super();
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._cache = new CSSBasedConfigurationCache();
    this._evictUntrustedReadingsTimeout = -1;
  }
  dispose() {
    if (this._evictUntrustedReadingsTimeout !== -1) {
      clearTimeout(this._evictUntrustedReadingsTimeout);
      this._evictUntrustedReadingsTimeout = -1;
    }
    super.dispose();
  }
  clearCache() {
    this._cache = new CSSBasedConfigurationCache();
    this._onDidChange.fire();
  }
  _writeToCache(item, value) {
    this._cache.put(item, value);
    if (!value.isTrusted && this._evictUntrustedReadingsTimeout === -1) {
      this._evictUntrustedReadingsTimeout = setTimeout(() => {
        this._evictUntrustedReadingsTimeout = -1;
        this._evictUntrustedReadings();
      }, 5e3);
    }
  }
  _evictUntrustedReadings() {
    const values = this._cache.getValues();
    let somethingRemoved = false;
    for (let i = 0, len = values.length; i < len; i++) {
      const item = values[i];
      if (!item.isTrusted) {
        somethingRemoved = true;
        this._cache.remove(item);
      }
    }
    if (somethingRemoved) {
      this._onDidChange.fire();
    }
  }
  readConfiguration(bareFontInfo) {
    if (!this._cache.has(bareFontInfo)) {
      let readConfig = CSSBasedConfiguration._actualReadConfiguration(bareFontInfo);
      if (readConfig.typicalHalfwidthCharacterWidth <= 2 || readConfig.typicalFullwidthCharacterWidth <= 2 || readConfig.spaceWidth <= 2 || readConfig.maxDigitWidth <= 2) {
        readConfig = new FontInfo({
          zoomLevel: getZoomLevel(),
          fontFamily: readConfig.fontFamily,
          fontWeight: readConfig.fontWeight,
          fontSize: readConfig.fontSize,
          fontFeatureSettings: readConfig.fontFeatureSettings,
          lineHeight: readConfig.lineHeight,
          letterSpacing: readConfig.letterSpacing,
          isMonospace: readConfig.isMonospace,
          typicalHalfwidthCharacterWidth: Math.max(readConfig.typicalHalfwidthCharacterWidth, 5),
          typicalFullwidthCharacterWidth: Math.max(readConfig.typicalFullwidthCharacterWidth, 5),
          canUseHalfwidthRightwardsArrow: readConfig.canUseHalfwidthRightwardsArrow,
          spaceWidth: Math.max(readConfig.spaceWidth, 5),
          middotWidth: Math.max(readConfig.middotWidth, 5),
          wsmiddotWidth: Math.max(readConfig.wsmiddotWidth, 5),
          maxDigitWidth: Math.max(readConfig.maxDigitWidth, 5)
        }, false);
      }
      this._writeToCache(bareFontInfo, readConfig);
    }
    return this._cache.get(bareFontInfo);
  }
  static createRequest(chr, type, all, monospace) {
    const result = new CharWidthRequest(chr, type);
    all.push(result);
    if (monospace) {
      monospace.push(result);
    }
    return result;
  }
  static _actualReadConfiguration(bareFontInfo) {
    const all = [];
    const monospace = [];
    const typicalHalfwidthCharacter = this.createRequest("n", 0, all, monospace);
    const typicalFullwidthCharacter = this.createRequest("\uFF4D", 0, all, null);
    const space = this.createRequest(" ", 0, all, monospace);
    const digit0 = this.createRequest("0", 0, all, monospace);
    const digit1 = this.createRequest("1", 0, all, monospace);
    const digit2 = this.createRequest("2", 0, all, monospace);
    const digit3 = this.createRequest("3", 0, all, monospace);
    const digit4 = this.createRequest("4", 0, all, monospace);
    const digit5 = this.createRequest("5", 0, all, monospace);
    const digit6 = this.createRequest("6", 0, all, monospace);
    const digit7 = this.createRequest("7", 0, all, monospace);
    const digit8 = this.createRequest("8", 0, all, monospace);
    const digit9 = this.createRequest("9", 0, all, monospace);
    const rightwardsArrow = this.createRequest("\u2192", 0, all, monospace);
    const halfwidthRightwardsArrow = this.createRequest("\uFFEB", 0, all, null);
    const middot = this.createRequest("\xB7", 0, all, monospace);
    const wsmiddotWidth = this.createRequest(String.fromCharCode(11825), 0, all, null);
    this.createRequest("|", 0, all, monospace);
    this.createRequest("/", 0, all, monospace);
    this.createRequest("-", 0, all, monospace);
    this.createRequest("_", 0, all, monospace);
    this.createRequest("i", 0, all, monospace);
    this.createRequest("l", 0, all, monospace);
    this.createRequest("m", 0, all, monospace);
    this.createRequest("|", 1, all, monospace);
    this.createRequest("_", 1, all, monospace);
    this.createRequest("i", 1, all, monospace);
    this.createRequest("l", 1, all, monospace);
    this.createRequest("m", 1, all, monospace);
    this.createRequest("n", 1, all, monospace);
    this.createRequest("|", 2, all, monospace);
    this.createRequest("_", 2, all, monospace);
    this.createRequest("i", 2, all, monospace);
    this.createRequest("l", 2, all, monospace);
    this.createRequest("m", 2, all, monospace);
    this.createRequest("n", 2, all, monospace);
    readCharWidths(bareFontInfo, all);
    const maxDigitWidth = Math.max(digit0.width, digit1.width, digit2.width, digit3.width, digit4.width, digit5.width, digit6.width, digit7.width, digit8.width, digit9.width);
    let isMonospace = bareFontInfo.fontFeatureSettings === EditorFontLigatures.OFF;
    const referenceWidth = monospace[0].width;
    for (let i = 1, len = monospace.length; isMonospace && i < len; i++) {
      const diff = referenceWidth - monospace[i].width;
      if (diff < -1e-3 || diff > 1e-3) {
        isMonospace = false;
        break;
      }
    }
    let canUseHalfwidthRightwardsArrow = true;
    if (isMonospace && halfwidthRightwardsArrow.width !== referenceWidth) {
      canUseHalfwidthRightwardsArrow = false;
    }
    if (halfwidthRightwardsArrow.width > rightwardsArrow.width) {
      canUseHalfwidthRightwardsArrow = false;
    }
    const canTrustBrowserZoomLevel = getTimeSinceLastZoomLevelChanged() > 2e3;
    return new FontInfo({
      zoomLevel: getZoomLevel(),
      fontFamily: bareFontInfo.fontFamily,
      fontWeight: bareFontInfo.fontWeight,
      fontSize: bareFontInfo.fontSize,
      fontFeatureSettings: bareFontInfo.fontFeatureSettings,
      lineHeight: bareFontInfo.lineHeight,
      letterSpacing: bareFontInfo.letterSpacing,
      isMonospace,
      typicalHalfwidthCharacterWidth: typicalHalfwidthCharacter.width,
      typicalFullwidthCharacterWidth: typicalFullwidthCharacter.width,
      canUseHalfwidthRightwardsArrow,
      spaceWidth: space.width,
      middotWidth: middot.width,
      wsmiddotWidth: wsmiddotWidth.width,
      maxDigitWidth
    }, canTrustBrowserZoomLevel);
  }
};
CSSBasedConfiguration.INSTANCE = new CSSBasedConfiguration();
var Configuration2 = class extends CommonEditorConfiguration {
  constructor(isSimpleWidget, options, referenceDomElement = null, accessibilityService) {
    super(isSimpleWidget, options);
    this.accessibilityService = accessibilityService;
    this._elementSizeObserver = this._register(new ElementSizeObserver(referenceDomElement, options.dimension, () => this._onReferenceDomElementSizeChanged()));
    this._register(CSSBasedConfiguration.INSTANCE.onDidChange(() => this._onCSSBasedConfigurationChanged()));
    if (this._validatedOptions.get(9)) {
      this._elementSizeObserver.startObserving();
    }
    this._register(onDidChangeZoomLevel((_) => this._recomputeOptions()));
    this._register(this.accessibilityService.onDidChangeScreenReaderOptimized(() => this._recomputeOptions()));
    this._recomputeOptions();
  }
  static applyFontInfoSlow(domNode, fontInfo) {
    domNode.style.fontFamily = fontInfo.getMassagedFontFamily();
    domNode.style.fontWeight = fontInfo.fontWeight;
    domNode.style.fontSize = fontInfo.fontSize + "px";
    domNode.style.fontFeatureSettings = fontInfo.fontFeatureSettings;
    domNode.style.lineHeight = fontInfo.lineHeight + "px";
    domNode.style.letterSpacing = fontInfo.letterSpacing + "px";
  }
  static applyFontInfo(domNode, fontInfo) {
    domNode.setFontFamily(fontInfo.getMassagedFontFamily());
    domNode.setFontWeight(fontInfo.fontWeight);
    domNode.setFontSize(fontInfo.fontSize);
    domNode.setFontFeatureSettings(fontInfo.fontFeatureSettings);
    domNode.setLineHeight(fontInfo.lineHeight);
    domNode.setLetterSpacing(fontInfo.letterSpacing);
  }
  _onReferenceDomElementSizeChanged() {
    this._recomputeOptions();
  }
  _onCSSBasedConfigurationChanged() {
    this._recomputeOptions();
  }
  observeReferenceElement(dimension) {
    this._elementSizeObserver.observe(dimension);
  }
  dispose() {
    super.dispose();
  }
  _getExtraEditorClassName() {
    let extra = "";
    if (!isSafari && !isWebkitWebView) {
      extra += "no-user-select ";
    }
    if (isMacintosh) {
      extra += "mac ";
    }
    return extra;
  }
  _getEnvConfiguration() {
    return {
      extraEditorClassName: this._getExtraEditorClassName(),
      outerWidth: this._elementSizeObserver.getWidth(),
      outerHeight: this._elementSizeObserver.getHeight(),
      emptySelectionClipboard: isWebKit || isFirefox,
      pixelRatio: getPixelRatio(),
      zoomLevel: getZoomLevel(),
      accessibilitySupport: this.accessibilityService.isScreenReaderOptimized() ? 2 : this.accessibilityService.getAccessibilitySupport()
    };
  }
  readConfiguration(bareFontInfo) {
    return CSSBasedConfiguration.INSTANCE.readConfiguration(bareFontInfo);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/actions.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Action = class extends Disposable {
  constructor(id, label = "", cssClass = "", enabled = true, actionCallback) {
    super();
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._enabled = true;
    this._checked = false;
    this._id = id;
    this._label = label;
    this._cssClass = cssClass;
    this._enabled = enabled;
    this._actionCallback = actionCallback;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(value) {
    this._setLabel(value);
  }
  _setLabel(value) {
    if (this._label !== value) {
      this._label = value;
      this._onDidChange.fire({label: value});
    }
  }
  get tooltip() {
    return this._tooltip || "";
  }
  set tooltip(value) {
    this._setTooltip(value);
  }
  _setTooltip(value) {
    if (this._tooltip !== value) {
      this._tooltip = value;
      this._onDidChange.fire({tooltip: value});
    }
  }
  get class() {
    return this._cssClass;
  }
  set class(value) {
    this._setClass(value);
  }
  _setClass(value) {
    if (this._cssClass !== value) {
      this._cssClass = value;
      this._onDidChange.fire({class: value});
    }
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._setEnabled(value);
  }
  _setEnabled(value) {
    if (this._enabled !== value) {
      this._enabled = value;
      this._onDidChange.fire({enabled: value});
    }
  }
  get checked() {
    return this._checked;
  }
  set checked(value) {
    this._setChecked(value);
  }
  _setChecked(value) {
    if (this._checked !== value) {
      this._checked = value;
      this._onDidChange.fire({checked: value});
    }
  }
  run(event, _data) {
    if (this._actionCallback) {
      return this._actionCallback(event);
    }
    return Promise.resolve(true);
  }
};
var ActionRunner = class extends Disposable {
  constructor() {
    super(...arguments);
    this._onDidBeforeRun = this._register(new Emitter());
    this.onDidBeforeRun = this._onDidBeforeRun.event;
    this._onDidRun = this._register(new Emitter());
    this.onDidRun = this._onDidRun.event;
  }
  run(action, context) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!action.enabled) {
        return Promise.resolve(null);
      }
      this._onDidBeforeRun.fire({action});
      try {
        const result = yield this.runAction(action, context);
        this._onDidRun.fire({action, result});
      } catch (error) {
        this._onDidRun.fire({action, error});
      }
    });
  }
  runAction(action, context) {
    const res = context ? action.run(context) : action.run();
    return Promise.resolve(res);
  }
};
var Separator = class extends Action {
  constructor(label) {
    super(Separator.ID, label, label ? "separator text" : "separator");
    this.checked = false;
    this.enabled = false;
  }
};
Separator.ID = "vs.actions.separator";
var SubmenuAction = class extends Action {
  constructor(id, label, _actions, cssClass) {
    super(id, label, cssClass, true);
    this._actions = _actions;
  }
  get actions() {
    return Array.isArray(this._actions) ? this._actions : this._actions();
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js
var STATIC_VALUES = new Map();
STATIC_VALUES.set("false", false);
STATIC_VALUES.set("true", true);
STATIC_VALUES.set("isMac", isMacintosh);
STATIC_VALUES.set("isLinux", isLinux);
STATIC_VALUES.set("isWindows", isWindows);
STATIC_VALUES.set("isWeb", isWeb);
STATIC_VALUES.set("isMacNative", isMacintosh && !isWeb);
var hasOwnProperty3 = Object.prototype.hasOwnProperty;
var ContextKeyExpr = class {
  static has(key) {
    return ContextKeyDefinedExpr.create(key);
  }
  static equals(key, value) {
    return ContextKeyEqualsExpr.create(key, value);
  }
  static regex(key, value) {
    return ContextKeyRegexExpr.create(key, value);
  }
  static not(key) {
    return ContextKeyNotExpr.create(key);
  }
  static and(...expr) {
    return ContextKeyAndExpr.create(expr);
  }
  static or(...expr) {
    return ContextKeyOrExpr.create(expr);
  }
  static deserialize(serialized, strict = false) {
    if (!serialized) {
      return void 0;
    }
    return this._deserializeOrExpression(serialized, strict);
  }
  static _deserializeOrExpression(serialized, strict) {
    let pieces = serialized.split("||");
    return ContextKeyOrExpr.create(pieces.map((p) => this._deserializeAndExpression(p, strict)));
  }
  static _deserializeAndExpression(serialized, strict) {
    let pieces = serialized.split("&&");
    return ContextKeyAndExpr.create(pieces.map((p) => this._deserializeOne(p, strict)));
  }
  static _deserializeOne(serializedOne, strict) {
    serializedOne = serializedOne.trim();
    if (serializedOne.indexOf("!=") >= 0) {
      let pieces = serializedOne.split("!=");
      return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));
    }
    if (serializedOne.indexOf("==") >= 0) {
      let pieces = serializedOne.split("==");
      return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));
    }
    if (serializedOne.indexOf("=~") >= 0) {
      let pieces = serializedOne.split("=~");
      return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));
    }
    if (serializedOne.indexOf(" in ") >= 0) {
      let pieces = serializedOne.split(" in ");
      return ContextKeyInExpr.create(pieces[0].trim(), pieces[1].trim());
    }
    if (/^\!\s*/.test(serializedOne)) {
      return ContextKeyNotExpr.create(serializedOne.substr(1).trim());
    }
    return ContextKeyDefinedExpr.create(serializedOne);
  }
  static _deserializeValue(serializedValue, strict) {
    serializedValue = serializedValue.trim();
    if (serializedValue === "true") {
      return true;
    }
    if (serializedValue === "false") {
      return false;
    }
    let m = /^'([^']*)'$/.exec(serializedValue);
    if (m) {
      return m[1].trim();
    }
    return serializedValue;
  }
  static _deserializeRegexValue(serializedValue, strict) {
    if (isFalsyOrWhitespace(serializedValue)) {
      if (strict) {
        throw new Error("missing regexp-value for =~-expression");
      } else {
        console.warn("missing regexp-value for =~-expression");
      }
      return null;
    }
    let start = serializedValue.indexOf("/");
    let end = serializedValue.lastIndexOf("/");
    if (start === end || start < 0) {
      if (strict) {
        throw new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);
      } else {
        console.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);
      }
      return null;
    }
    let value = serializedValue.slice(start + 1, end);
    let caseIgnoreFlag = serializedValue[end + 1] === "i" ? "i" : "";
    try {
      return new RegExp(value, caseIgnoreFlag);
    } catch (e) {
      if (strict) {
        throw new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);
      } else {
        console.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);
      }
      return null;
    }
  }
};
function cmp(a, b) {
  return a.cmp(b);
}
var ContextKeyFalseExpr = class {
  constructor() {
    this.type = 0;
  }
  cmp(other) {
    return this.type - other.type;
  }
  equals(other) {
    return other.type === this.type;
  }
  evaluate(context) {
    return false;
  }
  serialize() {
    return "false";
  }
  keys() {
    return [];
  }
  negate() {
    return ContextKeyTrueExpr.INSTANCE;
  }
};
ContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();
var ContextKeyTrueExpr = class {
  constructor() {
    this.type = 1;
  }
  cmp(other) {
    return this.type - other.type;
  }
  equals(other) {
    return other.type === this.type;
  }
  evaluate(context) {
    return true;
  }
  serialize() {
    return "true";
  }
  keys() {
    return [];
  }
  negate() {
    return ContextKeyFalseExpr.INSTANCE;
  }
};
ContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();
var ContextKeyDefinedExpr = class {
  constructor(key) {
    this.key = key;
    this.type = 2;
  }
  static create(key) {
    const staticValue = STATIC_VALUES.get(key);
    if (typeof staticValue === "boolean") {
      return staticValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
    }
    return new ContextKeyDefinedExpr(key);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.key < other.key) {
      return -1;
    }
    if (this.key > other.key) {
      return 1;
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key;
    }
    return false;
  }
  evaluate(context) {
    return !!context.getValue(this.key);
  }
  serialize() {
    return this.key;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return ContextKeyNotExpr.create(this.key);
  }
};
var ContextKeyEqualsExpr = class {
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this.type = 4;
  }
  static create(key, value) {
    if (typeof value === "boolean") {
      return value ? ContextKeyDefinedExpr.create(key) : ContextKeyNotExpr.create(key);
    }
    const staticValue = STATIC_VALUES.get(key);
    if (typeof staticValue === "boolean") {
      const trueValue = staticValue ? "true" : "false";
      return value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
    }
    return new ContextKeyEqualsExpr(key, value);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.key < other.key) {
      return -1;
    }
    if (this.key > other.key) {
      return 1;
    }
    if (this.value < other.value) {
      return -1;
    }
    if (this.value > other.value) {
      return 1;
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  evaluate(context) {
    return context.getValue(this.key) == this.value;
  }
  serialize() {
    return this.key + " == '" + this.value + "'";
  }
  keys() {
    return [this.key];
  }
  negate() {
    return ContextKeyNotEqualsExpr.create(this.key, this.value);
  }
};
var ContextKeyInExpr = class {
  constructor(key, valueKey) {
    this.key = key;
    this.valueKey = valueKey;
    this.type = 10;
  }
  static create(key, valueKey) {
    return new ContextKeyInExpr(key, valueKey);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.key < other.key) {
      return -1;
    }
    if (this.key > other.key) {
      return 1;
    }
    if (this.valueKey < other.valueKey) {
      return -1;
    }
    if (this.valueKey > other.valueKey) {
      return 1;
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.valueKey === other.valueKey;
    }
    return false;
  }
  evaluate(context) {
    const source = context.getValue(this.valueKey);
    const item = context.getValue(this.key);
    if (Array.isArray(source)) {
      return source.indexOf(item) >= 0;
    }
    if (typeof item === "string" && typeof source === "object" && source !== null) {
      return hasOwnProperty3.call(source, item);
    }
    return false;
  }
  serialize() {
    return this.key + " in '" + this.valueKey + "'";
  }
  keys() {
    return [this.key, this.valueKey];
  }
  negate() {
    return ContextKeyNotInExpr.create(this);
  }
};
var ContextKeyNotInExpr = class {
  constructor(_actual) {
    this._actual = _actual;
    this.type = 11;
  }
  static create(actual) {
    return new ContextKeyNotInExpr(actual);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return this._actual.cmp(other._actual);
  }
  equals(other) {
    if (other.type === this.type) {
      return this._actual.equals(other._actual);
    }
    return false;
  }
  evaluate(context) {
    return !this._actual.evaluate(context);
  }
  serialize() {
    throw new Error("Method not implemented.");
  }
  keys() {
    return this._actual.keys();
  }
  negate() {
    return this._actual;
  }
};
var ContextKeyNotEqualsExpr = class {
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this.type = 5;
  }
  static create(key, value) {
    if (typeof value === "boolean") {
      if (value) {
        return ContextKeyNotExpr.create(key);
      }
      return ContextKeyDefinedExpr.create(key);
    }
    const staticValue = STATIC_VALUES.get(key);
    if (typeof staticValue === "boolean") {
      const falseValue = staticValue ? "true" : "false";
      return value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
    }
    return new ContextKeyNotEqualsExpr(key, value);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.key < other.key) {
      return -1;
    }
    if (this.key > other.key) {
      return 1;
    }
    if (this.value < other.value) {
      return -1;
    }
    if (this.value > other.value) {
      return 1;
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  evaluate(context) {
    return context.getValue(this.key) != this.value;
  }
  serialize() {
    return this.key + " != '" + this.value + "'";
  }
  keys() {
    return [this.key];
  }
  negate() {
    return ContextKeyEqualsExpr.create(this.key, this.value);
  }
};
var ContextKeyNotExpr = class {
  constructor(key) {
    this.key = key;
    this.type = 3;
  }
  static create(key) {
    const staticValue = STATIC_VALUES.get(key);
    if (typeof staticValue === "boolean") {
      return staticValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
    }
    return new ContextKeyNotExpr(key);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.key < other.key) {
      return -1;
    }
    if (this.key > other.key) {
      return 1;
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key;
    }
    return false;
  }
  evaluate(context) {
    return !context.getValue(this.key);
  }
  serialize() {
    return "!" + this.key;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return ContextKeyDefinedExpr.create(this.key);
  }
};
var ContextKeyRegexExpr = class {
  constructor(key, regexp) {
    this.key = key;
    this.regexp = regexp;
    this.type = 7;
  }
  static create(key, regexp) {
    return new ContextKeyRegexExpr(key, regexp);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.key < other.key) {
      return -1;
    }
    if (this.key > other.key) {
      return 1;
    }
    const thisSource = this.regexp ? this.regexp.source : "";
    const otherSource = other.regexp ? other.regexp.source : "";
    if (thisSource < otherSource) {
      return -1;
    }
    if (thisSource > otherSource) {
      return 1;
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      const thisSource = this.regexp ? this.regexp.source : "";
      const otherSource = other.regexp ? other.regexp.source : "";
      return this.key === other.key && thisSource === otherSource;
    }
    return false;
  }
  evaluate(context) {
    let value = context.getValue(this.key);
    return this.regexp ? this.regexp.test(value) : false;
  }
  serialize() {
    const value = this.regexp ? `/${this.regexp.source}/${this.regexp.ignoreCase ? "i" : ""}` : "/invalid/";
    return `${this.key} =~ ${value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return ContextKeyNotRegexExpr.create(this);
  }
};
var ContextKeyNotRegexExpr = class {
  constructor(_actual) {
    this._actual = _actual;
    this.type = 8;
  }
  static create(actual) {
    return new ContextKeyNotRegexExpr(actual);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return this._actual.cmp(other._actual);
  }
  equals(other) {
    if (other.type === this.type) {
      return this._actual.equals(other._actual);
    }
    return false;
  }
  evaluate(context) {
    return !this._actual.evaluate(context);
  }
  serialize() {
    throw new Error("Method not implemented.");
  }
  keys() {
    return this._actual.keys();
  }
  negate() {
    return this._actual;
  }
};
var ContextKeyAndExpr = class {
  constructor(expr) {
    this.expr = expr;
    this.type = 6;
  }
  static create(_expr) {
    return ContextKeyAndExpr._normalizeArr(_expr);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.expr.length < other.expr.length) {
      return -1;
    }
    if (this.expr.length > other.expr.length) {
      return 1;
    }
    for (let i = 0, len = this.expr.length; i < len; i++) {
      const r = cmp(this.expr[i], other.expr[i]);
      if (r !== 0) {
        return r;
      }
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      if (this.expr.length !== other.expr.length) {
        return false;
      }
      for (let i = 0, len = this.expr.length; i < len; i++) {
        if (!this.expr[i].equals(other.expr[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  evaluate(context) {
    for (let i = 0, len = this.expr.length; i < len; i++) {
      if (!this.expr[i].evaluate(context)) {
        return false;
      }
    }
    return true;
  }
  static _normalizeArr(arr) {
    const expr = [];
    let hasTrue = false;
    for (const e of arr) {
      if (!e) {
        continue;
      }
      if (e.type === 1) {
        hasTrue = true;
        continue;
      }
      if (e.type === 0) {
        return ContextKeyFalseExpr.INSTANCE;
      }
      if (e.type === 6) {
        expr.push(...e.expr);
        continue;
      }
      expr.push(e);
    }
    if (expr.length === 0 && hasTrue) {
      return ContextKeyTrueExpr.INSTANCE;
    }
    if (expr.length === 0) {
      return void 0;
    }
    if (expr.length === 1) {
      return expr[0];
    }
    expr.sort(cmp);
    while (expr.length > 1) {
      const lastElement = expr[expr.length - 1];
      if (lastElement.type !== 9) {
        break;
      }
      expr.pop();
      const secondToLastElement = expr.pop();
      const resultElement = ContextKeyOrExpr.create(lastElement.expr.map((el) => ContextKeyAndExpr.create([el, secondToLastElement])));
      if (resultElement) {
        expr.push(resultElement);
        expr.sort(cmp);
      }
    }
    return new ContextKeyAndExpr(expr);
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" && ");
  }
  keys() {
    const result = [];
    for (let expr of this.expr) {
      result.push(...expr.keys());
    }
    return result;
  }
  negate() {
    let result = [];
    for (let expr of this.expr) {
      result.push(expr.negate());
    }
    return ContextKeyOrExpr.create(result);
  }
};
var ContextKeyOrExpr = class {
  constructor(expr) {
    this.expr = expr;
    this.type = 9;
  }
  static create(_expr) {
    const expr = ContextKeyOrExpr._normalizeArr(_expr);
    if (expr.length === 0) {
      return void 0;
    }
    if (expr.length === 1) {
      return expr[0];
    }
    return new ContextKeyOrExpr(expr);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.expr.length < other.expr.length) {
      return -1;
    }
    if (this.expr.length > other.expr.length) {
      return 1;
    }
    for (let i = 0, len = this.expr.length; i < len; i++) {
      const r = cmp(this.expr[i], other.expr[i]);
      if (r !== 0) {
        return r;
      }
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      if (this.expr.length !== other.expr.length) {
        return false;
      }
      for (let i = 0, len = this.expr.length; i < len; i++) {
        if (!this.expr[i].equals(other.expr[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  evaluate(context) {
    for (let i = 0, len = this.expr.length; i < len; i++) {
      if (this.expr[i].evaluate(context)) {
        return true;
      }
    }
    return false;
  }
  static _normalizeArr(arr) {
    let expr = [];
    let hasFalse = false;
    if (arr) {
      for (let i = 0, len = arr.length; i < len; i++) {
        const e = arr[i];
        if (!e) {
          continue;
        }
        if (e.type === 0) {
          hasFalse = true;
          continue;
        }
        if (e.type === 1) {
          return [ContextKeyTrueExpr.INSTANCE];
        }
        if (e.type === 9) {
          expr = expr.concat(e.expr);
          continue;
        }
        expr.push(e);
      }
      if (expr.length === 0 && hasFalse) {
        return [ContextKeyFalseExpr.INSTANCE];
      }
      expr.sort(cmp);
    }
    return expr;
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" || ");
  }
  keys() {
    const result = [];
    for (let expr of this.expr) {
      result.push(...expr.keys());
    }
    return result;
  }
  negate() {
    let result = [];
    for (let expr of this.expr) {
      result.push(expr.negate());
    }
    const terminals = (node) => {
      if (node.type === 9) {
        return node.expr;
      }
      return [node];
    };
    while (result.length > 1) {
      const LEFT = result.shift();
      const RIGHT = result.shift();
      const all = [];
      for (const left of terminals(LEFT)) {
        for (const right of terminals(RIGHT)) {
          all.push(ContextKeyExpr.and(left, right));
        }
      }
      result.unshift(ContextKeyExpr.or(...all));
    }
    return result[0];
  }
};
var RawContextKey = class extends ContextKeyDefinedExpr {
  constructor(key, defaultValue) {
    super(key);
    this._defaultValue = defaultValue;
  }
  bindTo(target) {
    return target.createKey(this.key, this._defaultValue);
  }
  getValue(target) {
    return target.getContextKeyValue(this.key);
  }
  toNegated() {
    return ContextKeyExpr.not(this.key);
  }
};
var IContextKeyService = createDecorator("contextKeyService");
var SET_CONTEXT_COMMAND_ID = "setContext";

// ../../node_modules/monaco-editor/esm/vs/platform/actions/common/actions.js
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function isIMenuItem(item) {
  return item.command !== void 0;
}
var MenuId = class {
  constructor(debugName) {
    this.id = MenuId._idPool++;
    this._debugName = debugName;
  }
};
MenuId._idPool = 0;
MenuId.CommandPalette = new MenuId("CommandPalette");
MenuId.EditorContext = new MenuId("EditorContext");
MenuId.EditorContextPeek = new MenuId("EditorContextPeek");
MenuId.MenubarEditMenu = new MenuId("MenubarEditMenu");
MenuId.MenubarGoMenu = new MenuId("MenubarGoMenu");
MenuId.MenubarSelectionMenu = new MenuId("MenubarSelectionMenu");
var IMenuService = createDecorator("menuService");
var MenuRegistry = new class {
  constructor() {
    this._commands = new Map();
    this._menuItems = new Map();
    this._onDidChangeMenu = new Emitter();
    this.onDidChangeMenu = this._onDidChangeMenu.event;
    this._commandPaletteChangeEvent = {
      has: (id) => id === MenuId.CommandPalette
    };
  }
  addCommand(command) {
    return this.addCommands(Iterable.single(command));
  }
  addCommands(commands) {
    for (const command of commands) {
      this._commands.set(command.id, command);
    }
    this._onDidChangeMenu.fire(this._commandPaletteChangeEvent);
    return toDisposable(() => {
      let didChange = false;
      for (const command of commands) {
        didChange = this._commands.delete(command.id) || didChange;
      }
      if (didChange) {
        this._onDidChangeMenu.fire(this._commandPaletteChangeEvent);
      }
    });
  }
  getCommand(id) {
    return this._commands.get(id);
  }
  getCommands() {
    const map = new Map();
    this._commands.forEach((value, key) => map.set(key, value));
    return map;
  }
  appendMenuItem(id, item) {
    return this.appendMenuItems(Iterable.single({id, item}));
  }
  appendMenuItems(items) {
    const changedIds = new Set();
    const toRemove = new LinkedList();
    for (const {id, item} of items) {
      let list = this._menuItems.get(id);
      if (!list) {
        list = new LinkedList();
        this._menuItems.set(id, list);
      }
      toRemove.push(list.push(item));
      changedIds.add(id);
    }
    this._onDidChangeMenu.fire(changedIds);
    return toDisposable(() => {
      if (toRemove.size > 0) {
        for (let fn of toRemove) {
          fn();
        }
        this._onDidChangeMenu.fire(changedIds);
        toRemove.clear();
      }
    });
  }
  getMenuItems(id) {
    let result;
    if (this._menuItems.has(id)) {
      result = [...this._menuItems.get(id)];
    } else {
      result = [];
    }
    if (id === MenuId.CommandPalette) {
      this._appendImplicitItems(result);
    }
    return result;
  }
  _appendImplicitItems(result) {
    const set = new Set();
    for (const item of result) {
      if (isIMenuItem(item)) {
        set.add(item.command.id);
        if (item.alt) {
          set.add(item.alt.id);
        }
      }
    }
    this._commands.forEach((command, id) => {
      if (!set.has(id)) {
        result.push({command});
      }
    });
  }
}();
var ExecuteCommandAction = class ExecuteCommandAction2 extends Action {
  constructor(id, label, _commandService) {
    super(id, label);
    this._commandService = _commandService;
  }
  run(...args) {
    return this._commandService.executeCommand(this.id, ...args);
  }
};
ExecuteCommandAction = __decorate4([
  __param4(2, ICommandService)
], ExecuteCommandAction);
var SubmenuItemAction = class extends SubmenuAction {
  constructor(item, menuService, contextKeyService, options) {
    super(`submenuitem.${item.submenu.id}`, typeof item.title === "string" ? item.title : item.title.value, () => {
      const result = [];
      const menu = menuService.createMenu(item.submenu, contextKeyService);
      const groups = menu.getActions(options);
      menu.dispose();
      for (let group of groups) {
        const [, actions] = group;
        if (actions.length > 0) {
          result.push(...actions);
          result.push(new Separator());
        }
      }
      if (result.length) {
        result.pop();
      }
      return result;
    }, "submenu");
    this.item = item;
  }
};
var MenuItemAction = class MenuItemAction2 extends ExecuteCommandAction {
  constructor(item, alt, options, contextKeyService, commandService) {
    typeof item.title === "string" ? super(item.id, item.title, commandService) : super(item.id, item.title.value, commandService);
    this._cssClass = void 0;
    this._enabled = !item.precondition || contextKeyService.contextMatchesRules(item.precondition);
    this._tooltip = item.tooltip ? typeof item.tooltip === "string" ? item.tooltip : item.tooltip.value : void 0;
    if (item.toggled) {
      const toggled = item.toggled.condition ? item.toggled : {condition: item.toggled};
      this._checked = contextKeyService.contextMatchesRules(toggled.condition);
      if (this._checked && toggled.tooltip) {
        this._tooltip = typeof toggled.tooltip === "string" ? toggled.tooltip : toggled.tooltip.value;
      }
    }
    this._options = options || {};
    this.item = item;
    this.alt = alt ? new MenuItemAction2(alt, void 0, this._options, contextKeyService, commandService) : void 0;
  }
  dispose() {
    if (this.alt) {
      this.alt.dispose();
    }
    super.dispose();
  }
  run(...args) {
    let runArgs = [];
    if (this._options.arg) {
      runArgs = [...runArgs, this._options.arg];
    }
    if (this._options.shouldForwardArgs) {
      runArgs = [...runArgs, ...args];
    }
    return super.run(...runArgs);
  }
};
MenuItemAction = __decorate4([
  __param4(3, IContextKeyService),
  __param4(4, ICommandService)
], MenuItemAction);

// ../../node_modules/monaco-editor/esm/vs/platform/telemetry/common/telemetry.js
var ITelemetryService = createDecorator("telemetryService");

// ../../node_modules/monaco-editor/esm/vs/editor/browser/editorExtensions.js
var Command = class {
  constructor(opts) {
    this.id = opts.id;
    this.precondition = opts.precondition;
    this._kbOpts = opts.kbOpts;
    this._menuOpts = opts.menuOpts;
    this._description = opts.description;
  }
  register() {
    if (Array.isArray(this._menuOpts)) {
      this._menuOpts.forEach(this._registerMenuItem, this);
    } else if (this._menuOpts) {
      this._registerMenuItem(this._menuOpts);
    }
    if (this._kbOpts) {
      let kbWhen = this._kbOpts.kbExpr;
      if (this.precondition) {
        if (kbWhen) {
          kbWhen = ContextKeyExpr.and(kbWhen, this.precondition);
        } else {
          kbWhen = this.precondition;
        }
      }
      KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: this.id,
        handler: (accessor, args) => this.runCommand(accessor, args),
        weight: this._kbOpts.weight,
        args: this._kbOpts.args,
        when: kbWhen,
        primary: this._kbOpts.primary,
        secondary: this._kbOpts.secondary,
        win: this._kbOpts.win,
        linux: this._kbOpts.linux,
        mac: this._kbOpts.mac,
        description: this._description
      });
    } else {
      CommandsRegistry.registerCommand({
        id: this.id,
        handler: (accessor, args) => this.runCommand(accessor, args),
        description: this._description
      });
    }
  }
  _registerMenuItem(item) {
    MenuRegistry.appendMenuItem(item.menuId, {
      group: item.group,
      command: {
        id: this.id,
        title: item.title,
        icon: item.icon
      },
      when: item.when,
      order: item.order
    });
  }
};
var MultiCommand = class extends Command {
  constructor() {
    super(...arguments);
    this._implementations = [];
  }
  addImplementation(priority, implementation) {
    this._implementations.push([priority, implementation]);
    this._implementations.sort((a, b) => b[0] - a[0]);
    return {
      dispose: () => {
        for (let i = 0; i < this._implementations.length; i++) {
          if (this._implementations[i][1] === implementation) {
            this._implementations.splice(i, 1);
            return;
          }
        }
      }
    };
  }
  runCommand(accessor, args) {
    for (const impl of this._implementations) {
      if (impl[1](accessor, args)) {
        return;
      }
    }
  }
};
var ProxyCommand = class extends Command {
  constructor(command, opts) {
    super(opts);
    this.command = command;
  }
  runCommand(accessor, args) {
    return this.command.runCommand(accessor, args);
  }
};
var EditorCommand = class extends Command {
  static bindToContribution(controllerGetter) {
    return class EditorControllerCommandImpl extends EditorCommand {
      constructor(opts) {
        super(opts);
        this._callback = opts.handler;
      }
      runEditorCommand(accessor, editor2, args) {
        const controller = controllerGetter(editor2);
        if (controller) {
          this._callback(controllerGetter(editor2), args);
        }
      }
    };
  }
  runCommand(accessor, args) {
    const codeEditorService = accessor.get(ICodeEditorService);
    const editor2 = codeEditorService.getFocusedCodeEditor() || codeEditorService.getActiveCodeEditor();
    if (!editor2) {
      return;
    }
    return editor2.invokeWithinContext((editorAccessor) => {
      const kbService = editorAccessor.get(IContextKeyService);
      if (!kbService.contextMatchesRules(withNullAsUndefined(this.precondition))) {
        return;
      }
      return this.runEditorCommand(editorAccessor, editor2, args);
    });
  }
};
var EditorAction = class extends EditorCommand {
  constructor(opts) {
    super(EditorAction.convertOptions(opts));
    this.label = opts.label;
    this.alias = opts.alias;
  }
  static convertOptions(opts) {
    let menuOpts;
    if (Array.isArray(opts.menuOpts)) {
      menuOpts = opts.menuOpts;
    } else if (opts.menuOpts) {
      menuOpts = [opts.menuOpts];
    } else {
      menuOpts = [];
    }
    function withDefaults(item) {
      if (!item.menuId) {
        item.menuId = MenuId.EditorContext;
      }
      if (!item.title) {
        item.title = opts.label;
      }
      item.when = ContextKeyExpr.and(opts.precondition, item.when);
      return item;
    }
    if (Array.isArray(opts.contextMenuOpts)) {
      menuOpts.push(...opts.contextMenuOpts.map(withDefaults));
    } else if (opts.contextMenuOpts) {
      menuOpts.push(withDefaults(opts.contextMenuOpts));
    }
    opts.menuOpts = menuOpts;
    return opts;
  }
  runEditorCommand(accessor, editor2, args) {
    this.reportTelemetry(accessor, editor2);
    return this.run(accessor, editor2, args || {});
  }
  reportTelemetry(accessor, editor2) {
    accessor.get(ITelemetryService).publicLog2("editorActionInvoked", {name: this.label, id: this.id});
  }
};
function registerEditorCommand(editorCommand) {
  EditorContributionRegistry.INSTANCE.registerEditorCommand(editorCommand);
  return editorCommand;
}
function registerEditorAction(ctor) {
  const action = new ctor();
  EditorContributionRegistry.INSTANCE.registerEditorAction(action);
  return action;
}
function registerEditorContribution(id, ctor) {
  EditorContributionRegistry.INSTANCE.registerEditorContribution(id, ctor);
}
var EditorExtensionsRegistry;
(function(EditorExtensionsRegistry2) {
  function getEditorCommand(commandId) {
    return EditorContributionRegistry.INSTANCE.getEditorCommand(commandId);
  }
  EditorExtensionsRegistry2.getEditorCommand = getEditorCommand;
  function getEditorActions() {
    return EditorContributionRegistry.INSTANCE.getEditorActions();
  }
  EditorExtensionsRegistry2.getEditorActions = getEditorActions;
  function getEditorContributions() {
    return EditorContributionRegistry.INSTANCE.getEditorContributions();
  }
  EditorExtensionsRegistry2.getEditorContributions = getEditorContributions;
  function getSomeEditorContributions(ids) {
    return EditorContributionRegistry.INSTANCE.getEditorContributions().filter((c) => ids.indexOf(c.id) >= 0);
  }
  EditorExtensionsRegistry2.getSomeEditorContributions = getSomeEditorContributions;
  function getDiffEditorContributions() {
    return EditorContributionRegistry.INSTANCE.getDiffEditorContributions();
  }
  EditorExtensionsRegistry2.getDiffEditorContributions = getDiffEditorContributions;
})(EditorExtensionsRegistry || (EditorExtensionsRegistry = {}));
var Extensions4 = {
  EditorCommonContributions: "editor.contributions"
};
var EditorContributionRegistry = class {
  constructor() {
    this.editorContributions = [];
    this.diffEditorContributions = [];
    this.editorActions = [];
    this.editorCommands = Object.create(null);
  }
  registerEditorContribution(id, ctor) {
    this.editorContributions.push({id, ctor});
  }
  getEditorContributions() {
    return this.editorContributions.slice(0);
  }
  getDiffEditorContributions() {
    return this.diffEditorContributions.slice(0);
  }
  registerEditorAction(action) {
    action.register();
    this.editorActions.push(action);
  }
  getEditorActions() {
    return this.editorActions.slice(0);
  }
  registerEditorCommand(editorCommand) {
    editorCommand.register();
    this.editorCommands[editorCommand.id] = editorCommand;
  }
  getEditorCommand(commandId) {
    return this.editorCommands[commandId] || null;
  }
};
EditorContributionRegistry.INSTANCE = new EditorContributionRegistry();
Registry2.add(Extensions4.EditorCommonContributions, EditorContributionRegistry.INSTANCE);
function registerCommand(command) {
  command.register();
  return command;
}
var UndoCommand = registerCommand(new MultiCommand({
  id: "undo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2048 | 56
  },
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "1_do",
    title: localize({key: "miUndo", comment: ["&& denotes a mnemonic"]}, "&&Undo"),
    order: 1
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("undo", "Undo"),
    order: 1
  }]
}));
registerCommand(new ProxyCommand(UndoCommand, {id: "default:undo", precondition: void 0}));
var RedoCommand = registerCommand(new MultiCommand({
  id: "redo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2048 | 55,
    secondary: [2048 | 1024 | 56],
    mac: {primary: 2048 | 1024 | 56}
  },
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "1_do",
    title: localize({key: "miRedo", comment: ["&& denotes a mnemonic"]}, "&&Redo"),
    order: 2
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("redo", "Redo"),
    order: 1
  }]
}));
registerCommand(new ProxyCommand(RedoCommand, {id: "default:redo", precondition: void 0}));
var SelectAllCommand = registerCommand(new MultiCommand({
  id: "editor.action.selectAll",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    kbExpr: null,
    primary: 2048 | 31
  },
  menuOpts: [{
    menuId: MenuId.MenubarSelectionMenu,
    group: "1_basic",
    title: localize({key: "miSelectAll", comment: ["&& denotes a mnemonic"]}, "&&Select All"),
    order: 1
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("selectAll", "Select All"),
    order: 1
  }]
}));

// ../../node_modules/monaco-editor/esm/vs/base/browser/fastDomNode.js
var FastDomNode = class {
  constructor(domNode) {
    this.domNode = domNode;
    this._maxWidth = -1;
    this._width = -1;
    this._height = -1;
    this._top = -1;
    this._left = -1;
    this._bottom = -1;
    this._right = -1;
    this._fontFamily = "";
    this._fontWeight = "";
    this._fontSize = -1;
    this._fontFeatureSettings = "";
    this._lineHeight = -1;
    this._letterSpacing = -100;
    this._className = "";
    this._display = "";
    this._position = "";
    this._visibility = "";
    this._backgroundColor = "";
    this._layerHint = false;
    this._contain = "none";
    this._boxShadow = "";
  }
  setMaxWidth(maxWidth) {
    if (this._maxWidth === maxWidth) {
      return;
    }
    this._maxWidth = maxWidth;
    this.domNode.style.maxWidth = this._maxWidth + "px";
  }
  setWidth(width) {
    if (this._width === width) {
      return;
    }
    this._width = width;
    this.domNode.style.width = this._width + "px";
  }
  setHeight(height) {
    if (this._height === height) {
      return;
    }
    this._height = height;
    this.domNode.style.height = this._height + "px";
  }
  setTop(top) {
    if (this._top === top) {
      return;
    }
    this._top = top;
    this.domNode.style.top = this._top + "px";
  }
  unsetTop() {
    if (this._top === -1) {
      return;
    }
    this._top = -1;
    this.domNode.style.top = "";
  }
  setLeft(left) {
    if (this._left === left) {
      return;
    }
    this._left = left;
    this.domNode.style.left = this._left + "px";
  }
  setBottom(bottom) {
    if (this._bottom === bottom) {
      return;
    }
    this._bottom = bottom;
    this.domNode.style.bottom = this._bottom + "px";
  }
  setRight(right) {
    if (this._right === right) {
      return;
    }
    this._right = right;
    this.domNode.style.right = this._right + "px";
  }
  setFontFamily(fontFamily) {
    if (this._fontFamily === fontFamily) {
      return;
    }
    this._fontFamily = fontFamily;
    this.domNode.style.fontFamily = this._fontFamily;
  }
  setFontWeight(fontWeight) {
    if (this._fontWeight === fontWeight) {
      return;
    }
    this._fontWeight = fontWeight;
    this.domNode.style.fontWeight = this._fontWeight;
  }
  setFontSize(fontSize) {
    if (this._fontSize === fontSize) {
      return;
    }
    this._fontSize = fontSize;
    this.domNode.style.fontSize = this._fontSize + "px";
  }
  setFontFeatureSettings(fontFeatureSettings) {
    if (this._fontFeatureSettings === fontFeatureSettings) {
      return;
    }
    this._fontFeatureSettings = fontFeatureSettings;
    this.domNode.style.fontFeatureSettings = this._fontFeatureSettings;
  }
  setLineHeight(lineHeight) {
    if (this._lineHeight === lineHeight) {
      return;
    }
    this._lineHeight = lineHeight;
    this.domNode.style.lineHeight = this._lineHeight + "px";
  }
  setLetterSpacing(letterSpacing) {
    if (this._letterSpacing === letterSpacing) {
      return;
    }
    this._letterSpacing = letterSpacing;
    this.domNode.style.letterSpacing = this._letterSpacing + "px";
  }
  setClassName(className) {
    if (this._className === className) {
      return;
    }
    this._className = className;
    this.domNode.className = this._className;
  }
  toggleClassName(className, shouldHaveIt) {
    toggleClass(this.domNode, className, shouldHaveIt);
    this._className = this.domNode.className;
  }
  setDisplay(display) {
    if (this._display === display) {
      return;
    }
    this._display = display;
    this.domNode.style.display = this._display;
  }
  setPosition(position) {
    if (this._position === position) {
      return;
    }
    this._position = position;
    this.domNode.style.position = this._position;
  }
  setVisibility(visibility) {
    if (this._visibility === visibility) {
      return;
    }
    this._visibility = visibility;
    this.domNode.style.visibility = this._visibility;
  }
  setBackgroundColor(backgroundColor) {
    if (this._backgroundColor === backgroundColor) {
      return;
    }
    this._backgroundColor = backgroundColor;
    this.domNode.style.backgroundColor = this._backgroundColor;
  }
  setLayerHinting(layerHint) {
    if (this._layerHint === layerHint) {
      return;
    }
    this._layerHint = layerHint;
    this.domNode.style.transform = this._layerHint ? "translate3d(0px, 0px, 0px)" : "";
  }
  setBoxShadow(boxShadow) {
    if (this._boxShadow === boxShadow) {
      return;
    }
    this._boxShadow = boxShadow;
    this.domNode.style.boxShadow = boxShadow;
  }
  setContain(contain) {
    if (this._contain === contain) {
      return;
    }
    this._contain = contain;
    this.domNode.style.contain = this._contain;
  }
  setAttribute(name, value) {
    this.domNode.setAttribute(name, value);
  }
  removeAttribute(name) {
    this.domNode.removeAttribute(name);
  }
  appendChild(child) {
    this.domNode.appendChild(child.domNode);
  }
  removeChild(child) {
    this.domNode.removeChild(child.domNode);
  }
};
function createFastDomNode(domNode) {
  return new FastDomNode(domNode);
}

// ../../node_modules/monaco-editor/esm/vs/base/common/decorators.js
var memoizeId = 0;
function createMemoizer() {
  const memoizeKeyPrefix = `$memoize${memoizeId++}`;
  let self2 = void 0;
  const result = function memoize2(target, key, descriptor) {
    let fnKey = null;
    let fn = null;
    if (typeof descriptor.value === "function") {
      fnKey = "value";
      fn = descriptor.value;
      if (fn.length !== 0) {
        console.warn("Memoize should only be used in functions with zero parameters");
      }
    } else if (typeof descriptor.get === "function") {
      fnKey = "get";
      fn = descriptor.get;
    }
    if (!fn) {
      throw new Error("not supported");
    }
    const memoizeKey = `${memoizeKeyPrefix}:${key}`;
    descriptor[fnKey] = function(...args) {
      self2 = this;
      if (!this.hasOwnProperty(memoizeKey)) {
        Object.defineProperty(this, memoizeKey, {
          configurable: true,
          enumerable: false,
          writable: true,
          value: fn.apply(this, args)
        });
      }
      return this[memoizeKey];
    };
  };
  result.clear = () => {
    if (typeof self2 === "undefined") {
      return;
    }
    Object.getOwnPropertyNames(self2).forEach((property) => {
      if (property.indexOf(memoizeKeyPrefix) === 0) {
        delete self2[property];
      }
    });
  };
  return result;
}
function memoize(target, key, descriptor) {
  return createMemoizer()(target, key, descriptor);
}

// ../../node_modules/monaco-editor/esm/vs/base/browser/touch.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EventType2;
(function(EventType3) {
  EventType3.Tap = "-monaco-gesturetap";
  EventType3.Change = "-monaco-gesturechange";
  EventType3.Start = "-monaco-gesturestart";
  EventType3.End = "-monaco-gesturesend";
  EventType3.Contextmenu = "-monaco-gesturecontextmenu";
})(EventType2 || (EventType2 = {}));
var Gesture = class extends Disposable {
  constructor() {
    super();
    this.dispatched = false;
    this.activeTouches = {};
    this.handle = null;
    this.targets = [];
    this.ignoreTargets = [];
    this._lastSetTapCountTime = 0;
    this._register(addDisposableListener(document, "touchstart", (e) => this.onTouchStart(e), {passive: false}));
    this._register(addDisposableListener(document, "touchend", (e) => this.onTouchEnd(e)));
    this._register(addDisposableListener(document, "touchmove", (e) => this.onTouchMove(e), {passive: false}));
  }
  static addTarget(element) {
    if (!Gesture.isTouchDevice()) {
      return Disposable.None;
    }
    if (!Gesture.INSTANCE) {
      Gesture.INSTANCE = new Gesture();
    }
    Gesture.INSTANCE.targets.push(element);
    return {
      dispose: () => {
        Gesture.INSTANCE.targets = Gesture.INSTANCE.targets.filter((t) => t !== element);
      }
    };
  }
  static ignoreTarget(element) {
    if (!Gesture.isTouchDevice()) {
      return Disposable.None;
    }
    if (!Gesture.INSTANCE) {
      Gesture.INSTANCE = new Gesture();
    }
    Gesture.INSTANCE.ignoreTargets.push(element);
    return {
      dispose: () => {
        Gesture.INSTANCE.ignoreTargets = Gesture.INSTANCE.ignoreTargets.filter((t) => t !== element);
      }
    };
  }
  static isTouchDevice() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0;
  }
  dispose() {
    if (this.handle) {
      this.handle.dispose();
      this.handle = null;
    }
    super.dispose();
  }
  onTouchStart(e) {
    let timestamp = Date.now();
    if (this.handle) {
      this.handle.dispose();
      this.handle = null;
    }
    for (let i = 0, len = e.targetTouches.length; i < len; i++) {
      let touch = e.targetTouches.item(i);
      this.activeTouches[touch.identifier] = {
        id: touch.identifier,
        initialTarget: touch.target,
        initialTimeStamp: timestamp,
        initialPageX: touch.pageX,
        initialPageY: touch.pageY,
        rollingTimestamps: [timestamp],
        rollingPageX: [touch.pageX],
        rollingPageY: [touch.pageY]
      };
      let evt = this.newGestureEvent(EventType2.Start, touch.target);
      evt.pageX = touch.pageX;
      evt.pageY = touch.pageY;
      this.dispatchEvent(evt);
    }
    if (this.dispatched) {
      e.preventDefault();
      e.stopPropagation();
      this.dispatched = false;
    }
  }
  onTouchEnd(e) {
    let timestamp = Date.now();
    let activeTouchCount = Object.keys(this.activeTouches).length;
    for (let i = 0, len = e.changedTouches.length; i < len; i++) {
      let touch = e.changedTouches.item(i);
      if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
        console.warn("move of an UNKNOWN touch", touch);
        continue;
      }
      let data = this.activeTouches[touch.identifier], holdTime = Date.now() - data.initialTimeStamp;
      if (holdTime < Gesture.HOLD_DELAY && Math.abs(data.initialPageX - tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - tail(data.rollingPageY)) < 30) {
        let evt = this.newGestureEvent(EventType2.Tap, data.initialTarget);
        evt.pageX = tail(data.rollingPageX);
        evt.pageY = tail(data.rollingPageY);
        this.dispatchEvent(evt);
      } else if (holdTime >= Gesture.HOLD_DELAY && Math.abs(data.initialPageX - tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - tail(data.rollingPageY)) < 30) {
        let evt = this.newGestureEvent(EventType2.Contextmenu, data.initialTarget);
        evt.pageX = tail(data.rollingPageX);
        evt.pageY = tail(data.rollingPageY);
        this.dispatchEvent(evt);
      } else if (activeTouchCount === 1) {
        let finalX = tail(data.rollingPageX);
        let finalY = tail(data.rollingPageY);
        let deltaT = tail(data.rollingTimestamps) - data.rollingTimestamps[0];
        let deltaX = finalX - data.rollingPageX[0];
        let deltaY = finalY - data.rollingPageY[0];
        const dispatchTo = this.targets.filter((t) => data.initialTarget instanceof Node && t.contains(data.initialTarget));
        this.inertia(dispatchTo, timestamp, Math.abs(deltaX) / deltaT, deltaX > 0 ? 1 : -1, finalX, Math.abs(deltaY) / deltaT, deltaY > 0 ? 1 : -1, finalY);
      }
      this.dispatchEvent(this.newGestureEvent(EventType2.End, data.initialTarget));
      delete this.activeTouches[touch.identifier];
    }
    if (this.dispatched) {
      e.preventDefault();
      e.stopPropagation();
      this.dispatched = false;
    }
  }
  newGestureEvent(type, initialTarget) {
    let event = document.createEvent("CustomEvent");
    event.initEvent(type, false, true);
    event.initialTarget = initialTarget;
    event.tapCount = 0;
    return event;
  }
  dispatchEvent(event) {
    if (event.type === EventType2.Tap) {
      const currentTime = new Date().getTime();
      let setTapCount = 0;
      if (currentTime - this._lastSetTapCountTime > Gesture.CLEAR_TAP_COUNT_TIME) {
        setTapCount = 1;
      } else {
        setTapCount = 2;
      }
      this._lastSetTapCountTime = currentTime;
      event.tapCount = setTapCount;
    } else if (event.type === EventType2.Change || event.type === EventType2.Contextmenu) {
      this._lastSetTapCountTime = 0;
    }
    for (let i = 0; i < this.ignoreTargets.length; i++) {
      if (event.initialTarget instanceof Node && this.ignoreTargets[i].contains(event.initialTarget)) {
        return;
      }
    }
    this.targets.forEach((target) => {
      if (event.initialTarget instanceof Node && target.contains(event.initialTarget)) {
        target.dispatchEvent(event);
        this.dispatched = true;
      }
    });
  }
  inertia(dispatchTo, t1, vX, dirX, x, vY, dirY, y) {
    this.handle = scheduleAtNextAnimationFrame(() => {
      let now = Date.now();
      let deltaT = now - t1, delta_pos_x = 0, delta_pos_y = 0, stopped = true;
      vX += Gesture.SCROLL_FRICTION * deltaT;
      vY += Gesture.SCROLL_FRICTION * deltaT;
      if (vX > 0) {
        stopped = false;
        delta_pos_x = dirX * vX * deltaT;
      }
      if (vY > 0) {
        stopped = false;
        delta_pos_y = dirY * vY * deltaT;
      }
      let evt = this.newGestureEvent(EventType2.Change);
      evt.translationX = delta_pos_x;
      evt.translationY = delta_pos_y;
      dispatchTo.forEach((d) => d.dispatchEvent(evt));
      if (!stopped) {
        this.inertia(dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);
      }
    });
  }
  onTouchMove(e) {
    let timestamp = Date.now();
    for (let i = 0, len = e.changedTouches.length; i < len; i++) {
      let touch = e.changedTouches.item(i);
      if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
        console.warn("end of an UNKNOWN touch", touch);
        continue;
      }
      let data = this.activeTouches[touch.identifier];
      let evt = this.newGestureEvent(EventType2.Change, data.initialTarget);
      evt.translationX = touch.pageX - tail(data.rollingPageX);
      evt.translationY = touch.pageY - tail(data.rollingPageY);
      evt.pageX = touch.pageX;
      evt.pageY = touch.pageY;
      this.dispatchEvent(evt);
      if (data.rollingPageX.length > 3) {
        data.rollingPageX.shift();
        data.rollingPageY.shift();
        data.rollingTimestamps.shift();
      }
      data.rollingPageX.push(touch.pageX);
      data.rollingPageY.push(touch.pageY);
      data.rollingTimestamps.push(timestamp);
    }
    if (this.dispatched) {
      e.preventDefault();
      e.stopPropagation();
      this.dispatched = false;
    }
  }
};
Gesture.SCROLL_FRICTION = -5e-3;
Gesture.HOLD_DELAY = 700;
Gesture.CLEAR_TAP_COUNT_TIME = 400;
__decorate5([
  memoize
], Gesture, "isTouchDevice", null);

// ../../node_modules/monaco-editor/esm/vs/base/browser/globalMouseMoveMonitor.js
function standardMouseMoveMerger(lastEvent, currentEvent) {
  let ev = new StandardMouseEvent(currentEvent);
  ev.preventDefault();
  return {
    leftButton: ev.leftButton,
    buttons: ev.buttons,
    posx: ev.posx,
    posy: ev.posy
  };
}
var GlobalMouseMoveMonitor = class {
  constructor() {
    this._hooks = new DisposableStore();
    this._mouseMoveEventMerger = null;
    this._mouseMoveCallback = null;
    this._onStopCallback = null;
  }
  dispose() {
    this.stopMonitoring(false);
    this._hooks.dispose();
  }
  stopMonitoring(invokeStopCallback) {
    if (!this.isMonitoring()) {
      return;
    }
    this._hooks.clear();
    this._mouseMoveEventMerger = null;
    this._mouseMoveCallback = null;
    const onStopCallback = this._onStopCallback;
    this._onStopCallback = null;
    if (invokeStopCallback && onStopCallback) {
      onStopCallback();
    }
  }
  isMonitoring() {
    return !!this._mouseMoveEventMerger;
  }
  startMonitoring(initialElement, initialButtons, mouseMoveEventMerger, mouseMoveCallback, onStopCallback) {
    if (this.isMonitoring()) {
      return;
    }
    this._mouseMoveEventMerger = mouseMoveEventMerger;
    this._mouseMoveCallback = mouseMoveCallback;
    this._onStopCallback = onStopCallback;
    const windowChain = IframeUtils.getSameOriginWindowChain();
    const mouseMove = isIOS && BrowserFeatures.pointerEvents ? "pointermove" : "mousemove";
    const mouseUp = isIOS && BrowserFeatures.pointerEvents ? "pointerup" : "mouseup";
    const listenTo = windowChain.map((element) => element.window.document);
    const shadowRoot = getShadowRoot(initialElement);
    if (shadowRoot) {
      listenTo.unshift(shadowRoot);
    }
    for (const element of listenTo) {
      this._hooks.add(addDisposableThrottledListener(element, mouseMove, (data) => {
        if (data.buttons !== initialButtons) {
          this.stopMonitoring(true);
          return;
        }
        this._mouseMoveCallback(data);
      }, (lastEvent, currentEvent) => this._mouseMoveEventMerger(lastEvent, currentEvent)));
      this._hooks.add(addDisposableListener(element, mouseUp, (e) => this.stopMonitoring(true)));
    }
    if (IframeUtils.hasDifferentOriginAncestor()) {
      let lastSameOriginAncestor = windowChain[windowChain.length - 1];
      this._hooks.add(addDisposableListener(lastSameOriginAncestor.window.document, "mouseout", (browserEvent) => {
        let e = new StandardMouseEvent(browserEvent);
        if (e.target.tagName.toLowerCase() === "html") {
          this.stopMonitoring(true);
        }
      }));
      this._hooks.add(addDisposableListener(lastSameOriginAncestor.window.document, "mouseover", (browserEvent) => {
        let e = new StandardMouseEvent(browserEvent);
        if (e.target.tagName.toLowerCase() === "html") {
          this.stopMonitoring(true);
        }
      }));
      this._hooks.add(addDisposableListener(lastSameOriginAncestor.window.document.body, "mouseleave", (browserEvent) => {
        this.stopMonitoring(true);
      }));
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/editorDom.js
var PageCoordinates = class {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  toClientCoordinates() {
    return new ClientCoordinates(this.x - StandardWindow.scrollX, this.y - StandardWindow.scrollY);
  }
};
var ClientCoordinates = class {
  constructor(clientX, clientY) {
    this.clientX = clientX;
    this.clientY = clientY;
  }
  toPageCoordinates() {
    return new PageCoordinates(this.clientX + StandardWindow.scrollX, this.clientY + StandardWindow.scrollY);
  }
};
var EditorPagePosition = class {
  constructor(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
};
function createEditorPagePosition(editorViewDomNode) {
  const editorPos = getDomNodePagePosition(editorViewDomNode);
  return new EditorPagePosition(editorPos.left, editorPos.top, editorPos.width, editorPos.height);
}
var EditorMouseEvent = class extends StandardMouseEvent {
  constructor(e, editorViewDomNode) {
    super(e);
    this.pos = new PageCoordinates(this.posx, this.posy);
    this.editorPos = createEditorPagePosition(editorViewDomNode);
  }
};
var EditorMouseEventFactory = class {
  constructor(editorViewDomNode) {
    this._editorViewDomNode = editorViewDomNode;
  }
  _create(e) {
    return new EditorMouseEvent(e, this._editorViewDomNode);
  }
  onContextMenu(target, callback) {
    return addDisposableListener(target, "contextmenu", (e) => {
      callback(this._create(e));
    });
  }
  onMouseUp(target, callback) {
    return addDisposableListener(target, "mouseup", (e) => {
      callback(this._create(e));
    });
  }
  onMouseDown(target, callback) {
    return addDisposableListener(target, "mousedown", (e) => {
      callback(this._create(e));
    });
  }
  onMouseLeave(target, callback) {
    return addDisposableNonBubblingMouseOutListener(target, (e) => {
      callback(this._create(e));
    });
  }
  onMouseMoveThrottled(target, callback, merger, minimumTimeMs) {
    const myMerger = (lastEvent, currentEvent) => {
      return merger(lastEvent, this._create(currentEvent));
    };
    return addDisposableThrottledListener(target, "mousemove", callback, myMerger, minimumTimeMs);
  }
};
var EditorPointerEventFactory = class {
  constructor(editorViewDomNode) {
    this._editorViewDomNode = editorViewDomNode;
  }
  _create(e) {
    return new EditorMouseEvent(e, this._editorViewDomNode);
  }
  onPointerUp(target, callback) {
    return addDisposableListener(target, "pointerup", (e) => {
      callback(this._create(e));
    });
  }
  onPointerDown(target, callback) {
    return addDisposableListener(target, "pointerdown", (e) => {
      callback(this._create(e));
    });
  }
  onPointerLeave(target, callback) {
    return addDisposableNonBubblingPointerOutListener(target, (e) => {
      callback(this._create(e));
    });
  }
  onPointerMoveThrottled(target, callback, merger, minimumTimeMs) {
    const myMerger = (lastEvent, currentEvent) => {
      return merger(lastEvent, this._create(currentEvent));
    };
    return addDisposableThrottledListener(target, "pointermove", callback, myMerger, minimumTimeMs);
  }
};
var GlobalEditorMouseMoveMonitor = class extends Disposable {
  constructor(editorViewDomNode) {
    super();
    this._editorViewDomNode = editorViewDomNode;
    this._globalMouseMoveMonitor = this._register(new GlobalMouseMoveMonitor());
    this._keydownListener = null;
  }
  startMonitoring(initialElement, initialButtons, merger, mouseMoveCallback, onStopCallback) {
    this._keydownListener = addStandardDisposableListener(document, "keydown", (e) => {
      const kb = e.toKeybinding();
      if (kb.isModifierKey()) {
        return;
      }
      this._globalMouseMoveMonitor.stopMonitoring(true);
    }, true);
    const myMerger = (lastEvent, currentEvent) => {
      return merger(lastEvent, new EditorMouseEvent(currentEvent, this._editorViewDomNode));
    };
    this._globalMouseMoveMonitor.startMonitoring(initialElement, initialButtons, myMerger, mouseMoveCallback, () => {
      this._keydownListener.dispose();
      onStopCallback();
    });
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewEventHandler.js
var ViewEventHandler = class extends Disposable {
  constructor() {
    super();
    this._shouldRender = true;
  }
  shouldRender() {
    return this._shouldRender;
  }
  forceShouldRender() {
    this._shouldRender = true;
  }
  setShouldRender() {
    this._shouldRender = true;
  }
  onDidRender() {
    this._shouldRender = false;
  }
  onConfigurationChanged(e) {
    return false;
  }
  onCursorStateChanged(e) {
    return false;
  }
  onDecorationsChanged(e) {
    return false;
  }
  onFlushed(e) {
    return false;
  }
  onFocusChanged(e) {
    return false;
  }
  onLanguageConfigurationChanged(e) {
    return false;
  }
  onLineMappingChanged(e) {
    return false;
  }
  onLinesChanged(e) {
    return false;
  }
  onLinesDeleted(e) {
    return false;
  }
  onLinesInserted(e) {
    return false;
  }
  onRevealRangeRequest(e) {
    return false;
  }
  onScrollChanged(e) {
    return false;
  }
  onThemeChanged(e) {
    return false;
  }
  onTokensChanged(e) {
    return false;
  }
  onTokensColorsChanged(e) {
    return false;
  }
  onZonesChanged(e) {
    return false;
  }
  handleEvents(events) {
    let shouldRender = false;
    for (let i = 0, len = events.length; i < len; i++) {
      let e = events[i];
      switch (e.type) {
        case 0:
          if (this.onConfigurationChanged(e)) {
            shouldRender = true;
          }
          break;
        case 1:
          if (this.onCursorStateChanged(e)) {
            shouldRender = true;
          }
          break;
        case 2:
          if (this.onDecorationsChanged(e)) {
            shouldRender = true;
          }
          break;
        case 3:
          if (this.onFlushed(e)) {
            shouldRender = true;
          }
          break;
        case 4:
          if (this.onFocusChanged(e)) {
            shouldRender = true;
          }
          break;
        case 5:
          if (this.onLanguageConfigurationChanged(e)) {
            shouldRender = true;
          }
          break;
        case 6:
          if (this.onLineMappingChanged(e)) {
            shouldRender = true;
          }
          break;
        case 7:
          if (this.onLinesChanged(e)) {
            shouldRender = true;
          }
          break;
        case 8:
          if (this.onLinesDeleted(e)) {
            shouldRender = true;
          }
          break;
        case 9:
          if (this.onLinesInserted(e)) {
            shouldRender = true;
          }
          break;
        case 10:
          if (this.onRevealRangeRequest(e)) {
            shouldRender = true;
          }
          break;
        case 11:
          if (this.onScrollChanged(e)) {
            shouldRender = true;
          }
          break;
        case 13:
          if (this.onTokensChanged(e)) {
            shouldRender = true;
          }
          break;
        case 12:
          if (this.onThemeChanged(e)) {
            shouldRender = true;
          }
          break;
        case 14:
          if (this.onTokensColorsChanged(e)) {
            shouldRender = true;
          }
          break;
        case 15:
          if (this.onZonesChanged(e)) {
            shouldRender = true;
          }
          break;
        default:
          console.info("View received unknown event: ");
          console.info(e);
      }
    }
    if (shouldRender) {
      this._shouldRender = true;
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/view/viewPart.js
var ViewPart = class extends ViewEventHandler {
  constructor(context) {
    super();
    this._context = context;
    this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this);
    super.dispose();
  }
};
var PartFingerprints = class {
  static write(target, partId) {
    if (target instanceof FastDomNode) {
      target.setAttribute("data-mprt", String(partId));
    } else {
      target.setAttribute("data-mprt", String(partId));
    }
  }
  static read(target) {
    const r = target.getAttribute("data-mprt");
    if (r === null) {
      return 0;
    }
    return parseInt(r, 10);
  }
  static collect(child, stopAt) {
    let result = [], resultLen = 0;
    while (child && child !== document.body) {
      if (child === stopAt) {
        break;
      }
      if (child.nodeType === child.ELEMENT_NODE) {
        result[resultLen++] = this.read(child);
      }
      child = child.parentElement;
    }
    const r = new Uint8Array(resultLen);
    for (let i = 0; i < resultLen; i++) {
      r[i] = result[resultLen - i - 1];
    }
    return r;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/view/renderingContext.js
var RestrictedRenderingContext = class {
  constructor(viewLayout, viewportData) {
    this._viewLayout = viewLayout;
    this.viewportData = viewportData;
    this.scrollWidth = this._viewLayout.getScrollWidth();
    this.scrollHeight = this._viewLayout.getScrollHeight();
    this.visibleRange = this.viewportData.visibleRange;
    this.bigNumbersDelta = this.viewportData.bigNumbersDelta;
    const vInfo = this._viewLayout.getCurrentViewport();
    this.scrollTop = vInfo.top;
    this.scrollLeft = vInfo.left;
    this.viewportWidth = vInfo.width;
    this.viewportHeight = vInfo.height;
  }
  getScrolledTopFromAbsoluteTop(absoluteTop) {
    return absoluteTop - this.scrollTop;
  }
  getVerticalOffsetForLineNumber(lineNumber) {
    return this._viewLayout.getVerticalOffsetForLineNumber(lineNumber);
  }
  getDecorationsInViewport() {
    return this.viewportData.getDecorationsInViewport();
  }
};
var RenderingContext = class extends RestrictedRenderingContext {
  constructor(viewLayout, viewportData, viewLines) {
    super(viewLayout, viewportData);
    this._viewLines = viewLines;
  }
  linesVisibleRangesForRange(range2, includeNewLines) {
    return this._viewLines.linesVisibleRangesForRange(range2, includeNewLines);
  }
  visibleRangeForPosition(position) {
    return this._viewLines.visibleRangeForPosition(position);
  }
};
var LineVisibleRanges = class {
  constructor(outsideRenderedLine, lineNumber, ranges) {
    this.outsideRenderedLine = outsideRenderedLine;
    this.lineNumber = lineNumber;
    this.ranges = ranges;
  }
};
var HorizontalRange = class {
  constructor(left, width) {
    this.left = Math.round(left);
    this.width = Math.round(width);
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
};
var HorizontalPosition = class {
  constructor(outsideRenderedLine, left) {
    this.outsideRenderedLine = outsideRenderedLine;
    this.left = Math.round(left);
  }
};
var VisibleRanges = class {
  constructor(outsideRenderedLine, ranges) {
    this.outsideRenderedLine = outsideRenderedLine;
    this.ranges = ranges;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/rangeUtil.js
var FloatHorizontalRange = class {
  constructor(left, width) {
    this.left = left;
    this.width = width;
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
  static compare(a, b) {
    return a.left - b.left;
  }
};
var RangeUtil = class {
  static _createRange() {
    if (!this._handyReadyRange) {
      this._handyReadyRange = document.createRange();
    }
    return this._handyReadyRange;
  }
  static _detachRange(range2, endNode) {
    range2.selectNodeContents(endNode);
  }
  static _readClientRects(startElement, startOffset, endElement, endOffset, endNode) {
    const range2 = this._createRange();
    try {
      range2.setStart(startElement, startOffset);
      range2.setEnd(endElement, endOffset);
      return range2.getClientRects();
    } catch (e) {
      return null;
    } finally {
      this._detachRange(range2, endNode);
    }
  }
  static _mergeAdjacentRanges(ranges) {
    if (ranges.length === 1) {
      return [new HorizontalRange(ranges[0].left, ranges[0].width)];
    }
    ranges.sort(FloatHorizontalRange.compare);
    let result = [], resultLen = 0;
    let prevLeft = ranges[0].left;
    let prevWidth = ranges[0].width;
    for (let i = 1, len = ranges.length; i < len; i++) {
      const range2 = ranges[i];
      const myLeft = range2.left;
      const myWidth = range2.width;
      if (prevLeft + prevWidth + 0.9 >= myLeft) {
        prevWidth = Math.max(prevWidth, myLeft + myWidth - prevLeft);
      } else {
        result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);
        prevLeft = myLeft;
        prevWidth = myWidth;
      }
    }
    result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);
    return result;
  }
  static _createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft) {
    if (!clientRects || clientRects.length === 0) {
      return null;
    }
    const result = [];
    for (let i = 0, len = clientRects.length; i < len; i++) {
      const clientRect = clientRects[i];
      result[i] = new FloatHorizontalRange(Math.max(0, clientRect.left - clientRectDeltaLeft), clientRect.width);
    }
    return this._mergeAdjacentRanges(result);
  }
  static readHorizontalRanges(domNode, startChildIndex, startOffset, endChildIndex, endOffset, clientRectDeltaLeft, endNode) {
    const min = 0;
    const max = domNode.children.length - 1;
    if (min > max) {
      return null;
    }
    startChildIndex = Math.min(max, Math.max(min, startChildIndex));
    endChildIndex = Math.min(max, Math.max(min, endChildIndex));
    if (startChildIndex === endChildIndex && startOffset === endOffset && startOffset === 0) {
      const clientRects2 = domNode.children[startChildIndex].getClientRects();
      return this._createHorizontalRangesFromClientRects(clientRects2, clientRectDeltaLeft);
    }
    if (startChildIndex !== endChildIndex) {
      if (endChildIndex > 0 && endOffset === 0) {
        endChildIndex--;
        endOffset = 1073741824;
      }
    }
    let startElement = domNode.children[startChildIndex].firstChild;
    let endElement = domNode.children[endChildIndex].firstChild;
    if (!startElement || !endElement) {
      if (!startElement && startOffset === 0 && startChildIndex > 0) {
        startElement = domNode.children[startChildIndex - 1].firstChild;
        startOffset = 1073741824;
      }
      if (!endElement && endOffset === 0 && endChildIndex > 0) {
        endElement = domNode.children[endChildIndex - 1].firstChild;
        endOffset = 1073741824;
      }
    }
    if (!startElement || !endElement) {
      return null;
    }
    startOffset = Math.min(startElement.textContent.length, Math.max(0, startOffset));
    endOffset = Math.min(endElement.textContent.length, Math.max(0, endOffset));
    const clientRects = this._readClientRects(startElement, startOffset, endElement, endOffset, endNode);
    return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft);
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/theme/common/themeService.js
var IThemeService = createDecorator("themeService");
function themeColorFromId(id) {
  return {id};
}
var ThemeIcon;
(function(ThemeIcon2) {
  function isThemeIcon(obj) {
    return obj && typeof obj === "object" && typeof obj.id === "string";
  }
  ThemeIcon2.isThemeIcon = isThemeIcon;
  const _regexFromString = /^\$\(([a-z.]+\/)?([a-z-~]+)\)$/i;
  function fromString(str) {
    const match2 = _regexFromString.exec(str);
    if (!match2) {
      return void 0;
    }
    let [, owner, name] = match2;
    if (!owner) {
      owner = `codicon/`;
    }
    return {id: owner + name};
  }
  ThemeIcon2.fromString = fromString;
  const _regexAsClassName = /^(codicon\/)?([a-z-]+)(~[a-z]+)?$/i;
  function asClassName(icon) {
    const match2 = _regexAsClassName.exec(icon.id);
    if (!match2) {
      return void 0;
    }
    let [, , name, modifier] = match2;
    let className = `codicon codicon-${name}`;
    if (modifier) {
      className += ` ${modifier.substr(1)}`;
    }
    return className;
  }
  ThemeIcon2.asClassName = asClassName;
})(ThemeIcon || (ThemeIcon = {}));
var DARK = "dark";
var HIGH_CONTRAST = "hc";
function getThemeTypeSelector(type) {
  switch (type) {
    case DARK:
      return "vs-dark";
    case HIGH_CONTRAST:
      return "hc-black";
    default:
      return "vs";
  }
}
var Extensions5 = {
  ThemingContribution: "base.contributions.theming"
};
var ThemingRegistry = class {
  constructor() {
    this.themingParticipants = [];
    this.themingParticipants = [];
    this.onThemingParticipantAddedEmitter = new Emitter();
  }
  onColorThemeChange(participant) {
    this.themingParticipants.push(participant);
    this.onThemingParticipantAddedEmitter.fire(participant);
    return toDisposable(() => {
      const idx = this.themingParticipants.indexOf(participant);
      this.themingParticipants.splice(idx, 1);
    });
  }
  getThemingParticipants() {
    return this.themingParticipants;
  }
};
var themingRegistry = new ThemingRegistry();
Registry2.add(Extensions5.ThemingContribution, themingRegistry);
function registerThemingParticipant(participant) {
  return themingRegistry.onColorThemeChange(participant);
}
var Themable = class extends Disposable {
  constructor(themeService) {
    super();
    this.themeService = themeService;
    this.theme = themeService.getColorTheme();
    this._register(this.themeService.onDidColorThemeChange((theme) => this.onThemeChange(theme)));
  }
  onThemeChange(theme) {
    this.theme = theme;
    this.updateStyles();
  }
  updateStyles() {
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLine.js
var canUseFastRenderedViewLine = function() {
  if (isNative) {
    return true;
  }
  if (isLinux || isFirefox || isSafari) {
    return false;
  }
  return true;
}();
var monospaceAssumptionsAreValid = true;
var alwaysRenderInlineSelection = isEdge;
var DomReadingContext = class {
  constructor(domNode, endNode) {
    this._domNode = domNode;
    this._clientRectDeltaLeft = 0;
    this._clientRectDeltaLeftRead = false;
    this.endNode = endNode;
  }
  get clientRectDeltaLeft() {
    if (!this._clientRectDeltaLeftRead) {
      this._clientRectDeltaLeftRead = true;
      this._clientRectDeltaLeft = this._domNode.getBoundingClientRect().left;
    }
    return this._clientRectDeltaLeft;
  }
};
var ViewLineOptions = class {
  constructor(config, themeType) {
    this.themeType = themeType;
    const options = config.options;
    const fontInfo = options.get(36);
    this.renderWhitespace = options.get(80);
    this.renderControlCharacters = options.get(74);
    this.spaceWidth = fontInfo.spaceWidth;
    this.middotWidth = fontInfo.middotWidth;
    this.wsmiddotWidth = fontInfo.wsmiddotWidth;
    this.useMonospaceOptimizations = fontInfo.isMonospace && !options.get(24);
    this.canUseHalfwidthRightwardsArrow = fontInfo.canUseHalfwidthRightwardsArrow;
    this.lineHeight = options.get(51);
    this.stopRenderingLineAfter = options.get(95);
    this.fontLigatures = options.get(37);
  }
  equals(other) {
    return this.themeType === other.themeType && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.spaceWidth === other.spaceWidth && this.middotWidth === other.middotWidth && this.wsmiddotWidth === other.wsmiddotWidth && this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineHeight === other.lineHeight && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.fontLigatures === other.fontLigatures;
  }
};
var ViewLine = class {
  constructor(options) {
    this._options = options;
    this._isMaybeInvalid = true;
    this._renderedViewLine = null;
  }
  getDomNode() {
    if (this._renderedViewLine && this._renderedViewLine.domNode) {
      return this._renderedViewLine.domNode.domNode;
    }
    return null;
  }
  setDomNode(domNode) {
    if (this._renderedViewLine) {
      this._renderedViewLine.domNode = createFastDomNode(domNode);
    } else {
      throw new Error("I have no rendered view line to set the dom node to...");
    }
  }
  onContentChanged() {
    this._isMaybeInvalid = true;
  }
  onTokensChanged() {
    this._isMaybeInvalid = true;
  }
  onDecorationsChanged() {
    this._isMaybeInvalid = true;
  }
  onOptionsChanged(newOptions) {
    this._isMaybeInvalid = true;
    this._options = newOptions;
  }
  onSelectionChanged() {
    if (alwaysRenderInlineSelection || this._options.themeType === HIGH_CONTRAST || this._options.renderWhitespace === "selection") {
      this._isMaybeInvalid = true;
      return true;
    }
    return false;
  }
  renderLine(lineNumber, deltaTop, viewportData, sb) {
    if (this._isMaybeInvalid === false) {
      return false;
    }
    this._isMaybeInvalid = false;
    const lineData = viewportData.getViewLineRenderingData(lineNumber);
    const options = this._options;
    const actualInlineDecorations = LineDecoration.filter(lineData.inlineDecorations, lineNumber, lineData.minColumn, lineData.maxColumn);
    let selectionsOnLine = null;
    if (alwaysRenderInlineSelection || options.themeType === HIGH_CONTRAST || this._options.renderWhitespace === "selection") {
      const selections = viewportData.selections;
      for (const selection of selections) {
        if (selection.endLineNumber < lineNumber || selection.startLineNumber > lineNumber) {
          continue;
        }
        const startColumn = selection.startLineNumber === lineNumber ? selection.startColumn : lineData.minColumn;
        const endColumn = selection.endLineNumber === lineNumber ? selection.endColumn : lineData.maxColumn;
        if (startColumn < endColumn) {
          if (options.themeType === HIGH_CONTRAST || this._options.renderWhitespace !== "selection") {
            actualInlineDecorations.push(new LineDecoration(startColumn, endColumn, "inline-selected-text", 0));
          } else {
            if (!selectionsOnLine) {
              selectionsOnLine = [];
            }
            selectionsOnLine.push(new LineRange(startColumn - 1, endColumn - 1));
          }
        }
      }
    }
    const renderLineInput = new RenderLineInput(options.useMonospaceOptimizations, options.canUseHalfwidthRightwardsArrow, lineData.content, lineData.continuesWithWrappedLine, lineData.isBasicASCII, lineData.containsRTL, lineData.minColumn - 1, lineData.tokens, actualInlineDecorations, lineData.tabSize, lineData.startVisibleColumn, options.spaceWidth, options.middotWidth, options.wsmiddotWidth, options.stopRenderingLineAfter, options.renderWhitespace, options.renderControlCharacters, options.fontLigatures !== EditorFontLigatures.OFF, selectionsOnLine);
    if (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {
      return false;
    }
    sb.appendASCIIString('<div style="top:');
    sb.appendASCIIString(String(deltaTop));
    sb.appendASCIIString("px;height:");
    sb.appendASCIIString(String(this._options.lineHeight));
    sb.appendASCIIString('px;" class="');
    sb.appendASCIIString(ViewLine.CLASS_NAME);
    sb.appendASCIIString('">');
    const output = renderViewLine(renderLineInput, sb);
    sb.appendASCIIString("</div>");
    let renderedViewLine = null;
    if (monospaceAssumptionsAreValid && canUseFastRenderedViewLine && lineData.isBasicASCII && options.useMonospaceOptimizations && output.containsForeignElements === 0) {
      if (lineData.content.length < 300 && renderLineInput.lineTokens.getCount() < 100) {
        renderedViewLine = new FastRenderedViewLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping);
      }
    }
    if (!renderedViewLine) {
      renderedViewLine = createRenderedLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping, output.containsRTL, output.containsForeignElements);
    }
    this._renderedViewLine = renderedViewLine;
    return true;
  }
  layoutLine(lineNumber, deltaTop) {
    if (this._renderedViewLine && this._renderedViewLine.domNode) {
      this._renderedViewLine.domNode.setTop(deltaTop);
      this._renderedViewLine.domNode.setHeight(this._options.lineHeight);
    }
  }
  getWidth() {
    if (!this._renderedViewLine) {
      return 0;
    }
    return this._renderedViewLine.getWidth();
  }
  getWidthIsFast() {
    if (!this._renderedViewLine) {
      return true;
    }
    return this._renderedViewLine.getWidthIsFast();
  }
  needsMonospaceFontCheck() {
    if (!this._renderedViewLine) {
      return false;
    }
    return this._renderedViewLine instanceof FastRenderedViewLine;
  }
  monospaceAssumptionsAreValid() {
    if (!this._renderedViewLine) {
      return monospaceAssumptionsAreValid;
    }
    if (this._renderedViewLine instanceof FastRenderedViewLine) {
      return this._renderedViewLine.monospaceAssumptionsAreValid();
    }
    return monospaceAssumptionsAreValid;
  }
  onMonospaceAssumptionsInvalidated() {
    if (this._renderedViewLine && this._renderedViewLine instanceof FastRenderedViewLine) {
      this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine();
    }
  }
  getVisibleRangesForRange(startColumn, endColumn, context) {
    if (!this._renderedViewLine) {
      return null;
    }
    startColumn = startColumn | 0;
    endColumn = endColumn | 0;
    startColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, startColumn));
    endColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, endColumn));
    const stopRenderingLineAfter = this._renderedViewLine.input.stopRenderingLineAfter | 0;
    let outsideRenderedLine = false;
    if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1 && endColumn > stopRenderingLineAfter + 1) {
      outsideRenderedLine = true;
    }
    if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1) {
      startColumn = stopRenderingLineAfter + 1;
    }
    if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter + 1) {
      endColumn = stopRenderingLineAfter + 1;
    }
    const horizontalRanges = this._renderedViewLine.getVisibleRangesForRange(startColumn, endColumn, context);
    if (horizontalRanges && horizontalRanges.length > 0) {
      return new VisibleRanges(outsideRenderedLine, horizontalRanges);
    }
    return null;
  }
  getColumnOfNodeOffset(lineNumber, spanNode, offset) {
    if (!this._renderedViewLine) {
      return 1;
    }
    return this._renderedViewLine.getColumnOfNodeOffset(lineNumber, spanNode, offset);
  }
};
ViewLine.CLASS_NAME = "view-line";
var FastRenderedViewLine = class {
  constructor(domNode, renderLineInput, characterMapping) {
    this.domNode = domNode;
    this.input = renderLineInput;
    this._characterMapping = characterMapping;
    this._charWidth = renderLineInput.spaceWidth;
  }
  getWidth() {
    return this._getCharPosition(this._characterMapping.length);
  }
  getWidthIsFast() {
    return true;
  }
  monospaceAssumptionsAreValid() {
    if (!this.domNode) {
      return monospaceAssumptionsAreValid;
    }
    const expectedWidth = this.getWidth();
    const actualWidth = this.domNode.domNode.firstChild.offsetWidth;
    if (Math.abs(expectedWidth - actualWidth) >= 2) {
      console.warn(`monospace assumptions have been violated, therefore disabling monospace optimizations!`);
      monospaceAssumptionsAreValid = false;
    }
    return monospaceAssumptionsAreValid;
  }
  toSlowRenderedLine() {
    return createRenderedLine(this.domNode, this.input, this._characterMapping, false, 0);
  }
  getVisibleRangesForRange(startColumn, endColumn, context) {
    const startPosition = this._getCharPosition(startColumn);
    const endPosition = this._getCharPosition(endColumn);
    return [new HorizontalRange(startPosition, endPosition - startPosition)];
  }
  _getCharPosition(column) {
    const charOffset = this._characterMapping.getAbsoluteOffsets();
    if (charOffset.length === 0) {
      return 0;
    }
    return Math.round(this._charWidth * charOffset[column - 1]);
  }
  getColumnOfNodeOffset(lineNumber, spanNode, offset) {
    const spanNodeTextContentLength = spanNode.textContent.length;
    let spanIndex = -1;
    while (spanNode) {
      spanNode = spanNode.previousSibling;
      spanIndex++;
    }
    const charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);
    return charOffset + 1;
  }
};
var RenderedViewLine = class {
  constructor(domNode, renderLineInput, characterMapping, containsRTL2, containsForeignElements) {
    this.domNode = domNode;
    this.input = renderLineInput;
    this._characterMapping = characterMapping;
    this._isWhitespaceOnly = /^\s*$/.test(renderLineInput.lineContent);
    this._containsForeignElements = containsForeignElements;
    this._cachedWidth = -1;
    this._pixelOffsetCache = null;
    if (!containsRTL2 || this._characterMapping.length === 0) {
      this._pixelOffsetCache = new Int32Array(Math.max(2, this._characterMapping.length + 1));
      for (let column = 0, len = this._characterMapping.length; column <= len; column++) {
        this._pixelOffsetCache[column] = -1;
      }
    }
  }
  _getReadingTarget(myDomNode) {
    return myDomNode.domNode.firstChild;
  }
  getWidth() {
    if (!this.domNode) {
      return 0;
    }
    if (this._cachedWidth === -1) {
      this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;
    }
    return this._cachedWidth;
  }
  getWidthIsFast() {
    if (this._cachedWidth === -1) {
      return false;
    }
    return true;
  }
  getVisibleRangesForRange(startColumn, endColumn, context) {
    if (!this.domNode) {
      return null;
    }
    if (this._pixelOffsetCache !== null) {
      const startOffset = this._readPixelOffset(this.domNode, startColumn, context);
      if (startOffset === -1) {
        return null;
      }
      const endOffset = this._readPixelOffset(this.domNode, endColumn, context);
      if (endOffset === -1) {
        return null;
      }
      return [new HorizontalRange(startOffset, endOffset - startOffset)];
    }
    return this._readVisibleRangesForRange(this.domNode, startColumn, endColumn, context);
  }
  _readVisibleRangesForRange(domNode, startColumn, endColumn, context) {
    if (startColumn === endColumn) {
      const pixelOffset = this._readPixelOffset(domNode, startColumn, context);
      if (pixelOffset === -1) {
        return null;
      } else {
        return [new HorizontalRange(pixelOffset, 0)];
      }
    } else {
      return this._readRawVisibleRangesForRange(domNode, startColumn, endColumn, context);
    }
  }
  _readPixelOffset(domNode, column, context) {
    if (this._characterMapping.length === 0) {
      if (this._containsForeignElements === 0) {
        return 0;
      }
      if (this._containsForeignElements === 2) {
        return 0;
      }
      if (this._containsForeignElements === 1) {
        return this.getWidth();
      }
      const readingTarget = this._getReadingTarget(domNode);
      if (readingTarget.firstChild) {
        return readingTarget.firstChild.offsetWidth;
      } else {
        return 0;
      }
    }
    if (this._pixelOffsetCache !== null) {
      const cachedPixelOffset = this._pixelOffsetCache[column];
      if (cachedPixelOffset !== -1) {
        return cachedPixelOffset;
      }
      const result = this._actualReadPixelOffset(domNode, column, context);
      this._pixelOffsetCache[column] = result;
      return result;
    }
    return this._actualReadPixelOffset(domNode, column, context);
  }
  _actualReadPixelOffset(domNode, column, context) {
    if (this._characterMapping.length === 0) {
      const r2 = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), 0, 0, 0, 0, context.clientRectDeltaLeft, context.endNode);
      if (!r2 || r2.length === 0) {
        return -1;
      }
      return r2[0].left;
    }
    if (column === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0) {
      return this.getWidth();
    }
    const partData = this._characterMapping.charOffsetToPartData(column - 1);
    const partIndex = CharacterMapping.getPartIndex(partData);
    const charOffsetInPart = CharacterMapping.getCharIndex(partData);
    const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), partIndex, charOffsetInPart, partIndex, charOffsetInPart, context.clientRectDeltaLeft, context.endNode);
    if (!r || r.length === 0) {
      return -1;
    }
    const result = r[0].left;
    if (this.input.isBasicASCII) {
      const charOffset = this._characterMapping.getAbsoluteOffsets();
      const expectedResult = Math.round(this.input.spaceWidth * charOffset[column - 1]);
      if (Math.abs(expectedResult - result) <= 1) {
        return expectedResult;
      }
    }
    return result;
  }
  _readRawVisibleRangesForRange(domNode, startColumn, endColumn, context) {
    if (startColumn === 1 && endColumn === this._characterMapping.length) {
      return [new HorizontalRange(0, this.getWidth())];
    }
    const startPartData = this._characterMapping.charOffsetToPartData(startColumn - 1);
    const startPartIndex = CharacterMapping.getPartIndex(startPartData);
    const startCharOffsetInPart = CharacterMapping.getCharIndex(startPartData);
    const endPartData = this._characterMapping.charOffsetToPartData(endColumn - 1);
    const endPartIndex = CharacterMapping.getPartIndex(endPartData);
    const endCharOffsetInPart = CharacterMapping.getCharIndex(endPartData);
    return RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), startPartIndex, startCharOffsetInPart, endPartIndex, endCharOffsetInPart, context.clientRectDeltaLeft, context.endNode);
  }
  getColumnOfNodeOffset(lineNumber, spanNode, offset) {
    const spanNodeTextContentLength = spanNode.textContent.length;
    let spanIndex = -1;
    while (spanNode) {
      spanNode = spanNode.previousSibling;
      spanIndex++;
    }
    const charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);
    return charOffset + 1;
  }
};
var WebKitRenderedViewLine = class extends RenderedViewLine {
  _readVisibleRangesForRange(domNode, startColumn, endColumn, context) {
    const output = super._readVisibleRangesForRange(domNode, startColumn, endColumn, context);
    if (!output || output.length === 0 || startColumn === endColumn || startColumn === 1 && endColumn === this._characterMapping.length) {
      return output;
    }
    if (!this.input.containsRTL) {
      const endPixelOffset = this._readPixelOffset(domNode, endColumn, context);
      if (endPixelOffset !== -1) {
        const lastRange = output[output.length - 1];
        if (lastRange.left < endPixelOffset) {
          lastRange.width = endPixelOffset - lastRange.left;
        }
      }
    }
    return output;
  }
};
var createRenderedLine = function() {
  if (isWebKit) {
    return createWebKitRenderedLine;
  }
  return createNormalRenderedLine;
}();
function createWebKitRenderedLine(domNode, renderLineInput, characterMapping, containsRTL2, containsForeignElements) {
  return new WebKitRenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL2, containsForeignElements);
}
function createNormalRenderedLine(domNode, renderLineInput, characterMapping, containsRTL2, containsForeignElements) {
  return new RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL2, containsForeignElements);
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/textChange.js
var TextChange = class {
  constructor(oldPosition, oldText, newPosition, newText) {
    this.oldPosition = oldPosition;
    this.oldText = oldText;
    this.newPosition = newPosition;
    this.newText = newText;
  }
  get oldLength() {
    return this.oldText.length;
  }
  get oldEnd() {
    return this.oldPosition + this.oldText.length;
  }
  get newLength() {
    return this.newText.length;
  }
  get newEnd() {
    return this.newPosition + this.newText.length;
  }
  toString() {
    if (this.oldText.length === 0) {
      return `(insert@${this.oldPosition} "${this.newText}")`;
    }
    if (this.newText.length === 0) {
      return `(delete@${this.oldPosition} "${this.oldText}")`;
    }
    return `(replace@${this.oldPosition} "${this.oldText}" with "${this.newText}")`;
  }
  static _writeStringSize(str) {
    return 4 + 2 * str.length;
  }
  static _writeString(b, str, offset) {
    const len = str.length;
    writeUInt32BE(b, len, offset);
    offset += 4;
    for (let i = 0; i < len; i++) {
      writeUInt16LE(b, str.charCodeAt(i), offset);
      offset += 2;
    }
    return offset;
  }
  static _readString(b, offset) {
    const len = readUInt32BE(b, offset);
    offset += 4;
    return decodeUTF16LE(b, offset, len);
  }
  writeSize() {
    return 4 + 4 + TextChange._writeStringSize(this.oldText) + TextChange._writeStringSize(this.newText);
  }
  write(b, offset) {
    writeUInt32BE(b, this.oldPosition, offset);
    offset += 4;
    writeUInt32BE(b, this.newPosition, offset);
    offset += 4;
    offset = TextChange._writeString(b, this.oldText, offset);
    offset = TextChange._writeString(b, this.newText, offset);
    return offset;
  }
  static read(b, offset, dest) {
    const oldPosition = readUInt32BE(b, offset);
    offset += 4;
    const newPosition = readUInt32BE(b, offset);
    offset += 4;
    const oldText = TextChange._readString(b, offset);
    offset += TextChange._writeStringSize(oldText);
    const newText = TextChange._readString(b, offset);
    offset += TextChange._writeStringSize(newText);
    dest.push(new TextChange(oldPosition, oldText, newPosition, newText));
    return offset;
  }
};
function compressConsecutiveTextChanges(prevEdits, currEdits) {
  if (prevEdits === null || prevEdits.length === 0) {
    return currEdits;
  }
  const compressor = new TextChangeCompressor(prevEdits, currEdits);
  return compressor.compress();
}
var TextChangeCompressor = class {
  constructor(prevEdits, currEdits) {
    this._prevEdits = prevEdits;
    this._currEdits = currEdits;
    this._result = [];
    this._resultLen = 0;
    this._prevLen = this._prevEdits.length;
    this._prevDeltaOffset = 0;
    this._currLen = this._currEdits.length;
    this._currDeltaOffset = 0;
  }
  compress() {
    let prevIndex = 0;
    let currIndex = 0;
    let prevEdit = this._getPrev(prevIndex);
    let currEdit = this._getCurr(currIndex);
    while (prevIndex < this._prevLen || currIndex < this._currLen) {
      if (prevEdit === null) {
        this._acceptCurr(currEdit);
        currEdit = this._getCurr(++currIndex);
        continue;
      }
      if (currEdit === null) {
        this._acceptPrev(prevEdit);
        prevEdit = this._getPrev(++prevIndex);
        continue;
      }
      if (currEdit.oldEnd <= prevEdit.newPosition) {
        this._acceptCurr(currEdit);
        currEdit = this._getCurr(++currIndex);
        continue;
      }
      if (prevEdit.newEnd <= currEdit.oldPosition) {
        this._acceptPrev(prevEdit);
        prevEdit = this._getPrev(++prevIndex);
        continue;
      }
      if (currEdit.oldPosition < prevEdit.newPosition) {
        const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);
        this._acceptCurr(e1);
        currEdit = e2;
        continue;
      }
      if (prevEdit.newPosition < currEdit.oldPosition) {
        const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);
        this._acceptPrev(e1);
        prevEdit = e2;
        continue;
      }
      let mergePrev;
      let mergeCurr;
      if (currEdit.oldEnd === prevEdit.newEnd) {
        mergePrev = prevEdit;
        mergeCurr = currEdit;
        prevEdit = this._getPrev(++prevIndex);
        currEdit = this._getCurr(++currIndex);
      } else if (currEdit.oldEnd < prevEdit.newEnd) {
        const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);
        mergePrev = e1;
        mergeCurr = currEdit;
        prevEdit = e2;
        currEdit = this._getCurr(++currIndex);
      } else {
        const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);
        mergePrev = prevEdit;
        mergeCurr = e1;
        prevEdit = this._getPrev(++prevIndex);
        currEdit = e2;
      }
      this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);
      this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;
      this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;
    }
    const merged = TextChangeCompressor._merge(this._result);
    const cleaned = TextChangeCompressor._removeNoOps(merged);
    return cleaned;
  }
  _acceptCurr(currEdit) {
    this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);
    this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;
  }
  _getCurr(currIndex) {
    return currIndex < this._currLen ? this._currEdits[currIndex] : null;
  }
  _acceptPrev(prevEdit) {
    this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);
    this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;
  }
  _getPrev(prevIndex) {
    return prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null;
  }
  static _rebaseCurr(prevDeltaOffset, currEdit) {
    return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);
  }
  static _rebasePrev(currDeltaOffset, prevEdit) {
    return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);
  }
  static _splitPrev(edit, offset) {
    const preText = edit.newText.substr(0, offset);
    const postText = edit.newText.substr(offset);
    return [
      new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),
      new TextChange(edit.oldEnd, "", edit.newPosition + offset, postText)
    ];
  }
  static _splitCurr(edit, offset) {
    const preText = edit.oldText.substr(0, offset);
    const postText = edit.oldText.substr(offset);
    return [
      new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),
      new TextChange(edit.oldPosition + offset, postText, edit.newEnd, "")
    ];
  }
  static _merge(edits) {
    if (edits.length === 0) {
      return edits;
    }
    let result = [], resultLen = 0;
    let prev = edits[0];
    for (let i = 1; i < edits.length; i++) {
      const curr = edits[i];
      if (prev.oldEnd === curr.oldPosition) {
        prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);
      } else {
        result[resultLen++] = prev;
        prev = curr;
      }
    }
    result[resultLen++] = prev;
    return result;
  }
  static _removeNoOps(edits) {
    if (edits.length === 0) {
      return edits;
    }
    let result = [], resultLen = 0;
    for (let i = 0; i < edits.length; i++) {
      const edit = edits[i];
      if (edit.oldText === edit.newText) {
        continue;
      }
      result[resultLen++] = edit;
    }
    return result;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js
function uriGetComparisonKey(resource) {
  return resource.toString();
}
var SingleModelEditStackData = class {
  constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {
    this.beforeVersionId = beforeVersionId;
    this.afterVersionId = afterVersionId;
    this.beforeEOL = beforeEOL;
    this.afterEOL = afterEOL;
    this.beforeCursorState = beforeCursorState;
    this.afterCursorState = afterCursorState;
    this.changes = changes;
  }
  static create(model2, beforeCursorState) {
    const alternativeVersionId = model2.getAlternativeVersionId();
    const eol = getModelEOL(model2);
    return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);
  }
  append(model2, textChanges, afterEOL, afterVersionId, afterCursorState) {
    if (textChanges.length > 0) {
      this.changes = compressConsecutiveTextChanges(this.changes, textChanges);
    }
    this.afterEOL = afterEOL;
    this.afterVersionId = afterVersionId;
    this.afterCursorState = afterCursorState;
  }
  static _writeSelectionsSize(selections) {
    return 4 + 4 * 4 * (selections ? selections.length : 0);
  }
  static _writeSelections(b, selections, offset) {
    writeUInt32BE(b, selections ? selections.length : 0, offset);
    offset += 4;
    if (selections) {
      for (const selection of selections) {
        writeUInt32BE(b, selection.selectionStartLineNumber, offset);
        offset += 4;
        writeUInt32BE(b, selection.selectionStartColumn, offset);
        offset += 4;
        writeUInt32BE(b, selection.positionLineNumber, offset);
        offset += 4;
        writeUInt32BE(b, selection.positionColumn, offset);
        offset += 4;
      }
    }
    return offset;
  }
  static _readSelections(b, offset, dest) {
    const count = readUInt32BE(b, offset);
    offset += 4;
    for (let i = 0; i < count; i++) {
      const selectionStartLineNumber = readUInt32BE(b, offset);
      offset += 4;
      const selectionStartColumn = readUInt32BE(b, offset);
      offset += 4;
      const positionLineNumber = readUInt32BE(b, offset);
      offset += 4;
      const positionColumn = readUInt32BE(b, offset);
      offset += 4;
      dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));
    }
    return offset;
  }
  serialize() {
    let necessarySize = 4 + 4 + 1 + 1 + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState) + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState) + 4;
    for (const change of this.changes) {
      necessarySize += change.writeSize();
    }
    const b = new Uint8Array(necessarySize);
    let offset = 0;
    writeUInt32BE(b, this.beforeVersionId, offset);
    offset += 4;
    writeUInt32BE(b, this.afterVersionId, offset);
    offset += 4;
    writeUInt8(b, this.beforeEOL, offset);
    offset += 1;
    writeUInt8(b, this.afterEOL, offset);
    offset += 1;
    offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);
    offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);
    writeUInt32BE(b, this.changes.length, offset);
    offset += 4;
    for (const change of this.changes) {
      offset = change.write(b, offset);
    }
    return b.buffer;
  }
  static deserialize(source) {
    const b = new Uint8Array(source);
    let offset = 0;
    const beforeVersionId = readUInt32BE(b, offset);
    offset += 4;
    const afterVersionId = readUInt32BE(b, offset);
    offset += 4;
    const beforeEOL = readUInt8(b, offset);
    offset += 1;
    const afterEOL = readUInt8(b, offset);
    offset += 1;
    const beforeCursorState = [];
    offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);
    const afterCursorState = [];
    offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);
    const changeCount = readUInt32BE(b, offset);
    offset += 4;
    const changes = [];
    for (let i = 0; i < changeCount; i++) {
      offset = TextChange.read(b, offset, changes);
    }
    return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);
  }
};
var SingleModelEditStackElement = class {
  constructor(model2, beforeCursorState) {
    this.model = model2;
    this._data = SingleModelEditStackData.create(model2, beforeCursorState);
  }
  get type() {
    return 0;
  }
  get resource() {
    if (URI.isUri(this.model)) {
      return this.model;
    }
    return this.model.uri;
  }
  get label() {
    return localize("edit", "Typing");
  }
  toString() {
    const data = this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data);
    return data.changes.map((change) => change.toString()).join(", ");
  }
  matchesResource(resource) {
    const uri = URI.isUri(this.model) ? this.model : this.model.uri;
    return uri.toString() === resource.toString();
  }
  setModel(model2) {
    this.model = model2;
  }
  canAppend(model2) {
    return this.model === model2 && this._data instanceof SingleModelEditStackData;
  }
  append(model2, textChanges, afterEOL, afterVersionId, afterCursorState) {
    if (this._data instanceof SingleModelEditStackData) {
      this._data.append(model2, textChanges, afterEOL, afterVersionId, afterCursorState);
    }
  }
  close() {
    if (this._data instanceof SingleModelEditStackData) {
      this._data = this._data.serialize();
    }
  }
  undo() {
    if (URI.isUri(this.model)) {
      throw new Error(`Invalid SingleModelEditStackElement`);
    }
    if (this._data instanceof SingleModelEditStackData) {
      this._data = this._data.serialize();
    }
    const data = SingleModelEditStackData.deserialize(this._data);
    this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);
  }
  redo() {
    if (URI.isUri(this.model)) {
      throw new Error(`Invalid SingleModelEditStackElement`);
    }
    if (this._data instanceof SingleModelEditStackData) {
      this._data = this._data.serialize();
    }
    const data = SingleModelEditStackData.deserialize(this._data);
    this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);
  }
};
var MultiModelEditStackElement = class {
  constructor(label, editStackElements) {
    this.type = 1;
    this.label = label;
    this._isOpen = true;
    this._editStackElementsArr = editStackElements.slice(0);
    this._editStackElementsMap = new Map();
    for (const editStackElement of this._editStackElementsArr) {
      const key = uriGetComparisonKey(editStackElement.resource);
      this._editStackElementsMap.set(key, editStackElement);
    }
    this._delegate = null;
  }
  get resources() {
    return this._editStackElementsArr.map((editStackElement) => editStackElement.resource);
  }
  prepareUndoRedo() {
    if (this._delegate) {
      return this._delegate.prepareUndoRedo(this);
    }
  }
  matchesResource(resource) {
    const key = uriGetComparisonKey(resource);
    return this._editStackElementsMap.has(key);
  }
  setModel(model2) {
    const key = uriGetComparisonKey(URI.isUri(model2) ? model2 : model2.uri);
    if (this._editStackElementsMap.has(key)) {
      this._editStackElementsMap.get(key).setModel(model2);
    }
  }
  canAppend(model2) {
    if (!this._isOpen) {
      return false;
    }
    const key = uriGetComparisonKey(model2.uri);
    if (this._editStackElementsMap.has(key)) {
      const editStackElement = this._editStackElementsMap.get(key);
      return editStackElement.canAppend(model2);
    }
    return false;
  }
  append(model2, textChanges, afterEOL, afterVersionId, afterCursorState) {
    const key = uriGetComparisonKey(model2.uri);
    const editStackElement = this._editStackElementsMap.get(key);
    editStackElement.append(model2, textChanges, afterEOL, afterVersionId, afterCursorState);
  }
  close() {
    this._isOpen = false;
  }
  undo() {
    this._isOpen = false;
    for (const editStackElement of this._editStackElementsArr) {
      editStackElement.undo();
    }
  }
  redo() {
    for (const editStackElement of this._editStackElementsArr) {
      editStackElement.redo();
    }
  }
  split() {
    return this._editStackElementsArr;
  }
};
function getModelEOL(model2) {
  const eol = model2.getEOL();
  if (eol === "\n") {
    return 0;
  } else {
    return 1;
  }
}
function isEditStackElement(element) {
  if (!element) {
    return false;
  }
  return element instanceof SingleModelEditStackElement || element instanceof MultiModelEditStackElement;
}
var EditStack = class {
  constructor(model2, undoRedoService) {
    this._model = model2;
    this._undoRedoService = undoRedoService;
  }
  pushStackElement() {
    const lastElement = this._undoRedoService.getLastElement(this._model.uri);
    if (isEditStackElement(lastElement)) {
      lastElement.close();
    }
  }
  clear() {
    this._undoRedoService.removeElements(this._model.uri);
  }
  _getOrCreateEditStackElement(beforeCursorState) {
    const lastElement = this._undoRedoService.getLastElement(this._model.uri);
    if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {
      return lastElement;
    }
    const newElement = new SingleModelEditStackElement(this._model, beforeCursorState);
    this._undoRedoService.pushElement(newElement);
    return newElement;
  }
  pushEOL(eol) {
    const editStackElement = this._getOrCreateEditStackElement(null);
    this._model.setEOL(eol);
    editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);
  }
  pushEditOperation(beforeCursorState, editOperations, cursorStateComputer) {
    const editStackElement = this._getOrCreateEditStackElement(beforeCursorState);
    const inverseEditOperations = this._model.applyEdits(editOperations, true);
    const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);
    const textChanges = inverseEditOperations.map((op, index) => ({index, textChange: op.textChange}));
    textChanges.sort((a, b) => {
      if (a.textChange.oldPosition === b.textChange.oldPosition) {
        return a.index - b.index;
      }
      return a.textChange.oldPosition - b.textChange.oldPosition;
    });
    editStackElement.append(this._model, textChanges.map((op) => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);
    return afterCursorState;
  }
  static _computeCursorState(cursorStateComputer, inverseEditOperations) {
    try {
      return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;
    } catch (e) {
      onUnexpectedError(e);
      return null;
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js
var SpacesDiffResult = class {
  constructor() {
    this.spacesDiff = 0;
    this.looksLikeAlignment = false;
  }
};
function spacesDiff(a, aLength, b, bLength, result) {
  result.spacesDiff = 0;
  result.looksLikeAlignment = false;
  let i;
  for (i = 0; i < aLength && i < bLength; i++) {
    let aCharCode = a.charCodeAt(i);
    let bCharCode = b.charCodeAt(i);
    if (aCharCode !== bCharCode) {
      break;
    }
  }
  let aSpacesCnt = 0, aTabsCount = 0;
  for (let j = i; j < aLength; j++) {
    let aCharCode = a.charCodeAt(j);
    if (aCharCode === 32) {
      aSpacesCnt++;
    } else {
      aTabsCount++;
    }
  }
  let bSpacesCnt = 0, bTabsCount = 0;
  for (let j = i; j < bLength; j++) {
    let bCharCode = b.charCodeAt(j);
    if (bCharCode === 32) {
      bSpacesCnt++;
    } else {
      bTabsCount++;
    }
  }
  if (aSpacesCnt > 0 && aTabsCount > 0) {
    return;
  }
  if (bSpacesCnt > 0 && bTabsCount > 0) {
    return;
  }
  let tabsDiff = Math.abs(aTabsCount - bTabsCount);
  let spacesDiff2 = Math.abs(aSpacesCnt - bSpacesCnt);
  if (tabsDiff === 0) {
    result.spacesDiff = spacesDiff2;
    if (spacesDiff2 > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {
      if (b.charCodeAt(bSpacesCnt) !== 32 && a.charCodeAt(bSpacesCnt - 1) === 32) {
        if (a.charCodeAt(a.length - 1) === 44) {
          result.looksLikeAlignment = true;
        }
      }
    }
    return;
  }
  if (spacesDiff2 % tabsDiff === 0) {
    result.spacesDiff = spacesDiff2 / tabsDiff;
    return;
  }
}
function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {
  const linesCount = Math.min(source.getLineCount(), 1e4);
  let linesIndentedWithTabsCount = 0;
  let linesIndentedWithSpacesCount = 0;
  let previousLineText = "";
  let previousLineIndentation = 0;
  const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7];
  const MAX_ALLOWED_TAB_SIZE_GUESS = 8;
  let spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  let tmp = new SpacesDiffResult();
  for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {
    let currentLineLength = source.getLineLength(lineNumber);
    let currentLineText = source.getLineContent(lineNumber);
    const useCurrentLineText = currentLineLength <= 65536;
    let currentLineHasContent = false;
    let currentLineIndentation = 0;
    let currentLineSpacesCount = 0;
    let currentLineTabsCount = 0;
    for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {
      let charCode = useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j);
      if (charCode === 9) {
        currentLineTabsCount++;
      } else if (charCode === 32) {
        currentLineSpacesCount++;
      } else {
        currentLineHasContent = true;
        currentLineIndentation = j;
        break;
      }
    }
    if (!currentLineHasContent) {
      continue;
    }
    if (currentLineTabsCount > 0) {
      linesIndentedWithTabsCount++;
    } else if (currentLineSpacesCount > 1) {
      linesIndentedWithSpacesCount++;
    }
    spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);
    if (tmp.looksLikeAlignment) {
      if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {
        continue;
      }
    }
    let currentSpacesDiff = tmp.spacesDiff;
    if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {
      spacesDiffCount[currentSpacesDiff]++;
    }
    previousLineText = currentLineText;
    previousLineIndentation = currentLineIndentation;
  }
  let insertSpaces = defaultInsertSpaces;
  if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {
    insertSpaces = linesIndentedWithTabsCount < linesIndentedWithSpacesCount;
  }
  let tabSize = defaultTabSize;
  if (insertSpaces) {
    let tabSizeScore = insertSpaces ? 0 : 0.1 * linesCount;
    ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {
      let possibleTabSizeScore = spacesDiffCount[possibleTabSize];
      if (possibleTabSizeScore > tabSizeScore) {
        tabSizeScore = possibleTabSizeScore;
        tabSize = possibleTabSize;
      }
    });
    if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {
      tabSize = 2;
    }
  }
  return {
    insertSpaces,
    tabSize
  };
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js
function getNodeColor(node) {
  return (node.metadata & 1) >>> 0;
}
function setNodeColor(node, color) {
  node.metadata = node.metadata & 254 | color << 0;
}
function getNodeIsVisited(node) {
  return (node.metadata & 2) >>> 1 === 1;
}
function setNodeIsVisited(node, value) {
  node.metadata = node.metadata & 253 | (value ? 1 : 0) << 1;
}
function getNodeIsForValidation(node) {
  return (node.metadata & 4) >>> 2 === 1;
}
function setNodeIsForValidation(node, value) {
  node.metadata = node.metadata & 251 | (value ? 1 : 0) << 2;
}
function getNodeIsInOverviewRuler(node) {
  return (node.metadata & 8) >>> 3 === 1;
}
function setNodeIsInOverviewRuler(node, value) {
  node.metadata = node.metadata & 247 | (value ? 1 : 0) << 3;
}
function getNodeStickiness(node) {
  return (node.metadata & 48) >>> 4;
}
function _setNodeStickiness(node, stickiness) {
  node.metadata = node.metadata & 207 | stickiness << 4;
}
function getCollapseOnReplaceEdit(node) {
  return (node.metadata & 64) >>> 6 === 1;
}
function setCollapseOnReplaceEdit(node, value) {
  node.metadata = node.metadata & 191 | (value ? 1 : 0) << 6;
}
var IntervalNode = class {
  constructor(id, start, end) {
    this.metadata = 0;
    this.parent = this;
    this.left = this;
    this.right = this;
    setNodeColor(this, 1);
    this.start = start;
    this.end = end;
    this.delta = 0;
    this.maxEnd = end;
    this.id = id;
    this.ownerId = 0;
    this.options = null;
    setNodeIsForValidation(this, false);
    _setNodeStickiness(this, 1);
    setNodeIsInOverviewRuler(this, false);
    setCollapseOnReplaceEdit(this, false);
    this.cachedVersionId = 0;
    this.cachedAbsoluteStart = start;
    this.cachedAbsoluteEnd = end;
    this.range = null;
    setNodeIsVisited(this, false);
  }
  reset(versionId, start, end, range2) {
    this.start = start;
    this.end = end;
    this.maxEnd = end;
    this.cachedVersionId = versionId;
    this.cachedAbsoluteStart = start;
    this.cachedAbsoluteEnd = end;
    this.range = range2;
  }
  setOptions(options) {
    this.options = options;
    let className = this.options.className;
    setNodeIsForValidation(this, className === "squiggly-error" || className === "squiggly-warning" || className === "squiggly-info");
    _setNodeStickiness(this, this.options.stickiness);
    setNodeIsInOverviewRuler(this, this.options.overviewRuler && this.options.overviewRuler.color ? true : false);
    setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);
  }
  setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {
    if (this.cachedVersionId !== cachedVersionId) {
      this.range = null;
    }
    this.cachedVersionId = cachedVersionId;
    this.cachedAbsoluteStart = absoluteStart;
    this.cachedAbsoluteEnd = absoluteEnd;
  }
  detach() {
    this.parent = null;
    this.left = null;
    this.right = null;
  }
};
var SENTINEL = new IntervalNode(null, 0, 0);
SENTINEL.parent = SENTINEL;
SENTINEL.left = SENTINEL;
SENTINEL.right = SENTINEL;
setNodeColor(SENTINEL, 0);
var IntervalTree = class {
  constructor() {
    this.root = SENTINEL;
    this.requestNormalizeDelta = false;
  }
  intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {
    if (this.root === SENTINEL) {
      return [];
    }
    return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);
  }
  search(filterOwnerId, filterOutValidation, cachedVersionId) {
    if (this.root === SENTINEL) {
      return [];
    }
    return search(this, filterOwnerId, filterOutValidation, cachedVersionId);
  }
  collectNodesFromOwner(ownerId) {
    return collectNodesFromOwner(this, ownerId);
  }
  collectNodesPostOrder() {
    return collectNodesPostOrder(this);
  }
  insert(node) {
    rbTreeInsert(this, node);
    this._normalizeDeltaIfNecessary();
  }
  delete(node) {
    rbTreeDelete(this, node);
    this._normalizeDeltaIfNecessary();
  }
  resolveNode(node, cachedVersionId) {
    const initialNode = node;
    let delta = 0;
    while (node !== this.root) {
      if (node === node.parent.right) {
        delta += node.parent.delta;
      }
      node = node.parent;
    }
    const nodeStart = initialNode.start + delta;
    const nodeEnd = initialNode.end + delta;
    initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
  }
  acceptReplace(offset, length, textLength, forceMoveMarkers) {
    const nodesOfInterest = searchForEditing(this, offset, offset + length);
    for (let i = 0, len = nodesOfInterest.length; i < len; i++) {
      const node = nodesOfInterest[i];
      rbTreeDelete(this, node);
    }
    this._normalizeDeltaIfNecessary();
    noOverlapReplace(this, offset, offset + length, textLength);
    this._normalizeDeltaIfNecessary();
    for (let i = 0, len = nodesOfInterest.length; i < len; i++) {
      const node = nodesOfInterest[i];
      node.start = node.cachedAbsoluteStart;
      node.end = node.cachedAbsoluteEnd;
      nodeAcceptEdit(node, offset, offset + length, textLength, forceMoveMarkers);
      node.maxEnd = node.end;
      rbTreeInsert(this, node);
    }
    this._normalizeDeltaIfNecessary();
  }
  _normalizeDeltaIfNecessary() {
    if (!this.requestNormalizeDelta) {
      return;
    }
    this.requestNormalizeDelta = false;
    normalizeDelta(this);
  }
};
function normalizeDelta(T) {
  let node = T.root;
  let delta = 0;
  while (node !== SENTINEL) {
    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
      node = node.left;
      continue;
    }
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
    node.start = delta + node.start;
    node.end = delta + node.end;
    node.delta = 0;
    recomputeMaxEnd(node);
    setNodeIsVisited(node, true);
    setNodeIsVisited(node.left, false);
    setNodeIsVisited(node.right, false);
    if (node === node.parent.right) {
      delta -= node.parent.delta;
    }
    node = node.parent;
  }
  setNodeIsVisited(T.root, false);
}
function adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {
  if (markerOffset < checkOffset) {
    return true;
  }
  if (markerOffset > checkOffset) {
    return false;
  }
  if (moveSemantics === 1) {
    return false;
  }
  if (moveSemantics === 2) {
    return true;
  }
  return markerStickToPreviousCharacter;
}
function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {
  const nodeStickiness = getNodeStickiness(node);
  const startStickToPreviousCharacter = nodeStickiness === 0 || nodeStickiness === 2;
  const endStickToPreviousCharacter = nodeStickiness === 1 || nodeStickiness === 2;
  const deletingCnt = end - start;
  const insertingCnt = textLength;
  const commonLength = Math.min(deletingCnt, insertingCnt);
  const nodeStart = node.start;
  let startDone = false;
  const nodeEnd = node.end;
  let endDone = false;
  if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {
    node.start = start;
    startDone = true;
    node.end = start;
    endDone = true;
  }
  {
    const moveSemantics = forceMoveMarkers ? 1 : deletingCnt > 0 ? 2 : 0;
    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {
      startDone = true;
    }
    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {
      endDone = true;
    }
  }
  if (commonLength > 0 && !forceMoveMarkers) {
    const moveSemantics = deletingCnt > insertingCnt ? 2 : 0;
    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {
      startDone = true;
    }
    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {
      endDone = true;
    }
  }
  {
    const moveSemantics = forceMoveMarkers ? 1 : 0;
    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {
      node.start = start + insertingCnt;
      startDone = true;
    }
    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {
      node.end = start + insertingCnt;
      endDone = true;
    }
  }
  const deltaColumn = insertingCnt - deletingCnt;
  if (!startDone) {
    node.start = Math.max(0, nodeStart + deltaColumn);
  }
  if (!endDone) {
    node.end = Math.max(0, nodeEnd + deltaColumn);
  }
  if (node.start > node.end) {
    node.end = node.start;
  }
}
function searchForEditing(T, start, end) {
  let node = T.root;
  let delta = 0;
  let nodeMaxEnd = 0;
  let nodeStart = 0;
  let nodeEnd = 0;
  let result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      if (node === node.parent.right) {
        delta -= node.parent.delta;
      }
      node = node.parent;
      continue;
    }
    if (!getNodeIsVisited(node.left)) {
      nodeMaxEnd = delta + node.maxEnd;
      if (nodeMaxEnd < start) {
        setNodeIsVisited(node, true);
        continue;
      }
      if (node.left !== SENTINEL) {
        node = node.left;
        continue;
      }
    }
    nodeStart = delta + node.start;
    if (nodeStart > end) {
      setNodeIsVisited(node, true);
      continue;
    }
    nodeEnd = delta + node.end;
    if (nodeEnd >= start) {
      node.setCachedOffsets(nodeStart, nodeEnd, 0);
      result[resultLen++] = node;
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function noOverlapReplace(T, start, end, textLength) {
  let node = T.root;
  let delta = 0;
  let nodeMaxEnd = 0;
  let nodeStart = 0;
  const editDelta = textLength - (end - start);
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      if (node === node.parent.right) {
        delta -= node.parent.delta;
      }
      recomputeMaxEnd(node);
      node = node.parent;
      continue;
    }
    if (!getNodeIsVisited(node.left)) {
      nodeMaxEnd = delta + node.maxEnd;
      if (nodeMaxEnd < start) {
        setNodeIsVisited(node, true);
        continue;
      }
      if (node.left !== SENTINEL) {
        node = node.left;
        continue;
      }
    }
    nodeStart = delta + node.start;
    if (nodeStart > end) {
      node.start += editDelta;
      node.end += editDelta;
      node.delta += editDelta;
      if (node.delta < -1073741824 || node.delta > 1073741824) {
        T.requestNormalizeDelta = true;
      }
      setNodeIsVisited(node, true);
      continue;
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
}
function collectNodesFromOwner(T, ownerId) {
  let node = T.root;
  let result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      node = node.parent;
      continue;
    }
    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
      node = node.left;
      continue;
    }
    if (node.ownerId === ownerId) {
      result[resultLen++] = node;
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function collectNodesPostOrder(T) {
  let node = T.root;
  let result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      node = node.parent;
      continue;
    }
    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
      node = node.left;
      continue;
    }
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      node = node.right;
      continue;
    }
    result[resultLen++] = node;
    setNodeIsVisited(node, true);
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function search(T, filterOwnerId, filterOutValidation, cachedVersionId) {
  let node = T.root;
  let delta = 0;
  let nodeStart = 0;
  let nodeEnd = 0;
  let result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      if (node === node.parent.right) {
        delta -= node.parent.delta;
      }
      node = node.parent;
      continue;
    }
    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
      node = node.left;
      continue;
    }
    nodeStart = delta + node.start;
    nodeEnd = delta + node.end;
    node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
    let include = true;
    if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {
      include = false;
    }
    if (filterOutValidation && getNodeIsForValidation(node)) {
      include = false;
    }
    if (include) {
      result[resultLen++] = node;
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {
  let node = T.root;
  let delta = 0;
  let nodeMaxEnd = 0;
  let nodeStart = 0;
  let nodeEnd = 0;
  let result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      if (node === node.parent.right) {
        delta -= node.parent.delta;
      }
      node = node.parent;
      continue;
    }
    if (!getNodeIsVisited(node.left)) {
      nodeMaxEnd = delta + node.maxEnd;
      if (nodeMaxEnd < intervalStart) {
        setNodeIsVisited(node, true);
        continue;
      }
      if (node.left !== SENTINEL) {
        node = node.left;
        continue;
      }
    }
    nodeStart = delta + node.start;
    if (nodeStart > intervalEnd) {
      setNodeIsVisited(node, true);
      continue;
    }
    nodeEnd = delta + node.end;
    if (nodeEnd >= intervalStart) {
      node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
      let include = true;
      if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {
        include = false;
      }
      if (filterOutValidation && getNodeIsForValidation(node)) {
        include = false;
      }
      if (include) {
        result[resultLen++] = node;
      }
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function rbTreeInsert(T, newNode) {
  if (T.root === SENTINEL) {
    newNode.parent = SENTINEL;
    newNode.left = SENTINEL;
    newNode.right = SENTINEL;
    setNodeColor(newNode, 0);
    T.root = newNode;
    return T.root;
  }
  treeInsert(T, newNode);
  recomputeMaxEndWalkToRoot(newNode.parent);
  let x = newNode;
  while (x !== T.root && getNodeColor(x.parent) === 1) {
    if (x.parent === x.parent.parent.left) {
      const y = x.parent.parent.right;
      if (getNodeColor(y) === 1) {
        setNodeColor(x.parent, 0);
        setNodeColor(y, 0);
        setNodeColor(x.parent.parent, 1);
        x = x.parent.parent;
      } else {
        if (x === x.parent.right) {
          x = x.parent;
          leftRotate2(T, x);
        }
        setNodeColor(x.parent, 0);
        setNodeColor(x.parent.parent, 1);
        rightRotate(T, x.parent.parent);
      }
    } else {
      const y = x.parent.parent.left;
      if (getNodeColor(y) === 1) {
        setNodeColor(x.parent, 0);
        setNodeColor(y, 0);
        setNodeColor(x.parent.parent, 1);
        x = x.parent.parent;
      } else {
        if (x === x.parent.left) {
          x = x.parent;
          rightRotate(T, x);
        }
        setNodeColor(x.parent, 0);
        setNodeColor(x.parent.parent, 1);
        leftRotate2(T, x.parent.parent);
      }
    }
  }
  setNodeColor(T.root, 0);
  return newNode;
}
function treeInsert(T, z) {
  let delta = 0;
  let x = T.root;
  const zAbsoluteStart = z.start;
  const zAbsoluteEnd = z.end;
  while (true) {
    const cmp2 = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);
    if (cmp2 < 0) {
      if (x.left === SENTINEL) {
        z.start -= delta;
        z.end -= delta;
        z.maxEnd -= delta;
        x.left = z;
        break;
      } else {
        x = x.left;
      }
    } else {
      if (x.right === SENTINEL) {
        z.start -= delta + x.delta;
        z.end -= delta + x.delta;
        z.maxEnd -= delta + x.delta;
        x.right = z;
        break;
      } else {
        delta += x.delta;
        x = x.right;
      }
    }
  }
  z.parent = x;
  z.left = SENTINEL;
  z.right = SENTINEL;
  setNodeColor(z, 1);
}
function rbTreeDelete(T, z) {
  let x;
  let y;
  if (z.left === SENTINEL) {
    x = z.right;
    y = z;
    x.delta += z.delta;
    if (x.delta < -1073741824 || x.delta > 1073741824) {
      T.requestNormalizeDelta = true;
    }
    x.start += z.delta;
    x.end += z.delta;
  } else if (z.right === SENTINEL) {
    x = z.left;
    y = z;
  } else {
    y = leftest(z.right);
    x = y.right;
    x.start += y.delta;
    x.end += y.delta;
    x.delta += y.delta;
    if (x.delta < -1073741824 || x.delta > 1073741824) {
      T.requestNormalizeDelta = true;
    }
    y.start += z.delta;
    y.end += z.delta;
    y.delta = z.delta;
    if (y.delta < -1073741824 || y.delta > 1073741824) {
      T.requestNormalizeDelta = true;
    }
  }
  if (y === T.root) {
    T.root = x;
    setNodeColor(x, 0);
    z.detach();
    resetSentinel();
    recomputeMaxEnd(x);
    T.root.parent = SENTINEL;
    return;
  }
  let yWasRed = getNodeColor(y) === 1;
  if (y === y.parent.left) {
    y.parent.left = x;
  } else {
    y.parent.right = x;
  }
  if (y === z) {
    x.parent = y.parent;
  } else {
    if (y.parent === z) {
      x.parent = y;
    } else {
      x.parent = y.parent;
    }
    y.left = z.left;
    y.right = z.right;
    y.parent = z.parent;
    setNodeColor(y, getNodeColor(z));
    if (z === T.root) {
      T.root = y;
    } else {
      if (z === z.parent.left) {
        z.parent.left = y;
      } else {
        z.parent.right = y;
      }
    }
    if (y.left !== SENTINEL) {
      y.left.parent = y;
    }
    if (y.right !== SENTINEL) {
      y.right.parent = y;
    }
  }
  z.detach();
  if (yWasRed) {
    recomputeMaxEndWalkToRoot(x.parent);
    if (y !== z) {
      recomputeMaxEndWalkToRoot(y);
      recomputeMaxEndWalkToRoot(y.parent);
    }
    resetSentinel();
    return;
  }
  recomputeMaxEndWalkToRoot(x);
  recomputeMaxEndWalkToRoot(x.parent);
  if (y !== z) {
    recomputeMaxEndWalkToRoot(y);
    recomputeMaxEndWalkToRoot(y.parent);
  }
  let w;
  while (x !== T.root && getNodeColor(x) === 0) {
    if (x === x.parent.left) {
      w = x.parent.right;
      if (getNodeColor(w) === 1) {
        setNodeColor(w, 0);
        setNodeColor(x.parent, 1);
        leftRotate2(T, x.parent);
        w = x.parent.right;
      }
      if (getNodeColor(w.left) === 0 && getNodeColor(w.right) === 0) {
        setNodeColor(w, 1);
        x = x.parent;
      } else {
        if (getNodeColor(w.right) === 0) {
          setNodeColor(w.left, 0);
          setNodeColor(w, 1);
          rightRotate(T, w);
          w = x.parent.right;
        }
        setNodeColor(w, getNodeColor(x.parent));
        setNodeColor(x.parent, 0);
        setNodeColor(w.right, 0);
        leftRotate2(T, x.parent);
        x = T.root;
      }
    } else {
      w = x.parent.left;
      if (getNodeColor(w) === 1) {
        setNodeColor(w, 0);
        setNodeColor(x.parent, 1);
        rightRotate(T, x.parent);
        w = x.parent.left;
      }
      if (getNodeColor(w.left) === 0 && getNodeColor(w.right) === 0) {
        setNodeColor(w, 1);
        x = x.parent;
      } else {
        if (getNodeColor(w.left) === 0) {
          setNodeColor(w.right, 0);
          setNodeColor(w, 1);
          leftRotate2(T, w);
          w = x.parent.left;
        }
        setNodeColor(w, getNodeColor(x.parent));
        setNodeColor(x.parent, 0);
        setNodeColor(w.left, 0);
        rightRotate(T, x.parent);
        x = T.root;
      }
    }
  }
  setNodeColor(x, 0);
  resetSentinel();
}
function leftest(node) {
  while (node.left !== SENTINEL) {
    node = node.left;
  }
  return node;
}
function resetSentinel() {
  SENTINEL.parent = SENTINEL;
  SENTINEL.delta = 0;
  SENTINEL.start = 0;
  SENTINEL.end = 0;
}
function leftRotate2(T, x) {
  const y = x.right;
  y.delta += x.delta;
  if (y.delta < -1073741824 || y.delta > 1073741824) {
    T.requestNormalizeDelta = true;
  }
  y.start += x.delta;
  y.end += x.delta;
  x.right = y.left;
  if (y.left !== SENTINEL) {
    y.left.parent = x;
  }
  y.parent = x.parent;
  if (x.parent === SENTINEL) {
    T.root = y;
  } else if (x === x.parent.left) {
    x.parent.left = y;
  } else {
    x.parent.right = y;
  }
  y.left = x;
  x.parent = y;
  recomputeMaxEnd(x);
  recomputeMaxEnd(y);
}
function rightRotate(T, y) {
  const x = y.left;
  y.delta -= x.delta;
  if (y.delta < -1073741824 || y.delta > 1073741824) {
    T.requestNormalizeDelta = true;
  }
  y.start -= x.delta;
  y.end -= x.delta;
  y.left = x.right;
  if (x.right !== SENTINEL) {
    x.right.parent = y;
  }
  x.parent = y.parent;
  if (y.parent === SENTINEL) {
    T.root = x;
  } else if (y === y.parent.right) {
    y.parent.right = x;
  } else {
    y.parent.left = x;
  }
  x.right = y;
  y.parent = x;
  recomputeMaxEnd(y);
  recomputeMaxEnd(x);
}
function computeMaxEnd(node) {
  let maxEnd = node.end;
  if (node.left !== SENTINEL) {
    const leftMaxEnd = node.left.maxEnd;
    if (leftMaxEnd > maxEnd) {
      maxEnd = leftMaxEnd;
    }
  }
  if (node.right !== SENTINEL) {
    const rightMaxEnd = node.right.maxEnd + node.delta;
    if (rightMaxEnd > maxEnd) {
      maxEnd = rightMaxEnd;
    }
  }
  return maxEnd;
}
function recomputeMaxEnd(node) {
  node.maxEnd = computeMaxEnd(node);
}
function recomputeMaxEndWalkToRoot(node) {
  while (node !== SENTINEL) {
    const maxEnd = computeMaxEnd(node);
    if (node.maxEnd === maxEnd) {
      return;
    }
    node.maxEnd = maxEnd;
    node = node.parent;
  }
}
function intervalCompare(aStart, aEnd, bStart, bEnd) {
  if (aStart === bStart) {
    return aEnd - bEnd;
  }
  return aStart - bStart;
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js
var TreeNode = class {
  constructor(piece, color) {
    this.piece = piece;
    this.color = color;
    this.size_left = 0;
    this.lf_left = 0;
    this.parent = this;
    this.left = this;
    this.right = this;
  }
  next() {
    if (this.right !== SENTINEL2) {
      return leftest2(this.right);
    }
    let node = this;
    while (node.parent !== SENTINEL2) {
      if (node.parent.left === node) {
        break;
      }
      node = node.parent;
    }
    if (node.parent === SENTINEL2) {
      return SENTINEL2;
    } else {
      return node.parent;
    }
  }
  prev() {
    if (this.left !== SENTINEL2) {
      return righttest(this.left);
    }
    let node = this;
    while (node.parent !== SENTINEL2) {
      if (node.parent.right === node) {
        break;
      }
      node = node.parent;
    }
    if (node.parent === SENTINEL2) {
      return SENTINEL2;
    } else {
      return node.parent;
    }
  }
  detach() {
    this.parent = null;
    this.left = null;
    this.right = null;
  }
};
var SENTINEL2 = new TreeNode(null, 0);
SENTINEL2.parent = SENTINEL2;
SENTINEL2.left = SENTINEL2;
SENTINEL2.right = SENTINEL2;
SENTINEL2.color = 0;
function leftest2(node) {
  while (node.left !== SENTINEL2) {
    node = node.left;
  }
  return node;
}
function righttest(node) {
  while (node.right !== SENTINEL2) {
    node = node.right;
  }
  return node;
}
function calculateSize(node) {
  if (node === SENTINEL2) {
    return 0;
  }
  return node.size_left + node.piece.length + calculateSize(node.right);
}
function calculateLF(node) {
  if (node === SENTINEL2) {
    return 0;
  }
  return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);
}
function resetSentinel2() {
  SENTINEL2.parent = SENTINEL2;
}
function leftRotate3(tree, x) {
  let y = x.right;
  y.size_left += x.size_left + (x.piece ? x.piece.length : 0);
  y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
  x.right = y.left;
  if (y.left !== SENTINEL2) {
    y.left.parent = x;
  }
  y.parent = x.parent;
  if (x.parent === SENTINEL2) {
    tree.root = y;
  } else if (x.parent.left === x) {
    x.parent.left = y;
  } else {
    x.parent.right = y;
  }
  y.left = x;
  x.parent = y;
}
function rightRotate2(tree, y) {
  let x = y.left;
  y.left = x.right;
  if (x.right !== SENTINEL2) {
    x.right.parent = y;
  }
  x.parent = y.parent;
  y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);
  y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
  if (y.parent === SENTINEL2) {
    tree.root = x;
  } else if (y === y.parent.right) {
    y.parent.right = x;
  } else {
    y.parent.left = x;
  }
  x.right = y;
  y.parent = x;
}
function rbDelete(tree, z) {
  let x;
  let y;
  if (z.left === SENTINEL2) {
    y = z;
    x = y.right;
  } else if (z.right === SENTINEL2) {
    y = z;
    x = y.left;
  } else {
    y = leftest2(z.right);
    x = y.right;
  }
  if (y === tree.root) {
    tree.root = x;
    x.color = 0;
    z.detach();
    resetSentinel2();
    tree.root.parent = SENTINEL2;
    return;
  }
  let yWasRed = y.color === 1;
  if (y === y.parent.left) {
    y.parent.left = x;
  } else {
    y.parent.right = x;
  }
  if (y === z) {
    x.parent = y.parent;
    recomputeTreeMetadata(tree, x);
  } else {
    if (y.parent === z) {
      x.parent = y;
    } else {
      x.parent = y.parent;
    }
    recomputeTreeMetadata(tree, x);
    y.left = z.left;
    y.right = z.right;
    y.parent = z.parent;
    y.color = z.color;
    if (z === tree.root) {
      tree.root = y;
    } else {
      if (z === z.parent.left) {
        z.parent.left = y;
      } else {
        z.parent.right = y;
      }
    }
    if (y.left !== SENTINEL2) {
      y.left.parent = y;
    }
    if (y.right !== SENTINEL2) {
      y.right.parent = y;
    }
    y.size_left = z.size_left;
    y.lf_left = z.lf_left;
    recomputeTreeMetadata(tree, y);
  }
  z.detach();
  if (x.parent.left === x) {
    let newSizeLeft = calculateSize(x);
    let newLFLeft = calculateLF(x);
    if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {
      let delta = newSizeLeft - x.parent.size_left;
      let lf_delta = newLFLeft - x.parent.lf_left;
      x.parent.size_left = newSizeLeft;
      x.parent.lf_left = newLFLeft;
      updateTreeMetadata(tree, x.parent, delta, lf_delta);
    }
  }
  recomputeTreeMetadata(tree, x.parent);
  if (yWasRed) {
    resetSentinel2();
    return;
  }
  let w;
  while (x !== tree.root && x.color === 0) {
    if (x === x.parent.left) {
      w = x.parent.right;
      if (w.color === 1) {
        w.color = 0;
        x.parent.color = 1;
        leftRotate3(tree, x.parent);
        w = x.parent.right;
      }
      if (w.left.color === 0 && w.right.color === 0) {
        w.color = 1;
        x = x.parent;
      } else {
        if (w.right.color === 0) {
          w.left.color = 0;
          w.color = 1;
          rightRotate2(tree, w);
          w = x.parent.right;
        }
        w.color = x.parent.color;
        x.parent.color = 0;
        w.right.color = 0;
        leftRotate3(tree, x.parent);
        x = tree.root;
      }
    } else {
      w = x.parent.left;
      if (w.color === 1) {
        w.color = 0;
        x.parent.color = 1;
        rightRotate2(tree, x.parent);
        w = x.parent.left;
      }
      if (w.left.color === 0 && w.right.color === 0) {
        w.color = 1;
        x = x.parent;
      } else {
        if (w.left.color === 0) {
          w.right.color = 0;
          w.color = 1;
          leftRotate3(tree, w);
          w = x.parent.left;
        }
        w.color = x.parent.color;
        x.parent.color = 0;
        w.left.color = 0;
        rightRotate2(tree, x.parent);
        x = tree.root;
      }
    }
  }
  x.color = 0;
  resetSentinel2();
}
function fixInsert(tree, x) {
  recomputeTreeMetadata(tree, x);
  while (x !== tree.root && x.parent.color === 1) {
    if (x.parent === x.parent.parent.left) {
      const y = x.parent.parent.right;
      if (y.color === 1) {
        x.parent.color = 0;
        y.color = 0;
        x.parent.parent.color = 1;
        x = x.parent.parent;
      } else {
        if (x === x.parent.right) {
          x = x.parent;
          leftRotate3(tree, x);
        }
        x.parent.color = 0;
        x.parent.parent.color = 1;
        rightRotate2(tree, x.parent.parent);
      }
    } else {
      const y = x.parent.parent.left;
      if (y.color === 1) {
        x.parent.color = 0;
        y.color = 0;
        x.parent.parent.color = 1;
        x = x.parent.parent;
      } else {
        if (x === x.parent.left) {
          x = x.parent;
          rightRotate2(tree, x);
        }
        x.parent.color = 0;
        x.parent.parent.color = 1;
        leftRotate3(tree, x.parent.parent);
      }
    }
  }
  tree.root.color = 0;
}
function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {
  while (x !== tree.root && x !== SENTINEL2) {
    if (x.parent.left === x) {
      x.parent.size_left += delta;
      x.parent.lf_left += lineFeedCntDelta;
    }
    x = x.parent;
  }
}
function recomputeTreeMetadata(tree, x) {
  let delta = 0;
  let lf_delta = 0;
  if (x === tree.root) {
    return;
  }
  if (delta === 0) {
    while (x !== tree.root && x === x.parent.right) {
      x = x.parent;
    }
    if (x === tree.root) {
      return;
    }
    x = x.parent;
    delta = calculateSize(x.left) - x.size_left;
    lf_delta = calculateLF(x.left) - x.lf_left;
    x.size_left += delta;
    x.lf_left += lf_delta;
  }
  while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {
    if (x.parent.left === x) {
      x.parent.size_left += delta;
      x.parent.lf_left += lf_delta;
    }
    x = x.parent;
  }
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/controller/wordCharacterClassifier.js
var WordCharacterClassifier = class extends CharacterClassifier {
  constructor(wordSeparators2) {
    super(0);
    for (let i = 0, len = wordSeparators2.length; i < len; i++) {
      this.set(wordSeparators2.charCodeAt(i), 2);
    }
    this.set(32, 1);
    this.set(9, 1);
  }
};
function once(computeFn) {
  let cache = {};
  return (input) => {
    if (!cache.hasOwnProperty(input)) {
      cache[input] = computeFn(input);
    }
    return cache[input];
  };
}
var getMapForWordSeparators = once((input) => new WordCharacterClassifier(input));

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js
var LIMIT_FIND_COUNT = 999;
var SearchParams = class {
  constructor(searchString, isRegex, matchCase, wordSeparators2) {
    this.searchString = searchString;
    this.isRegex = isRegex;
    this.matchCase = matchCase;
    this.wordSeparators = wordSeparators2;
  }
  parseSearchRequest() {
    if (this.searchString === "") {
      return null;
    }
    let multiline;
    if (this.isRegex) {
      multiline = isMultilineRegexSource(this.searchString);
    } else {
      multiline = this.searchString.indexOf("\n") >= 0;
    }
    let regex = null;
    try {
      regex = createRegExp(this.searchString, this.isRegex, {
        matchCase: this.matchCase,
        wholeWord: false,
        multiline,
        global: true,
        unicode: true
      });
    } catch (err) {
      return null;
    }
    if (!regex) {
      return null;
    }
    let canUseSimpleSearch = !this.isRegex && !multiline;
    if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {
      canUseSimpleSearch = this.matchCase;
    }
    return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);
  }
};
function isMultilineRegexSource(searchString) {
  if (!searchString || searchString.length === 0) {
    return false;
  }
  for (let i = 0, len = searchString.length; i < len; i++) {
    const chCode = searchString.charCodeAt(i);
    if (chCode === 92) {
      i++;
      if (i >= len) {
        break;
      }
      const nextChCode = searchString.charCodeAt(i);
      if (nextChCode === 110 || nextChCode === 114 || nextChCode === 87 || nextChCode === 119) {
        return true;
      }
    }
  }
  return false;
}
var SearchData = class {
  constructor(regex, wordSeparators2, simpleSearch) {
    this.regex = regex;
    this.wordSeparators = wordSeparators2;
    this.simpleSearch = simpleSearch;
  }
};
function createFindMatch(range2, rawMatches, captureMatches) {
  if (!captureMatches) {
    return new FindMatch(range2, null);
  }
  let matches = [];
  for (let i = 0, len = rawMatches.length; i < len; i++) {
    matches[i] = rawMatches[i];
  }
  return new FindMatch(range2, matches);
}
var LineFeedCounter = class {
  constructor(text) {
    let lineFeedsOffsets = [];
    let lineFeedsOffsetsLen = 0;
    for (let i = 0, textLen = text.length; i < textLen; i++) {
      if (text.charCodeAt(i) === 10) {
        lineFeedsOffsets[lineFeedsOffsetsLen++] = i;
      }
    }
    this._lineFeedsOffsets = lineFeedsOffsets;
  }
  findLineFeedCountBeforeOffset(offset) {
    const lineFeedsOffsets = this._lineFeedsOffsets;
    let min = 0;
    let max = lineFeedsOffsets.length - 1;
    if (max === -1) {
      return 0;
    }
    if (offset <= lineFeedsOffsets[0]) {
      return 0;
    }
    while (min < max) {
      const mid = min + ((max - min) / 2 >> 0);
      if (lineFeedsOffsets[mid] >= offset) {
        max = mid - 1;
      } else {
        if (lineFeedsOffsets[mid + 1] >= offset) {
          min = mid;
          max = mid;
        } else {
          min = mid + 1;
        }
      }
    }
    return min + 1;
  }
};
var TextModelSearch = class {
  static findMatches(model2, searchParams, searchRange, captureMatches, limitResultCount) {
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return [];
    }
    if (searchData.regex.multiline) {
      return this._doFindMatchesMultiline(model2, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);
    }
    return this._doFindMatchesLineByLine(model2, searchRange, searchData, captureMatches, limitResultCount);
  }
  static _getMultilineMatchRange(model2, deltaOffset, text, lfCounter, matchIndex, match0) {
    let startOffset;
    let lineFeedCountBeforeMatch = 0;
    if (lfCounter) {
      lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);
      startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch;
    } else {
      startOffset = deltaOffset + matchIndex;
    }
    let endOffset;
    if (lfCounter) {
      let lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);
      let lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;
      endOffset = startOffset + match0.length + lineFeedCountInMatch;
    } else {
      endOffset = startOffset + match0.length;
    }
    const startPosition = model2.getPositionAt(startOffset);
    const endPosition = model2.getPositionAt(endOffset);
    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
  }
  static _doFindMatchesMultiline(model2, searchRange, searcher, captureMatches, limitResultCount) {
    const deltaOffset = model2.getOffsetAt(searchRange.getStartPosition());
    const text = model2.getValueInRange(searchRange, 1);
    const lfCounter = model2.getEOL() === "\r\n" ? new LineFeedCounter(text) : null;
    const result = [];
    let counter = 0;
    let m;
    searcher.reset(0);
    while (m = searcher.next(text)) {
      result[counter++] = createFindMatch(this._getMultilineMatchRange(model2, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);
      if (counter >= limitResultCount) {
        return result;
      }
    }
    return result;
  }
  static _doFindMatchesLineByLine(model2, searchRange, searchData, captureMatches, limitResultCount) {
    const result = [];
    let resultLen = 0;
    if (searchRange.startLineNumber === searchRange.endLineNumber) {
      const text2 = model2.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);
      resultLen = this._findMatchesInLine(searchData, text2, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
      return result;
    }
    const text = model2.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);
    resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
    for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {
      resultLen = this._findMatchesInLine(searchData, model2.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);
    }
    if (resultLen < limitResultCount) {
      const text2 = model2.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);
      resultLen = this._findMatchesInLine(searchData, text2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);
    }
    return result;
  }
  static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
    const wordSeparators2 = searchData.wordSeparators;
    if (!captureMatches && searchData.simpleSearch) {
      const searchString = searchData.simpleSearch;
      const searchStringLen = searchString.length;
      const textLength = text.length;
      let lastMatchIndex = -searchStringLen;
      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
        if (!wordSeparators2 || isValidMatch(wordSeparators2, text, textLength, lastMatchIndex, searchStringLen)) {
          result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
          if (resultLen >= limitResultCount) {
            return resultLen;
          }
        }
      }
      return resultLen;
    }
    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
    let m;
    searcher.reset(0);
    do {
      m = searcher.next(text);
      if (m) {
        result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
        if (resultLen >= limitResultCount) {
          return resultLen;
        }
      }
    } while (m);
    return resultLen;
  }
  static findNextMatch(model2, searchParams, searchStart, captureMatches) {
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return null;
    }
    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
    if (searchData.regex.multiline) {
      return this._doFindNextMatchMultiline(model2, searchStart, searcher, captureMatches);
    }
    return this._doFindNextMatchLineByLine(model2, searchStart, searcher, captureMatches);
  }
  static _doFindNextMatchMultiline(model2, searchStart, searcher, captureMatches) {
    const searchTextStart = new Position(searchStart.lineNumber, 1);
    const deltaOffset = model2.getOffsetAt(searchTextStart);
    const lineCount = model2.getLineCount();
    const text = model2.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model2.getLineMaxColumn(lineCount)), 1);
    const lfCounter = model2.getEOL() === "\r\n" ? new LineFeedCounter(text) : null;
    searcher.reset(searchStart.column - 1);
    let m = searcher.next(text);
    if (m) {
      return createFindMatch(this._getMultilineMatchRange(model2, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);
    }
    if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {
      return this._doFindNextMatchMultiline(model2, new Position(1, 1), searcher, captureMatches);
    }
    return null;
  }
  static _doFindNextMatchLineByLine(model2, searchStart, searcher, captureMatches) {
    const lineCount = model2.getLineCount();
    const startLineNumber = searchStart.lineNumber;
    const text = model2.getLineContent(startLineNumber);
    const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);
    if (r) {
      return r;
    }
    for (let i = 1; i <= lineCount; i++) {
      const lineIndex = (startLineNumber + i - 1) % lineCount;
      const text2 = model2.getLineContent(lineIndex + 1);
      const r2 = this._findFirstMatchInLine(searcher, text2, lineIndex + 1, 1, captureMatches);
      if (r2) {
        return r2;
      }
    }
    return null;
  }
  static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {
    searcher.reset(fromColumn - 1);
    const m = searcher.next(text);
    if (m) {
      return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
    }
    return null;
  }
  static findPreviousMatch(model2, searchParams, searchStart, captureMatches) {
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return null;
    }
    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
    if (searchData.regex.multiline) {
      return this._doFindPreviousMatchMultiline(model2, searchStart, searcher, captureMatches);
    }
    return this._doFindPreviousMatchLineByLine(model2, searchStart, searcher, captureMatches);
  }
  static _doFindPreviousMatchMultiline(model2, searchStart, searcher, captureMatches) {
    const matches = this._doFindMatchesMultiline(model2, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);
    if (matches.length > 0) {
      return matches[matches.length - 1];
    }
    const lineCount = model2.getLineCount();
    if (searchStart.lineNumber !== lineCount || searchStart.column !== model2.getLineMaxColumn(lineCount)) {
      return this._doFindPreviousMatchMultiline(model2, new Position(lineCount, model2.getLineMaxColumn(lineCount)), searcher, captureMatches);
    }
    return null;
  }
  static _doFindPreviousMatchLineByLine(model2, searchStart, searcher, captureMatches) {
    const lineCount = model2.getLineCount();
    const startLineNumber = searchStart.lineNumber;
    const text = model2.getLineContent(startLineNumber).substring(0, searchStart.column - 1);
    const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);
    if (r) {
      return r;
    }
    for (let i = 1; i <= lineCount; i++) {
      const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;
      const text2 = model2.getLineContent(lineIndex + 1);
      const r2 = this._findLastMatchInLine(searcher, text2, lineIndex + 1, captureMatches);
      if (r2) {
        return r2;
      }
    }
    return null;
  }
  static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {
    let bestResult = null;
    let m;
    searcher.reset(0);
    while (m = searcher.next(text)) {
      bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
    }
    return bestResult;
  }
};
function leftIsWordBounday(wordSeparators2, text, textLength, matchStartIndex, matchLength) {
  if (matchStartIndex === 0) {
    return true;
  }
  const charBefore = text.charCodeAt(matchStartIndex - 1);
  if (wordSeparators2.get(charBefore) !== 0) {
    return true;
  }
  if (charBefore === 13 || charBefore === 10) {
    return true;
  }
  if (matchLength > 0) {
    const firstCharInMatch = text.charCodeAt(matchStartIndex);
    if (wordSeparators2.get(firstCharInMatch) !== 0) {
      return true;
    }
  }
  return false;
}
function rightIsWordBounday(wordSeparators2, text, textLength, matchStartIndex, matchLength) {
  if (matchStartIndex + matchLength === textLength) {
    return true;
  }
  const charAfter = text.charCodeAt(matchStartIndex + matchLength);
  if (wordSeparators2.get(charAfter) !== 0) {
    return true;
  }
  if (charAfter === 13 || charAfter === 10) {
    return true;
  }
  if (matchLength > 0) {
    const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
    if (wordSeparators2.get(lastCharInMatch) !== 0) {
      return true;
    }
  }
  return false;
}
function isValidMatch(wordSeparators2, text, textLength, matchStartIndex, matchLength) {
  return leftIsWordBounday(wordSeparators2, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators2, text, textLength, matchStartIndex, matchLength);
}
var Searcher = class {
  constructor(wordSeparators2, searchRegex) {
    this._wordSeparators = wordSeparators2;
    this._searchRegex = searchRegex;
    this._prevMatchStartIndex = -1;
    this._prevMatchLength = 0;
  }
  reset(lastIndex) {
    this._searchRegex.lastIndex = lastIndex;
    this._prevMatchStartIndex = -1;
    this._prevMatchLength = 0;
  }
  next(text) {
    const textLength = text.length;
    let m;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
        return null;
      }
      m = this._searchRegex.exec(text);
      if (!m) {
        return null;
      }
      const matchStartIndex = m.index;
      const matchLength = m[0].length;
      if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
        if (matchLength === 0) {
          if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 65535) {
            this._searchRegex.lastIndex += 2;
          } else {
            this._searchRegex.lastIndex += 1;
          }
          continue;
        }
        return null;
      }
      this._prevMatchStartIndex = matchStartIndex;
      this._prevMatchLength = matchLength;
      if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
        return m;
      }
    } while (m);
    return null;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js
var AverageBufferSize = 65535;
function createUintArray(arr) {
  let r;
  if (arr[arr.length - 1] < 65536) {
    r = new Uint16Array(arr.length);
  } else {
    r = new Uint32Array(arr.length);
  }
  r.set(arr, 0);
  return r;
}
var LineStarts = class {
  constructor(lineStarts, cr, lf, crlf, isBasicASCII2) {
    this.lineStarts = lineStarts;
    this.cr = cr;
    this.lf = lf;
    this.crlf = crlf;
    this.isBasicASCII = isBasicASCII2;
  }
};
function createLineStartsFast(str, readonly = true) {
  let r = [0], rLength = 1;
  for (let i = 0, len = str.length; i < len; i++) {
    const chr = str.charCodeAt(i);
    if (chr === 13) {
      if (i + 1 < len && str.charCodeAt(i + 1) === 10) {
        r[rLength++] = i + 2;
        i++;
      } else {
        r[rLength++] = i + 1;
      }
    } else if (chr === 10) {
      r[rLength++] = i + 1;
    }
  }
  if (readonly) {
    return createUintArray(r);
  } else {
    return r;
  }
}
function createLineStarts(r, str) {
  r.length = 0;
  r[0] = 0;
  let rLength = 1;
  let cr = 0, lf = 0, crlf = 0;
  let isBasicASCII2 = true;
  for (let i = 0, len = str.length; i < len; i++) {
    const chr = str.charCodeAt(i);
    if (chr === 13) {
      if (i + 1 < len && str.charCodeAt(i + 1) === 10) {
        crlf++;
        r[rLength++] = i + 2;
        i++;
      } else {
        cr++;
        r[rLength++] = i + 1;
      }
    } else if (chr === 10) {
      lf++;
      r[rLength++] = i + 1;
    } else {
      if (isBasicASCII2) {
        if (chr !== 9 && (chr < 32 || chr > 126)) {
          isBasicASCII2 = false;
        }
      }
    }
  }
  const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII2);
  r.length = 0;
  return result;
}
var Piece = class {
  constructor(bufferIndex, start, end, lineFeedCnt, length) {
    this.bufferIndex = bufferIndex;
    this.start = start;
    this.end = end;
    this.lineFeedCnt = lineFeedCnt;
    this.length = length;
  }
};
var StringBuffer = class {
  constructor(buffer4, lineStarts) {
    this.buffer = buffer4;
    this.lineStarts = lineStarts;
  }
};
var PieceTreeSnapshot = class {
  constructor(tree, BOM) {
    this._pieces = [];
    this._tree = tree;
    this._BOM = BOM;
    this._index = 0;
    if (tree.root !== SENTINEL2) {
      tree.iterate(tree.root, (node) => {
        if (node !== SENTINEL2) {
          this._pieces.push(node.piece);
        }
        return true;
      });
    }
  }
  read() {
    if (this._pieces.length === 0) {
      if (this._index === 0) {
        this._index++;
        return this._BOM;
      } else {
        return null;
      }
    }
    if (this._index > this._pieces.length - 1) {
      return null;
    }
    if (this._index === 0) {
      return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);
    }
    return this._tree.getPieceContent(this._pieces[this._index++]);
  }
};
var PieceTreeSearchCache = class {
  constructor(limit) {
    this._limit = limit;
    this._cache = [];
  }
  get(offset) {
    for (let i = this._cache.length - 1; i >= 0; i--) {
      let nodePos = this._cache[i];
      if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {
        return nodePos;
      }
    }
    return null;
  }
  get2(lineNumber) {
    for (let i = this._cache.length - 1; i >= 0; i--) {
      let nodePos = this._cache[i];
      if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {
        return nodePos;
      }
    }
    return null;
  }
  set(nodePosition) {
    if (this._cache.length >= this._limit) {
      this._cache.shift();
    }
    this._cache.push(nodePosition);
  }
  validate(offset) {
    let hasInvalidVal = false;
    let tmp = this._cache;
    for (let i = 0; i < tmp.length; i++) {
      let nodePos = tmp[i];
      if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {
        tmp[i] = null;
        hasInvalidVal = true;
        continue;
      }
    }
    if (hasInvalidVal) {
      let newArr = [];
      for (const entry of tmp) {
        if (entry !== null) {
          newArr.push(entry);
        }
      }
      this._cache = newArr;
    }
  }
};
var PieceTreeBase = class {
  constructor(chunks, eol, eolNormalized) {
    this.create(chunks, eol, eolNormalized);
  }
  create(chunks, eol, eolNormalized) {
    this._buffers = [
      new StringBuffer("", [0])
    ];
    this._lastChangeBufferPos = {line: 0, column: 0};
    this.root = SENTINEL2;
    this._lineCnt = 1;
    this._length = 0;
    this._EOL = eol;
    this._EOLLength = eol.length;
    this._EOLNormalized = eolNormalized;
    let lastNode = null;
    for (let i = 0, len = chunks.length; i < len; i++) {
      if (chunks[i].buffer.length > 0) {
        if (!chunks[i].lineStarts) {
          chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);
        }
        let piece = new Piece(i + 1, {line: 0, column: 0}, {line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1]}, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);
        this._buffers.push(chunks[i]);
        lastNode = this.rbInsertRight(lastNode, piece);
      }
    }
    this._searchCache = new PieceTreeSearchCache(1);
    this._lastVisitedLine = {lineNumber: 0, value: ""};
    this.computeBufferMetadata();
  }
  normalizeEOL(eol) {
    let averageBufferSize = AverageBufferSize;
    let min = averageBufferSize - Math.floor(averageBufferSize / 3);
    let max = min * 2;
    let tempChunk = "";
    let tempChunkLen = 0;
    let chunks = [];
    this.iterate(this.root, (node) => {
      let str = this.getNodeContent(node);
      let len = str.length;
      if (tempChunkLen <= min || tempChunkLen + len < max) {
        tempChunk += str;
        tempChunkLen += len;
        return true;
      }
      let text = tempChunk.replace(/\r\n|\r|\n/g, eol);
      chunks.push(new StringBuffer(text, createLineStartsFast(text)));
      tempChunk = str;
      tempChunkLen = len;
      return true;
    });
    if (tempChunkLen > 0) {
      let text = tempChunk.replace(/\r\n|\r|\n/g, eol);
      chunks.push(new StringBuffer(text, createLineStartsFast(text)));
    }
    this.create(chunks, eol, true);
  }
  getEOL() {
    return this._EOL;
  }
  setEOL(newEOL) {
    this._EOL = newEOL;
    this._EOLLength = this._EOL.length;
    this.normalizeEOL(newEOL);
  }
  createSnapshot(BOM) {
    return new PieceTreeSnapshot(this, BOM);
  }
  getOffsetAt(lineNumber, column) {
    let leftLen = 0;
    let x = this.root;
    while (x !== SENTINEL2) {
      if (x.left !== SENTINEL2 && x.lf_left + 1 >= lineNumber) {
        x = x.left;
      } else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {
        leftLen += x.size_left;
        let accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
        return leftLen += accumualtedValInCurrentIndex + column - 1;
      } else {
        lineNumber -= x.lf_left + x.piece.lineFeedCnt;
        leftLen += x.size_left + x.piece.length;
        x = x.right;
      }
    }
    return leftLen;
  }
  getPositionAt(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    let x = this.root;
    let lfCnt = 0;
    let originalOffset = offset;
    while (x !== SENTINEL2) {
      if (x.size_left !== 0 && x.size_left >= offset) {
        x = x.left;
      } else if (x.size_left + x.piece.length >= offset) {
        let out = this.getIndexOf(x, offset - x.size_left);
        lfCnt += x.lf_left + out.index;
        if (out.index === 0) {
          let lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
          let column = originalOffset - lineStartOffset;
          return new Position(lfCnt + 1, column + 1);
        }
        return new Position(lfCnt + 1, out.remainder + 1);
      } else {
        offset -= x.size_left + x.piece.length;
        lfCnt += x.lf_left + x.piece.lineFeedCnt;
        if (x.right === SENTINEL2) {
          let lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
          let column = originalOffset - offset - lineStartOffset;
          return new Position(lfCnt + 1, column + 1);
        } else {
          x = x.right;
        }
      }
    }
    return new Position(1, 1);
  }
  getValueInRange(range2, eol) {
    if (range2.startLineNumber === range2.endLineNumber && range2.startColumn === range2.endColumn) {
      return "";
    }
    let startPosition = this.nodeAt2(range2.startLineNumber, range2.startColumn);
    let endPosition = this.nodeAt2(range2.endLineNumber, range2.endColumn);
    let value = this.getValueInRange2(startPosition, endPosition);
    if (eol) {
      if (eol !== this._EOL || !this._EOLNormalized) {
        return value.replace(/\r\n|\r|\n/g, eol);
      }
      if (eol === this.getEOL() && this._EOLNormalized) {
        if (eol === "\r\n") {
        }
        return value;
      }
      return value.replace(/\r\n|\r|\n/g, eol);
    }
    return value;
  }
  getValueInRange2(startPosition, endPosition) {
    if (startPosition.node === endPosition.node) {
      let node = startPosition.node;
      let buffer5 = this._buffers[node.piece.bufferIndex].buffer;
      let startOffset2 = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
      return buffer5.substring(startOffset2 + startPosition.remainder, startOffset2 + endPosition.remainder);
    }
    let x = startPosition.node;
    let buffer4 = this._buffers[x.piece.bufferIndex].buffer;
    let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
    let ret = buffer4.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);
    x = x.next();
    while (x !== SENTINEL2) {
      let buffer5 = this._buffers[x.piece.bufferIndex].buffer;
      let startOffset2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
      if (x === endPosition.node) {
        ret += buffer5.substring(startOffset2, startOffset2 + endPosition.remainder);
        break;
      } else {
        ret += buffer5.substr(startOffset2, x.piece.length);
      }
      x = x.next();
    }
    return ret;
  }
  getLinesContent() {
    let lines = [];
    let linesLength = 0;
    let currentLine = "";
    let danglingCR = false;
    this.iterate(this.root, (node) => {
      if (node === SENTINEL2) {
        return true;
      }
      const piece = node.piece;
      let pieceLength = piece.length;
      if (pieceLength === 0) {
        return true;
      }
      const buffer4 = this._buffers[piece.bufferIndex].buffer;
      const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
      const pieceStartLine = piece.start.line;
      const pieceEndLine = piece.end.line;
      let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;
      if (danglingCR) {
        if (buffer4.charCodeAt(pieceStartOffset) === 10) {
          pieceStartOffset++;
          pieceLength--;
        }
        lines[linesLength++] = currentLine;
        currentLine = "";
        danglingCR = false;
        if (pieceLength === 0) {
          return true;
        }
      }
      if (pieceStartLine === pieceEndLine) {
        if (!this._EOLNormalized && buffer4.charCodeAt(pieceStartOffset + pieceLength - 1) === 13) {
          danglingCR = true;
          currentLine += buffer4.substr(pieceStartOffset, pieceLength - 1);
        } else {
          currentLine += buffer4.substr(pieceStartOffset, pieceLength);
        }
        return true;
      }
      currentLine += this._EOLNormalized ? buffer4.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength)) : buffer4.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\r\n|\r|\n)$/, "");
      lines[linesLength++] = currentLine;
      for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {
        currentLine = this._EOLNormalized ? buffer4.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength) : buffer4.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\r\n|\r|\n)$/, "");
        lines[linesLength++] = currentLine;
      }
      if (!this._EOLNormalized && buffer4.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13) {
        danglingCR = true;
        if (piece.end.column === 0) {
          linesLength--;
        } else {
          currentLine = buffer4.substr(lineStarts[pieceEndLine], piece.end.column - 1);
        }
      } else {
        currentLine = buffer4.substr(lineStarts[pieceEndLine], piece.end.column);
      }
      return true;
    });
    if (danglingCR) {
      lines[linesLength++] = currentLine;
      currentLine = "";
    }
    lines[linesLength++] = currentLine;
    return lines;
  }
  getLength() {
    return this._length;
  }
  getLineCount() {
    return this._lineCnt;
  }
  getLineContent(lineNumber) {
    if (this._lastVisitedLine.lineNumber === lineNumber) {
      return this._lastVisitedLine.value;
    }
    this._lastVisitedLine.lineNumber = lineNumber;
    if (lineNumber === this._lineCnt) {
      this._lastVisitedLine.value = this.getLineRawContent(lineNumber);
    } else if (this._EOLNormalized) {
      this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);
    } else {
      this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\r\n|\r|\n)$/, "");
    }
    return this._lastVisitedLine.value;
  }
  _getCharCode(nodePos) {
    if (nodePos.remainder === nodePos.node.piece.length) {
      let matchingNode = nodePos.node.next();
      if (!matchingNode) {
        return 0;
      }
      let buffer4 = this._buffers[matchingNode.piece.bufferIndex];
      let startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);
      return buffer4.buffer.charCodeAt(startOffset);
    } else {
      let buffer4 = this._buffers[nodePos.node.piece.bufferIndex];
      let startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);
      let targetOffset = startOffset + nodePos.remainder;
      return buffer4.buffer.charCodeAt(targetOffset);
    }
  }
  getLineCharCode(lineNumber, index) {
    let nodePos = this.nodeAt2(lineNumber, index + 1);
    return this._getCharCode(nodePos);
  }
  getLineLength(lineNumber) {
    if (lineNumber === this.getLineCount()) {
      let startOffset = this.getOffsetAt(lineNumber, 1);
      return this.getLength() - startOffset;
    }
    return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;
  }
  findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {
    let buffer4 = this._buffers[node.piece.bufferIndex];
    let startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
    let start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);
    let end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);
    let m;
    let ret = {line: 0, column: 0};
    let searchText;
    let offsetInBuffer;
    if (searcher._wordSeparators) {
      searchText = buffer4.buffer.substring(start, end);
      offsetInBuffer = (offset) => offset + start;
      searcher.reset(0);
    } else {
      searchText = buffer4.buffer;
      offsetInBuffer = (offset) => offset;
      searcher.reset(start);
    }
    do {
      m = searcher.next(searchText);
      if (m) {
        if (offsetInBuffer(m.index) >= end) {
          return resultLen;
        }
        this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);
        let lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);
        let retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;
        let retEndColumn = retStartColumn + m[0].length;
        result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);
        if (offsetInBuffer(m.index) + m[0].length >= end) {
          return resultLen;
        }
        if (resultLen >= limitResultCount) {
          return resultLen;
        }
      }
    } while (m);
    return resultLen;
  }
  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
    const result = [];
    let resultLen = 0;
    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
    let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);
    if (startPosition === null) {
      return [];
    }
    let endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);
    if (endPosition === null) {
      return [];
    }
    let start = this.positionInBuffer(startPosition.node, startPosition.remainder);
    let end = this.positionInBuffer(endPosition.node, endPosition.remainder);
    if (startPosition.node === endPosition.node) {
      this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
      return result;
    }
    let startLineNumber = searchRange.startLineNumber;
    let currentNode = startPosition.node;
    while (currentNode !== endPosition.node) {
      let lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);
      if (lineBreakCnt >= 1) {
        let lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;
        let startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);
        let nextLineStartOffset = lineStarts[start.line + lineBreakCnt];
        let startColumn3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
        resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn3, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);
        if (resultLen >= limitResultCount) {
          return result;
        }
        startLineNumber += lineBreakCnt;
      }
      let startColumn2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
      if (startLineNumber === searchRange.endLineNumber) {
        const text = this.getLineContent(startLineNumber).substring(startColumn2, searchRange.endColumn - 1);
        resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn2, resultLen, result, captureMatches, limitResultCount);
        return result;
      }
      resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn2), startLineNumber, startColumn2, resultLen, result, captureMatches, limitResultCount);
      if (resultLen >= limitResultCount) {
        return result;
      }
      startLineNumber++;
      startPosition = this.nodeAt2(startLineNumber, 1);
      currentNode = startPosition.node;
      start = this.positionInBuffer(startPosition.node, startPosition.remainder);
    }
    if (startLineNumber === searchRange.endLineNumber) {
      let startColumn2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
      const text = this.getLineContent(startLineNumber).substring(startColumn2, searchRange.endColumn - 1);
      resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn2, resultLen, result, captureMatches, limitResultCount);
      return result;
    }
    let startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
    resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
    return result;
  }
  _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
    const wordSeparators2 = searchData.wordSeparators;
    if (!captureMatches && searchData.simpleSearch) {
      const searchString = searchData.simpleSearch;
      const searchStringLen = searchString.length;
      const textLength = text.length;
      let lastMatchIndex = -searchStringLen;
      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
        if (!wordSeparators2 || isValidMatch(wordSeparators2, text, textLength, lastMatchIndex, searchStringLen)) {
          result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
          if (resultLen >= limitResultCount) {
            return resultLen;
          }
        }
      }
      return resultLen;
    }
    let m;
    searcher.reset(0);
    do {
      m = searcher.next(text);
      if (m) {
        result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
        if (resultLen >= limitResultCount) {
          return resultLen;
        }
      }
    } while (m);
    return resultLen;
  }
  insert(offset, value, eolNormalized = false) {
    this._EOLNormalized = this._EOLNormalized && eolNormalized;
    this._lastVisitedLine.lineNumber = 0;
    this._lastVisitedLine.value = "";
    if (this.root !== SENTINEL2) {
      let {node, remainder, nodeStartOffset} = this.nodeAt(offset);
      let piece = node.piece;
      let bufferIndex = piece.bufferIndex;
      let insertPosInBuffer = this.positionInBuffer(node, remainder);
      if (node.piece.bufferIndex === 0 && piece.end.line === this._lastChangeBufferPos.line && piece.end.column === this._lastChangeBufferPos.column && nodeStartOffset + piece.length === offset && value.length < AverageBufferSize) {
        this.appendToNode(node, value);
        this.computeBufferMetadata();
        return;
      }
      if (nodeStartOffset === offset) {
        this.insertContentToNodeLeft(value, node);
        this._searchCache.validate(offset);
      } else if (nodeStartOffset + node.piece.length > offset) {
        let nodesToDel = [];
        let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));
        if (this.shouldCheckCRLF() && this.endWithCR(value)) {
          let headOfRight = this.nodeCharCodeAt(node, remainder);
          if (headOfRight === 10) {
            let newStart = {line: newRightPiece.start.line + 1, column: 0};
            newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);
            value += "\n";
          }
        }
        if (this.shouldCheckCRLF() && this.startWithLF(value)) {
          let tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);
          if (tailOfLeft === 13) {
            let previousPos = this.positionInBuffer(node, remainder - 1);
            this.deleteNodeTail(node, previousPos);
            value = "\r" + value;
            if (node.piece.length === 0) {
              nodesToDel.push(node);
            }
          } else {
            this.deleteNodeTail(node, insertPosInBuffer);
          }
        } else {
          this.deleteNodeTail(node, insertPosInBuffer);
        }
        let newPieces = this.createNewPieces(value);
        if (newRightPiece.length > 0) {
          this.rbInsertRight(node, newRightPiece);
        }
        let tmpNode = node;
        for (let k = 0; k < newPieces.length; k++) {
          tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
        }
        this.deleteNodes(nodesToDel);
      } else {
        this.insertContentToNodeRight(value, node);
      }
    } else {
      let pieces = this.createNewPieces(value);
      let node = this.rbInsertLeft(null, pieces[0]);
      for (let k = 1; k < pieces.length; k++) {
        node = this.rbInsertRight(node, pieces[k]);
      }
    }
    this.computeBufferMetadata();
  }
  delete(offset, cnt) {
    this._lastVisitedLine.lineNumber = 0;
    this._lastVisitedLine.value = "";
    if (cnt <= 0 || this.root === SENTINEL2) {
      return;
    }
    let startPosition = this.nodeAt(offset);
    let endPosition = this.nodeAt(offset + cnt);
    let startNode = startPosition.node;
    let endNode = endPosition.node;
    if (startNode === endNode) {
      let startSplitPosInBuffer2 = this.positionInBuffer(startNode, startPosition.remainder);
      let endSplitPosInBuffer2 = this.positionInBuffer(startNode, endPosition.remainder);
      if (startPosition.nodeStartOffset === offset) {
        if (cnt === startNode.piece.length) {
          let next = startNode.next();
          rbDelete(this, startNode);
          this.validateCRLFWithPrevNode(next);
          this.computeBufferMetadata();
          return;
        }
        this.deleteNodeHead(startNode, endSplitPosInBuffer2);
        this._searchCache.validate(offset);
        this.validateCRLFWithPrevNode(startNode);
        this.computeBufferMetadata();
        return;
      }
      if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {
        this.deleteNodeTail(startNode, startSplitPosInBuffer2);
        this.validateCRLFWithNextNode(startNode);
        this.computeBufferMetadata();
        return;
      }
      this.shrinkNode(startNode, startSplitPosInBuffer2, endSplitPosInBuffer2);
      this.computeBufferMetadata();
      return;
    }
    let nodesToDel = [];
    let startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);
    this.deleteNodeTail(startNode, startSplitPosInBuffer);
    this._searchCache.validate(offset);
    if (startNode.piece.length === 0) {
      nodesToDel.push(startNode);
    }
    let endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);
    this.deleteNodeHead(endNode, endSplitPosInBuffer);
    if (endNode.piece.length === 0) {
      nodesToDel.push(endNode);
    }
    let secondNode = startNode.next();
    for (let node = secondNode; node !== SENTINEL2 && node !== endNode; node = node.next()) {
      nodesToDel.push(node);
    }
    let prev = startNode.piece.length === 0 ? startNode.prev() : startNode;
    this.deleteNodes(nodesToDel);
    this.validateCRLFWithNextNode(prev);
    this.computeBufferMetadata();
  }
  insertContentToNodeLeft(value, node) {
    let nodesToDel = [];
    if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {
      let piece = node.piece;
      let newStart = {line: piece.start.line + 1, column: 0};
      let nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);
      node.piece = nPiece;
      value += "\n";
      updateTreeMetadata(this, node, -1, -1);
      if (node.piece.length === 0) {
        nodesToDel.push(node);
      }
    }
    let newPieces = this.createNewPieces(value);
    let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);
    for (let k = newPieces.length - 2; k >= 0; k--) {
      newNode = this.rbInsertLeft(newNode, newPieces[k]);
    }
    this.validateCRLFWithPrevNode(newNode);
    this.deleteNodes(nodesToDel);
  }
  insertContentToNodeRight(value, node) {
    if (this.adjustCarriageReturnFromNext(value, node)) {
      value += "\n";
    }
    let newPieces = this.createNewPieces(value);
    let newNode = this.rbInsertRight(node, newPieces[0]);
    let tmpNode = newNode;
    for (let k = 1; k < newPieces.length; k++) {
      tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
    }
    this.validateCRLFWithPrevNode(newNode);
  }
  positionInBuffer(node, remainder, ret) {
    let piece = node.piece;
    let bufferIndex = node.piece.bufferIndex;
    let lineStarts = this._buffers[bufferIndex].lineStarts;
    let startOffset = lineStarts[piece.start.line] + piece.start.column;
    let offset = startOffset + remainder;
    let low = piece.start.line;
    let high = piece.end.line;
    let mid = 0;
    let midStop = 0;
    let midStart = 0;
    while (low <= high) {
      mid = low + (high - low) / 2 | 0;
      midStart = lineStarts[mid];
      if (mid === high) {
        break;
      }
      midStop = lineStarts[mid + 1];
      if (offset < midStart) {
        high = mid - 1;
      } else if (offset >= midStop) {
        low = mid + 1;
      } else {
        break;
      }
    }
    if (ret) {
      ret.line = mid;
      ret.column = offset - midStart;
      return null;
    }
    return {
      line: mid,
      column: offset - midStart
    };
  }
  getLineFeedCnt(bufferIndex, start, end) {
    if (end.column === 0) {
      return end.line - start.line;
    }
    let lineStarts = this._buffers[bufferIndex].lineStarts;
    if (end.line === lineStarts.length - 1) {
      return end.line - start.line;
    }
    let nextLineStartOffset = lineStarts[end.line + 1];
    let endOffset = lineStarts[end.line] + end.column;
    if (nextLineStartOffset > endOffset + 1) {
      return end.line - start.line;
    }
    let previousCharOffset = endOffset - 1;
    let buffer4 = this._buffers[bufferIndex].buffer;
    if (buffer4.charCodeAt(previousCharOffset) === 13) {
      return end.line - start.line + 1;
    } else {
      return end.line - start.line;
    }
  }
  offsetInBuffer(bufferIndex, cursor) {
    let lineStarts = this._buffers[bufferIndex].lineStarts;
    return lineStarts[cursor.line] + cursor.column;
  }
  deleteNodes(nodes) {
    for (let i = 0; i < nodes.length; i++) {
      rbDelete(this, nodes[i]);
    }
  }
  createNewPieces(text) {
    if (text.length > AverageBufferSize) {
      let newPieces = [];
      while (text.length > AverageBufferSize) {
        const lastChar = text.charCodeAt(AverageBufferSize - 1);
        let splitText;
        if (lastChar === 13 || lastChar >= 55296 && lastChar <= 56319) {
          splitText = text.substring(0, AverageBufferSize - 1);
          text = text.substring(AverageBufferSize - 1);
        } else {
          splitText = text.substring(0, AverageBufferSize);
          text = text.substring(AverageBufferSize);
        }
        let lineStarts3 = createLineStartsFast(splitText);
        newPieces.push(new Piece(this._buffers.length, {line: 0, column: 0}, {line: lineStarts3.length - 1, column: splitText.length - lineStarts3[lineStarts3.length - 1]}, lineStarts3.length - 1, splitText.length));
        this._buffers.push(new StringBuffer(splitText, lineStarts3));
      }
      let lineStarts2 = createLineStartsFast(text);
      newPieces.push(new Piece(this._buffers.length, {line: 0, column: 0}, {line: lineStarts2.length - 1, column: text.length - lineStarts2[lineStarts2.length - 1]}, lineStarts2.length - 1, text.length));
      this._buffers.push(new StringBuffer(text, lineStarts2));
      return newPieces;
    }
    let startOffset = this._buffers[0].buffer.length;
    const lineStarts = createLineStartsFast(text, false);
    let start = this._lastChangeBufferPos;
    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset && startOffset !== 0 && this.startWithLF(text) && this.endWithCR(this._buffers[0].buffer)) {
      this._lastChangeBufferPos = {line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1};
      start = this._lastChangeBufferPos;
      for (let i = 0; i < lineStarts.length; i++) {
        lineStarts[i] += startOffset + 1;
      }
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
      this._buffers[0].buffer += "_" + text;
      startOffset += 1;
    } else {
      if (startOffset !== 0) {
        for (let i = 0; i < lineStarts.length; i++) {
          lineStarts[i] += startOffset;
        }
      }
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
      this._buffers[0].buffer += text;
    }
    const endOffset = this._buffers[0].buffer.length;
    let endIndex = this._buffers[0].lineStarts.length - 1;
    let endColumn = endOffset - this._buffers[0].lineStarts[endIndex];
    let endPos = {line: endIndex, column: endColumn};
    let newPiece = new Piece(0, start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);
    this._lastChangeBufferPos = endPos;
    return [newPiece];
  }
  getLineRawContent(lineNumber, endOffset = 0) {
    let x = this.root;
    let ret = "";
    let cache = this._searchCache.get2(lineNumber);
    if (cache) {
      x = cache.node;
      let prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);
      let buffer4 = this._buffers[x.piece.bufferIndex].buffer;
      let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
      if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {
        ret = buffer4.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
      } else {
        let accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);
        return buffer4.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);
      }
    } else {
      let nodeStartOffset = 0;
      const originalLineNumber = lineNumber;
      while (x !== SENTINEL2) {
        if (x.left !== SENTINEL2 && x.lf_left >= lineNumber - 1) {
          x = x.left;
        } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
          let prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
          let accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
          let buffer4 = this._buffers[x.piece.bufferIndex].buffer;
          let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
          nodeStartOffset += x.size_left;
          this._searchCache.set({
            node: x,
            nodeStartOffset,
            nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)
          });
          return buffer4.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);
        } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
          let prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
          let buffer4 = this._buffers[x.piece.bufferIndex].buffer;
          let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
          ret = buffer4.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
          break;
        } else {
          lineNumber -= x.lf_left + x.piece.lineFeedCnt;
          nodeStartOffset += x.size_left + x.piece.length;
          x = x.right;
        }
      }
    }
    x = x.next();
    while (x !== SENTINEL2) {
      let buffer4 = this._buffers[x.piece.bufferIndex].buffer;
      if (x.piece.lineFeedCnt > 0) {
        let accumulatedValue = this.getAccumulatedValue(x, 0);
        let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
        ret += buffer4.substring(startOffset, startOffset + accumulatedValue - endOffset);
        return ret;
      } else {
        let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
        ret += buffer4.substr(startOffset, x.piece.length);
      }
      x = x.next();
    }
    return ret;
  }
  computeBufferMetadata() {
    let x = this.root;
    let lfCnt = 1;
    let len = 0;
    while (x !== SENTINEL2) {
      lfCnt += x.lf_left + x.piece.lineFeedCnt;
      len += x.size_left + x.piece.length;
      x = x.right;
    }
    this._lineCnt = lfCnt;
    this._length = len;
    this._searchCache.validate(this._length);
  }
  getIndexOf(node, accumulatedValue) {
    let piece = node.piece;
    let pos = this.positionInBuffer(node, accumulatedValue);
    let lineCnt = pos.line - piece.start.line;
    if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {
      let realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);
      if (realLineCnt !== lineCnt) {
        return {index: realLineCnt, remainder: 0};
      }
    }
    return {index: lineCnt, remainder: pos.column};
  }
  getAccumulatedValue(node, index) {
    if (index < 0) {
      return 0;
    }
    let piece = node.piece;
    let lineStarts = this._buffers[piece.bufferIndex].lineStarts;
    let expectedLineStartIndex = piece.start.line + index + 1;
    if (expectedLineStartIndex > piece.end.line) {
      return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;
    } else {
      return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;
    }
  }
  deleteNodeTail(node, pos) {
    const piece = node.piece;
    const originalLFCnt = piece.lineFeedCnt;
    const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
    const newEnd = pos;
    const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);
    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
    const lf_delta = newLineFeedCnt - originalLFCnt;
    const size_delta = newEndOffset - originalEndOffset;
    const newLength = piece.length + size_delta;
    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
    updateTreeMetadata(this, node, size_delta, lf_delta);
  }
  deleteNodeHead(node, pos) {
    const piece = node.piece;
    const originalLFCnt = piece.lineFeedCnt;
    const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
    const newStart = pos;
    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
    const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);
    const lf_delta = newLineFeedCnt - originalLFCnt;
    const size_delta = originalStartOffset - newStartOffset;
    const newLength = piece.length + size_delta;
    node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
    updateTreeMetadata(this, node, size_delta, lf_delta);
  }
  shrinkNode(node, start, end) {
    const piece = node.piece;
    const originalStartPos = piece.start;
    const originalEndPos = piece.end;
    const oldLength = piece.length;
    const oldLFCnt = piece.lineFeedCnt;
    const newEnd = start;
    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
    const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);
    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
    updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);
    let newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));
    let newNode = this.rbInsertRight(node, newPiece);
    this.validateCRLFWithPrevNode(newNode);
  }
  appendToNode(node, value) {
    if (this.adjustCarriageReturnFromNext(value, node)) {
      value += "\n";
    }
    const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);
    const startOffset = this._buffers[0].buffer.length;
    this._buffers[0].buffer += value;
    const lineStarts = createLineStartsFast(value, false);
    for (let i = 0; i < lineStarts.length; i++) {
      lineStarts[i] += startOffset;
    }
    if (hitCRLF) {
      let prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
      this._buffers[0].lineStarts.pop();
      this._lastChangeBufferPos = {line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset};
    }
    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
    const endIndex = this._buffers[0].lineStarts.length - 1;
    const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];
    const newEnd = {line: endIndex, column: endColumn};
    const newLength = node.piece.length + value.length;
    const oldLineFeedCnt = node.piece.lineFeedCnt;
    const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);
    const lf_delta = newLineFeedCnt - oldLineFeedCnt;
    node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);
    this._lastChangeBufferPos = newEnd;
    updateTreeMetadata(this, node, value.length, lf_delta);
  }
  nodeAt(offset) {
    let x = this.root;
    let cache = this._searchCache.get(offset);
    if (cache) {
      return {
        node: cache.node,
        nodeStartOffset: cache.nodeStartOffset,
        remainder: offset - cache.nodeStartOffset
      };
    }
    let nodeStartOffset = 0;
    while (x !== SENTINEL2) {
      if (x.size_left > offset) {
        x = x.left;
      } else if (x.size_left + x.piece.length >= offset) {
        nodeStartOffset += x.size_left;
        let ret = {
          node: x,
          remainder: offset - x.size_left,
          nodeStartOffset
        };
        this._searchCache.set(ret);
        return ret;
      } else {
        offset -= x.size_left + x.piece.length;
        nodeStartOffset += x.size_left + x.piece.length;
        x = x.right;
      }
    }
    return null;
  }
  nodeAt2(lineNumber, column) {
    let x = this.root;
    let nodeStartOffset = 0;
    while (x !== SENTINEL2) {
      if (x.left !== SENTINEL2 && x.lf_left >= lineNumber - 1) {
        x = x.left;
      } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
        let prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
        let accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
        nodeStartOffset += x.size_left;
        return {
          node: x,
          remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),
          nodeStartOffset
        };
      } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
        let prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
        if (prevAccumualtedValue + column - 1 <= x.piece.length) {
          return {
            node: x,
            remainder: prevAccumualtedValue + column - 1,
            nodeStartOffset
          };
        } else {
          column -= x.piece.length - prevAccumualtedValue;
          break;
        }
      } else {
        lineNumber -= x.lf_left + x.piece.lineFeedCnt;
        nodeStartOffset += x.size_left + x.piece.length;
        x = x.right;
      }
    }
    x = x.next();
    while (x !== SENTINEL2) {
      if (x.piece.lineFeedCnt > 0) {
        let accumulatedValue = this.getAccumulatedValue(x, 0);
        let nodeStartOffset2 = this.offsetOfNode(x);
        return {
          node: x,
          remainder: Math.min(column - 1, accumulatedValue),
          nodeStartOffset: nodeStartOffset2
        };
      } else {
        if (x.piece.length >= column - 1) {
          let nodeStartOffset2 = this.offsetOfNode(x);
          return {
            node: x,
            remainder: column - 1,
            nodeStartOffset: nodeStartOffset2
          };
        } else {
          column -= x.piece.length;
        }
      }
      x = x.next();
    }
    return null;
  }
  nodeCharCodeAt(node, offset) {
    if (node.piece.lineFeedCnt < 1) {
      return -1;
    }
    let buffer4 = this._buffers[node.piece.bufferIndex];
    let newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;
    return buffer4.buffer.charCodeAt(newOffset);
  }
  offsetOfNode(node) {
    if (!node) {
      return 0;
    }
    let pos = node.size_left;
    while (node !== this.root) {
      if (node.parent.right === node) {
        pos += node.parent.size_left + node.parent.piece.length;
      }
      node = node.parent;
    }
    return pos;
  }
  shouldCheckCRLF() {
    return !(this._EOLNormalized && this._EOL === "\n");
  }
  startWithLF(val) {
    if (typeof val === "string") {
      return val.charCodeAt(0) === 10;
    }
    if (val === SENTINEL2 || val.piece.lineFeedCnt === 0) {
      return false;
    }
    let piece = val.piece;
    let lineStarts = this._buffers[piece.bufferIndex].lineStarts;
    let line = piece.start.line;
    let startOffset = lineStarts[line] + piece.start.column;
    if (line === lineStarts.length - 1) {
      return false;
    }
    let nextLineOffset = lineStarts[line + 1];
    if (nextLineOffset > startOffset + 1) {
      return false;
    }
    return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;
  }
  endWithCR(val) {
    if (typeof val === "string") {
      return val.charCodeAt(val.length - 1) === 13;
    }
    if (val === SENTINEL2 || val.piece.lineFeedCnt === 0) {
      return false;
    }
    return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;
  }
  validateCRLFWithPrevNode(nextNode) {
    if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {
      let node = nextNode.prev();
      if (this.endWithCR(node)) {
        this.fixCRLF(node, nextNode);
      }
    }
  }
  validateCRLFWithNextNode(node) {
    if (this.shouldCheckCRLF() && this.endWithCR(node)) {
      let nextNode = node.next();
      if (this.startWithLF(nextNode)) {
        this.fixCRLF(node, nextNode);
      }
    }
  }
  fixCRLF(prev, next) {
    let nodesToDel = [];
    let lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;
    let newEnd;
    if (prev.piece.end.column === 0) {
      newEnd = {line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1};
    } else {
      newEnd = {line: prev.piece.end.line, column: prev.piece.end.column - 1};
    }
    const prevNewLength = prev.piece.length - 1;
    const prevNewLFCnt = prev.piece.lineFeedCnt - 1;
    prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);
    updateTreeMetadata(this, prev, -1, -1);
    if (prev.piece.length === 0) {
      nodesToDel.push(prev);
    }
    let newStart = {line: next.piece.start.line + 1, column: 0};
    const newLength = next.piece.length - 1;
    const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);
    next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);
    updateTreeMetadata(this, next, -1, -1);
    if (next.piece.length === 0) {
      nodesToDel.push(next);
    }
    let pieces = this.createNewPieces("\r\n");
    this.rbInsertRight(prev, pieces[0]);
    for (let i = 0; i < nodesToDel.length; i++) {
      rbDelete(this, nodesToDel[i]);
    }
  }
  adjustCarriageReturnFromNext(value, node) {
    if (this.shouldCheckCRLF() && this.endWithCR(value)) {
      let nextNode = node.next();
      if (this.startWithLF(nextNode)) {
        value += "\n";
        if (nextNode.piece.length === 1) {
          rbDelete(this, nextNode);
        } else {
          const piece = nextNode.piece;
          const newStart = {line: piece.start.line + 1, column: 0};
          const newLength = piece.length - 1;
          const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
          nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
          updateTreeMetadata(this, nextNode, -1, -1);
        }
        return true;
      }
    }
    return false;
  }
  iterate(node, callback) {
    if (node === SENTINEL2) {
      return callback(SENTINEL2);
    }
    let leftRet = this.iterate(node.left, callback);
    if (!leftRet) {
      return leftRet;
    }
    return callback(node) && this.iterate(node.right, callback);
  }
  getNodeContent(node) {
    if (node === SENTINEL2) {
      return "";
    }
    let buffer4 = this._buffers[node.piece.bufferIndex];
    let currentContent;
    let piece = node.piece;
    let startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
    let endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
    currentContent = buffer4.buffer.substring(startOffset, endOffset);
    return currentContent;
  }
  getPieceContent(piece) {
    let buffer4 = this._buffers[piece.bufferIndex];
    let startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
    let endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
    let currentContent = buffer4.buffer.substring(startOffset, endOffset);
    return currentContent;
  }
  rbInsertRight(node, p) {
    let z = new TreeNode(p, 1);
    z.left = SENTINEL2;
    z.right = SENTINEL2;
    z.parent = SENTINEL2;
    z.size_left = 0;
    z.lf_left = 0;
    let x = this.root;
    if (x === SENTINEL2) {
      this.root = z;
      z.color = 0;
    } else if (node.right === SENTINEL2) {
      node.right = z;
      z.parent = node;
    } else {
      let nextNode = leftest2(node.right);
      nextNode.left = z;
      z.parent = nextNode;
    }
    fixInsert(this, z);
    return z;
  }
  rbInsertLeft(node, p) {
    let z = new TreeNode(p, 1);
    z.left = SENTINEL2;
    z.right = SENTINEL2;
    z.parent = SENTINEL2;
    z.size_left = 0;
    z.lf_left = 0;
    if (this.root === SENTINEL2) {
      this.root = z;
      z.color = 0;
    } else if (node.left === SENTINEL2) {
      node.left = z;
      z.parent = node;
    } else {
      let prevNode = righttest(node.left);
      prevNode.right = z;
      z.parent = prevNode;
    }
    fixInsert(this, z);
    return z;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/tokensStore.js
function countEOL(text) {
  let eolCount = 0;
  let firstLineLength = 0;
  let lastLineStart = 0;
  let eol = 0;
  for (let i = 0, len = text.length; i < len; i++) {
    const chr = text.charCodeAt(i);
    if (chr === 13) {
      if (eolCount === 0) {
        firstLineLength = i;
      }
      eolCount++;
      if (i + 1 < len && text.charCodeAt(i + 1) === 10) {
        eol |= 2;
        i++;
      } else {
        eol |= 3;
      }
      lastLineStart = i + 1;
    } else if (chr === 10) {
      eol |= 1;
      if (eolCount === 0) {
        firstLineLength = i;
      }
      eolCount++;
      lastLineStart = i + 1;
    }
  }
  if (eolCount === 0) {
    firstLineLength = text.length;
  }
  return [eolCount, firstLineLength, text.length - lastLineStart, eol];
}
function getDefaultMetadata(topLevelLanguageId) {
  return (topLevelLanguageId << 0 | 0 << 8 | 0 << 11 | 1 << 14 | 2 << 23) >>> 0;
}
var EMPTY_LINE_TOKENS = new Uint32Array(0).buffer;
var MultilineTokensBuilder = class {
  constructor() {
    this.tokens = [];
  }
  add(lineNumber, lineTokens) {
    if (this.tokens.length > 0) {
      const last = this.tokens[this.tokens.length - 1];
      const lastLineNumber = last.startLineNumber + last.tokens.length - 1;
      if (lastLineNumber + 1 === lineNumber) {
        last.tokens.push(lineTokens);
        return;
      }
    }
    this.tokens.push(new MultilineTokens(lineNumber, [lineTokens]));
  }
};
var SparseEncodedTokens = class {
  constructor(tokens) {
    this._tokens = tokens;
    this._tokenCount = tokens.length / 4;
  }
  toString(startLineNumber) {
    let pieces = [];
    for (let i = 0; i < this._tokenCount; i++) {
      pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);
    }
    return `[${pieces.join(",")}]`;
  }
  getMaxDeltaLine() {
    const tokenCount = this._getTokenCount();
    if (tokenCount === 0) {
      return -1;
    }
    return this._getDeltaLine(tokenCount - 1);
  }
  getRange() {
    const tokenCount = this._getTokenCount();
    if (tokenCount === 0) {
      return null;
    }
    const startChar = this._getStartCharacter(0);
    const maxDeltaLine = this._getDeltaLine(tokenCount - 1);
    const endChar = this._getEndCharacter(tokenCount - 1);
    return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);
  }
  _getTokenCount() {
    return this._tokenCount;
  }
  _getDeltaLine(tokenIndex) {
    return this._tokens[4 * tokenIndex];
  }
  _getStartCharacter(tokenIndex) {
    return this._tokens[4 * tokenIndex + 1];
  }
  _getEndCharacter(tokenIndex) {
    return this._tokens[4 * tokenIndex + 2];
  }
  isEmpty() {
    return this._getTokenCount() === 0;
  }
  getLineTokens(deltaLine) {
    let low = 0;
    let high = this._getTokenCount() - 1;
    while (low < high) {
      const mid = low + Math.floor((high - low) / 2);
      const midDeltaLine = this._getDeltaLine(mid);
      if (midDeltaLine < deltaLine) {
        low = mid + 1;
      } else if (midDeltaLine > deltaLine) {
        high = mid - 1;
      } else {
        let min = mid;
        while (min > low && this._getDeltaLine(min - 1) === deltaLine) {
          min--;
        }
        let max = mid;
        while (max < high && this._getDeltaLine(max + 1) === deltaLine) {
          max++;
        }
        return new LineTokens2(this._tokens.subarray(4 * min, 4 * max + 4));
      }
    }
    if (this._getDeltaLine(low) === deltaLine) {
      return new LineTokens2(this._tokens.subarray(4 * low, 4 * low + 4));
    }
    return null;
  }
  clear() {
    this._tokenCount = 0;
  }
  removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {
    const tokens = this._tokens;
    const tokenCount = this._tokenCount;
    let newTokenCount = 0;
    let hasDeletedTokens = false;
    let firstDeltaLine = 0;
    for (let i = 0; i < tokenCount; i++) {
      const srcOffset = 4 * i;
      const tokenDeltaLine = tokens[srcOffset];
      const tokenStartCharacter = tokens[srcOffset + 1];
      const tokenEndCharacter = tokens[srcOffset + 2];
      const tokenMetadata = tokens[srcOffset + 3];
      if ((tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) && (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar)) {
        hasDeletedTokens = true;
      } else {
        if (newTokenCount === 0) {
          firstDeltaLine = tokenDeltaLine;
        }
        if (hasDeletedTokens) {
          const destOffset = 4 * newTokenCount;
          tokens[destOffset] = tokenDeltaLine - firstDeltaLine;
          tokens[destOffset + 1] = tokenStartCharacter;
          tokens[destOffset + 2] = tokenEndCharacter;
          tokens[destOffset + 3] = tokenMetadata;
        }
        newTokenCount++;
      }
    }
    this._tokenCount = newTokenCount;
    return firstDeltaLine;
  }
  split(startDeltaLine, startChar, endDeltaLine, endChar) {
    const tokens = this._tokens;
    const tokenCount = this._tokenCount;
    let aTokens = [];
    let bTokens = [];
    let destTokens = aTokens;
    let destOffset = 0;
    let destFirstDeltaLine = 0;
    for (let i = 0; i < tokenCount; i++) {
      const srcOffset = 4 * i;
      const tokenDeltaLine = tokens[srcOffset];
      const tokenStartCharacter = tokens[srcOffset + 1];
      const tokenEndCharacter = tokens[srcOffset + 2];
      const tokenMetadata = tokens[srcOffset + 3];
      if (tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) {
        if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar) {
          continue;
        } else {
          if (destTokens !== bTokens) {
            destTokens = bTokens;
            destOffset = 0;
            destFirstDeltaLine = tokenDeltaLine;
          }
        }
      }
      destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;
      destTokens[destOffset++] = tokenStartCharacter;
      destTokens[destOffset++] = tokenEndCharacter;
      destTokens[destOffset++] = tokenMetadata;
    }
    return [new SparseEncodedTokens(new Uint32Array(aTokens)), new SparseEncodedTokens(new Uint32Array(bTokens)), destFirstDeltaLine];
  }
  acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {
    const tokens = this._tokens;
    const tokenCount = this._tokenCount;
    const deletedLineCount = endDeltaLine - startDeltaLine;
    let newTokenCount = 0;
    let hasDeletedTokens = false;
    for (let i = 0; i < tokenCount; i++) {
      const srcOffset = 4 * i;
      let tokenDeltaLine = tokens[srcOffset];
      let tokenStartCharacter = tokens[srcOffset + 1];
      let tokenEndCharacter = tokens[srcOffset + 2];
      const tokenMetadata = tokens[srcOffset + 3];
      if (tokenDeltaLine < startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter) {
        newTokenCount++;
        continue;
      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {
        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {
          tokenEndCharacter -= endCharacter - startCharacter;
        } else {
          tokenEndCharacter = startCharacter;
        }
      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {
        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {
          tokenEndCharacter -= endCharacter - startCharacter;
        } else {
          hasDeletedTokens = true;
          continue;
        }
      } else if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter) {
        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {
          if (tokenDeltaLine === startDeltaLine) {
            tokenStartCharacter = startCharacter;
            tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);
          } else {
            tokenStartCharacter = 0;
            tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);
          }
        } else {
          hasDeletedTokens = true;
          continue;
        }
      } else if (tokenDeltaLine > endDeltaLine) {
        if (deletedLineCount === 0 && !hasDeletedTokens) {
          newTokenCount = tokenCount;
          break;
        }
        tokenDeltaLine -= deletedLineCount;
      } else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {
        if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {
          tokenStartCharacter += horizontalShiftForFirstLineTokens;
          tokenEndCharacter += horizontalShiftForFirstLineTokens;
        }
        tokenDeltaLine -= deletedLineCount;
        tokenStartCharacter -= endCharacter - startCharacter;
        tokenEndCharacter -= endCharacter - startCharacter;
      } else {
        throw new Error(`Not possible!`);
      }
      const destOffset = 4 * newTokenCount;
      tokens[destOffset] = tokenDeltaLine;
      tokens[destOffset + 1] = tokenStartCharacter;
      tokens[destOffset + 2] = tokenEndCharacter;
      tokens[destOffset + 3] = tokenMetadata;
      newTokenCount++;
    }
    this._tokenCount = newTokenCount;
  }
  acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {
    const isInsertingPreciselyOneWordCharacter = eolCount === 0 && firstLineLength === 1 && (firstCharCode >= 48 && firstCharCode <= 57 || firstCharCode >= 65 && firstCharCode <= 90 || firstCharCode >= 97 && firstCharCode <= 122);
    const tokens = this._tokens;
    const tokenCount = this._tokenCount;
    for (let i = 0; i < tokenCount; i++) {
      const offset = 4 * i;
      let tokenDeltaLine = tokens[offset];
      let tokenStartCharacter = tokens[offset + 1];
      let tokenEndCharacter = tokens[offset + 2];
      if (tokenDeltaLine < deltaLine || tokenDeltaLine === deltaLine && tokenEndCharacter < character) {
        continue;
      } else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {
        if (isInsertingPreciselyOneWordCharacter) {
          tokenEndCharacter += 1;
        } else {
          continue;
        }
      } else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {
        if (eolCount === 0) {
          tokenEndCharacter += firstLineLength;
        } else {
          tokenEndCharacter = character;
        }
      } else {
        if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {
          if (isInsertingPreciselyOneWordCharacter) {
            continue;
          }
        }
        if (tokenDeltaLine === deltaLine) {
          tokenDeltaLine += eolCount;
          if (eolCount === 0) {
            tokenStartCharacter += firstLineLength;
            tokenEndCharacter += firstLineLength;
          } else {
            const tokenLength = tokenEndCharacter - tokenStartCharacter;
            tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);
            tokenEndCharacter = tokenStartCharacter + tokenLength;
          }
        } else {
          tokenDeltaLine += eolCount;
        }
      }
      tokens[offset] = tokenDeltaLine;
      tokens[offset + 1] = tokenStartCharacter;
      tokens[offset + 2] = tokenEndCharacter;
    }
  }
};
var LineTokens2 = class {
  constructor(tokens) {
    this._tokens = tokens;
  }
  getCount() {
    return this._tokens.length / 4;
  }
  getStartCharacter(tokenIndex) {
    return this._tokens[4 * tokenIndex + 1];
  }
  getEndCharacter(tokenIndex) {
    return this._tokens[4 * tokenIndex + 2];
  }
  getMetadata(tokenIndex) {
    return this._tokens[4 * tokenIndex + 3];
  }
};
var MultilineTokens2 = class {
  constructor(startLineNumber, tokens) {
    this.startLineNumber = startLineNumber;
    this.tokens = tokens;
    this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();
  }
  toString() {
    return this.tokens.toString(this.startLineNumber);
  }
  _updateEndLineNumber() {
    this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();
  }
  isEmpty() {
    return this.tokens.isEmpty();
  }
  getLineTokens(lineNumber) {
    if (this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber) {
      return this.tokens.getLineTokens(lineNumber - this.startLineNumber);
    }
    return null;
  }
  getRange() {
    const deltaRange = this.tokens.getRange();
    if (!deltaRange) {
      return deltaRange;
    }
    return new Range(this.startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this.startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);
  }
  removeTokens(range2) {
    const startLineIndex = range2.startLineNumber - this.startLineNumber;
    const endLineIndex = range2.endLineNumber - this.startLineNumber;
    this.startLineNumber += this.tokens.removeTokens(startLineIndex, range2.startColumn - 1, endLineIndex, range2.endColumn - 1);
    this._updateEndLineNumber();
  }
  split(range2) {
    const startLineIndex = range2.startLineNumber - this.startLineNumber;
    const endLineIndex = range2.endLineNumber - this.startLineNumber;
    const [a, b, bDeltaLine] = this.tokens.split(startLineIndex, range2.startColumn - 1, endLineIndex, range2.endColumn - 1);
    return [new MultilineTokens2(this.startLineNumber, a), new MultilineTokens2(this.startLineNumber + bDeltaLine, b)];
  }
  applyEdit(range2, text) {
    const [eolCount, firstLineLength, lastLineLength] = countEOL(text);
    this.acceptEdit(range2, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0);
  }
  acceptEdit(range2, eolCount, firstLineLength, lastLineLength, firstCharCode) {
    this._acceptDeleteRange(range2);
    this._acceptInsertText(new Position(range2.startLineNumber, range2.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);
    this._updateEndLineNumber();
  }
  _acceptDeleteRange(range2) {
    if (range2.startLineNumber === range2.endLineNumber && range2.startColumn === range2.endColumn) {
      return;
    }
    const firstLineIndex = range2.startLineNumber - this.startLineNumber;
    const lastLineIndex = range2.endLineNumber - this.startLineNumber;
    if (lastLineIndex < 0) {
      const deletedLinesCount = lastLineIndex - firstLineIndex;
      this.startLineNumber -= deletedLinesCount;
      return;
    }
    const tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();
    if (firstLineIndex >= tokenMaxDeltaLine + 1) {
      return;
    }
    if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {
      this.startLineNumber = 0;
      this.tokens.clear();
      return;
    }
    if (firstLineIndex < 0) {
      const deletedBefore = -firstLineIndex;
      this.startLineNumber -= deletedBefore;
      this.tokens.acceptDeleteRange(range2.startColumn - 1, 0, 0, lastLineIndex, range2.endColumn - 1);
    } else {
      this.tokens.acceptDeleteRange(0, firstLineIndex, range2.startColumn - 1, lastLineIndex, range2.endColumn - 1);
    }
  }
  _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {
    if (eolCount === 0 && firstLineLength === 0) {
      return;
    }
    const lineIndex = position.lineNumber - this.startLineNumber;
    if (lineIndex < 0) {
      this.startLineNumber += eolCount;
      return;
    }
    const tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();
    if (lineIndex >= tokenMaxDeltaLine + 1) {
      return;
    }
    this.tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);
  }
};
var MultilineTokens = class {
  constructor(startLineNumber, tokens) {
    this.startLineNumber = startLineNumber;
    this.tokens = tokens;
  }
};
function toUint32Array(arr) {
  if (arr instanceof Uint32Array) {
    return arr;
  } else {
    return new Uint32Array(arr);
  }
}
var TokensStore2 = class {
  constructor() {
    this._pieces = [];
    this._isComplete = false;
  }
  flush() {
    this._pieces = [];
    this._isComplete = false;
  }
  set(pieces, isComplete) {
    this._pieces = pieces || [];
    this._isComplete = isComplete;
  }
  setPartial(_range, pieces) {
    let range2 = _range;
    if (pieces.length > 0) {
      const _firstRange = pieces[0].getRange();
      const _lastRange = pieces[pieces.length - 1].getRange();
      if (!_firstRange || !_lastRange) {
        return _range;
      }
      range2 = _range.plusRange(_firstRange).plusRange(_lastRange);
    }
    let insertPosition = null;
    for (let i = 0, len = this._pieces.length; i < len; i++) {
      const piece = this._pieces[i];
      if (piece.endLineNumber < range2.startLineNumber) {
        continue;
      }
      if (piece.startLineNumber > range2.endLineNumber) {
        insertPosition = insertPosition || {index: i};
        break;
      }
      piece.removeTokens(range2);
      if (piece.isEmpty()) {
        this._pieces.splice(i, 1);
        i--;
        len--;
        continue;
      }
      if (piece.endLineNumber < range2.startLineNumber) {
        continue;
      }
      if (piece.startLineNumber > range2.endLineNumber) {
        insertPosition = insertPosition || {index: i};
        continue;
      }
      const [a, b] = piece.split(range2);
      if (a.isEmpty()) {
        insertPosition = insertPosition || {index: i};
        continue;
      }
      if (b.isEmpty()) {
        continue;
      }
      this._pieces.splice(i, 1, a, b);
      i++;
      len++;
      insertPosition = insertPosition || {index: i};
    }
    insertPosition = insertPosition || {index: this._pieces.length};
    if (pieces.length > 0) {
      this._pieces = arrayInsert(this._pieces, insertPosition.index, pieces);
    }
    return range2;
  }
  isComplete() {
    return this._isComplete;
  }
  addSemanticTokens(lineNumber, aTokens) {
    const pieces = this._pieces;
    if (pieces.length === 0) {
      return aTokens;
    }
    const pieceIndex = TokensStore2._findFirstPieceWithLine(pieces, lineNumber);
    const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);
    if (!bTokens) {
      return aTokens;
    }
    const aLen = aTokens.getCount();
    const bLen = bTokens.getCount();
    let aIndex = 0;
    let result = [], resultLen = 0;
    let lastEndOffset = 0;
    const emitToken = (endOffset, metadata) => {
      if (endOffset === lastEndOffset) {
        return;
      }
      lastEndOffset = endOffset;
      result[resultLen++] = endOffset;
      result[resultLen++] = metadata;
    };
    for (let bIndex = 0; bIndex < bLen; bIndex++) {
      const bStartCharacter = bTokens.getStartCharacter(bIndex);
      const bEndCharacter = bTokens.getEndCharacter(bIndex);
      const bMetadata = bTokens.getMetadata(bIndex);
      const bMask = ((bMetadata & 1 ? 2048 : 0) | (bMetadata & 2 ? 4096 : 0) | (bMetadata & 4 ? 8192 : 0) | (bMetadata & 8 ? 8372224 : 0) | (bMetadata & 16 ? 4286578688 : 0)) >>> 0;
      const aMask = ~bMask >>> 0;
      while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {
        emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));
        aIndex++;
      }
      if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {
        emitToken(bStartCharacter, aTokens.getMetadata(aIndex));
      }
      while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {
        emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);
        aIndex++;
      }
      if (aIndex < aLen) {
        emitToken(bEndCharacter, aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);
        if (aTokens.getEndOffset(aIndex) === bEndCharacter) {
          aIndex++;
        }
      } else {
        const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);
        emitToken(bEndCharacter, aTokens.getMetadata(aMergeIndex) & aMask | bMetadata & bMask);
      }
    }
    while (aIndex < aLen) {
      emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));
      aIndex++;
    }
    return new LineTokens(new Uint32Array(result), aTokens.getLineContent());
  }
  static _findFirstPieceWithLine(pieces, lineNumber) {
    let low = 0;
    let high = pieces.length - 1;
    while (low < high) {
      let mid = low + Math.floor((high - low) / 2);
      if (pieces[mid].endLineNumber < lineNumber) {
        low = mid + 1;
      } else if (pieces[mid].startLineNumber > lineNumber) {
        high = mid - 1;
      } else {
        while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {
          mid--;
        }
        return mid;
      }
    }
    return low;
  }
  acceptEdit(range2, eolCount, firstLineLength, lastLineLength, firstCharCode) {
    for (const piece of this._pieces) {
      piece.acceptEdit(range2, eolCount, firstLineLength, lastLineLength, firstCharCode);
    }
  }
};
var TokensStore = class {
  constructor() {
    this._lineTokens = [];
    this._len = 0;
  }
  flush() {
    this._lineTokens = [];
    this._len = 0;
  }
  getTokens(topLevelLanguageId, lineIndex, lineText) {
    let rawLineTokens = null;
    if (lineIndex < this._len) {
      rawLineTokens = this._lineTokens[lineIndex];
    }
    if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {
      return new LineTokens(toUint32Array(rawLineTokens), lineText);
    }
    let lineTokens = new Uint32Array(2);
    lineTokens[0] = lineText.length;
    lineTokens[1] = getDefaultMetadata(topLevelLanguageId);
    return new LineTokens(lineTokens, lineText);
  }
  static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {
    const tokens = _tokens ? toUint32Array(_tokens) : null;
    if (lineTextLength === 0) {
      let hasDifferentLanguageId = false;
      if (tokens && tokens.length > 1) {
        hasDifferentLanguageId = TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId;
      }
      if (!hasDifferentLanguageId) {
        return EMPTY_LINE_TOKENS;
      }
    }
    if (!tokens || tokens.length === 0) {
      const tokens2 = new Uint32Array(2);
      tokens2[0] = lineTextLength;
      tokens2[1] = getDefaultMetadata(topLevelLanguageId);
      return tokens2.buffer;
    }
    tokens[tokens.length - 2] = lineTextLength;
    if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {
      return tokens.buffer;
    }
    return tokens;
  }
  _ensureLine(lineIndex) {
    while (lineIndex >= this._len) {
      this._lineTokens[this._len] = null;
      this._len++;
    }
  }
  _deleteLines(start, deleteCount) {
    if (deleteCount === 0) {
      return;
    }
    if (start + deleteCount > this._len) {
      deleteCount = this._len - start;
    }
    this._lineTokens.splice(start, deleteCount);
    this._len -= deleteCount;
  }
  _insertLines(insertIndex, insertCount) {
    if (insertCount === 0) {
      return;
    }
    let lineTokens = [];
    for (let i = 0; i < insertCount; i++) {
      lineTokens[i] = null;
    }
    this._lineTokens = arrayInsert(this._lineTokens, insertIndex, lineTokens);
    this._len += insertCount;
  }
  setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {
    const tokens = TokensStore._massageTokens(topLevelLanguageId, lineTextLength, _tokens);
    this._ensureLine(lineIndex);
    const oldTokens = this._lineTokens[lineIndex];
    this._lineTokens[lineIndex] = tokens;
    if (checkEquality) {
      return !TokensStore._equals(oldTokens, tokens);
    }
    return false;
  }
  static _equals(_a, _b) {
    if (!_a || !_b) {
      return !_a && !_b;
    }
    const a = toUint32Array(_a);
    const b = toUint32Array(_b);
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0, len = a.length; i < len; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  acceptEdit(range2, eolCount, firstLineLength) {
    this._acceptDeleteRange(range2);
    this._acceptInsertText(new Position(range2.startLineNumber, range2.startColumn), eolCount, firstLineLength);
  }
  _acceptDeleteRange(range2) {
    const firstLineIndex = range2.startLineNumber - 1;
    if (firstLineIndex >= this._len) {
      return;
    }
    if (range2.startLineNumber === range2.endLineNumber) {
      if (range2.startColumn === range2.endColumn) {
        return;
      }
      this._lineTokens[firstLineIndex] = TokensStore._delete(this._lineTokens[firstLineIndex], range2.startColumn - 1, range2.endColumn - 1);
      return;
    }
    this._lineTokens[firstLineIndex] = TokensStore._deleteEnding(this._lineTokens[firstLineIndex], range2.startColumn - 1);
    const lastLineIndex = range2.endLineNumber - 1;
    let lastLineTokens = null;
    if (lastLineIndex < this._len) {
      lastLineTokens = TokensStore._deleteBeginning(this._lineTokens[lastLineIndex], range2.endColumn - 1);
    }
    this._lineTokens[firstLineIndex] = TokensStore._append(this._lineTokens[firstLineIndex], lastLineTokens);
    this._deleteLines(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
  }
  _acceptInsertText(position, eolCount, firstLineLength) {
    if (eolCount === 0 && firstLineLength === 0) {
      return;
    }
    const lineIndex = position.lineNumber - 1;
    if (lineIndex >= this._len) {
      return;
    }
    if (eolCount === 0) {
      this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);
      return;
    }
    this._lineTokens[lineIndex] = TokensStore._deleteEnding(this._lineTokens[lineIndex], position.column - 1);
    this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);
    this._insertLines(position.lineNumber, eolCount);
  }
  static _deleteBeginning(lineTokens, toChIndex) {
    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
      return lineTokens;
    }
    return TokensStore._delete(lineTokens, 0, toChIndex);
  }
  static _deleteEnding(lineTokens, fromChIndex) {
    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
      return lineTokens;
    }
    const tokens = toUint32Array(lineTokens);
    const lineTextLength = tokens[tokens.length - 2];
    return TokensStore._delete(lineTokens, fromChIndex, lineTextLength);
  }
  static _delete(lineTokens, fromChIndex, toChIndex) {
    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {
      return lineTokens;
    }
    const tokens = toUint32Array(lineTokens);
    const tokensCount = tokens.length >>> 1;
    if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {
      return EMPTY_LINE_TOKENS;
    }
    const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);
    const fromTokenStartOffset = fromTokenIndex > 0 ? tokens[fromTokenIndex - 1 << 1] : 0;
    const fromTokenEndOffset = tokens[fromTokenIndex << 1];
    if (toChIndex < fromTokenEndOffset) {
      const delta2 = toChIndex - fromChIndex;
      for (let i = fromTokenIndex; i < tokensCount; i++) {
        tokens[i << 1] -= delta2;
      }
      return lineTokens;
    }
    let dest;
    let lastEnd;
    if (fromTokenStartOffset !== fromChIndex) {
      tokens[fromTokenIndex << 1] = fromChIndex;
      dest = fromTokenIndex + 1 << 1;
      lastEnd = fromChIndex;
    } else {
      dest = fromTokenIndex << 1;
      lastEnd = fromTokenStartOffset;
    }
    const delta = toChIndex - fromChIndex;
    for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {
      const tokenEndOffset = tokens[tokenIndex << 1] - delta;
      if (tokenEndOffset > lastEnd) {
        tokens[dest++] = tokenEndOffset;
        tokens[dest++] = tokens[(tokenIndex << 1) + 1];
        lastEnd = tokenEndOffset;
      }
    }
    if (dest === tokens.length) {
      return lineTokens;
    }
    let tmp = new Uint32Array(dest);
    tmp.set(tokens.subarray(0, dest), 0);
    return tmp.buffer;
  }
  static _append(lineTokens, _otherTokens) {
    if (_otherTokens === EMPTY_LINE_TOKENS) {
      return lineTokens;
    }
    if (lineTokens === EMPTY_LINE_TOKENS) {
      return _otherTokens;
    }
    if (lineTokens === null) {
      return lineTokens;
    }
    if (_otherTokens === null) {
      return null;
    }
    const myTokens = toUint32Array(lineTokens);
    const otherTokens = toUint32Array(_otherTokens);
    const otherTokensCount = otherTokens.length >>> 1;
    let result = new Uint32Array(myTokens.length + otherTokens.length);
    result.set(myTokens, 0);
    let dest = myTokens.length;
    const delta = myTokens[myTokens.length - 2];
    for (let i = 0; i < otherTokensCount; i++) {
      result[dest++] = otherTokens[i << 1] + delta;
      result[dest++] = otherTokens[(i << 1) + 1];
    }
    return result.buffer;
  }
  static _insert(lineTokens, chIndex, textLength) {
    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
      return lineTokens;
    }
    const tokens = toUint32Array(lineTokens);
    const tokensCount = tokens.length >>> 1;
    let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);
    if (fromTokenIndex > 0) {
      const fromTokenStartOffset = tokens[fromTokenIndex - 1 << 1];
      if (fromTokenStartOffset === chIndex) {
        fromTokenIndex--;
      }
    }
    for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {
      tokens[tokenIndex << 1] += textLength;
    }
    return lineTokens;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js
var PieceTreeTextBuffer = class {
  constructor(chunks, BOM, eol, containsRTL2, containsUnusualLineTerminators2, isBasicASCII2, eolNormalized) {
    this._onDidChangeContent = new Emitter();
    this._BOM = BOM;
    this._mightContainNonBasicASCII = !isBasicASCII2;
    this._mightContainRTL = containsRTL2;
    this._mightContainUnusualLineTerminators = containsUnusualLineTerminators2;
    this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);
  }
  dispose() {
    this._onDidChangeContent.dispose();
  }
  mightContainRTL() {
    return this._mightContainRTL;
  }
  mightContainUnusualLineTerminators() {
    return this._mightContainUnusualLineTerminators;
  }
  resetMightContainUnusualLineTerminators() {
    this._mightContainUnusualLineTerminators = false;
  }
  mightContainNonBasicASCII() {
    return this._mightContainNonBasicASCII;
  }
  getBOM() {
    return this._BOM;
  }
  getEOL() {
    return this._pieceTree.getEOL();
  }
  createSnapshot(preserveBOM) {
    return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : "");
  }
  getOffsetAt(lineNumber, column) {
    return this._pieceTree.getOffsetAt(lineNumber, column);
  }
  getPositionAt(offset) {
    return this._pieceTree.getPositionAt(offset);
  }
  getRangeAt(start, length) {
    let end = start + length;
    const startPosition = this.getPositionAt(start);
    const endPosition = this.getPositionAt(end);
    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
  }
  getValueInRange(range2, eol = 0) {
    if (range2.isEmpty()) {
      return "";
    }
    const lineEnding = this._getEndOfLine(eol);
    return this._pieceTree.getValueInRange(range2, lineEnding);
  }
  getValueLengthInRange(range2, eol = 0) {
    if (range2.isEmpty()) {
      return 0;
    }
    if (range2.startLineNumber === range2.endLineNumber) {
      return range2.endColumn - range2.startColumn;
    }
    let startOffset = this.getOffsetAt(range2.startLineNumber, range2.startColumn);
    let endOffset = this.getOffsetAt(range2.endLineNumber, range2.endColumn);
    return endOffset - startOffset;
  }
  getCharacterCountInRange(range2, eol = 0) {
    if (this._mightContainNonBasicASCII) {
      let result = 0;
      const fromLineNumber = range2.startLineNumber;
      const toLineNumber = range2.endLineNumber;
      for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
        const lineContent = this.getLineContent(lineNumber);
        const fromOffset = lineNumber === fromLineNumber ? range2.startColumn - 1 : 0;
        const toOffset = lineNumber === toLineNumber ? range2.endColumn - 1 : lineContent.length;
        for (let offset = fromOffset; offset < toOffset; offset++) {
          if (isHighSurrogate(lineContent.charCodeAt(offset))) {
            result = result + 1;
            offset = offset + 1;
          } else {
            result = result + 1;
          }
        }
      }
      result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);
      return result;
    }
    return this.getValueLengthInRange(range2, eol);
  }
  getLength() {
    return this._pieceTree.getLength();
  }
  getLineCount() {
    return this._pieceTree.getLineCount();
  }
  getLinesContent() {
    return this._pieceTree.getLinesContent();
  }
  getLineContent(lineNumber) {
    return this._pieceTree.getLineContent(lineNumber);
  }
  getLineCharCode(lineNumber, index) {
    return this._pieceTree.getLineCharCode(lineNumber, index);
  }
  getLineLength(lineNumber) {
    return this._pieceTree.getLineLength(lineNumber);
  }
  getLineFirstNonWhitespaceColumn(lineNumber) {
    const result = firstNonWhitespaceIndex(this.getLineContent(lineNumber));
    if (result === -1) {
      return 0;
    }
    return result + 1;
  }
  getLineLastNonWhitespaceColumn(lineNumber) {
    const result = lastNonWhitespaceIndex(this.getLineContent(lineNumber));
    if (result === -1) {
      return 0;
    }
    return result + 2;
  }
  _getEndOfLine(eol) {
    switch (eol) {
      case 1:
        return "\n";
      case 2:
        return "\r\n";
      case 0:
        return this.getEOL();
      default:
        throw new Error("Unknown EOL preference");
    }
  }
  setEOL(newEOL) {
    this._pieceTree.setEOL(newEOL);
  }
  applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {
    let mightContainRTL = this._mightContainRTL;
    let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;
    let mightContainNonBasicASCII = this._mightContainNonBasicASCII;
    let canReduceOperations = true;
    let operations = [];
    for (let i = 0; i < rawOperations.length; i++) {
      let op = rawOperations[i];
      if (canReduceOperations && op._isTracked) {
        canReduceOperations = false;
      }
      let validatedRange = op.range;
      if (op.text) {
        let textMightContainNonBasicASCII = true;
        if (!mightContainNonBasicASCII) {
          textMightContainNonBasicASCII = !isBasicASCII(op.text);
          mightContainNonBasicASCII = textMightContainNonBasicASCII;
        }
        if (!mightContainRTL && textMightContainNonBasicASCII) {
          mightContainRTL = containsRTL(op.text);
        }
        if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {
          mightContainUnusualLineTerminators = containsUnusualLineTerminators(op.text);
        }
      }
      let validText = "";
      let eolCount = 0;
      let firstLineLength = 0;
      let lastLineLength = 0;
      if (op.text) {
        let strEOL;
        [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);
        const bufferEOL = this.getEOL();
        const expectedStrEOL = bufferEOL === "\r\n" ? 2 : 1;
        if (strEOL === 0 || strEOL === expectedStrEOL) {
          validText = op.text;
        } else {
          validText = op.text.replace(/\r\n|\r|\n/g, bufferEOL);
        }
      }
      operations[i] = {
        sortIndex: i,
        identifier: op.identifier || null,
        range: validatedRange,
        rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),
        rangeLength: this.getValueLengthInRange(validatedRange),
        text: validText,
        eolCount,
        firstLineLength,
        lastLineLength,
        forceMoveMarkers: Boolean(op.forceMoveMarkers),
        isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false
      };
    }
    operations.sort(PieceTreeTextBuffer._sortOpsAscending);
    let hasTouchingRanges = false;
    for (let i = 0, count = operations.length - 1; i < count; i++) {
      let rangeEnd = operations[i].range.getEndPosition();
      let nextRangeStart = operations[i + 1].range.getStartPosition();
      if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {
        if (nextRangeStart.isBefore(rangeEnd)) {
          throw new Error("Overlapping ranges are not allowed!");
        }
        hasTouchingRanges = true;
      }
    }
    if (canReduceOperations) {
      operations = this._reduceOperations(operations);
    }
    let reverseRanges = computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : [];
    let newTrimAutoWhitespaceCandidates = [];
    if (recordTrimAutoWhitespace) {
      for (let i = 0; i < operations.length; i++) {
        let op = operations[i];
        let reverseRange = reverseRanges[i];
        if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {
          for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {
            let currentLineContent = "";
            if (lineNumber === reverseRange.startLineNumber) {
              currentLineContent = this.getLineContent(op.range.startLineNumber);
              if (firstNonWhitespaceIndex(currentLineContent) !== -1) {
                continue;
              }
            }
            newTrimAutoWhitespaceCandidates.push({lineNumber, oldContent: currentLineContent});
          }
        }
      }
    }
    let reverseOperations = null;
    if (computeUndoEdits) {
      let reverseRangeDeltaOffset = 0;
      reverseOperations = [];
      for (let i = 0; i < operations.length; i++) {
        const op = operations[i];
        const reverseRange = reverseRanges[i];
        const bufferText = this.getValueInRange(op.range);
        const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;
        reverseRangeDeltaOffset += op.text.length - bufferText.length;
        reverseOperations[i] = {
          sortIndex: op.sortIndex,
          identifier: op.identifier,
          range: reverseRange,
          text: bufferText,
          textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)
        };
      }
      if (!hasTouchingRanges) {
        reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);
      }
    }
    this._mightContainRTL = mightContainRTL;
    this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;
    this._mightContainNonBasicASCII = mightContainNonBasicASCII;
    const contentChanges = this._doApplyEdits(operations);
    let trimAutoWhitespaceLineNumbers = null;
    if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {
      newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);
      trimAutoWhitespaceLineNumbers = [];
      for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {
        let lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;
        if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {
          continue;
        }
        let prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;
        let lineContent = this.getLineContent(lineNumber);
        if (lineContent.length === 0 || lineContent === prevContent || firstNonWhitespaceIndex(lineContent) !== -1) {
          continue;
        }
        trimAutoWhitespaceLineNumbers.push(lineNumber);
      }
    }
    this._onDidChangeContent.fire();
    return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);
  }
  _reduceOperations(operations) {
    if (operations.length < 1e3) {
      return operations;
    }
    return [this._toSingleEditOperation(operations)];
  }
  _toSingleEditOperation(operations) {
    let forceMoveMarkers = false;
    const firstEditRange = operations[0].range;
    const lastEditRange = operations[operations.length - 1].range;
    const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);
    let lastEndLineNumber = firstEditRange.startLineNumber;
    let lastEndColumn = firstEditRange.startColumn;
    const result = [];
    for (let i = 0, len = operations.length; i < len; i++) {
      const operation = operations[i];
      const range2 = operation.range;
      forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;
      result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range2.startLineNumber, range2.startColumn)));
      if (operation.text.length > 0) {
        result.push(operation.text);
      }
      lastEndLineNumber = range2.endLineNumber;
      lastEndColumn = range2.endColumn;
    }
    const text = result.join("");
    const [eolCount, firstLineLength, lastLineLength] = countEOL(text);
    return {
      sortIndex: 0,
      identifier: operations[0].identifier,
      range: entireEditRange,
      rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),
      rangeLength: this.getValueLengthInRange(entireEditRange, 0),
      text,
      eolCount,
      firstLineLength,
      lastLineLength,
      forceMoveMarkers,
      isAutoWhitespaceEdit: false
    };
  }
  _doApplyEdits(operations) {
    operations.sort(PieceTreeTextBuffer._sortOpsDescending);
    let contentChanges = [];
    for (let i = 0; i < operations.length; i++) {
      let op = operations[i];
      const startLineNumber = op.range.startLineNumber;
      const startColumn = op.range.startColumn;
      const endLineNumber = op.range.endLineNumber;
      const endColumn = op.range.endColumn;
      if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {
        continue;
      }
      if (op.text) {
        this._pieceTree.delete(op.rangeOffset, op.rangeLength);
        this._pieceTree.insert(op.rangeOffset, op.text, true);
      } else {
        this._pieceTree.delete(op.rangeOffset, op.rangeLength);
      }
      const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
      contentChanges.push({
        range: contentChangeRange,
        rangeLength: op.rangeLength,
        text: op.text,
        rangeOffset: op.rangeOffset,
        forceMoveMarkers: op.forceMoveMarkers
      });
    }
    return contentChanges;
  }
  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
    return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
  }
  static _getInverseEditRanges(operations) {
    let result = [];
    let prevOpEndLineNumber = 0;
    let prevOpEndColumn = 0;
    let prevOp = null;
    for (let i = 0, len = operations.length; i < len; i++) {
      let op = operations[i];
      let startLineNumber;
      let startColumn;
      if (prevOp) {
        if (prevOp.range.endLineNumber === op.range.startLineNumber) {
          startLineNumber = prevOpEndLineNumber;
          startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);
        } else {
          startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);
          startColumn = op.range.startColumn;
        }
      } else {
        startLineNumber = op.range.startLineNumber;
        startColumn = op.range.startColumn;
      }
      let resultRange;
      if (op.text.length > 0) {
        const lineCount = op.eolCount + 1;
        if (lineCount === 1) {
          resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);
        } else {
          resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);
        }
      } else {
        resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);
      }
      prevOpEndLineNumber = resultRange.endLineNumber;
      prevOpEndColumn = resultRange.endColumn;
      result.push(resultRange);
      prevOp = op;
    }
    return result;
  }
  static _sortOpsAscending(a, b) {
    let r = Range.compareRangesUsingEnds(a.range, b.range);
    if (r === 0) {
      return a.sortIndex - b.sortIndex;
    }
    return r;
  }
  static _sortOpsDescending(a, b) {
    let r = Range.compareRangesUsingEnds(a.range, b.range);
    if (r === 0) {
      return b.sortIndex - a.sortIndex;
    }
    return -r;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js
var PieceTreeTextBufferFactory = class {
  constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {
    this._chunks = _chunks;
    this._bom = _bom;
    this._cr = _cr;
    this._lf = _lf;
    this._crlf = _crlf;
    this._containsRTL = _containsRTL;
    this._containsUnusualLineTerminators = _containsUnusualLineTerminators;
    this._isBasicASCII = _isBasicASCII;
    this._normalizeEOL = _normalizeEOL;
  }
  _getEOL(defaultEOL) {
    const totalEOLCount = this._cr + this._lf + this._crlf;
    const totalCRCount = this._cr + this._crlf;
    if (totalEOLCount === 0) {
      return defaultEOL === 1 ? "\n" : "\r\n";
    }
    if (totalCRCount > totalEOLCount / 2) {
      return "\r\n";
    }
    return "\n";
  }
  create(defaultEOL) {
    const eol = this._getEOL(defaultEOL);
    let chunks = this._chunks;
    if (this._normalizeEOL && (eol === "\r\n" && (this._cr > 0 || this._lf > 0) || eol === "\n" && (this._cr > 0 || this._crlf > 0))) {
      for (let i = 0, len = chunks.length; i < len; i++) {
        let str = chunks[i].buffer.replace(/\r\n|\r|\n/g, eol);
        let newLineStart = createLineStartsFast(str);
        chunks[i] = new StringBuffer(str, newLineStart);
      }
    }
    return new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
  }
};
var PieceTreeTextBufferBuilder = class {
  constructor() {
    this.chunks = [];
    this.BOM = "";
    this._hasPreviousChar = false;
    this._previousChar = 0;
    this._tmpLineStarts = [];
    this.cr = 0;
    this.lf = 0;
    this.crlf = 0;
    this.containsRTL = false;
    this.containsUnusualLineTerminators = false;
    this.isBasicASCII = true;
  }
  acceptChunk(chunk) {
    if (chunk.length === 0) {
      return;
    }
    if (this.chunks.length === 0) {
      if (startsWithUTF8BOM(chunk)) {
        this.BOM = UTF8_BOM_CHARACTER;
        chunk = chunk.substr(1);
      }
    }
    const lastChar = chunk.charCodeAt(chunk.length - 1);
    if (lastChar === 13 || lastChar >= 55296 && lastChar <= 56319) {
      this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);
      this._hasPreviousChar = true;
      this._previousChar = lastChar;
    } else {
      this._acceptChunk1(chunk, false);
      this._hasPreviousChar = false;
      this._previousChar = lastChar;
    }
  }
  _acceptChunk1(chunk, allowEmptyStrings) {
    if (!allowEmptyStrings && chunk.length === 0) {
      return;
    }
    if (this._hasPreviousChar) {
      this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);
    } else {
      this._acceptChunk2(chunk);
    }
  }
  _acceptChunk2(chunk) {
    const lineStarts = createLineStarts(this._tmpLineStarts, chunk);
    this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));
    this.cr += lineStarts.cr;
    this.lf += lineStarts.lf;
    this.crlf += lineStarts.crlf;
    if (this.isBasicASCII) {
      this.isBasicASCII = lineStarts.isBasicASCII;
    }
    if (!this.isBasicASCII && !this.containsRTL) {
      this.containsRTL = containsRTL(chunk);
    }
    if (!this.isBasicASCII && !this.containsUnusualLineTerminators) {
      this.containsUnusualLineTerminators = containsUnusualLineTerminators(chunk);
    }
  }
  finish(normalizeEOL = true) {
    this._finish();
    return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);
  }
  _finish() {
    if (this.chunks.length === 0) {
      this._acceptChunk1("", true);
    }
    if (this._hasPreviousChar) {
      this._hasPreviousChar = false;
      let lastChunk = this.chunks[this.chunks.length - 1];
      lastChunk.buffer += String.fromCharCode(this._previousChar);
      let newLineStarts = createLineStartsFast(lastChunk.buffer);
      lastChunk.lineStarts = newLineStarts;
      if (this._previousChar === 13) {
        this.cr++;
      }
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelEvents.js
var ModelRawFlush = class {
  constructor() {
    this.changeType = 1;
  }
};
var ModelRawLineChanged = class {
  constructor(lineNumber, detail) {
    this.changeType = 2;
    this.lineNumber = lineNumber;
    this.detail = detail;
  }
};
var ModelRawLinesDeleted = class {
  constructor(fromLineNumber, toLineNumber) {
    this.changeType = 3;
    this.fromLineNumber = fromLineNumber;
    this.toLineNumber = toLineNumber;
  }
};
var ModelRawLinesInserted = class {
  constructor(fromLineNumber, toLineNumber, detail) {
    this.changeType = 4;
    this.fromLineNumber = fromLineNumber;
    this.toLineNumber = toLineNumber;
    this.detail = detail;
  }
};
var ModelRawEOLChanged = class {
  constructor() {
    this.changeType = 5;
  }
};
var ModelRawContentChangedEvent = class {
  constructor(changes, versionId, isUndoing, isRedoing) {
    this.changes = changes;
    this.versionId = versionId;
    this.isUndoing = isUndoing;
    this.isRedoing = isRedoing;
    this.resultingSelection = null;
  }
  containsEvent(type) {
    for (let i = 0, len = this.changes.length; i < len; i++) {
      const change = this.changes[i];
      if (change.changeType === type) {
        return true;
      }
    }
    return false;
  }
  static merge(a, b) {
    const changes = [].concat(a.changes).concat(b.changes);
    const versionId = b.versionId;
    const isUndoing = a.isUndoing || b.isUndoing;
    const isRedoing = a.isRedoing || b.isRedoing;
    return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);
  }
};
var InternalModelContentChangeEvent = class {
  constructor(rawContentChangedEvent, contentChangedEvent) {
    this.rawContentChangedEvent = rawContentChangedEvent;
    this.contentChangedEvent = contentChangedEvent;
  }
  merge(other) {
    const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);
    const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);
    return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);
  }
  static _mergeChangeEvents(a, b) {
    const changes = [].concat(a.changes).concat(b.changes);
    const eol = b.eol;
    const versionId = b.versionId;
    const isUndoing = a.isUndoing || b.isUndoing;
    const isRedoing = a.isRedoing || b.isRedoing;
    const isFlush = a.isFlush || b.isFlush;
    return {
      changes,
      eol,
      versionId,
      isUndoing,
      isRedoing,
      isFlush
    };
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js
var TokenizationStateStore = class {
  constructor() {
    this._beginState = [];
    this._valid = [];
    this._len = 0;
    this._invalidLineStartIndex = 0;
  }
  _reset(initialState) {
    this._beginState = [];
    this._valid = [];
    this._len = 0;
    this._invalidLineStartIndex = 0;
    if (initialState) {
      this._setBeginState(0, initialState);
    }
  }
  flush(initialState) {
    this._reset(initialState);
  }
  get invalidLineStartIndex() {
    return this._invalidLineStartIndex;
  }
  _invalidateLine(lineIndex) {
    if (lineIndex < this._len) {
      this._valid[lineIndex] = false;
    }
    if (lineIndex < this._invalidLineStartIndex) {
      this._invalidLineStartIndex = lineIndex;
    }
  }
  _isValid(lineIndex) {
    if (lineIndex < this._len) {
      return this._valid[lineIndex];
    }
    return false;
  }
  getBeginState(lineIndex) {
    if (lineIndex < this._len) {
      return this._beginState[lineIndex];
    }
    return null;
  }
  _ensureLine(lineIndex) {
    while (lineIndex >= this._len) {
      this._beginState[this._len] = null;
      this._valid[this._len] = false;
      this._len++;
    }
  }
  _deleteLines(start, deleteCount) {
    if (deleteCount === 0) {
      return;
    }
    if (start + deleteCount > this._len) {
      deleteCount = this._len - start;
    }
    this._beginState.splice(start, deleteCount);
    this._valid.splice(start, deleteCount);
    this._len -= deleteCount;
  }
  _insertLines(insertIndex, insertCount) {
    if (insertCount === 0) {
      return;
    }
    let beginState = [];
    let valid = [];
    for (let i = 0; i < insertCount; i++) {
      beginState[i] = null;
      valid[i] = false;
    }
    this._beginState = arrayInsert(this._beginState, insertIndex, beginState);
    this._valid = arrayInsert(this._valid, insertIndex, valid);
    this._len += insertCount;
  }
  _setValid(lineIndex, valid) {
    this._ensureLine(lineIndex);
    this._valid[lineIndex] = valid;
  }
  _setBeginState(lineIndex, beginState) {
    this._ensureLine(lineIndex);
    this._beginState[lineIndex] = beginState;
  }
  setEndState(linesLength, lineIndex, endState) {
    this._setValid(lineIndex, true);
    this._invalidLineStartIndex = lineIndex + 1;
    if (lineIndex === linesLength - 1) {
      return;
    }
    const previousEndState = this.getBeginState(lineIndex + 1);
    if (previousEndState === null || !endState.equals(previousEndState)) {
      this._setBeginState(lineIndex + 1, endState);
      this._invalidateLine(lineIndex + 1);
      return;
    }
    let i = lineIndex + 1;
    while (i < linesLength) {
      if (!this._isValid(i)) {
        break;
      }
      i++;
    }
    this._invalidLineStartIndex = i;
  }
  setFakeTokens(lineIndex) {
    this._setValid(lineIndex, false);
  }
  applyEdits(range2, eolCount) {
    const deletingLinesCnt = range2.endLineNumber - range2.startLineNumber;
    const insertingLinesCnt = eolCount;
    const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);
    for (let j = editingLinesCnt; j >= 0; j--) {
      this._invalidateLine(range2.startLineNumber + j - 1);
    }
    this._acceptDeleteRange(range2);
    this._acceptInsertText(new Position(range2.startLineNumber, range2.startColumn), eolCount);
  }
  _acceptDeleteRange(range2) {
    const firstLineIndex = range2.startLineNumber - 1;
    if (firstLineIndex >= this._len) {
      return;
    }
    this._deleteLines(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
  }
  _acceptInsertText(position, eolCount) {
    const lineIndex = position.lineNumber - 1;
    if (lineIndex >= this._len) {
      return;
    }
    this._insertLines(position.lineNumber, eolCount);
  }
};
var TextModelTokenization = class extends Disposable {
  constructor(textModel) {
    super();
    this._isDisposed = false;
    this._textModel = textModel;
    this._tokenizationStateStore = new TokenizationStateStore();
    this._tokenizationSupport = null;
    this._register(TokenizationRegistry.onDidChange((e) => {
      const languageIdentifier = this._textModel.getLanguageIdentifier();
      if (e.changedLanguages.indexOf(languageIdentifier.language) === -1) {
        return;
      }
      this._resetTokenizationState();
      this._textModel.clearTokens();
    }));
    this._register(this._textModel.onDidChangeRawContentFast((e) => {
      if (e.containsEvent(1)) {
        this._resetTokenizationState();
        return;
      }
    }));
    this._register(this._textModel.onDidChangeContentFast((e) => {
      for (let i = 0, len = e.changes.length; i < len; i++) {
        const change = e.changes[i];
        const [eolCount] = countEOL(change.text);
        this._tokenizationStateStore.applyEdits(change.range, eolCount);
      }
      this._beginBackgroundTokenization();
    }));
    this._register(this._textModel.onDidChangeAttached(() => {
      this._beginBackgroundTokenization();
    }));
    this._register(this._textModel.onDidChangeLanguage(() => {
      this._resetTokenizationState();
      this._textModel.clearTokens();
    }));
    this._resetTokenizationState();
  }
  dispose() {
    this._isDisposed = true;
    super.dispose();
  }
  _resetTokenizationState() {
    const [tokenizationSupport, initialState] = initializeTokenization(this._textModel);
    this._tokenizationSupport = tokenizationSupport;
    this._tokenizationStateStore.flush(initialState);
    this._beginBackgroundTokenization();
  }
  _beginBackgroundTokenization() {
    if (this._textModel.isAttachedToEditor() && this._hasLinesToTokenize()) {
      setImmediate(() => {
        if (this._isDisposed) {
          return;
        }
        this._revalidateTokensNow();
      });
    }
  }
  _revalidateTokensNow(toLineNumber = this._textModel.getLineCount()) {
    const MAX_ALLOWED_TIME = 1;
    const builder = new MultilineTokensBuilder();
    const sw = StopWatch.create(false);
    while (this._hasLinesToTokenize()) {
      if (sw.elapsed() > MAX_ALLOWED_TIME) {
        break;
      }
      const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);
      if (tokenizedLineNumber >= toLineNumber) {
        break;
      }
    }
    this._beginBackgroundTokenization();
    this._textModel.setTokens(builder.tokens);
  }
  tokenizeViewport(startLineNumber, endLineNumber) {
    const builder = new MultilineTokensBuilder();
    this._tokenizeViewport(builder, startLineNumber, endLineNumber);
    this._textModel.setTokens(builder.tokens);
  }
  reset() {
    this._resetTokenizationState();
    this._textModel.clearTokens();
  }
  forceTokenization(lineNumber) {
    const builder = new MultilineTokensBuilder();
    this._updateTokensUntilLine(builder, lineNumber);
    this._textModel.setTokens(builder.tokens);
  }
  isCheapToTokenize(lineNumber) {
    if (!this._tokenizationSupport) {
      return true;
    }
    const firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;
    if (lineNumber > firstInvalidLineNumber) {
      return false;
    }
    if (lineNumber < firstInvalidLineNumber) {
      return true;
    }
    if (this._textModel.getLineLength(lineNumber) < 2048) {
      return true;
    }
    return false;
  }
  _hasLinesToTokenize() {
    if (!this._tokenizationSupport) {
      return false;
    }
    return this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount();
  }
  _tokenizeOneInvalidLine(builder) {
    if (!this._hasLinesToTokenize()) {
      return this._textModel.getLineCount() + 1;
    }
    const lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;
    this._updateTokensUntilLine(builder, lineNumber);
    return lineNumber;
  }
  _updateTokensUntilLine(builder, lineNumber) {
    if (!this._tokenizationSupport) {
      return;
    }
    const languageIdentifier = this._textModel.getLanguageIdentifier();
    const linesLength = this._textModel.getLineCount();
    const endLineIndex = lineNumber - 1;
    for (let lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {
      const text = this._textModel.getLineContent(lineIndex + 1);
      const lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);
      const r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, lineStartState);
      builder.add(lineIndex + 1, r.tokens);
      this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);
      lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1;
    }
  }
  _tokenizeViewport(builder, startLineNumber, endLineNumber) {
    if (!this._tokenizationSupport) {
      return;
    }
    if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {
      return;
    }
    if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {
      this._updateTokensUntilLine(builder, endLineNumber);
      return;
    }
    let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    let fakeLines = [];
    let initialState = null;
    for (let i = startLineNumber - 1; nonWhitespaceColumn > 0 && i >= 1; i--) {
      let newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);
      if (newNonWhitespaceIndex === 0) {
        continue;
      }
      if (newNonWhitespaceIndex < nonWhitespaceColumn) {
        initialState = this._tokenizationStateStore.getBeginState(i - 1);
        if (initialState) {
          break;
        }
        fakeLines.push(this._textModel.getLineContent(i));
        nonWhitespaceColumn = newNonWhitespaceIndex;
      }
    }
    if (!initialState) {
      initialState = this._tokenizationSupport.getInitialState();
    }
    const languageIdentifier = this._textModel.getLanguageIdentifier();
    let state = initialState;
    for (let i = fakeLines.length - 1; i >= 0; i--) {
      let r = safeTokenize(languageIdentifier, this._tokenizationSupport, fakeLines[i], state);
      state = r.endState;
    }
    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      let text = this._textModel.getLineContent(lineNumber);
      let r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, state);
      builder.add(lineNumber, r.tokens);
      this._tokenizationStateStore.setFakeTokens(lineNumber - 1);
      state = r.endState;
    }
  }
};
function initializeTokenization(textModel) {
  const languageIdentifier = textModel.getLanguageIdentifier();
  let tokenizationSupport = textModel.isTooLargeForTokenization() ? null : TokenizationRegistry.get(languageIdentifier.language);
  let initialState = null;
  if (tokenizationSupport) {
    try {
      initialState = tokenizationSupport.getInitialState();
    } catch (e) {
      onUnexpectedError(e);
      tokenizationSupport = null;
    }
  }
  return [tokenizationSupport, initialState];
}
function safeTokenize(languageIdentifier, tokenizationSupport, text, state) {
  let r = null;
  if (tokenizationSupport) {
    try {
      r = tokenizationSupport.tokenize2(text, state.clone(), 0);
    } catch (e) {
      onUnexpectedError(e);
    }
  }
  if (!r) {
    r = nullTokenize2(languageIdentifier.id, text, state, 0);
  }
  LineTokens.convertToEndOffset(r.tokens, text.length);
  return r;
}

// ../../node_modules/monaco-editor/esm/vs/base/common/color.js
function roundFloat(number, decimalPoints) {
  const decimal = Math.pow(10, decimalPoints);
  return Math.round(number * decimal) / decimal;
}
var RGBA = class {
  constructor(r, g, b, a = 1) {
    this.r = Math.min(255, Math.max(0, r)) | 0;
    this.g = Math.min(255, Math.max(0, g)) | 0;
    this.b = Math.min(255, Math.max(0, b)) | 0;
    this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
  }
  static equals(a, b) {
    return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
  }
};
var HSLA = class {
  constructor(h, s, l, a) {
    this.h = Math.max(Math.min(360, h), 0) | 0;
    this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
    this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);
    this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
  }
  static equals(a, b) {
    return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;
  }
  static fromRGBA(rgba) {
    const r = rgba.r / 255;
    const g = rgba.g / 255;
    const b = rgba.b / 255;
    const a = rgba.a;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0;
    let s = 0;
    const l = (min + max) / 2;
    const chroma = max - min;
    if (chroma > 0) {
      s = Math.min(l <= 0.5 ? chroma / (2 * l) : chroma / (2 - 2 * l), 1);
      switch (max) {
        case r:
          h = (g - b) / chroma + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / chroma + 2;
          break;
        case b:
          h = (r - g) / chroma + 4;
          break;
      }
      h *= 60;
      h = Math.round(h);
    }
    return new HSLA(h, s, l, a);
  }
  static _hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }
  static toRGBA(hsla) {
    const h = hsla.h / 360;
    const {s, l, a} = hsla;
    let r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = HSLA._hue2rgb(p, q, h + 1 / 3);
      g = HSLA._hue2rgb(p, q, h);
      b = HSLA._hue2rgb(p, q, h - 1 / 3);
    }
    return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);
  }
};
var HSVA = class {
  constructor(h, s, v, a) {
    this.h = Math.max(Math.min(360, h), 0) | 0;
    this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
    this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);
    this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
  }
  static equals(a, b) {
    return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;
  }
  static fromRGBA(rgba) {
    const r = rgba.r / 255;
    const g = rgba.g / 255;
    const b = rgba.b / 255;
    const cmax = Math.max(r, g, b);
    const cmin = Math.min(r, g, b);
    const delta = cmax - cmin;
    const s = cmax === 0 ? 0 : delta / cmax;
    let m;
    if (delta === 0) {
      m = 0;
    } else if (cmax === r) {
      m = ((g - b) / delta % 6 + 6) % 6;
    } else if (cmax === g) {
      m = (b - r) / delta + 2;
    } else {
      m = (r - g) / delta + 4;
    }
    return new HSVA(Math.round(m * 60), s, cmax, rgba.a);
  }
  static toRGBA(hsva) {
    const {h, s, v, a} = hsva;
    const c = v * s;
    const x = c * (1 - Math.abs(h / 60 % 2 - 1));
    const m = v - c;
    let [r, g, b] = [0, 0, 0];
    if (h < 60) {
      r = c;
      g = x;
    } else if (h < 120) {
      r = x;
      g = c;
    } else if (h < 180) {
      g = c;
      b = x;
    } else if (h < 240) {
      g = x;
      b = c;
    } else if (h < 300) {
      r = x;
      b = c;
    } else if (h < 360) {
      r = c;
      b = x;
    }
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    return new RGBA(r, g, b, a);
  }
};
var Color = class {
  constructor(arg) {
    if (!arg) {
      throw new Error("Color needs a value");
    } else if (arg instanceof RGBA) {
      this.rgba = arg;
    } else if (arg instanceof HSLA) {
      this._hsla = arg;
      this.rgba = HSLA.toRGBA(arg);
    } else if (arg instanceof HSVA) {
      this._hsva = arg;
      this.rgba = HSVA.toRGBA(arg);
    } else {
      throw new Error("Invalid color ctor argument");
    }
  }
  static fromHex(hex) {
    return Color.Format.CSS.parseHex(hex) || Color.red;
  }
  get hsla() {
    if (this._hsla) {
      return this._hsla;
    } else {
      return HSLA.fromRGBA(this.rgba);
    }
  }
  get hsva() {
    if (this._hsva) {
      return this._hsva;
    }
    return HSVA.fromRGBA(this.rgba);
  }
  equals(other) {
    return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
  }
  getRelativeLuminance() {
    const R = Color._relativeLuminanceForComponent(this.rgba.r);
    const G = Color._relativeLuminanceForComponent(this.rgba.g);
    const B = Color._relativeLuminanceForComponent(this.rgba.b);
    const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;
    return roundFloat(luminance, 4);
  }
  static _relativeLuminanceForComponent(color) {
    const c = color / 255;
    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  isLighter() {
    const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3;
    return yiq >= 128;
  }
  isLighterThan(another) {
    const lum1 = this.getRelativeLuminance();
    const lum2 = another.getRelativeLuminance();
    return lum1 > lum2;
  }
  isDarkerThan(another) {
    const lum1 = this.getRelativeLuminance();
    const lum2 = another.getRelativeLuminance();
    return lum1 < lum2;
  }
  lighten(factor) {
    return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));
  }
  darken(factor) {
    return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));
  }
  transparent(factor) {
    const {r, g, b, a} = this.rgba;
    return new Color(new RGBA(r, g, b, a * factor));
  }
  isTransparent() {
    return this.rgba.a === 0;
  }
  isOpaque() {
    return this.rgba.a === 1;
  }
  opposite() {
    return new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
  }
  toString() {
    return "" + Color.Format.CSS.format(this);
  }
  static getLighterColor(of, relative2, factor) {
    if (of.isLighterThan(relative2)) {
      return of;
    }
    factor = factor ? factor : 0.5;
    const lum1 = of.getRelativeLuminance();
    const lum2 = relative2.getRelativeLuminance();
    factor = factor * (lum2 - lum1) / lum2;
    return of.lighten(factor);
  }
  static getDarkerColor(of, relative2, factor) {
    if (of.isDarkerThan(relative2)) {
      return of;
    }
    factor = factor ? factor : 0.5;
    const lum1 = of.getRelativeLuminance();
    const lum2 = relative2.getRelativeLuminance();
    factor = factor * (lum1 - lum2) / lum1;
    return of.darken(factor);
  }
};
Color.white = new Color(new RGBA(255, 255, 255, 1));
Color.black = new Color(new RGBA(0, 0, 0, 1));
Color.red = new Color(new RGBA(255, 0, 0, 1));
Color.blue = new Color(new RGBA(0, 0, 255, 1));
Color.cyan = new Color(new RGBA(0, 255, 255, 1));
Color.lightgrey = new Color(new RGBA(211, 211, 211, 1));
Color.transparent = new Color(new RGBA(0, 0, 0, 0));
(function(Color2) {
  let Format;
  (function(Format2) {
    let CSS;
    (function(CSS2) {
      function formatRGB(color) {
        if (color.rgba.a === 1) {
          return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;
        }
        return Color2.Format.CSS.formatRGBA(color);
      }
      CSS2.formatRGB = formatRGB;
      function formatRGBA(color) {
        return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+color.rgba.a.toFixed(2)})`;
      }
      CSS2.formatRGBA = formatRGBA;
      function formatHSL(color) {
        if (color.hsla.a === 1) {
          return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;
        }
        return Color2.Format.CSS.formatHSLA(color);
      }
      CSS2.formatHSL = formatHSL;
      function formatHSLA(color) {
        return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;
      }
      CSS2.formatHSLA = formatHSLA;
      function _toTwoDigitHex(n) {
        const r = n.toString(16);
        return r.length !== 2 ? "0" + r : r;
      }
      function formatHex(color) {
        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;
      }
      CSS2.formatHex = formatHex;
      function formatHexA(color, compact = false) {
        if (compact && color.rgba.a === 1) {
          return Color2.Format.CSS.formatHex(color);
        }
        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;
      }
      CSS2.formatHexA = formatHexA;
      function format2(color) {
        if (color.isOpaque()) {
          return Color2.Format.CSS.formatHex(color);
        }
        return Color2.Format.CSS.formatRGBA(color);
      }
      CSS2.format = format2;
      function parseHex(hex) {
        const length = hex.length;
        if (length === 0) {
          return null;
        }
        if (hex.charCodeAt(0) !== 35) {
          return null;
        }
        if (length === 7) {
          const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
          const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
          const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
          return new Color2(new RGBA(r, g, b, 1));
        }
        if (length === 9) {
          const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
          const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
          const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
          const a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));
          return new Color2(new RGBA(r, g, b, a / 255));
        }
        if (length === 4) {
          const r = _parseHexDigit(hex.charCodeAt(1));
          const g = _parseHexDigit(hex.charCodeAt(2));
          const b = _parseHexDigit(hex.charCodeAt(3));
          return new Color2(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));
        }
        if (length === 5) {
          const r = _parseHexDigit(hex.charCodeAt(1));
          const g = _parseHexDigit(hex.charCodeAt(2));
          const b = _parseHexDigit(hex.charCodeAt(3));
          const a = _parseHexDigit(hex.charCodeAt(4));
          return new Color2(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));
        }
        return null;
      }
      CSS2.parseHex = parseHex;
      function _parseHexDigit(charCode) {
        switch (charCode) {
          case 48:
            return 0;
          case 49:
            return 1;
          case 50:
            return 2;
          case 51:
            return 3;
          case 52:
            return 4;
          case 53:
            return 5;
          case 54:
            return 6;
          case 55:
            return 7;
          case 56:
            return 8;
          case 57:
            return 9;
          case 97:
            return 10;
          case 65:
            return 10;
          case 98:
            return 11;
          case 66:
            return 11;
          case 99:
            return 12;
          case 67:
            return 12;
          case 100:
            return 13;
          case 68:
            return 13;
          case 101:
            return 14;
          case 69:
            return 14;
          case 102:
            return 15;
          case 70:
            return 15;
        }
        return 0;
      }
    })(CSS = Format2.CSS || (Format2.CSS = {}));
  })(Format = Color2.Format || (Color2.Format = {}));
})(Color || (Color = {}));

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js
function createTextBufferBuilder() {
  return new PieceTreeTextBufferBuilder();
}
function createTextBufferFactory(text) {
  const builder = createTextBufferBuilder();
  builder.acceptChunk(text);
  return builder.finish();
}
function createTextBuffer(value, defaultEOL) {
  const factory = typeof value === "string" ? createTextBufferFactory(value) : value;
  return factory.create(defaultEOL);
}
var MODEL_ID = 0;
var LIMIT_FIND_COUNT2 = 999;
var LONG_LINE_BOUNDARY = 1e4;
var TextModelSnapshot = class {
  constructor(source) {
    this._source = source;
    this._eos = false;
  }
  read() {
    if (this._eos) {
      return null;
    }
    let result = [], resultCnt = 0, resultLength = 0;
    do {
      let tmp = this._source.read();
      if (tmp === null) {
        this._eos = true;
        if (resultCnt === 0) {
          return null;
        } else {
          return result.join("");
        }
      }
      if (tmp.length > 0) {
        result[resultCnt++] = tmp;
        resultLength += tmp.length;
      }
      if (resultLength >= 64 * 1024) {
        return result.join("");
      }
    } while (true);
  }
};
var invalidFunc = () => {
  throw new Error(`Invalid change accessor`);
};
var BracketSearchCanceled = class {
  constructor() {
    this._searchCanceledBrand = void 0;
  }
};
BracketSearchCanceled.INSTANCE = new BracketSearchCanceled();
function stripBracketSearchCanceled(result) {
  if (result instanceof BracketSearchCanceled) {
    return null;
  }
  return result;
}
var TextModel = class extends Disposable {
  constructor(source, creationOptions, languageIdentifier, associatedResource = null, undoRedoService) {
    super();
    this._onWillDispose = this._register(new Emitter());
    this.onWillDispose = this._onWillDispose.event;
    this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter());
    this.onDidChangeDecorations = this._onDidChangeDecorations.event;
    this._onDidChangeLanguage = this._register(new Emitter());
    this.onDidChangeLanguage = this._onDidChangeLanguage.event;
    this._onDidChangeLanguageConfiguration = this._register(new Emitter());
    this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;
    this._onDidChangeTokens = this._register(new Emitter());
    this.onDidChangeTokens = this._onDidChangeTokens.event;
    this._onDidChangeOptions = this._register(new Emitter());
    this.onDidChangeOptions = this._onDidChangeOptions.event;
    this._onDidChangeAttached = this._register(new Emitter());
    this.onDidChangeAttached = this._onDidChangeAttached.event;
    this._eventEmitter = this._register(new DidChangeContentEmitter());
    MODEL_ID++;
    this.id = "$model" + MODEL_ID;
    this.isForSimpleWidget = creationOptions.isForSimpleWidget;
    if (typeof associatedResource === "undefined" || associatedResource === null) {
      this._associatedResource = URI.parse("inmemory://model/" + MODEL_ID);
    } else {
      this._associatedResource = associatedResource;
    }
    this._undoRedoService = undoRedoService;
    this._attachedEditorCount = 0;
    this._buffer = createTextBuffer(source, creationOptions.defaultEOL);
    this._options = TextModel.resolveOptions(this._buffer, creationOptions);
    const bufferLineCount = this._buffer.getLineCount();
    const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0);
    if (creationOptions.largeFileOptimizations) {
      this._isTooLargeForTokenization = bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD || bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD;
    } else {
      this._isTooLargeForTokenization = false;
    }
    this._isTooLargeForSyncing = bufferTextLength > TextModel.MODEL_SYNC_LIMIT;
    this._versionId = 1;
    this._alternativeVersionId = 1;
    this._initialUndoRedoSnapshot = null;
    this._isDisposed = false;
    this._isDisposing = false;
    this._languageIdentifier = languageIdentifier || NULL_LANGUAGE_IDENTIFIER;
    this._languageRegistryListener = LanguageConfigurationRegistry.onDidChange((e) => {
      if (e.languageIdentifier.id === this._languageIdentifier.id) {
        this._onDidChangeLanguageConfiguration.fire({});
      }
    });
    this._instanceId = singleLetterHash(MODEL_ID);
    this._lastDecorationId = 0;
    this._decorations = Object.create(null);
    this._decorationsTree = new DecorationsTrees();
    this._commandManager = new EditStack(this, undoRedoService);
    this._isUndoing = false;
    this._isRedoing = false;
    this._trimAutoWhitespaceLines = null;
    this._tokens = new TokensStore();
    this._tokens2 = new TokensStore2();
    this._tokenization = new TextModelTokenization(this);
  }
  static resolveOptions(textBuffer, options) {
    if (options.detectIndentation) {
      const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);
      return new TextModelResolvedOptions({
        tabSize: guessedIndentation.tabSize,
        indentSize: guessedIndentation.tabSize,
        insertSpaces: guessedIndentation.insertSpaces,
        trimAutoWhitespace: options.trimAutoWhitespace,
        defaultEOL: options.defaultEOL
      });
    }
    return new TextModelResolvedOptions({
      tabSize: options.tabSize,
      indentSize: options.indentSize,
      insertSpaces: options.insertSpaces,
      trimAutoWhitespace: options.trimAutoWhitespace,
      defaultEOL: options.defaultEOL
    });
  }
  onDidChangeRawContentFast(listener) {
    return this._eventEmitter.fastEvent((e) => listener(e.rawContentChangedEvent));
  }
  onDidChangeContentFast(listener) {
    return this._eventEmitter.fastEvent((e) => listener(e.contentChangedEvent));
  }
  onDidChangeContent(listener) {
    return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));
  }
  dispose() {
    this._isDisposing = true;
    this._onWillDispose.fire();
    this._languageRegistryListener.dispose();
    this._tokenization.dispose();
    this._isDisposed = true;
    super.dispose();
    this._isDisposing = false;
  }
  _assertNotDisposed() {
    if (this._isDisposed) {
      throw new Error("Model is disposed!");
    }
  }
  _emitContentChangedEvent(rawChange, change) {
    if (this._isDisposing) {
      return;
    }
    this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));
  }
  setValue(value) {
    this._assertNotDisposed();
    if (value === null) {
      return;
    }
    const textBuffer = createTextBuffer(value, this._options.defaultEOL);
    this.setValueFromTextBuffer(textBuffer);
  }
  _createContentChanged2(range2, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {
    return {
      changes: [{
        range: range2,
        rangeOffset,
        rangeLength,
        text
      }],
      eol: this._buffer.getEOL(),
      versionId: this.getVersionId(),
      isUndoing,
      isRedoing,
      isFlush
    };
  }
  setValueFromTextBuffer(textBuffer) {
    this._assertNotDisposed();
    if (textBuffer === null) {
      return;
    }
    const oldFullModelRange = this.getFullModelRange();
    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
    const endLineNumber = this.getLineCount();
    const endColumn = this.getLineMaxColumn(endLineNumber);
    this._buffer = textBuffer;
    this._increaseVersionId();
    this._tokens.flush();
    this._tokens2.flush();
    this._decorations = Object.create(null);
    this._decorationsTree = new DecorationsTrees();
    this._commandManager.clear();
    this._trimAutoWhitespaceLines = null;
    this._emitContentChangedEvent(new ModelRawContentChangedEvent([
      new ModelRawFlush()
    ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));
  }
  setEOL(eol) {
    this._assertNotDisposed();
    const newEOL = eol === 1 ? "\r\n" : "\n";
    if (this._buffer.getEOL() === newEOL) {
      return;
    }
    const oldFullModelRange = this.getFullModelRange();
    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
    const endLineNumber = this.getLineCount();
    const endColumn = this.getLineMaxColumn(endLineNumber);
    this._onBeforeEOLChange();
    this._buffer.setEOL(newEOL);
    this._increaseVersionId();
    this._onAfterEOLChange();
    this._emitContentChangedEvent(new ModelRawContentChangedEvent([
      new ModelRawEOLChanged()
    ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));
  }
  _onBeforeEOLChange() {
    const versionId = this.getVersionId();
    const allDecorations = this._decorationsTree.search(0, false, false, versionId);
    this._ensureNodesHaveRanges(allDecorations);
  }
  _onAfterEOLChange() {
    const versionId = this.getVersionId();
    const allDecorations = this._decorationsTree.collectNodesPostOrder();
    for (let i = 0, len = allDecorations.length; i < len; i++) {
      const node = allDecorations[i];
      const delta = node.cachedAbsoluteStart - node.start;
      const startOffset = this._buffer.getOffsetAt(node.range.startLineNumber, node.range.startColumn);
      const endOffset = this._buffer.getOffsetAt(node.range.endLineNumber, node.range.endColumn);
      node.cachedAbsoluteStart = startOffset;
      node.cachedAbsoluteEnd = endOffset;
      node.cachedVersionId = versionId;
      node.start = startOffset - delta;
      node.end = endOffset - delta;
      recomputeMaxEnd(node);
    }
  }
  onBeforeAttached() {
    this._attachedEditorCount++;
    if (this._attachedEditorCount === 1) {
      this._onDidChangeAttached.fire(void 0);
    }
  }
  onBeforeDetached() {
    this._attachedEditorCount--;
    if (this._attachedEditorCount === 0) {
      this._onDidChangeAttached.fire(void 0);
    }
  }
  isAttachedToEditor() {
    return this._attachedEditorCount > 0;
  }
  getAttachedEditorCount() {
    return this._attachedEditorCount;
  }
  isTooLargeForSyncing() {
    return this._isTooLargeForSyncing;
  }
  isTooLargeForTokenization() {
    return this._isTooLargeForTokenization;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isDominatedByLongLines() {
    this._assertNotDisposed();
    if (this.isTooLargeForTokenization()) {
      return false;
    }
    let smallLineCharCount = 0;
    let longLineCharCount = 0;
    const lineCount = this._buffer.getLineCount();
    for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {
      const lineLength = this._buffer.getLineLength(lineNumber);
      if (lineLength >= LONG_LINE_BOUNDARY) {
        longLineCharCount += lineLength;
      } else {
        smallLineCharCount += lineLength;
      }
    }
    return longLineCharCount > smallLineCharCount;
  }
  get uri() {
    return this._associatedResource;
  }
  getOptions() {
    this._assertNotDisposed();
    return this._options;
  }
  getFormattingOptions() {
    return {
      tabSize: this._options.indentSize,
      insertSpaces: this._options.insertSpaces
    };
  }
  updateOptions(_newOpts) {
    this._assertNotDisposed();
    let tabSize = typeof _newOpts.tabSize !== "undefined" ? _newOpts.tabSize : this._options.tabSize;
    let indentSize = typeof _newOpts.indentSize !== "undefined" ? _newOpts.indentSize : this._options.indentSize;
    let insertSpaces = typeof _newOpts.insertSpaces !== "undefined" ? _newOpts.insertSpaces : this._options.insertSpaces;
    let trimAutoWhitespace = typeof _newOpts.trimAutoWhitespace !== "undefined" ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;
    let newOpts = new TextModelResolvedOptions({
      tabSize,
      indentSize,
      insertSpaces,
      defaultEOL: this._options.defaultEOL,
      trimAutoWhitespace
    });
    if (this._options.equals(newOpts)) {
      return;
    }
    let e = this._options.createChangeEvent(newOpts);
    this._options = newOpts;
    this._onDidChangeOptions.fire(e);
  }
  detectIndentation(defaultInsertSpaces, defaultTabSize) {
    this._assertNotDisposed();
    let guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);
    this.updateOptions({
      insertSpaces: guessedIndentation.insertSpaces,
      tabSize: guessedIndentation.tabSize,
      indentSize: guessedIndentation.tabSize
    });
  }
  static _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {
    let spacesCnt = 0;
    for (let i = 0; i < str.length; i++) {
      if (str.charAt(i) === "	") {
        spacesCnt += indentSize;
      } else {
        spacesCnt++;
      }
    }
    let result = "";
    if (!insertSpaces) {
      let tabsCnt = Math.floor(spacesCnt / indentSize);
      spacesCnt = spacesCnt % indentSize;
      for (let i = 0; i < tabsCnt; i++) {
        result += "	";
      }
    }
    for (let i = 0; i < spacesCnt; i++) {
      result += " ";
    }
    return result;
  }
  static normalizeIndentation(str, indentSize, insertSpaces) {
    let firstNonWhitespaceIndex2 = firstNonWhitespaceIndex(str);
    if (firstNonWhitespaceIndex2 === -1) {
      firstNonWhitespaceIndex2 = str.length;
    }
    return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex2), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex2);
  }
  normalizeIndentation(str) {
    this._assertNotDisposed();
    return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);
  }
  getVersionId() {
    this._assertNotDisposed();
    return this._versionId;
  }
  mightContainRTL() {
    return this._buffer.mightContainRTL();
  }
  mightContainUnusualLineTerminators() {
    return this._buffer.mightContainUnusualLineTerminators();
  }
  removeUnusualLineTerminators(selections = null) {
    const matches = this.findMatches(UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824);
    this._buffer.resetMightContainUnusualLineTerminators();
    this.pushEditOperations(selections, matches.map((m) => ({range: m.range, text: null})), () => null);
  }
  mightContainNonBasicASCII() {
    return this._buffer.mightContainNonBasicASCII();
  }
  getAlternativeVersionId() {
    this._assertNotDisposed();
    return this._alternativeVersionId;
  }
  getOffsetAt(rawPosition) {
    this._assertNotDisposed();
    let position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0);
    return this._buffer.getOffsetAt(position.lineNumber, position.column);
  }
  getPositionAt(rawOffset) {
    this._assertNotDisposed();
    let offset = Math.min(this._buffer.getLength(), Math.max(0, rawOffset));
    return this._buffer.getPositionAt(offset);
  }
  _increaseVersionId() {
    this._versionId = this._versionId + 1;
    this._alternativeVersionId = this._versionId;
  }
  _overwriteVersionId(versionId) {
    this._versionId = versionId;
  }
  _overwriteAlternativeVersionId(newAlternativeVersionId) {
    this._alternativeVersionId = newAlternativeVersionId;
  }
  _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {
    this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;
  }
  getValue(eol, preserveBOM = false) {
    this._assertNotDisposed();
    const fullModelRange = this.getFullModelRange();
    const fullModelValue = this.getValueInRange(fullModelRange, eol);
    if (preserveBOM) {
      return this._buffer.getBOM() + fullModelValue;
    }
    return fullModelValue;
  }
  createSnapshot(preserveBOM = false) {
    return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));
  }
  getValueLength(eol, preserveBOM = false) {
    this._assertNotDisposed();
    const fullModelRange = this.getFullModelRange();
    const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);
    if (preserveBOM) {
      return this._buffer.getBOM().length + fullModelValue;
    }
    return fullModelValue;
  }
  getValueInRange(rawRange, eol = 0) {
    this._assertNotDisposed();
    return this._buffer.getValueInRange(this.validateRange(rawRange), eol);
  }
  getValueLengthInRange(rawRange, eol = 0) {
    this._assertNotDisposed();
    return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);
  }
  getCharacterCountInRange(rawRange, eol = 0) {
    this._assertNotDisposed();
    return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);
  }
  getLineCount() {
    this._assertNotDisposed();
    return this._buffer.getLineCount();
  }
  getLineContent(lineNumber) {
    this._assertNotDisposed();
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return this._buffer.getLineContent(lineNumber);
  }
  getLineLength(lineNumber) {
    this._assertNotDisposed();
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return this._buffer.getLineLength(lineNumber);
  }
  getLinesContent() {
    this._assertNotDisposed();
    return this._buffer.getLinesContent();
  }
  getEOL() {
    this._assertNotDisposed();
    return this._buffer.getEOL();
  }
  getLineMinColumn(lineNumber) {
    this._assertNotDisposed();
    return 1;
  }
  getLineMaxColumn(lineNumber) {
    this._assertNotDisposed();
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return this._buffer.getLineLength(lineNumber) + 1;
  }
  getLineFirstNonWhitespaceColumn(lineNumber) {
    this._assertNotDisposed();
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);
  }
  getLineLastNonWhitespaceColumn(lineNumber) {
    this._assertNotDisposed();
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);
  }
  _validateRangeRelaxedNoAllocations(range2) {
    const linesCount = this._buffer.getLineCount();
    const initialStartLineNumber = range2.startLineNumber;
    const initialStartColumn = range2.startColumn;
    let startLineNumber;
    let startColumn;
    if (initialStartLineNumber < 1) {
      startLineNumber = 1;
      startColumn = 1;
    } else if (initialStartLineNumber > linesCount) {
      startLineNumber = linesCount;
      startColumn = this.getLineMaxColumn(startLineNumber);
    } else {
      startLineNumber = initialStartLineNumber | 0;
      if (initialStartColumn <= 1) {
        startColumn = 1;
      } else {
        const maxColumn = this.getLineMaxColumn(startLineNumber);
        if (initialStartColumn >= maxColumn) {
          startColumn = maxColumn;
        } else {
          startColumn = initialStartColumn | 0;
        }
      }
    }
    const initialEndLineNumber = range2.endLineNumber;
    const initialEndColumn = range2.endColumn;
    let endLineNumber;
    let endColumn;
    if (initialEndLineNumber < 1) {
      endLineNumber = 1;
      endColumn = 1;
    } else if (initialEndLineNumber > linesCount) {
      endLineNumber = linesCount;
      endColumn = this.getLineMaxColumn(endLineNumber);
    } else {
      endLineNumber = initialEndLineNumber | 0;
      if (initialEndColumn <= 1) {
        endColumn = 1;
      } else {
        const maxColumn = this.getLineMaxColumn(endLineNumber);
        if (initialEndColumn >= maxColumn) {
          endColumn = maxColumn;
        } else {
          endColumn = initialEndColumn | 0;
        }
      }
    }
    if (initialStartLineNumber === startLineNumber && initialStartColumn === startColumn && initialEndLineNumber === endLineNumber && initialEndColumn === endColumn && range2 instanceof Range && !(range2 instanceof Selection)) {
      return range2;
    }
    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
  }
  _isValidPosition(lineNumber, column, validationType) {
    if (typeof lineNumber !== "number" || typeof column !== "number") {
      return false;
    }
    if (isNaN(lineNumber) || isNaN(column)) {
      return false;
    }
    if (lineNumber < 1 || column < 1) {
      return false;
    }
    if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {
      return false;
    }
    const lineCount = this._buffer.getLineCount();
    if (lineNumber > lineCount) {
      return false;
    }
    if (column === 1) {
      return true;
    }
    const maxColumn = this.getLineMaxColumn(lineNumber);
    if (column > maxColumn) {
      return false;
    }
    if (validationType === 1) {
      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);
      if (isHighSurrogate(charCodeBefore)) {
        return false;
      }
    }
    return true;
  }
  _validatePosition(_lineNumber, _column, validationType) {
    const lineNumber = Math.floor(typeof _lineNumber === "number" && !isNaN(_lineNumber) ? _lineNumber : 1);
    const column = Math.floor(typeof _column === "number" && !isNaN(_column) ? _column : 1);
    const lineCount = this._buffer.getLineCount();
    if (lineNumber < 1) {
      return new Position(1, 1);
    }
    if (lineNumber > lineCount) {
      return new Position(lineCount, this.getLineMaxColumn(lineCount));
    }
    if (column <= 1) {
      return new Position(lineNumber, 1);
    }
    const maxColumn = this.getLineMaxColumn(lineNumber);
    if (column >= maxColumn) {
      return new Position(lineNumber, maxColumn);
    }
    if (validationType === 1) {
      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);
      if (isHighSurrogate(charCodeBefore)) {
        return new Position(lineNumber, column - 1);
      }
    }
    return new Position(lineNumber, column);
  }
  validatePosition(position) {
    const validationType = 1;
    this._assertNotDisposed();
    if (position instanceof Position) {
      if (this._isValidPosition(position.lineNumber, position.column, validationType)) {
        return position;
      }
    }
    return this._validatePosition(position.lineNumber, position.column, validationType);
  }
  _isValidRange(range2, validationType) {
    const startLineNumber = range2.startLineNumber;
    const startColumn = range2.startColumn;
    const endLineNumber = range2.endLineNumber;
    const endColumn = range2.endColumn;
    if (!this._isValidPosition(startLineNumber, startColumn, 0)) {
      return false;
    }
    if (!this._isValidPosition(endLineNumber, endColumn, 0)) {
      return false;
    }
    if (validationType === 1) {
      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;
      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;
      const startInsideSurrogatePair = isHighSurrogate(charCodeBeforeStart);
      const endInsideSurrogatePair = isHighSurrogate(charCodeBeforeEnd);
      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
        return true;
      }
      return false;
    }
    return true;
  }
  validateRange(_range) {
    const validationType = 1;
    this._assertNotDisposed();
    if (_range instanceof Range && !(_range instanceof Selection)) {
      if (this._isValidRange(_range, validationType)) {
        return _range;
      }
    }
    const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0);
    const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0);
    const startLineNumber = start.lineNumber;
    const startColumn = start.column;
    const endLineNumber = end.lineNumber;
    const endColumn = end.column;
    if (validationType === 1) {
      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;
      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;
      const startInsideSurrogatePair = isHighSurrogate(charCodeBeforeStart);
      const endInsideSurrogatePair = isHighSurrogate(charCodeBeforeEnd);
      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
      }
      if (startLineNumber === endLineNumber && startColumn === endColumn) {
        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);
      }
      if (startInsideSurrogatePair && endInsideSurrogatePair) {
        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);
      }
      if (startInsideSurrogatePair) {
        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);
      }
      return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);
    }
    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
  }
  modifyPosition(rawPosition, offset) {
    this._assertNotDisposed();
    let candidate = this.getOffsetAt(rawPosition) + offset;
    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));
  }
  getFullModelRange() {
    this._assertNotDisposed();
    const lineCount = this.getLineCount();
    return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));
  }
  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
    return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
  }
  findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators2, captureMatches, limitResultCount = LIMIT_FIND_COUNT2) {
    this._assertNotDisposed();
    let searchRanges = null;
    if (rawSearchScope !== null) {
      if (!Array.isArray(rawSearchScope)) {
        rawSearchScope = [rawSearchScope];
      }
      if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {
        searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));
      }
    }
    if (searchRanges === null) {
      searchRanges = [this.getFullModelRange()];
    }
    searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);
    const uniqueSearchRanges = [];
    uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {
      if (Range.areIntersecting(prev, curr)) {
        return prev.plusRange(curr);
      }
      uniqueSearchRanges.push(prev);
      return curr;
    }));
    let matchMapper;
    if (!isRegex && searchString.indexOf("\n") < 0) {
      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators2);
      const searchData = searchParams.parseSearchRequest();
      if (!searchData) {
        return [];
      }
      matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
    } else {
      matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators2), searchRange, captureMatches, limitResultCount);
    }
    return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);
  }
  findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators2, captureMatches) {
    this._assertNotDisposed();
    const searchStart = this.validatePosition(rawSearchStart);
    if (!isRegex && searchString.indexOf("\n") < 0) {
      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators2);
      const searchData = searchParams.parseSearchRequest();
      if (!searchData) {
        return null;
      }
      const lineCount = this.getLineCount();
      let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));
      let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);
      TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators2), searchStart, captureMatches);
      if (ret.length > 0) {
        return ret[0];
      }
      searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));
      ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);
      if (ret.length > 0) {
        return ret[0];
      }
      return null;
    }
    return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators2), searchStart, captureMatches);
  }
  findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators2, captureMatches) {
    this._assertNotDisposed();
    const searchStart = this.validatePosition(rawSearchStart);
    return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators2), searchStart, captureMatches);
  }
  pushStackElement() {
    this._commandManager.pushStackElement();
  }
  pushEOL(eol) {
    const currentEOL = this.getEOL() === "\n" ? 0 : 1;
    if (currentEOL === eol) {
      return;
    }
    try {
      this._onDidChangeDecorations.beginDeferredEmit();
      this._eventEmitter.beginDeferredEmit();
      if (this._initialUndoRedoSnapshot === null) {
        this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);
      }
      this._commandManager.pushEOL(eol);
    } finally {
      this._eventEmitter.endDeferredEmit();
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _validateEditOperation(rawOperation) {
    if (rawOperation instanceof ValidAnnotatedEditOperation) {
      return rawOperation;
    }
    return new ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);
  }
  _validateEditOperations(rawOperations) {
    const result = [];
    for (let i = 0, len = rawOperations.length; i < len; i++) {
      result[i] = this._validateEditOperation(rawOperations[i]);
    }
    return result;
  }
  pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit();
      this._eventEmitter.beginDeferredEmit();
      return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);
    } finally {
      this._eventEmitter.endDeferredEmit();
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {
    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
      let incomingEdits = editOperations.map((op) => {
        return {
          range: this.validateRange(op.range),
          text: op.text
        };
      });
      let editsAreNearCursors = true;
      if (beforeCursorState) {
        for (let i = 0, len = beforeCursorState.length; i < len; i++) {
          let sel = beforeCursorState[i];
          let foundEditNearSel = false;
          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
            let editRange = incomingEdits[j].range;
            let selIsAbove = editRange.startLineNumber > sel.endLineNumber;
            let selIsBelow = sel.startLineNumber > editRange.endLineNumber;
            if (!selIsAbove && !selIsBelow) {
              foundEditNearSel = true;
              break;
            }
          }
          if (!foundEditNearSel) {
            editsAreNearCursors = false;
            break;
          }
        }
      }
      if (editsAreNearCursors) {
        for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {
          let trimLineNumber = this._trimAutoWhitespaceLines[i];
          let maxLineColumn = this.getLineMaxColumn(trimLineNumber);
          let allowTrimLine = true;
          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
            let editRange = incomingEdits[j].range;
            let editText = incomingEdits[j].text;
            if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {
              continue;
            }
            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === "\n") {
              continue;
            }
            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1 && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === "\n") {
              continue;
            }
            allowTrimLine = false;
            break;
          }
          if (allowTrimLine) {
            const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);
            editOperations.push(new ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));
          }
        }
      }
      this._trimAutoWhitespaceLines = null;
    }
    if (this._initialUndoRedoSnapshot === null) {
      this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);
    }
    return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);
  }
  _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {
    const edits = changes.map((change) => {
      const rangeStart = this.getPositionAt(change.newPosition);
      const rangeEnd = this.getPositionAt(change.newEnd);
      return {
        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),
        text: change.oldText
      };
    });
    this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);
  }
  _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {
    const edits = changes.map((change) => {
      const rangeStart = this.getPositionAt(change.oldPosition);
      const rangeEnd = this.getPositionAt(change.oldEnd);
      return {
        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),
        text: change.newText
      };
    });
    this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);
  }
  _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit();
      this._eventEmitter.beginDeferredEmit();
      this._isUndoing = isUndoing;
      this._isRedoing = isRedoing;
      this.applyEdits(edits, false);
      this.setEOL(eol);
      this._overwriteAlternativeVersionId(resultingAlternativeVersionId);
    } finally {
      this._isUndoing = false;
      this._isRedoing = false;
      this._eventEmitter.endDeferredEmit(resultingSelection);
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  applyEdits(rawOperations, computeUndoEdits = false) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit();
      this._eventEmitter.beginDeferredEmit();
      const operations = this._validateEditOperations(rawOperations);
      return this._doApplyEdits(operations, computeUndoEdits);
    } finally {
      this._eventEmitter.endDeferredEmit();
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _doApplyEdits(rawOperations, computeUndoEdits) {
    const oldLineCount = this._buffer.getLineCount();
    const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);
    const newLineCount = this._buffer.getLineCount();
    const contentChanges = result.changes;
    this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;
    if (contentChanges.length !== 0) {
      let rawContentChanges = [];
      let lineCount = oldLineCount;
      for (let i = 0, len = contentChanges.length; i < len; i++) {
        const change = contentChanges[i];
        const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);
        this._tokens.acceptEdit(change.range, eolCount, firstLineLength);
        this._tokens2.acceptEdit(change.range, eolCount, firstLineLength, lastLineLength, change.text.length > 0 ? change.text.charCodeAt(0) : 0);
        this._onDidChangeDecorations.fire();
        this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);
        const startLineNumber = change.range.startLineNumber;
        const endLineNumber = change.range.endLineNumber;
        const deletingLinesCnt = endLineNumber - startLineNumber;
        const insertingLinesCnt = eolCount;
        const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);
        const changeLineCountDelta = insertingLinesCnt - deletingLinesCnt;
        for (let j = editingLinesCnt; j >= 0; j--) {
          const editLineNumber = startLineNumber + j;
          const currentEditLineNumber = newLineCount - lineCount - changeLineCountDelta + editLineNumber;
          rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber)));
        }
        if (editingLinesCnt < deletingLinesCnt) {
          const spliceStartLineNumber = startLineNumber + editingLinesCnt;
          rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));
        }
        if (editingLinesCnt < insertingLinesCnt) {
          const spliceLineNumber = startLineNumber + editingLinesCnt;
          const cnt = insertingLinesCnt - editingLinesCnt;
          const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;
          let newLines = [];
          for (let i2 = 0; i2 < cnt; i2++) {
            let lineNumber = fromLineNumber + i2;
            newLines[lineNumber - fromLineNumber] = this.getLineContent(lineNumber);
          }
          rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines));
        }
        lineCount += changeLineCountDelta;
      }
      this._increaseVersionId();
      this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {
        changes: contentChanges,
        eol: this._buffer.getEOL(),
        versionId: this.getVersionId(),
        isUndoing: this._isUndoing,
        isRedoing: this._isRedoing,
        isFlush: false
      });
    }
    return result.reverseEdits === null ? void 0 : result.reverseEdits;
  }
  undo() {
    this._undoRedoService.undo(this.uri);
  }
  canUndo() {
    return this._undoRedoService.canUndo(this.uri);
  }
  redo() {
    this._undoRedoService.redo(this.uri);
  }
  canRedo() {
    return this._undoRedoService.canRedo(this.uri);
  }
  changeDecorations(callback, ownerId = 0) {
    this._assertNotDisposed();
    try {
      this._onDidChangeDecorations.beginDeferredEmit();
      return this._changeDecorations(ownerId, callback);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _changeDecorations(ownerId, callback) {
    let changeAccessor = {
      addDecoration: (range2, options) => {
        return this._deltaDecorationsImpl(ownerId, [], [{range: range2, options}])[0];
      },
      changeDecoration: (id, newRange) => {
        this._changeDecorationImpl(id, newRange);
      },
      changeDecorationOptions: (id, options) => {
        this._changeDecorationOptionsImpl(id, _normalizeOptions(options));
      },
      removeDecoration: (id) => {
        this._deltaDecorationsImpl(ownerId, [id], []);
      },
      deltaDecorations: (oldDecorations, newDecorations) => {
        if (oldDecorations.length === 0 && newDecorations.length === 0) {
          return [];
        }
        return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);
      }
    };
    let result = null;
    try {
      result = callback(changeAccessor);
    } catch (e) {
      onUnexpectedError(e);
    }
    changeAccessor.addDecoration = invalidFunc;
    changeAccessor.changeDecoration = invalidFunc;
    changeAccessor.changeDecorationOptions = invalidFunc;
    changeAccessor.removeDecoration = invalidFunc;
    changeAccessor.deltaDecorations = invalidFunc;
    return result;
  }
  deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {
    this._assertNotDisposed();
    if (!oldDecorations) {
      oldDecorations = [];
    }
    if (oldDecorations.length === 0 && newDecorations.length === 0) {
      return [];
    }
    try {
      this._onDidChangeDecorations.beginDeferredEmit();
      return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _getTrackedRange(id) {
    return this.getDecorationRange(id);
  }
  _setTrackedRange(id, newRange, newStickiness) {
    const node = id ? this._decorations[id] : null;
    if (!node) {
      if (!newRange) {
        return null;
      }
      return this._deltaDecorationsImpl(0, [], [{range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness]}])[0];
    }
    if (!newRange) {
      this._decorationsTree.delete(node);
      delete this._decorations[node.id];
      return null;
    }
    const range2 = this._validateRangeRelaxedNoAllocations(newRange);
    const startOffset = this._buffer.getOffsetAt(range2.startLineNumber, range2.startColumn);
    const endOffset = this._buffer.getOffsetAt(range2.endLineNumber, range2.endColumn);
    this._decorationsTree.delete(node);
    node.reset(this.getVersionId(), startOffset, endOffset, range2);
    node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);
    this._decorationsTree.insert(node);
    return node.id;
  }
  removeAllDecorationsWithOwnerId(ownerId) {
    if (this._isDisposed) {
      return;
    }
    const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      this._decorationsTree.delete(node);
      delete this._decorations[node.id];
    }
  }
  getDecorationOptions(decorationId) {
    const node = this._decorations[decorationId];
    if (!node) {
      return null;
    }
    return node.options;
  }
  getDecorationRange(decorationId) {
    const node = this._decorations[decorationId];
    if (!node) {
      return null;
    }
    const versionId = this.getVersionId();
    if (node.cachedVersionId !== versionId) {
      this._decorationsTree.resolveNode(node, versionId);
    }
    if (node.range === null) {
      node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);
    }
    return node.range;
  }
  getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      return [];
    }
    return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);
  }
  getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false) {
    let lineCount = this.getLineCount();
    let startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));
    let endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));
    let endColumn = this.getLineMaxColumn(endLineNumber);
    return this._getDecorationsInRange(new Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);
  }
  getDecorationsInRange(range2, ownerId = 0, filterOutValidation = false) {
    let validatedRange = this.validateRange(range2);
    return this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);
  }
  getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {
    const versionId = this.getVersionId();
    const result = this._decorationsTree.search(ownerId, filterOutValidation, true, versionId);
    return this._ensureNodesHaveRanges(result);
  }
  getAllDecorations(ownerId = 0, filterOutValidation = false) {
    const versionId = this.getVersionId();
    const result = this._decorationsTree.search(ownerId, filterOutValidation, false, versionId);
    return this._ensureNodesHaveRanges(result);
  }
  _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {
    const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);
    const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);
    const versionId = this.getVersionId();
    const result = this._decorationsTree.intervalSearch(startOffset, endOffset, filterOwnerId, filterOutValidation, versionId);
    return this._ensureNodesHaveRanges(result);
  }
  _ensureNodesHaveRanges(nodes) {
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      if (node.range === null) {
        node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);
      }
    }
    return nodes;
  }
  _getRangeAt(start, end) {
    return this._buffer.getRangeAt(start, end - start);
  }
  _changeDecorationImpl(decorationId, _range) {
    const node = this._decorations[decorationId];
    if (!node) {
      return;
    }
    const range2 = this._validateRangeRelaxedNoAllocations(_range);
    const startOffset = this._buffer.getOffsetAt(range2.startLineNumber, range2.startColumn);
    const endOffset = this._buffer.getOffsetAt(range2.endLineNumber, range2.endColumn);
    this._decorationsTree.delete(node);
    node.reset(this.getVersionId(), startOffset, endOffset, range2);
    this._decorationsTree.insert(node);
    this._onDidChangeDecorations.checkAffectedAndFire(node.options);
  }
  _changeDecorationOptionsImpl(decorationId, options) {
    const node = this._decorations[decorationId];
    if (!node) {
      return;
    }
    const nodeWasInOverviewRuler = node.options.overviewRuler && node.options.overviewRuler.color ? true : false;
    const nodeIsInOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;
    this._onDidChangeDecorations.checkAffectedAndFire(node.options);
    this._onDidChangeDecorations.checkAffectedAndFire(options);
    if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {
      this._decorationsTree.delete(node);
      node.setOptions(options);
      this._decorationsTree.insert(node);
    } else {
      node.setOptions(options);
    }
  }
  _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {
    const versionId = this.getVersionId();
    const oldDecorationsLen = oldDecorationsIds.length;
    let oldDecorationIndex = 0;
    const newDecorationsLen = newDecorations.length;
    let newDecorationIndex = 0;
    let result = new Array(newDecorationsLen);
    while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {
      let node = null;
      if (oldDecorationIndex < oldDecorationsLen) {
        do {
          node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];
        } while (!node && oldDecorationIndex < oldDecorationsLen);
        if (node) {
          this._decorationsTree.delete(node);
          this._onDidChangeDecorations.checkAffectedAndFire(node.options);
        }
      }
      if (newDecorationIndex < newDecorationsLen) {
        if (!node) {
          const internalDecorationId = ++this._lastDecorationId;
          const decorationId = `${this._instanceId};${internalDecorationId}`;
          node = new IntervalNode(decorationId, 0, 0);
          this._decorations[decorationId] = node;
        }
        const newDecoration = newDecorations[newDecorationIndex];
        const range2 = this._validateRangeRelaxedNoAllocations(newDecoration.range);
        const options = _normalizeOptions(newDecoration.options);
        const startOffset = this._buffer.getOffsetAt(range2.startLineNumber, range2.startColumn);
        const endOffset = this._buffer.getOffsetAt(range2.endLineNumber, range2.endColumn);
        node.ownerId = ownerId;
        node.reset(versionId, startOffset, endOffset, range2);
        node.setOptions(options);
        this._onDidChangeDecorations.checkAffectedAndFire(options);
        this._decorationsTree.insert(node);
        result[newDecorationIndex] = node.id;
        newDecorationIndex++;
      } else {
        if (node) {
          delete this._decorations[node.id];
        }
      }
    }
    return result;
  }
  setTokens(tokens) {
    if (tokens.length === 0) {
      return;
    }
    let ranges = [];
    for (let i = 0, len = tokens.length; i < len; i++) {
      const element = tokens[i];
      let minChangedLineNumber = 0;
      let maxChangedLineNumber = 0;
      let hasChange = false;
      for (let j = 0, lenJ = element.tokens.length; j < lenJ; j++) {
        const lineNumber = element.startLineNumber + j;
        if (hasChange) {
          this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], false);
          maxChangedLineNumber = lineNumber;
        } else {
          const lineHasChange = this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], true);
          if (lineHasChange) {
            hasChange = true;
            minChangedLineNumber = lineNumber;
            maxChangedLineNumber = lineNumber;
          }
        }
      }
      if (hasChange) {
        ranges.push({fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber});
      }
    }
    if (ranges.length > 0) {
      this._emitModelTokensChangedEvent({
        tokenizationSupportChanged: false,
        semanticTokensApplied: false,
        ranges
      });
    }
  }
  setSemanticTokens(tokens, isComplete) {
    this._tokens2.set(tokens, isComplete);
    this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: false,
      semanticTokensApplied: tokens !== null,
      ranges: [{fromLineNumber: 1, toLineNumber: this.getLineCount()}]
    });
  }
  hasSemanticTokens() {
    return this._tokens2.isComplete();
  }
  setPartialSemanticTokens(range2, tokens) {
    if (this.hasSemanticTokens()) {
      return;
    }
    const changedRange = this._tokens2.setPartial(range2, tokens);
    this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: false,
      semanticTokensApplied: true,
      ranges: [{fromLineNumber: changedRange.startLineNumber, toLineNumber: changedRange.endLineNumber}]
    });
  }
  tokenizeViewport(startLineNumber, endLineNumber) {
    startLineNumber = Math.max(1, startLineNumber);
    endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);
    this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);
  }
  clearTokens() {
    this._tokens.flush();
    this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: true,
      semanticTokensApplied: false,
      ranges: [{
        fromLineNumber: 1,
        toLineNumber: this._buffer.getLineCount()
      }]
    });
  }
  _emitModelTokensChangedEvent(e) {
    if (!this._isDisposing) {
      this._onDidChangeTokens.fire(e);
    }
  }
  resetTokenization() {
    this._tokenization.reset();
  }
  forceTokenization(lineNumber) {
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    this._tokenization.forceTokenization(lineNumber);
  }
  isCheapToTokenize(lineNumber) {
    return this._tokenization.isCheapToTokenize(lineNumber);
  }
  tokenizeIfCheap(lineNumber) {
    if (this.isCheapToTokenize(lineNumber)) {
      this.forceTokenization(lineNumber);
    }
  }
  getLineTokens(lineNumber) {
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return this._getLineTokens(lineNumber);
  }
  _getLineTokens(lineNumber) {
    const lineText = this.getLineContent(lineNumber);
    const syntacticTokens = this._tokens.getTokens(this._languageIdentifier.id, lineNumber - 1, lineText);
    return this._tokens2.addSemanticTokens(lineNumber, syntacticTokens);
  }
  getLanguageIdentifier() {
    return this._languageIdentifier;
  }
  getModeId() {
    return this._languageIdentifier.language;
  }
  setMode(languageIdentifier) {
    if (this._languageIdentifier.id === languageIdentifier.id) {
      return;
    }
    let e = {
      oldLanguage: this._languageIdentifier.language,
      newLanguage: languageIdentifier.language
    };
    this._languageIdentifier = languageIdentifier;
    this._onDidChangeLanguage.fire(e);
    this._onDidChangeLanguageConfiguration.fire({});
  }
  getLanguageIdAtPosition(lineNumber, column) {
    const position = this.validatePosition(new Position(lineNumber, column));
    const lineTokens = this.getLineTokens(position.lineNumber);
    return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));
  }
  getWordAtPosition(_position) {
    this._assertNotDisposed();
    const position = this.validatePosition(_position);
    const lineContent = this.getLineContent(position.lineNumber);
    const lineTokens = this._getLineTokens(position.lineNumber);
    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
    const [rbStartOffset, rbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex);
    const rightBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex)), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);
    if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {
      return rightBiasedWord;
    }
    if (tokenIndex > 0 && rbStartOffset === position.column - 1) {
      const [lbStartOffset, lbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1);
      const leftBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex - 1)), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);
      if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {
        return leftBiasedWord;
      }
    }
    return null;
  }
  static _findLanguageBoundaries(lineTokens, tokenIndex) {
    const languageId = lineTokens.getLanguageId(tokenIndex);
    let startOffset = 0;
    for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {
      startOffset = lineTokens.getStartOffset(i);
    }
    let endOffset = lineTokens.getLineContent().length;
    for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {
      endOffset = lineTokens.getEndOffset(i);
    }
    return [startOffset, endOffset];
  }
  getWordUntilPosition(position) {
    const wordAtPosition = this.getWordAtPosition(position);
    if (!wordAtPosition) {
      return {
        word: "",
        startColumn: position.column,
        endColumn: position.column
      };
    }
    return {
      word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),
      startColumn: wordAtPosition.startColumn,
      endColumn: position.column
    };
  }
  findMatchingBracketUp(_bracket, _position) {
    let bracket = _bracket.toLowerCase();
    let position = this.validatePosition(_position);
    let lineTokens = this._getLineTokens(position.lineNumber);
    let languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));
    let bracketsSupport = LanguageConfigurationRegistry.getBracketsSupport(languageId);
    if (!bracketsSupport) {
      return null;
    }
    let data = bracketsSupport.textIsBracket[bracket];
    if (!data) {
      return null;
    }
    return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, null));
  }
  matchBracket(position) {
    return this._matchBracket(this.validatePosition(position));
  }
  _matchBracket(position) {
    const lineNumber = position.lineNumber;
    const lineTokens = this._getLineTokens(lineNumber);
    const tokenCount = lineTokens.getCount();
    const lineText = this._buffer.getLineContent(lineNumber);
    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
    if (tokenIndex < 0) {
      return null;
    }
    const currentModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));
    if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {
      let searchStartOffset = Math.max(0, position.column - 1 - currentModeBrackets.maxBracketLength);
      for (let i = tokenIndex - 1; i >= 0; i--) {
        const tokenEndOffset = lineTokens.getEndOffset(i);
        if (tokenEndOffset <= searchStartOffset) {
          break;
        }
        if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i))) {
          searchStartOffset = tokenEndOffset;
        }
      }
      const searchEndOffset = Math.min(lineText.length, position.column - 1 + currentModeBrackets.maxBracketLength);
      let bestResult = null;
      while (true) {
        const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (!foundBracket) {
          break;
        }
        if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();
          const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], null);
          if (r) {
            if (r instanceof BracketSearchCanceled) {
              return null;
            }
            bestResult = r;
          }
        }
        searchStartOffset = foundBracket.endColumn - 1;
      }
      if (bestResult) {
        return bestResult;
      }
    }
    if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {
      const prevTokenIndex = tokenIndex - 1;
      const prevModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(prevTokenIndex));
      if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {
        const searchStartOffset = Math.max(0, position.column - 1 - prevModeBrackets.maxBracketLength);
        let searchEndOffset = Math.min(lineText.length, position.column - 1 + prevModeBrackets.maxBracketLength);
        for (let i = prevTokenIndex + 1; i < tokenCount; i++) {
          const tokenStartOffset = lineTokens.getStartOffset(i);
          if (tokenStartOffset >= searchEndOffset) {
            break;
          }
          if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i))) {
            searchEndOffset = tokenStartOffset;
          }
        }
        const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();
          const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], null);
          if (r) {
            if (r instanceof BracketSearchCanceled) {
              return null;
            }
            return r;
          }
        }
      }
    }
    return null;
  }
  _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {
    if (!data) {
      return null;
    }
    const matched = isOpen ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate) : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate);
    if (!matched) {
      return null;
    }
    if (matched instanceof BracketSearchCanceled) {
      return matched;
    }
    return [foundBracket, matched];
  }
  _findMatchingBracketUp(bracket, position, continueSearchPredicate) {
    const languageId = bracket.languageIdentifier.id;
    const reversedBracketRegex = bracket.reversedRegex;
    let count = -1;
    let totalCallCount = 0;
    const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {
      while (true) {
        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {
          return BracketSearchCanceled.INSTANCE;
        }
        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (!r) {
          break;
        }
        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
        if (bracket.isOpen(hitText)) {
          count++;
        } else if (bracket.isClose(hitText)) {
          count--;
        }
        if (count === 0) {
          return r;
        }
        searchEndOffset = r.startColumn - 1;
      }
      return null;
    };
    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
      const lineTokens = this._getLineTokens(lineNumber);
      const tokenCount = lineTokens.getCount();
      const lineText = this._buffer.getLineContent(lineNumber);
      let tokenIndex = tokenCount - 1;
      let searchStartOffset = lineText.length;
      let searchEndOffset = lineText.length;
      if (lineNumber === position.lineNumber) {
        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        searchStartOffset = position.column - 1;
        searchEndOffset = position.column - 1;
      }
      let prevSearchInToken = true;
      for (; tokenIndex >= 0; tokenIndex--) {
        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
        if (searchInToken) {
          if (prevSearchInToken) {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
          } else {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          }
        } else {
          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return r;
            }
          }
        }
        prevSearchInToken = searchInToken;
      }
      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (r) {
          return r;
        }
      }
    }
    return null;
  }
  _findMatchingBracketDown(bracket, position, continueSearchPredicate) {
    const languageId = bracket.languageIdentifier.id;
    const bracketRegex = bracket.forwardRegex;
    let count = 1;
    let totalCallCount = 0;
    const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {
      while (true) {
        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {
          return BracketSearchCanceled.INSTANCE;
        }
        const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (!r) {
          break;
        }
        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
        if (bracket.isOpen(hitText)) {
          count++;
        } else if (bracket.isClose(hitText)) {
          count--;
        }
        if (count === 0) {
          return r;
        }
        searchStartOffset = r.endColumn - 1;
      }
      return null;
    };
    const lineCount = this.getLineCount();
    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {
      const lineTokens = this._getLineTokens(lineNumber);
      const tokenCount = lineTokens.getCount();
      const lineText = this._buffer.getLineContent(lineNumber);
      let tokenIndex = 0;
      let searchStartOffset = 0;
      let searchEndOffset = 0;
      if (lineNumber === position.lineNumber) {
        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        searchStartOffset = position.column - 1;
        searchEndOffset = position.column - 1;
      }
      let prevSearchInToken = true;
      for (; tokenIndex < tokenCount; tokenIndex++) {
        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
        if (searchInToken) {
          if (prevSearchInToken) {
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          } else {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          }
        } else {
          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return r;
            }
          }
        }
        prevSearchInToken = searchInToken;
      }
      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (r) {
          return r;
        }
      }
    }
    return null;
  }
  findPrevBracket(_position) {
    const position = this.validatePosition(_position);
    let languageId = -1;
    let modeBrackets = null;
    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
      const lineTokens = this._getLineTokens(lineNumber);
      const tokenCount = lineTokens.getCount();
      const lineText = this._buffer.getLineContent(lineNumber);
      let tokenIndex = tokenCount - 1;
      let searchStartOffset = lineText.length;
      let searchEndOffset = lineText.length;
      if (lineNumber === position.lineNumber) {
        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        searchStartOffset = position.column - 1;
        searchEndOffset = position.column - 1;
        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
        if (languageId !== tokenLanguageId) {
          languageId = tokenLanguageId;
          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);
        }
      }
      let prevSearchInToken = true;
      for (; tokenIndex >= 0; tokenIndex--) {
        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
        if (languageId !== tokenLanguageId) {
          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return this._toFoundBracket(modeBrackets, r);
            }
            prevSearchInToken = false;
          }
          languageId = tokenLanguageId;
          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);
        }
        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
        if (searchInToken) {
          if (prevSearchInToken) {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
          } else {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          }
        } else {
          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return this._toFoundBracket(modeBrackets, r);
            }
          }
        }
        prevSearchInToken = searchInToken;
      }
      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (r) {
          return this._toFoundBracket(modeBrackets, r);
        }
      }
    }
    return null;
  }
  findNextBracket(_position) {
    const position = this.validatePosition(_position);
    const lineCount = this.getLineCount();
    let languageId = -1;
    let modeBrackets = null;
    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {
      const lineTokens = this._getLineTokens(lineNumber);
      const tokenCount = lineTokens.getCount();
      const lineText = this._buffer.getLineContent(lineNumber);
      let tokenIndex = 0;
      let searchStartOffset = 0;
      let searchEndOffset = 0;
      if (lineNumber === position.lineNumber) {
        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        searchStartOffset = position.column - 1;
        searchEndOffset = position.column - 1;
        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
        if (languageId !== tokenLanguageId) {
          languageId = tokenLanguageId;
          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);
        }
      }
      let prevSearchInToken = true;
      for (; tokenIndex < tokenCount; tokenIndex++) {
        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
        if (languageId !== tokenLanguageId) {
          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return this._toFoundBracket(modeBrackets, r);
            }
            prevSearchInToken = false;
          }
          languageId = tokenLanguageId;
          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);
        }
        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
        if (searchInToken) {
          if (prevSearchInToken) {
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          } else {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          }
        } else {
          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return this._toFoundBracket(modeBrackets, r);
            }
          }
        }
        prevSearchInToken = searchInToken;
      }
      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (r) {
          return this._toFoundBracket(modeBrackets, r);
        }
      }
    }
    return null;
  }
  findEnclosingBrackets(_position, maxDuration) {
    let continueSearchPredicate;
    if (typeof maxDuration === "undefined") {
      continueSearchPredicate = null;
    } else {
      const startTime = Date.now();
      continueSearchPredicate = () => {
        return Date.now() - startTime <= maxDuration;
      };
    }
    const position = this.validatePosition(_position);
    const lineCount = this.getLineCount();
    const savedCounts = new Map();
    let counts = [];
    const resetCounts = (languageId2, modeBrackets2) => {
      if (!savedCounts.has(languageId2)) {
        let tmp = [];
        for (let i = 0, len = modeBrackets2 ? modeBrackets2.brackets.length : 0; i < len; i++) {
          tmp[i] = 0;
        }
        savedCounts.set(languageId2, tmp);
      }
      counts = savedCounts.get(languageId2);
    };
    let totalCallCount = 0;
    const searchInRange = (modeBrackets2, lineNumber, lineText, searchStartOffset, searchEndOffset) => {
      while (true) {
        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {
          return BracketSearchCanceled.INSTANCE;
        }
        const r = BracketsUtils.findNextBracketInRange(modeBrackets2.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (!r) {
          break;
        }
        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
        const bracket = modeBrackets2.textIsBracket[hitText];
        if (bracket) {
          if (bracket.isOpen(hitText)) {
            counts[bracket.index]++;
          } else if (bracket.isClose(hitText)) {
            counts[bracket.index]--;
          }
          if (counts[bracket.index] === -1) {
            return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);
          }
        }
        searchStartOffset = r.endColumn - 1;
      }
      return null;
    };
    let languageId = -1;
    let modeBrackets = null;
    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {
      const lineTokens = this._getLineTokens(lineNumber);
      const tokenCount = lineTokens.getCount();
      const lineText = this._buffer.getLineContent(lineNumber);
      let tokenIndex = 0;
      let searchStartOffset = 0;
      let searchEndOffset = 0;
      if (lineNumber === position.lineNumber) {
        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        searchStartOffset = position.column - 1;
        searchEndOffset = position.column - 1;
        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
        if (languageId !== tokenLanguageId) {
          languageId = tokenLanguageId;
          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);
          resetCounts(languageId, modeBrackets);
        }
      }
      let prevSearchInToken = true;
      for (; tokenIndex < tokenCount; tokenIndex++) {
        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
        if (languageId !== tokenLanguageId) {
          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return stripBracketSearchCanceled(r);
            }
            prevSearchInToken = false;
          }
          languageId = tokenLanguageId;
          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);
          resetCounts(languageId, modeBrackets);
        }
        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
        if (searchInToken) {
          if (prevSearchInToken) {
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          } else {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          }
        } else {
          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return stripBracketSearchCanceled(r);
            }
          }
        }
        prevSearchInToken = searchInToken;
      }
      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (r) {
          return stripBracketSearchCanceled(r);
        }
      }
    }
    return null;
  }
  _toFoundBracket(modeBrackets, r) {
    if (!r) {
      return null;
    }
    let text = this.getValueInRange(r);
    text = text.toLowerCase();
    let data = modeBrackets.textIsBracket[text];
    if (!data) {
      return null;
    }
    return {
      range: r,
      open: data.open,
      close: data.close,
      isOpen: modeBrackets.textIsOpenBracket[text]
    };
  }
  static computeIndentLevel(line, tabSize) {
    let indent = 0;
    let i = 0;
    let len = line.length;
    while (i < len) {
      let chCode = line.charCodeAt(i);
      if (chCode === 32) {
        indent++;
      } else if (chCode === 9) {
        indent = indent - indent % tabSize + tabSize;
      } else {
        break;
      }
      i++;
    }
    if (i === len) {
      return -1;
    }
    return indent;
  }
  _computeIndentLevel(lineIndex) {
    return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);
  }
  getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {
    this._assertNotDisposed();
    const lineCount = this.getLineCount();
    if (lineNumber < 1 || lineNumber > lineCount) {
      throw new Error("Illegal value for lineNumber");
    }
    const foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);
    const offSide = Boolean(foldingRules && foldingRules.offSide);
    let up_aboveContentLineIndex = -2;
    let up_aboveContentLineIndent = -1;
    let up_belowContentLineIndex = -2;
    let up_belowContentLineIndent = -1;
    const up_resolveIndents = (lineNumber2) => {
      if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber2 - 1)) {
        up_aboveContentLineIndex = -1;
        up_aboveContentLineIndent = -1;
        for (let lineIndex = lineNumber2 - 2; lineIndex >= 0; lineIndex--) {
          let indent2 = this._computeIndentLevel(lineIndex);
          if (indent2 >= 0) {
            up_aboveContentLineIndex = lineIndex;
            up_aboveContentLineIndent = indent2;
            break;
          }
        }
      }
      if (up_belowContentLineIndex === -2) {
        up_belowContentLineIndex = -1;
        up_belowContentLineIndent = -1;
        for (let lineIndex = lineNumber2; lineIndex < lineCount; lineIndex++) {
          let indent2 = this._computeIndentLevel(lineIndex);
          if (indent2 >= 0) {
            up_belowContentLineIndex = lineIndex;
            up_belowContentLineIndent = indent2;
            break;
          }
        }
      }
    };
    let down_aboveContentLineIndex = -2;
    let down_aboveContentLineIndent = -1;
    let down_belowContentLineIndex = -2;
    let down_belowContentLineIndent = -1;
    const down_resolveIndents = (lineNumber2) => {
      if (down_aboveContentLineIndex === -2) {
        down_aboveContentLineIndex = -1;
        down_aboveContentLineIndent = -1;
        for (let lineIndex = lineNumber2 - 2; lineIndex >= 0; lineIndex--) {
          let indent2 = this._computeIndentLevel(lineIndex);
          if (indent2 >= 0) {
            down_aboveContentLineIndex = lineIndex;
            down_aboveContentLineIndent = indent2;
            break;
          }
        }
      }
      if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber2 - 1)) {
        down_belowContentLineIndex = -1;
        down_belowContentLineIndent = -1;
        for (let lineIndex = lineNumber2; lineIndex < lineCount; lineIndex++) {
          let indent2 = this._computeIndentLevel(lineIndex);
          if (indent2 >= 0) {
            down_belowContentLineIndex = lineIndex;
            down_belowContentLineIndent = indent2;
            break;
          }
        }
      }
    };
    let startLineNumber = 0;
    let goUp = true;
    let endLineNumber = 0;
    let goDown = true;
    let indent = 0;
    let initialIndent = 0;
    for (let distance = 0; goUp || goDown; distance++) {
      const upLineNumber = lineNumber - distance;
      const downLineNumber = lineNumber + distance;
      if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {
        goUp = false;
      }
      if (distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {
        goDown = false;
      }
      if (distance > 5e4) {
        goUp = false;
        goDown = false;
      }
      let upLineIndentLevel = -1;
      if (goUp) {
        const currentIndent = this._computeIndentLevel(upLineNumber - 1);
        if (currentIndent >= 0) {
          up_belowContentLineIndex = upLineNumber - 1;
          up_belowContentLineIndent = currentIndent;
          upLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);
        } else {
          up_resolveIndents(upLineNumber);
          upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);
        }
      }
      let downLineIndentLevel = -1;
      if (goDown) {
        const currentIndent = this._computeIndentLevel(downLineNumber - 1);
        if (currentIndent >= 0) {
          down_aboveContentLineIndex = downLineNumber - 1;
          down_aboveContentLineIndent = currentIndent;
          downLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);
        } else {
          down_resolveIndents(downLineNumber);
          downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);
        }
      }
      if (distance === 0) {
        initialIndent = upLineIndentLevel;
        continue;
      }
      if (distance === 1) {
        if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {
          goUp = false;
          startLineNumber = downLineNumber;
          endLineNumber = downLineNumber;
          indent = downLineIndentLevel;
          continue;
        }
        if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {
          goDown = false;
          startLineNumber = upLineNumber;
          endLineNumber = upLineNumber;
          indent = upLineIndentLevel;
          continue;
        }
        startLineNumber = lineNumber;
        endLineNumber = lineNumber;
        indent = initialIndent;
        if (indent === 0) {
          return {startLineNumber, endLineNumber, indent};
        }
      }
      if (goUp) {
        if (upLineIndentLevel >= indent) {
          startLineNumber = upLineNumber;
        } else {
          goUp = false;
        }
      }
      if (goDown) {
        if (downLineIndentLevel >= indent) {
          endLineNumber = downLineNumber;
        } else {
          goDown = false;
        }
      }
    }
    return {startLineNumber, endLineNumber, indent};
  }
  getLinesIndentGuides(startLineNumber, endLineNumber) {
    this._assertNotDisposed();
    const lineCount = this.getLineCount();
    if (startLineNumber < 1 || startLineNumber > lineCount) {
      throw new Error("Illegal value for startLineNumber");
    }
    if (endLineNumber < 1 || endLineNumber > lineCount) {
      throw new Error("Illegal value for endLineNumber");
    }
    const foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);
    const offSide = Boolean(foldingRules && foldingRules.offSide);
    let result = new Array(endLineNumber - startLineNumber + 1);
    let aboveContentLineIndex = -2;
    let aboveContentLineIndent = -1;
    let belowContentLineIndex = -2;
    let belowContentLineIndent = -1;
    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      let resultIndex = lineNumber - startLineNumber;
      const currentIndent = this._computeIndentLevel(lineNumber - 1);
      if (currentIndent >= 0) {
        aboveContentLineIndex = lineNumber - 1;
        aboveContentLineIndent = currentIndent;
        result[resultIndex] = Math.ceil(currentIndent / this._options.indentSize);
        continue;
      }
      if (aboveContentLineIndex === -2) {
        aboveContentLineIndex = -1;
        aboveContentLineIndent = -1;
        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
          let indent = this._computeIndentLevel(lineIndex);
          if (indent >= 0) {
            aboveContentLineIndex = lineIndex;
            aboveContentLineIndent = indent;
            break;
          }
        }
      }
      if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {
        belowContentLineIndex = -1;
        belowContentLineIndent = -1;
        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {
          let indent = this._computeIndentLevel(lineIndex);
          if (indent >= 0) {
            belowContentLineIndex = lineIndex;
            belowContentLineIndent = indent;
            break;
          }
        }
      }
      result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);
    }
    return result;
  }
  _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {
    if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {
      return 0;
    } else if (aboveContentLineIndent < belowContentLineIndent) {
      return 1 + Math.floor(aboveContentLineIndent / this._options.indentSize);
    } else if (aboveContentLineIndent === belowContentLineIndent) {
      return Math.ceil(belowContentLineIndent / this._options.indentSize);
    } else {
      if (offSide) {
        return Math.ceil(belowContentLineIndent / this._options.indentSize);
      } else {
        return 1 + Math.floor(belowContentLineIndent / this._options.indentSize);
      }
    }
  }
};
TextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024;
TextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024;
TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1e3;
TextModel.DEFAULT_CREATION_OPTIONS = {
  isForSimpleWidget: false,
  tabSize: EDITOR_MODEL_DEFAULTS.tabSize,
  indentSize: EDITOR_MODEL_DEFAULTS.indentSize,
  insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,
  detectIndentation: false,
  defaultEOL: 1,
  trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,
  largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations
};
var DecorationsTrees = class {
  constructor() {
    this._decorationsTree0 = new IntervalTree();
    this._decorationsTree1 = new IntervalTree();
  }
  intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {
    const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);
    const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);
    return r0.concat(r1);
  }
  search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {
    if (overviewRulerOnly) {
      return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);
    } else {
      const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);
      const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);
      return r0.concat(r1);
    }
  }
  collectNodesFromOwner(ownerId) {
    const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);
    const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);
    return r0.concat(r1);
  }
  collectNodesPostOrder() {
    const r0 = this._decorationsTree0.collectNodesPostOrder();
    const r1 = this._decorationsTree1.collectNodesPostOrder();
    return r0.concat(r1);
  }
  insert(node) {
    if (getNodeIsInOverviewRuler(node)) {
      this._decorationsTree1.insert(node);
    } else {
      this._decorationsTree0.insert(node);
    }
  }
  delete(node) {
    if (getNodeIsInOverviewRuler(node)) {
      this._decorationsTree1.delete(node);
    } else {
      this._decorationsTree0.delete(node);
    }
  }
  resolveNode(node, cachedVersionId) {
    if (getNodeIsInOverviewRuler(node)) {
      this._decorationsTree1.resolveNode(node, cachedVersionId);
    } else {
      this._decorationsTree0.resolveNode(node, cachedVersionId);
    }
  }
  acceptReplace(offset, length, textLength, forceMoveMarkers) {
    this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);
    this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);
  }
};
function cleanClassName(className) {
  return className.replace(/[^a-z0-9\-_]/gi, " ");
}
var DecorationOptions = class {
  constructor(options) {
    this.color = options.color || "";
    this.darkColor = options.darkColor || "";
  }
};
var ModelDecorationOverviewRulerOptions = class extends DecorationOptions {
  constructor(options) {
    super(options);
    this._resolvedColor = null;
    this.position = typeof options.position === "number" ? options.position : OverviewRulerLane2.Center;
  }
  getColor(theme) {
    if (!this._resolvedColor) {
      if (theme.type !== "light" && this.darkColor) {
        this._resolvedColor = this._resolveColor(this.darkColor, theme);
      } else {
        this._resolvedColor = this._resolveColor(this.color, theme);
      }
    }
    return this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = null;
  }
  _resolveColor(color, theme) {
    if (typeof color === "string") {
      return color;
    }
    let c = color ? theme.getColor(color.id) : null;
    if (!c) {
      return "";
    }
    return c.toString();
  }
};
var ModelDecorationMinimapOptions = class extends DecorationOptions {
  constructor(options) {
    super(options);
    this.position = options.position;
  }
  getColor(theme) {
    if (!this._resolvedColor) {
      if (theme.type !== "light" && this.darkColor) {
        this._resolvedColor = this._resolveColor(this.darkColor, theme);
      } else {
        this._resolvedColor = this._resolveColor(this.color, theme);
      }
    }
    return this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = void 0;
  }
  _resolveColor(color, theme) {
    if (typeof color === "string") {
      return Color.fromHex(color);
    }
    return theme.getColor(color.id);
  }
};
var ModelDecorationOptions = class {
  constructor(options) {
    this.stickiness = options.stickiness || 0;
    this.zIndex = options.zIndex || 0;
    this.className = options.className ? cleanClassName(options.className) : null;
    this.hoverMessage = options.hoverMessage || null;
    this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;
    this.isWholeLine = options.isWholeLine || false;
    this.showIfCollapsed = options.showIfCollapsed || false;
    this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;
    this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;
    this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;
    this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;
    this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;
    this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;
    this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;
    this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;
    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;
    this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;
    this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;
  }
  static register(options) {
    return new ModelDecorationOptions(options);
  }
  static createDynamic(options) {
    return new ModelDecorationOptions(options);
  }
};
ModelDecorationOptions.EMPTY = ModelDecorationOptions.register({});
var TRACKED_RANGE_OPTIONS = [
  ModelDecorationOptions.register({stickiness: 0}),
  ModelDecorationOptions.register({stickiness: 1}),
  ModelDecorationOptions.register({stickiness: 2}),
  ModelDecorationOptions.register({stickiness: 3})
];
function _normalizeOptions(options) {
  if (options instanceof ModelDecorationOptions) {
    return options;
  }
  return ModelDecorationOptions.createDynamic(options);
}
var DidChangeDecorationsEmitter = class extends Disposable {
  constructor() {
    super();
    this._actual = this._register(new Emitter());
    this.event = this._actual.event;
    this._deferredCnt = 0;
    this._shouldFire = false;
    this._affectsMinimap = false;
    this._affectsOverviewRuler = false;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit() {
    this._deferredCnt--;
    if (this._deferredCnt === 0) {
      if (this._shouldFire) {
        const event = {
          affectsMinimap: this._affectsMinimap,
          affectsOverviewRuler: this._affectsOverviewRuler
        };
        this._shouldFire = false;
        this._affectsMinimap = false;
        this._affectsOverviewRuler = false;
        this._actual.fire(event);
      }
    }
  }
  checkAffectedAndFire(options) {
    if (!this._affectsMinimap) {
      this._affectsMinimap = options.minimap && options.minimap.position ? true : false;
    }
    if (!this._affectsOverviewRuler) {
      this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;
    }
    this._shouldFire = true;
  }
  fire() {
    this._affectsMinimap = true;
    this._affectsOverviewRuler = true;
    this._shouldFire = true;
  }
};
var DidChangeContentEmitter = class extends Disposable {
  constructor() {
    super();
    this._fastEmitter = this._register(new Emitter());
    this.fastEvent = this._fastEmitter.event;
    this._slowEmitter = this._register(new Emitter());
    this.slowEvent = this._slowEmitter.event;
    this._deferredCnt = 0;
    this._deferredEvent = null;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit(resultingSelection = null) {
    this._deferredCnt--;
    if (this._deferredCnt === 0) {
      if (this._deferredEvent !== null) {
        this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;
        const e = this._deferredEvent;
        this._deferredEvent = null;
        this._fastEmitter.fire(e);
        this._slowEmitter.fire(e);
      }
    }
  }
  fire(e) {
    if (this._deferredCnt > 0) {
      if (this._deferredEvent) {
        this._deferredEvent = this._deferredEvent.merge(e);
      } else {
        this._deferredEvent = e;
      }
      return;
    }
    this._fastEmitter.fire(e);
    this._slowEmitter.fire(e);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorCommon.js
var autoCloseAlways = () => true;
var autoCloseNever = () => false;
var autoCloseBeforeWhitespace = (chr) => chr === " " || chr === "	";
function appendEntry(target, key, value) {
  if (target.has(key)) {
    target.get(key).push(value);
  } else {
    target.set(key, [value]);
  }
}
var CursorConfiguration = class {
  constructor(languageIdentifier, modelOptions, configuration) {
    this._languageIdentifier = languageIdentifier;
    const options = configuration.options;
    const layoutInfo = options.get(117);
    this.readOnly = options.get(72);
    this.tabSize = modelOptions.tabSize;
    this.indentSize = modelOptions.indentSize;
    this.insertSpaces = modelOptions.insertSpaces;
    this.lineHeight = options.get(51);
    this.pageSize = Math.max(1, Math.floor(layoutInfo.height / this.lineHeight) - 2);
    this.useTabStops = options.get(104);
    this.wordSeparators = options.get(105);
    this.emptySelectionClipboard = options.get(26);
    this.copyWithSyntaxHighlighting = options.get(16);
    this.multiCursorMergeOverlapping = options.get(60);
    this.multiCursorPaste = options.get(62);
    this.autoClosingBrackets = options.get(5);
    this.autoClosingQuotes = options.get(7);
    this.autoClosingOvertype = options.get(6);
    this.autoSurround = options.get(10);
    this.autoIndent = options.get(8);
    this.autoClosingPairsOpen2 = new Map();
    this.autoClosingPairsClose2 = new Map();
    this.surroundingPairs = {};
    this._electricChars = null;
    this.shouldAutoCloseBefore = {
      quote: CursorConfiguration._getShouldAutoClose(languageIdentifier, this.autoClosingQuotes),
      bracket: CursorConfiguration._getShouldAutoClose(languageIdentifier, this.autoClosingBrackets)
    };
    let autoClosingPairs = CursorConfiguration._getAutoClosingPairs(languageIdentifier);
    if (autoClosingPairs) {
      for (const pair of autoClosingPairs) {
        appendEntry(this.autoClosingPairsOpen2, pair.open.charAt(pair.open.length - 1), pair);
        if (pair.close.length === 1) {
          appendEntry(this.autoClosingPairsClose2, pair.close, pair);
        }
      }
    }
    let surroundingPairs = CursorConfiguration._getSurroundingPairs(languageIdentifier);
    if (surroundingPairs) {
      for (const pair of surroundingPairs) {
        this.surroundingPairs[pair.open] = pair.close;
      }
    }
  }
  static shouldRecreate(e) {
    return e.hasChanged(117) || e.hasChanged(105) || e.hasChanged(26) || e.hasChanged(60) || e.hasChanged(62) || e.hasChanged(5) || e.hasChanged(7) || e.hasChanged(6) || e.hasChanged(10) || e.hasChanged(104) || e.hasChanged(51) || e.hasChanged(72);
  }
  get electricChars() {
    if (!this._electricChars) {
      this._electricChars = {};
      let electricChars = CursorConfiguration._getElectricCharacters(this._languageIdentifier);
      if (electricChars) {
        for (const char of electricChars) {
          this._electricChars[char] = true;
        }
      }
    }
    return this._electricChars;
  }
  normalizeIndentation(str) {
    return TextModel.normalizeIndentation(str, this.indentSize, this.insertSpaces);
  }
  static _getElectricCharacters(languageIdentifier) {
    try {
      return LanguageConfigurationRegistry.getElectricCharacters(languageIdentifier.id);
    } catch (e) {
      onUnexpectedError(e);
      return null;
    }
  }
  static _getAutoClosingPairs(languageIdentifier) {
    try {
      return LanguageConfigurationRegistry.getAutoClosingPairs(languageIdentifier.id);
    } catch (e) {
      onUnexpectedError(e);
      return null;
    }
  }
  static _getShouldAutoClose(languageIdentifier, autoCloseConfig) {
    switch (autoCloseConfig) {
      case "beforeWhitespace":
        return autoCloseBeforeWhitespace;
      case "languageDefined":
        return CursorConfiguration._getLanguageDefinedShouldAutoClose(languageIdentifier);
      case "always":
        return autoCloseAlways;
      case "never":
        return autoCloseNever;
    }
  }
  static _getLanguageDefinedShouldAutoClose(languageIdentifier) {
    try {
      const autoCloseBeforeSet = LanguageConfigurationRegistry.getAutoCloseBeforeSet(languageIdentifier.id);
      return (c) => autoCloseBeforeSet.indexOf(c) !== -1;
    } catch (e) {
      onUnexpectedError(e);
      return autoCloseNever;
    }
  }
  static _getSurroundingPairs(languageIdentifier) {
    try {
      return LanguageConfigurationRegistry.getSurroundingPairs(languageIdentifier.id);
    } catch (e) {
      onUnexpectedError(e);
      return null;
    }
  }
};
var SingleCursorState = class {
  constructor(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {
    this.selectionStart = selectionStart;
    this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;
    this.position = position;
    this.leftoverVisibleColumns = leftoverVisibleColumns;
    this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);
  }
  equals(other) {
    return this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns && this.leftoverVisibleColumns === other.leftoverVisibleColumns && this.position.equals(other.position) && this.selectionStart.equalsRange(other.selectionStart);
  }
  hasSelection() {
    return !this.selection.isEmpty() || !this.selectionStart.isEmpty();
  }
  move(inSelectionMode, lineNumber, column, leftoverVisibleColumns) {
    if (inSelectionMode) {
      return new SingleCursorState(this.selectionStart, this.selectionStartLeftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);
    } else {
      return new SingleCursorState(new Range(lineNumber, column, lineNumber, column), leftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);
    }
  }
  static _computeSelection(selectionStart, position) {
    let startLineNumber, startColumn, endLineNumber, endColumn;
    if (selectionStart.isEmpty()) {
      startLineNumber = selectionStart.startLineNumber;
      startColumn = selectionStart.startColumn;
      endLineNumber = position.lineNumber;
      endColumn = position.column;
    } else {
      if (position.isBeforeOrEqual(selectionStart.getStartPosition())) {
        startLineNumber = selectionStart.endLineNumber;
        startColumn = selectionStart.endColumn;
        endLineNumber = position.lineNumber;
        endColumn = position.column;
      } else {
        startLineNumber = selectionStart.startLineNumber;
        startColumn = selectionStart.startColumn;
        endLineNumber = position.lineNumber;
        endColumn = position.column;
      }
    }
    return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
  }
};
var CursorContext = class {
  constructor(model2, coordinatesConverter, cursorConfig) {
    this.model = model2;
    this.coordinatesConverter = coordinatesConverter;
    this.cursorConfig = cursorConfig;
  }
};
var PartialModelCursorState = class {
  constructor(modelState) {
    this.modelState = modelState;
    this.viewState = null;
  }
};
var PartialViewCursorState = class {
  constructor(viewState) {
    this.modelState = null;
    this.viewState = viewState;
  }
};
var CursorState = class {
  constructor(modelState, viewState) {
    this.modelState = modelState;
    this.viewState = viewState;
  }
  static fromModelState(modelState) {
    return new PartialModelCursorState(modelState);
  }
  static fromViewState(viewState) {
    return new PartialViewCursorState(viewState);
  }
  static fromModelSelection(modelSelection) {
    const selectionStartLineNumber = modelSelection.selectionStartLineNumber;
    const selectionStartColumn = modelSelection.selectionStartColumn;
    const positionLineNumber = modelSelection.positionLineNumber;
    const positionColumn = modelSelection.positionColumn;
    const modelState = new SingleCursorState(new Range(selectionStartLineNumber, selectionStartColumn, selectionStartLineNumber, selectionStartColumn), 0, new Position(positionLineNumber, positionColumn), 0);
    return CursorState.fromModelState(modelState);
  }
  static fromModelSelections(modelSelections) {
    let states = [];
    for (let i = 0, len = modelSelections.length; i < len; i++) {
      states[i] = this.fromModelSelection(modelSelections[i]);
    }
    return states;
  }
  equals(other) {
    return this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState);
  }
};
var EditOperationResult = class {
  constructor(type, commands, opts) {
    this.type = type;
    this.commands = commands;
    this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;
    this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;
  }
};
var CursorColumns = class {
  static visibleColumnFromColumn(lineContent, column, tabSize) {
    const lineContentLength = lineContent.length;
    const endOffset = column - 1 < lineContentLength ? column - 1 : lineContentLength;
    let result = 0;
    let i = 0;
    while (i < endOffset) {
      const codePoint = getNextCodePoint(lineContent, endOffset, i);
      i += codePoint >= 65536 ? 2 : 1;
      if (codePoint === 9) {
        result = CursorColumns.nextRenderTabStop(result, tabSize);
      } else {
        let graphemeBreakType = getGraphemeBreakType(codePoint);
        while (i < endOffset) {
          const nextCodePoint = getNextCodePoint(lineContent, endOffset, i);
          const nextGraphemeBreakType = getGraphemeBreakType(nextCodePoint);
          if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
            break;
          }
          i += nextCodePoint >= 65536 ? 2 : 1;
          graphemeBreakType = nextGraphemeBreakType;
        }
        if (isFullWidthCharacter(codePoint) || isEmojiImprecise(codePoint)) {
          result = result + 2;
        } else {
          result = result + 1;
        }
      }
    }
    return result;
  }
  static visibleColumnFromColumn2(config, model2, position) {
    return this.visibleColumnFromColumn(model2.getLineContent(position.lineNumber), position.column, config.tabSize);
  }
  static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {
    if (visibleColumn <= 0) {
      return 1;
    }
    const lineLength = lineContent.length;
    let beforeVisibleColumn = 0;
    let beforeColumn = 1;
    let i = 0;
    while (i < lineLength) {
      const codePoint = getNextCodePoint(lineContent, lineLength, i);
      i += codePoint >= 65536 ? 2 : 1;
      let afterVisibleColumn;
      if (codePoint === 9) {
        afterVisibleColumn = CursorColumns.nextRenderTabStop(beforeVisibleColumn, tabSize);
      } else {
        let graphemeBreakType = getGraphemeBreakType(codePoint);
        while (i < lineLength) {
          const nextCodePoint = getNextCodePoint(lineContent, lineLength, i);
          const nextGraphemeBreakType = getGraphemeBreakType(nextCodePoint);
          if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
            break;
          }
          i += nextCodePoint >= 65536 ? 2 : 1;
          graphemeBreakType = nextGraphemeBreakType;
        }
        if (isFullWidthCharacter(codePoint) || isEmojiImprecise(codePoint)) {
          afterVisibleColumn = beforeVisibleColumn + 2;
        } else {
          afterVisibleColumn = beforeVisibleColumn + 1;
        }
      }
      const afterColumn = i + 1;
      if (afterVisibleColumn >= visibleColumn) {
        const beforeDelta = visibleColumn - beforeVisibleColumn;
        const afterDelta = afterVisibleColumn - visibleColumn;
        if (afterDelta < beforeDelta) {
          return afterColumn;
        } else {
          return beforeColumn;
        }
      }
      beforeVisibleColumn = afterVisibleColumn;
      beforeColumn = afterColumn;
    }
    return lineLength + 1;
  }
  static columnFromVisibleColumn2(config, model2, lineNumber, visibleColumn) {
    let result = this.columnFromVisibleColumn(model2.getLineContent(lineNumber), visibleColumn, config.tabSize);
    let minColumn = model2.getLineMinColumn(lineNumber);
    if (result < minColumn) {
      return minColumn;
    }
    let maxColumn = model2.getLineMaxColumn(lineNumber);
    if (result > maxColumn) {
      return maxColumn;
    }
    return result;
  }
  static nextRenderTabStop(visibleColumn, tabSize) {
    return visibleColumn + tabSize - visibleColumn % tabSize;
  }
  static nextIndentTabStop(visibleColumn, indentSize) {
    return visibleColumn + indentSize - visibleColumn % indentSize;
  }
  static prevRenderTabStop(column, tabSize) {
    return column - 1 - (column - 1) % tabSize;
  }
  static prevIndentTabStop(column, indentSize) {
    return column - 1 - (column - 1) % indentSize;
  }
};
function isQuote(ch) {
  return ch === "'" || ch === '"' || ch === "`";
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/controller/mouseTarget.js
var PointerHandlerLastRenderData = class {
  constructor(lastViewCursorsRenderData, lastTextareaPosition) {
    this.lastViewCursorsRenderData = lastViewCursorsRenderData;
    this.lastTextareaPosition = lastTextareaPosition;
  }
};
var MouseTarget = class {
  constructor(element, type, mouseColumn = 0, position = null, range2 = null, detail = null) {
    this.element = element;
    this.type = type;
    this.mouseColumn = mouseColumn;
    this.position = position;
    if (!range2 && position) {
      range2 = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
    }
    this.range = range2;
    this.detail = detail;
  }
  static _typeToString(type) {
    if (type === 1) {
      return "TEXTAREA";
    }
    if (type === 2) {
      return "GUTTER_GLYPH_MARGIN";
    }
    if (type === 3) {
      return "GUTTER_LINE_NUMBERS";
    }
    if (type === 4) {
      return "GUTTER_LINE_DECORATIONS";
    }
    if (type === 5) {
      return "GUTTER_VIEW_ZONE";
    }
    if (type === 6) {
      return "CONTENT_TEXT";
    }
    if (type === 7) {
      return "CONTENT_EMPTY";
    }
    if (type === 8) {
      return "CONTENT_VIEW_ZONE";
    }
    if (type === 9) {
      return "CONTENT_WIDGET";
    }
    if (type === 10) {
      return "OVERVIEW_RULER";
    }
    if (type === 11) {
      return "SCROLLBAR";
    }
    if (type === 12) {
      return "OVERLAY_WIDGET";
    }
    return "UNKNOWN";
  }
  static toString(target) {
    return this._typeToString(target.type) + ": " + target.position + " - " + target.range + " - " + target.detail;
  }
  toString() {
    return MouseTarget.toString(this);
  }
};
var ElementPath = class {
  static isTextArea(path) {
    return path.length === 2 && path[0] === 3 && path[1] === 6;
  }
  static isChildOfViewLines(path) {
    return path.length >= 4 && path[0] === 3 && path[3] === 7;
  }
  static isStrictChildOfViewLines(path) {
    return path.length > 4 && path[0] === 3 && path[3] === 7;
  }
  static isChildOfScrollableElement(path) {
    return path.length >= 2 && path[0] === 3 && path[1] === 5;
  }
  static isChildOfMinimap(path) {
    return path.length >= 2 && path[0] === 3 && path[1] === 8;
  }
  static isChildOfContentWidgets(path) {
    return path.length >= 4 && path[0] === 3 && path[3] === 1;
  }
  static isChildOfOverflowingContentWidgets(path) {
    return path.length >= 1 && path[0] === 2;
  }
  static isChildOfOverlayWidgets(path) {
    return path.length >= 2 && path[0] === 3 && path[1] === 4;
  }
};
var HitTestContext = class {
  constructor(context, viewHelper, lastRenderData) {
    this.model = context.model;
    const options = context.configuration.options;
    this.layoutInfo = options.get(117);
    this.viewDomNode = viewHelper.viewDomNode;
    this.lineHeight = options.get(51);
    this.typicalHalfwidthCharacterWidth = options.get(36).typicalHalfwidthCharacterWidth;
    this.lastRenderData = lastRenderData;
    this._context = context;
    this._viewHelper = viewHelper;
  }
  getZoneAtCoord(mouseVerticalOffset) {
    return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);
  }
  static getZoneAtCoord(context, mouseVerticalOffset) {
    const viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);
    if (viewZoneWhitespace) {
      let viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2, lineCount = context.model.getLineCount(), positionBefore = null, position, positionAfter = null;
      if (viewZoneWhitespace.afterLineNumber !== lineCount) {
        positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);
      }
      if (viewZoneWhitespace.afterLineNumber > 0) {
        positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.model.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));
      }
      if (positionAfter === null) {
        position = positionBefore;
      } else if (positionBefore === null) {
        position = positionAfter;
      } else if (mouseVerticalOffset < viewZoneMiddle) {
        position = positionBefore;
      } else {
        position = positionAfter;
      }
      return {
        viewZoneId: viewZoneWhitespace.id,
        afterLineNumber: viewZoneWhitespace.afterLineNumber,
        positionBefore,
        positionAfter,
        position
      };
    }
    return null;
  }
  getFullLineRangeAtCoord(mouseVerticalOffset) {
    if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {
      const lineNumber2 = this._context.model.getLineCount();
      const maxLineColumn2 = this._context.model.getLineMaxColumn(lineNumber2);
      return {
        range: new Range(lineNumber2, maxLineColumn2, lineNumber2, maxLineColumn2),
        isAfterLines: true
      };
    }
    const lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);
    const maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);
    return {
      range: new Range(lineNumber, 1, lineNumber, maxLineColumn),
      isAfterLines: false
    };
  }
  getLineNumberAtVerticalOffset(mouseVerticalOffset) {
    return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);
  }
  isAfterLines(mouseVerticalOffset) {
    return this._context.viewLayout.isAfterLines(mouseVerticalOffset);
  }
  getVerticalOffsetForLineNumber(lineNumber) {
    return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);
  }
  findAttribute(element, attr) {
    return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);
  }
  static _findAttribute(element, attr, stopAt) {
    while (element && element !== document.body) {
      if (element.hasAttribute && element.hasAttribute(attr)) {
        return element.getAttribute(attr);
      }
      if (element === stopAt) {
        return null;
      }
      element = element.parentNode;
    }
    return null;
  }
  getLineWidth(lineNumber) {
    return this._viewHelper.getLineWidth(lineNumber);
  }
  visibleRangeForPosition(lineNumber, column) {
    return this._viewHelper.visibleRangeForPosition(lineNumber, column);
  }
  getPositionFromDOMInfo(spanNode, offset) {
    return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);
  }
  getCurrentScrollTop() {
    return this._context.viewLayout.getCurrentScrollTop();
  }
  getCurrentScrollLeft() {
    return this._context.viewLayout.getCurrentScrollLeft();
  }
};
var BareHitTestRequest = class {
  constructor(ctx, editorPos, pos) {
    this.editorPos = editorPos;
    this.pos = pos;
    this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + pos.y - editorPos.y);
    this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + pos.x - editorPos.x - ctx.layoutInfo.contentLeft;
    this.isInMarginArea = pos.x - editorPos.x < ctx.layoutInfo.contentLeft && pos.x - editorPos.x >= ctx.layoutInfo.glyphMarginLeft;
    this.isInContentArea = !this.isInMarginArea;
    this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));
  }
};
var HitTestRequest = class extends BareHitTestRequest {
  constructor(ctx, editorPos, pos, target) {
    super(ctx, editorPos, pos);
    this._ctx = ctx;
    if (target) {
      this.target = target;
      this.targetPath = PartFingerprints.collect(target, ctx.viewDomNode);
    } else {
      this.target = null;
      this.targetPath = new Uint8Array(0);
    }
  }
  toString() {
    return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}
	target: ${this.target ? this.target.outerHTML : null}`;
  }
  fulfill(type, position = null, range2 = null, detail = null) {
    let mouseColumn = this.mouseColumn;
    if (position && position.column < this._ctx.model.getLineMaxColumn(position.lineNumber)) {
      mouseColumn = CursorColumns.visibleColumnFromColumn(this._ctx.model.getLineContent(position.lineNumber), position.column, this._ctx.model.getTextModelOptions().tabSize) + 1;
    }
    return new MouseTarget(this.target, type, mouseColumn, position, range2, detail);
  }
  withTarget(target) {
    return new HitTestRequest(this._ctx, this.editorPos, this.pos, target);
  }
};
var EMPTY_CONTENT_AFTER_LINES = {isAfterLines: true};
function createEmptyContentDataInLines(horizontalDistanceToText) {
  return {
    isAfterLines: false,
    horizontalDistanceToText
  };
}
var MouseTargetFactory = class {
  constructor(context, viewHelper) {
    this._context = context;
    this._viewHelper = viewHelper;
  }
  mouseTargetIsWidget(e) {
    const t = e.target;
    const path = PartFingerprints.collect(t, this._viewHelper.viewDomNode);
    if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {
      return true;
    }
    if (ElementPath.isChildOfOverlayWidgets(path)) {
      return true;
    }
    return false;
  }
  createMouseTarget(lastRenderData, editorPos, pos, target) {
    const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);
    const request = new HitTestRequest(ctx, editorPos, pos, target);
    try {
      const r = MouseTargetFactory._createMouseTarget(ctx, request, false);
      return r;
    } catch (err) {
      return request.fulfill(0);
    }
  }
  static _createMouseTarget(ctx, request, domHitTestExecuted) {
    if (request.target === null) {
      if (domHitTestExecuted) {
        return request.fulfill(0);
      }
      const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);
      if (hitTestResult.position) {
        return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);
      }
      return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);
    }
    const resolvedRequest = request;
    let result = null;
    result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);
    result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);
    result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);
    result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);
    result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);
    result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);
    result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);
    result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);
    result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest, domHitTestExecuted);
    result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);
    return result || request.fulfill(0);
  }
  static _hitTestContentWidget(ctx, request) {
    if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {
      const widgetId = ctx.findAttribute(request.target, "widgetId");
      if (widgetId) {
        return request.fulfill(9, null, null, widgetId);
      } else {
        return request.fulfill(0);
      }
    }
    return null;
  }
  static _hitTestOverlayWidget(ctx, request) {
    if (ElementPath.isChildOfOverlayWidgets(request.targetPath)) {
      const widgetId = ctx.findAttribute(request.target, "widgetId");
      if (widgetId) {
        return request.fulfill(12, null, null, widgetId);
      } else {
        return request.fulfill(0);
      }
    }
    return null;
  }
  static _hitTestViewCursor(ctx, request) {
    if (request.target) {
      const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;
      for (const d of lastViewCursorsRenderData) {
        if (request.target === d.domNode) {
          return request.fulfill(6, d.position);
        }
      }
    }
    if (request.isInContentArea) {
      const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;
      const mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;
      const mouseVerticalOffset = request.mouseVerticalOffset;
      for (const d of lastViewCursorsRenderData) {
        if (mouseContentHorizontalOffset < d.contentLeft) {
          continue;
        }
        if (mouseContentHorizontalOffset > d.contentLeft + d.width) {
          continue;
        }
        const cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);
        if (cursorVerticalOffset <= mouseVerticalOffset && mouseVerticalOffset <= cursorVerticalOffset + d.height) {
          return request.fulfill(6, d.position);
        }
      }
    }
    return null;
  }
  static _hitTestViewZone(ctx, request) {
    const viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);
    if (viewZoneData) {
      const mouseTargetType = request.isInContentArea ? 8 : 5;
      return request.fulfill(mouseTargetType, viewZoneData.position, null, viewZoneData);
    }
    return null;
  }
  static _hitTestTextArea(ctx, request) {
    if (ElementPath.isTextArea(request.targetPath)) {
      if (ctx.lastRenderData.lastTextareaPosition) {
        return request.fulfill(6, ctx.lastRenderData.lastTextareaPosition);
      }
      return request.fulfill(1, ctx.lastRenderData.lastTextareaPosition);
    }
    return null;
  }
  static _hitTestMargin(ctx, request) {
    if (request.isInMarginArea) {
      const res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);
      const pos = res.range.getStartPosition();
      let offset = Math.abs(request.pos.x - request.editorPos.x);
      const detail = {
        isAfterLines: res.isAfterLines,
        glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,
        glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,
        lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,
        offsetX: offset
      };
      offset -= ctx.layoutInfo.glyphMarginLeft;
      if (offset <= ctx.layoutInfo.glyphMarginWidth) {
        return request.fulfill(2, pos, res.range, detail);
      }
      offset -= ctx.layoutInfo.glyphMarginWidth;
      if (offset <= ctx.layoutInfo.lineNumbersWidth) {
        return request.fulfill(3, pos, res.range, detail);
      }
      offset -= ctx.layoutInfo.lineNumbersWidth;
      return request.fulfill(4, pos, res.range, detail);
    }
    return null;
  }
  static _hitTestViewLines(ctx, request, domHitTestExecuted) {
    if (!ElementPath.isChildOfViewLines(request.targetPath)) {
      return null;
    }
    if (ctx.isAfterLines(request.mouseVerticalOffset)) {
      const lineCount = ctx.model.getLineCount();
      const maxLineColumn = ctx.model.getLineMaxColumn(lineCount);
      return request.fulfill(7, new Position(lineCount, maxLineColumn), void 0, EMPTY_CONTENT_AFTER_LINES);
    }
    if (domHitTestExecuted) {
      if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {
        const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
        if (ctx.model.getLineLength(lineNumber) === 0) {
          const lineWidth2 = ctx.getLineWidth(lineNumber);
          const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth2);
          return request.fulfill(7, new Position(lineNumber, 1), void 0, detail);
        }
        const lineWidth = ctx.getLineWidth(lineNumber);
        if (request.mouseContentHorizontalOffset >= lineWidth) {
          const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);
          const pos = new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber));
          return request.fulfill(7, pos, void 0, detail);
        }
      }
      return request.fulfill(0);
    }
    const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);
    if (hitTestResult.position) {
      return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);
    }
    return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);
  }
  static _hitTestMinimap(ctx, request) {
    if (ElementPath.isChildOfMinimap(request.targetPath)) {
      const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
      const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);
      return request.fulfill(11, new Position(possibleLineNumber, maxColumn));
    }
    return null;
  }
  static _hitTestScrollbarSlider(ctx, request) {
    if (ElementPath.isChildOfScrollableElement(request.targetPath)) {
      if (request.target && request.target.nodeType === 1) {
        const className = request.target.className;
        if (className && /\b(slider|scrollbar)\b/.test(className)) {
          const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
          const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);
          return request.fulfill(11, new Position(possibleLineNumber, maxColumn));
        }
      }
    }
    return null;
  }
  static _hitTestScrollbar(ctx, request) {
    if (ElementPath.isChildOfScrollableElement(request.targetPath)) {
      const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
      const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);
      return request.fulfill(11, new Position(possibleLineNumber, maxColumn));
    }
    return null;
  }
  getMouseColumn(editorPos, pos) {
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    const mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + pos.x - editorPos.x - layoutInfo.contentLeft;
    return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(36).typicalHalfwidthCharacterWidth);
  }
  static _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {
    if (mouseContentHorizontalOffset < 0) {
      return 1;
    }
    const chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);
    return chars + 1;
  }
  static createMouseTargetFromHitTestPosition(ctx, request, lineNumber, column) {
    const pos = new Position(lineNumber, column);
    const lineWidth = ctx.getLineWidth(lineNumber);
    if (request.mouseContentHorizontalOffset > lineWidth) {
      if (isEdge && pos.column === 1) {
        const detail2 = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);
        return request.fulfill(7, new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber)), void 0, detail2);
      }
      const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);
      return request.fulfill(7, pos, void 0, detail);
    }
    const visibleRange = ctx.visibleRangeForPosition(lineNumber, column);
    if (!visibleRange) {
      return request.fulfill(0, pos);
    }
    const columnHorizontalOffset = visibleRange.left;
    if (request.mouseContentHorizontalOffset === columnHorizontalOffset) {
      return request.fulfill(6, pos);
    }
    const points = [];
    points.push({offset: visibleRange.left, column});
    if (column > 1) {
      const visibleRange2 = ctx.visibleRangeForPosition(lineNumber, column - 1);
      if (visibleRange2) {
        points.push({offset: visibleRange2.left, column: column - 1});
      }
    }
    const lineMaxColumn = ctx.model.getLineMaxColumn(lineNumber);
    if (column < lineMaxColumn) {
      const visibleRange2 = ctx.visibleRangeForPosition(lineNumber, column + 1);
      if (visibleRange2) {
        points.push({offset: visibleRange2.left, column: column + 1});
      }
    }
    points.sort((a, b) => a.offset - b.offset);
    for (let i = 1; i < points.length; i++) {
      const prev = points[i - 1];
      const curr = points[i];
      if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {
        const rng = new Range(lineNumber, prev.column, lineNumber, curr.column);
        return request.fulfill(6, pos, rng);
      }
    }
    return request.fulfill(6, pos);
  }
  static _doHitTestWithCaretRangeFromPoint(ctx, request) {
    const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
    const lineVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);
    const lineCenteredVerticalOffset = lineVerticalOffset + Math.floor(ctx.lineHeight / 2);
    let adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);
    if (adjustedPageY <= request.editorPos.y) {
      adjustedPageY = request.editorPos.y + 1;
    }
    if (adjustedPageY >= request.editorPos.y + ctx.layoutInfo.height) {
      adjustedPageY = request.editorPos.y + ctx.layoutInfo.height - 1;
    }
    const adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);
    const r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates());
    if (r.position) {
      return r;
    }
    return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates());
  }
  static _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {
    const shadowRoot = getShadowRoot(ctx.viewDomNode);
    let range2;
    if (shadowRoot) {
      if (typeof shadowRoot.caretRangeFromPoint === "undefined") {
        range2 = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);
      } else {
        range2 = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);
      }
    } else {
      range2 = document.caretRangeFromPoint(coords.clientX, coords.clientY);
    }
    if (!range2 || !range2.startContainer) {
      return {
        position: null,
        hitTarget: null
      };
    }
    const startContainer = range2.startContainer;
    let hitTarget = null;
    if (startContainer.nodeType === startContainer.TEXT_NODE) {
      const parent1 = startContainer.parentNode;
      const parent2 = parent1 ? parent1.parentNode : null;
      const parent3 = parent2 ? parent2.parentNode : null;
      const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;
      if (parent3ClassName === ViewLine.CLASS_NAME) {
        const p = ctx.getPositionFromDOMInfo(parent1, range2.startOffset);
        return {
          position: p,
          hitTarget: null
        };
      } else {
        hitTarget = startContainer.parentNode;
      }
    } else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {
      const parent1 = startContainer.parentNode;
      const parent2 = parent1 ? parent1.parentNode : null;
      const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;
      if (parent2ClassName === ViewLine.CLASS_NAME) {
        const p = ctx.getPositionFromDOMInfo(startContainer, startContainer.textContent.length);
        return {
          position: p,
          hitTarget: null
        };
      } else {
        hitTarget = startContainer;
      }
    }
    return {
      position: null,
      hitTarget
    };
  }
  static _doHitTestWithCaretPositionFromPoint(ctx, coords) {
    const hitResult = document.caretPositionFromPoint(coords.clientX, coords.clientY);
    if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {
      const parent1 = hitResult.offsetNode.parentNode;
      const parent2 = parent1 ? parent1.parentNode : null;
      const parent3 = parent2 ? parent2.parentNode : null;
      const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;
      if (parent3ClassName === ViewLine.CLASS_NAME) {
        const p = ctx.getPositionFromDOMInfo(hitResult.offsetNode.parentNode, hitResult.offset);
        return {
          position: p,
          hitTarget: null
        };
      } else {
        return {
          position: null,
          hitTarget: hitResult.offsetNode.parentNode
        };
      }
    }
    if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {
      const parent1 = hitResult.offsetNode.parentNode;
      const parent1ClassName = parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null;
      if (parent1ClassName === ViewLine.CLASS_NAME) {
        const tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];
        if (tokenSpan) {
          const p = ctx.getPositionFromDOMInfo(tokenSpan, 0);
          return {
            position: p,
            hitTarget: null
          };
        }
      }
    }
    return {
      position: null,
      hitTarget: hitResult.offsetNode
    };
  }
  static _doHitTestWithMoveToPoint(ctx, coords) {
    let resultPosition = null;
    let resultHitTarget = null;
    const textRange = document.body.createTextRange();
    try {
      textRange.moveToPoint(coords.clientX, coords.clientY);
    } catch (err) {
      return {
        position: null,
        hitTarget: null
      };
    }
    textRange.collapse(true);
    const parentElement = textRange ? textRange.parentElement() : null;
    const parent1 = parentElement ? parentElement.parentNode : null;
    const parent2 = parent1 ? parent1.parentNode : null;
    const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : "";
    if (parent2ClassName === ViewLine.CLASS_NAME) {
      const rangeToContainEntireSpan = textRange.duplicate();
      rangeToContainEntireSpan.moveToElementText(parentElement);
      rangeToContainEntireSpan.setEndPoint("EndToStart", textRange);
      resultPosition = ctx.getPositionFromDOMInfo(parentElement, rangeToContainEntireSpan.text.length);
      rangeToContainEntireSpan.moveToElementText(ctx.viewDomNode);
    } else {
      resultHitTarget = parentElement;
    }
    textRange.moveToElementText(ctx.viewDomNode);
    return {
      position: resultPosition,
      hitTarget: resultHitTarget
    };
  }
  static _doHitTest(ctx, request) {
    if (typeof document.caretRangeFromPoint === "function") {
      return this._doHitTestWithCaretRangeFromPoint(ctx, request);
    } else if (document.caretPositionFromPoint) {
      return this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates());
    } else if (document.body.createTextRange) {
      return this._doHitTestWithMoveToPoint(ctx, request.pos.toClientCoordinates());
    }
    return {
      position: null,
      hitTarget: null
    };
  }
};
function shadowCaretRangeFromPoint(shadowRoot, x, y) {
  const range2 = document.createRange();
  let el = shadowRoot.elementFromPoint(x, y);
  if (el !== null) {
    while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE) {
      el = el.lastChild;
    }
    const rect = el.getBoundingClientRect();
    const font = window.getComputedStyle(el, null).getPropertyValue("font");
    const text = el.innerText;
    let pixelCursor = rect.left;
    let offset = 0;
    let step;
    if (x > rect.left + rect.width) {
      offset = text.length;
    } else {
      const charWidthReader = CharWidthReader.getInstance();
      for (let i = 0; i < text.length + 1; i++) {
        step = charWidthReader.getCharWidth(text.charAt(i), font) / 2;
        pixelCursor += step;
        if (x < pixelCursor) {
          offset = i;
          break;
        }
        pixelCursor += step;
      }
    }
    range2.setStart(el.firstChild, offset);
    range2.setEnd(el.firstChild, offset);
  }
  return range2;
}
var CharWidthReader = class {
  constructor() {
    this._cache = {};
    this._canvas = document.createElement("canvas");
  }
  static getInstance() {
    if (!CharWidthReader._INSTANCE) {
      CharWidthReader._INSTANCE = new CharWidthReader();
    }
    return CharWidthReader._INSTANCE;
  }
  getCharWidth(char, font) {
    const cacheKey = char + font;
    if (this._cache[cacheKey]) {
      return this._cache[cacheKey];
    }
    const context = this._canvas.getContext("2d");
    context.font = font;
    const metrics = context.measureText(char);
    const width = metrics.width;
    this._cache[cacheKey] = width;
    return width;
  }
};
CharWidthReader._INSTANCE = null;

// ../../node_modules/monaco-editor/esm/vs/editor/browser/controller/mouseHandler.js
function createMouseMoveEventMerger(mouseTargetFactory) {
  return function(lastEvent, currentEvent) {
    let targetIsWidget = false;
    if (mouseTargetFactory) {
      targetIsWidget = mouseTargetFactory.mouseTargetIsWidget(currentEvent);
    }
    if (!targetIsWidget) {
      currentEvent.preventDefault();
    }
    return currentEvent;
  };
}
var MouseHandler = class extends ViewEventHandler {
  constructor(context, viewController, viewHelper) {
    super();
    this._context = context;
    this.viewController = viewController;
    this.viewHelper = viewHelper;
    this.mouseTargetFactory = new MouseTargetFactory(this._context, viewHelper);
    this._mouseDownOperation = this._register(new MouseDownOperation(this._context, this.viewController, this.viewHelper, (e, testEventTarget) => this._createMouseTarget(e, testEventTarget), (e) => this._getMouseColumn(e)));
    this.lastMouseLeaveTime = -1;
    const mouseEvents = new EditorMouseEventFactory(this.viewHelper.viewDomNode);
    this._register(mouseEvents.onContextMenu(this.viewHelper.viewDomNode, (e) => this._onContextMenu(e, true)));
    this._register(mouseEvents.onMouseMoveThrottled(this.viewHelper.viewDomNode, (e) => this._onMouseMove(e), createMouseMoveEventMerger(this.mouseTargetFactory), MouseHandler.MOUSE_MOVE_MINIMUM_TIME));
    this._register(mouseEvents.onMouseUp(this.viewHelper.viewDomNode, (e) => this._onMouseUp(e)));
    this._register(mouseEvents.onMouseLeave(this.viewHelper.viewDomNode, (e) => this._onMouseLeave(e)));
    this._register(mouseEvents.onMouseDown(this.viewHelper.viewDomNode, (e) => this._onMouseDown(e)));
    const onMouseWheel = (browserEvent) => {
      this.viewController.emitMouseWheel(browserEvent);
      if (!this._context.configuration.options.get(59)) {
        return;
      }
      const e = new StandardWheelEvent(browserEvent);
      if (e.browserEvent.ctrlKey || e.browserEvent.metaKey) {
        const zoomLevel = EditorZoom.getZoomLevel();
        const delta = e.deltaY > 0 ? 1 : -1;
        EditorZoom.setZoomLevel(zoomLevel + delta);
        e.preventDefault();
        e.stopPropagation();
      }
    };
    this._register(addDisposableListener(this.viewHelper.viewDomNode, EventType.MOUSE_WHEEL, onMouseWheel, {capture: true, passive: false}));
    this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this);
    super.dispose();
  }
  onCursorStateChanged(e) {
    this._mouseDownOperation.onCursorStateChanged(e);
    return false;
  }
  onFocusChanged(e) {
    return false;
  }
  onScrollChanged(e) {
    this._mouseDownOperation.onScrollChanged();
    return false;
  }
  getTargetAtClientPoint(clientX, clientY) {
    const clientPos = new ClientCoordinates(clientX, clientY);
    const pos = clientPos.toPageCoordinates();
    const editorPos = createEditorPagePosition(this.viewHelper.viewDomNode);
    if (pos.y < editorPos.y || pos.y > editorPos.y + editorPos.height || pos.x < editorPos.x || pos.x > editorPos.x + editorPos.width) {
      return null;
    }
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), editorPos, pos, null);
  }
  _createMouseTarget(e, testEventTarget) {
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), e.editorPos, e.pos, testEventTarget ? e.target : null);
  }
  _getMouseColumn(e) {
    return this.mouseTargetFactory.getMouseColumn(e.editorPos, e.pos);
  }
  _onContextMenu(e, testEventTarget) {
    this.viewController.emitContextMenu({
      event: e,
      target: this._createMouseTarget(e, testEventTarget)
    });
  }
  _onMouseMove(e) {
    if (this._mouseDownOperation.isActive()) {
      return;
    }
    const actualMouseMoveTime = e.timestamp;
    if (actualMouseMoveTime < this.lastMouseLeaveTime) {
      return;
    }
    this.viewController.emitMouseMove({
      event: e,
      target: this._createMouseTarget(e, true)
    });
  }
  _onMouseLeave(e) {
    this.lastMouseLeaveTime = new Date().getTime();
    this.viewController.emitMouseLeave({
      event: e,
      target: null
    });
  }
  _onMouseUp(e) {
    this.viewController.emitMouseUp({
      event: e,
      target: this._createMouseTarget(e, true)
    });
  }
  _onMouseDown(e) {
    const t = this._createMouseTarget(e, true);
    const targetIsContent = t.type === 6 || t.type === 7;
    const targetIsGutter = t.type === 2 || t.type === 3 || t.type === 4;
    const targetIsLineNumbers = t.type === 3;
    const selectOnLineNumbers = this._context.configuration.options.get(90);
    const targetIsViewZone = t.type === 8 || t.type === 5;
    const targetIsWidget = t.type === 9;
    let shouldHandle = e.leftButton || e.middleButton;
    if (isMacintosh && e.leftButton && e.ctrlKey) {
      shouldHandle = false;
    }
    const focus = () => {
      e.preventDefault();
      this.viewHelper.focusTextArea();
    };
    if (shouldHandle && (targetIsContent || targetIsLineNumbers && selectOnLineNumbers)) {
      focus();
      this._mouseDownOperation.start(t.type, e);
    } else if (targetIsGutter) {
      e.preventDefault();
    } else if (targetIsViewZone) {
      const viewZoneData = t.detail;
      if (this.viewHelper.shouldSuppressMouseDownOnViewZone(viewZoneData.viewZoneId)) {
        focus();
        this._mouseDownOperation.start(t.type, e);
        e.preventDefault();
      }
    } else if (targetIsWidget && this.viewHelper.shouldSuppressMouseDownOnWidget(t.detail)) {
      focus();
      e.preventDefault();
    }
    this.viewController.emitMouseDown({
      event: e,
      target: t
    });
  }
};
MouseHandler.MOUSE_MOVE_MINIMUM_TIME = 100;
var MouseDownOperation = class extends Disposable {
  constructor(context, viewController, viewHelper, createMouseTarget, getMouseColumn) {
    super();
    this._context = context;
    this._viewController = viewController;
    this._viewHelper = viewHelper;
    this._createMouseTarget = createMouseTarget;
    this._getMouseColumn = getMouseColumn;
    this._mouseMoveMonitor = this._register(new GlobalEditorMouseMoveMonitor(this._viewHelper.viewDomNode));
    this._onScrollTimeout = this._register(new TimeoutTimer());
    this._mouseState = new MouseDownState();
    this._currentSelection = new Selection(1, 1, 1, 1);
    this._isActive = false;
    this._lastMouseEvent = null;
  }
  dispose() {
    super.dispose();
  }
  isActive() {
    return this._isActive;
  }
  _onMouseDownThenMove(e) {
    this._lastMouseEvent = e;
    this._mouseState.setModifiers(e);
    const position = this._findMousePosition(e, true);
    if (!position) {
      return;
    }
    if (this._mouseState.isDragAndDrop) {
      this._viewController.emitMouseDrag({
        event: e,
        target: position
      });
    } else {
      this._dispatchMouse(position, true);
    }
  }
  start(targetType, e) {
    this._lastMouseEvent = e;
    this._mouseState.setStartedOnLineNumbers(targetType === 3);
    this._mouseState.setStartButtons(e);
    this._mouseState.setModifiers(e);
    const position = this._findMousePosition(e, true);
    if (!position || !position.position) {
      return;
    }
    this._mouseState.trySetCount(e.detail, position.position);
    e.detail = this._mouseState.count;
    const options = this._context.configuration.options;
    if (!options.get(72) && options.get(25) && !options.get(13) && !this._mouseState.altKey && e.detail < 2 && !this._isActive && !this._currentSelection.isEmpty() && position.type === 6 && position.position && this._currentSelection.containsPosition(position.position)) {
      this._mouseState.isDragAndDrop = true;
      this._isActive = true;
      this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, createMouseMoveEventMerger(null), (e2) => this._onMouseDownThenMove(e2), () => {
        const position2 = this._findMousePosition(this._lastMouseEvent, true);
        this._viewController.emitMouseDrop({
          event: this._lastMouseEvent,
          target: position2 ? this._createMouseTarget(this._lastMouseEvent, true) : null
        });
        this._stop();
      });
      return;
    }
    this._mouseState.isDragAndDrop = false;
    this._dispatchMouse(position, e.shiftKey);
    if (!this._isActive) {
      this._isActive = true;
      this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, createMouseMoveEventMerger(null), (e2) => this._onMouseDownThenMove(e2), () => this._stop());
    }
  }
  _stop() {
    this._isActive = false;
    this._onScrollTimeout.cancel();
  }
  onScrollChanged() {
    if (!this._isActive) {
      return;
    }
    this._onScrollTimeout.setIfNotSet(() => {
      if (!this._lastMouseEvent) {
        return;
      }
      const position = this._findMousePosition(this._lastMouseEvent, false);
      if (!position) {
        return;
      }
      if (this._mouseState.isDragAndDrop) {
        return;
      }
      this._dispatchMouse(position, true);
    }, 10);
  }
  onCursorStateChanged(e) {
    this._currentSelection = e.selections[0];
  }
  _getPositionOutsideEditor(e) {
    const editorContent = e.editorPos;
    const model2 = this._context.model;
    const viewLayout = this._context.viewLayout;
    const mouseColumn = this._getMouseColumn(e);
    if (e.posy < editorContent.y) {
      const verticalOffset = Math.max(viewLayout.getCurrentScrollTop() - (editorContent.y - e.posy), 0);
      const viewZoneData = HitTestContext.getZoneAtCoord(this._context, verticalOffset);
      if (viewZoneData) {
        const newPosition = this._helpPositionJumpOverViewZone(viewZoneData);
        if (newPosition) {
          return new MouseTarget(null, 13, mouseColumn, newPosition);
        }
      }
      const aboveLineNumber = viewLayout.getLineNumberAtVerticalOffset(verticalOffset);
      return new MouseTarget(null, 13, mouseColumn, new Position(aboveLineNumber, 1));
    }
    if (e.posy > editorContent.y + editorContent.height) {
      const verticalOffset = viewLayout.getCurrentScrollTop() + (e.posy - editorContent.y);
      const viewZoneData = HitTestContext.getZoneAtCoord(this._context, verticalOffset);
      if (viewZoneData) {
        const newPosition = this._helpPositionJumpOverViewZone(viewZoneData);
        if (newPosition) {
          return new MouseTarget(null, 13, mouseColumn, newPosition);
        }
      }
      const belowLineNumber = viewLayout.getLineNumberAtVerticalOffset(verticalOffset);
      return new MouseTarget(null, 13, mouseColumn, new Position(belowLineNumber, model2.getLineMaxColumn(belowLineNumber)));
    }
    const possibleLineNumber = viewLayout.getLineNumberAtVerticalOffset(viewLayout.getCurrentScrollTop() + (e.posy - editorContent.y));
    if (e.posx < editorContent.x) {
      return new MouseTarget(null, 13, mouseColumn, new Position(possibleLineNumber, 1));
    }
    if (e.posx > editorContent.x + editorContent.width) {
      return new MouseTarget(null, 13, mouseColumn, new Position(possibleLineNumber, model2.getLineMaxColumn(possibleLineNumber)));
    }
    return null;
  }
  _findMousePosition(e, testEventTarget) {
    const positionOutsideEditor = this._getPositionOutsideEditor(e);
    if (positionOutsideEditor) {
      return positionOutsideEditor;
    }
    const t = this._createMouseTarget(e, testEventTarget);
    const hintedPosition = t.position;
    if (!hintedPosition) {
      return null;
    }
    if (t.type === 8 || t.type === 5) {
      const newPosition = this._helpPositionJumpOverViewZone(t.detail);
      if (newPosition) {
        return new MouseTarget(t.element, t.type, t.mouseColumn, newPosition, null, t.detail);
      }
    }
    return t;
  }
  _helpPositionJumpOverViewZone(viewZoneData) {
    const selectionStart = new Position(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn);
    const positionBefore = viewZoneData.positionBefore;
    const positionAfter = viewZoneData.positionAfter;
    if (positionBefore && positionAfter) {
      if (positionBefore.isBefore(selectionStart)) {
        return positionBefore;
      } else {
        return positionAfter;
      }
    }
    return null;
  }
  _dispatchMouse(position, inSelectionMode) {
    if (!position.position) {
      return;
    }
    this._viewController.dispatchMouse({
      position: position.position,
      mouseColumn: position.mouseColumn,
      startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
      inSelectionMode,
      mouseDownCount: this._mouseState.count,
      altKey: this._mouseState.altKey,
      ctrlKey: this._mouseState.ctrlKey,
      metaKey: this._mouseState.metaKey,
      shiftKey: this._mouseState.shiftKey,
      leftButton: this._mouseState.leftButton,
      middleButton: this._mouseState.middleButton
    });
  }
};
var MouseDownState = class {
  constructor() {
    this._altKey = false;
    this._ctrlKey = false;
    this._metaKey = false;
    this._shiftKey = false;
    this._leftButton = false;
    this._middleButton = false;
    this._startedOnLineNumbers = false;
    this._lastMouseDownPosition = null;
    this._lastMouseDownPositionEqualCount = 0;
    this._lastMouseDownCount = 0;
    this._lastSetMouseDownCountTime = 0;
    this.isDragAndDrop = false;
  }
  get altKey() {
    return this._altKey;
  }
  get ctrlKey() {
    return this._ctrlKey;
  }
  get metaKey() {
    return this._metaKey;
  }
  get shiftKey() {
    return this._shiftKey;
  }
  get leftButton() {
    return this._leftButton;
  }
  get middleButton() {
    return this._middleButton;
  }
  get startedOnLineNumbers() {
    return this._startedOnLineNumbers;
  }
  get count() {
    return this._lastMouseDownCount;
  }
  setModifiers(source) {
    this._altKey = source.altKey;
    this._ctrlKey = source.ctrlKey;
    this._metaKey = source.metaKey;
    this._shiftKey = source.shiftKey;
  }
  setStartButtons(source) {
    this._leftButton = source.leftButton;
    this._middleButton = source.middleButton;
  }
  setStartedOnLineNumbers(startedOnLineNumbers) {
    this._startedOnLineNumbers = startedOnLineNumbers;
  }
  trySetCount(setMouseDownCount, newMouseDownPosition) {
    const currentTime = new Date().getTime();
    if (currentTime - this._lastSetMouseDownCountTime > MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME) {
      setMouseDownCount = 1;
    }
    this._lastSetMouseDownCountTime = currentTime;
    if (setMouseDownCount > this._lastMouseDownCount + 1) {
      setMouseDownCount = this._lastMouseDownCount + 1;
    }
    if (this._lastMouseDownPosition && this._lastMouseDownPosition.equals(newMouseDownPosition)) {
      this._lastMouseDownPositionEqualCount++;
    } else {
      this._lastMouseDownPositionEqualCount = 1;
    }
    this._lastMouseDownPosition = newMouseDownPosition;
    this._lastMouseDownCount = Math.min(setMouseDownCount, this._lastMouseDownPositionEqualCount);
  }
};
MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME = 400;

// ../../node_modules/monaco-editor/esm/vs/editor/browser/controller/pointerHandler.js
function gestureChangeEventMerger(lastEvent, currentEvent) {
  const r = {
    translationY: currentEvent.translationY,
    translationX: currentEvent.translationX
  };
  if (lastEvent) {
    r.translationY += lastEvent.translationY;
    r.translationX += lastEvent.translationX;
  }
  return r;
}
var StandardPointerHandler = class extends MouseHandler {
  constructor(context, viewController, viewHelper) {
    super(context, viewController, viewHelper);
    this.viewHelper.linesContentDomNode.style.touchAction = "none";
    this._installGestureHandlerTimeout = window.setTimeout(() => {
      this._installGestureHandlerTimeout = -1;
      if (window.MSGesture) {
        const touchGesture = new MSGesture();
        const penGesture = new MSGesture();
        touchGesture.target = this.viewHelper.linesContentDomNode;
        penGesture.target = this.viewHelper.linesContentDomNode;
        this.viewHelper.linesContentDomNode.addEventListener("pointerdown", (e) => {
          const pointerType = e.pointerType;
          if (pointerType === "mouse") {
            this._lastPointerType = "mouse";
            return;
          } else if (pointerType === "touch") {
            this._lastPointerType = "touch";
            touchGesture.addPointer(e.pointerId);
          } else {
            this._lastPointerType = "pen";
            penGesture.addPointer(e.pointerId);
          }
        });
        this._register(addDisposableThrottledListener(this.viewHelper.linesContentDomNode, "MSGestureChange", (e) => this._onGestureChange(e), gestureChangeEventMerger));
        this._register(addDisposableListener(this.viewHelper.linesContentDomNode, "MSGestureTap", (e) => this._onCaptureGestureTap(e), true));
      }
    }, 100);
    this._lastPointerType = "mouse";
  }
  _onMouseDown(e) {
    if (this._lastPointerType === "mouse") {
      super._onMouseDown(e);
    }
  }
  _onCaptureGestureTap(rawEvent) {
    const e = new EditorMouseEvent(rawEvent, this.viewHelper.viewDomNode);
    const t = this._createMouseTarget(e, false);
    if (t.position) {
      this.viewController.moveTo(t.position);
    }
    if (e.browserEvent.fromElement) {
      e.preventDefault();
      this.viewHelper.focusTextArea();
    } else {
      setTimeout(() => {
        this.viewHelper.focusTextArea();
      });
    }
  }
  _onGestureChange(e) {
    this._context.model.deltaScrollNow(-e.translationX, -e.translationY);
  }
  dispose() {
    window.clearTimeout(this._installGestureHandlerTimeout);
    super.dispose();
  }
};
var PointerEventHandler = class extends MouseHandler {
  constructor(context, viewController, viewHelper) {
    super(context, viewController, viewHelper);
    this._register(Gesture.addTarget(this.viewHelper.linesContentDomNode));
    this._register(addDisposableListener(this.viewHelper.linesContentDomNode, EventType2.Tap, (e) => this.onTap(e)));
    this._register(addDisposableListener(this.viewHelper.linesContentDomNode, EventType2.Change, (e) => this.onChange(e)));
    this._register(addDisposableListener(this.viewHelper.linesContentDomNode, EventType2.Contextmenu, (e) => this._onContextMenu(new EditorMouseEvent(e, this.viewHelper.viewDomNode), false)));
    this._lastPointerType = "mouse";
    this._register(addDisposableListener(this.viewHelper.linesContentDomNode, "pointerdown", (e) => {
      const pointerType = e.pointerType;
      if (pointerType === "mouse") {
        this._lastPointerType = "mouse";
        return;
      } else if (pointerType === "touch") {
        this._lastPointerType = "touch";
      } else {
        this._lastPointerType = "pen";
      }
    }));
    const pointerEvents = new EditorPointerEventFactory(this.viewHelper.viewDomNode);
    this._register(pointerEvents.onPointerMoveThrottled(this.viewHelper.viewDomNode, (e) => this._onMouseMove(e), createMouseMoveEventMerger(this.mouseTargetFactory), MouseHandler.MOUSE_MOVE_MINIMUM_TIME));
    this._register(pointerEvents.onPointerUp(this.viewHelper.viewDomNode, (e) => this._onMouseUp(e)));
    this._register(pointerEvents.onPointerLeave(this.viewHelper.viewDomNode, (e) => this._onMouseLeave(e)));
    this._register(pointerEvents.onPointerDown(this.viewHelper.viewDomNode, (e) => this._onMouseDown(e)));
  }
  onTap(event) {
    if (!event.initialTarget || !this.viewHelper.linesContentDomNode.contains(event.initialTarget)) {
      return;
    }
    event.preventDefault();
    this.viewHelper.focusTextArea();
    const target = this._createMouseTarget(new EditorMouseEvent(event, this.viewHelper.viewDomNode), false);
    if (target.position) {
      this.viewController.dispatchMouse({
        position: target.position,
        mouseColumn: target.position.column,
        startedOnLineNumbers: false,
        mouseDownCount: event.tapCount,
        inSelectionMode: false,
        altKey: false,
        ctrlKey: false,
        metaKey: false,
        shiftKey: false,
        leftButton: false,
        middleButton: false
      });
    }
  }
  onChange(e) {
    if (this._lastPointerType === "touch") {
      this._context.model.deltaScrollNow(-e.translationX, -e.translationY);
    }
  }
  _onMouseDown(e) {
    if (e.target && this.viewHelper.linesContentDomNode.contains(e.target) && this._lastPointerType === "touch") {
      return;
    }
    super._onMouseDown(e);
  }
};
var TouchHandler = class extends MouseHandler {
  constructor(context, viewController, viewHelper) {
    super(context, viewController, viewHelper);
    this._register(Gesture.addTarget(this.viewHelper.linesContentDomNode));
    this._register(addDisposableListener(this.viewHelper.linesContentDomNode, EventType2.Tap, (e) => this.onTap(e)));
    this._register(addDisposableListener(this.viewHelper.linesContentDomNode, EventType2.Change, (e) => this.onChange(e)));
    this._register(addDisposableListener(this.viewHelper.linesContentDomNode, EventType2.Contextmenu, (e) => this._onContextMenu(new EditorMouseEvent(e, this.viewHelper.viewDomNode), false)));
  }
  onTap(event) {
    event.preventDefault();
    this.viewHelper.focusTextArea();
    const target = this._createMouseTarget(new EditorMouseEvent(event, this.viewHelper.viewDomNode), false);
    if (target.position) {
      this.viewController.moveTo(target.position);
    }
  }
  onChange(e) {
    this._context.model.deltaScrollNow(-e.translationX, -e.translationY);
  }
};
var PointerHandler = class extends Disposable {
  constructor(context, viewController, viewHelper) {
    super();
    if (isIOS && BrowserFeatures.pointerEvents) {
      this.handler = this._register(new PointerEventHandler(context, viewController, viewHelper));
    } else if (window.TouchEvent) {
      this.handler = this._register(new TouchHandler(context, viewController, viewHelper));
    } else if (window.navigator.pointerEnabled || window.PointerEvent) {
      this.handler = this._register(new StandardPointerHandler(context, viewController, viewHelper));
    } else {
      this.handler = this._register(new MouseHandler(context, viewController, viewHelper));
    }
  }
  getTargetAtClientPoint(clientX, clientY) {
    return this.handler.getTargetAtClientPoint(clientX, clientY);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaState.js
var TextAreaState = class {
  constructor(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {
    this.value = value;
    this.selectionStart = selectionStart;
    this.selectionEnd = selectionEnd;
    this.selectionStartPosition = selectionStartPosition;
    this.selectionEndPosition = selectionEndPosition;
  }
  toString() {
    return "[ <" + this.value + ">, selectionStart: " + this.selectionStart + ", selectionEnd: " + this.selectionEnd + "]";
  }
  static readFromTextArea(textArea) {
    return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);
  }
  collapseSelection() {
    return new TextAreaState(this.value, this.value.length, this.value.length, null, null);
  }
  writeToTextArea(reason, textArea, select) {
    textArea.setValue(reason, this.value);
    if (select) {
      textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);
    }
  }
  deduceEditorPosition(offset) {
    if (offset <= this.selectionStart) {
      const str = this.value.substring(offset, this.selectionStart);
      return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);
    }
    if (offset >= this.selectionEnd) {
      const str = this.value.substring(this.selectionEnd, offset);
      return this._finishDeduceEditorPosition(this.selectionEndPosition, str, 1);
    }
    const str1 = this.value.substring(this.selectionStart, offset);
    if (str1.indexOf(String.fromCharCode(8230)) === -1) {
      return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);
    }
    const str2 = this.value.substring(offset, this.selectionEnd);
    return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);
  }
  _finishDeduceEditorPosition(anchor, deltaText, signum) {
    let lineFeedCnt = 0;
    let lastLineFeedIndex = -1;
    while ((lastLineFeedIndex = deltaText.indexOf("\n", lastLineFeedIndex + 1)) !== -1) {
      lineFeedCnt++;
    }
    return [anchor, signum * deltaText.length, lineFeedCnt];
  }
  static selectedText(text) {
    return new TextAreaState(text, 0, text.length, null, null);
  }
  static deduceInput(previousState, currentState, couldBeEmojiInput) {
    if (!previousState) {
      return {
        text: "",
        replaceCharCnt: 0
      };
    }
    let previousValue = previousState.value;
    let previousSelectionStart = previousState.selectionStart;
    let previousSelectionEnd = previousState.selectionEnd;
    let currentValue = currentState.value;
    let currentSelectionStart = currentState.selectionStart;
    let currentSelectionEnd = currentState.selectionEnd;
    const previousSuffix = previousValue.substring(previousSelectionEnd);
    const currentSuffix = currentValue.substring(currentSelectionEnd);
    const suffixLength = commonSuffixLength(previousSuffix, currentSuffix);
    currentValue = currentValue.substring(0, currentValue.length - suffixLength);
    previousValue = previousValue.substring(0, previousValue.length - suffixLength);
    const previousPrefix = previousValue.substring(0, previousSelectionStart);
    const currentPrefix = currentValue.substring(0, currentSelectionStart);
    const prefixLength = commonPrefixLength(previousPrefix, currentPrefix);
    currentValue = currentValue.substring(prefixLength);
    previousValue = previousValue.substring(prefixLength);
    currentSelectionStart -= prefixLength;
    previousSelectionStart -= prefixLength;
    currentSelectionEnd -= prefixLength;
    previousSelectionEnd -= prefixLength;
    if (couldBeEmojiInput && currentSelectionStart === currentSelectionEnd && previousValue.length > 0) {
      let potentialEmojiInput = null;
      if (currentSelectionStart === currentValue.length) {
        if (startsWith(currentValue, previousValue)) {
          potentialEmojiInput = currentValue.substring(previousValue.length);
        }
      } else {
        if (endsWith(currentValue, previousValue)) {
          potentialEmojiInput = currentValue.substring(0, currentValue.length - previousValue.length);
        }
      }
      if (potentialEmojiInput !== null && potentialEmojiInput.length > 0) {
        if (/\uFE0F/.test(potentialEmojiInput) || containsEmoji(potentialEmojiInput)) {
          return {
            text: potentialEmojiInput,
            replaceCharCnt: 0
          };
        }
      }
    }
    if (currentSelectionStart === currentSelectionEnd) {
      if (previousValue === currentValue && previousSelectionStart === 0 && previousSelectionEnd === previousValue.length && currentSelectionStart === currentValue.length && currentValue.indexOf("\n") === -1) {
        if (containsFullWidthCharacter(currentValue)) {
          return {
            text: "",
            replaceCharCnt: 0
          };
        }
      }
      const replacePreviousCharacters2 = previousPrefix.length - prefixLength;
      return {
        text: currentValue,
        replaceCharCnt: replacePreviousCharacters2
      };
    }
    const replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;
    return {
      text: currentValue,
      replaceCharCnt: replacePreviousCharacters
    };
  }
};
TextAreaState.EMPTY = new TextAreaState("", 0, 0, null, null);
var PagedScreenReaderStrategy = class {
  static _getPageOfLine(lineNumber, linesPerPage) {
    return Math.floor((lineNumber - 1) / linesPerPage);
  }
  static _getRangeForPage(page, linesPerPage) {
    const offset = page * linesPerPage;
    const startLineNumber = offset + 1;
    const endLineNumber = offset + linesPerPage;
    return new Range(startLineNumber, 1, endLineNumber + 1, 1);
  }
  static fromEditorSelection(previousState, model2, selection, linesPerPage, trimLongText) {
    const selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);
    const selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);
    const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);
    const selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);
    const pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));
    let pretext = model2.getValueInRange(pretextRange, 1);
    const lastLine = model2.getLineCount();
    const lastLineMaxColumn = model2.getLineMaxColumn(lastLine);
    const posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));
    let posttext = model2.getValueInRange(posttextRange, 1);
    let text;
    if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {
      text = model2.getValueInRange(selection, 1);
    } else {
      const selectionRange1 = selectionStartPageRange.intersectRanges(selection);
      const selectionRange2 = selectionEndPageRange.intersectRanges(selection);
      text = model2.getValueInRange(selectionRange1, 1) + String.fromCharCode(8230) + model2.getValueInRange(selectionRange2, 1);
    }
    if (trimLongText) {
      const LIMIT_CHARS = 500;
      if (pretext.length > LIMIT_CHARS) {
        pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);
      }
      if (posttext.length > LIMIT_CHARS) {
        posttext = posttext.substring(0, LIMIT_CHARS);
      }
      if (text.length > 2 * LIMIT_CHARS) {
        text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);
      }
    }
    return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaInput.js
var CopyOptions = {
  forceCopyWithSyntaxHighlighting: false
};
var InMemoryClipboardMetadataManager = class {
  constructor() {
    this._lastState = null;
  }
  set(lastCopiedValue, data) {
    this._lastState = {lastCopiedValue, data};
  }
  get(pastedText) {
    if (this._lastState && this._lastState.lastCopiedValue === pastedText) {
      return this._lastState.data;
    }
    this._lastState = null;
    return null;
  }
};
InMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();
var TextAreaInput = class extends Disposable {
  constructor(host, textArea) {
    super();
    this.textArea = textArea;
    this._onFocus = this._register(new Emitter());
    this.onFocus = this._onFocus.event;
    this._onBlur = this._register(new Emitter());
    this.onBlur = this._onBlur.event;
    this._onKeyDown = this._register(new Emitter());
    this.onKeyDown = this._onKeyDown.event;
    this._onKeyUp = this._register(new Emitter());
    this.onKeyUp = this._onKeyUp.event;
    this._onCut = this._register(new Emitter());
    this.onCut = this._onCut.event;
    this._onPaste = this._register(new Emitter());
    this.onPaste = this._onPaste.event;
    this._onType = this._register(new Emitter());
    this.onType = this._onType.event;
    this._onCompositionStart = this._register(new Emitter());
    this.onCompositionStart = this._onCompositionStart.event;
    this._onCompositionUpdate = this._register(new Emitter());
    this.onCompositionUpdate = this._onCompositionUpdate.event;
    this._onCompositionEnd = this._register(new Emitter());
    this.onCompositionEnd = this._onCompositionEnd.event;
    this._onSelectionChangeRequest = this._register(new Emitter());
    this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;
    this._host = host;
    this._textArea = this._register(new TextAreaWrapper(textArea));
    this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));
    this._textAreaState = TextAreaState.EMPTY;
    this._selectionChangeListener = null;
    this.writeScreenReaderContent("ctor");
    this._hasFocus = false;
    this._isDoingComposition = false;
    this._nextCommand = 0;
    let lastKeyDown = null;
    this._register(addStandardDisposableListener(textArea.domNode, "keydown", (e) => {
      if (e.keyCode === 109 || this._isDoingComposition && e.keyCode === 1) {
        e.stopPropagation();
      }
      if (e.equals(9)) {
        e.preventDefault();
      }
      lastKeyDown = e;
      this._onKeyDown.fire(e);
    }));
    this._register(addStandardDisposableListener(textArea.domNode, "keyup", (e) => {
      this._onKeyUp.fire(e);
    }));
    this._register(addDisposableListener(textArea.domNode, "compositionstart", (e) => {
      if (this._isDoingComposition) {
        return;
      }
      this._isDoingComposition = true;
      let moveOneCharacterLeft = false;
      if (isMacintosh && lastKeyDown && lastKeyDown.equals(109) && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data) {
        if (lastKeyDown.code === "ArrowRight" || lastKeyDown.code === "ArrowLeft") {
          moveOneCharacterLeft = true;
        }
      }
      if (moveOneCharacterLeft) {
        this._textAreaState = new TextAreaState(this._textAreaState.value, this._textAreaState.selectionStart - 1, this._textAreaState.selectionEnd, this._textAreaState.selectionStartPosition ? new Position(this._textAreaState.selectionStartPosition.lineNumber, this._textAreaState.selectionStartPosition.column - 1) : null, this._textAreaState.selectionEndPosition);
      } else if (!isEdge) {
        this._setAndWriteTextAreaState("compositionstart", TextAreaState.EMPTY);
      }
      this._onCompositionStart.fire({moveOneCharacterLeft});
    }));
    const deduceInputFromTextAreaValue = (couldBeEmojiInput) => {
      const oldState = this._textAreaState;
      const newState = TextAreaState.readFromTextArea(this._textArea);
      return [newState, TextAreaState.deduceInput(oldState, newState, couldBeEmojiInput)];
    };
    const deduceComposition = (text) => {
      const oldState = this._textAreaState;
      const newState = TextAreaState.selectedText(text);
      const typeInput = {
        text: newState.value,
        replaceCharCnt: oldState.selectionEnd - oldState.selectionStart
      };
      return [newState, typeInput];
    };
    const compositionDataInValid = (locale) => {
      if (isEdge && locale === "ja") {
        return true;
      }
      return false;
    };
    this._register(addDisposableListener(textArea.domNode, "compositionupdate", (e) => {
      if (compositionDataInValid(e.locale)) {
        const [newState2, typeInput2] = deduceInputFromTextAreaValue(false);
        this._textAreaState = newState2;
        this._onType.fire(typeInput2);
        this._onCompositionUpdate.fire(e);
        return;
      }
      const [newState, typeInput] = deduceComposition(e.data || "");
      this._textAreaState = newState;
      this._onType.fire(typeInput);
      this._onCompositionUpdate.fire(e);
    }));
    this._register(addDisposableListener(textArea.domNode, "compositionend", (e) => {
      if (!this._isDoingComposition) {
        return;
      }
      if (compositionDataInValid(e.locale)) {
        const [newState, typeInput] = deduceInputFromTextAreaValue(false);
        this._textAreaState = newState;
        this._onType.fire(typeInput);
      } else {
        const [newState, typeInput] = deduceComposition(e.data || "");
        this._textAreaState = newState;
        this._onType.fire(typeInput);
      }
      if (isEdge || isChrome) {
        this._textAreaState = TextAreaState.readFromTextArea(this._textArea);
      }
      if (!this._isDoingComposition) {
        return;
      }
      this._isDoingComposition = false;
      this._onCompositionEnd.fire();
    }));
    this._register(addDisposableListener(textArea.domNode, "input", () => {
      this._textArea.setIgnoreSelectionChangeTime("received input event");
      if (this._isDoingComposition) {
        return;
      }
      const [newState, typeInput] = deduceInputFromTextAreaValue(isMacintosh);
      if (typeInput.replaceCharCnt === 0 && typeInput.text.length === 1 && isHighSurrogate(typeInput.text.charCodeAt(0))) {
        return;
      }
      this._textAreaState = newState;
      if (this._nextCommand === 0) {
        if (typeInput.text !== "") {
          this._onType.fire(typeInput);
        }
      } else {
        if (typeInput.text !== "" || typeInput.replaceCharCnt !== 0) {
          this._firePaste(typeInput.text, null);
        }
        this._nextCommand = 0;
      }
    }));
    this._register(addDisposableListener(textArea.domNode, "cut", (e) => {
      this._textArea.setIgnoreSelectionChangeTime("received cut event");
      this._ensureClipboardGetsEditorSelection(e);
      this._asyncTriggerCut.schedule();
    }));
    this._register(addDisposableListener(textArea.domNode, "copy", (e) => {
      this._ensureClipboardGetsEditorSelection(e);
    }));
    this._register(addDisposableListener(textArea.domNode, "paste", (e) => {
      this._textArea.setIgnoreSelectionChangeTime("received paste event");
      if (ClipboardEventUtils.canUseTextData(e)) {
        const [pastePlainText, metadata] = ClipboardEventUtils.getTextData(e);
        if (pastePlainText !== "") {
          this._firePaste(pastePlainText, metadata);
        }
      } else {
        if (this._textArea.getSelectionStart() !== this._textArea.getSelectionEnd()) {
          this._setAndWriteTextAreaState("paste", TextAreaState.EMPTY);
        }
        this._nextCommand = 1;
      }
    }));
    this._register(addDisposableListener(textArea.domNode, "focus", () => {
      this._setHasFocus(true);
    }));
    this._register(addDisposableListener(textArea.domNode, "blur", () => {
      this._setHasFocus(false);
    }));
  }
  _installSelectionChangeListener() {
    let previousSelectionChangeEventTime = 0;
    return addDisposableListener(document, "selectionchange", (e) => {
      if (!this._hasFocus) {
        return;
      }
      if (this._isDoingComposition) {
        return;
      }
      if (!isChrome) {
        return;
      }
      const now = Date.now();
      const delta1 = now - previousSelectionChangeEventTime;
      previousSelectionChangeEventTime = now;
      if (delta1 < 5) {
        return;
      }
      const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();
      this._textArea.resetSelectionChangeTime();
      if (delta2 < 100) {
        return;
      }
      if (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {
        return;
      }
      const newValue = this._textArea.getValue();
      if (this._textAreaState.value !== newValue) {
        return;
      }
      const newSelectionStart = this._textArea.getSelectionStart();
      const newSelectionEnd = this._textArea.getSelectionEnd();
      if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {
        return;
      }
      const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);
      const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);
      const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);
      const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);
      const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);
      this._onSelectionChangeRequest.fire(newSelection);
    });
  }
  dispose() {
    super.dispose();
    if (this._selectionChangeListener) {
      this._selectionChangeListener.dispose();
      this._selectionChangeListener = null;
    }
  }
  focusTextArea() {
    this._setHasFocus(true);
    this.refreshFocusState();
  }
  isFocused() {
    return this._hasFocus;
  }
  refreshFocusState() {
    const shadowRoot = getShadowRoot(this.textArea.domNode);
    if (shadowRoot) {
      this._setHasFocus(shadowRoot.activeElement === this.textArea.domNode);
    } else if (isInDOM(this.textArea.domNode)) {
      this._setHasFocus(document.activeElement === this.textArea.domNode);
    } else {
      this._setHasFocus(false);
    }
  }
  _setHasFocus(newHasFocus) {
    if (this._hasFocus === newHasFocus) {
      return;
    }
    this._hasFocus = newHasFocus;
    if (this._selectionChangeListener) {
      this._selectionChangeListener.dispose();
      this._selectionChangeListener = null;
    }
    if (this._hasFocus) {
      this._selectionChangeListener = this._installSelectionChangeListener();
    }
    if (this._hasFocus) {
      if (isEdge) {
        this._setAndWriteTextAreaState("focusgain", TextAreaState.EMPTY);
      } else {
        this.writeScreenReaderContent("focusgain");
      }
    }
    if (this._hasFocus) {
      this._onFocus.fire();
    } else {
      this._onBlur.fire();
    }
  }
  _setAndWriteTextAreaState(reason, textAreaState) {
    if (!this._hasFocus) {
      textAreaState = textAreaState.collapseSelection();
    }
    textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);
    this._textAreaState = textAreaState;
  }
  writeScreenReaderContent(reason) {
    if (this._isDoingComposition) {
      return;
    }
    this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));
  }
  _ensureClipboardGetsEditorSelection(e) {
    const dataToCopy = this._host.getDataToCopy(ClipboardEventUtils.canUseTextData(e) && BrowserFeatures.clipboard.richText);
    const storedMetadata = {
      version: 1,
      isFromEmptySelection: dataToCopy.isFromEmptySelection,
      multicursorText: dataToCopy.multicursorText,
      mode: dataToCopy.mode
    };
    InMemoryClipboardMetadataManager.INSTANCE.set(isFirefox ? dataToCopy.text.replace(/\r\n/g, "\n") : dataToCopy.text, storedMetadata);
    if (!ClipboardEventUtils.canUseTextData(e)) {
      this._setAndWriteTextAreaState("copy or cut", TextAreaState.selectedText(dataToCopy.text));
      return;
    }
    ClipboardEventUtils.setTextData(e, dataToCopy.text, dataToCopy.html, storedMetadata);
  }
  _firePaste(text, metadata) {
    if (!metadata) {
      metadata = InMemoryClipboardMetadataManager.INSTANCE.get(text);
    }
    this._onPaste.fire({
      text,
      metadata
    });
  }
};
var ClipboardEventUtils = class {
  static canUseTextData(e) {
    if (e.clipboardData) {
      return true;
    }
    if (window.clipboardData) {
      return true;
    }
    return false;
  }
  static getTextData(e) {
    if (e.clipboardData) {
      e.preventDefault();
      const text = e.clipboardData.getData("text/plain");
      let metadata = null;
      const rawmetadata = e.clipboardData.getData("vscode-editor-data");
      if (typeof rawmetadata === "string") {
        try {
          metadata = JSON.parse(rawmetadata);
          if (metadata.version !== 1) {
            metadata = null;
          }
        } catch (err) {
        }
      }
      return [text, metadata];
    }
    if (window.clipboardData) {
      e.preventDefault();
      const text = window.clipboardData.getData("Text");
      return [text, null];
    }
    throw new Error("ClipboardEventUtils.getTextData: Cannot use text data!");
  }
  static setTextData(e, text, html, metadata) {
    if (e.clipboardData) {
      e.clipboardData.setData("text/plain", text);
      if (typeof html === "string") {
        e.clipboardData.setData("text/html", html);
      }
      e.clipboardData.setData("vscode-editor-data", JSON.stringify(metadata));
      e.preventDefault();
      return;
    }
    if (window.clipboardData) {
      window.clipboardData.setData("Text", text);
      e.preventDefault();
      return;
    }
    throw new Error("ClipboardEventUtils.setTextData: Cannot use text data!");
  }
};
var TextAreaWrapper = class extends Disposable {
  constructor(_textArea) {
    super();
    this._actual = _textArea;
    this._ignoreSelectionChangeTime = 0;
  }
  setIgnoreSelectionChangeTime(reason) {
    this._ignoreSelectionChangeTime = Date.now();
  }
  getIgnoreSelectionChangeTime() {
    return this._ignoreSelectionChangeTime;
  }
  resetSelectionChangeTime() {
    this._ignoreSelectionChangeTime = 0;
  }
  getValue() {
    return this._actual.domNode.value;
  }
  setValue(reason, value) {
    const textArea = this._actual.domNode;
    if (textArea.value === value) {
      return;
    }
    this.setIgnoreSelectionChangeTime("setValue");
    textArea.value = value;
  }
  getSelectionStart() {
    return this._actual.domNode.selectionStart;
  }
  getSelectionEnd() {
    return this._actual.domNode.selectionEnd;
  }
  setSelectionRange(reason, selectionStart, selectionEnd) {
    const textArea = this._actual.domNode;
    let activeElement = null;
    const shadowRoot = getShadowRoot(textArea);
    if (shadowRoot) {
      activeElement = shadowRoot.activeElement;
    } else {
      activeElement = document.activeElement;
    }
    const currentIsFocused = activeElement === textArea;
    const currentSelectionStart = textArea.selectionStart;
    const currentSelectionEnd = textArea.selectionEnd;
    if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {
      if (isFirefox && window.parent !== window) {
        textArea.focus();
      }
      return;
    }
    if (currentIsFocused) {
      this.setIgnoreSelectionChangeTime("setSelectionRange");
      textArea.setSelectionRange(selectionStart, selectionEnd);
      if (isFirefox && window.parent !== window) {
        textArea.focus();
      }
      return;
    }
    try {
      const scrollState = saveParentsScrollTop(textArea);
      this.setIgnoreSelectionChangeTime("setSelectionRange");
      textArea.focus();
      textArea.setSelectionRange(selectionStart, selectionEnd);
      restoreParentsScrollTop(textArea, scrollState);
    } catch (e) {
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/view/dynamicViewOverlay.js
var DynamicViewOverlay = class extends ViewEventHandler {
};

// ../../node_modules/monaco-editor/esm/vs/platform/theme/common/colorRegistry.js
var Extensions6 = {
  ColorContribution: "base.contributions.colors"
};
var ColorRegistry = class {
  constructor() {
    this._onDidChangeSchema = new Emitter();
    this.onDidChangeSchema = this._onDidChangeSchema.event;
    this.colorSchema = {type: "object", properties: {}};
    this.colorReferenceSchema = {type: "string", enum: [], enumDescriptions: []};
    this.colorsById = {};
  }
  registerColor(id, defaults, description, needsTransparency = false, deprecationMessage) {
    let colorContribution = {id, description, defaults, needsTransparency, deprecationMessage};
    this.colorsById[id] = colorContribution;
    let propertySchema = {type: "string", description, format: "color-hex", defaultSnippets: [{body: "${1:#ff0000}"}]};
    if (deprecationMessage) {
      propertySchema.deprecationMessage = deprecationMessage;
    }
    this.colorSchema.properties[id] = propertySchema;
    this.colorReferenceSchema.enum.push(id);
    this.colorReferenceSchema.enumDescriptions.push(description);
    this._onDidChangeSchema.fire();
    return id;
  }
  resolveDefaultColor(id, theme) {
    const colorDesc = this.colorsById[id];
    if (colorDesc && colorDesc.defaults) {
      const colorValue = colorDesc.defaults[theme.type];
      return resolveColorValue(colorValue, theme);
    }
    return void 0;
  }
  getColorSchema() {
    return this.colorSchema;
  }
  toString() {
    let sorter2 = (a, b) => {
      let cat1 = a.indexOf(".") === -1 ? 0 : 1;
      let cat2 = b.indexOf(".") === -1 ? 0 : 1;
      if (cat1 !== cat2) {
        return cat1 - cat2;
      }
      return a.localeCompare(b);
    };
    return Object.keys(this.colorsById).sort(sorter2).map((k) => `- \`${k}\`: ${this.colorsById[k].description}`).join("\n");
  }
};
var colorRegistry = new ColorRegistry();
Registry2.add(Extensions6.ColorContribution, colorRegistry);
function registerColor(id, defaults, description, needsTransparency, deprecationMessage) {
  return colorRegistry.registerColor(id, defaults, description, needsTransparency, deprecationMessage);
}
var foreground = registerColor("foreground", {dark: "#CCCCCC", light: "#616161", hc: "#FFFFFF"}, localize("foreground", "Overall foreground color. This color is only used if not overridden by a component."));
var errorForeground = registerColor("errorForeground", {dark: "#F48771", light: "#A1260D", hc: "#F48771"}, localize("errorForeground", "Overall foreground color for error messages. This color is only used if not overridden by a component."));
var iconForeground = registerColor("icon.foreground", {dark: "#C5C5C5", light: "#424242", hc: "#FFFFFF"}, localize("iconForeground", "The default color for icons in the workbench."));
var focusBorder = registerColor("focusBorder", {dark: "#007FD4", light: "#0090F1", hc: "#F38518"}, localize("focusBorder", "Overall border color for focused elements. This color is only used if not overridden by a component."));
var contrastBorder = registerColor("contrastBorder", {light: null, dark: null, hc: "#6FC3DF"}, localize("contrastBorder", "An extra border around elements to separate them from others for greater contrast."));
var activeContrastBorder = registerColor("contrastActiveBorder", {light: null, dark: null, hc: focusBorder}, localize("activeContrastBorder", "An extra border around active elements to separate them from others for greater contrast."));
var textLinkForeground = registerColor("textLink.foreground", {light: "#006AB1", dark: "#3794FF", hc: "#3794FF"}, localize("textLinkForeground", "Foreground color for links in text."));
var textCodeBlockBackground = registerColor("textCodeBlock.background", {light: "#dcdcdc66", dark: "#0a0a0a66", hc: Color.black}, localize("textCodeBlockBackground", "Background color for code blocks in text."));
var widgetShadow = registerColor("widget.shadow", {dark: "#000000", light: "#A8A8A8", hc: null}, localize("widgetShadow", "Shadow color of widgets such as find/replace inside the editor."));
var inputBackground = registerColor("input.background", {dark: "#3C3C3C", light: Color.white, hc: Color.black}, localize("inputBoxBackground", "Input box background."));
var inputForeground = registerColor("input.foreground", {dark: foreground, light: foreground, hc: foreground}, localize("inputBoxForeground", "Input box foreground."));
var inputBorder = registerColor("input.border", {dark: null, light: null, hc: contrastBorder}, localize("inputBoxBorder", "Input box border."));
var inputActiveOptionBorder = registerColor("inputOption.activeBorder", {dark: "#007ACC00", light: "#007ACC00", hc: contrastBorder}, localize("inputBoxActiveOptionBorder", "Border color of activated options in input fields."));
var inputActiveOptionBackground = registerColor("inputOption.activeBackground", {dark: transparent(focusBorder, 0.4), light: transparent(focusBorder, 0.2), hc: Color.transparent}, localize("inputOption.activeBackground", "Background color of activated options in input fields."));
var inputActiveOptionForeground = registerColor("inputOption.activeForeground", {dark: Color.white, light: Color.black, hc: null}, localize("inputOption.activeForeground", "Foreground color of activated options in input fields."));
var inputValidationInfoBackground = registerColor("inputValidation.infoBackground", {dark: "#063B49", light: "#D6ECF2", hc: Color.black}, localize("inputValidationInfoBackground", "Input validation background color for information severity."));
var inputValidationInfoForeground = registerColor("inputValidation.infoForeground", {dark: null, light: null, hc: null}, localize("inputValidationInfoForeground", "Input validation foreground color for information severity."));
var inputValidationInfoBorder = registerColor("inputValidation.infoBorder", {dark: "#007acc", light: "#007acc", hc: contrastBorder}, localize("inputValidationInfoBorder", "Input validation border color for information severity."));
var inputValidationWarningBackground = registerColor("inputValidation.warningBackground", {dark: "#352A05", light: "#F6F5D2", hc: Color.black}, localize("inputValidationWarningBackground", "Input validation background color for warning severity."));
var inputValidationWarningForeground = registerColor("inputValidation.warningForeground", {dark: null, light: null, hc: null}, localize("inputValidationWarningForeground", "Input validation foreground color for warning severity."));
var inputValidationWarningBorder = registerColor("inputValidation.warningBorder", {dark: "#B89500", light: "#B89500", hc: contrastBorder}, localize("inputValidationWarningBorder", "Input validation border color for warning severity."));
var inputValidationErrorBackground = registerColor("inputValidation.errorBackground", {dark: "#5A1D1D", light: "#F2DEDE", hc: Color.black}, localize("inputValidationErrorBackground", "Input validation background color for error severity."));
var inputValidationErrorForeground = registerColor("inputValidation.errorForeground", {dark: null, light: null, hc: null}, localize("inputValidationErrorForeground", "Input validation foreground color for error severity."));
var inputValidationErrorBorder = registerColor("inputValidation.errorBorder", {dark: "#BE1100", light: "#BE1100", hc: contrastBorder}, localize("inputValidationErrorBorder", "Input validation border color for error severity."));
var selectBackground = registerColor("dropdown.background", {dark: "#3C3C3C", light: Color.white, hc: Color.black}, localize("dropdownBackground", "Dropdown background."));
var selectForeground = registerColor("dropdown.foreground", {dark: "#F0F0F0", light: null, hc: Color.white}, localize("dropdownForeground", "Dropdown foreground."));
var buttonForeground = registerColor("button.foreground", {dark: Color.white, light: Color.white, hc: Color.white}, localize("buttonForeground", "Button foreground color."));
var buttonBackground = registerColor("button.background", {dark: "#0E639C", light: "#007ACC", hc: null}, localize("buttonBackground", "Button background color."));
var buttonHoverBackground = registerColor("button.hoverBackground", {dark: lighten(buttonBackground, 0.2), light: darken(buttonBackground, 0.2), hc: null}, localize("buttonHoverBackground", "Button background color when hovering."));
var badgeBackground = registerColor("badge.background", {dark: "#4D4D4D", light: "#C4C4C4", hc: Color.black}, localize("badgeBackground", "Badge background color. Badges are small information labels, e.g. for search results count."));
var badgeForeground = registerColor("badge.foreground", {dark: Color.white, light: "#333", hc: Color.white}, localize("badgeForeground", "Badge foreground color. Badges are small information labels, e.g. for search results count."));
var scrollbarShadow = registerColor("scrollbar.shadow", {dark: "#000000", light: "#DDDDDD", hc: null}, localize("scrollbarShadow", "Scrollbar shadow to indicate that the view is scrolled."));
var scrollbarSliderBackground = registerColor("scrollbarSlider.background", {dark: Color.fromHex("#797979").transparent(0.4), light: Color.fromHex("#646464").transparent(0.4), hc: transparent(contrastBorder, 0.6)}, localize("scrollbarSliderBackground", "Scrollbar slider background color."));
var scrollbarSliderHoverBackground = registerColor("scrollbarSlider.hoverBackground", {dark: Color.fromHex("#646464").transparent(0.7), light: Color.fromHex("#646464").transparent(0.7), hc: transparent(contrastBorder, 0.8)}, localize("scrollbarSliderHoverBackground", "Scrollbar slider background color when hovering."));
var scrollbarSliderActiveBackground = registerColor("scrollbarSlider.activeBackground", {dark: Color.fromHex("#BFBFBF").transparent(0.4), light: Color.fromHex("#000000").transparent(0.6), hc: contrastBorder}, localize("scrollbarSliderActiveBackground", "Scrollbar slider background color when clicked on."));
var progressBarBackground = registerColor("progressBar.background", {dark: Color.fromHex("#0E70C0"), light: Color.fromHex("#0E70C0"), hc: contrastBorder}, localize("progressBarBackground", "Background color of the progress bar that can show for long running operations."));
var editorErrorForeground = registerColor("editorError.foreground", {dark: "#F48771", light: "#E51400", hc: null}, localize("editorError.foreground", "Foreground color of error squigglies in the editor."));
var editorErrorBorder = registerColor("editorError.border", {dark: null, light: null, hc: Color.fromHex("#E47777").transparent(0.8)}, localize("errorBorder", "Border color of error boxes in the editor."));
var editorWarningForeground = registerColor("editorWarning.foreground", {dark: "#CCA700", light: "#E9A700", hc: null}, localize("editorWarning.foreground", "Foreground color of warning squigglies in the editor."));
var editorWarningBorder = registerColor("editorWarning.border", {dark: null, light: null, hc: Color.fromHex("#FFCC00").transparent(0.8)}, localize("warningBorder", "Border color of warning boxes in the editor."));
var editorInfoForeground = registerColor("editorInfo.foreground", {dark: "#75BEFF", light: "#75BEFF", hc: null}, localize("editorInfo.foreground", "Foreground color of info squigglies in the editor."));
var editorInfoBorder = registerColor("editorInfo.border", {dark: null, light: null, hc: Color.fromHex("#75BEFF").transparent(0.8)}, localize("infoBorder", "Border color of info boxes in the editor."));
var editorHintForeground = registerColor("editorHint.foreground", {dark: Color.fromHex("#eeeeee").transparent(0.7), light: "#6c6c6c", hc: null}, localize("editorHint.foreground", "Foreground color of hint squigglies in the editor."));
var editorHintBorder = registerColor("editorHint.border", {dark: null, light: null, hc: Color.fromHex("#eeeeee").transparent(0.8)}, localize("hintBorder", "Border color of hint boxes in the editor."));
var editorBackground = registerColor("editor.background", {light: "#fffffe", dark: "#1E1E1E", hc: Color.black}, localize("editorBackground", "Editor background color."));
var editorForeground = registerColor("editor.foreground", {light: "#333333", dark: "#BBBBBB", hc: Color.white}, localize("editorForeground", "Editor default foreground color."));
var editorWidgetBackground = registerColor("editorWidget.background", {dark: "#252526", light: "#F3F3F3", hc: "#0C141F"}, localize("editorWidgetBackground", "Background color of editor widgets, such as find/replace."));
var editorWidgetForeground = registerColor("editorWidget.foreground", {dark: foreground, light: foreground, hc: foreground}, localize("editorWidgetForeground", "Foreground color of editor widgets, such as find/replace."));
var editorWidgetBorder = registerColor("editorWidget.border", {dark: "#454545", light: "#C8C8C8", hc: contrastBorder}, localize("editorWidgetBorder", "Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget."));
var editorWidgetResizeBorder = registerColor("editorWidget.resizeBorder", {light: null, dark: null, hc: null}, localize("editorWidgetResizeBorder", "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget."));
var quickInputBackground = registerColor("quickInput.background", {dark: editorWidgetBackground, light: editorWidgetBackground, hc: editorWidgetBackground}, localize("pickerBackground", "Quick picker background color. The quick picker widget is the container for pickers like the command palette."));
var quickInputForeground = registerColor("quickInput.foreground", {dark: editorWidgetForeground, light: editorWidgetForeground, hc: editorWidgetForeground}, localize("pickerForeground", "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette."));
var quickInputTitleBackground = registerColor("quickInputTitle.background", {dark: new Color(new RGBA(255, 255, 255, 0.105)), light: new Color(new RGBA(0, 0, 0, 0.06)), hc: "#000000"}, localize("pickerTitleBackground", "Quick picker title background color. The quick picker widget is the container for pickers like the command palette."));
var pickerGroupForeground = registerColor("pickerGroup.foreground", {dark: "#3794FF", light: "#0066BF", hc: Color.white}, localize("pickerGroupForeground", "Quick picker color for grouping labels."));
var pickerGroupBorder = registerColor("pickerGroup.border", {dark: "#3F3F46", light: "#CCCEDB", hc: Color.white}, localize("pickerGroupBorder", "Quick picker color for grouping borders."));
var editorSelectionBackground = registerColor("editor.selectionBackground", {light: "#ADD6FF", dark: "#264F78", hc: "#f3f518"}, localize("editorSelectionBackground", "Color of the editor selection."));
var editorSelectionForeground = registerColor("editor.selectionForeground", {light: null, dark: null, hc: "#000000"}, localize("editorSelectionForeground", "Color of the selected text for high contrast."));
var editorInactiveSelection = registerColor("editor.inactiveSelectionBackground", {light: transparent(editorSelectionBackground, 0.5), dark: transparent(editorSelectionBackground, 0.5), hc: transparent(editorSelectionBackground, 0.5)}, localize("editorInactiveSelection", "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), true);
var editorSelectionHighlight = registerColor("editor.selectionHighlightBackground", {light: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), dark: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), hc: null}, localize("editorSelectionHighlight", "Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations."), true);
var editorSelectionHighlightBorder = registerColor("editor.selectionHighlightBorder", {light: null, dark: null, hc: activeContrastBorder}, localize("editorSelectionHighlightBorder", "Border color for regions with the same content as the selection."));
var editorFindMatch = registerColor("editor.findMatchBackground", {light: "#A8AC94", dark: "#515C6A", hc: null}, localize("editorFindMatch", "Color of the current search match."));
var editorFindMatchHighlight = registerColor("editor.findMatchHighlightBackground", {light: "#EA5C0055", dark: "#EA5C0055", hc: null}, localize("findMatchHighlight", "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), true);
var editorFindRangeHighlight = registerColor("editor.findRangeHighlightBackground", {dark: "#3a3d4166", light: "#b4b4b44d", hc: null}, localize("findRangeHighlight", "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), true);
var editorFindMatchBorder = registerColor("editor.findMatchBorder", {light: null, dark: null, hc: activeContrastBorder}, localize("editorFindMatchBorder", "Border color of the current search match."));
var editorFindMatchHighlightBorder = registerColor("editor.findMatchHighlightBorder", {light: null, dark: null, hc: activeContrastBorder}, localize("findMatchHighlightBorder", "Border color of the other search matches."));
var editorFindRangeHighlightBorder = registerColor("editor.findRangeHighlightBorder", {dark: null, light: null, hc: transparent(activeContrastBorder, 0.4)}, localize("findRangeHighlightBorder", "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), true);
var editorHoverHighlight = registerColor("editor.hoverHighlightBackground", {light: "#ADD6FF26", dark: "#264f7840", hc: "#ADD6FF26"}, localize("hoverHighlight", "Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations."), true);
var editorHoverBackground = registerColor("editorHoverWidget.background", {light: editorWidgetBackground, dark: editorWidgetBackground, hc: editorWidgetBackground}, localize("hoverBackground", "Background color of the editor hover."));
var editorHoverForeground = registerColor("editorHoverWidget.foreground", {light: editorWidgetForeground, dark: editorWidgetForeground, hc: editorWidgetForeground}, localize("hoverForeground", "Foreground color of the editor hover."));
var editorHoverBorder = registerColor("editorHoverWidget.border", {light: editorWidgetBorder, dark: editorWidgetBorder, hc: editorWidgetBorder}, localize("hoverBorder", "Border color of the editor hover."));
var editorHoverStatusBarBackground = registerColor("editorHoverWidget.statusBarBackground", {dark: lighten(editorHoverBackground, 0.2), light: darken(editorHoverBackground, 0.05), hc: editorWidgetBackground}, localize("statusBarBackground", "Background color of the editor hover status bar."));
var editorActiveLinkForeground = registerColor("editorLink.activeForeground", {dark: "#4E94CE", light: Color.blue, hc: Color.cyan}, localize("activeLinkForeground", "Color of active links."));
var editorLightBulbForeground = registerColor("editorLightBulb.foreground", {dark: "#FFCC00", light: "#DDB100", hc: "#FFCC00"}, localize("editorLightBulbForeground", "The color used for the lightbulb actions icon."));
var editorLightBulbAutoFixForeground = registerColor("editorLightBulbAutoFix.foreground", {dark: "#75BEFF", light: "#007ACC", hc: "#75BEFF"}, localize("editorLightBulbAutoFixForeground", "The color used for the lightbulb auto fix actions icon."));
var defaultInsertColor = new Color(new RGBA(155, 185, 85, 0.2));
var defaultRemoveColor = new Color(new RGBA(255, 0, 0, 0.2));
var diffInserted = registerColor("diffEditor.insertedTextBackground", {dark: defaultInsertColor, light: defaultInsertColor, hc: null}, localize("diffEditorInserted", "Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations."), true);
var diffRemoved = registerColor("diffEditor.removedTextBackground", {dark: defaultRemoveColor, light: defaultRemoveColor, hc: null}, localize("diffEditorRemoved", "Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations."), true);
var diffInsertedOutline = registerColor("diffEditor.insertedTextBorder", {dark: null, light: null, hc: "#33ff2eff"}, localize("diffEditorInsertedOutline", "Outline color for the text that got inserted."));
var diffRemovedOutline = registerColor("diffEditor.removedTextBorder", {dark: null, light: null, hc: "#FF008F"}, localize("diffEditorRemovedOutline", "Outline color for text that got removed."));
var diffBorder = registerColor("diffEditor.border", {dark: null, light: null, hc: contrastBorder}, localize("diffEditorBorder", "Border color between the two text editors."));
var diffDiagonalFill = registerColor("diffEditor.diagonalFill", {dark: "#cccccc33", light: "#22222233", hc: null}, localize("diffDiagonalFill", "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views."));
var listFocusBackground = registerColor("list.focusBackground", {dark: "#062F4A", light: "#D6EBFF", hc: null}, localize("listFocusBackground", "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listFocusForeground = registerColor("list.focusForeground", {dark: null, light: null, hc: null}, localize("listFocusForeground", "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listActiveSelectionBackground = registerColor("list.activeSelectionBackground", {dark: "#094771", light: "#0074E8", hc: null}, localize("listActiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listActiveSelectionForeground = registerColor("list.activeSelectionForeground", {dark: Color.white, light: Color.white, hc: null}, localize("listActiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listInactiveSelectionBackground = registerColor("list.inactiveSelectionBackground", {dark: "#37373D", light: "#E4E6F1", hc: null}, localize("listInactiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
var listInactiveSelectionForeground = registerColor("list.inactiveSelectionForeground", {dark: null, light: null, hc: null}, localize("listInactiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
var listInactiveFocusBackground = registerColor("list.inactiveFocusBackground", {dark: null, light: null, hc: null}, localize("listInactiveFocusBackground", "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
var listHoverBackground = registerColor("list.hoverBackground", {dark: "#2A2D2E", light: "#F0F0F0", hc: null}, localize("listHoverBackground", "List/Tree background when hovering over items using the mouse."));
var listHoverForeground = registerColor("list.hoverForeground", {dark: null, light: null, hc: null}, localize("listHoverForeground", "List/Tree foreground when hovering over items using the mouse."));
var listDropBackground = registerColor("list.dropBackground", {dark: listFocusBackground, light: listFocusBackground, hc: null}, localize("listDropBackground", "List/Tree drag and drop background when moving items around using the mouse."));
var listHighlightForeground = registerColor("list.highlightForeground", {dark: "#0097fb", light: "#0066BF", hc: focusBorder}, localize("highlight", "List/Tree foreground color of the match highlights when searching inside the list/tree."));
var listFilterWidgetBackground = registerColor("listFilterWidget.background", {light: "#efc1ad", dark: "#653723", hc: Color.black}, localize("listFilterWidgetBackground", "Background color of the type filter widget in lists and trees."));
var listFilterWidgetOutline = registerColor("listFilterWidget.outline", {dark: Color.transparent, light: Color.transparent, hc: "#f38518"}, localize("listFilterWidgetOutline", "Outline color of the type filter widget in lists and trees."));
var listFilterWidgetNoMatchesOutline = registerColor("listFilterWidget.noMatchesOutline", {dark: "#BE1100", light: "#BE1100", hc: contrastBorder}, localize("listFilterWidgetNoMatchesOutline", "Outline color of the type filter widget in lists and trees, when there are no matches."));
var treeIndentGuidesStroke = registerColor("tree.indentGuidesStroke", {dark: "#585858", light: "#a9a9a9", hc: "#a9a9a9"}, localize("treeIndentGuidesStroke", "Tree stroke color for the indentation guides."));
var menuBorder = registerColor("menu.border", {dark: null, light: null, hc: contrastBorder}, localize("menuBorder", "Border color of menus."));
var menuForeground = registerColor("menu.foreground", {dark: selectForeground, light: foreground, hc: selectForeground}, localize("menuForeground", "Foreground color of menu items."));
var menuBackground = registerColor("menu.background", {dark: selectBackground, light: selectBackground, hc: selectBackground}, localize("menuBackground", "Background color of menu items."));
var menuSelectionForeground = registerColor("menu.selectionForeground", {dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hc: listActiveSelectionForeground}, localize("menuSelectionForeground", "Foreground color of the selected menu item in menus."));
var menuSelectionBackground = registerColor("menu.selectionBackground", {dark: listActiveSelectionBackground, light: listActiveSelectionBackground, hc: listActiveSelectionBackground}, localize("menuSelectionBackground", "Background color of the selected menu item in menus."));
var menuSelectionBorder = registerColor("menu.selectionBorder", {dark: null, light: null, hc: activeContrastBorder}, localize("menuSelectionBorder", "Border color of the selected menu item in menus."));
var menuSeparatorBackground = registerColor("menu.separatorBackground", {dark: "#BBBBBB", light: "#888888", hc: contrastBorder}, localize("menuSeparatorBackground", "Color of a separator menu item in menus."));
var snippetTabstopHighlightBackground = registerColor("editor.snippetTabstopHighlightBackground", {dark: new Color(new RGBA(124, 124, 124, 0.3)), light: new Color(new RGBA(10, 50, 100, 0.2)), hc: new Color(new RGBA(124, 124, 124, 0.3))}, localize("snippetTabstopHighlightBackground", "Highlight background color of a snippet tabstop."));
var snippetTabstopHighlightBorder = registerColor("editor.snippetTabstopHighlightBorder", {dark: null, light: null, hc: null}, localize("snippetTabstopHighlightBorder", "Highlight border color of a snippet tabstop."));
var snippetFinalTabstopHighlightBackground = registerColor("editor.snippetFinalTabstopHighlightBackground", {dark: null, light: null, hc: null}, localize("snippetFinalTabstopHighlightBackground", "Highlight background color of the final tabstop of a snippet."));
var snippetFinalTabstopHighlightBorder = registerColor("editor.snippetFinalTabstopHighlightBorder", {dark: "#525252", light: new Color(new RGBA(10, 50, 100, 0.5)), hc: "#525252"}, localize("snippetFinalTabstopHighlightBorder", "Highlight border color of the final tabstop of a snippet."));
var overviewRulerFindMatchForeground = registerColor("editorOverviewRuler.findMatchForeground", {dark: "#d186167e", light: "#d186167e", hc: "#AB5A00"}, localize("overviewRulerFindMatchForeground", "Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations."), true);
var overviewRulerSelectionHighlightForeground = registerColor("editorOverviewRuler.selectionHighlightForeground", {dark: "#A0A0A0CC", light: "#A0A0A0CC", hc: "#A0A0A0CC"}, localize("overviewRulerSelectionHighlightForeground", "Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var minimapFindMatch = registerColor("minimap.findMatchHighlight", {light: "#d18616", dark: "#d18616", hc: "#AB5A00"}, localize("minimapFindMatchHighlight", "Minimap marker color for find matches."), true);
var minimapSelection = registerColor("minimap.selectionHighlight", {light: "#ADD6FF", dark: "#264F78", hc: "#ffffff"}, localize("minimapSelectionHighlight", "Minimap marker color for the editor selection."), true);
var minimapError = registerColor("minimap.errorHighlight", {dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hc: new Color(new RGBA(255, 50, 50, 1))}, localize("minimapError", "Minimap marker color for errors."));
var minimapWarning = registerColor("minimap.warningHighlight", {dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningBorder}, localize("overviewRuleWarning", "Minimap marker color for warnings."));
var minimapBackground = registerColor("minimap.background", {dark: null, light: null, hc: null}, localize("minimapBackground", "Minimap background color."));
var minimapSliderBackground = registerColor("minimapSlider.background", {light: transparent(scrollbarSliderBackground, 0.5), dark: transparent(scrollbarSliderBackground, 0.5), hc: transparent(scrollbarSliderBackground, 0.5)}, localize("minimapSliderBackground", "Minimap slider background color."));
var minimapSliderHoverBackground = registerColor("minimapSlider.hoverBackground", {light: transparent(scrollbarSliderHoverBackground, 0.5), dark: transparent(scrollbarSliderHoverBackground, 0.5), hc: transparent(scrollbarSliderHoverBackground, 0.5)}, localize("minimapSliderHoverBackground", "Minimap slider background color when hovering."));
var minimapSliderActiveBackground = registerColor("minimapSlider.activeBackground", {light: transparent(scrollbarSliderActiveBackground, 0.5), dark: transparent(scrollbarSliderActiveBackground, 0.5), hc: transparent(scrollbarSliderActiveBackground, 0.5)}, localize("minimapSliderActiveBackground", "Minimap slider background color when clicked on."));
var problemsErrorIconForeground = registerColor("problemsErrorIcon.foreground", {dark: editorErrorForeground, light: editorErrorForeground, hc: editorErrorForeground}, localize("problemsErrorIconForeground", "The color used for the problems error icon."));
var problemsWarningIconForeground = registerColor("problemsWarningIcon.foreground", {dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningForeground}, localize("problemsWarningIconForeground", "The color used for the problems warning icon."));
var problemsInfoIconForeground = registerColor("problemsInfoIcon.foreground", {dark: editorInfoForeground, light: editorInfoForeground, hc: editorInfoForeground}, localize("problemsInfoIconForeground", "The color used for the problems info icon."));
function darken(colorValue, factor) {
  return (theme) => {
    let color = resolveColorValue(colorValue, theme);
    if (color) {
      return color.darken(factor);
    }
    return void 0;
  };
}
function lighten(colorValue, factor) {
  return (theme) => {
    let color = resolveColorValue(colorValue, theme);
    if (color) {
      return color.lighten(factor);
    }
    return void 0;
  };
}
function transparent(colorValue, factor) {
  return (theme) => {
    let color = resolveColorValue(colorValue, theme);
    if (color) {
      return color.transparent(factor);
    }
    return void 0;
  };
}
function lessProminent(colorValue, backgroundColorValue, factor, transparency) {
  return (theme) => {
    let from = resolveColorValue(colorValue, theme);
    if (from) {
      let backgroundColor = resolveColorValue(backgroundColorValue, theme);
      if (backgroundColor) {
        if (from.isDarkerThan(backgroundColor)) {
          return Color.getLighterColor(from, backgroundColor, factor).transparent(transparency);
        }
        return Color.getDarkerColor(from, backgroundColor, factor).transparent(transparency);
      }
      return from.transparent(factor * transparency);
    }
    return void 0;
  };
}
function resolveColorValue(colorValue, theme) {
  if (colorValue === null) {
    return void 0;
  } else if (typeof colorValue === "string") {
    if (colorValue[0] === "#") {
      return Color.fromHex(colorValue);
    }
    return theme.getColor(colorValue);
  } else if (colorValue instanceof Color) {
    return colorValue;
  } else if (typeof colorValue === "function") {
    return colorValue(theme);
  }
  return void 0;
}
var workbenchColorsSchemaId = "vscode://schemas/workbench-colors";
var schemaRegistry = Registry2.as(Extensions.JSONContribution);
schemaRegistry.registerSchema(workbenchColorsSchemaId, colorRegistry.getColorSchema());
var delayer = new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(workbenchColorsSchemaId), 200);
colorRegistry.onDidChangeSchema(() => {
  if (!delayer.isScheduled()) {
    delayer.schedule();
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/common/view/editorColorRegistry.js
var editorLineHighlight = registerColor("editor.lineHighlightBackground", {dark: null, light: null, hc: null}, localize("lineHighlight", "Background color for the highlight of line at the cursor position."));
var editorLineHighlightBorder = registerColor("editor.lineHighlightBorder", {dark: "#282828", light: "#eeeeee", hc: "#f38518"}, localize("lineHighlightBorderBox", "Background color for the border around the line at the cursor position."));
var editorRangeHighlight = registerColor("editor.rangeHighlightBackground", {dark: "#ffffff0b", light: "#fdff0033", hc: null}, localize("rangeHighlight", "Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations."), true);
var editorRangeHighlightBorder = registerColor("editor.rangeHighlightBorder", {dark: null, light: null, hc: activeContrastBorder}, localize("rangeHighlightBorder", "Background color of the border around highlighted ranges."), true);
var editorSymbolHighlight = registerColor("editor.symbolHighlightBackground", {dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hc: null}, localize("symbolHighlight", "Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations."), true);
var editorSymbolHighlightBorder = registerColor("editor.symbolHighlightBorder", {dark: null, light: null, hc: activeContrastBorder}, localize("symbolHighlightBorder", "Background color of the border around highlighted symbols."), true);
var editorCursorForeground = registerColor("editorCursor.foreground", {dark: "#AEAFAD", light: Color.black, hc: Color.white}, localize("caret", "Color of the editor cursor."));
var editorCursorBackground = registerColor("editorCursor.background", null, localize("editorCursorBackground", "The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor."));
var editorWhitespaces = registerColor("editorWhitespace.foreground", {dark: "#e3e4e229", light: "#33333333", hc: "#e3e4e229"}, localize("editorWhitespaces", "Color of whitespace characters in the editor."));
var editorIndentGuides = registerColor("editorIndentGuide.background", {dark: editorWhitespaces, light: editorWhitespaces, hc: editorWhitespaces}, localize("editorIndentGuides", "Color of the editor indentation guides."));
var editorActiveIndentGuides = registerColor("editorIndentGuide.activeBackground", {dark: editorWhitespaces, light: editorWhitespaces, hc: editorWhitespaces}, localize("editorActiveIndentGuide", "Color of the active editor indentation guides."));
var editorLineNumbers = registerColor("editorLineNumber.foreground", {dark: "#858585", light: "#237893", hc: Color.white}, localize("editorLineNumbers", "Color of editor line numbers."));
var deprecatedEditorActiveLineNumber = registerColor("editorActiveLineNumber.foreground", {dark: "#c6c6c6", light: "#0B216F", hc: activeContrastBorder}, localize("editorActiveLineNumber", "Color of editor active line number"), false, localize("deprecatedEditorActiveLineNumber", "Id is deprecated. Use 'editorLineNumber.activeForeground' instead."));
var editorActiveLineNumber = registerColor("editorLineNumber.activeForeground", {dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hc: deprecatedEditorActiveLineNumber}, localize("editorActiveLineNumber", "Color of editor active line number"));
var editorRuler = registerColor("editorRuler.foreground", {dark: "#5A5A5A", light: Color.lightgrey, hc: Color.white}, localize("editorRuler", "Color of the editor rulers."));
var editorCodeLensForeground = registerColor("editorCodeLens.foreground", {dark: "#999999", light: "#999999", hc: "#999999"}, localize("editorCodeLensForeground", "Foreground color of editor CodeLens"));
var editorBracketMatchBackground = registerColor("editorBracketMatch.background", {dark: "#0064001a", light: "#0064001a", hc: "#0064001a"}, localize("editorBracketMatchBackground", "Background color behind matching brackets"));
var editorBracketMatchBorder = registerColor("editorBracketMatch.border", {dark: "#888", light: "#B9B9B9", hc: contrastBorder}, localize("editorBracketMatchBorder", "Color for matching brackets boxes"));
var editorOverviewRulerBorder = registerColor("editorOverviewRuler.border", {dark: "#7f7f7f4d", light: "#7f7f7f4d", hc: "#7f7f7f4d"}, localize("editorOverviewRulerBorder", "Color of the overview ruler border."));
var editorOverviewRulerBackground = registerColor("editorOverviewRuler.background", null, localize("editorOverviewRulerBackground", "Background color of the editor overview ruler. Only used when the minimap is enabled and placed on the right side of the editor."));
var editorGutter = registerColor("editorGutter.background", {dark: editorBackground, light: editorBackground, hc: editorBackground}, localize("editorGutter", "Background color of the editor gutter. The gutter contains the glyph margins and the line numbers."));
var editorUnnecessaryCodeBorder = registerColor("editorUnnecessaryCode.border", {dark: null, light: null, hc: Color.fromHex("#fff").transparent(0.8)}, localize("unnecessaryCodeBorder", "Border color of unnecessary (unused) source code in the editor."));
var editorUnnecessaryCodeOpacity = registerColor("editorUnnecessaryCode.opacity", {dark: Color.fromHex("#000a"), light: Color.fromHex("#0007"), hc: null}, localize("unnecessaryCodeOpacity", `Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  'editorUnnecessaryCode.border' theme color to underline unnecessary code instead of fading it out.`));
var rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));
var overviewRulerRangeHighlight = registerColor("editorOverviewRuler.rangeHighlightForeground", {dark: rulerRangeDefault, light: rulerRangeDefault, hc: rulerRangeDefault}, localize("overviewRulerRangeHighlight", "Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var overviewRulerError = registerColor("editorOverviewRuler.errorForeground", {dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hc: new Color(new RGBA(255, 50, 50, 1))}, localize("overviewRuleError", "Overview ruler marker color for errors."));
var overviewRulerWarning = registerColor("editorOverviewRuler.warningForeground", {dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningBorder}, localize("overviewRuleWarning", "Overview ruler marker color for warnings."));
var overviewRulerInfo = registerColor("editorOverviewRuler.infoForeground", {dark: editorInfoForeground, light: editorInfoForeground, hc: editorInfoBorder}, localize("overviewRuleInfo", "Overview ruler marker color for infos."));
registerThemingParticipant((theme, collector) => {
  const background = theme.getColor(editorBackground);
  if (background) {
    collector.addRule(`.monaco-editor, .monaco-editor-background, .monaco-editor .inputarea.ime-input { background-color: ${background}; }`);
  }
  const foreground2 = theme.getColor(editorForeground);
  if (foreground2) {
    collector.addRule(`.monaco-editor, .monaco-editor .inputarea.ime-input { color: ${foreground2}; }`);
  }
  const gutter = theme.getColor(editorGutter);
  if (gutter) {
    collector.addRule(`.monaco-editor .margin { background-color: ${gutter}; }`);
  }
  const rangeHighlight = theme.getColor(editorRangeHighlight);
  if (rangeHighlight) {
    collector.addRule(`.monaco-editor .rangeHighlight { background-color: ${rangeHighlight}; }`);
  }
  const rangeHighlightBorder = theme.getColor(editorRangeHighlightBorder);
  if (rangeHighlightBorder) {
    collector.addRule(`.monaco-editor .rangeHighlight { border: 1px ${theme.type === "hc" ? "dotted" : "solid"} ${rangeHighlightBorder}; }`);
  }
  const symbolHighlight = theme.getColor(editorSymbolHighlight);
  if (symbolHighlight) {
    collector.addRule(`.monaco-editor .symbolHighlight { background-color: ${symbolHighlight}; }`);
  }
  const symbolHighlightBorder = theme.getColor(editorSymbolHighlightBorder);
  if (symbolHighlightBorder) {
    collector.addRule(`.monaco-editor .symbolHighlight { border: 1px ${theme.type === "hc" ? "dotted" : "solid"} ${symbolHighlightBorder}; }`);
  }
  const invisibles = theme.getColor(editorWhitespaces);
  if (invisibles) {
    collector.addRule(`.monaco-editor .mtkw { color: ${invisibles} !important; }`);
    collector.addRule(`.monaco-editor .mtkz { color: ${invisibles} !important; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lineNumbers/lineNumbers.js
var LineNumbersOverlay = class extends DynamicViewOverlay {
  constructor(context) {
    super();
    this._context = context;
    this._readConfig();
    this._lastCursorModelPosition = new Position(1, 1);
    this._renderResult = null;
    this._context.addEventHandler(this);
  }
  _readConfig() {
    const options = this._context.configuration.options;
    this._lineHeight = options.get(51);
    const lineNumbers = options.get(52);
    this._renderLineNumbers = lineNumbers.renderType;
    this._renderCustomLineNumbers = lineNumbers.renderFn;
    this._renderFinalNewline = options.get(76);
    const layoutInfo = options.get(117);
    this._lineNumbersLeft = layoutInfo.lineNumbersLeft;
    this._lineNumbersWidth = layoutInfo.lineNumbersWidth;
  }
  dispose() {
    this._context.removeEventHandler(this);
    this._renderResult = null;
    super.dispose();
  }
  onConfigurationChanged(e) {
    this._readConfig();
    return true;
  }
  onCursorStateChanged(e) {
    const primaryViewPosition = e.selections[0].getPosition();
    this._lastCursorModelPosition = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(primaryViewPosition);
    if (this._renderLineNumbers === 2 || this._renderLineNumbers === 3) {
      return true;
    }
    return false;
  }
  onFlushed(e) {
    return true;
  }
  onLinesChanged(e) {
    return true;
  }
  onLinesDeleted(e) {
    return true;
  }
  onLinesInserted(e) {
    return true;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return true;
  }
  _getLineRenderLineNumber(viewLineNumber) {
    const modelPosition = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(viewLineNumber, 1));
    if (modelPosition.column !== 1) {
      return "";
    }
    const modelLineNumber = modelPosition.lineNumber;
    if (this._renderCustomLineNumbers) {
      return this._renderCustomLineNumbers(modelLineNumber);
    }
    if (this._renderLineNumbers === 2) {
      const diff = Math.abs(this._lastCursorModelPosition.lineNumber - modelLineNumber);
      if (diff === 0) {
        return '<span class="relative-current-line-number">' + modelLineNumber + "</span>";
      }
      return String(diff);
    }
    if (this._renderLineNumbers === 3) {
      if (this._lastCursorModelPosition.lineNumber === modelLineNumber) {
        return String(modelLineNumber);
      }
      if (modelLineNumber % 10 === 0) {
        return String(modelLineNumber);
      }
      return "";
    }
    return String(modelLineNumber);
  }
  prepareRender(ctx) {
    if (this._renderLineNumbers === 0) {
      this._renderResult = null;
      return;
    }
    const lineHeightClassName = isLinux ? this._lineHeight % 2 === 0 ? " lh-even" : " lh-odd" : "";
    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;
    const visibleEndLineNumber = ctx.visibleRange.endLineNumber;
    const common = '<div class="' + LineNumbersOverlay.CLASS_NAME + lineHeightClassName + '" style="left:' + this._lineNumbersLeft.toString() + "px;width:" + this._lineNumbersWidth.toString() + 'px;">';
    const lineCount = this._context.model.getLineCount();
    const output = [];
    for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
      const lineIndex = lineNumber - visibleStartLineNumber;
      if (!this._renderFinalNewline) {
        if (lineNumber === lineCount && this._context.model.getLineLength(lineNumber) === 0) {
          output[lineIndex] = "";
          continue;
        }
      }
      const renderLineNumber = this._getLineRenderLineNumber(lineNumber);
      if (renderLineNumber) {
        output[lineIndex] = common + renderLineNumber + "</div>";
      } else {
        output[lineIndex] = "";
      }
    }
    this._renderResult = output;
  }
  render(startLineNumber, lineNumber) {
    if (!this._renderResult) {
      return "";
    }
    const lineIndex = lineNumber - startLineNumber;
    if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
      return "";
    }
    return this._renderResult[lineIndex];
  }
};
LineNumbersOverlay.CLASS_NAME = "line-numbers";
registerThemingParticipant((theme, collector) => {
  const lineNumbers = theme.getColor(editorLineNumbers);
  if (lineNumbers) {
    collector.addRule(`.monaco-editor .line-numbers { color: ${lineNumbers}; }`);
  }
  const activeLineNumber = theme.getColor(editorActiveLineNumber);
  if (activeLineNumber) {
    collector.addRule(`.monaco-editor .current-line ~ .line-numbers { color: ${activeLineNumber}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/margin/margin.js
var Margin = class extends ViewPart {
  constructor(context) {
    super(context);
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._canUseLayerHinting = !options.get(23);
    this._contentLeft = layoutInfo.contentLeft;
    this._glyphMarginLeft = layoutInfo.glyphMarginLeft;
    this._glyphMarginWidth = layoutInfo.glyphMarginWidth;
    this._domNode = createFastDomNode(document.createElement("div"));
    this._domNode.setClassName(Margin.OUTER_CLASS_NAME);
    this._domNode.setPosition("absolute");
    this._domNode.setAttribute("role", "presentation");
    this._domNode.setAttribute("aria-hidden", "true");
    this._glyphMarginBackgroundDomNode = createFastDomNode(document.createElement("div"));
    this._glyphMarginBackgroundDomNode.setClassName(Margin.CLASS_NAME);
    this._domNode.appendChild(this._glyphMarginBackgroundDomNode);
  }
  dispose() {
    super.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._canUseLayerHinting = !options.get(23);
    this._contentLeft = layoutInfo.contentLeft;
    this._glyphMarginLeft = layoutInfo.glyphMarginLeft;
    this._glyphMarginWidth = layoutInfo.glyphMarginWidth;
    return true;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollTopChanged;
  }
  prepareRender(ctx) {
  }
  render(ctx) {
    this._domNode.setLayerHinting(this._canUseLayerHinting);
    this._domNode.setContain("strict");
    const adjustedScrollTop = ctx.scrollTop - ctx.bigNumbersDelta;
    this._domNode.setTop(-adjustedScrollTop);
    const height = Math.min(ctx.scrollHeight, 1e6);
    this._domNode.setHeight(height);
    this._domNode.setWidth(this._contentLeft);
    this._glyphMarginBackgroundDomNode.setLeft(this._glyphMarginLeft);
    this._glyphMarginBackgroundDomNode.setWidth(this._glyphMarginWidth);
    this._glyphMarginBackgroundDomNode.setHeight(height);
  }
};
Margin.CLASS_NAME = "glyph-margin";
Margin.OUTER_CLASS_NAME = "margin";

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/mouseCursor/mouseCursor.js
var MOUSE_CURSOR_TEXT_CSS_CLASS_NAME = `monaco-mouse-cursor-text`;

// ../../node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaHandler.js
var VisibleTextAreaData = class {
  constructor(top, left, width) {
    this.top = top;
    this.left = left;
    this.width = width;
  }
  setWidth(width) {
    return new VisibleTextAreaData(this.top, this.left, width);
  }
};
var canUseZeroSizeTextarea = isEdge || isFirefox;
var TextAreaHandler = class extends ViewPart {
  constructor(context, viewController, viewHelper) {
    super(context);
    this._primaryCursorPosition = new Position(1, 1);
    this._primaryCursorVisibleRange = null;
    this._viewController = viewController;
    this._viewHelper = viewHelper;
    this._scrollLeft = 0;
    this._scrollTop = 0;
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._setAccessibilityOptions(options);
    this._contentLeft = layoutInfo.contentLeft;
    this._contentWidth = layoutInfo.contentWidth;
    this._contentHeight = layoutInfo.height;
    this._fontInfo = options.get(36);
    this._lineHeight = options.get(51);
    this._emptySelectionClipboard = options.get(26);
    this._copyWithSyntaxHighlighting = options.get(16);
    this._visibleTextArea = null;
    this._selections = [new Selection(1, 1, 1, 1)];
    this._modelSelections = [new Selection(1, 1, 1, 1)];
    this._lastRenderPosition = null;
    this.textArea = createFastDomNode(document.createElement("textarea"));
    PartFingerprints.write(this.textArea, 6);
    this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);
    this.textArea.setAttribute("wrap", "off");
    this.textArea.setAttribute("autocorrect", "off");
    this.textArea.setAttribute("autocapitalize", "off");
    this.textArea.setAttribute("autocomplete", "off");
    this.textArea.setAttribute("spellcheck", "false");
    this.textArea.setAttribute("aria-label", this._getAriaLabel(options));
    this.textArea.setAttribute("tabindex", String(options.get(102)));
    this.textArea.setAttribute("role", "textbox");
    this.textArea.setAttribute("aria-roledescription", localize("editor", "editor"));
    this.textArea.setAttribute("aria-multiline", "true");
    this.textArea.setAttribute("aria-haspopup", "false");
    this.textArea.setAttribute("aria-autocomplete", "both");
    if (isWeb && options.get(72)) {
      this.textArea.setAttribute("readonly", "true");
    }
    this.textAreaCover = createFastDomNode(document.createElement("div"));
    this.textAreaCover.setPosition("absolute");
    const simpleModel = {
      getLineCount: () => {
        return this._context.model.getLineCount();
      },
      getLineMaxColumn: (lineNumber) => {
        return this._context.model.getLineMaxColumn(lineNumber);
      },
      getValueInRange: (range2, eol) => {
        return this._context.model.getValueInRange(range2, eol);
      }
    };
    const textAreaInputHost = {
      getDataToCopy: (generateHTML) => {
        const rawTextToCopy = this._context.model.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, isWindows);
        const newLineCharacter = this._context.model.getEOL();
        const isFromEmptySelection = this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty();
        const multicursorText = Array.isArray(rawTextToCopy) ? rawTextToCopy : null;
        const text = Array.isArray(rawTextToCopy) ? rawTextToCopy.join(newLineCharacter) : rawTextToCopy;
        let html = void 0;
        let mode = null;
        if (generateHTML) {
          if (CopyOptions.forceCopyWithSyntaxHighlighting || this._copyWithSyntaxHighlighting && text.length < 65536) {
            const richText = this._context.model.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);
            if (richText) {
              html = richText.html;
              mode = richText.mode;
            }
          }
        }
        return {
          isFromEmptySelection,
          multicursorText,
          text,
          html,
          mode
        };
      },
      getScreenReaderContent: (currentState) => {
        if (this._accessibilitySupport === 1) {
          if (isMacintosh) {
            const selection = this._selections[0];
            if (selection.isEmpty()) {
              const position = selection.getStartPosition();
              let textBefore = this._getWordBeforePosition(position);
              if (textBefore.length === 0) {
                textBefore = this._getCharacterBeforePosition(position);
              }
              if (textBefore.length > 0) {
                return new TextAreaState(textBefore, textBefore.length, textBefore.length, position, position);
              }
            }
          }
          return TextAreaState.EMPTY;
        }
        return PagedScreenReaderStrategy.fromEditorSelection(currentState, simpleModel, this._selections[0], this._accessibilityPageSize, this._accessibilitySupport === 0);
      },
      deduceModelPosition: (viewAnchorPosition, deltaOffset, lineFeedCnt) => {
        return this._context.model.deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt);
      }
    };
    this._textAreaInput = this._register(new TextAreaInput(textAreaInputHost, this.textArea));
    this._register(this._textAreaInput.onKeyDown((e) => {
      this._viewController.emitKeyDown(e);
    }));
    this._register(this._textAreaInput.onKeyUp((e) => {
      this._viewController.emitKeyUp(e);
    }));
    this._register(this._textAreaInput.onPaste((e) => {
      let pasteOnNewLine = false;
      let multicursorText = null;
      let mode = null;
      if (e.metadata) {
        pasteOnNewLine = this._emptySelectionClipboard && !!e.metadata.isFromEmptySelection;
        multicursorText = typeof e.metadata.multicursorText !== "undefined" ? e.metadata.multicursorText : null;
        mode = e.metadata.mode;
      }
      this._viewController.paste(e.text, pasteOnNewLine, multicursorText, mode);
    }));
    this._register(this._textAreaInput.onCut(() => {
      this._viewController.cut();
    }));
    this._register(this._textAreaInput.onType((e) => {
      if (e.replaceCharCnt) {
        this._viewController.replacePreviousChar(e.text, e.replaceCharCnt);
      } else {
        this._viewController.type(e.text);
      }
    }));
    this._register(this._textAreaInput.onSelectionChangeRequest((modelSelection) => {
      this._viewController.setSelection(modelSelection);
    }));
    this._register(this._textAreaInput.onCompositionStart((e) => {
      const lineNumber = this._selections[0].startLineNumber;
      const column = this._selections[0].startColumn - (e.moveOneCharacterLeft ? 1 : 0);
      this._context.model.revealRange("keyboard", true, new Range(lineNumber, column, lineNumber, column), 0, 1);
      const visibleRange = this._viewHelper.visibleRangeForPositionRelativeToEditor(lineNumber, column);
      if (visibleRange) {
        this._visibleTextArea = new VisibleTextAreaData(this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber), visibleRange.left, canUseZeroSizeTextarea ? 0 : 1);
        this._render();
      }
      this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME} ime-input`);
      this._viewController.compositionStart();
    }));
    this._register(this._textAreaInput.onCompositionUpdate((e) => {
      if (isEdge) {
        this._visibleTextArea = this._visibleTextArea.setWidth(0);
      } else {
        this._visibleTextArea = this._visibleTextArea.setWidth(measureText(e.data, this._fontInfo));
      }
      this._render();
    }));
    this._register(this._textAreaInput.onCompositionEnd(() => {
      this._visibleTextArea = null;
      this._render();
      this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);
      this._viewController.compositionEnd();
    }));
    this._register(this._textAreaInput.onFocus(() => {
      this._context.model.setHasFocus(true);
    }));
    this._register(this._textAreaInput.onBlur(() => {
      this._context.model.setHasFocus(false);
    }));
  }
  dispose() {
    super.dispose();
  }
  _getWordBeforePosition(position) {
    const lineContent = this._context.model.getLineContent(position.lineNumber);
    const wordSeparators2 = getMapForWordSeparators(this._context.configuration.options.get(105));
    let column = position.column;
    let distance = 0;
    while (column > 1) {
      const charCode = lineContent.charCodeAt(column - 2);
      const charClass = wordSeparators2.get(charCode);
      if (charClass !== 0 || distance > 50) {
        return lineContent.substring(column - 1, position.column - 1);
      }
      distance++;
      column--;
    }
    return lineContent.substring(0, position.column - 1);
  }
  _getCharacterBeforePosition(position) {
    if (position.column > 1) {
      const lineContent = this._context.model.getLineContent(position.lineNumber);
      const charBefore = lineContent.charAt(position.column - 2);
      if (!isHighSurrogate(charBefore.charCodeAt(0))) {
        return charBefore;
      }
    }
    return "";
  }
  _getAriaLabel(options) {
    const accessibilitySupport = options.get(2);
    if (accessibilitySupport === 1) {
      return localize("accessibilityOffAriaLabel", "The editor is not accessible at this time. Press {0} for options.", isLinux ? "Shift+Alt+F1" : "Alt+F1");
    }
    return options.get(4);
  }
  _setAccessibilityOptions(options) {
    this._accessibilitySupport = options.get(2);
    const accessibilityPageSize = options.get(3);
    if (this._accessibilitySupport === 2 && accessibilityPageSize === EditorOptions.accessibilityPageSize.defaultValue) {
      this._accessibilityPageSize = 100;
    } else {
      this._accessibilityPageSize = accessibilityPageSize;
    }
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._setAccessibilityOptions(options);
    this._contentLeft = layoutInfo.contentLeft;
    this._contentWidth = layoutInfo.contentWidth;
    this._contentHeight = layoutInfo.height;
    this._fontInfo = options.get(36);
    this._lineHeight = options.get(51);
    this._emptySelectionClipboard = options.get(26);
    this._copyWithSyntaxHighlighting = options.get(16);
    this.textArea.setAttribute("aria-label", this._getAriaLabel(options));
    this.textArea.setAttribute("tabindex", String(options.get(102)));
    if (isWeb && e.hasChanged(72)) {
      if (options.get(72)) {
        this.textArea.setAttribute("readonly", "true");
      } else {
        this.textArea.removeAttribute("readonly");
      }
    }
    if (e.hasChanged(2)) {
      this._textAreaInput.writeScreenReaderContent("strategy changed");
    }
    return true;
  }
  onCursorStateChanged(e) {
    this._selections = e.selections.slice(0);
    this._modelSelections = e.modelSelections.slice(0);
    this._textAreaInput.writeScreenReaderContent("selection changed");
    return true;
  }
  onDecorationsChanged(e) {
    return true;
  }
  onFlushed(e) {
    return true;
  }
  onLinesChanged(e) {
    return true;
  }
  onLinesDeleted(e) {
    return true;
  }
  onLinesInserted(e) {
    return true;
  }
  onScrollChanged(e) {
    this._scrollLeft = e.scrollLeft;
    this._scrollTop = e.scrollTop;
    return true;
  }
  onZonesChanged(e) {
    return true;
  }
  isFocused() {
    return this._textAreaInput.isFocused();
  }
  focusTextArea() {
    this._textAreaInput.focusTextArea();
  }
  getLastRenderData() {
    return this._lastRenderPosition;
  }
  setAriaOptions(options) {
    if (options.activeDescendant) {
      this.textArea.setAttribute("aria-haspopup", "true");
      this.textArea.setAttribute("aria-autocomplete", "list");
      this.textArea.setAttribute("aria-activedescendant", options.activeDescendant);
    } else {
      this.textArea.setAttribute("aria-haspopup", "false");
      this.textArea.setAttribute("aria-autocomplete", "both");
      this.textArea.removeAttribute("aria-activedescendant");
    }
    if (options.role) {
      this.textArea.setAttribute("role", options.role);
    }
  }
  prepareRender(ctx) {
    this._primaryCursorPosition = new Position(this._selections[0].positionLineNumber, this._selections[0].positionColumn);
    this._primaryCursorVisibleRange = ctx.visibleRangeForPosition(this._primaryCursorPosition);
  }
  render(ctx) {
    this._textAreaInput.writeScreenReaderContent("render");
    this._render();
  }
  _render() {
    if (this._visibleTextArea) {
      this._renderInsideEditor(null, this._visibleTextArea.top - this._scrollTop, this._contentLeft + this._visibleTextArea.left - this._scrollLeft, this._visibleTextArea.width, this._lineHeight);
      return;
    }
    if (!this._primaryCursorVisibleRange) {
      this._renderAtTopLeft();
      return;
    }
    const left = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;
    if (left < this._contentLeft || left > this._contentLeft + this._contentWidth) {
      this._renderAtTopLeft();
      return;
    }
    const top = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;
    if (top < 0 || top > this._contentHeight) {
      this._renderAtTopLeft();
      return;
    }
    if (isMacintosh) {
      this._renderInsideEditor(this._primaryCursorPosition, top, left, canUseZeroSizeTextarea ? 0 : 1, this._lineHeight);
      return;
    }
    this._renderInsideEditor(this._primaryCursorPosition, top, left, canUseZeroSizeTextarea ? 0 : 1, canUseZeroSizeTextarea ? 0 : 1);
  }
  _renderInsideEditor(renderedPosition, top, left, width, height) {
    this._lastRenderPosition = renderedPosition;
    const ta = this.textArea;
    const tac = this.textAreaCover;
    Configuration2.applyFontInfo(ta, this._fontInfo);
    ta.setTop(top);
    ta.setLeft(left);
    ta.setWidth(width);
    ta.setHeight(height);
    tac.setTop(0);
    tac.setLeft(0);
    tac.setWidth(0);
    tac.setHeight(0);
  }
  _renderAtTopLeft() {
    this._lastRenderPosition = null;
    const ta = this.textArea;
    const tac = this.textAreaCover;
    Configuration2.applyFontInfo(ta, this._fontInfo);
    ta.setTop(0);
    ta.setLeft(0);
    tac.setTop(0);
    tac.setLeft(0);
    if (canUseZeroSizeTextarea) {
      ta.setWidth(0);
      ta.setHeight(0);
      tac.setWidth(0);
      tac.setHeight(0);
      return;
    }
    ta.setWidth(1);
    ta.setHeight(1);
    tac.setWidth(1);
    tac.setHeight(1);
    const options = this._context.configuration.options;
    if (options.get(42)) {
      tac.setClassName("monaco-editor-background textAreaCover " + Margin.OUTER_CLASS_NAME);
    } else {
      if (options.get(52).renderType !== 0) {
        tac.setClassName("monaco-editor-background textAreaCover " + LineNumbersOverlay.CLASS_NAME);
      } else {
        tac.setClassName("monaco-editor-background textAreaCover");
      }
    }
  }
};
function measureText(text, fontInfo) {
  const canvasElem = document.createElement("canvas");
  const context = canvasElem.getContext("2d");
  context.font = createFontString(fontInfo);
  const metrics = context.measureText(text);
  if (isFirefox) {
    return metrics.width + 2;
  } else {
    return metrics.width;
  }
}
function createFontString(bareFontInfo) {
  return doCreateFontString("normal", bareFontInfo.fontWeight, bareFontInfo.fontSize, bareFontInfo.lineHeight, bareFontInfo.fontFamily);
}
function doCreateFontString(fontStyle, fontWeight, fontSize, lineHeight, fontFamily) {
  return `${fontStyle} normal ${fontWeight} ${fontSize}px / ${lineHeight}px ${fontFamily}`;
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorColumnSelection.js
var ColumnSelection = class {
  static columnSelect(config, model2, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {
    let lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;
    let reversed = fromLineNumber > toLineNumber;
    let isRTL = fromVisibleColumn > toVisibleColumn;
    let isLTR = fromVisibleColumn < toVisibleColumn;
    let result = [];
    for (let i = 0; i < lineCount; i++) {
      let lineNumber = fromLineNumber + (reversed ? -i : i);
      let startColumn = CursorColumns.columnFromVisibleColumn2(config, model2, lineNumber, fromVisibleColumn);
      let endColumn = CursorColumns.columnFromVisibleColumn2(config, model2, lineNumber, toVisibleColumn);
      let visibleStartColumn = CursorColumns.visibleColumnFromColumn2(config, model2, new Position(lineNumber, startColumn));
      let visibleEndColumn = CursorColumns.visibleColumnFromColumn2(config, model2, new Position(lineNumber, endColumn));
      if (isLTR) {
        if (visibleStartColumn > toVisibleColumn) {
          continue;
        }
        if (visibleEndColumn < fromVisibleColumn) {
          continue;
        }
      }
      if (isRTL) {
        if (visibleEndColumn > fromVisibleColumn) {
          continue;
        }
        if (visibleStartColumn < toVisibleColumn) {
          continue;
        }
      }
      result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0, new Position(lineNumber, endColumn), 0));
    }
    if (result.length === 0) {
      for (let i = 0; i < lineCount; i++) {
        const lineNumber = fromLineNumber + (reversed ? -i : i);
        const maxColumn = model2.getLineMaxColumn(lineNumber);
        result.push(new SingleCursorState(new Range(lineNumber, maxColumn, lineNumber, maxColumn), 0, new Position(lineNumber, maxColumn), 0));
      }
    }
    return {
      viewStates: result,
      reversed,
      fromLineNumber,
      fromVisualColumn: fromVisibleColumn,
      toLineNumber,
      toVisualColumn: toVisibleColumn
    };
  }
  static columnSelectLeft(config, model2, prevColumnSelectData) {
    let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;
    if (toViewVisualColumn > 1) {
      toViewVisualColumn--;
    }
    return ColumnSelection.columnSelect(config, model2, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);
  }
  static columnSelectRight(config, model2, prevColumnSelectData) {
    let maxVisualViewColumn = 0;
    const minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);
    const maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);
    for (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {
      const lineMaxViewColumn = model2.getLineMaxColumn(lineNumber);
      const lineMaxVisualViewColumn = CursorColumns.visibleColumnFromColumn2(config, model2, new Position(lineNumber, lineMaxViewColumn));
      maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);
    }
    let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;
    if (toViewVisualColumn < maxVisualViewColumn) {
      toViewVisualColumn++;
    }
    return this.columnSelect(config, model2, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);
  }
  static columnSelectUp(config, model2, prevColumnSelectData, isPaged) {
    const linesCount = isPaged ? config.pageSize : 1;
    const toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);
    return this.columnSelect(config, model2, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);
  }
  static columnSelectDown(config, model2, prevColumnSelectData, isPaged) {
    const linesCount = isPaged ? config.pageSize : 1;
    const toViewLineNumber = Math.min(model2.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);
    return this.columnSelect(config, model2, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/commands/replaceCommand.js
var ReplaceCommand = class {
  constructor(range2, text, insertsAutoWhitespace = false) {
    this._range = range2;
    this._text = text;
    this.insertsAutoWhitespace = insertsAutoWhitespace;
  }
  getEditOperations(model2, builder) {
    builder.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(model2, helper) {
    let inverseEditOperations = helper.getInverseEditOperations();
    let srcRange = inverseEditOperations[0].range;
    return new Selection(srcRange.endLineNumber, srcRange.endColumn, srcRange.endLineNumber, srcRange.endColumn);
  }
};
var ReplaceCommandWithoutChangingPosition = class {
  constructor(range2, text, insertsAutoWhitespace = false) {
    this._range = range2;
    this._text = text;
    this.insertsAutoWhitespace = insertsAutoWhitespace;
  }
  getEditOperations(model2, builder) {
    builder.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(model2, helper) {
    let inverseEditOperations = helper.getInverseEditOperations();
    let srcRange = inverseEditOperations[0].range;
    return new Selection(srcRange.startLineNumber, srcRange.startColumn, srcRange.startLineNumber, srcRange.startColumn);
  }
};
var ReplaceCommandWithOffsetCursorState = class {
  constructor(range2, text, lineNumberDeltaOffset, columnDeltaOffset, insertsAutoWhitespace = false) {
    this._range = range2;
    this._text = text;
    this._columnDeltaOffset = columnDeltaOffset;
    this._lineNumberDeltaOffset = lineNumberDeltaOffset;
    this.insertsAutoWhitespace = insertsAutoWhitespace;
  }
  getEditOperations(model2, builder) {
    builder.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(model2, helper) {
    let inverseEditOperations = helper.getInverseEditOperations();
    let srcRange = inverseEditOperations[0].range;
    return new Selection(srcRange.endLineNumber + this._lineNumberDeltaOffset, srcRange.endColumn + this._columnDeltaOffset, srcRange.endLineNumber + this._lineNumberDeltaOffset, srcRange.endColumn + this._columnDeltaOffset);
  }
};
var ReplaceCommandThatPreservesSelection = class {
  constructor(editRange, text, initialSelection, forceMoveMarkers = false) {
    this._range = editRange;
    this._text = text;
    this._initialSelection = initialSelection;
    this._forceMoveMarkers = forceMoveMarkers;
    this._selectionId = null;
  }
  getEditOperations(model2, builder) {
    builder.addTrackedEditOperation(this._range, this._text, this._forceMoveMarkers);
    this._selectionId = builder.trackSelection(this._initialSelection);
  }
  computeCursorState(model2, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorMoveOperations.js
var CursorPosition = class {
  constructor(lineNumber, column, leftoverVisibleColumns) {
    this.lineNumber = lineNumber;
    this.column = column;
    this.leftoverVisibleColumns = leftoverVisibleColumns;
  }
};
var MoveOperations = class {
  static leftPosition(model2, lineNumber, column) {
    if (column > model2.getLineMinColumn(lineNumber)) {
      column = column - prevCharLength(model2.getLineContent(lineNumber), column - 1);
    } else if (lineNumber > 1) {
      lineNumber = lineNumber - 1;
      column = model2.getLineMaxColumn(lineNumber);
    }
    return new Position(lineNumber, column);
  }
  static left(config, model2, lineNumber, column) {
    const pos = MoveOperations.leftPosition(model2, lineNumber, column);
    return new CursorPosition(pos.lineNumber, pos.column, 0);
  }
  static moveLeft(config, model2, cursor, inSelectionMode, noOfColumns) {
    let lineNumber, column;
    if (cursor.hasSelection() && !inSelectionMode) {
      lineNumber = cursor.selection.startLineNumber;
      column = cursor.selection.startColumn;
    } else {
      let r = MoveOperations.left(config, model2, cursor.position.lineNumber, cursor.position.column - (noOfColumns - 1));
      lineNumber = r.lineNumber;
      column = r.column;
    }
    return cursor.move(inSelectionMode, lineNumber, column, 0);
  }
  static rightPosition(model2, lineNumber, column) {
    if (column < model2.getLineMaxColumn(lineNumber)) {
      column = column + nextCharLength(model2.getLineContent(lineNumber), column - 1);
    } else if (lineNumber < model2.getLineCount()) {
      lineNumber = lineNumber + 1;
      column = model2.getLineMinColumn(lineNumber);
    }
    return new Position(lineNumber, column);
  }
  static right(config, model2, lineNumber, column) {
    const pos = MoveOperations.rightPosition(model2, lineNumber, column);
    return new CursorPosition(pos.lineNumber, pos.column, 0);
  }
  static moveRight(config, model2, cursor, inSelectionMode, noOfColumns) {
    let lineNumber, column;
    if (cursor.hasSelection() && !inSelectionMode) {
      lineNumber = cursor.selection.endLineNumber;
      column = cursor.selection.endColumn;
    } else {
      let r = MoveOperations.right(config, model2, cursor.position.lineNumber, cursor.position.column + (noOfColumns - 1));
      lineNumber = r.lineNumber;
      column = r.column;
    }
    return cursor.move(inSelectionMode, lineNumber, column, 0);
  }
  static down(config, model2, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {
    const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model2.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;
    const lineCount = model2.getLineCount();
    const wasOnLastPosition = lineNumber === lineCount && column === model2.getLineMaxColumn(lineNumber);
    lineNumber = lineNumber + count;
    if (lineNumber > lineCount) {
      lineNumber = lineCount;
      if (allowMoveOnLastLine) {
        column = model2.getLineMaxColumn(lineNumber);
      } else {
        column = Math.min(model2.getLineMaxColumn(lineNumber), column);
      }
    } else {
      column = CursorColumns.columnFromVisibleColumn2(config, model2, lineNumber, currentVisibleColumn);
    }
    if (wasOnLastPosition) {
      leftoverVisibleColumns = 0;
    } else {
      leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model2.getLineContent(lineNumber), column, config.tabSize);
    }
    return new CursorPosition(lineNumber, column, leftoverVisibleColumns);
  }
  static moveDown(config, model2, cursor, inSelectionMode, linesCount) {
    let lineNumber, column;
    if (cursor.hasSelection() && !inSelectionMode) {
      lineNumber = cursor.selection.endLineNumber;
      column = cursor.selection.endColumn;
    } else {
      lineNumber = cursor.position.lineNumber;
      column = cursor.position.column;
    }
    let r = MoveOperations.down(config, model2, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);
    return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);
  }
  static translateDown(config, model2, cursor) {
    let selection = cursor.selection;
    let selectionStart = MoveOperations.down(config, model2, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);
    let position = MoveOperations.down(config, model2, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);
    return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);
  }
  static up(config, model2, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {
    const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model2.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;
    const wasOnFirstPosition = lineNumber === 1 && column === 1;
    lineNumber = lineNumber - count;
    if (lineNumber < 1) {
      lineNumber = 1;
      if (allowMoveOnFirstLine) {
        column = model2.getLineMinColumn(lineNumber);
      } else {
        column = Math.min(model2.getLineMaxColumn(lineNumber), column);
      }
    } else {
      column = CursorColumns.columnFromVisibleColumn2(config, model2, lineNumber, currentVisibleColumn);
    }
    if (wasOnFirstPosition) {
      leftoverVisibleColumns = 0;
    } else {
      leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model2.getLineContent(lineNumber), column, config.tabSize);
    }
    return new CursorPosition(lineNumber, column, leftoverVisibleColumns);
  }
  static moveUp(config, model2, cursor, inSelectionMode, linesCount) {
    let lineNumber, column;
    if (cursor.hasSelection() && !inSelectionMode) {
      lineNumber = cursor.selection.startLineNumber;
      column = cursor.selection.startColumn;
    } else {
      lineNumber = cursor.position.lineNumber;
      column = cursor.position.column;
    }
    let r = MoveOperations.up(config, model2, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);
    return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);
  }
  static translateUp(config, model2, cursor) {
    let selection = cursor.selection;
    let selectionStart = MoveOperations.up(config, model2, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);
    let position = MoveOperations.up(config, model2, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);
    return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);
  }
  static moveToBeginningOfLine(config, model2, cursor, inSelectionMode) {
    let lineNumber = cursor.position.lineNumber;
    let minColumn = model2.getLineMinColumn(lineNumber);
    let firstNonBlankColumn = model2.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;
    let column;
    let relevantColumnNumber = cursor.position.column;
    if (relevantColumnNumber === firstNonBlankColumn) {
      column = minColumn;
    } else {
      column = firstNonBlankColumn;
    }
    return cursor.move(inSelectionMode, lineNumber, column, 0);
  }
  static moveToEndOfLine(config, model2, cursor, inSelectionMode, sticky) {
    let lineNumber = cursor.position.lineNumber;
    let maxColumn = model2.getLineMaxColumn(lineNumber);
    return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 - maxColumn : 0);
  }
  static moveToBeginningOfBuffer(config, model2, cursor, inSelectionMode) {
    return cursor.move(inSelectionMode, 1, 1, 0);
  }
  static moveToEndOfBuffer(config, model2, cursor, inSelectionMode) {
    let lastLineNumber = model2.getLineCount();
    let lastColumn = model2.getLineMaxColumn(lastLineNumber);
    return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorDeleteOperations.js
var DeleteOperations = class {
  static deleteRight(prevEditOperationType, config, model2, selections) {
    let commands = [];
    let shouldPushStackElementBefore = prevEditOperationType !== 3;
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      let deleteSelection = selection;
      if (deleteSelection.isEmpty()) {
        let position = selection.getPosition();
        let rightOfPosition = MoveOperations.right(config, model2, position.lineNumber, position.column);
        deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);
      }
      if (deleteSelection.isEmpty()) {
        commands[i] = null;
        continue;
      }
      if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {
        shouldPushStackElementBefore = true;
      }
      commands[i] = new ReplaceCommand(deleteSelection, "");
    }
    return [shouldPushStackElementBefore, commands];
  }
  static _isAutoClosingPairDelete(config, model2, selections) {
    if (config.autoClosingBrackets === "never" && config.autoClosingQuotes === "never") {
      return false;
    }
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      const position = selection.getPosition();
      if (!selection.isEmpty()) {
        return false;
      }
      const lineText = model2.getLineContent(position.lineNumber);
      const character = lineText[position.column - 2];
      const autoClosingPairCandidates = config.autoClosingPairsOpen2.get(character);
      if (!autoClosingPairCandidates) {
        return false;
      }
      if (isQuote(character)) {
        if (config.autoClosingQuotes === "never") {
          return false;
        }
      } else {
        if (config.autoClosingBrackets === "never") {
          return false;
        }
      }
      const afterCharacter = lineText[position.column - 1];
      let foundAutoClosingPair = false;
      for (const autoClosingPairCandidate of autoClosingPairCandidates) {
        if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {
          foundAutoClosingPair = true;
        }
      }
      if (!foundAutoClosingPair) {
        return false;
      }
    }
    return true;
  }
  static _runAutoClosingPairDelete(config, model2, selections) {
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      const position = selections[i].getPosition();
      const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);
      commands[i] = new ReplaceCommand(deleteSelection, "");
    }
    return [true, commands];
  }
  static deleteLeft(prevEditOperationType, config, model2, selections) {
    if (this._isAutoClosingPairDelete(config, model2, selections)) {
      return this._runAutoClosingPairDelete(config, model2, selections);
    }
    let commands = [];
    let shouldPushStackElementBefore = prevEditOperationType !== 2;
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      let deleteSelection = selection;
      if (deleteSelection.isEmpty()) {
        let position = selection.getPosition();
        if (config.useTabStops && position.column > 1) {
          let lineContent = model2.getLineContent(position.lineNumber);
          let firstNonWhitespaceIndex2 = firstNonWhitespaceIndex(lineContent);
          let lastIndentationColumn = firstNonWhitespaceIndex2 === -1 ? lineContent.length + 1 : firstNonWhitespaceIndex2 + 1;
          if (position.column <= lastIndentationColumn) {
            let fromVisibleColumn = CursorColumns.visibleColumnFromColumn2(config, model2, position);
            let toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);
            let toColumn = CursorColumns.columnFromVisibleColumn2(config, model2, position.lineNumber, toVisibleColumn);
            deleteSelection = new Range(position.lineNumber, toColumn, position.lineNumber, position.column);
          } else {
            deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column);
          }
        } else {
          let leftOfPosition = MoveOperations.left(config, model2, position.lineNumber, position.column);
          deleteSelection = new Range(leftOfPosition.lineNumber, leftOfPosition.column, position.lineNumber, position.column);
        }
      }
      if (deleteSelection.isEmpty()) {
        commands[i] = null;
        continue;
      }
      if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {
        shouldPushStackElementBefore = true;
      }
      commands[i] = new ReplaceCommand(deleteSelection, "");
    }
    return [shouldPushStackElementBefore, commands];
  }
  static cut(config, model2, selections) {
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      if (selection.isEmpty()) {
        if (config.emptySelectionClipboard) {
          let position = selection.getPosition();
          let startLineNumber, startColumn, endLineNumber, endColumn;
          if (position.lineNumber < model2.getLineCount()) {
            startLineNumber = position.lineNumber;
            startColumn = 1;
            endLineNumber = position.lineNumber + 1;
            endColumn = 1;
          } else if (position.lineNumber > 1) {
            startLineNumber = position.lineNumber - 1;
            startColumn = model2.getLineMaxColumn(position.lineNumber - 1);
            endLineNumber = position.lineNumber;
            endColumn = model2.getLineMaxColumn(position.lineNumber);
          } else {
            startLineNumber = position.lineNumber;
            startColumn = 1;
            endLineNumber = position.lineNumber;
            endColumn = model2.getLineMaxColumn(position.lineNumber);
          }
          let deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
          if (!deleteSelection.isEmpty()) {
            commands[i] = new ReplaceCommand(deleteSelection, "");
          } else {
            commands[i] = null;
          }
        } else {
          commands[i] = null;
        }
      } else {
        commands[i] = new ReplaceCommand(selection, "");
      }
    }
    return new EditOperationResult(0, commands, {
      shouldPushStackElementBefore: true,
      shouldPushStackElementAfter: true
    });
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorWordOperations.js
var WordOperations = class {
  static _createWord(lineContent, wordType, nextCharClass, start, end) {
    return {start, end, wordType, nextCharClass};
  }
  static _findPreviousWordOnLine(wordSeparators2, model2, position) {
    let lineContent = model2.getLineContent(position.lineNumber);
    return this._doFindPreviousWordOnLine(lineContent, wordSeparators2, position);
  }
  static _doFindPreviousWordOnLine(lineContent, wordSeparators2, position) {
    let wordType = 0;
    for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {
      let chCode = lineContent.charCodeAt(chIndex);
      let chClass = wordSeparators2.get(chCode);
      if (chClass === 0) {
        if (wordType === 2) {
          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators2, wordType, chIndex + 1));
        }
        wordType = 1;
      } else if (chClass === 2) {
        if (wordType === 1) {
          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators2, wordType, chIndex + 1));
        }
        wordType = 2;
      } else if (chClass === 1) {
        if (wordType !== 0) {
          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators2, wordType, chIndex + 1));
        }
      }
    }
    if (wordType !== 0) {
      return this._createWord(lineContent, wordType, 1, 0, this._findEndOfWord(lineContent, wordSeparators2, wordType, 0));
    }
    return null;
  }
  static _findEndOfWord(lineContent, wordSeparators2, wordType, startIndex) {
    let len = lineContent.length;
    for (let chIndex = startIndex; chIndex < len; chIndex++) {
      let chCode = lineContent.charCodeAt(chIndex);
      let chClass = wordSeparators2.get(chCode);
      if (chClass === 1) {
        return chIndex;
      }
      if (wordType === 1 && chClass === 2) {
        return chIndex;
      }
      if (wordType === 2 && chClass === 0) {
        return chIndex;
      }
    }
    return len;
  }
  static _findNextWordOnLine(wordSeparators2, model2, position) {
    let lineContent = model2.getLineContent(position.lineNumber);
    return this._doFindNextWordOnLine(lineContent, wordSeparators2, position);
  }
  static _doFindNextWordOnLine(lineContent, wordSeparators2, position) {
    let wordType = 0;
    let len = lineContent.length;
    for (let chIndex = position.column - 1; chIndex < len; chIndex++) {
      let chCode = lineContent.charCodeAt(chIndex);
      let chClass = wordSeparators2.get(chCode);
      if (chClass === 0) {
        if (wordType === 2) {
          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators2, wordType, chIndex - 1), chIndex);
        }
        wordType = 1;
      } else if (chClass === 2) {
        if (wordType === 1) {
          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators2, wordType, chIndex - 1), chIndex);
        }
        wordType = 2;
      } else if (chClass === 1) {
        if (wordType !== 0) {
          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators2, wordType, chIndex - 1), chIndex);
        }
      }
    }
    if (wordType !== 0) {
      return this._createWord(lineContent, wordType, 1, this._findStartOfWord(lineContent, wordSeparators2, wordType, len - 1), len);
    }
    return null;
  }
  static _findStartOfWord(lineContent, wordSeparators2, wordType, startIndex) {
    for (let chIndex = startIndex; chIndex >= 0; chIndex--) {
      let chCode = lineContent.charCodeAt(chIndex);
      let chClass = wordSeparators2.get(chCode);
      if (chClass === 1) {
        return chIndex + 1;
      }
      if (wordType === 1 && chClass === 2) {
        return chIndex + 1;
      }
      if (wordType === 2 && chClass === 0) {
        return chIndex + 1;
      }
    }
    return 0;
  }
  static moveWordLeft(wordSeparators2, model2, position, wordNavigationType) {
    let lineNumber = position.lineNumber;
    let column = position.column;
    if (column === 1) {
      if (lineNumber > 1) {
        lineNumber = lineNumber - 1;
        column = model2.getLineMaxColumn(lineNumber);
      }
    }
    let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators2, model2, new Position(lineNumber, column));
    if (wordNavigationType === 0) {
      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);
    }
    if (wordNavigationType === 1) {
      if (prevWordOnLine && prevWordOnLine.wordType === 2 && prevWordOnLine.end - prevWordOnLine.start === 1 && prevWordOnLine.nextCharClass === 0) {
        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators2, model2, new Position(lineNumber, prevWordOnLine.start + 1));
      }
      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);
    }
    if (wordNavigationType === 3) {
      while (prevWordOnLine && prevWordOnLine.wordType === 2) {
        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators2, model2, new Position(lineNumber, prevWordOnLine.start + 1));
      }
      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);
    }
    if (prevWordOnLine && column <= prevWordOnLine.end + 1) {
      prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators2, model2, new Position(lineNumber, prevWordOnLine.start + 1));
    }
    return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);
  }
  static _moveWordPartLeft(model2, position) {
    const lineNumber = position.lineNumber;
    const maxColumn = model2.getLineMaxColumn(lineNumber);
    if (position.column === 1) {
      return lineNumber > 1 ? new Position(lineNumber - 1, model2.getLineMaxColumn(lineNumber - 1)) : position;
    }
    const lineContent = model2.getLineContent(lineNumber);
    for (let column = position.column - 1; column > 1; column--) {
      const left = lineContent.charCodeAt(column - 2);
      const right = lineContent.charCodeAt(column - 1);
      if (left === 95 && right !== 95) {
        return new Position(lineNumber, column);
      }
      if (isLowerAsciiLetter(left) && isUpperAsciiLetter(right)) {
        return new Position(lineNumber, column);
      }
      if (isUpperAsciiLetter(left) && isUpperAsciiLetter(right)) {
        if (column + 1 < maxColumn) {
          const rightRight = lineContent.charCodeAt(column);
          if (isLowerAsciiLetter(rightRight)) {
            return new Position(lineNumber, column);
          }
        }
      }
    }
    return new Position(lineNumber, 1);
  }
  static moveWordRight(wordSeparators2, model2, position, wordNavigationType) {
    let lineNumber = position.lineNumber;
    let column = position.column;
    let movedDown = false;
    if (column === model2.getLineMaxColumn(lineNumber)) {
      if (lineNumber < model2.getLineCount()) {
        movedDown = true;
        lineNumber = lineNumber + 1;
        column = 1;
      }
    }
    let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators2, model2, new Position(lineNumber, column));
    if (wordNavigationType === 2) {
      if (nextWordOnLine && nextWordOnLine.wordType === 2) {
        if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0) {
          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators2, model2, new Position(lineNumber, nextWordOnLine.end + 1));
        }
      }
      if (nextWordOnLine) {
        column = nextWordOnLine.end + 1;
      } else {
        column = model2.getLineMaxColumn(lineNumber);
      }
    } else if (wordNavigationType === 3) {
      if (movedDown) {
        column = 0;
      }
      while (nextWordOnLine && (nextWordOnLine.wordType === 2 || nextWordOnLine.start + 1 <= column)) {
        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators2, model2, new Position(lineNumber, nextWordOnLine.end + 1));
      }
      if (nextWordOnLine) {
        column = nextWordOnLine.start + 1;
      } else {
        column = model2.getLineMaxColumn(lineNumber);
      }
    } else {
      if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {
        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators2, model2, new Position(lineNumber, nextWordOnLine.end + 1));
      }
      if (nextWordOnLine) {
        column = nextWordOnLine.start + 1;
      } else {
        column = model2.getLineMaxColumn(lineNumber);
      }
    }
    return new Position(lineNumber, column);
  }
  static _moveWordPartRight(model2, position) {
    const lineNumber = position.lineNumber;
    const maxColumn = model2.getLineMaxColumn(lineNumber);
    if (position.column === maxColumn) {
      return lineNumber < model2.getLineCount() ? new Position(lineNumber + 1, 1) : position;
    }
    const lineContent = model2.getLineContent(lineNumber);
    for (let column = position.column + 1; column < maxColumn; column++) {
      const left = lineContent.charCodeAt(column - 2);
      const right = lineContent.charCodeAt(column - 1);
      if (left !== 95 && right === 95) {
        return new Position(lineNumber, column);
      }
      if (isLowerAsciiLetter(left) && isUpperAsciiLetter(right)) {
        return new Position(lineNumber, column);
      }
      if (isUpperAsciiLetter(left) && isUpperAsciiLetter(right)) {
        if (column + 1 < maxColumn) {
          const rightRight = lineContent.charCodeAt(column);
          if (isLowerAsciiLetter(rightRight)) {
            return new Position(lineNumber, column);
          }
        }
      }
    }
    return new Position(lineNumber, maxColumn);
  }
  static _deleteWordLeftWhitespace(model2, position) {
    const lineContent = model2.getLineContent(position.lineNumber);
    const startIndex = position.column - 2;
    const lastNonWhitespace = lastNonWhitespaceIndex(lineContent, startIndex);
    if (lastNonWhitespace + 1 < startIndex) {
      return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);
    }
    return null;
  }
  static deleteWordLeft(wordSeparators2, model2, selection, whitespaceHeuristics, wordNavigationType) {
    if (!selection.isEmpty()) {
      return selection;
    }
    const position = new Position(selection.positionLineNumber, selection.positionColumn);
    let lineNumber = position.lineNumber;
    let column = position.column;
    if (lineNumber === 1 && column === 1) {
      return null;
    }
    if (whitespaceHeuristics) {
      let r = this._deleteWordLeftWhitespace(model2, position);
      if (r) {
        return r;
      }
    }
    let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators2, model2, position);
    if (wordNavigationType === 0) {
      if (prevWordOnLine) {
        column = prevWordOnLine.start + 1;
      } else {
        if (column > 1) {
          column = 1;
        } else {
          lineNumber--;
          column = model2.getLineMaxColumn(lineNumber);
        }
      }
    } else {
      if (prevWordOnLine && column <= prevWordOnLine.end + 1) {
        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators2, model2, new Position(lineNumber, prevWordOnLine.start + 1));
      }
      if (prevWordOnLine) {
        column = prevWordOnLine.end + 1;
      } else {
        if (column > 1) {
          column = 1;
        } else {
          lineNumber--;
          column = model2.getLineMaxColumn(lineNumber);
        }
      }
    }
    return new Range(lineNumber, column, position.lineNumber, position.column);
  }
  static _deleteWordPartLeft(model2, selection) {
    if (!selection.isEmpty()) {
      return selection;
    }
    const pos = selection.getPosition();
    const toPosition = WordOperations._moveWordPartLeft(model2, pos);
    return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);
  }
  static _findFirstNonWhitespaceChar(str, startIndex) {
    let len = str.length;
    for (let chIndex = startIndex; chIndex < len; chIndex++) {
      let ch = str.charAt(chIndex);
      if (ch !== " " && ch !== "	") {
        return chIndex;
      }
    }
    return len;
  }
  static _deleteWordRightWhitespace(model2, position) {
    const lineContent = model2.getLineContent(position.lineNumber);
    const startIndex = position.column - 1;
    const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);
    if (startIndex + 1 < firstNonWhitespace) {
      return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);
    }
    return null;
  }
  static deleteWordRight(wordSeparators2, model2, selection, whitespaceHeuristics, wordNavigationType) {
    if (!selection.isEmpty()) {
      return selection;
    }
    const position = new Position(selection.positionLineNumber, selection.positionColumn);
    let lineNumber = position.lineNumber;
    let column = position.column;
    const lineCount = model2.getLineCount();
    const maxColumn = model2.getLineMaxColumn(lineNumber);
    if (lineNumber === lineCount && column === maxColumn) {
      return null;
    }
    if (whitespaceHeuristics) {
      let r = this._deleteWordRightWhitespace(model2, position);
      if (r) {
        return r;
      }
    }
    let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators2, model2, position);
    if (wordNavigationType === 2) {
      if (nextWordOnLine) {
        column = nextWordOnLine.end + 1;
      } else {
        if (column < maxColumn || lineNumber === lineCount) {
          column = maxColumn;
        } else {
          lineNumber++;
          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators2, model2, new Position(lineNumber, 1));
          if (nextWordOnLine) {
            column = nextWordOnLine.start + 1;
          } else {
            column = model2.getLineMaxColumn(lineNumber);
          }
        }
      }
    } else {
      if (nextWordOnLine && column >= nextWordOnLine.start + 1) {
        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators2, model2, new Position(lineNumber, nextWordOnLine.end + 1));
      }
      if (nextWordOnLine) {
        column = nextWordOnLine.start + 1;
      } else {
        if (column < maxColumn || lineNumber === lineCount) {
          column = maxColumn;
        } else {
          lineNumber++;
          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators2, model2, new Position(lineNumber, 1));
          if (nextWordOnLine) {
            column = nextWordOnLine.start + 1;
          } else {
            column = model2.getLineMaxColumn(lineNumber);
          }
        }
      }
    }
    return new Range(lineNumber, column, position.lineNumber, position.column);
  }
  static _deleteWordPartRight(model2, selection) {
    if (!selection.isEmpty()) {
      return selection;
    }
    const pos = selection.getPosition();
    const toPosition = WordOperations._moveWordPartRight(model2, pos);
    return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);
  }
  static _createWordAtPosition(model2, lineNumber, word) {
    const range2 = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);
    return {
      word: model2.getValueInRange(range2),
      startColumn: range2.startColumn,
      endColumn: range2.endColumn
    };
  }
  static getWordAtPosition(model2, _wordSeparators, position) {
    const wordSeparators2 = getMapForWordSeparators(_wordSeparators);
    const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators2, model2, position);
    if (prevWord && prevWord.wordType === 1 && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {
      return WordOperations._createWordAtPosition(model2, position.lineNumber, prevWord);
    }
    const nextWord = WordOperations._findNextWordOnLine(wordSeparators2, model2, position);
    if (nextWord && nextWord.wordType === 1 && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {
      return WordOperations._createWordAtPosition(model2, position.lineNumber, nextWord);
    }
    return null;
  }
  static word(config, model2, cursor, inSelectionMode, position) {
    const wordSeparators2 = getMapForWordSeparators(config.wordSeparators);
    let prevWord = WordOperations._findPreviousWordOnLine(wordSeparators2, model2, position);
    let nextWord = WordOperations._findNextWordOnLine(wordSeparators2, model2, position);
    if (!inSelectionMode) {
      let startColumn2;
      let endColumn2;
      if (prevWord && prevWord.wordType === 1 && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {
        startColumn2 = prevWord.start + 1;
        endColumn2 = prevWord.end + 1;
      } else if (nextWord && nextWord.wordType === 1 && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {
        startColumn2 = nextWord.start + 1;
        endColumn2 = nextWord.end + 1;
      } else {
        if (prevWord) {
          startColumn2 = prevWord.end + 1;
        } else {
          startColumn2 = 1;
        }
        if (nextWord) {
          endColumn2 = nextWord.start + 1;
        } else {
          endColumn2 = model2.getLineMaxColumn(position.lineNumber);
        }
      }
      return new SingleCursorState(new Range(position.lineNumber, startColumn2, position.lineNumber, endColumn2), 0, new Position(position.lineNumber, endColumn2), 0);
    }
    let startColumn;
    let endColumn;
    if (prevWord && prevWord.wordType === 1 && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {
      startColumn = prevWord.start + 1;
      endColumn = prevWord.end + 1;
    } else if (nextWord && nextWord.wordType === 1 && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {
      startColumn = nextWord.start + 1;
      endColumn = nextWord.end + 1;
    } else {
      startColumn = position.column;
      endColumn = position.column;
    }
    let lineNumber = position.lineNumber;
    let column;
    if (cursor.selectionStart.containsPosition(position)) {
      column = cursor.selectionStart.endColumn;
    } else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {
      column = startColumn;
      let possiblePosition = new Position(lineNumber, column);
      if (cursor.selectionStart.containsPosition(possiblePosition)) {
        column = cursor.selectionStart.endColumn;
      }
    } else {
      column = endColumn;
      let possiblePosition = new Position(lineNumber, column);
      if (cursor.selectionStart.containsPosition(possiblePosition)) {
        column = cursor.selectionStart.startColumn;
      }
    }
    return cursor.move(true, lineNumber, column, 0);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorMoveCommands.js
var CursorMoveCommands = class {
  static addCursorDown(viewModel, cursors, useLogicalLine) {
    let result = [], resultLen = 0;
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);
      if (useLogicalLine) {
        result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));
      } else {
        result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));
      }
    }
    return result;
  }
  static addCursorUp(viewModel, cursors, useLogicalLine) {
    let result = [], resultLen = 0;
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);
      if (useLogicalLine) {
        result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));
      } else {
        result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));
      }
    }
    return result;
  }
  static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);
    }
    return result;
  }
  static _moveToLineStart(viewModel, cursor, inSelectionMode) {
    const currentViewStateColumn = cursor.viewState.position.column;
    const currentModelStateColumn = cursor.modelState.position.column;
    const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;
    const currentViewStatelineNumber = cursor.viewState.position.lineNumber;
    const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);
    const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;
    if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {
      return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);
    } else {
      return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);
    }
  }
  static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {
    return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));
  }
  static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {
    return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));
  }
  static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);
    }
    return result;
  }
  static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {
    const viewStatePosition = cursor.viewState.position;
    const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);
    const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;
    const modelStatePosition = cursor.modelState.position;
    const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);
    const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;
    if (isEndOfViewLine || isEndLineOfWrappedLine) {
      return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);
    } else {
      return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);
    }
  }
  static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {
    return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));
  }
  static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {
    return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));
  }
  static expandLineSelection(viewModel, cursors) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      const startLineNumber = cursor.modelState.selection.startLineNumber;
      const lineCount = viewModel.model.getLineCount();
      let endLineNumber = cursor.modelState.selection.endLineNumber;
      let endColumn;
      if (endLineNumber === lineCount) {
        endColumn = viewModel.model.getLineMaxColumn(lineCount);
      } else {
        endLineNumber++;
        endColumn = 1;
      }
      result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0, new Position(endLineNumber, endColumn), 0));
    }
    return result;
  }
  static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));
    }
    return result;
  }
  static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));
    }
    return result;
  }
  static selectAll(viewModel, cursor) {
    const lineCount = viewModel.model.getLineCount();
    const maxColumn = viewModel.model.getLineMaxColumn(lineCount);
    return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(lineCount, maxColumn), 0));
  }
  static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {
    const position = viewModel.model.validatePosition(_position);
    const viewPosition = _viewPosition ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position) : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position);
    if (!inSelectionMode || !cursor.modelState.hasSelection()) {
      const lineCount = viewModel.model.getLineCount();
      let selectToLineNumber = position.lineNumber + 1;
      let selectToColumn = 1;
      if (selectToLineNumber > lineCount) {
        selectToLineNumber = lineCount;
        selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);
      }
      return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 0, new Position(selectToLineNumber, selectToColumn), 0));
    }
    const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;
    if (position.lineNumber < enteringLineNumber) {
      return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), viewPosition.lineNumber, 1, 0));
    } else if (position.lineNumber > enteringLineNumber) {
      const lineCount = viewModel.getLineCount();
      let selectToViewLineNumber = viewPosition.lineNumber + 1;
      let selectToViewColumn = 1;
      if (selectToViewLineNumber > lineCount) {
        selectToViewLineNumber = lineCount;
        selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);
      }
      return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), selectToViewLineNumber, selectToViewColumn, 0));
    } else {
      const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();
      return CursorState.fromModelState(cursor.modelState.move(cursor.modelState.hasSelection(), endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));
    }
  }
  static word(viewModel, cursor, inSelectionMode, _position) {
    const position = viewModel.model.validatePosition(_position);
    return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));
  }
  static cancelSelection(viewModel, cursor) {
    if (!cursor.modelState.hasSelection()) {
      return new CursorState(cursor.modelState, cursor.viewState);
    }
    const lineNumber = cursor.viewState.position.lineNumber;
    const column = cursor.viewState.position.column;
    return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0, new Position(lineNumber, column), 0));
  }
  static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {
    const position = viewModel.model.validatePosition(_position);
    const viewPosition = _viewPosition ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position) : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position);
    return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));
  }
  static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {
    switch (direction) {
      case 0: {
        if (unit === 4) {
          return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);
        } else {
          return this._moveLeft(viewModel, cursors, inSelectionMode, value);
        }
      }
      case 1: {
        if (unit === 4) {
          return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);
        } else {
          return this._moveRight(viewModel, cursors, inSelectionMode, value);
        }
      }
      case 2: {
        if (unit === 2) {
          return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);
        } else {
          return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);
        }
      }
      case 3: {
        if (unit === 2) {
          return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);
        } else {
          return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);
        }
      }
      case 4: {
        return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);
      }
      case 5: {
        return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);
      }
      case 6: {
        return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);
      }
      case 7: {
        return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);
      }
      case 8: {
        return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);
      }
      default:
        return null;
    }
  }
  static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {
    const visibleViewRange = viewModel.getCompletelyVisibleViewRange();
    const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);
    switch (direction) {
      case 9: {
        const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);
        const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);
        return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];
      }
      case 11: {
        const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);
        const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);
        return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];
      }
      case 10: {
        const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);
        const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);
        return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];
      }
      case 12: {
        let result = [];
        for (let i = 0, len = cursors.length; i < len; i++) {
          const cursor = cursors[i];
          result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);
        }
        return result;
      }
      default:
        return null;
    }
  }
  static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {
    let viewLineNumber = cursor.viewState.position.lineNumber;
    if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {
      return new CursorState(cursor.modelState, cursor.viewState);
    } else {
      if (viewLineNumber > visibleViewRange.endLineNumber - 1) {
        viewLineNumber = visibleViewRange.endLineNumber - 1;
      }
      if (viewLineNumber < visibleViewRange.startLineNumber) {
        viewLineNumber = visibleViewRange.startLineNumber;
      }
      const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);
      return this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);
    }
  }
  static _firstLineNumberInRange(model2, range2, count) {
    let startLineNumber = range2.startLineNumber;
    if (range2.startColumn !== model2.getLineMinColumn(startLineNumber)) {
      startLineNumber++;
    }
    return Math.min(range2.endLineNumber, startLineNumber + count - 1);
  }
  static _lastLineNumberInRange(model2, range2, count) {
    let startLineNumber = range2.startLineNumber;
    if (range2.startColumn !== model2.getLineMinColumn(startLineNumber)) {
      startLineNumber++;
    }
    return Math.max(startLineNumber, range2.endLineNumber - count + 1);
  }
  static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {
    const hasMultipleCursors = cursors.length > 1;
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      const skipWrappingPointStop = hasMultipleCursors || !cursor.viewState.hasSelection();
      let newViewState = MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns);
      if (skipWrappingPointStop && noOfColumns === 1 && newViewState.position.lineNumber !== cursor.viewState.position.lineNumber) {
        const newViewModelPosition = viewModel.coordinatesConverter.convertViewPositionToModelPosition(newViewState.position);
        if (newViewModelPosition.lineNumber === cursor.modelState.position.lineNumber) {
          newViewState = MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, newViewState, inSelectionMode, 1);
        }
      }
      result[i] = CursorState.fromViewState(newViewState);
    }
    return result;
  }
  static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      const viewLineNumber = cursor.viewState.position.lineNumber;
      const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);
      result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));
    }
    return result;
  }
  static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {
    const hasMultipleCursors = cursors.length > 1;
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      const skipWrappingPointStop = hasMultipleCursors || !cursor.viewState.hasSelection();
      let newViewState = MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns);
      if (skipWrappingPointStop && noOfColumns === 1 && newViewState.position.lineNumber !== cursor.viewState.position.lineNumber) {
        const newViewModelPosition = viewModel.coordinatesConverter.convertViewPositionToModelPosition(newViewState.position);
        if (newViewModelPosition.lineNumber === cursor.modelState.position.lineNumber) {
          newViewState = MoveOperations.moveRight(viewModel.cursorConfig, viewModel, newViewState, inSelectionMode, 1);
        }
      }
      result[i] = CursorState.fromViewState(newViewState);
    }
    return result;
  }
  static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      const viewLineNumber = cursor.viewState.position.lineNumber;
      const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);
      result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));
    }
    return result;
  }
  static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));
    }
    return result;
  }
  static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));
    }
    return result;
  }
  static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));
    }
    return result;
  }
  static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));
    }
    return result;
  }
  static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {
    return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));
  }
  static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {
    return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));
  }
  static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      const viewLineNumber = cursor.viewState.position.lineNumber;
      const viewColumn = viewModel.getLineMinColumn(viewLineNumber);
      result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);
    }
    return result;
  }
  static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      const viewLineNumber = cursor.viewState.position.lineNumber;
      const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);
      result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);
    }
    return result;
  }
  static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      const viewLineNumber = cursor.viewState.position.lineNumber;
      const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);
      result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);
    }
    return result;
  }
  static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      const viewLineNumber = cursor.viewState.position.lineNumber;
      const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);
      result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);
    }
    return result;
  }
  static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {
    let result = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      const cursor = cursors[i];
      const viewLineNumber = cursor.viewState.position.lineNumber;
      const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);
      result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);
    }
    return result;
  }
};
var CursorMove;
(function(CursorMove2) {
  const isCursorMoveArgs = function(arg) {
    if (!isObject(arg)) {
      return false;
    }
    let cursorMoveArg = arg;
    if (!isString(cursorMoveArg.to)) {
      return false;
    }
    if (!isUndefined(cursorMoveArg.select) && !isBoolean(cursorMoveArg.select)) {
      return false;
    }
    if (!isUndefined(cursorMoveArg.by) && !isString(cursorMoveArg.by)) {
      return false;
    }
    if (!isUndefined(cursorMoveArg.value) && !isNumber(cursorMoveArg.value)) {
      return false;
    }
    return true;
  };
  CursorMove2.description = {
    description: "Move cursor to a logical position in the view",
    args: [
      {
        name: "Cursor move argument object",
        description: `Property-value pairs that can be passed through this argument:
					* 'to': A mandatory logical position value providing where to move the cursor.
						\`\`\`
						'left', 'right', 'up', 'down'
						'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'
						'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'
						'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'
						\`\`\`
					* 'by': Unit to move. Default is computed based on 'to' value.
						\`\`\`
						'line', 'wrappedLine', 'character', 'halfLine'
						\`\`\`
					* 'value': Number of units to move. Default is '1'.
					* 'select': If 'true' makes the selection. Default is 'false'.
				`,
        constraint: isCursorMoveArgs,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["left", "right", "up", "down", "wrappedLineStart", "wrappedLineEnd", "wrappedLineColumnCenter", "wrappedLineFirstNonWhitespaceCharacter", "wrappedLineLastNonWhitespaceCharacter", "viewPortTop", "viewPortCenter", "viewPortBottom", "viewPortIfOutside"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "character", "halfLine"]
            },
            value: {
              type: "number",
              default: 1
            },
            select: {
              type: "boolean",
              default: false
            }
          }
        }
      }
    ]
  };
  CursorMove2.RawDirection = {
    Left: "left",
    Right: "right",
    Up: "up",
    Down: "down",
    WrappedLineStart: "wrappedLineStart",
    WrappedLineFirstNonWhitespaceCharacter: "wrappedLineFirstNonWhitespaceCharacter",
    WrappedLineColumnCenter: "wrappedLineColumnCenter",
    WrappedLineEnd: "wrappedLineEnd",
    WrappedLineLastNonWhitespaceCharacter: "wrappedLineLastNonWhitespaceCharacter",
    ViewPortTop: "viewPortTop",
    ViewPortCenter: "viewPortCenter",
    ViewPortBottom: "viewPortBottom",
    ViewPortIfOutside: "viewPortIfOutside"
  };
  CursorMove2.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Character: "character",
    HalfLine: "halfLine"
  };
  function parse3(args) {
    if (!args.to) {
      return null;
    }
    let direction;
    switch (args.to) {
      case CursorMove2.RawDirection.Left:
        direction = 0;
        break;
      case CursorMove2.RawDirection.Right:
        direction = 1;
        break;
      case CursorMove2.RawDirection.Up:
        direction = 2;
        break;
      case CursorMove2.RawDirection.Down:
        direction = 3;
        break;
      case CursorMove2.RawDirection.WrappedLineStart:
        direction = 4;
        break;
      case CursorMove2.RawDirection.WrappedLineFirstNonWhitespaceCharacter:
        direction = 5;
        break;
      case CursorMove2.RawDirection.WrappedLineColumnCenter:
        direction = 6;
        break;
      case CursorMove2.RawDirection.WrappedLineEnd:
        direction = 7;
        break;
      case CursorMove2.RawDirection.WrappedLineLastNonWhitespaceCharacter:
        direction = 8;
        break;
      case CursorMove2.RawDirection.ViewPortTop:
        direction = 9;
        break;
      case CursorMove2.RawDirection.ViewPortBottom:
        direction = 11;
        break;
      case CursorMove2.RawDirection.ViewPortCenter:
        direction = 10;
        break;
      case CursorMove2.RawDirection.ViewPortIfOutside:
        direction = 12;
        break;
      default:
        return null;
    }
    let unit = 0;
    switch (args.by) {
      case CursorMove2.RawUnit.Line:
        unit = 1;
        break;
      case CursorMove2.RawUnit.WrappedLine:
        unit = 2;
        break;
      case CursorMove2.RawUnit.Character:
        unit = 3;
        break;
      case CursorMove2.RawUnit.HalfLine:
        unit = 4;
        break;
    }
    return {
      direction,
      unit,
      select: !!args.select,
      value: args.value || 1
    };
  }
  CursorMove2.parse = parse3;
})(CursorMove || (CursorMove = {}));

// ../../node_modules/monaco-editor/esm/vs/editor/common/commands/shiftCommand.js
var repeatCache = Object.create(null);
function cachedStringRepeat(str, count) {
  if (!repeatCache[str]) {
    repeatCache[str] = ["", str];
  }
  const cache = repeatCache[str];
  for (let i = cache.length; i <= count; i++) {
    cache[i] = cache[i - 1] + str;
  }
  return cache[count];
}
var ShiftCommand = class {
  constructor(range2, opts) {
    this._opts = opts;
    this._selection = range2;
    this._selectionId = null;
    this._useLastEditRangeForCursorEndPosition = false;
    this._selectionStartColumnStaysPut = false;
  }
  static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {
    const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);
    if (insertSpaces) {
      const indent = cachedStringRepeat(" ", indentSize);
      const desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);
      const indentCount = desiredTabStop / indentSize;
      return cachedStringRepeat(indent, indentCount);
    } else {
      const indent = "	";
      const desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);
      const indentCount = desiredTabStop / tabSize;
      return cachedStringRepeat(indent, indentCount);
    }
  }
  static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {
    const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);
    if (insertSpaces) {
      const indent = cachedStringRepeat(" ", indentSize);
      const desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);
      const indentCount = desiredTabStop / indentSize;
      return cachedStringRepeat(indent, indentCount);
    } else {
      const indent = "	";
      const desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);
      const indentCount = desiredTabStop / tabSize;
      return cachedStringRepeat(indent, indentCount);
    }
  }
  _addEditOperation(builder, range2, text) {
    if (this._useLastEditRangeForCursorEndPosition) {
      builder.addTrackedEditOperation(range2, text);
    } else {
      builder.addEditOperation(range2, text);
    }
  }
  getEditOperations(model2, builder) {
    const startLine = this._selection.startLineNumber;
    let endLine = this._selection.endLineNumber;
    if (this._selection.endColumn === 1 && startLine !== endLine) {
      endLine = endLine - 1;
    }
    const {tabSize, indentSize, insertSpaces} = this._opts;
    const shouldIndentEmptyLines = startLine === endLine;
    if (this._opts.useTabStops) {
      if (this._selection.isEmpty()) {
        if (/^\s*$/.test(model2.getLineContent(startLine))) {
          this._useLastEditRangeForCursorEndPosition = true;
        }
      }
      let previousLineExtraSpaces = 0, extraSpaces = 0;
      for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {
        extraSpaces = 0;
        let lineText = model2.getLineContent(lineNumber);
        let indentationEndIndex = firstNonWhitespaceIndex(lineText);
        if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {
          continue;
        }
        if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {
          continue;
        }
        if (indentationEndIndex === -1) {
          indentationEndIndex = lineText.length;
        }
        if (lineNumber > 1) {
          let contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);
          if (contentStartVisibleColumn % indentSize !== 0) {
            if (model2.isCheapToTokenize(lineNumber - 1)) {
              let enterAction = LanguageConfigurationRegistry.getEnterAction(this._opts.autoIndent, model2, new Range(lineNumber - 1, model2.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model2.getLineMaxColumn(lineNumber - 1)));
              if (enterAction) {
                extraSpaces = previousLineExtraSpaces;
                if (enterAction.appendText) {
                  for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {
                    if (enterAction.appendText.charCodeAt(j) === 32) {
                      extraSpaces++;
                    } else {
                      break;
                    }
                  }
                }
                if (enterAction.removeText) {
                  extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);
                }
                for (let j = 0; j < extraSpaces; j++) {
                  if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32) {
                    break;
                  }
                  indentationEndIndex--;
                }
              }
            }
          }
        }
        if (this._opts.isUnshift && indentationEndIndex === 0) {
          continue;
        }
        let desiredIndent;
        if (this._opts.isUnshift) {
          desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);
        } else {
          desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);
        }
        this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);
        if (lineNumber === startLine && !this._selection.isEmpty()) {
          this._selectionStartColumnStaysPut = this._selection.startColumn <= indentationEndIndex + 1;
        }
      }
    } else {
      if (!this._opts.isUnshift && this._selection.isEmpty() && model2.getLineLength(startLine) === 0) {
        this._useLastEditRangeForCursorEndPosition = true;
      }
      const oneIndent = insertSpaces ? cachedStringRepeat(" ", indentSize) : "	";
      for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {
        const lineText = model2.getLineContent(lineNumber);
        let indentationEndIndex = firstNonWhitespaceIndex(lineText);
        if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {
          continue;
        }
        if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {
          continue;
        }
        if (indentationEndIndex === -1) {
          indentationEndIndex = lineText.length;
        }
        if (this._opts.isUnshift && indentationEndIndex === 0) {
          continue;
        }
        if (this._opts.isUnshift) {
          indentationEndIndex = Math.min(indentationEndIndex, indentSize);
          for (let i = 0; i < indentationEndIndex; i++) {
            const chr = lineText.charCodeAt(i);
            if (chr === 9) {
              indentationEndIndex = i + 1;
              break;
            }
          }
          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), "");
        } else {
          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);
          if (lineNumber === startLine && !this._selection.isEmpty()) {
            this._selectionStartColumnStaysPut = this._selection.startColumn === 1;
          }
        }
      }
    }
    this._selectionId = builder.trackSelection(this._selection);
  }
  computeCursorState(model2, helper) {
    if (this._useLastEditRangeForCursorEndPosition) {
      let lastOp = helper.getInverseEditOperations()[0];
      return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);
    }
    const result = helper.getTrackedSelection(this._selectionId);
    if (this._selectionStartColumnStaysPut) {
      let initialStartColumn = this._selection.startColumn;
      let resultStartColumn = result.startColumn;
      if (resultStartColumn <= initialStartColumn) {
        return result;
      }
      if (result.getDirection() === 0) {
        return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);
      }
      return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);
    }
    return result;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/commands/surroundSelectionCommand.js
var SurroundSelectionCommand = class {
  constructor(range2, charBeforeSelection, charAfterSelection) {
    this._range = range2;
    this._charBeforeSelection = charBeforeSelection;
    this._charAfterSelection = charAfterSelection;
  }
  getEditOperations(model2, builder) {
    builder.addTrackedEditOperation(new Range(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection);
    builder.addTrackedEditOperation(new Range(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);
  }
  computeCursorState(model2, helper) {
    let inverseEditOperations = helper.getInverseEditOperations();
    let firstOperationRange = inverseEditOperations[0].range;
    let secondOperationRange = inverseEditOperations[1].range;
    return new Selection(firstOperationRange.endLineNumber, firstOperationRange.endColumn, secondOperationRange.endLineNumber, secondOperationRange.endColumn - this._charAfterSelection.length);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorTypeOperations.js
var TypeOperations = class {
  static indent(config, model2, selections) {
    if (model2 === null || selections === null) {
      return [];
    }
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      commands[i] = new ShiftCommand(selections[i], {
        isUnshift: false,
        tabSize: config.tabSize,
        indentSize: config.indentSize,
        insertSpaces: config.insertSpaces,
        useTabStops: config.useTabStops,
        autoIndent: config.autoIndent
      });
    }
    return commands;
  }
  static outdent(config, model2, selections) {
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      commands[i] = new ShiftCommand(selections[i], {
        isUnshift: true,
        tabSize: config.tabSize,
        indentSize: config.indentSize,
        insertSpaces: config.insertSpaces,
        useTabStops: config.useTabStops,
        autoIndent: config.autoIndent
      });
    }
    return commands;
  }
  static shiftIndent(config, indentation, count) {
    count = count || 1;
    return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);
  }
  static unshiftIndent(config, indentation, count) {
    count = count || 1;
    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);
  }
  static _distributedPaste(config, model2, selections, text) {
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      commands[i] = new ReplaceCommand(selections[i], text[i]);
    }
    return new EditOperationResult(0, commands, {
      shouldPushStackElementBefore: true,
      shouldPushStackElementAfter: true
    });
  }
  static _simplePaste(config, model2, selections, text, pasteOnNewLine) {
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      let position = selection.getPosition();
      if (pasteOnNewLine && !selection.isEmpty()) {
        pasteOnNewLine = false;
      }
      if (pasteOnNewLine && text.indexOf("\n") !== text.length - 1) {
        pasteOnNewLine = false;
      }
      if (pasteOnNewLine) {
        let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);
        commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);
      } else {
        commands[i] = new ReplaceCommand(selection, text);
      }
    }
    return new EditOperationResult(0, commands, {
      shouldPushStackElementBefore: true,
      shouldPushStackElementAfter: true
    });
  }
  static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {
    if (pasteOnNewLine) {
      return null;
    }
    if (selections.length === 1) {
      return null;
    }
    if (multicursorText && multicursorText.length === selections.length) {
      return multicursorText;
    }
    if (config.multiCursorPaste === "spread") {
      if (text.charCodeAt(text.length - 1) === 10) {
        text = text.substr(0, text.length - 1);
      }
      if (text.charCodeAt(text.length - 1) === 13) {
        text = text.substr(0, text.length - 1);
      }
      let lines = text.split(/\r\n|\r|\n/);
      if (lines.length === selections.length) {
        return lines;
      }
    }
    return null;
  }
  static paste(config, model2, selections, text, pasteOnNewLine, multicursorText) {
    const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);
    if (distributedPaste) {
      selections = selections.sort(Range.compareRangesUsingStarts);
      return this._distributedPaste(config, model2, selections, distributedPaste);
    } else {
      return this._simplePaste(config, model2, selections, text, pasteOnNewLine);
    }
  }
  static _goodIndentForLine(config, model2, lineNumber) {
    let action = null;
    let indentation = "";
    const expectedIndentAction = LanguageConfigurationRegistry.getInheritIndentForLine(config.autoIndent, model2, lineNumber, false);
    if (expectedIndentAction) {
      action = expectedIndentAction.action;
      indentation = expectedIndentAction.indentation;
    } else if (lineNumber > 1) {
      let lastLineNumber;
      for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {
        const lineText = model2.getLineContent(lastLineNumber);
        const nonWhitespaceIdx = lastNonWhitespaceIndex(lineText);
        if (nonWhitespaceIdx >= 0) {
          break;
        }
      }
      if (lastLineNumber < 1) {
        return null;
      }
      const maxColumn = model2.getLineMaxColumn(lastLineNumber);
      const expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model2, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));
      if (expectedEnterAction) {
        indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;
      }
    }
    if (action) {
      if (action === IndentAction2.Indent) {
        indentation = TypeOperations.shiftIndent(config, indentation);
      }
      if (action === IndentAction2.Outdent) {
        indentation = TypeOperations.unshiftIndent(config, indentation);
      }
      indentation = config.normalizeIndentation(indentation);
    }
    if (!indentation) {
      return null;
    }
    return indentation;
  }
  static _replaceJumpToNextIndent(config, model2, selection, insertsAutoWhitespace) {
    let typeText = "";
    let position = selection.getStartPosition();
    if (config.insertSpaces) {
      let visibleColumnFromColumn = CursorColumns.visibleColumnFromColumn2(config, model2, position);
      let indentSize = config.indentSize;
      let spacesCnt = indentSize - visibleColumnFromColumn % indentSize;
      for (let i = 0; i < spacesCnt; i++) {
        typeText += " ";
      }
    } else {
      typeText = "	";
    }
    return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);
  }
  static tab(config, model2, selections) {
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      if (selection.isEmpty()) {
        let lineText = model2.getLineContent(selection.startLineNumber);
        if (/^\s*$/.test(lineText) && model2.isCheapToTokenize(selection.startLineNumber)) {
          let goodIndent = this._goodIndentForLine(config, model2, selection.startLineNumber);
          goodIndent = goodIndent || "	";
          let possibleTypeText = config.normalizeIndentation(goodIndent);
          if (!startsWith(lineText, possibleTypeText)) {
            commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);
            continue;
          }
        }
        commands[i] = this._replaceJumpToNextIndent(config, model2, selection, true);
      } else {
        if (selection.startLineNumber === selection.endLineNumber) {
          let lineMaxColumn = model2.getLineMaxColumn(selection.startLineNumber);
          if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {
            commands[i] = this._replaceJumpToNextIndent(config, model2, selection, false);
            continue;
          }
        }
        commands[i] = new ShiftCommand(selection, {
          isUnshift: false,
          tabSize: config.tabSize,
          indentSize: config.indentSize,
          insertSpaces: config.insertSpaces,
          useTabStops: config.useTabStops,
          autoIndent: config.autoIndent
        });
      }
    }
    return commands;
  }
  static replacePreviousChar(prevEditOperationType, config, model2, selections, txt, replaceCharCnt) {
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      if (!selection.isEmpty()) {
        commands[i] = null;
        continue;
      }
      const pos = selection.getPosition();
      const startColumn = Math.max(1, pos.column - replaceCharCnt);
      const range2 = new Range(pos.lineNumber, startColumn, pos.lineNumber, pos.column);
      const oldText = model2.getValueInRange(range2);
      if (oldText === txt) {
        commands[i] = null;
        continue;
      }
      commands[i] = new ReplaceCommand(range2, txt);
    }
    return new EditOperationResult(1, commands, {
      shouldPushStackElementBefore: prevEditOperationType !== 1,
      shouldPushStackElementAfter: false
    });
  }
  static _typeCommand(range2, text, keepPosition) {
    if (keepPosition) {
      return new ReplaceCommandWithoutChangingPosition(range2, text, true);
    } else {
      return new ReplaceCommand(range2, text, true);
    }
  }
  static _enter(config, model2, keepPosition, range2) {
    if (config.autoIndent === 0) {
      return TypeOperations._typeCommand(range2, "\n", keepPosition);
    }
    if (!model2.isCheapToTokenize(range2.getStartPosition().lineNumber) || config.autoIndent === 1) {
      let lineText2 = model2.getLineContent(range2.startLineNumber);
      let indentation2 = getLeadingWhitespace(lineText2).substring(0, range2.startColumn - 1);
      return TypeOperations._typeCommand(range2, "\n" + config.normalizeIndentation(indentation2), keepPosition);
    }
    const r = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model2, range2);
    if (r) {
      if (r.indentAction === IndentAction2.None) {
        return TypeOperations._typeCommand(range2, "\n" + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);
      } else if (r.indentAction === IndentAction2.Indent) {
        return TypeOperations._typeCommand(range2, "\n" + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);
      } else if (r.indentAction === IndentAction2.IndentOutdent) {
        const normalIndent = config.normalizeIndentation(r.indentation);
        const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);
        const typeText = "\n" + increasedIndent + "\n" + normalIndent;
        if (keepPosition) {
          return new ReplaceCommandWithoutChangingPosition(range2, typeText, true);
        } else {
          return new ReplaceCommandWithOffsetCursorState(range2, typeText, -1, increasedIndent.length - normalIndent.length, true);
        }
      } else if (r.indentAction === IndentAction2.Outdent) {
        const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);
        return TypeOperations._typeCommand(range2, "\n" + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);
      }
    }
    const lineText = model2.getLineContent(range2.startLineNumber);
    const indentation = getLeadingWhitespace(lineText).substring(0, range2.startColumn - 1);
    if (config.autoIndent >= 4) {
      const ir = LanguageConfigurationRegistry.getIndentForEnter(config.autoIndent, model2, range2, {
        unshiftIndent: (indent) => {
          return TypeOperations.unshiftIndent(config, indent);
        },
        shiftIndent: (indent) => {
          return TypeOperations.shiftIndent(config, indent);
        },
        normalizeIndentation: (indent) => {
          return config.normalizeIndentation(indent);
        }
      });
      if (ir) {
        let oldEndViewColumn = CursorColumns.visibleColumnFromColumn2(config, model2, range2.getEndPosition());
        const oldEndColumn = range2.endColumn;
        let beforeText = "\n";
        if (indentation !== config.normalizeIndentation(ir.beforeEnter)) {
          beforeText = config.normalizeIndentation(ir.beforeEnter) + lineText.substring(indentation.length, range2.startColumn - 1) + "\n";
          range2 = new Range(range2.startLineNumber, 1, range2.endLineNumber, range2.endColumn);
        }
        const newLineContent = model2.getLineContent(range2.endLineNumber);
        const firstNonWhitespace = firstNonWhitespaceIndex(newLineContent);
        if (firstNonWhitespace >= 0) {
          range2 = range2.setEndPosition(range2.endLineNumber, Math.max(range2.endColumn, firstNonWhitespace + 1));
        } else {
          range2 = range2.setEndPosition(range2.endLineNumber, model2.getLineMaxColumn(range2.endLineNumber));
        }
        if (keepPosition) {
          return new ReplaceCommandWithoutChangingPosition(range2, beforeText + config.normalizeIndentation(ir.afterEnter), true);
        } else {
          let offset = 0;
          if (oldEndColumn <= firstNonWhitespace + 1) {
            if (!config.insertSpaces) {
              oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);
            }
            offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);
          }
          return new ReplaceCommandWithOffsetCursorState(range2, beforeText + config.normalizeIndentation(ir.afterEnter), 0, offset, true);
        }
      }
    }
    return TypeOperations._typeCommand(range2, "\n" + config.normalizeIndentation(indentation), keepPosition);
  }
  static _isAutoIndentType(config, model2, selections) {
    if (config.autoIndent < 4) {
      return false;
    }
    for (let i = 0, len = selections.length; i < len; i++) {
      if (!model2.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {
        return false;
      }
    }
    return true;
  }
  static _runAutoIndentType(config, model2, range2, ch) {
    const currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model2, range2.startLineNumber, range2.startColumn);
    const actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(config.autoIndent, model2, range2, ch, {
      shiftIndent: (indentation) => {
        return TypeOperations.shiftIndent(config, indentation);
      },
      unshiftIndent: (indentation) => {
        return TypeOperations.unshiftIndent(config, indentation);
      }
    });
    if (actualIndentation === null) {
      return null;
    }
    if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {
      const firstNonWhitespace = model2.getLineFirstNonWhitespaceColumn(range2.startLineNumber);
      if (firstNonWhitespace === 0) {
        return TypeOperations._typeCommand(new Range(range2.startLineNumber, 0, range2.endLineNumber, range2.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);
      } else {
        return TypeOperations._typeCommand(new Range(range2.startLineNumber, 0, range2.endLineNumber, range2.endColumn), config.normalizeIndentation(actualIndentation) + model2.getLineContent(range2.startLineNumber).substring(firstNonWhitespace - 1, range2.startColumn - 1) + ch, false);
      }
    }
    return null;
  }
  static _isAutoClosingOvertype(config, model2, selections, autoClosedCharacters, ch) {
    if (config.autoClosingOvertype === "never") {
      return false;
    }
    if (!config.autoClosingPairsClose2.has(ch)) {
      return false;
    }
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      if (!selection.isEmpty()) {
        return false;
      }
      const position = selection.getPosition();
      const lineText = model2.getLineContent(position.lineNumber);
      const afterCharacter = lineText.charAt(position.column - 1);
      if (afterCharacter !== ch) {
        return false;
      }
      const chIsQuote = isQuote(ch);
      const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0;
      if (beforeCharacter === 92 && chIsQuote) {
        return false;
      }
      if (config.autoClosingOvertype === "auto") {
        let found = false;
        for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {
          const autoClosedCharacter = autoClosedCharacters[j];
          if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {
            found = true;
            break;
          }
        }
        if (!found) {
          return false;
        }
      }
    }
    return true;
  }
  static _runAutoClosingOvertype(prevEditOperationType, config, model2, selections, ch) {
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      const position = selection.getPosition();
      const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);
      commands[i] = new ReplaceCommand(typeSelection, ch);
    }
    return new EditOperationResult(1, commands, {
      shouldPushStackElementBefore: prevEditOperationType !== 1,
      shouldPushStackElementAfter: false
    });
  }
  static _autoClosingPairIsSymmetric(autoClosingPair) {
    const {open, close} = autoClosingPair;
    return open.indexOf(close) >= 0 || close.indexOf(open) >= 0;
  }
  static _isBeforeClosingBrace(config, autoClosingPair, characterAfter) {
    const otherAutoClosingPairs = config.autoClosingPairsClose2.get(characterAfter);
    if (!otherAutoClosingPairs) {
      return false;
    }
    const thisBraceIsSymmetric = TypeOperations._autoClosingPairIsSymmetric(autoClosingPair);
    for (const otherAutoClosingPair of otherAutoClosingPairs) {
      const otherBraceIsSymmetric = TypeOperations._autoClosingPairIsSymmetric(otherAutoClosingPair);
      if (!thisBraceIsSymmetric && otherBraceIsSymmetric) {
        continue;
      }
      return true;
    }
    return false;
  }
  static _findAutoClosingPairOpen(config, model2, positions, ch) {
    const autoClosingPairCandidates = config.autoClosingPairsOpen2.get(ch);
    if (!autoClosingPairCandidates) {
      return null;
    }
    let autoClosingPair = null;
    for (const autoClosingPairCandidate of autoClosingPairCandidates) {
      if (autoClosingPair === null || autoClosingPairCandidate.open.length > autoClosingPair.open.length) {
        let candidateIsMatch = true;
        for (const position of positions) {
          const relevantText = model2.getValueInRange(new Range(position.lineNumber, position.column - autoClosingPairCandidate.open.length + 1, position.lineNumber, position.column));
          if (relevantText + ch !== autoClosingPairCandidate.open) {
            candidateIsMatch = false;
            break;
          }
        }
        if (candidateIsMatch) {
          autoClosingPair = autoClosingPairCandidate;
        }
      }
    }
    return autoClosingPair;
  }
  static _isAutoClosingOpenCharType(config, model2, selections, ch, insertOpenCharacter) {
    const chIsQuote = isQuote(ch);
    const autoCloseConfig = chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets;
    if (autoCloseConfig === "never") {
      return null;
    }
    const autoClosingPair = this._findAutoClosingPairOpen(config, model2, selections.map((s) => s.getPosition()), ch);
    if (!autoClosingPair) {
      return null;
    }
    const shouldAutoCloseBefore = chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      if (!selection.isEmpty()) {
        return null;
      }
      const position = selection.getPosition();
      const lineText = model2.getLineContent(position.lineNumber);
      if (lineText.length > position.column - 1) {
        const characterAfter = lineText.charAt(position.column - 1);
        const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, autoClosingPair, characterAfter);
        if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {
          return null;
        }
      }
      if (!model2.isCheapToTokenize(position.lineNumber)) {
        return null;
      }
      if (autoClosingPair.open.length === 1 && chIsQuote && autoCloseConfig !== "always") {
        const wordSeparators2 = getMapForWordSeparators(config.wordSeparators);
        if (insertOpenCharacter && position.column > 1 && wordSeparators2.get(lineText.charCodeAt(position.column - 2)) === 0) {
          return null;
        }
        if (!insertOpenCharacter && position.column > 2 && wordSeparators2.get(lineText.charCodeAt(position.column - 3)) === 0) {
          return null;
        }
      }
      model2.forceTokenization(position.lineNumber);
      const lineTokens = model2.getLineTokens(position.lineNumber);
      let shouldAutoClosePair = false;
      try {
        shouldAutoClosePair = LanguageConfigurationRegistry.shouldAutoClosePair(autoClosingPair, lineTokens, insertOpenCharacter ? position.column : position.column - 1);
      } catch (e) {
        onUnexpectedError(e);
      }
      if (!shouldAutoClosePair) {
        return null;
      }
    }
    return autoClosingPair;
  }
  static _runAutoClosingOpenCharType(prevEditOperationType, config, model2, selections, ch, insertOpenCharacter, autoClosingPair) {
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      commands[i] = new TypeWithAutoClosingCommand(selection, ch, insertOpenCharacter, autoClosingPair.close);
    }
    return new EditOperationResult(1, commands, {
      shouldPushStackElementBefore: true,
      shouldPushStackElementAfter: false
    });
  }
  static _shouldSurroundChar(config, ch) {
    if (isQuote(ch)) {
      return config.autoSurround === "quotes" || config.autoSurround === "languageDefined";
    } else {
      return config.autoSurround === "brackets" || config.autoSurround === "languageDefined";
    }
  }
  static _isSurroundSelectionType(config, model2, selections, ch) {
    if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {
      return false;
    }
    const isTypingAQuoteCharacter = isQuote(ch);
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      if (selection.isEmpty()) {
        return false;
      }
      let selectionContainsOnlyWhitespace = true;
      for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {
        const lineText = model2.getLineContent(lineNumber);
        const startIndex = lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0;
        const endIndex = lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length;
        const selectedText = lineText.substring(startIndex, endIndex);
        if (/[^ \t]/.test(selectedText)) {
          selectionContainsOnlyWhitespace = false;
          break;
        }
      }
      if (selectionContainsOnlyWhitespace) {
        return false;
      }
      if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {
        const selectionText = model2.getValueInRange(selection);
        if (isQuote(selectionText)) {
          return false;
        }
      }
    }
    return true;
  }
  static _runSurroundSelectionType(prevEditOperationType, config, model2, selections, ch) {
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      const closeCharacter = config.surroundingPairs[ch];
      commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);
    }
    return new EditOperationResult(0, commands, {
      shouldPushStackElementBefore: true,
      shouldPushStackElementAfter: true
    });
  }
  static _isTypeInterceptorElectricChar(config, model2, selections) {
    if (selections.length === 1 && model2.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {
      return true;
    }
    return false;
  }
  static _typeInterceptorElectricChar(prevEditOperationType, config, model2, selection, ch) {
    if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {
      return null;
    }
    let position = selection.getPosition();
    model2.forceTokenization(position.lineNumber);
    let lineTokens = model2.getLineTokens(position.lineNumber);
    let electricAction;
    try {
      electricAction = LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);
    } catch (e) {
      onUnexpectedError(e);
      return null;
    }
    if (!electricAction) {
      return null;
    }
    if (electricAction.matchOpenBracket) {
      let endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;
      let match2 = model2.findMatchingBracketUp(electricAction.matchOpenBracket, {
        lineNumber: position.lineNumber,
        column: endColumn
      });
      if (match2) {
        if (match2.startLineNumber === position.lineNumber) {
          return null;
        }
        let matchLine = model2.getLineContent(match2.startLineNumber);
        let matchLineIndentation = getLeadingWhitespace(matchLine);
        let newIndentation = config.normalizeIndentation(matchLineIndentation);
        let lineText = model2.getLineContent(position.lineNumber);
        let lineFirstNonBlankColumn = model2.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;
        let prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);
        let typeText = newIndentation + prefix + ch;
        let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);
        const command = new ReplaceCommand(typeSelection, typeText);
        return new EditOperationResult(1, [command], {
          shouldPushStackElementBefore: false,
          shouldPushStackElementAfter: true
        });
      }
    }
    return null;
  }
  static compositionEndWithInterceptors(prevEditOperationType, config, model2, selectionsWhenCompositionStarted, selections, autoClosedCharacters) {
    if (!selectionsWhenCompositionStarted || Selection.selectionsArrEqual(selectionsWhenCompositionStarted, selections)) {
      return null;
    }
    let ch = null;
    for (const selection of selections) {
      if (!selection.isEmpty()) {
        return null;
      }
      const position = selection.getPosition();
      const currentChar = model2.getValueInRange(new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column));
      if (ch === null) {
        ch = currentChar;
      } else if (ch !== currentChar) {
        return null;
      }
    }
    if (!ch) {
      return null;
    }
    if (this._isAutoClosingOvertype(config, model2, selections, autoClosedCharacters, ch)) {
      const commands = selections.map((s) => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), "", false));
      return new EditOperationResult(1, commands, {
        shouldPushStackElementBefore: true,
        shouldPushStackElementAfter: false
      });
    }
    const autoClosingPairOpenCharType = this._isAutoClosingOpenCharType(config, model2, selections, ch, false);
    if (autoClosingPairOpenCharType) {
      return this._runAutoClosingOpenCharType(prevEditOperationType, config, model2, selections, ch, false, autoClosingPairOpenCharType);
    }
    return null;
  }
  static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model2, selections, autoClosedCharacters, ch) {
    if (!isDoingComposition && ch === "\n") {
      let commands2 = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        commands2[i] = TypeOperations._enter(config, model2, false, selections[i]);
      }
      return new EditOperationResult(1, commands2, {
        shouldPushStackElementBefore: true,
        shouldPushStackElementAfter: false
      });
    }
    if (!isDoingComposition && this._isAutoIndentType(config, model2, selections)) {
      let commands2 = [];
      let autoIndentFails = false;
      for (let i = 0, len = selections.length; i < len; i++) {
        commands2[i] = this._runAutoIndentType(config, model2, selections[i], ch);
        if (!commands2[i]) {
          autoIndentFails = true;
          break;
        }
      }
      if (!autoIndentFails) {
        return new EditOperationResult(1, commands2, {
          shouldPushStackElementBefore: true,
          shouldPushStackElementAfter: false
        });
      }
    }
    if (!isDoingComposition && this._isAutoClosingOvertype(config, model2, selections, autoClosedCharacters, ch)) {
      return this._runAutoClosingOvertype(prevEditOperationType, config, model2, selections, ch);
    }
    if (!isDoingComposition) {
      const autoClosingPairOpenCharType = this._isAutoClosingOpenCharType(config, model2, selections, ch, true);
      if (autoClosingPairOpenCharType) {
        return this._runAutoClosingOpenCharType(prevEditOperationType, config, model2, selections, ch, true, autoClosingPairOpenCharType);
      }
    }
    if (this._isSurroundSelectionType(config, model2, selections, ch)) {
      return this._runSurroundSelectionType(prevEditOperationType, config, model2, selections, ch);
    }
    if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model2, selections)) {
      const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model2, selections[0], ch);
      if (r) {
        return r;
      }
    }
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      commands[i] = new ReplaceCommand(selections[i], ch);
    }
    let shouldPushStackElementBefore = prevEditOperationType !== 1;
    if (ch === " ") {
      shouldPushStackElementBefore = true;
    }
    return new EditOperationResult(1, commands, {
      shouldPushStackElementBefore,
      shouldPushStackElementAfter: false
    });
  }
  static typeWithoutInterceptors(prevEditOperationType, config, model2, selections, str) {
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      commands[i] = new ReplaceCommand(selections[i], str);
    }
    return new EditOperationResult(1, commands, {
      shouldPushStackElementBefore: prevEditOperationType !== 1,
      shouldPushStackElementAfter: false
    });
  }
  static lineInsertBefore(config, model2, selections) {
    if (model2 === null || selections === null) {
      return [];
    }
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      let lineNumber = selections[i].positionLineNumber;
      if (lineNumber === 1) {
        commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), "\n");
      } else {
        lineNumber--;
        let column = model2.getLineMaxColumn(lineNumber);
        commands[i] = this._enter(config, model2, false, new Range(lineNumber, column, lineNumber, column));
      }
    }
    return commands;
  }
  static lineInsertAfter(config, model2, selections) {
    if (model2 === null || selections === null) {
      return [];
    }
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      const lineNumber = selections[i].positionLineNumber;
      let column = model2.getLineMaxColumn(lineNumber);
      commands[i] = this._enter(config, model2, false, new Range(lineNumber, column, lineNumber, column));
    }
    return commands;
  }
  static lineBreakInsert(config, model2, selections) {
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      commands[i] = this._enter(config, model2, true, selections[i]);
    }
    return commands;
  }
};
var TypeWithAutoClosingCommand = class extends ReplaceCommandWithOffsetCursorState {
  constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {
    super(selection, (insertOpenCharacter ? openCharacter : "") + closeCharacter, 0, -closeCharacter.length);
    this._openCharacter = openCharacter;
    this._closeCharacter = closeCharacter;
    this.closeCharacterRange = null;
    this.enclosingRange = null;
  }
  computeCursorState(model2, helper) {
    let inverseEditOperations = helper.getInverseEditOperations();
    let range2 = inverseEditOperations[0].range;
    this.closeCharacterRange = new Range(range2.startLineNumber, range2.endColumn - this._closeCharacter.length, range2.endLineNumber, range2.endColumn);
    this.enclosingRange = new Range(range2.startLineNumber, range2.endColumn - this._openCharacter.length - this._closeCharacter.length, range2.endLineNumber, range2.endColumn);
    return super.computeCursorState(model2, helper);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js
var EditorContextKeys;
(function(EditorContextKeys2) {
  EditorContextKeys2.editorSimpleInput = new RawContextKey("editorSimpleInput", false);
  EditorContextKeys2.editorTextFocus = new RawContextKey("editorTextFocus", false);
  EditorContextKeys2.focus = new RawContextKey("editorFocus", false);
  EditorContextKeys2.textInputFocus = new RawContextKey("textInputFocus", false);
  EditorContextKeys2.readOnly = new RawContextKey("editorReadonly", false);
  EditorContextKeys2.columnSelection = new RawContextKey("editorColumnSelection", false);
  EditorContextKeys2.writable = EditorContextKeys2.readOnly.toNegated();
  EditorContextKeys2.hasNonEmptySelection = new RawContextKey("editorHasSelection", false);
  EditorContextKeys2.hasOnlyEmptySelection = EditorContextKeys2.hasNonEmptySelection.toNegated();
  EditorContextKeys2.hasMultipleSelections = new RawContextKey("editorHasMultipleSelections", false);
  EditorContextKeys2.hasSingleSelection = EditorContextKeys2.hasMultipleSelections.toNegated();
  EditorContextKeys2.tabMovesFocus = new RawContextKey("editorTabMovesFocus", false);
  EditorContextKeys2.tabDoesNotMoveFocus = EditorContextKeys2.tabMovesFocus.toNegated();
  EditorContextKeys2.isInWalkThroughSnippet = new RawContextKey("isInEmbeddedEditor", false);
  EditorContextKeys2.canUndo = new RawContextKey("canUndo", false);
  EditorContextKeys2.canRedo = new RawContextKey("canRedo", false);
  EditorContextKeys2.hoverVisible = new RawContextKey("editorHoverVisible", false);
  EditorContextKeys2.inCompositeEditor = new RawContextKey("inCompositeEditor", void 0);
  EditorContextKeys2.notInCompositeEditor = EditorContextKeys2.inCompositeEditor.toNegated();
  EditorContextKeys2.languageId = new RawContextKey("editorLangId", "");
  EditorContextKeys2.hasCompletionItemProvider = new RawContextKey("editorHasCompletionItemProvider", false);
  EditorContextKeys2.hasCodeActionsProvider = new RawContextKey("editorHasCodeActionsProvider", false);
  EditorContextKeys2.hasCodeLensProvider = new RawContextKey("editorHasCodeLensProvider", false);
  EditorContextKeys2.hasDefinitionProvider = new RawContextKey("editorHasDefinitionProvider", false);
  EditorContextKeys2.hasDeclarationProvider = new RawContextKey("editorHasDeclarationProvider", false);
  EditorContextKeys2.hasImplementationProvider = new RawContextKey("editorHasImplementationProvider", false);
  EditorContextKeys2.hasTypeDefinitionProvider = new RawContextKey("editorHasTypeDefinitionProvider", false);
  EditorContextKeys2.hasHoverProvider = new RawContextKey("editorHasHoverProvider", false);
  EditorContextKeys2.hasDocumentHighlightProvider = new RawContextKey("editorHasDocumentHighlightProvider", false);
  EditorContextKeys2.hasDocumentSymbolProvider = new RawContextKey("editorHasDocumentSymbolProvider", false);
  EditorContextKeys2.hasReferenceProvider = new RawContextKey("editorHasReferenceProvider", false);
  EditorContextKeys2.hasRenameProvider = new RawContextKey("editorHasRenameProvider", false);
  EditorContextKeys2.hasSignatureHelpProvider = new RawContextKey("editorHasSignatureHelpProvider", false);
  EditorContextKeys2.hasDocumentFormattingProvider = new RawContextKey("editorHasDocumentFormattingProvider", false);
  EditorContextKeys2.hasDocumentSelectionFormattingProvider = new RawContextKey("editorHasDocumentSelectionFormattingProvider", false);
  EditorContextKeys2.hasMultipleDocumentFormattingProvider = new RawContextKey("editorHasMultipleDocumentFormattingProvider", false);
  EditorContextKeys2.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey("editorHasMultipleDocumentSelectionFormattingProvider", false);
})(EditorContextKeys || (EditorContextKeys = {}));

// ../../node_modules/monaco-editor/esm/vs/editor/browser/controller/coreCommands.js
var CORE_WEIGHT = 0;
var CoreEditorCommand = class extends EditorCommand {
  runEditorCommand(accessor, editor2, args) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    this.runCoreEditorCommand(viewModel, args || {});
  }
};
var EditorScroll_;
(function(EditorScroll_2) {
  const isEditorScrollArgs = function(arg) {
    if (!isObject(arg)) {
      return false;
    }
    const scrollArg = arg;
    if (!isString(scrollArg.to)) {
      return false;
    }
    if (!isUndefined(scrollArg.by) && !isString(scrollArg.by)) {
      return false;
    }
    if (!isUndefined(scrollArg.value) && !isNumber(scrollArg.value)) {
      return false;
    }
    if (!isUndefined(scrollArg.revealCursor) && !isBoolean(scrollArg.revealCursor)) {
      return false;
    }
    return true;
  };
  EditorScroll_2.description = {
    description: "Scroll editor in the given direction",
    args: [
      {
        name: "Editor scroll argument object",
        description: `Property-value pairs that can be passed through this argument:
					* 'to': A mandatory direction value.
						\`\`\`
						'up', 'down'
						\`\`\`
					* 'by': Unit to move. Default is computed based on 'to' value.
						\`\`\`
						'line', 'wrappedLine', 'page', 'halfPage'
						\`\`\`
					* 'value': Number of units to move. Default is '1'.
					* 'revealCursor': If 'true' reveals the cursor if it is outside view port.
				`,
        constraint: isEditorScrollArgs,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["up", "down"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "page", "halfPage"]
            },
            value: {
              type: "number",
              default: 1
            },
            revealCursor: {
              type: "boolean"
            }
          }
        }
      }
    ]
  };
  EditorScroll_2.RawDirection = {
    Up: "up",
    Down: "down"
  };
  EditorScroll_2.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Page: "page",
    HalfPage: "halfPage"
  };
  function parse3(args) {
    let direction;
    switch (args.to) {
      case EditorScroll_2.RawDirection.Up:
        direction = 1;
        break;
      case EditorScroll_2.RawDirection.Down:
        direction = 2;
        break;
      default:
        return null;
    }
    let unit;
    switch (args.by) {
      case EditorScroll_2.RawUnit.Line:
        unit = 1;
        break;
      case EditorScroll_2.RawUnit.WrappedLine:
        unit = 2;
        break;
      case EditorScroll_2.RawUnit.Page:
        unit = 3;
        break;
      case EditorScroll_2.RawUnit.HalfPage:
        unit = 4;
        break;
      default:
        unit = 2;
    }
    const value = Math.floor(args.value || 1);
    const revealCursor = !!args.revealCursor;
    return {
      direction,
      unit,
      value,
      revealCursor,
      select: !!args.select
    };
  }
  EditorScroll_2.parse = parse3;
})(EditorScroll_ || (EditorScroll_ = {}));
var RevealLine_;
(function(RevealLine_2) {
  const isRevealLineArgs = function(arg) {
    if (!isObject(arg)) {
      return false;
    }
    const reveaLineArg = arg;
    if (!isNumber(reveaLineArg.lineNumber)) {
      return false;
    }
    if (!isUndefined(reveaLineArg.at) && !isString(reveaLineArg.at)) {
      return false;
    }
    return true;
  };
  RevealLine_2.description = {
    description: "Reveal the given line at the given logical position",
    args: [
      {
        name: "Reveal line argument object",
        description: `Property-value pairs that can be passed through this argument:
					* 'lineNumber': A mandatory line number value.
					* 'at': Logical position at which line has to be revealed .
						\`\`\`
						'top', 'center', 'bottom'
						\`\`\`
				`,
        constraint: isRevealLineArgs,
        schema: {
          type: "object",
          required: ["lineNumber"],
          properties: {
            lineNumber: {
              type: "number"
            },
            at: {
              type: "string",
              enum: ["top", "center", "bottom"]
            }
          }
        }
      }
    ]
  };
  RevealLine_2.RawAtArgument = {
    Top: "top",
    Center: "center",
    Bottom: "bottom"
  };
})(RevealLine_ || (RevealLine_ = {}));
var EditorOrNativeTextInputCommand = class {
  constructor(target) {
    target.addImplementation(1e4, (accessor, args) => {
      const focusedEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
      if (focusedEditor && focusedEditor.hasTextFocus()) {
        this.runEditorCommand(accessor, focusedEditor, args);
        return true;
      }
      return false;
    });
    target.addImplementation(1e3, (accessor, args) => {
      const activeElement = document.activeElement;
      if (activeElement && ["input", "textarea"].indexOf(activeElement.tagName.toLowerCase()) >= 0) {
        this.runDOMCommand();
        return true;
      }
      return false;
    });
    target.addImplementation(0, (accessor, args) => {
      const activeEditor = accessor.get(ICodeEditorService).getActiveCodeEditor();
      if (activeEditor) {
        activeEditor.focus();
        this.runEditorCommand(accessor, activeEditor, args);
        return true;
      }
      return false;
    });
  }
};
var CoreNavigationCommands;
(function(CoreNavigationCommands2) {
  class BaseMoveToCommand extends CoreEditorCommand {
    constructor(opts) {
      super(opts);
      this._inSelectionMode = opts.inSelectionMode;
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, [
        CursorMoveCommands.moveTo(viewModel, viewModel.getPrimaryCursorState(), this._inSelectionMode, args.position, args.viewPosition)
      ]);
      viewModel.revealPrimaryCursor(args.source, true);
    }
  }
  CoreNavigationCommands2.MoveTo = registerEditorCommand(new BaseMoveToCommand({
    id: "_moveTo",
    inSelectionMode: false,
    precondition: void 0
  }));
  CoreNavigationCommands2.MoveToSelect = registerEditorCommand(new BaseMoveToCommand({
    id: "_moveToSelect",
    inSelectionMode: true,
    precondition: void 0
  }));
  class ColumnSelectCommand extends CoreEditorCommand {
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      const result = this._getColumnSelectResult(viewModel, viewModel.getPrimaryCursorState(), viewModel.getCursorColumnSelectData(), args);
      viewModel.setCursorStates(args.source, 3, result.viewStates.map((viewState) => CursorState.fromViewState(viewState)));
      viewModel.setCursorColumnSelectData({
        isReal: true,
        fromViewLineNumber: result.fromLineNumber,
        fromViewVisualColumn: result.fromVisualColumn,
        toViewLineNumber: result.toLineNumber,
        toViewVisualColumn: result.toVisualColumn
      });
      if (result.reversed) {
        viewModel.revealTopMostCursor(args.source);
      } else {
        viewModel.revealBottomMostCursor(args.source);
      }
    }
  }
  CoreNavigationCommands2.ColumnSelect = registerEditorCommand(new class extends ColumnSelectCommand {
    constructor() {
      super({
        id: "columnSelect",
        precondition: void 0
      });
    }
    _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {
      const validatedPosition = viewModel.model.validatePosition(args.position);
      const validatedViewPosition = viewModel.coordinatesConverter.validateViewPosition(new Position(args.viewPosition.lineNumber, args.viewPosition.column), validatedPosition);
      let fromViewLineNumber = args.doColumnSelect ? prevColumnSelectData.fromViewLineNumber : validatedViewPosition.lineNumber;
      let fromViewVisualColumn = args.doColumnSelect ? prevColumnSelectData.fromViewVisualColumn : args.mouseColumn - 1;
      return ColumnSelection.columnSelect(viewModel.cursorConfig, viewModel, fromViewLineNumber, fromViewVisualColumn, validatedViewPosition.lineNumber, args.mouseColumn - 1);
    }
  }());
  CoreNavigationCommands2.CursorColumnSelectLeft = registerEditorCommand(new class extends ColumnSelectCommand {
    constructor() {
      super({
        id: "cursorColumnSelectLeft",
        precondition: void 0,
        kbOpts: {
          weight: CORE_WEIGHT,
          kbExpr: EditorContextKeys.textInputFocus,
          primary: 2048 | 1024 | 512 | 15,
          linux: {primary: 0}
        }
      });
    }
    _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {
      return ColumnSelection.columnSelectLeft(viewModel.cursorConfig, viewModel, prevColumnSelectData);
    }
  }());
  CoreNavigationCommands2.CursorColumnSelectRight = registerEditorCommand(new class extends ColumnSelectCommand {
    constructor() {
      super({
        id: "cursorColumnSelectRight",
        precondition: void 0,
        kbOpts: {
          weight: CORE_WEIGHT,
          kbExpr: EditorContextKeys.textInputFocus,
          primary: 2048 | 1024 | 512 | 17,
          linux: {primary: 0}
        }
      });
    }
    _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {
      return ColumnSelection.columnSelectRight(viewModel.cursorConfig, viewModel, prevColumnSelectData);
    }
  }());
  class ColumnSelectUpCommand extends ColumnSelectCommand {
    constructor(opts) {
      super(opts);
      this._isPaged = opts.isPaged;
    }
    _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {
      return ColumnSelection.columnSelectUp(viewModel.cursorConfig, viewModel, prevColumnSelectData, this._isPaged);
    }
  }
  CoreNavigationCommands2.CursorColumnSelectUp = registerEditorCommand(new ColumnSelectUpCommand({
    isPaged: false,
    id: "cursorColumnSelectUp",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 2048 | 1024 | 512 | 16,
      linux: {primary: 0}
    }
  }));
  CoreNavigationCommands2.CursorColumnSelectPageUp = registerEditorCommand(new ColumnSelectUpCommand({
    isPaged: true,
    id: "cursorColumnSelectPageUp",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 2048 | 1024 | 512 | 11,
      linux: {primary: 0}
    }
  }));
  class ColumnSelectDownCommand extends ColumnSelectCommand {
    constructor(opts) {
      super(opts);
      this._isPaged = opts.isPaged;
    }
    _getColumnSelectResult(viewModel, primary, prevColumnSelectData, args) {
      return ColumnSelection.columnSelectDown(viewModel.cursorConfig, viewModel, prevColumnSelectData, this._isPaged);
    }
  }
  CoreNavigationCommands2.CursorColumnSelectDown = registerEditorCommand(new ColumnSelectDownCommand({
    isPaged: false,
    id: "cursorColumnSelectDown",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 2048 | 1024 | 512 | 18,
      linux: {primary: 0}
    }
  }));
  CoreNavigationCommands2.CursorColumnSelectPageDown = registerEditorCommand(new ColumnSelectDownCommand({
    isPaged: true,
    id: "cursorColumnSelectPageDown",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 2048 | 1024 | 512 | 12,
      linux: {primary: 0}
    }
  }));
  class CursorMoveImpl extends CoreEditorCommand {
    constructor() {
      super({
        id: "cursorMove",
        precondition: void 0,
        description: CursorMove.description
      });
    }
    runCoreEditorCommand(viewModel, args) {
      const parsed = CursorMove.parse(args);
      if (!parsed) {
        return;
      }
      this._runCursorMove(viewModel, args.source, parsed);
    }
    _runCursorMove(viewModel, source, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(source, 3, CursorMoveImpl._move(viewModel, viewModel.getCursorStates(), args));
      viewModel.revealPrimaryCursor(source, true);
    }
    static _move(viewModel, cursors, args) {
      const inSelectionMode = args.select;
      const value = args.value;
      switch (args.direction) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
          return CursorMoveCommands.simpleMove(viewModel, cursors, args.direction, inSelectionMode, value, args.unit);
        case 9:
        case 11:
        case 10:
        case 12:
          return CursorMoveCommands.viewportMove(viewModel, cursors, args.direction, inSelectionMode, value);
        default:
          return null;
      }
    }
  }
  CoreNavigationCommands2.CursorMoveImpl = CursorMoveImpl;
  CoreNavigationCommands2.CursorMove = registerEditorCommand(new CursorMoveImpl());
  class CursorMoveBasedCommand extends CoreEditorCommand {
    constructor(opts) {
      super(opts);
      this._staticArgs = opts.args;
    }
    runCoreEditorCommand(viewModel, dynamicArgs) {
      let args = this._staticArgs;
      if (this._staticArgs.value === -1) {
        args = {
          direction: this._staticArgs.direction,
          unit: this._staticArgs.unit,
          select: this._staticArgs.select,
          value: viewModel.cursorConfig.pageSize
        };
      }
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(dynamicArgs.source, 3, CursorMoveCommands.simpleMove(viewModel, viewModel.getCursorStates(), args.direction, args.select, args.value, args.unit));
      viewModel.revealPrimaryCursor(dynamicArgs.source, true);
    }
  }
  CoreNavigationCommands2.CursorLeft = registerEditorCommand(new CursorMoveBasedCommand({
    args: {
      direction: 0,
      unit: 0,
      select: false,
      value: 1
    },
    id: "cursorLeft",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 15,
      mac: {primary: 15, secondary: [256 | 32]}
    }
  }));
  CoreNavigationCommands2.CursorLeftSelect = registerEditorCommand(new CursorMoveBasedCommand({
    args: {
      direction: 0,
      unit: 0,
      select: true,
      value: 1
    },
    id: "cursorLeftSelect",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 1024 | 15
    }
  }));
  CoreNavigationCommands2.CursorRight = registerEditorCommand(new CursorMoveBasedCommand({
    args: {
      direction: 1,
      unit: 0,
      select: false,
      value: 1
    },
    id: "cursorRight",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 17,
      mac: {primary: 17, secondary: [256 | 36]}
    }
  }));
  CoreNavigationCommands2.CursorRightSelect = registerEditorCommand(new CursorMoveBasedCommand({
    args: {
      direction: 1,
      unit: 0,
      select: true,
      value: 1
    },
    id: "cursorRightSelect",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 1024 | 17
    }
  }));
  CoreNavigationCommands2.CursorUp = registerEditorCommand(new CursorMoveBasedCommand({
    args: {
      direction: 2,
      unit: 2,
      select: false,
      value: 1
    },
    id: "cursorUp",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 16,
      mac: {primary: 16, secondary: [256 | 46]}
    }
  }));
  CoreNavigationCommands2.CursorUpSelect = registerEditorCommand(new CursorMoveBasedCommand({
    args: {
      direction: 2,
      unit: 2,
      select: true,
      value: 1
    },
    id: "cursorUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 1024 | 16,
      secondary: [2048 | 1024 | 16],
      mac: {primary: 1024 | 16},
      linux: {primary: 1024 | 16}
    }
  }));
  CoreNavigationCommands2.CursorPageUp = registerEditorCommand(new CursorMoveBasedCommand({
    args: {
      direction: 2,
      unit: 2,
      select: false,
      value: -1
    },
    id: "cursorPageUp",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 11
    }
  }));
  CoreNavigationCommands2.CursorPageUpSelect = registerEditorCommand(new CursorMoveBasedCommand({
    args: {
      direction: 2,
      unit: 2,
      select: true,
      value: -1
    },
    id: "cursorPageUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 1024 | 11
    }
  }));
  CoreNavigationCommands2.CursorDown = registerEditorCommand(new CursorMoveBasedCommand({
    args: {
      direction: 3,
      unit: 2,
      select: false,
      value: 1
    },
    id: "cursorDown",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 18,
      mac: {primary: 18, secondary: [256 | 44]}
    }
  }));
  CoreNavigationCommands2.CursorDownSelect = registerEditorCommand(new CursorMoveBasedCommand({
    args: {
      direction: 3,
      unit: 2,
      select: true,
      value: 1
    },
    id: "cursorDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 1024 | 18,
      secondary: [2048 | 1024 | 18],
      mac: {primary: 1024 | 18},
      linux: {primary: 1024 | 18}
    }
  }));
  CoreNavigationCommands2.CursorPageDown = registerEditorCommand(new CursorMoveBasedCommand({
    args: {
      direction: 3,
      unit: 2,
      select: false,
      value: -1
    },
    id: "cursorPageDown",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 12
    }
  }));
  CoreNavigationCommands2.CursorPageDownSelect = registerEditorCommand(new CursorMoveBasedCommand({
    args: {
      direction: 3,
      unit: 2,
      select: true,
      value: -1
    },
    id: "cursorPageDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 1024 | 12
    }
  }));
  CoreNavigationCommands2.CreateCursor = registerEditorCommand(new class extends CoreEditorCommand {
    constructor() {
      super({
        id: "createCursor",
        precondition: void 0
      });
    }
    runCoreEditorCommand(viewModel, args) {
      let newState;
      if (args.wholeLine) {
        newState = CursorMoveCommands.line(viewModel, viewModel.getPrimaryCursorState(), false, args.position, args.viewPosition);
      } else {
        newState = CursorMoveCommands.moveTo(viewModel, viewModel.getPrimaryCursorState(), false, args.position, args.viewPosition);
      }
      const states = viewModel.getCursorStates();
      if (states.length > 1) {
        const newModelPosition = newState.modelState ? newState.modelState.position : null;
        const newViewPosition = newState.viewState ? newState.viewState.position : null;
        for (let i = 0, len = states.length; i < len; i++) {
          const state = states[i];
          if (newModelPosition && !state.modelState.selection.containsPosition(newModelPosition)) {
            continue;
          }
          if (newViewPosition && !state.viewState.selection.containsPosition(newViewPosition)) {
            continue;
          }
          states.splice(i, 1);
          viewModel.model.pushStackElement();
          viewModel.setCursorStates(args.source, 3, states);
          return;
        }
      }
      states.push(newState);
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, states);
    }
  }());
  CoreNavigationCommands2.LastCursorMoveToSelect = registerEditorCommand(new class extends CoreEditorCommand {
    constructor() {
      super({
        id: "_lastCursorMoveToSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(viewModel, args) {
      const lastAddedCursorIndex = viewModel.getLastAddedCursorIndex();
      const states = viewModel.getCursorStates();
      const newStates = states.slice(0);
      newStates[lastAddedCursorIndex] = CursorMoveCommands.moveTo(viewModel, states[lastAddedCursorIndex], true, args.position, args.viewPosition);
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, newStates);
    }
  }());
  class HomeCommand extends CoreEditorCommand {
    constructor(opts) {
      super(opts);
      this._inSelectionMode = opts.inSelectionMode;
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, CursorMoveCommands.moveToBeginningOfLine(viewModel, viewModel.getCursorStates(), this._inSelectionMode));
      viewModel.revealPrimaryCursor(args.source, true);
    }
  }
  CoreNavigationCommands2.CursorHome = registerEditorCommand(new HomeCommand({
    inSelectionMode: false,
    id: "cursorHome",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 14,
      mac: {primary: 14, secondary: [2048 | 15]}
    }
  }));
  CoreNavigationCommands2.CursorHomeSelect = registerEditorCommand(new HomeCommand({
    inSelectionMode: true,
    id: "cursorHomeSelect",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 1024 | 14,
      mac: {primary: 1024 | 14, secondary: [2048 | 1024 | 15]}
    }
  }));
  class LineStartCommand extends CoreEditorCommand {
    constructor(opts) {
      super(opts);
      this._inSelectionMode = opts.inSelectionMode;
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, this._exec(viewModel.getCursorStates()));
      viewModel.revealPrimaryCursor(args.source, true);
    }
    _exec(cursors) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        const cursor = cursors[i];
        const lineNumber = cursor.modelState.position.lineNumber;
        result[i] = CursorState.fromModelState(cursor.modelState.move(this._inSelectionMode, lineNumber, 1, 0));
      }
      return result;
    }
  }
  CoreNavigationCommands2.CursorLineStart = registerEditorCommand(new LineStartCommand({
    inSelectionMode: false,
    id: "cursorLineStart",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 0,
      mac: {primary: 256 | 31}
    }
  }));
  CoreNavigationCommands2.CursorLineStartSelect = registerEditorCommand(new LineStartCommand({
    inSelectionMode: true,
    id: "cursorLineStartSelect",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 0,
      mac: {primary: 256 | 1024 | 31}
    }
  }));
  class EndCommand extends CoreEditorCommand {
    constructor(opts) {
      super(opts);
      this._inSelectionMode = opts.inSelectionMode;
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, CursorMoveCommands.moveToEndOfLine(viewModel, viewModel.getCursorStates(), this._inSelectionMode, args.sticky || false));
      viewModel.revealPrimaryCursor(args.source, true);
    }
  }
  CoreNavigationCommands2.CursorEnd = registerEditorCommand(new EndCommand({
    inSelectionMode: false,
    id: "cursorEnd",
    precondition: void 0,
    kbOpts: {
      args: {sticky: false},
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 13,
      mac: {primary: 13, secondary: [2048 | 17]}
    },
    description: {
      description: `Go to End`,
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: localize("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: false
            }
          }
        }
      }]
    }
  }));
  CoreNavigationCommands2.CursorEndSelect = registerEditorCommand(new EndCommand({
    inSelectionMode: true,
    id: "cursorEndSelect",
    precondition: void 0,
    kbOpts: {
      args: {sticky: false},
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 1024 | 13,
      mac: {primary: 1024 | 13, secondary: [2048 | 1024 | 17]}
    },
    description: {
      description: `Select to End`,
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: localize("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: false
            }
          }
        }
      }]
    }
  }));
  class LineEndCommand extends CoreEditorCommand {
    constructor(opts) {
      super(opts);
      this._inSelectionMode = opts.inSelectionMode;
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, this._exec(viewModel, viewModel.getCursorStates()));
      viewModel.revealPrimaryCursor(args.source, true);
    }
    _exec(viewModel, cursors) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        const cursor = cursors[i];
        const lineNumber = cursor.modelState.position.lineNumber;
        const maxColumn = viewModel.model.getLineMaxColumn(lineNumber);
        result[i] = CursorState.fromModelState(cursor.modelState.move(this._inSelectionMode, lineNumber, maxColumn, 0));
      }
      return result;
    }
  }
  CoreNavigationCommands2.CursorLineEnd = registerEditorCommand(new LineEndCommand({
    inSelectionMode: false,
    id: "cursorLineEnd",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 0,
      mac: {primary: 256 | 35}
    }
  }));
  CoreNavigationCommands2.CursorLineEndSelect = registerEditorCommand(new LineEndCommand({
    inSelectionMode: true,
    id: "cursorLineEndSelect",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 0,
      mac: {primary: 256 | 1024 | 35}
    }
  }));
  class TopCommand extends CoreEditorCommand {
    constructor(opts) {
      super(opts);
      this._inSelectionMode = opts.inSelectionMode;
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, CursorMoveCommands.moveToBeginningOfBuffer(viewModel, viewModel.getCursorStates(), this._inSelectionMode));
      viewModel.revealPrimaryCursor(args.source, true);
    }
  }
  CoreNavigationCommands2.CursorTop = registerEditorCommand(new TopCommand({
    inSelectionMode: false,
    id: "cursorTop",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 2048 | 14,
      mac: {primary: 2048 | 16}
    }
  }));
  CoreNavigationCommands2.CursorTopSelect = registerEditorCommand(new TopCommand({
    inSelectionMode: true,
    id: "cursorTopSelect",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 2048 | 1024 | 14,
      mac: {primary: 2048 | 1024 | 16}
    }
  }));
  class BottomCommand extends CoreEditorCommand {
    constructor(opts) {
      super(opts);
      this._inSelectionMode = opts.inSelectionMode;
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, CursorMoveCommands.moveToEndOfBuffer(viewModel, viewModel.getCursorStates(), this._inSelectionMode));
      viewModel.revealPrimaryCursor(args.source, true);
    }
  }
  CoreNavigationCommands2.CursorBottom = registerEditorCommand(new BottomCommand({
    inSelectionMode: false,
    id: "cursorBottom",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 2048 | 13,
      mac: {primary: 2048 | 18}
    }
  }));
  CoreNavigationCommands2.CursorBottomSelect = registerEditorCommand(new BottomCommand({
    inSelectionMode: true,
    id: "cursorBottomSelect",
    precondition: void 0,
    kbOpts: {
      weight: CORE_WEIGHT,
      kbExpr: EditorContextKeys.textInputFocus,
      primary: 2048 | 1024 | 13,
      mac: {primary: 2048 | 1024 | 18}
    }
  }));
  class EditorScrollImpl extends CoreEditorCommand {
    constructor() {
      super({
        id: "editorScroll",
        precondition: void 0,
        description: EditorScroll_.description
      });
    }
    runCoreEditorCommand(viewModel, args) {
      const parsed = EditorScroll_.parse(args);
      if (!parsed) {
        return;
      }
      this._runEditorScroll(viewModel, args.source, parsed);
    }
    _runEditorScroll(viewModel, source, args) {
      const desiredScrollTop = this._computeDesiredScrollTop(viewModel, args);
      if (args.revealCursor) {
        const desiredVisibleViewRange = viewModel.getCompletelyVisibleViewRangeAtScrollTop(desiredScrollTop);
        viewModel.setCursorStates(source, 3, [
          CursorMoveCommands.findPositionInViewportIfOutside(viewModel, viewModel.getPrimaryCursorState(), desiredVisibleViewRange, args.select)
        ]);
      }
      viewModel.setScrollTop(desiredScrollTop, 0);
    }
    _computeDesiredScrollTop(viewModel, args) {
      if (args.unit === 1) {
        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();
        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);
        let desiredTopModelLineNumber;
        if (args.direction === 1) {
          desiredTopModelLineNumber = Math.max(1, visibleModelRange.startLineNumber - args.value);
        } else {
          desiredTopModelLineNumber = Math.min(viewModel.model.getLineCount(), visibleModelRange.startLineNumber + args.value);
        }
        const viewPosition = viewModel.coordinatesConverter.convertModelPositionToViewPosition(new Position(desiredTopModelLineNumber, 1));
        return viewModel.getVerticalOffsetForLineNumber(viewPosition.lineNumber);
      }
      let noOfLines;
      if (args.unit === 3) {
        noOfLines = viewModel.cursorConfig.pageSize * args.value;
      } else if (args.unit === 4) {
        noOfLines = Math.round(viewModel.cursorConfig.pageSize / 2) * args.value;
      } else {
        noOfLines = args.value;
      }
      const deltaLines = (args.direction === 1 ? -1 : 1) * noOfLines;
      return viewModel.getScrollTop() + deltaLines * viewModel.cursorConfig.lineHeight;
    }
  }
  CoreNavigationCommands2.EditorScrollImpl = EditorScrollImpl;
  CoreNavigationCommands2.EditorScroll = registerEditorCommand(new EditorScrollImpl());
  CoreNavigationCommands2.ScrollLineUp = registerEditorCommand(new class extends CoreEditorCommand {
    constructor() {
      super({
        id: "scrollLineUp",
        precondition: void 0,
        kbOpts: {
          weight: CORE_WEIGHT,
          kbExpr: EditorContextKeys.textInputFocus,
          primary: 2048 | 16,
          mac: {primary: 256 | 11}
        }
      });
    }
    runCoreEditorCommand(viewModel, args) {
      CoreNavigationCommands2.EditorScroll._runEditorScroll(viewModel, args.source, {
        direction: 1,
        unit: 2,
        value: 1,
        revealCursor: false,
        select: false
      });
    }
  }());
  CoreNavigationCommands2.ScrollPageUp = registerEditorCommand(new class extends CoreEditorCommand {
    constructor() {
      super({
        id: "scrollPageUp",
        precondition: void 0,
        kbOpts: {
          weight: CORE_WEIGHT,
          kbExpr: EditorContextKeys.textInputFocus,
          primary: 2048 | 11,
          win: {primary: 512 | 11},
          linux: {primary: 512 | 11}
        }
      });
    }
    runCoreEditorCommand(viewModel, args) {
      CoreNavigationCommands2.EditorScroll._runEditorScroll(viewModel, args.source, {
        direction: 1,
        unit: 3,
        value: 1,
        revealCursor: false,
        select: false
      });
    }
  }());
  CoreNavigationCommands2.ScrollLineDown = registerEditorCommand(new class extends CoreEditorCommand {
    constructor() {
      super({
        id: "scrollLineDown",
        precondition: void 0,
        kbOpts: {
          weight: CORE_WEIGHT,
          kbExpr: EditorContextKeys.textInputFocus,
          primary: 2048 | 18,
          mac: {primary: 256 | 12}
        }
      });
    }
    runCoreEditorCommand(viewModel, args) {
      CoreNavigationCommands2.EditorScroll._runEditorScroll(viewModel, args.source, {
        direction: 2,
        unit: 2,
        value: 1,
        revealCursor: false,
        select: false
      });
    }
  }());
  CoreNavigationCommands2.ScrollPageDown = registerEditorCommand(new class extends CoreEditorCommand {
    constructor() {
      super({
        id: "scrollPageDown",
        precondition: void 0,
        kbOpts: {
          weight: CORE_WEIGHT,
          kbExpr: EditorContextKeys.textInputFocus,
          primary: 2048 | 12,
          win: {primary: 512 | 12},
          linux: {primary: 512 | 12}
        }
      });
    }
    runCoreEditorCommand(viewModel, args) {
      CoreNavigationCommands2.EditorScroll._runEditorScroll(viewModel, args.source, {
        direction: 2,
        unit: 3,
        value: 1,
        revealCursor: false,
        select: false
      });
    }
  }());
  class WordCommand extends CoreEditorCommand {
    constructor(opts) {
      super(opts);
      this._inSelectionMode = opts.inSelectionMode;
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, [
        CursorMoveCommands.word(viewModel, viewModel.getPrimaryCursorState(), this._inSelectionMode, args.position)
      ]);
      viewModel.revealPrimaryCursor(args.source, true);
    }
  }
  CoreNavigationCommands2.WordSelect = registerEditorCommand(new WordCommand({
    inSelectionMode: false,
    id: "_wordSelect",
    precondition: void 0
  }));
  CoreNavigationCommands2.WordSelectDrag = registerEditorCommand(new WordCommand({
    inSelectionMode: true,
    id: "_wordSelectDrag",
    precondition: void 0
  }));
  CoreNavigationCommands2.LastCursorWordSelect = registerEditorCommand(new class extends CoreEditorCommand {
    constructor() {
      super({
        id: "lastCursorWordSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(viewModel, args) {
      const lastAddedCursorIndex = viewModel.getLastAddedCursorIndex();
      const states = viewModel.getCursorStates();
      const newStates = states.slice(0);
      const lastAddedState = states[lastAddedCursorIndex];
      newStates[lastAddedCursorIndex] = CursorMoveCommands.word(viewModel, lastAddedState, lastAddedState.modelState.hasSelection(), args.position);
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, newStates);
    }
  }());
  class LineCommand extends CoreEditorCommand {
    constructor(opts) {
      super(opts);
      this._inSelectionMode = opts.inSelectionMode;
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, [
        CursorMoveCommands.line(viewModel, viewModel.getPrimaryCursorState(), this._inSelectionMode, args.position, args.viewPosition)
      ]);
      viewModel.revealPrimaryCursor(args.source, false);
    }
  }
  CoreNavigationCommands2.LineSelect = registerEditorCommand(new LineCommand({
    inSelectionMode: false,
    id: "_lineSelect",
    precondition: void 0
  }));
  CoreNavigationCommands2.LineSelectDrag = registerEditorCommand(new LineCommand({
    inSelectionMode: true,
    id: "_lineSelectDrag",
    precondition: void 0
  }));
  class LastCursorLineCommand extends CoreEditorCommand {
    constructor(opts) {
      super(opts);
      this._inSelectionMode = opts.inSelectionMode;
    }
    runCoreEditorCommand(viewModel, args) {
      const lastAddedCursorIndex = viewModel.getLastAddedCursorIndex();
      const states = viewModel.getCursorStates();
      const newStates = states.slice(0);
      newStates[lastAddedCursorIndex] = CursorMoveCommands.line(viewModel, states[lastAddedCursorIndex], this._inSelectionMode, args.position, args.viewPosition);
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, newStates);
    }
  }
  CoreNavigationCommands2.LastCursorLineSelect = registerEditorCommand(new LastCursorLineCommand({
    inSelectionMode: false,
    id: "lastCursorLineSelect",
    precondition: void 0
  }));
  CoreNavigationCommands2.LastCursorLineSelectDrag = registerEditorCommand(new LastCursorLineCommand({
    inSelectionMode: true,
    id: "lastCursorLineSelectDrag",
    precondition: void 0
  }));
  CoreNavigationCommands2.ExpandLineSelection = registerEditorCommand(new class extends CoreEditorCommand {
    constructor() {
      super({
        id: "expandLineSelection",
        precondition: void 0,
        kbOpts: {
          weight: CORE_WEIGHT,
          kbExpr: EditorContextKeys.textInputFocus,
          primary: 2048 | 42
        }
      });
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, CursorMoveCommands.expandLineSelection(viewModel, viewModel.getCursorStates()));
      viewModel.revealPrimaryCursor(args.source, true);
    }
  }());
  CoreNavigationCommands2.CancelSelection = registerEditorCommand(new class extends CoreEditorCommand {
    constructor() {
      super({
        id: "cancelSelection",
        precondition: EditorContextKeys.hasNonEmptySelection,
        kbOpts: {
          weight: CORE_WEIGHT,
          kbExpr: EditorContextKeys.textInputFocus,
          primary: 9,
          secondary: [1024 | 9]
        }
      });
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, [
        CursorMoveCommands.cancelSelection(viewModel, viewModel.getPrimaryCursorState())
      ]);
      viewModel.revealPrimaryCursor(args.source, true);
    }
  }());
  CoreNavigationCommands2.RemoveSecondaryCursors = registerEditorCommand(new class extends CoreEditorCommand {
    constructor() {
      super({
        id: "removeSecondaryCursors",
        precondition: EditorContextKeys.hasMultipleSelections,
        kbOpts: {
          weight: CORE_WEIGHT + 1,
          kbExpr: EditorContextKeys.textInputFocus,
          primary: 9,
          secondary: [1024 | 9]
        }
      });
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, [
        viewModel.getPrimaryCursorState()
      ]);
      viewModel.revealPrimaryCursor(args.source, true);
    }
  }());
  CoreNavigationCommands2.RevealLine = registerEditorCommand(new class extends CoreEditorCommand {
    constructor() {
      super({
        id: "revealLine",
        precondition: void 0,
        description: RevealLine_.description
      });
    }
    runCoreEditorCommand(viewModel, args) {
      const revealLineArg = args;
      let lineNumber = (revealLineArg.lineNumber || 0) + 1;
      if (lineNumber < 1) {
        lineNumber = 1;
      }
      const lineCount = viewModel.model.getLineCount();
      if (lineNumber > lineCount) {
        lineNumber = lineCount;
      }
      const range2 = new Range(lineNumber, 1, lineNumber, viewModel.model.getLineMaxColumn(lineNumber));
      let revealAt = 0;
      if (revealLineArg.at) {
        switch (revealLineArg.at) {
          case RevealLine_.RawAtArgument.Top:
            revealAt = 3;
            break;
          case RevealLine_.RawAtArgument.Center:
            revealAt = 1;
            break;
          case RevealLine_.RawAtArgument.Bottom:
            revealAt = 4;
            break;
          default:
            break;
        }
      }
      const viewRange = viewModel.coordinatesConverter.convertModelRangeToViewRange(range2);
      viewModel.revealRange(args.source, false, viewRange, revealAt, 0);
    }
  }());
  CoreNavigationCommands2.SelectAll = new class extends EditorOrNativeTextInputCommand {
    constructor() {
      super(SelectAllCommand);
    }
    runDOMCommand() {
      document.execCommand("selectAll");
    }
    runEditorCommand(accessor, editor2, args) {
      const viewModel = editor2._getViewModel();
      if (!viewModel) {
        return;
      }
      this.runCoreEditorCommand(viewModel, args);
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates("keyboard", 3, [
        CursorMoveCommands.selectAll(viewModel, viewModel.getPrimaryCursorState())
      ]);
    }
  }();
  CoreNavigationCommands2.SetSelection = registerEditorCommand(new class extends CoreEditorCommand {
    constructor() {
      super({
        id: "setSelection",
        precondition: void 0
      });
    }
    runCoreEditorCommand(viewModel, args) {
      viewModel.model.pushStackElement();
      viewModel.setCursorStates(args.source, 3, [
        CursorState.fromModelSelection(args.selection)
      ]);
    }
  }());
})(CoreNavigationCommands || (CoreNavigationCommands = {}));
var columnSelectionCondition = ContextKeyExpr.and(EditorContextKeys.textInputFocus, EditorContextKeys.columnSelection);
function registerColumnSelection(id, keybinding) {
  KeybindingsRegistry.registerKeybindingRule({
    id,
    primary: keybinding,
    when: columnSelectionCondition,
    weight: CORE_WEIGHT + 1
  });
}
registerColumnSelection(CoreNavigationCommands.CursorColumnSelectLeft.id, 1024 | 15);
registerColumnSelection(CoreNavigationCommands.CursorColumnSelectRight.id, 1024 | 17);
registerColumnSelection(CoreNavigationCommands.CursorColumnSelectUp.id, 1024 | 16);
registerColumnSelection(CoreNavigationCommands.CursorColumnSelectPageUp.id, 1024 | 11);
registerColumnSelection(CoreNavigationCommands.CursorColumnSelectDown.id, 1024 | 18);
registerColumnSelection(CoreNavigationCommands.CursorColumnSelectPageDown.id, 1024 | 12);
function registerCommand2(command) {
  command.register();
  return command;
}
var CoreEditingCommands;
(function(CoreEditingCommands2) {
  class CoreEditingCommand extends EditorCommand {
    runEditorCommand(accessor, editor2, args) {
      const viewModel = editor2._getViewModel();
      if (!viewModel) {
        return;
      }
      this.runCoreEditingCommand(editor2, viewModel, args || {});
    }
  }
  CoreEditingCommands2.CoreEditingCommand = CoreEditingCommand;
  CoreEditingCommands2.LineBreakInsert = registerEditorCommand(new class extends CoreEditingCommand {
    constructor() {
      super({
        id: "lineBreakInsert",
        precondition: EditorContextKeys.writable,
        kbOpts: {
          weight: CORE_WEIGHT,
          kbExpr: EditorContextKeys.textInputFocus,
          primary: 0,
          mac: {primary: 256 | 45}
        }
      });
    }
    runCoreEditingCommand(editor2, viewModel, args) {
      editor2.pushUndoStop();
      editor2.executeCommands(this.id, TypeOperations.lineBreakInsert(viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map((s) => s.modelState.selection)));
    }
  }());
  CoreEditingCommands2.Outdent = registerEditorCommand(new class extends CoreEditingCommand {
    constructor() {
      super({
        id: "outdent",
        precondition: EditorContextKeys.writable,
        kbOpts: {
          weight: CORE_WEIGHT,
          kbExpr: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, EditorContextKeys.tabDoesNotMoveFocus),
          primary: 1024 | 2
        }
      });
    }
    runCoreEditingCommand(editor2, viewModel, args) {
      editor2.pushUndoStop();
      editor2.executeCommands(this.id, TypeOperations.outdent(viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map((s) => s.modelState.selection)));
      editor2.pushUndoStop();
    }
  }());
  CoreEditingCommands2.Tab = registerEditorCommand(new class extends CoreEditingCommand {
    constructor() {
      super({
        id: "tab",
        precondition: EditorContextKeys.writable,
        kbOpts: {
          weight: CORE_WEIGHT,
          kbExpr: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, EditorContextKeys.tabDoesNotMoveFocus),
          primary: 2
        }
      });
    }
    runCoreEditingCommand(editor2, viewModel, args) {
      editor2.pushUndoStop();
      editor2.executeCommands(this.id, TypeOperations.tab(viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map((s) => s.modelState.selection)));
      editor2.pushUndoStop();
    }
  }());
  CoreEditingCommands2.DeleteLeft = registerEditorCommand(new class extends CoreEditingCommand {
    constructor() {
      super({
        id: "deleteLeft",
        precondition: void 0,
        kbOpts: {
          weight: CORE_WEIGHT,
          kbExpr: EditorContextKeys.textInputFocus,
          primary: 1,
          secondary: [1024 | 1],
          mac: {primary: 1, secondary: [1024 | 1, 256 | 38, 256 | 1]}
        }
      });
    }
    runCoreEditingCommand(editor2, viewModel, args) {
      const [shouldPushStackElementBefore, commands] = DeleteOperations.deleteLeft(viewModel.getPrevEditOperationType(), viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map((s) => s.modelState.selection));
      if (shouldPushStackElementBefore) {
        editor2.pushUndoStop();
      }
      editor2.executeCommands(this.id, commands);
      viewModel.setPrevEditOperationType(2);
    }
  }());
  CoreEditingCommands2.DeleteRight = registerEditorCommand(new class extends CoreEditingCommand {
    constructor() {
      super({
        id: "deleteRight",
        precondition: void 0,
        kbOpts: {
          weight: CORE_WEIGHT,
          kbExpr: EditorContextKeys.textInputFocus,
          primary: 20,
          mac: {primary: 20, secondary: [256 | 34, 256 | 20]}
        }
      });
    }
    runCoreEditingCommand(editor2, viewModel, args) {
      const [shouldPushStackElementBefore, commands] = DeleteOperations.deleteRight(viewModel.getPrevEditOperationType(), viewModel.cursorConfig, viewModel.model, viewModel.getCursorStates().map((s) => s.modelState.selection));
      if (shouldPushStackElementBefore) {
        editor2.pushUndoStop();
      }
      editor2.executeCommands(this.id, commands);
      viewModel.setPrevEditOperationType(3);
    }
  }());
  CoreEditingCommands2.Undo = new class extends EditorOrNativeTextInputCommand {
    constructor() {
      super(UndoCommand);
    }
    runDOMCommand() {
      document.execCommand("undo");
    }
    runEditorCommand(accessor, editor2, args) {
      if (!editor2.hasModel() || editor2.getOption(72) === true) {
        return;
      }
      editor2.getModel().undo();
    }
  }();
  CoreEditingCommands2.Redo = new class extends EditorOrNativeTextInputCommand {
    constructor() {
      super(RedoCommand);
    }
    runDOMCommand() {
      document.execCommand("redo");
    }
    runEditorCommand(accessor, editor2, args) {
      if (!editor2.hasModel() || editor2.getOption(72) === true) {
        return;
      }
      editor2.getModel().redo();
    }
  }();
})(CoreEditingCommands || (CoreEditingCommands = {}));
var EditorHandlerCommand = class extends Command {
  constructor(id, handlerId, description) {
    super({
      id,
      precondition: void 0,
      description
    });
    this._handlerId = handlerId;
  }
  runCommand(accessor, args) {
    const editor2 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
    if (!editor2) {
      return;
    }
    editor2.trigger("keyboard", this._handlerId, args);
  }
};
function registerOverwritableCommand(handlerId, description) {
  registerCommand2(new EditorHandlerCommand("default:" + handlerId, handlerId));
  registerCommand2(new EditorHandlerCommand(handlerId, handlerId, description));
}
registerOverwritableCommand("type", {
  description: `Type`,
  args: [{
    name: "args",
    schema: {
      type: "object",
      required: ["text"],
      properties: {
        text: {
          type: "string"
        }
      }
    }
  }]
});
registerOverwritableCommand("replacePreviousChar");
registerOverwritableCommand("compositionStart");
registerOverwritableCommand("compositionEnd");
registerOverwritableCommand("paste");
registerOverwritableCommand("cut");

// ../../node_modules/monaco-editor/esm/vs/editor/browser/view/viewController.js
var ViewController = class {
  constructor(configuration, viewModel, userInputEvents, commandDelegate) {
    this.configuration = configuration;
    this.viewModel = viewModel;
    this.userInputEvents = userInputEvents;
    this.commandDelegate = commandDelegate;
  }
  paste(text, pasteOnNewLine, multicursorText, mode) {
    this.commandDelegate.paste(text, pasteOnNewLine, multicursorText, mode);
  }
  type(text) {
    this.commandDelegate.type(text);
  }
  replacePreviousChar(text, replaceCharCnt) {
    this.commandDelegate.replacePreviousChar(text, replaceCharCnt);
  }
  compositionStart() {
    this.commandDelegate.startComposition();
  }
  compositionEnd() {
    this.commandDelegate.endComposition();
  }
  cut() {
    this.commandDelegate.cut();
  }
  setSelection(modelSelection) {
    CoreNavigationCommands.SetSelection.runCoreEditorCommand(this.viewModel, {
      source: "keyboard",
      selection: modelSelection
    });
  }
  _validateViewColumn(viewPosition) {
    const minColumn = this.viewModel.getLineMinColumn(viewPosition.lineNumber);
    if (viewPosition.column < minColumn) {
      return new Position(viewPosition.lineNumber, minColumn);
    }
    return viewPosition;
  }
  _hasMulticursorModifier(data) {
    switch (this.configuration.options.get(61)) {
      case "altKey":
        return data.altKey;
      case "ctrlKey":
        return data.ctrlKey;
      case "metaKey":
        return data.metaKey;
      default:
        return false;
    }
  }
  _hasNonMulticursorModifier(data) {
    switch (this.configuration.options.get(61)) {
      case "altKey":
        return data.ctrlKey || data.metaKey;
      case "ctrlKey":
        return data.altKey || data.metaKey;
      case "metaKey":
        return data.ctrlKey || data.altKey;
      default:
        return false;
    }
  }
  dispatchMouse(data) {
    const options = this.configuration.options;
    const selectionClipboardIsOn = isLinux && options.get(88);
    const columnSelection = options.get(13);
    if (data.middleButton && !selectionClipboardIsOn) {
      this._columnSelect(data.position, data.mouseColumn, data.inSelectionMode);
    } else if (data.startedOnLineNumbers) {
      if (this._hasMulticursorModifier(data)) {
        if (data.inSelectionMode) {
          this._lastCursorLineSelect(data.position);
        } else {
          this._createCursor(data.position, true);
        }
      } else {
        if (data.inSelectionMode) {
          this._lineSelectDrag(data.position);
        } else {
          this._lineSelect(data.position);
        }
      }
    } else if (data.mouseDownCount >= 4) {
      this._selectAll();
    } else if (data.mouseDownCount === 3) {
      if (this._hasMulticursorModifier(data)) {
        if (data.inSelectionMode) {
          this._lastCursorLineSelectDrag(data.position);
        } else {
          this._lastCursorLineSelect(data.position);
        }
      } else {
        if (data.inSelectionMode) {
          this._lineSelectDrag(data.position);
        } else {
          this._lineSelect(data.position);
        }
      }
    } else if (data.mouseDownCount === 2) {
      if (this._hasMulticursorModifier(data)) {
        this._lastCursorWordSelect(data.position);
      } else {
        if (data.inSelectionMode) {
          this._wordSelectDrag(data.position);
        } else {
          this._wordSelect(data.position);
        }
      }
    } else {
      if (this._hasMulticursorModifier(data)) {
        if (!this._hasNonMulticursorModifier(data)) {
          if (data.shiftKey) {
            this._columnSelect(data.position, data.mouseColumn, true);
          } else {
            if (data.inSelectionMode) {
              this._lastCursorMoveToSelect(data.position);
            } else {
              this._createCursor(data.position, false);
            }
          }
        }
      } else {
        if (data.inSelectionMode) {
          if (data.altKey) {
            this._columnSelect(data.position, data.mouseColumn, true);
          } else {
            if (columnSelection) {
              this._columnSelect(data.position, data.mouseColumn, true);
            } else {
              this._moveToSelect(data.position);
            }
          }
        } else {
          this.moveTo(data.position);
        }
      }
    }
  }
  _usualArgs(viewPosition) {
    viewPosition = this._validateViewColumn(viewPosition);
    return {
      source: "mouse",
      position: this._convertViewToModelPosition(viewPosition),
      viewPosition
    };
  }
  moveTo(viewPosition) {
    CoreNavigationCommands.MoveTo.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));
  }
  _moveToSelect(viewPosition) {
    CoreNavigationCommands.MoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));
  }
  _columnSelect(viewPosition, mouseColumn, doColumnSelect) {
    viewPosition = this._validateViewColumn(viewPosition);
    CoreNavigationCommands.ColumnSelect.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(viewPosition),
      viewPosition,
      mouseColumn,
      doColumnSelect
    });
  }
  _createCursor(viewPosition, wholeLine) {
    viewPosition = this._validateViewColumn(viewPosition);
    CoreNavigationCommands.CreateCursor.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(viewPosition),
      viewPosition,
      wholeLine
    });
  }
  _lastCursorMoveToSelect(viewPosition) {
    CoreNavigationCommands.LastCursorMoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));
  }
  _wordSelect(viewPosition) {
    CoreNavigationCommands.WordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));
  }
  _wordSelectDrag(viewPosition) {
    CoreNavigationCommands.WordSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));
  }
  _lastCursorWordSelect(viewPosition) {
    CoreNavigationCommands.LastCursorWordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));
  }
  _lineSelect(viewPosition) {
    CoreNavigationCommands.LineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));
  }
  _lineSelectDrag(viewPosition) {
    CoreNavigationCommands.LineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));
  }
  _lastCursorLineSelect(viewPosition) {
    CoreNavigationCommands.LastCursorLineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));
  }
  _lastCursorLineSelectDrag(viewPosition) {
    CoreNavigationCommands.LastCursorLineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(viewPosition));
  }
  _selectAll() {
    CoreNavigationCommands.SelectAll.runCoreEditorCommand(this.viewModel, {source: "mouse"});
  }
  _convertViewToModelPosition(viewPosition) {
    return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(viewPosition);
  }
  emitKeyDown(e) {
    this.userInputEvents.emitKeyDown(e);
  }
  emitKeyUp(e) {
    this.userInputEvents.emitKeyUp(e);
  }
  emitContextMenu(e) {
    this.userInputEvents.emitContextMenu(e);
  }
  emitMouseMove(e) {
    this.userInputEvents.emitMouseMove(e);
  }
  emitMouseLeave(e) {
    this.userInputEvents.emitMouseLeave(e);
  }
  emitMouseUp(e) {
    this.userInputEvents.emitMouseUp(e);
  }
  emitMouseDown(e) {
    this.userInputEvents.emitMouseDown(e);
  }
  emitMouseDrag(e) {
    this.userInputEvents.emitMouseDrag(e);
  }
  emitMouseDrop(e) {
    this.userInputEvents.emitMouseDrop(e);
  }
  emitMouseWheel(e) {
    this.userInputEvents.emitMouseWheel(e);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/view/viewUserInputEvents.js
var ViewUserInputEvents = class {
  constructor(coordinatesConverter) {
    this.onKeyDown = null;
    this.onKeyUp = null;
    this.onContextMenu = null;
    this.onMouseMove = null;
    this.onMouseLeave = null;
    this.onMouseDown = null;
    this.onMouseUp = null;
    this.onMouseDrag = null;
    this.onMouseDrop = null;
    this.onMouseWheel = null;
    this._coordinatesConverter = coordinatesConverter;
  }
  emitKeyDown(e) {
    if (this.onKeyDown) {
      this.onKeyDown(e);
    }
  }
  emitKeyUp(e) {
    if (this.onKeyUp) {
      this.onKeyUp(e);
    }
  }
  emitContextMenu(e) {
    if (this.onContextMenu) {
      this.onContextMenu(this._convertViewToModelMouseEvent(e));
    }
  }
  emitMouseMove(e) {
    if (this.onMouseMove) {
      this.onMouseMove(this._convertViewToModelMouseEvent(e));
    }
  }
  emitMouseLeave(e) {
    if (this.onMouseLeave) {
      this.onMouseLeave(this._convertViewToModelMouseEvent(e));
    }
  }
  emitMouseDown(e) {
    if (this.onMouseDown) {
      this.onMouseDown(this._convertViewToModelMouseEvent(e));
    }
  }
  emitMouseUp(e) {
    if (this.onMouseUp) {
      this.onMouseUp(this._convertViewToModelMouseEvent(e));
    }
  }
  emitMouseDrag(e) {
    if (this.onMouseDrag) {
      this.onMouseDrag(this._convertViewToModelMouseEvent(e));
    }
  }
  emitMouseDrop(e) {
    if (this.onMouseDrop) {
      this.onMouseDrop(this._convertViewToModelMouseEvent(e));
    }
  }
  emitMouseWheel(e) {
    if (this.onMouseWheel) {
      this.onMouseWheel(e);
    }
  }
  _convertViewToModelMouseEvent(e) {
    if (e.target) {
      return {
        event: e.event,
        target: this._convertViewToModelMouseTarget(e.target)
      };
    }
    return e;
  }
  _convertViewToModelMouseTarget(target) {
    return ViewUserInputEvents.convertViewToModelMouseTarget(target, this._coordinatesConverter);
  }
  static convertViewToModelMouseTarget(target, coordinatesConverter) {
    return new ExternalMouseTarget(target.element, target.type, target.mouseColumn, target.position ? coordinatesConverter.convertViewPositionToModelPosition(target.position) : null, target.range ? coordinatesConverter.convertViewRangeToModelRange(target.range) : null, target.detail);
  }
};
var ExternalMouseTarget = class {
  constructor(element, type, mouseColumn, position, range2, detail) {
    this.element = element;
    this.type = type;
    this.mouseColumn = mouseColumn;
    this.position = position;
    this.range = range2;
    this.detail = detail;
  }
  toString() {
    return MouseTarget.toString(this);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/view/viewLayer.js
var RenderedLinesCollection = class {
  constructor(createLine) {
    this._createLine = createLine;
    this._set(1, []);
  }
  flush() {
    this._set(1, []);
  }
  _set(rendLineNumberStart, lines) {
    this._lines = lines;
    this._rendLineNumberStart = rendLineNumberStart;
  }
  _get() {
    return {
      rendLineNumberStart: this._rendLineNumberStart,
      lines: this._lines
    };
  }
  getStartLineNumber() {
    return this._rendLineNumberStart;
  }
  getEndLineNumber() {
    return this._rendLineNumberStart + this._lines.length - 1;
  }
  getCount() {
    return this._lines.length;
  }
  getLine(lineNumber) {
    const lineIndex = lineNumber - this._rendLineNumberStart;
    if (lineIndex < 0 || lineIndex >= this._lines.length) {
      throw new Error("Illegal value for lineNumber");
    }
    return this._lines[lineIndex];
  }
  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {
    if (this.getCount() === 0) {
      return null;
    }
    const startLineNumber = this.getStartLineNumber();
    const endLineNumber = this.getEndLineNumber();
    if (deleteToLineNumber < startLineNumber) {
      const deleteCnt = deleteToLineNumber - deleteFromLineNumber + 1;
      this._rendLineNumberStart -= deleteCnt;
      return null;
    }
    if (deleteFromLineNumber > endLineNumber) {
      return null;
    }
    let deleteStartIndex = 0;
    let deleteCount = 0;
    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      const lineIndex = lineNumber - this._rendLineNumberStart;
      if (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {
        if (deleteCount === 0) {
          deleteStartIndex = lineIndex;
          deleteCount = 1;
        } else {
          deleteCount++;
        }
      }
    }
    if (deleteFromLineNumber < startLineNumber) {
      let deleteAboveCount = 0;
      if (deleteToLineNumber < startLineNumber) {
        deleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;
      } else {
        deleteAboveCount = startLineNumber - deleteFromLineNumber;
      }
      this._rendLineNumberStart -= deleteAboveCount;
    }
    const deleted = this._lines.splice(deleteStartIndex, deleteCount);
    return deleted;
  }
  onLinesChanged(changeFromLineNumber, changeToLineNumber) {
    if (this.getCount() === 0) {
      return false;
    }
    const startLineNumber = this.getStartLineNumber();
    const endLineNumber = this.getEndLineNumber();
    let someoneNotified = false;
    for (let changedLineNumber = changeFromLineNumber; changedLineNumber <= changeToLineNumber; changedLineNumber++) {
      if (changedLineNumber >= startLineNumber && changedLineNumber <= endLineNumber) {
        this._lines[changedLineNumber - this._rendLineNumberStart].onContentChanged();
        someoneNotified = true;
      }
    }
    return someoneNotified;
  }
  onLinesInserted(insertFromLineNumber, insertToLineNumber) {
    if (this.getCount() === 0) {
      return null;
    }
    const insertCnt = insertToLineNumber - insertFromLineNumber + 1;
    const startLineNumber = this.getStartLineNumber();
    const endLineNumber = this.getEndLineNumber();
    if (insertFromLineNumber <= startLineNumber) {
      this._rendLineNumberStart += insertCnt;
      return null;
    }
    if (insertFromLineNumber > endLineNumber) {
      return null;
    }
    if (insertCnt + insertFromLineNumber > endLineNumber) {
      const deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);
      return deleted;
    }
    const newLines = [];
    for (let i = 0; i < insertCnt; i++) {
      newLines[i] = this._createLine();
    }
    const insertIndex = insertFromLineNumber - this._rendLineNumberStart;
    const beforeLines = this._lines.slice(0, insertIndex);
    const afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);
    const deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);
    this._lines = beforeLines.concat(newLines).concat(afterLines);
    return deletedLines;
  }
  onTokensChanged(ranges) {
    if (this.getCount() === 0) {
      return false;
    }
    const startLineNumber = this.getStartLineNumber();
    const endLineNumber = this.getEndLineNumber();
    let notifiedSomeone = false;
    for (let i = 0, len = ranges.length; i < len; i++) {
      const rng = ranges[i];
      if (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {
        continue;
      }
      const from = Math.max(startLineNumber, rng.fromLineNumber);
      const to = Math.min(endLineNumber, rng.toLineNumber);
      for (let lineNumber = from; lineNumber <= to; lineNumber++) {
        const lineIndex = lineNumber - this._rendLineNumberStart;
        this._lines[lineIndex].onTokensChanged();
        notifiedSomeone = true;
      }
    }
    return notifiedSomeone;
  }
};
var VisibleLinesCollection = class {
  constructor(host) {
    this._host = host;
    this.domNode = this._createDomNode();
    this._linesCollection = new RenderedLinesCollection(() => this._host.createVisibleLine());
  }
  _createDomNode() {
    const domNode = createFastDomNode(document.createElement("div"));
    domNode.setClassName("view-layer");
    domNode.setPosition("absolute");
    domNode.domNode.setAttribute("role", "presentation");
    domNode.domNode.setAttribute("aria-hidden", "true");
    return domNode;
  }
  onConfigurationChanged(e) {
    if (e.hasChanged(117)) {
      return true;
    }
    return false;
  }
  onFlushed(e) {
    this._linesCollection.flush();
    return true;
  }
  onLinesChanged(e) {
    return this._linesCollection.onLinesChanged(e.fromLineNumber, e.toLineNumber);
  }
  onLinesDeleted(e) {
    const deleted = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
    if (deleted) {
      for (let i = 0, len = deleted.length; i < len; i++) {
        const lineDomNode = deleted[i].getDomNode();
        if (lineDomNode) {
          this.domNode.domNode.removeChild(lineDomNode);
        }
      }
    }
    return true;
  }
  onLinesInserted(e) {
    const deleted = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);
    if (deleted) {
      for (let i = 0, len = deleted.length; i < len; i++) {
        const lineDomNode = deleted[i].getDomNode();
        if (lineDomNode) {
          this.domNode.domNode.removeChild(lineDomNode);
        }
      }
    }
    return true;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onTokensChanged(e) {
    return this._linesCollection.onTokensChanged(e.ranges);
  }
  onZonesChanged(e) {
    return true;
  }
  getStartLineNumber() {
    return this._linesCollection.getStartLineNumber();
  }
  getEndLineNumber() {
    return this._linesCollection.getEndLineNumber();
  }
  getVisibleLine(lineNumber) {
    return this._linesCollection.getLine(lineNumber);
  }
  renderLines(viewportData) {
    const inp = this._linesCollection._get();
    const renderer = new ViewLayerRenderer(this.domNode.domNode, this._host, viewportData);
    const ctx = {
      rendLineNumberStart: inp.rendLineNumberStart,
      lines: inp.lines,
      linesLength: inp.lines.length
    };
    const resCtx = renderer.render(ctx, viewportData.startLineNumber, viewportData.endLineNumber, viewportData.relativeVerticalOffset);
    this._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);
  }
};
var ViewLayerRenderer = class {
  constructor(domNode, host, viewportData) {
    this.domNode = domNode;
    this.host = host;
    this.viewportData = viewportData;
  }
  render(inContext, startLineNumber, stopLineNumber, deltaTop) {
    const ctx = {
      rendLineNumberStart: inContext.rendLineNumberStart,
      lines: inContext.lines.slice(0),
      linesLength: inContext.linesLength
    };
    if (ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber || stopLineNumber < ctx.rendLineNumberStart) {
      ctx.rendLineNumberStart = startLineNumber;
      ctx.linesLength = stopLineNumber - startLineNumber + 1;
      ctx.lines = [];
      for (let x = startLineNumber; x <= stopLineNumber; x++) {
        ctx.lines[x - startLineNumber] = this.host.createVisibleLine();
      }
      this._finishRendering(ctx, true, deltaTop);
      return ctx;
    }
    this._renderUntouchedLines(ctx, Math.max(startLineNumber - ctx.rendLineNumberStart, 0), Math.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1), deltaTop, startLineNumber);
    if (ctx.rendLineNumberStart > startLineNumber) {
      const fromLineNumber = startLineNumber;
      const toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);
      if (fromLineNumber <= toLineNumber) {
        this._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);
        ctx.linesLength += toLineNumber - fromLineNumber + 1;
      }
    } else if (ctx.rendLineNumberStart < startLineNumber) {
      const removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);
      if (removeCnt > 0) {
        this._removeLinesBefore(ctx, removeCnt);
        ctx.linesLength -= removeCnt;
      }
    }
    ctx.rendLineNumberStart = startLineNumber;
    if (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {
      const fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;
      const toLineNumber = stopLineNumber;
      if (fromLineNumber <= toLineNumber) {
        this._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);
        ctx.linesLength += toLineNumber - fromLineNumber + 1;
      }
    } else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {
      const fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);
      const toLineNumber = ctx.linesLength - 1;
      const removeCnt = toLineNumber - fromLineNumber + 1;
      if (removeCnt > 0) {
        this._removeLinesAfter(ctx, removeCnt);
        ctx.linesLength -= removeCnt;
      }
    }
    this._finishRendering(ctx, false, deltaTop);
    return ctx;
  }
  _renderUntouchedLines(ctx, startIndex, endIndex, deltaTop, deltaLN) {
    const rendLineNumberStart = ctx.rendLineNumberStart;
    const lines = ctx.lines;
    for (let i = startIndex; i <= endIndex; i++) {
      const lineNumber = rendLineNumberStart + i;
      lines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN]);
    }
  }
  _insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {
    const newLines = [];
    let newLinesLen = 0;
    for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
      newLines[newLinesLen++] = this.host.createVisibleLine();
    }
    ctx.lines = newLines.concat(ctx.lines);
  }
  _removeLinesBefore(ctx, removeCount) {
    for (let i = 0; i < removeCount; i++) {
      const lineDomNode = ctx.lines[i].getDomNode();
      if (lineDomNode) {
        this.domNode.removeChild(lineDomNode);
      }
    }
    ctx.lines.splice(0, removeCount);
  }
  _insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {
    const newLines = [];
    let newLinesLen = 0;
    for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
      newLines[newLinesLen++] = this.host.createVisibleLine();
    }
    ctx.lines = ctx.lines.concat(newLines);
  }
  _removeLinesAfter(ctx, removeCount) {
    const removeIndex = ctx.linesLength - removeCount;
    for (let i = 0; i < removeCount; i++) {
      const lineDomNode = ctx.lines[removeIndex + i].getDomNode();
      if (lineDomNode) {
        this.domNode.removeChild(lineDomNode);
      }
    }
    ctx.lines.splice(removeIndex, removeCount);
  }
  _finishRenderingNewLines(ctx, domNodeIsEmpty, newLinesHTML, wasNew) {
    const lastChild = this.domNode.lastChild;
    if (domNodeIsEmpty || !lastChild) {
      this.domNode.innerHTML = newLinesHTML;
    } else {
      lastChild.insertAdjacentHTML("afterend", newLinesHTML);
    }
    let currChild = this.domNode.lastChild;
    for (let i = ctx.linesLength - 1; i >= 0; i--) {
      const line = ctx.lines[i];
      if (wasNew[i]) {
        line.setDomNode(currChild);
        currChild = currChild.previousSibling;
      }
    }
  }
  _finishRenderingInvalidLines(ctx, invalidLinesHTML, wasInvalid) {
    const hugeDomNode = document.createElement("div");
    hugeDomNode.innerHTML = invalidLinesHTML;
    for (let i = 0; i < ctx.linesLength; i++) {
      const line = ctx.lines[i];
      if (wasInvalid[i]) {
        const source = hugeDomNode.firstChild;
        const lineDomNode = line.getDomNode();
        lineDomNode.parentNode.replaceChild(source, lineDomNode);
        line.setDomNode(source);
      }
    }
  }
  _finishRendering(ctx, domNodeIsEmpty, deltaTop) {
    const sb = ViewLayerRenderer._sb;
    const linesLength = ctx.linesLength;
    const lines = ctx.lines;
    const rendLineNumberStart = ctx.rendLineNumberStart;
    const wasNew = [];
    {
      sb.reset();
      let hadNewLine = false;
      for (let i = 0; i < linesLength; i++) {
        const line = lines[i];
        wasNew[i] = false;
        const lineDomNode = line.getDomNode();
        if (lineDomNode) {
          continue;
        }
        const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);
        if (!renderResult) {
          continue;
        }
        wasNew[i] = true;
        hadNewLine = true;
      }
      if (hadNewLine) {
        this._finishRenderingNewLines(ctx, domNodeIsEmpty, sb.build(), wasNew);
      }
    }
    {
      sb.reset();
      let hadInvalidLine = false;
      const wasInvalid = [];
      for (let i = 0; i < linesLength; i++) {
        const line = lines[i];
        wasInvalid[i] = false;
        if (wasNew[i]) {
          continue;
        }
        const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);
        if (!renderResult) {
          continue;
        }
        wasInvalid[i] = true;
        hadInvalidLine = true;
      }
      if (hadInvalidLine) {
        this._finishRenderingInvalidLines(ctx, sb.build(), wasInvalid);
      }
    }
  }
};
ViewLayerRenderer._sb = createStringBuilder(1e5);

// ../../node_modules/monaco-editor/esm/vs/editor/browser/view/viewOverlays.js
var ViewOverlays = class extends ViewPart {
  constructor(context) {
    super(context);
    this._visibleLines = new VisibleLinesCollection(this);
    this.domNode = this._visibleLines.domNode;
    this._dynamicOverlays = [];
    this._isFocused = false;
    this.domNode.setClassName("view-overlays");
  }
  shouldRender() {
    if (super.shouldRender()) {
      return true;
    }
    for (let i = 0, len = this._dynamicOverlays.length; i < len; i++) {
      const dynamicOverlay = this._dynamicOverlays[i];
      if (dynamicOverlay.shouldRender()) {
        return true;
      }
    }
    return false;
  }
  dispose() {
    super.dispose();
    for (let i = 0, len = this._dynamicOverlays.length; i < len; i++) {
      const dynamicOverlay = this._dynamicOverlays[i];
      dynamicOverlay.dispose();
    }
    this._dynamicOverlays = [];
  }
  getDomNode() {
    return this.domNode;
  }
  createVisibleLine() {
    return new ViewOverlayLine(this._context.configuration, this._dynamicOverlays);
  }
  addDynamicOverlay(overlay) {
    this._dynamicOverlays.push(overlay);
  }
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e);
    const startLineNumber = this._visibleLines.getStartLineNumber();
    const endLineNumber = this._visibleLines.getEndLineNumber();
    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      const line = this._visibleLines.getVisibleLine(lineNumber);
      line.onConfigurationChanged(e);
    }
    return true;
  }
  onFlushed(e) {
    return this._visibleLines.onFlushed(e);
  }
  onFocusChanged(e) {
    this._isFocused = e.isFocused;
    return true;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onScrollChanged(e) {
    return this._visibleLines.onScrollChanged(e) || true;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._visibleLines.onZonesChanged(e);
  }
  prepareRender(ctx) {
    const toRender = this._dynamicOverlays.filter((overlay) => overlay.shouldRender());
    for (let i = 0, len = toRender.length; i < len; i++) {
      const dynamicOverlay = toRender[i];
      dynamicOverlay.prepareRender(ctx);
      dynamicOverlay.onDidRender();
    }
  }
  render(ctx) {
    this._viewOverlaysRender(ctx);
    this.domNode.toggleClassName("focused", this._isFocused);
  }
  _viewOverlaysRender(ctx) {
    this._visibleLines.renderLines(ctx.viewportData);
  }
};
var ViewOverlayLine = class {
  constructor(configuration, dynamicOverlays) {
    this._configuration = configuration;
    this._lineHeight = this._configuration.options.get(51);
    this._dynamicOverlays = dynamicOverlays;
    this._domNode = null;
    this._renderedContent = null;
  }
  getDomNode() {
    if (!this._domNode) {
      return null;
    }
    return this._domNode.domNode;
  }
  setDomNode(domNode) {
    this._domNode = createFastDomNode(domNode);
  }
  onContentChanged() {
  }
  onTokensChanged() {
  }
  onConfigurationChanged(e) {
    this._lineHeight = this._configuration.options.get(51);
  }
  renderLine(lineNumber, deltaTop, viewportData, sb) {
    let result = "";
    for (let i = 0, len = this._dynamicOverlays.length; i < len; i++) {
      const dynamicOverlay = this._dynamicOverlays[i];
      result += dynamicOverlay.render(viewportData.startLineNumber, lineNumber);
    }
    if (this._renderedContent === result) {
      return false;
    }
    this._renderedContent = result;
    sb.appendASCIIString('<div style="position:absolute;top:');
    sb.appendASCIIString(String(deltaTop));
    sb.appendASCIIString("px;width:100%;height:");
    sb.appendASCIIString(String(this._lineHeight));
    sb.appendASCIIString('px;">');
    sb.appendASCIIString(result);
    sb.appendASCIIString("</div>");
    return true;
  }
  layoutLine(lineNumber, deltaTop) {
    if (this._domNode) {
      this._domNode.setTop(deltaTop);
      this._domNode.setHeight(this._lineHeight);
    }
  }
};
var ContentViewOverlays = class extends ViewOverlays {
  constructor(context) {
    super(context);
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._contentWidth = layoutInfo.contentWidth;
    this.domNode.setHeight(0);
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._contentWidth = layoutInfo.contentWidth;
    return super.onConfigurationChanged(e) || true;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollWidthChanged;
  }
  _viewOverlaysRender(ctx) {
    super._viewOverlaysRender(ctx);
    this.domNode.setWidth(Math.max(ctx.scrollWidth, this._contentWidth));
  }
};
var MarginViewOverlays = class extends ViewOverlays {
  constructor(context) {
    super(context);
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._contentLeft = layoutInfo.contentLeft;
    this.domNode.setClassName("margin-view-overlays");
    this.domNode.setWidth(1);
    Configuration2.applyFontInfo(this.domNode, options.get(36));
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    Configuration2.applyFontInfo(this.domNode, options.get(36));
    const layoutInfo = options.get(117);
    this._contentLeft = layoutInfo.contentLeft;
    return super.onConfigurationChanged(e) || true;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollHeightChanged;
  }
  _viewOverlaysRender(ctx) {
    super._viewOverlaysRender(ctx);
    const height = Math.min(ctx.scrollHeight, 1e6);
    this.domNode.setHeight(height);
    this.domNode.setWidth(this._contentLeft);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/contentWidgets/contentWidgets.js
var Coordinate = class {
  constructor(top, left) {
    this.top = top;
    this.left = left;
  }
};
var ViewContentWidgets = class extends ViewPart {
  constructor(context, viewDomNode) {
    super(context);
    this._viewDomNode = viewDomNode;
    this._widgets = {};
    this.domNode = createFastDomNode(document.createElement("div"));
    PartFingerprints.write(this.domNode, 1);
    this.domNode.setClassName("contentWidgets");
    this.domNode.setPosition("absolute");
    this.domNode.setTop(0);
    this.overflowingContentWidgetsDomNode = createFastDomNode(document.createElement("div"));
    PartFingerprints.write(this.overflowingContentWidgetsDomNode, 2);
    this.overflowingContentWidgetsDomNode.setClassName("overflowingContentWidgets");
  }
  dispose() {
    super.dispose();
    this._widgets = {};
  }
  onConfigurationChanged(e) {
    const keys = Object.keys(this._widgets);
    for (const widgetId of keys) {
      this._widgets[widgetId].onConfigurationChanged(e);
    }
    return true;
  }
  onDecorationsChanged(e) {
    return true;
  }
  onFlushed(e) {
    return true;
  }
  onLineMappingChanged(e) {
    const keys = Object.keys(this._widgets);
    for (const widgetId of keys) {
      this._widgets[widgetId].onLineMappingChanged(e);
    }
    return true;
  }
  onLinesChanged(e) {
    return true;
  }
  onLinesDeleted(e) {
    return true;
  }
  onLinesInserted(e) {
    return true;
  }
  onScrollChanged(e) {
    return true;
  }
  onZonesChanged(e) {
    return true;
  }
  addWidget(_widget) {
    const myWidget = new Widget(this._context, this._viewDomNode, _widget);
    this._widgets[myWidget.id] = myWidget;
    if (myWidget.allowEditorOverflow) {
      this.overflowingContentWidgetsDomNode.appendChild(myWidget.domNode);
    } else {
      this.domNode.appendChild(myWidget.domNode);
    }
    this.setShouldRender();
  }
  setWidgetPosition(widget, range2, preference) {
    const myWidget = this._widgets[widget.getId()];
    myWidget.setPosition(range2, preference);
    this.setShouldRender();
  }
  removeWidget(widget) {
    const widgetId = widget.getId();
    if (this._widgets.hasOwnProperty(widgetId)) {
      const myWidget = this._widgets[widgetId];
      delete this._widgets[widgetId];
      const domNode = myWidget.domNode.domNode;
      domNode.parentNode.removeChild(domNode);
      domNode.removeAttribute("monaco-visible-content-widget");
      this.setShouldRender();
    }
  }
  shouldSuppressMouseDownOnWidget(widgetId) {
    if (this._widgets.hasOwnProperty(widgetId)) {
      return this._widgets[widgetId].suppressMouseDown;
    }
    return false;
  }
  onBeforeRender(viewportData) {
    const keys = Object.keys(this._widgets);
    for (const widgetId of keys) {
      this._widgets[widgetId].onBeforeRender(viewportData);
    }
  }
  prepareRender(ctx) {
    const keys = Object.keys(this._widgets);
    for (const widgetId of keys) {
      this._widgets[widgetId].prepareRender(ctx);
    }
  }
  render(ctx) {
    const keys = Object.keys(this._widgets);
    for (const widgetId of keys) {
      this._widgets[widgetId].render(ctx);
    }
  }
};
var Widget = class {
  constructor(context, viewDomNode, actual) {
    this._context = context;
    this._viewDomNode = viewDomNode;
    this._actual = actual;
    this.domNode = createFastDomNode(this._actual.getDomNode());
    this.id = this._actual.getId();
    this.allowEditorOverflow = this._actual.allowEditorOverflow || false;
    this.suppressMouseDown = this._actual.suppressMouseDown || false;
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._fixedOverflowWidgets = options.get(30);
    this._contentWidth = layoutInfo.contentWidth;
    this._contentLeft = layoutInfo.contentLeft;
    this._lineHeight = options.get(51);
    this._range = null;
    this._viewRange = null;
    this._preference = [];
    this._cachedDomNodeClientWidth = -1;
    this._cachedDomNodeClientHeight = -1;
    this._maxWidth = this._getMaxWidth();
    this._isVisible = false;
    this._renderData = null;
    this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? "fixed" : "absolute");
    this.domNode.setVisibility("hidden");
    this.domNode.setAttribute("widgetId", this.id);
    this.domNode.setMaxWidth(this._maxWidth);
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    this._lineHeight = options.get(51);
    if (e.hasChanged(117)) {
      const layoutInfo = options.get(117);
      this._contentLeft = layoutInfo.contentLeft;
      this._contentWidth = layoutInfo.contentWidth;
      this._maxWidth = this._getMaxWidth();
    }
  }
  onLineMappingChanged(e) {
    this._setPosition(this._range);
  }
  _setPosition(range2) {
    this._range = range2;
    this._viewRange = null;
    if (this._range) {
      const validModelRange = this._context.model.validateModelRange(this._range);
      if (this._context.model.coordinatesConverter.modelPositionIsVisible(validModelRange.getStartPosition()) || this._context.model.coordinatesConverter.modelPositionIsVisible(validModelRange.getEndPosition())) {
        this._viewRange = this._context.model.coordinatesConverter.convertModelRangeToViewRange(validModelRange);
      }
    }
  }
  _getMaxWidth() {
    return this.allowEditorOverflow ? window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth : this._contentWidth;
  }
  setPosition(range2, preference) {
    this._setPosition(range2);
    this._preference = preference;
    this._cachedDomNodeClientWidth = -1;
    this._cachedDomNodeClientHeight = -1;
  }
  _layoutBoxInViewport(topLeft, bottomLeft, width, height, ctx) {
    const aboveLineTop = topLeft.top;
    const heightAboveLine = aboveLineTop;
    const underLineTop = bottomLeft.top + this._lineHeight;
    const heightUnderLine = ctx.viewportHeight - underLineTop;
    const aboveTop = aboveLineTop - height;
    const fitsAbove = heightAboveLine >= height;
    const belowTop = underLineTop;
    const fitsBelow = heightUnderLine >= height;
    let actualAboveLeft = topLeft.left;
    let actualBelowLeft = bottomLeft.left;
    if (actualAboveLeft + width > ctx.scrollLeft + ctx.viewportWidth) {
      actualAboveLeft = ctx.scrollLeft + ctx.viewportWidth - width;
    }
    if (actualBelowLeft + width > ctx.scrollLeft + ctx.viewportWidth) {
      actualBelowLeft = ctx.scrollLeft + ctx.viewportWidth - width;
    }
    if (actualAboveLeft < ctx.scrollLeft) {
      actualAboveLeft = ctx.scrollLeft;
    }
    if (actualBelowLeft < ctx.scrollLeft) {
      actualBelowLeft = ctx.scrollLeft;
    }
    return {
      fitsAbove,
      aboveTop,
      aboveLeft: actualAboveLeft,
      fitsBelow,
      belowTop,
      belowLeft: actualBelowLeft
    };
  }
  _layoutHorizontalSegmentInPage(windowSize, domNodePosition, left, width) {
    const MIN_LIMIT = Math.max(0, domNodePosition.left - width);
    const MAX_LIMIT = Math.min(domNodePosition.left + domNodePosition.width + width, windowSize.width);
    let absoluteLeft = domNodePosition.left + left - StandardWindow.scrollX;
    if (absoluteLeft + width > MAX_LIMIT) {
      const delta = absoluteLeft - (MAX_LIMIT - width);
      absoluteLeft -= delta;
      left -= delta;
    }
    if (absoluteLeft < MIN_LIMIT) {
      const delta = absoluteLeft - MIN_LIMIT;
      absoluteLeft -= delta;
      left -= delta;
    }
    return [left, absoluteLeft];
  }
  _layoutBoxInPage(topLeft, bottomLeft, width, height, ctx) {
    const aboveTop = topLeft.top - height;
    const belowTop = bottomLeft.top + this._lineHeight;
    const domNodePosition = getDomNodePagePosition(this._viewDomNode.domNode);
    const absoluteAboveTop = domNodePosition.top + aboveTop - StandardWindow.scrollY;
    const absoluteBelowTop = domNodePosition.top + belowTop - StandardWindow.scrollY;
    const windowSize = getClientArea(document.body);
    const [aboveLeft, absoluteAboveLeft] = this._layoutHorizontalSegmentInPage(windowSize, domNodePosition, topLeft.left - ctx.scrollLeft + this._contentLeft, width);
    const [belowLeft, absoluteBelowLeft] = this._layoutHorizontalSegmentInPage(windowSize, domNodePosition, bottomLeft.left - ctx.scrollLeft + this._contentLeft, width);
    const TOP_PADDING = 22;
    const BOTTOM_PADDING = 22;
    const fitsAbove = absoluteAboveTop >= TOP_PADDING;
    const fitsBelow = absoluteBelowTop + height <= windowSize.height - BOTTOM_PADDING;
    if (this._fixedOverflowWidgets) {
      return {
        fitsAbove,
        aboveTop: Math.max(absoluteAboveTop, TOP_PADDING),
        aboveLeft: absoluteAboveLeft,
        fitsBelow,
        belowTop: absoluteBelowTop,
        belowLeft: absoluteBelowLeft
      };
    }
    return {
      fitsAbove,
      aboveTop,
      aboveLeft,
      fitsBelow,
      belowTop,
      belowLeft
    };
  }
  _prepareRenderWidgetAtExactPositionOverflowing(topLeft) {
    return new Coordinate(topLeft.top, topLeft.left + this._contentLeft);
  }
  _getTopAndBottomLeft(ctx) {
    if (!this._viewRange) {
      return [null, null];
    }
    const visibleRangesForRange = ctx.linesVisibleRangesForRange(this._viewRange, false);
    if (!visibleRangesForRange || visibleRangesForRange.length === 0) {
      return [null, null];
    }
    let firstLine = visibleRangesForRange[0];
    let lastLine = visibleRangesForRange[0];
    for (const visibleRangesForLine of visibleRangesForRange) {
      if (visibleRangesForLine.lineNumber < firstLine.lineNumber) {
        firstLine = visibleRangesForLine;
      }
      if (visibleRangesForLine.lineNumber > lastLine.lineNumber) {
        lastLine = visibleRangesForLine;
      }
    }
    let firstLineMinLeft = 1073741824;
    for (const visibleRange of firstLine.ranges) {
      if (visibleRange.left < firstLineMinLeft) {
        firstLineMinLeft = visibleRange.left;
      }
    }
    let lastLineMinLeft = 1073741824;
    for (const visibleRange of lastLine.ranges) {
      if (visibleRange.left < lastLineMinLeft) {
        lastLineMinLeft = visibleRange.left;
      }
    }
    const topForPosition = ctx.getVerticalOffsetForLineNumber(firstLine.lineNumber) - ctx.scrollTop;
    const topLeft = new Coordinate(topForPosition, firstLineMinLeft);
    const topForBottomLine = ctx.getVerticalOffsetForLineNumber(lastLine.lineNumber) - ctx.scrollTop;
    const bottomLeft = new Coordinate(topForBottomLine, lastLineMinLeft);
    return [topLeft, bottomLeft];
  }
  _prepareRenderWidget(ctx) {
    const [topLeft, bottomLeft] = this._getTopAndBottomLeft(ctx);
    if (!topLeft || !bottomLeft) {
      return null;
    }
    if (this._cachedDomNodeClientWidth === -1 || this._cachedDomNodeClientHeight === -1) {
      const domNode = this.domNode.domNode;
      this._cachedDomNodeClientWidth = domNode.clientWidth;
      this._cachedDomNodeClientHeight = domNode.clientHeight;
    }
    let placement;
    if (this.allowEditorOverflow) {
      placement = this._layoutBoxInPage(topLeft, bottomLeft, this._cachedDomNodeClientWidth, this._cachedDomNodeClientHeight, ctx);
    } else {
      placement = this._layoutBoxInViewport(topLeft, bottomLeft, this._cachedDomNodeClientWidth, this._cachedDomNodeClientHeight, ctx);
    }
    if (this._preference) {
      for (let pass = 1; pass <= 2; pass++) {
        for (const pref of this._preference) {
          if (pref === 1) {
            if (!placement) {
              return null;
            }
            if (pass === 2 || placement.fitsAbove) {
              return new Coordinate(placement.aboveTop, placement.aboveLeft);
            }
          } else if (pref === 2) {
            if (!placement) {
              return null;
            }
            if (pass === 2 || placement.fitsBelow) {
              return new Coordinate(placement.belowTop, placement.belowLeft);
            }
          } else {
            if (this.allowEditorOverflow) {
              return this._prepareRenderWidgetAtExactPositionOverflowing(topLeft);
            } else {
              return topLeft;
            }
          }
        }
      }
    }
    return null;
  }
  onBeforeRender(viewportData) {
    if (!this._viewRange || !this._preference) {
      return;
    }
    if (this._viewRange.endLineNumber < viewportData.startLineNumber || this._viewRange.startLineNumber > viewportData.endLineNumber) {
      return;
    }
    this.domNode.setMaxWidth(this._maxWidth);
  }
  prepareRender(ctx) {
    this._renderData = this._prepareRenderWidget(ctx);
  }
  render(ctx) {
    if (!this._renderData) {
      if (this._isVisible) {
        this.domNode.removeAttribute("monaco-visible-content-widget");
        this._isVisible = false;
        this.domNode.setVisibility("hidden");
      }
      return;
    }
    if (this.allowEditorOverflow) {
      this.domNode.setTop(this._renderData.top);
      this.domNode.setLeft(this._renderData.left);
    } else {
      this.domNode.setTop(this._renderData.top + ctx.scrollTop - ctx.bigNumbersDelta);
      this.domNode.setLeft(this._renderData.left);
    }
    if (!this._isVisible) {
      this.domNode.setVisibility("inherit");
      this.domNode.setAttribute("monaco-visible-content-widget", "true");
      this._isVisible = true;
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight.js
var isRenderedUsingBorder = true;
var AbstractLineHighlightOverlay = class extends DynamicViewOverlay {
  constructor(context) {
    super();
    this._context = context;
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._lineHeight = options.get(51);
    this._renderLineHighlight = options.get(77);
    this._renderLineHightlightOnlyWhenFocus = options.get(78);
    this._contentLeft = layoutInfo.contentLeft;
    this._contentWidth = layoutInfo.contentWidth;
    this._selectionIsEmpty = true;
    this._focused = false;
    this._cursorLineNumbers = [];
    this._selections = [];
    this._renderData = null;
    this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this);
    super.dispose();
  }
  _readFromSelections() {
    let hasChanged = false;
    const renderSelections = isRenderedUsingBorder ? this._selections.slice(0, 1) : this._selections;
    const cursorsLineNumbers = renderSelections.map((s) => s.positionLineNumber);
    cursorsLineNumbers.sort((a, b) => a - b);
    if (!equals(this._cursorLineNumbers, cursorsLineNumbers)) {
      this._cursorLineNumbers = cursorsLineNumbers;
      hasChanged = true;
    }
    const selectionIsEmpty = renderSelections.every((s) => s.isEmpty());
    if (this._selectionIsEmpty !== selectionIsEmpty) {
      this._selectionIsEmpty = selectionIsEmpty;
      hasChanged = true;
    }
    return hasChanged;
  }
  onThemeChanged(e) {
    return this._readFromSelections();
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._lineHeight = options.get(51);
    this._renderLineHighlight = options.get(77);
    this._renderLineHightlightOnlyWhenFocus = options.get(78);
    this._contentLeft = layoutInfo.contentLeft;
    this._contentWidth = layoutInfo.contentWidth;
    return true;
  }
  onCursorStateChanged(e) {
    this._selections = e.selections;
    return this._readFromSelections();
  }
  onFlushed(e) {
    return true;
  }
  onLinesDeleted(e) {
    return true;
  }
  onLinesInserted(e) {
    return true;
  }
  onScrollChanged(e) {
    return e.scrollWidthChanged || e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return true;
  }
  onFocusChanged(e) {
    if (!this._renderLineHightlightOnlyWhenFocus) {
      return false;
    }
    this._focused = e.isFocused;
    return true;
  }
  prepareRender(ctx) {
    if (!this._shouldRenderThis()) {
      this._renderData = null;
      return;
    }
    const renderedLine = this._renderOne(ctx);
    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;
    const visibleEndLineNumber = ctx.visibleRange.endLineNumber;
    const len = this._cursorLineNumbers.length;
    let index = 0;
    const renderData = [];
    for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
      const lineIndex = lineNumber - visibleStartLineNumber;
      while (index < len && this._cursorLineNumbers[index] < lineNumber) {
        index++;
      }
      if (index < len && this._cursorLineNumbers[index] === lineNumber) {
        renderData[lineIndex] = renderedLine;
      } else {
        renderData[lineIndex] = "";
      }
    }
    this._renderData = renderData;
  }
  render(startLineNumber, lineNumber) {
    if (!this._renderData) {
      return "";
    }
    const lineIndex = lineNumber - startLineNumber;
    if (lineIndex >= this._renderData.length) {
      return "";
    }
    return this._renderData[lineIndex];
  }
};
var CurrentLineHighlightOverlay = class extends AbstractLineHighlightOverlay {
  _renderOne(ctx) {
    const className = "current-line" + (this._shouldRenderOther() ? " current-line-both" : "");
    return `<div class="${className}" style="width:${Math.max(ctx.scrollWidth, this._contentWidth)}px; height:${this._lineHeight}px;"></div>`;
  }
  _shouldRenderThis() {
    return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHightlightOnlyWhenFocus || this._focused);
  }
  _shouldRenderOther() {
    return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHightlightOnlyWhenFocus || this._focused);
  }
};
var CurrentLineMarginHighlightOverlay = class extends AbstractLineHighlightOverlay {
  _renderOne(ctx) {
    const className = "current-line current-line-margin" + (this._shouldRenderOther() ? " current-line-margin-both" : "");
    return `<div class="${className}" style="width:${this._contentLeft}px; height:${this._lineHeight}px;"></div>`;
  }
  _shouldRenderThis() {
    return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHightlightOnlyWhenFocus || this._focused);
  }
  _shouldRenderOther() {
    return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHightlightOnlyWhenFocus || this._focused);
  }
};
registerThemingParticipant((theme, collector) => {
  isRenderedUsingBorder = false;
  const lineHighlight = theme.getColor(editorLineHighlight);
  if (lineHighlight) {
    collector.addRule(`.monaco-editor .view-overlays .current-line { background-color: ${lineHighlight}; }`);
    collector.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { background-color: ${lineHighlight}; border: none; }`);
  }
  if (!lineHighlight || lineHighlight.isTransparent() || theme.defines(editorLineHighlightBorder)) {
    const lineHighlightBorder = theme.getColor(editorLineHighlightBorder);
    if (lineHighlightBorder) {
      isRenderedUsingBorder = true;
      collector.addRule(`.monaco-editor .view-overlays .current-line { border: 2px solid ${lineHighlightBorder}; }`);
      collector.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { border: 2px solid ${lineHighlightBorder}; }`);
      if (theme.type === "hc") {
        collector.addRule(`.monaco-editor .view-overlays .current-line { border-width: 1px; }`);
        collector.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { border-width: 1px; }`);
      }
    }
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/decorations/decorations.js
var DecorationsOverlay = class extends DynamicViewOverlay {
  constructor(context) {
    super();
    this._context = context;
    const options = this._context.configuration.options;
    this._lineHeight = options.get(51);
    this._typicalHalfwidthCharacterWidth = options.get(36).typicalHalfwidthCharacterWidth;
    this._renderResult = null;
    this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this);
    this._renderResult = null;
    super.dispose();
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    this._lineHeight = options.get(51);
    this._typicalHalfwidthCharacterWidth = options.get(36).typicalHalfwidthCharacterWidth;
    return true;
  }
  onDecorationsChanged(e) {
    return true;
  }
  onFlushed(e) {
    return true;
  }
  onLinesChanged(e) {
    return true;
  }
  onLinesDeleted(e) {
    return true;
  }
  onLinesInserted(e) {
    return true;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return true;
  }
  prepareRender(ctx) {
    const _decorations = ctx.getDecorationsInViewport();
    let decorations = [], decorationsLen = 0;
    for (let i = 0, len = _decorations.length; i < len; i++) {
      const d = _decorations[i];
      if (d.options.className) {
        decorations[decorationsLen++] = d;
      }
    }
    decorations = decorations.sort((a, b) => {
      if (a.options.zIndex < b.options.zIndex) {
        return -1;
      }
      if (a.options.zIndex > b.options.zIndex) {
        return 1;
      }
      const aClassName = a.options.className;
      const bClassName = b.options.className;
      if (aClassName < bClassName) {
        return -1;
      }
      if (aClassName > bClassName) {
        return 1;
      }
      return Range.compareRangesUsingStarts(a.range, b.range);
    });
    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;
    const visibleEndLineNumber = ctx.visibleRange.endLineNumber;
    const output = [];
    for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
      const lineIndex = lineNumber - visibleStartLineNumber;
      output[lineIndex] = "";
    }
    this._renderWholeLineDecorations(ctx, decorations, output);
    this._renderNormalDecorations(ctx, decorations, output);
    this._renderResult = output;
  }
  _renderWholeLineDecorations(ctx, decorations, output) {
    const lineHeight = String(this._lineHeight);
    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;
    const visibleEndLineNumber = ctx.visibleRange.endLineNumber;
    for (let i = 0, lenI = decorations.length; i < lenI; i++) {
      const d = decorations[i];
      if (!d.options.isWholeLine) {
        continue;
      }
      const decorationOutput = '<div class="cdr ' + d.options.className + '" style="left:0;width:100%;height:' + lineHeight + 'px;"></div>';
      const startLineNumber = Math.max(d.range.startLineNumber, visibleStartLineNumber);
      const endLineNumber = Math.min(d.range.endLineNumber, visibleEndLineNumber);
      for (let j = startLineNumber; j <= endLineNumber; j++) {
        const lineIndex = j - visibleStartLineNumber;
        output[lineIndex] += decorationOutput;
      }
    }
  }
  _renderNormalDecorations(ctx, decorations, output) {
    const lineHeight = String(this._lineHeight);
    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;
    let prevClassName = null;
    let prevShowIfCollapsed = false;
    let prevRange = null;
    for (let i = 0, lenI = decorations.length; i < lenI; i++) {
      const d = decorations[i];
      if (d.options.isWholeLine) {
        continue;
      }
      const className = d.options.className;
      const showIfCollapsed = Boolean(d.options.showIfCollapsed);
      let range2 = d.range;
      if (showIfCollapsed && range2.endColumn === 1 && range2.endLineNumber !== range2.startLineNumber) {
        range2 = new Range(range2.startLineNumber, range2.startColumn, range2.endLineNumber - 1, this._context.model.getLineMaxColumn(range2.endLineNumber - 1));
      }
      if (prevClassName === className && prevShowIfCollapsed === showIfCollapsed && Range.areIntersectingOrTouching(prevRange, range2)) {
        prevRange = Range.plusRange(prevRange, range2);
        continue;
      }
      if (prevClassName !== null) {
        this._renderNormalDecoration(ctx, prevRange, prevClassName, prevShowIfCollapsed, lineHeight, visibleStartLineNumber, output);
      }
      prevClassName = className;
      prevShowIfCollapsed = showIfCollapsed;
      prevRange = range2;
    }
    if (prevClassName !== null) {
      this._renderNormalDecoration(ctx, prevRange, prevClassName, prevShowIfCollapsed, lineHeight, visibleStartLineNumber, output);
    }
  }
  _renderNormalDecoration(ctx, range2, className, showIfCollapsed, lineHeight, visibleStartLineNumber, output) {
    const linesVisibleRanges = ctx.linesVisibleRangesForRange(range2, className === "findMatch");
    if (!linesVisibleRanges) {
      return;
    }
    for (let j = 0, lenJ = linesVisibleRanges.length; j < lenJ; j++) {
      const lineVisibleRanges = linesVisibleRanges[j];
      if (lineVisibleRanges.outsideRenderedLine) {
        continue;
      }
      const lineIndex = lineVisibleRanges.lineNumber - visibleStartLineNumber;
      if (showIfCollapsed && lineVisibleRanges.ranges.length === 1) {
        const singleVisibleRange = lineVisibleRanges.ranges[0];
        if (singleVisibleRange.width === 0) {
          lineVisibleRanges.ranges[0] = new HorizontalRange(singleVisibleRange.left, this._typicalHalfwidthCharacterWidth);
        }
      }
      for (let k = 0, lenK = lineVisibleRanges.ranges.length; k < lenK; k++) {
        const visibleRange = lineVisibleRanges.ranges[k];
        const decorationOutput = '<div class="cdr ' + className + '" style="left:' + String(visibleRange.left) + "px;width:" + String(visibleRange.width) + "px;height:" + lineHeight + 'px;"></div>';
        output[lineIndex] += decorationOutput;
      }
    }
  }
  render(startLineNumber, lineNumber) {
    if (!this._renderResult) {
      return "";
    }
    const lineIndex = lineNumber - startLineNumber;
    if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
      return "";
    }
    return this._renderResult[lineIndex];
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/widget.js
var Widget2 = class extends Disposable {
  onclick(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.CLICK, (e) => listener(new StandardMouseEvent(e))));
  }
  onmousedown(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.MOUSE_DOWN, (e) => listener(new StandardMouseEvent(e))));
  }
  onmouseover(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.MOUSE_OVER, (e) => listener(new StandardMouseEvent(e))));
  }
  onnonbubblingmouseout(domNode, listener) {
    this._register(addDisposableNonBubblingMouseOutListener(domNode, (e) => listener(new StandardMouseEvent(e))));
  }
  onkeydown(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.KEY_DOWN, (e) => listener(new StandardKeyboardEvent(e))));
  }
  onkeyup(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.KEY_UP, (e) => listener(new StandardKeyboardEvent(e))));
  }
  oninput(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.INPUT, listener));
  }
  onblur(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.BLUR, listener));
  }
  onfocus(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.FOCUS, listener));
  }
  ignoreGesture(domNode) {
    Gesture.ignoreTarget(domNode);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarArrow.js
var ARROW_IMG_SIZE = 11;
var ScrollbarArrow = class extends Widget2 {
  constructor(opts) {
    super();
    this._onActivate = opts.onActivate;
    this.bgDomNode = document.createElement("div");
    this.bgDomNode.className = "arrow-background";
    this.bgDomNode.style.position = "absolute";
    this.bgDomNode.style.width = opts.bgWidth + "px";
    this.bgDomNode.style.height = opts.bgHeight + "px";
    if (typeof opts.top !== "undefined") {
      this.bgDomNode.style.top = "0px";
    }
    if (typeof opts.left !== "undefined") {
      this.bgDomNode.style.left = "0px";
    }
    if (typeof opts.bottom !== "undefined") {
      this.bgDomNode.style.bottom = "0px";
    }
    if (typeof opts.right !== "undefined") {
      this.bgDomNode.style.right = "0px";
    }
    this.domNode = document.createElement("div");
    this.domNode.className = opts.className;
    addClasses(this.domNode, opts.icon.classNames);
    this.domNode.style.position = "absolute";
    this.domNode.style.width = ARROW_IMG_SIZE + "px";
    this.domNode.style.height = ARROW_IMG_SIZE + "px";
    if (typeof opts.top !== "undefined") {
      this.domNode.style.top = opts.top + "px";
    }
    if (typeof opts.left !== "undefined") {
      this.domNode.style.left = opts.left + "px";
    }
    if (typeof opts.bottom !== "undefined") {
      this.domNode.style.bottom = opts.bottom + "px";
    }
    if (typeof opts.right !== "undefined") {
      this.domNode.style.right = opts.right + "px";
    }
    this._mouseMoveMonitor = this._register(new GlobalMouseMoveMonitor());
    this.onmousedown(this.bgDomNode, (e) => this._arrowMouseDown(e));
    this.onmousedown(this.domNode, (e) => this._arrowMouseDown(e));
    this._mousedownRepeatTimer = this._register(new IntervalTimer());
    this._mousedownScheduleRepeatTimer = this._register(new TimeoutTimer());
  }
  _arrowMouseDown(e) {
    let scheduleRepeater = () => {
      this._mousedownRepeatTimer.cancelAndSet(() => this._onActivate(), 1e3 / 24);
    };
    this._onActivate();
    this._mousedownRepeatTimer.cancel();
    this._mousedownScheduleRepeatTimer.cancelAndSet(scheduleRepeater, 200);
    this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, (mouseMoveData) => {
    }, () => {
      this._mousedownRepeatTimer.cancel();
      this._mousedownScheduleRepeatTimer.cancel();
    });
    e.preventDefault();
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarVisibilityController.js
var ScrollbarVisibilityController = class extends Disposable {
  constructor(visibility, visibleClassName, invisibleClassName) {
    super();
    this._visibility = visibility;
    this._visibleClassName = visibleClassName;
    this._invisibleClassName = invisibleClassName;
    this._domNode = null;
    this._isVisible = false;
    this._isNeeded = false;
    this._shouldBeVisible = false;
    this._revealTimer = this._register(new TimeoutTimer());
  }
  applyVisibilitySetting(shouldBeVisible) {
    if (this._visibility === 2) {
      return false;
    }
    if (this._visibility === 3) {
      return true;
    }
    return shouldBeVisible;
  }
  setShouldBeVisible(rawShouldBeVisible) {
    let shouldBeVisible = this.applyVisibilitySetting(rawShouldBeVisible);
    if (this._shouldBeVisible !== shouldBeVisible) {
      this._shouldBeVisible = shouldBeVisible;
      this.ensureVisibility();
    }
  }
  setIsNeeded(isNeeded) {
    if (this._isNeeded !== isNeeded) {
      this._isNeeded = isNeeded;
      this.ensureVisibility();
    }
  }
  setDomNode(domNode) {
    this._domNode = domNode;
    this._domNode.setClassName(this._invisibleClassName);
    this.setShouldBeVisible(false);
  }
  ensureVisibility() {
    if (!this._isNeeded) {
      this._hide(false);
      return;
    }
    if (this._shouldBeVisible) {
      this._reveal();
    } else {
      this._hide(true);
    }
  }
  _reveal() {
    if (this._isVisible) {
      return;
    }
    this._isVisible = true;
    this._revealTimer.setIfNotSet(() => {
      if (this._domNode) {
        this._domNode.setClassName(this._visibleClassName);
      }
    }, 0);
  }
  _hide(withFadeAway) {
    this._revealTimer.cancel();
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    if (this._domNode) {
      this._domNode.setClassName(this._invisibleClassName + (withFadeAway ? " fade" : ""));
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/abstractScrollbar.js
var MOUSE_DRAG_RESET_DISTANCE = 140;
var AbstractScrollbar = class extends Widget2 {
  constructor(opts) {
    super();
    this._lazyRender = opts.lazyRender;
    this._host = opts.host;
    this._scrollable = opts.scrollable;
    this._scrollbarState = opts.scrollbarState;
    this._visibilityController = this._register(new ScrollbarVisibilityController(opts.visibility, "visible scrollbar " + opts.extraScrollbarClassName, "invisible scrollbar " + opts.extraScrollbarClassName));
    this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
    this._mouseMoveMonitor = this._register(new GlobalMouseMoveMonitor());
    this._shouldRender = true;
    this.domNode = createFastDomNode(document.createElement("div"));
    this.domNode.setAttribute("role", "presentation");
    this.domNode.setAttribute("aria-hidden", "true");
    this._visibilityController.setDomNode(this.domNode);
    this.domNode.setPosition("absolute");
    this.onmousedown(this.domNode.domNode, (e) => this._domNodeMouseDown(e));
  }
  _createArrow(opts) {
    let arrow = this._register(new ScrollbarArrow(opts));
    this.domNode.domNode.appendChild(arrow.bgDomNode);
    this.domNode.domNode.appendChild(arrow.domNode);
  }
  _createSlider(top, left, width, height) {
    this.slider = createFastDomNode(document.createElement("div"));
    this.slider.setClassName("slider");
    this.slider.setPosition("absolute");
    this.slider.setTop(top);
    this.slider.setLeft(left);
    if (typeof width === "number") {
      this.slider.setWidth(width);
    }
    if (typeof height === "number") {
      this.slider.setHeight(height);
    }
    this.slider.setLayerHinting(true);
    this.slider.setContain("strict");
    this.domNode.domNode.appendChild(this.slider.domNode);
    this.onmousedown(this.slider.domNode, (e) => {
      if (e.leftButton) {
        e.preventDefault();
        this._sliderMouseDown(e, () => {
        });
      }
    });
    this.onclick(this.slider.domNode, (e) => {
      if (e.leftButton) {
        e.stopPropagation();
      }
    });
  }
  _onElementSize(visibleSize) {
    if (this._scrollbarState.setVisibleSize(visibleSize)) {
      this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
      this._shouldRender = true;
      if (!this._lazyRender) {
        this.render();
      }
    }
    return this._shouldRender;
  }
  _onElementScrollSize(elementScrollSize) {
    if (this._scrollbarState.setScrollSize(elementScrollSize)) {
      this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
      this._shouldRender = true;
      if (!this._lazyRender) {
        this.render();
      }
    }
    return this._shouldRender;
  }
  _onElementScrollPosition(elementScrollPosition) {
    if (this._scrollbarState.setScrollPosition(elementScrollPosition)) {
      this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
      this._shouldRender = true;
      if (!this._lazyRender) {
        this.render();
      }
    }
    return this._shouldRender;
  }
  beginReveal() {
    this._visibilityController.setShouldBeVisible(true);
  }
  beginHide() {
    this._visibilityController.setShouldBeVisible(false);
  }
  render() {
    if (!this._shouldRender) {
      return;
    }
    this._shouldRender = false;
    this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize());
    this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition());
  }
  _domNodeMouseDown(e) {
    if (e.target !== this.domNode.domNode) {
      return;
    }
    this._onMouseDown(e);
  }
  delegateMouseDown(e) {
    let domTop = this.domNode.domNode.getClientRects()[0].top;
    let sliderStart = domTop + this._scrollbarState.getSliderPosition();
    let sliderStop = domTop + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize();
    let mousePos = this._sliderMousePosition(e);
    if (sliderStart <= mousePos && mousePos <= sliderStop) {
      if (e.leftButton) {
        e.preventDefault();
        this._sliderMouseDown(e, () => {
        });
      }
    } else {
      this._onMouseDown(e);
    }
  }
  _onMouseDown(e) {
    let offsetX;
    let offsetY;
    if (e.target === this.domNode.domNode && typeof e.browserEvent.offsetX === "number" && typeof e.browserEvent.offsetY === "number") {
      offsetX = e.browserEvent.offsetX;
      offsetY = e.browserEvent.offsetY;
    } else {
      const domNodePosition = getDomNodePagePosition(this.domNode.domNode);
      offsetX = e.posx - domNodePosition.left;
      offsetY = e.posy - domNodePosition.top;
    }
    this._setDesiredScrollPositionNow(this._scrollbarState.getDesiredScrollPositionFromOffset(this._mouseDownRelativePosition(offsetX, offsetY)));
    if (e.leftButton) {
      e.preventDefault();
      this._sliderMouseDown(e, () => {
      });
    }
  }
  _sliderMouseDown(e, onDragFinished) {
    const initialMousePosition = this._sliderMousePosition(e);
    const initialMouseOrthogonalPosition = this._sliderOrthogonalMousePosition(e);
    const initialScrollbarState = this._scrollbarState.clone();
    this.slider.toggleClassName("active", true);
    this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, (mouseMoveData) => {
      const mouseOrthogonalPosition = this._sliderOrthogonalMousePosition(mouseMoveData);
      const mouseOrthogonalDelta = Math.abs(mouseOrthogonalPosition - initialMouseOrthogonalPosition);
      if (isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {
        this._setDesiredScrollPositionNow(initialScrollbarState.getScrollPosition());
        return;
      }
      const mousePosition = this._sliderMousePosition(mouseMoveData);
      const mouseDelta = mousePosition - initialMousePosition;
      this._setDesiredScrollPositionNow(initialScrollbarState.getDesiredScrollPositionFromDelta(mouseDelta));
    }, () => {
      this.slider.toggleClassName("active", false);
      this._host.onDragEnd();
      onDragFinished();
    });
    this._host.onDragStart();
  }
  _setDesiredScrollPositionNow(_desiredScrollPosition) {
    let desiredScrollPosition = {};
    this.writeScrollPosition(desiredScrollPosition, _desiredScrollPosition);
    this._scrollable.setScrollPositionNow(desiredScrollPosition);
  }
  updateScrollbarSize(scrollbarSize) {
    this._updateScrollbarSize(scrollbarSize);
    this._scrollbarState.setScrollbarSize(scrollbarSize);
    this._shouldRender = true;
    if (!this._lazyRender) {
      this.render();
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarState.js
var MINIMUM_SLIDER_SIZE = 20;
var ScrollbarState = class {
  constructor(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {
    this._scrollbarSize = Math.round(scrollbarSize);
    this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);
    this._arrowSize = Math.round(arrowSize);
    this._visibleSize = visibleSize;
    this._scrollSize = scrollSize;
    this._scrollPosition = scrollPosition;
    this._computedAvailableSize = 0;
    this._computedIsNeeded = false;
    this._computedSliderSize = 0;
    this._computedSliderRatio = 0;
    this._computedSliderPosition = 0;
    this._refreshComputedValues();
  }
  clone() {
    return new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
  }
  setVisibleSize(visibleSize) {
    let iVisibleSize = Math.round(visibleSize);
    if (this._visibleSize !== iVisibleSize) {
      this._visibleSize = iVisibleSize;
      this._refreshComputedValues();
      return true;
    }
    return false;
  }
  setScrollSize(scrollSize) {
    let iScrollSize = Math.round(scrollSize);
    if (this._scrollSize !== iScrollSize) {
      this._scrollSize = iScrollSize;
      this._refreshComputedValues();
      return true;
    }
    return false;
  }
  setScrollPosition(scrollPosition) {
    let iScrollPosition = Math.round(scrollPosition);
    if (this._scrollPosition !== iScrollPosition) {
      this._scrollPosition = iScrollPosition;
      this._refreshComputedValues();
      return true;
    }
    return false;
  }
  setScrollbarSize(scrollbarSize) {
    this._scrollbarSize = scrollbarSize;
  }
  static _computeValues(oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {
    const computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);
    const computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);
    const computedIsNeeded = scrollSize > 0 && scrollSize > visibleSize;
    if (!computedIsNeeded) {
      return {
        computedAvailableSize: Math.round(computedAvailableSize),
        computedIsNeeded,
        computedSliderSize: Math.round(computedRepresentableSize),
        computedSliderRatio: 0,
        computedSliderPosition: 0
      };
    }
    const computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));
    const computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);
    const computedSliderPosition = scrollPosition * computedSliderRatio;
    return {
      computedAvailableSize: Math.round(computedAvailableSize),
      computedIsNeeded,
      computedSliderSize: Math.round(computedSliderSize),
      computedSliderRatio,
      computedSliderPosition: Math.round(computedSliderPosition)
    };
  }
  _refreshComputedValues() {
    const r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
    this._computedAvailableSize = r.computedAvailableSize;
    this._computedIsNeeded = r.computedIsNeeded;
    this._computedSliderSize = r.computedSliderSize;
    this._computedSliderRatio = r.computedSliderRatio;
    this._computedSliderPosition = r.computedSliderPosition;
  }
  getArrowSize() {
    return this._arrowSize;
  }
  getScrollPosition() {
    return this._scrollPosition;
  }
  getRectangleLargeSize() {
    return this._computedAvailableSize;
  }
  getRectangleSmallSize() {
    return this._scrollbarSize;
  }
  isNeeded() {
    return this._computedIsNeeded;
  }
  getSliderSize() {
    return this._computedSliderSize;
  }
  getSliderPosition() {
    return this._computedSliderPosition;
  }
  getDesiredScrollPositionFromOffset(offset) {
    if (!this._computedIsNeeded) {
      return 0;
    }
    let desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;
    return Math.round(desiredSliderPosition / this._computedSliderRatio);
  }
  getDesiredScrollPositionFromDelta(delta) {
    if (!this._computedIsNeeded) {
      return 0;
    }
    let desiredSliderPosition = this._computedSliderPosition + delta;
    return Math.round(desiredSliderPosition / this._computedSliderRatio);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/horizontalScrollbar.js
var scrollbarButtonLeftIcon = registerIcon("scrollbar-button-left", Codicon.triangleLeft);
var scrollbarButtonRightIcon = registerIcon("scrollbar-button-right", Codicon.triangleRight);
var HorizontalScrollbar = class extends AbstractScrollbar {
  constructor(scrollable, options, host) {
    const scrollDimensions = scrollable.getScrollDimensions();
    const scrollPosition = scrollable.getCurrentScrollPosition();
    super({
      lazyRender: options.lazyRender,
      host,
      scrollbarState: new ScrollbarState(options.horizontalHasArrows ? options.arrowSize : 0, options.horizontal === 2 ? 0 : options.horizontalScrollbarSize, options.vertical === 2 ? 0 : options.verticalScrollbarSize, scrollDimensions.width, scrollDimensions.scrollWidth, scrollPosition.scrollLeft),
      visibility: options.horizontal,
      extraScrollbarClassName: "horizontal",
      scrollable
    });
    if (options.horizontalHasArrows) {
      let arrowDelta = (options.arrowSize - ARROW_IMG_SIZE) / 2;
      let scrollbarDelta = (options.horizontalScrollbarSize - ARROW_IMG_SIZE) / 2;
      this._createArrow({
        className: "scra",
        icon: scrollbarButtonLeftIcon,
        top: scrollbarDelta,
        left: arrowDelta,
        bottom: void 0,
        right: void 0,
        bgWidth: options.arrowSize,
        bgHeight: options.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 1, 0))
      });
      this._createArrow({
        className: "scra",
        icon: scrollbarButtonRightIcon,
        top: scrollbarDelta,
        left: void 0,
        bottom: void 0,
        right: arrowDelta,
        bgWidth: options.arrowSize,
        bgHeight: options.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, -1, 0))
      });
    }
    this._createSlider(Math.floor((options.horizontalScrollbarSize - options.horizontalSliderSize) / 2), 0, void 0, options.horizontalSliderSize);
  }
  _updateSlider(sliderSize, sliderPosition) {
    this.slider.setWidth(sliderSize);
    this.slider.setLeft(sliderPosition);
  }
  _renderDomNode(largeSize, smallSize) {
    this.domNode.setWidth(largeSize);
    this.domNode.setHeight(smallSize);
    this.domNode.setLeft(0);
    this.domNode.setBottom(0);
  }
  onDidScroll(e) {
    this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender;
    this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender;
    this._shouldRender = this._onElementSize(e.width) || this._shouldRender;
    return this._shouldRender;
  }
  _mouseDownRelativePosition(offsetX, offsetY) {
    return offsetX;
  }
  _sliderMousePosition(e) {
    return e.posx;
  }
  _sliderOrthogonalMousePosition(e) {
    return e.posy;
  }
  _updateScrollbarSize(size) {
    this.slider.setHeight(size);
  }
  writeScrollPosition(target, scrollPosition) {
    target.scrollLeft = scrollPosition;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/verticalScrollbar.js
var scrollbarButtonUpIcon = registerIcon("scrollbar-button-up", Codicon.triangleUp);
var scrollbarButtonDownIcon = registerIcon("scrollbar-button-down", Codicon.triangleDown);
var VerticalScrollbar = class extends AbstractScrollbar {
  constructor(scrollable, options, host) {
    const scrollDimensions = scrollable.getScrollDimensions();
    const scrollPosition = scrollable.getCurrentScrollPosition();
    super({
      lazyRender: options.lazyRender,
      host,
      scrollbarState: new ScrollbarState(options.verticalHasArrows ? options.arrowSize : 0, options.vertical === 2 ? 0 : options.verticalScrollbarSize, 0, scrollDimensions.height, scrollDimensions.scrollHeight, scrollPosition.scrollTop),
      visibility: options.vertical,
      extraScrollbarClassName: "vertical",
      scrollable
    });
    if (options.verticalHasArrows) {
      let arrowDelta = (options.arrowSize - ARROW_IMG_SIZE) / 2;
      let scrollbarDelta = (options.verticalScrollbarSize - ARROW_IMG_SIZE) / 2;
      this._createArrow({
        className: "scra",
        icon: scrollbarButtonUpIcon,
        top: arrowDelta,
        left: scrollbarDelta,
        bottom: void 0,
        right: void 0,
        bgWidth: options.verticalScrollbarSize,
        bgHeight: options.arrowSize,
        onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 0, 1))
      });
      this._createArrow({
        className: "scra",
        icon: scrollbarButtonDownIcon,
        top: void 0,
        left: scrollbarDelta,
        bottom: arrowDelta,
        right: void 0,
        bgWidth: options.verticalScrollbarSize,
        bgHeight: options.arrowSize,
        onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 0, -1))
      });
    }
    this._createSlider(0, Math.floor((options.verticalScrollbarSize - options.verticalSliderSize) / 2), options.verticalSliderSize, void 0);
  }
  _updateSlider(sliderSize, sliderPosition) {
    this.slider.setHeight(sliderSize);
    this.slider.setTop(sliderPosition);
  }
  _renderDomNode(largeSize, smallSize) {
    this.domNode.setWidth(smallSize);
    this.domNode.setHeight(largeSize);
    this.domNode.setRight(0);
    this.domNode.setTop(0);
  }
  onDidScroll(e) {
    this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender;
    this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender;
    this._shouldRender = this._onElementSize(e.height) || this._shouldRender;
    return this._shouldRender;
  }
  _mouseDownRelativePosition(offsetX, offsetY) {
    return offsetY;
  }
  _sliderMousePosition(e) {
    return e.posy;
  }
  _sliderOrthogonalMousePosition(e) {
    return e.posx;
  }
  _updateScrollbarSize(size) {
    this.slider.setWidth(size);
  }
  writeScrollPosition(target, scrollPosition) {
    target.scrollTop = scrollPosition;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/scrollable.js
var ScrollState = class {
  constructor(width, scrollWidth, scrollLeft, height, scrollHeight, scrollTop) {
    width = width | 0;
    scrollWidth = scrollWidth | 0;
    scrollLeft = scrollLeft | 0;
    height = height | 0;
    scrollHeight = scrollHeight | 0;
    scrollTop = scrollTop | 0;
    this.rawScrollLeft = scrollLeft;
    this.rawScrollTop = scrollTop;
    if (width < 0) {
      width = 0;
    }
    if (scrollLeft + width > scrollWidth) {
      scrollLeft = scrollWidth - width;
    }
    if (scrollLeft < 0) {
      scrollLeft = 0;
    }
    if (height < 0) {
      height = 0;
    }
    if (scrollTop + height > scrollHeight) {
      scrollTop = scrollHeight - height;
    }
    if (scrollTop < 0) {
      scrollTop = 0;
    }
    this.width = width;
    this.scrollWidth = scrollWidth;
    this.scrollLeft = scrollLeft;
    this.height = height;
    this.scrollHeight = scrollHeight;
    this.scrollTop = scrollTop;
  }
  equals(other) {
    return this.rawScrollLeft === other.rawScrollLeft && this.rawScrollTop === other.rawScrollTop && this.width === other.width && this.scrollWidth === other.scrollWidth && this.scrollLeft === other.scrollLeft && this.height === other.height && this.scrollHeight === other.scrollHeight && this.scrollTop === other.scrollTop;
  }
  withScrollDimensions(update, useRawScrollPositions) {
    return new ScrollState(typeof update.width !== "undefined" ? update.width : this.width, typeof update.scrollWidth !== "undefined" ? update.scrollWidth : this.scrollWidth, useRawScrollPositions ? this.rawScrollLeft : this.scrollLeft, typeof update.height !== "undefined" ? update.height : this.height, typeof update.scrollHeight !== "undefined" ? update.scrollHeight : this.scrollHeight, useRawScrollPositions ? this.rawScrollTop : this.scrollTop);
  }
  withScrollPosition(update) {
    return new ScrollState(this.width, this.scrollWidth, typeof update.scrollLeft !== "undefined" ? update.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof update.scrollTop !== "undefined" ? update.scrollTop : this.rawScrollTop);
  }
  createScrollEvent(previous) {
    const widthChanged = this.width !== previous.width;
    const scrollWidthChanged = this.scrollWidth !== previous.scrollWidth;
    const scrollLeftChanged = this.scrollLeft !== previous.scrollLeft;
    const heightChanged = this.height !== previous.height;
    const scrollHeightChanged = this.scrollHeight !== previous.scrollHeight;
    const scrollTopChanged = this.scrollTop !== previous.scrollTop;
    return {
      oldWidth: previous.width,
      oldScrollWidth: previous.scrollWidth,
      oldScrollLeft: previous.scrollLeft,
      width: this.width,
      scrollWidth: this.scrollWidth,
      scrollLeft: this.scrollLeft,
      oldHeight: previous.height,
      oldScrollHeight: previous.scrollHeight,
      oldScrollTop: previous.scrollTop,
      height: this.height,
      scrollHeight: this.scrollHeight,
      scrollTop: this.scrollTop,
      widthChanged,
      scrollWidthChanged,
      scrollLeftChanged,
      heightChanged,
      scrollHeightChanged,
      scrollTopChanged
    };
  }
};
var Scrollable = class extends Disposable {
  constructor(smoothScrollDuration, scheduleAtNextAnimationFrame2) {
    super();
    this._onScroll = this._register(new Emitter());
    this.onScroll = this._onScroll.event;
    this._smoothScrollDuration = smoothScrollDuration;
    this._scheduleAtNextAnimationFrame = scheduleAtNextAnimationFrame2;
    this._state = new ScrollState(0, 0, 0, 0, 0, 0);
    this._smoothScrolling = null;
  }
  dispose() {
    if (this._smoothScrolling) {
      this._smoothScrolling.dispose();
      this._smoothScrolling = null;
    }
    super.dispose();
  }
  setSmoothScrollDuration(smoothScrollDuration) {
    this._smoothScrollDuration = smoothScrollDuration;
  }
  validateScrollPosition(scrollPosition) {
    return this._state.withScrollPosition(scrollPosition);
  }
  getScrollDimensions() {
    return this._state;
  }
  setScrollDimensions(dimensions, useRawScrollPositions) {
    const newState = this._state.withScrollDimensions(dimensions, useRawScrollPositions);
    this._setState(newState);
    if (this._smoothScrolling) {
      this._smoothScrolling.acceptScrollDimensions(this._state);
    }
  }
  getFutureScrollPosition() {
    if (this._smoothScrolling) {
      return this._smoothScrolling.to;
    }
    return this._state;
  }
  getCurrentScrollPosition() {
    return this._state;
  }
  setScrollPositionNow(update) {
    const newState = this._state.withScrollPosition(update);
    if (this._smoothScrolling) {
      this._smoothScrolling.dispose();
      this._smoothScrolling = null;
    }
    this._setState(newState);
  }
  setScrollPositionSmooth(update) {
    if (this._smoothScrollDuration === 0) {
      return this.setScrollPositionNow(update);
    }
    if (this._smoothScrolling) {
      update = {
        scrollLeft: typeof update.scrollLeft === "undefined" ? this._smoothScrolling.to.scrollLeft : update.scrollLeft,
        scrollTop: typeof update.scrollTop === "undefined" ? this._smoothScrolling.to.scrollTop : update.scrollTop
      };
      const validTarget = this._state.withScrollPosition(update);
      if (this._smoothScrolling.to.scrollLeft === validTarget.scrollLeft && this._smoothScrolling.to.scrollTop === validTarget.scrollTop) {
        return;
      }
      const newSmoothScrolling = this._smoothScrolling.combine(this._state, validTarget, this._smoothScrollDuration);
      this._smoothScrolling.dispose();
      this._smoothScrolling = newSmoothScrolling;
    } else {
      const validTarget = this._state.withScrollPosition(update);
      this._smoothScrolling = SmoothScrollingOperation.start(this._state, validTarget, this._smoothScrollDuration);
    }
    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      if (!this._smoothScrolling) {
        return;
      }
      this._smoothScrolling.animationFrameDisposable = null;
      this._performSmoothScrolling();
    });
  }
  _performSmoothScrolling() {
    if (!this._smoothScrolling) {
      return;
    }
    const update = this._smoothScrolling.tick();
    const newState = this._state.withScrollPosition(update);
    this._setState(newState);
    if (!this._smoothScrolling) {
      return;
    }
    if (update.isDone) {
      this._smoothScrolling.dispose();
      this._smoothScrolling = null;
      return;
    }
    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      if (!this._smoothScrolling) {
        return;
      }
      this._smoothScrolling.animationFrameDisposable = null;
      this._performSmoothScrolling();
    });
  }
  _setState(newState) {
    const oldState = this._state;
    if (oldState.equals(newState)) {
      return;
    }
    this._state = newState;
    this._onScroll.fire(this._state.createScrollEvent(oldState));
  }
};
var SmoothScrollingUpdate = class {
  constructor(scrollLeft, scrollTop, isDone) {
    this.scrollLeft = scrollLeft;
    this.scrollTop = scrollTop;
    this.isDone = isDone;
  }
};
function createEaseOutCubic(from, to) {
  const delta = to - from;
  return function(completion) {
    return from + delta * easeOutCubic(completion);
  };
}
function createComposed(a, b, cut) {
  return function(completion) {
    if (completion < cut) {
      return a(completion / cut);
    }
    return b((completion - cut) / (1 - cut));
  };
}
var SmoothScrollingOperation = class {
  constructor(from, to, startTime, duration) {
    this.from = from;
    this.to = to;
    this.duration = duration;
    this._startTime = startTime;
    this.animationFrameDisposable = null;
    this._initAnimations();
  }
  _initAnimations() {
    this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width);
    this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
  }
  _initAnimation(from, to, viewportSize) {
    const delta = Math.abs(from - to);
    if (delta > 2.5 * viewportSize) {
      let stop1, stop2;
      if (from < to) {
        stop1 = from + 0.75 * viewportSize;
        stop2 = to - 0.75 * viewportSize;
      } else {
        stop1 = from - 0.75 * viewportSize;
        stop2 = to + 0.75 * viewportSize;
      }
      return createComposed(createEaseOutCubic(from, stop1), createEaseOutCubic(stop2, to), 0.33);
    }
    return createEaseOutCubic(from, to);
  }
  dispose() {
    if (this.animationFrameDisposable !== null) {
      this.animationFrameDisposable.dispose();
      this.animationFrameDisposable = null;
    }
  }
  acceptScrollDimensions(state) {
    this.to = state.withScrollPosition(this.to);
    this._initAnimations();
  }
  tick() {
    return this._tick(Date.now());
  }
  _tick(now) {
    const completion = (now - this._startTime) / this.duration;
    if (completion < 1) {
      const newScrollLeft = this.scrollLeft(completion);
      const newScrollTop = this.scrollTop(completion);
      return new SmoothScrollingUpdate(newScrollLeft, newScrollTop, false);
    }
    return new SmoothScrollingUpdate(this.to.scrollLeft, this.to.scrollTop, true);
  }
  combine(from, to, duration) {
    return SmoothScrollingOperation.start(from, to, duration);
  }
  static start(from, to, duration) {
    duration = duration + 10;
    const startTime = Date.now() - 10;
    return new SmoothScrollingOperation(from, to, startTime, duration);
  }
};
function easeInCubic(t) {
  return Math.pow(t, 3);
}
function easeOutCubic(t) {
  return 1 - easeInCubic(1 - t);
}

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollableElement.js
var HIDE_TIMEOUT = 500;
var SCROLL_WHEEL_SENSITIVITY = 50;
var SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED = true;
var MouseWheelClassifierItem = class {
  constructor(timestamp, deltaX, deltaY) {
    this.timestamp = timestamp;
    this.deltaX = deltaX;
    this.deltaY = deltaY;
    this.score = 0;
  }
};
var MouseWheelClassifier = class {
  constructor() {
    this._capacity = 5;
    this._memory = [];
    this._front = -1;
    this._rear = -1;
  }
  isPhysicalMouseWheel() {
    if (this._front === -1 && this._rear === -1) {
      return false;
    }
    let remainingInfluence = 1;
    let score2 = 0;
    let iteration = 1;
    let index = this._rear;
    do {
      const influence = index === this._front ? remainingInfluence : Math.pow(2, -iteration);
      remainingInfluence -= influence;
      score2 += this._memory[index].score * influence;
      if (index === this._front) {
        break;
      }
      index = (this._capacity + index - 1) % this._capacity;
      iteration++;
    } while (true);
    return score2 <= 0.5;
  }
  accept(timestamp, deltaX, deltaY) {
    const item = new MouseWheelClassifierItem(timestamp, deltaX, deltaY);
    item.score = this._computeScore(item);
    if (this._front === -1 && this._rear === -1) {
      this._memory[0] = item;
      this._front = 0;
      this._rear = 0;
    } else {
      this._rear = (this._rear + 1) % this._capacity;
      if (this._rear === this._front) {
        this._front = (this._front + 1) % this._capacity;
      }
      this._memory[this._rear] = item;
    }
  }
  _computeScore(item) {
    if (Math.abs(item.deltaX) > 0 && Math.abs(item.deltaY) > 0) {
      return 1;
    }
    let score2 = 0.5;
    const prev = this._front === -1 && this._rear === -1 ? null : this._memory[this._rear];
    if (prev) {
    }
    if (!this._isAlmostInt(item.deltaX) || !this._isAlmostInt(item.deltaY)) {
      score2 += 0.25;
    }
    return Math.min(Math.max(score2, 0), 1);
  }
  _isAlmostInt(value) {
    const delta = Math.abs(Math.round(value) - value);
    return delta < 0.01;
  }
};
MouseWheelClassifier.INSTANCE = new MouseWheelClassifier();
var AbstractScrollableElement = class extends Widget2 {
  constructor(element, options, scrollable) {
    super();
    this._onScroll = this._register(new Emitter());
    this.onScroll = this._onScroll.event;
    this._onWillScroll = this._register(new Emitter());
    element.style.overflow = "hidden";
    this._options = resolveOptions(options);
    this._scrollable = scrollable;
    this._register(this._scrollable.onScroll((e) => {
      this._onWillScroll.fire(e);
      this._onDidScroll(e);
      this._onScroll.fire(e);
    }));
    let scrollbarHost = {
      onMouseWheel: (mouseWheelEvent) => this._onMouseWheel(mouseWheelEvent),
      onDragStart: () => this._onDragStart(),
      onDragEnd: () => this._onDragEnd()
    };
    this._verticalScrollbar = this._register(new VerticalScrollbar(this._scrollable, this._options, scrollbarHost));
    this._horizontalScrollbar = this._register(new HorizontalScrollbar(this._scrollable, this._options, scrollbarHost));
    this._domNode = document.createElement("div");
    this._domNode.className = "monaco-scrollable-element " + this._options.className;
    this._domNode.setAttribute("role", "presentation");
    this._domNode.style.position = "relative";
    this._domNode.style.overflow = "hidden";
    this._domNode.appendChild(element);
    this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode);
    this._domNode.appendChild(this._verticalScrollbar.domNode.domNode);
    if (this._options.useShadows) {
      this._leftShadowDomNode = createFastDomNode(document.createElement("div"));
      this._leftShadowDomNode.setClassName("shadow");
      this._domNode.appendChild(this._leftShadowDomNode.domNode);
      this._topShadowDomNode = createFastDomNode(document.createElement("div"));
      this._topShadowDomNode.setClassName("shadow");
      this._domNode.appendChild(this._topShadowDomNode.domNode);
      this._topLeftShadowDomNode = createFastDomNode(document.createElement("div"));
      this._topLeftShadowDomNode.setClassName("shadow top-left-corner");
      this._domNode.appendChild(this._topLeftShadowDomNode.domNode);
    } else {
      this._leftShadowDomNode = null;
      this._topShadowDomNode = null;
      this._topLeftShadowDomNode = null;
    }
    this._listenOnDomNode = this._options.listenOnDomNode || this._domNode;
    this._mouseWheelToDispose = [];
    this._setListeningToMouseWheel(this._options.handleMouseWheel);
    this.onmouseover(this._listenOnDomNode, (e) => this._onMouseOver(e));
    this.onnonbubblingmouseout(this._listenOnDomNode, (e) => this._onMouseOut(e));
    this._hideTimeout = this._register(new TimeoutTimer());
    this._isDragging = false;
    this._mouseIsOver = false;
    this._shouldRender = true;
    this._revealOnScroll = true;
  }
  dispose() {
    this._mouseWheelToDispose = dispose(this._mouseWheelToDispose);
    super.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  getOverviewRulerLayoutInfo() {
    return {
      parent: this._domNode,
      insertBefore: this._verticalScrollbar.domNode.domNode
    };
  }
  delegateVerticalScrollbarMouseDown(browserEvent) {
    this._verticalScrollbar.delegateMouseDown(browserEvent);
  }
  getScrollDimensions() {
    return this._scrollable.getScrollDimensions();
  }
  setScrollDimensions(dimensions) {
    this._scrollable.setScrollDimensions(dimensions, false);
  }
  updateClassName(newClassName) {
    this._options.className = newClassName;
    if (isMacintosh) {
      this._options.className += " mac";
    }
    this._domNode.className = "monaco-scrollable-element " + this._options.className;
  }
  updateOptions(newOptions) {
    if (typeof newOptions.handleMouseWheel !== "undefined") {
      this._options.handleMouseWheel = newOptions.handleMouseWheel;
      this._setListeningToMouseWheel(this._options.handleMouseWheel);
    }
    if (typeof newOptions.mouseWheelScrollSensitivity !== "undefined") {
      this._options.mouseWheelScrollSensitivity = newOptions.mouseWheelScrollSensitivity;
    }
    if (typeof newOptions.fastScrollSensitivity !== "undefined") {
      this._options.fastScrollSensitivity = newOptions.fastScrollSensitivity;
    }
    if (typeof newOptions.scrollPredominantAxis !== "undefined") {
      this._options.scrollPredominantAxis = newOptions.scrollPredominantAxis;
    }
    if (typeof newOptions.horizontalScrollbarSize !== "undefined") {
      this._horizontalScrollbar.updateScrollbarSize(newOptions.horizontalScrollbarSize);
    }
    if (!this._options.lazyRender) {
      this._render();
    }
  }
  _setListeningToMouseWheel(shouldListen) {
    let isListening = this._mouseWheelToDispose.length > 0;
    if (isListening === shouldListen) {
      return;
    }
    this._mouseWheelToDispose = dispose(this._mouseWheelToDispose);
    if (shouldListen) {
      let onMouseWheel = (browserEvent) => {
        this._onMouseWheel(new StandardWheelEvent(browserEvent));
      };
      this._mouseWheelToDispose.push(addDisposableListener(this._listenOnDomNode, EventType.MOUSE_WHEEL, onMouseWheel, {passive: false}));
    }
  }
  _onMouseWheel(e) {
    const classifier = MouseWheelClassifier.INSTANCE;
    if (SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED) {
      const osZoomFactor = window.devicePixelRatio / getZoomFactor();
      if (isWindows || isLinux) {
        classifier.accept(Date.now(), e.deltaX / osZoomFactor, e.deltaY / osZoomFactor);
      } else {
        classifier.accept(Date.now(), e.deltaX, e.deltaY);
      }
    }
    if (e.deltaY || e.deltaX) {
      let deltaY = e.deltaY * this._options.mouseWheelScrollSensitivity;
      let deltaX = e.deltaX * this._options.mouseWheelScrollSensitivity;
      if (this._options.scrollPredominantAxis) {
        if (Math.abs(deltaY) >= Math.abs(deltaX)) {
          deltaX = 0;
        } else {
          deltaY = 0;
        }
      }
      if (this._options.flipAxes) {
        [deltaY, deltaX] = [deltaX, deltaY];
      }
      const shiftConvert = !isMacintosh && e.browserEvent && e.browserEvent.shiftKey;
      if ((this._options.scrollYToX || shiftConvert) && !deltaX) {
        deltaX = deltaY;
        deltaY = 0;
      }
      if (e.browserEvent && e.browserEvent.altKey) {
        deltaX = deltaX * this._options.fastScrollSensitivity;
        deltaY = deltaY * this._options.fastScrollSensitivity;
      }
      const futureScrollPosition = this._scrollable.getFutureScrollPosition();
      let desiredScrollPosition = {};
      if (deltaY) {
        const desiredScrollTop = futureScrollPosition.scrollTop - SCROLL_WHEEL_SENSITIVITY * deltaY;
        this._verticalScrollbar.writeScrollPosition(desiredScrollPosition, desiredScrollTop);
      }
      if (deltaX) {
        const desiredScrollLeft = futureScrollPosition.scrollLeft - SCROLL_WHEEL_SENSITIVITY * deltaX;
        this._horizontalScrollbar.writeScrollPosition(desiredScrollPosition, desiredScrollLeft);
      }
      desiredScrollPosition = this._scrollable.validateScrollPosition(desiredScrollPosition);
      if (futureScrollPosition.scrollLeft !== desiredScrollPosition.scrollLeft || futureScrollPosition.scrollTop !== desiredScrollPosition.scrollTop) {
        const canPerformSmoothScroll = SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED && this._options.mouseWheelSmoothScroll && classifier.isPhysicalMouseWheel();
        if (canPerformSmoothScroll) {
          this._scrollable.setScrollPositionSmooth(desiredScrollPosition);
        } else {
          this._scrollable.setScrollPositionNow(desiredScrollPosition);
        }
        this._shouldRender = true;
      }
    }
    if (this._options.alwaysConsumeMouseWheel || this._shouldRender) {
      e.preventDefault();
      e.stopPropagation();
    }
  }
  _onDidScroll(e) {
    this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender;
    this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender;
    if (this._options.useShadows) {
      this._shouldRender = true;
    }
    if (this._revealOnScroll) {
      this._reveal();
    }
    if (!this._options.lazyRender) {
      this._render();
    }
  }
  renderNow() {
    if (!this._options.lazyRender) {
      throw new Error("Please use `lazyRender` together with `renderNow`!");
    }
    this._render();
  }
  _render() {
    if (!this._shouldRender) {
      return;
    }
    this._shouldRender = false;
    this._horizontalScrollbar.render();
    this._verticalScrollbar.render();
    if (this._options.useShadows) {
      const scrollState = this._scrollable.getCurrentScrollPosition();
      let enableTop = scrollState.scrollTop > 0;
      let enableLeft = scrollState.scrollLeft > 0;
      this._leftShadowDomNode.setClassName("shadow" + (enableLeft ? " left" : ""));
      this._topShadowDomNode.setClassName("shadow" + (enableTop ? " top" : ""));
      this._topLeftShadowDomNode.setClassName("shadow top-left-corner" + (enableTop ? " top" : "") + (enableLeft ? " left" : ""));
    }
  }
  _onDragStart() {
    this._isDragging = true;
    this._reveal();
  }
  _onDragEnd() {
    this._isDragging = false;
    this._hide();
  }
  _onMouseOut(e) {
    this._mouseIsOver = false;
    this._hide();
  }
  _onMouseOver(e) {
    this._mouseIsOver = true;
    this._reveal();
  }
  _reveal() {
    this._verticalScrollbar.beginReveal();
    this._horizontalScrollbar.beginReveal();
    this._scheduleHide();
  }
  _hide() {
    if (!this._mouseIsOver && !this._isDragging) {
      this._verticalScrollbar.beginHide();
      this._horizontalScrollbar.beginHide();
    }
  }
  _scheduleHide() {
    if (!this._mouseIsOver && !this._isDragging) {
      this._hideTimeout.cancelAndSet(() => this._hide(), HIDE_TIMEOUT);
    }
  }
};
var ScrollableElement = class extends AbstractScrollableElement {
  constructor(element, options) {
    options = options || {};
    options.mouseWheelSmoothScroll = false;
    const scrollable = new Scrollable(0, (callback) => scheduleAtNextAnimationFrame(callback));
    super(element, options, scrollable);
    this._register(scrollable);
  }
  setScrollPosition(update) {
    this._scrollable.setScrollPositionNow(update);
  }
};
var SmoothScrollableElement = class extends AbstractScrollableElement {
  constructor(element, options, scrollable) {
    super(element, options, scrollable);
  }
  setScrollPosition(update) {
    this._scrollable.setScrollPositionNow(update);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
};
var DomScrollableElement = class extends ScrollableElement {
  constructor(element, options) {
    super(element, options);
    this._element = element;
    this.onScroll((e) => {
      if (e.scrollTopChanged) {
        this._element.scrollTop = e.scrollTop;
      }
      if (e.scrollLeftChanged) {
        this._element.scrollLeft = e.scrollLeft;
      }
    });
    this.scanDomNode();
  }
  scanDomNode() {
    this.setScrollDimensions({
      width: this._element.clientWidth,
      scrollWidth: this._element.scrollWidth,
      height: this._element.clientHeight,
      scrollHeight: this._element.scrollHeight
    });
    this.setScrollPosition({
      scrollLeft: this._element.scrollLeft,
      scrollTop: this._element.scrollTop
    });
  }
};
function resolveOptions(opts) {
  let result = {
    lazyRender: typeof opts.lazyRender !== "undefined" ? opts.lazyRender : false,
    className: typeof opts.className !== "undefined" ? opts.className : "",
    useShadows: typeof opts.useShadows !== "undefined" ? opts.useShadows : true,
    handleMouseWheel: typeof opts.handleMouseWheel !== "undefined" ? opts.handleMouseWheel : true,
    flipAxes: typeof opts.flipAxes !== "undefined" ? opts.flipAxes : false,
    alwaysConsumeMouseWheel: typeof opts.alwaysConsumeMouseWheel !== "undefined" ? opts.alwaysConsumeMouseWheel : false,
    scrollYToX: typeof opts.scrollYToX !== "undefined" ? opts.scrollYToX : false,
    mouseWheelScrollSensitivity: typeof opts.mouseWheelScrollSensitivity !== "undefined" ? opts.mouseWheelScrollSensitivity : 1,
    fastScrollSensitivity: typeof opts.fastScrollSensitivity !== "undefined" ? opts.fastScrollSensitivity : 5,
    scrollPredominantAxis: typeof opts.scrollPredominantAxis !== "undefined" ? opts.scrollPredominantAxis : true,
    mouseWheelSmoothScroll: typeof opts.mouseWheelSmoothScroll !== "undefined" ? opts.mouseWheelSmoothScroll : true,
    arrowSize: typeof opts.arrowSize !== "undefined" ? opts.arrowSize : 11,
    listenOnDomNode: typeof opts.listenOnDomNode !== "undefined" ? opts.listenOnDomNode : null,
    horizontal: typeof opts.horizontal !== "undefined" ? opts.horizontal : 1,
    horizontalScrollbarSize: typeof opts.horizontalScrollbarSize !== "undefined" ? opts.horizontalScrollbarSize : 10,
    horizontalSliderSize: typeof opts.horizontalSliderSize !== "undefined" ? opts.horizontalSliderSize : 0,
    horizontalHasArrows: typeof opts.horizontalHasArrows !== "undefined" ? opts.horizontalHasArrows : false,
    vertical: typeof opts.vertical !== "undefined" ? opts.vertical : 1,
    verticalScrollbarSize: typeof opts.verticalScrollbarSize !== "undefined" ? opts.verticalScrollbarSize : 10,
    verticalHasArrows: typeof opts.verticalHasArrows !== "undefined" ? opts.verticalHasArrows : false,
    verticalSliderSize: typeof opts.verticalSliderSize !== "undefined" ? opts.verticalSliderSize : 0
  };
  result.horizontalSliderSize = typeof opts.horizontalSliderSize !== "undefined" ? opts.horizontalSliderSize : result.horizontalScrollbarSize;
  result.verticalSliderSize = typeof opts.verticalSliderSize !== "undefined" ? opts.verticalSliderSize : result.verticalScrollbarSize;
  if (isMacintosh) {
    result.className += " mac";
  }
  return result;
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/editorScrollbar/editorScrollbar.js
var EditorScrollbar2 = class extends ViewPart {
  constructor(context, linesContent, viewDomNode, overflowGuardDomNode) {
    super(context);
    const options = this._context.configuration.options;
    const scrollbar = options.get(84);
    const mouseWheelScrollSensitivity = options.get(58);
    const fastScrollSensitivity = options.get(28);
    const scrollPredominantAxis = options.get(87);
    const scrollbarOptions = {
      listenOnDomNode: viewDomNode.domNode,
      className: "editor-scrollable " + getThemeTypeSelector(context.theme.type),
      useShadows: false,
      lazyRender: true,
      vertical: scrollbar.vertical,
      horizontal: scrollbar.horizontal,
      verticalHasArrows: scrollbar.verticalHasArrows,
      horizontalHasArrows: scrollbar.horizontalHasArrows,
      verticalScrollbarSize: scrollbar.verticalScrollbarSize,
      verticalSliderSize: scrollbar.verticalSliderSize,
      horizontalScrollbarSize: scrollbar.horizontalScrollbarSize,
      horizontalSliderSize: scrollbar.horizontalSliderSize,
      handleMouseWheel: scrollbar.handleMouseWheel,
      alwaysConsumeMouseWheel: scrollbar.alwaysConsumeMouseWheel,
      arrowSize: scrollbar.arrowSize,
      mouseWheelScrollSensitivity,
      fastScrollSensitivity,
      scrollPredominantAxis
    };
    this.scrollbar = this._register(new SmoothScrollableElement(linesContent.domNode, scrollbarOptions, this._context.viewLayout.getScrollable()));
    PartFingerprints.write(this.scrollbar.getDomNode(), 5);
    this.scrollbarDomNode = createFastDomNode(this.scrollbar.getDomNode());
    this.scrollbarDomNode.setPosition("absolute");
    this._setLayout();
    const onBrowserDesperateReveal = (domNode, lookAtScrollTop, lookAtScrollLeft) => {
      const newScrollPosition = {};
      if (lookAtScrollTop) {
        const deltaTop = domNode.scrollTop;
        if (deltaTop) {
          newScrollPosition.scrollTop = this._context.viewLayout.getCurrentScrollTop() + deltaTop;
          domNode.scrollTop = 0;
        }
      }
      if (lookAtScrollLeft) {
        const deltaLeft = domNode.scrollLeft;
        if (deltaLeft) {
          newScrollPosition.scrollLeft = this._context.viewLayout.getCurrentScrollLeft() + deltaLeft;
          domNode.scrollLeft = 0;
        }
      }
      this._context.model.setScrollPosition(newScrollPosition, 1);
    };
    this._register(addDisposableListener(viewDomNode.domNode, "scroll", (e) => onBrowserDesperateReveal(viewDomNode.domNode, true, true)));
    this._register(addDisposableListener(linesContent.domNode, "scroll", (e) => onBrowserDesperateReveal(linesContent.domNode, true, false)));
    this._register(addDisposableListener(overflowGuardDomNode.domNode, "scroll", (e) => onBrowserDesperateReveal(overflowGuardDomNode.domNode, true, false)));
    this._register(addDisposableListener(this.scrollbarDomNode.domNode, "scroll", (e) => onBrowserDesperateReveal(this.scrollbarDomNode.domNode, true, false)));
  }
  dispose() {
    super.dispose();
  }
  _setLayout() {
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this.scrollbarDomNode.setLeft(layoutInfo.contentLeft);
    const minimap = options.get(56);
    const side = minimap.side;
    if (side === "right") {
      this.scrollbarDomNode.setWidth(layoutInfo.contentWidth + layoutInfo.minimap.minimapWidth);
    } else {
      this.scrollbarDomNode.setWidth(layoutInfo.contentWidth);
    }
    this.scrollbarDomNode.setHeight(layoutInfo.height);
  }
  getOverviewRulerLayoutInfo() {
    return this.scrollbar.getOverviewRulerLayoutInfo();
  }
  getDomNode() {
    return this.scrollbarDomNode;
  }
  delegateVerticalScrollbarMouseDown(browserEvent) {
    this.scrollbar.delegateVerticalScrollbarMouseDown(browserEvent);
  }
  onConfigurationChanged(e) {
    if (e.hasChanged(84) || e.hasChanged(58) || e.hasChanged(28)) {
      const options = this._context.configuration.options;
      const scrollbar = options.get(84);
      const mouseWheelScrollSensitivity = options.get(58);
      const fastScrollSensitivity = options.get(28);
      const scrollPredominantAxis = options.get(87);
      const newOpts = {
        handleMouseWheel: scrollbar.handleMouseWheel,
        mouseWheelScrollSensitivity,
        fastScrollSensitivity,
        scrollPredominantAxis
      };
      this.scrollbar.updateOptions(newOpts);
    }
    if (e.hasChanged(117)) {
      this._setLayout();
    }
    return true;
  }
  onScrollChanged(e) {
    return true;
  }
  onThemeChanged(e) {
    this.scrollbar.updateClassName("editor-scrollable " + getThemeTypeSelector(this._context.theme.type));
    return true;
  }
  prepareRender(ctx) {
  }
  render(ctx) {
    this.scrollbar.renderNow();
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/glyphMargin/glyphMargin.js
var DecorationToRender = class {
  constructor(startLineNumber, endLineNumber, className) {
    this.startLineNumber = +startLineNumber;
    this.endLineNumber = +endLineNumber;
    this.className = String(className);
  }
};
var DedupOverlay = class extends DynamicViewOverlay {
  _render(visibleStartLineNumber, visibleEndLineNumber, decorations) {
    const output = [];
    for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
      const lineIndex = lineNumber - visibleStartLineNumber;
      output[lineIndex] = [];
    }
    if (decorations.length === 0) {
      return output;
    }
    decorations.sort((a, b) => {
      if (a.className === b.className) {
        if (a.startLineNumber === b.startLineNumber) {
          return a.endLineNumber - b.endLineNumber;
        }
        return a.startLineNumber - b.startLineNumber;
      }
      return a.className < b.className ? -1 : 1;
    });
    let prevClassName = null;
    let prevEndLineIndex = 0;
    for (let i = 0, len = decorations.length; i < len; i++) {
      const d = decorations[i];
      const className = d.className;
      let startLineIndex = Math.max(d.startLineNumber, visibleStartLineNumber) - visibleStartLineNumber;
      const endLineIndex = Math.min(d.endLineNumber, visibleEndLineNumber) - visibleStartLineNumber;
      if (prevClassName === className) {
        startLineIndex = Math.max(prevEndLineIndex + 1, startLineIndex);
        prevEndLineIndex = Math.max(prevEndLineIndex, endLineIndex);
      } else {
        prevClassName = className;
        prevEndLineIndex = endLineIndex;
      }
      for (let i2 = startLineIndex; i2 <= prevEndLineIndex; i2++) {
        output[i2].push(prevClassName);
      }
    }
    return output;
  }
};
var GlyphMarginOverlay = class extends DedupOverlay {
  constructor(context) {
    super();
    this._context = context;
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._lineHeight = options.get(51);
    this._glyphMargin = options.get(42);
    this._glyphMarginLeft = layoutInfo.glyphMarginLeft;
    this._glyphMarginWidth = layoutInfo.glyphMarginWidth;
    this._renderResult = null;
    this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this);
    this._renderResult = null;
    super.dispose();
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._lineHeight = options.get(51);
    this._glyphMargin = options.get(42);
    this._glyphMarginLeft = layoutInfo.glyphMarginLeft;
    this._glyphMarginWidth = layoutInfo.glyphMarginWidth;
    return true;
  }
  onDecorationsChanged(e) {
    return true;
  }
  onFlushed(e) {
    return true;
  }
  onLinesChanged(e) {
    return true;
  }
  onLinesDeleted(e) {
    return true;
  }
  onLinesInserted(e) {
    return true;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return true;
  }
  _getDecorations(ctx) {
    const decorations = ctx.getDecorationsInViewport();
    let r = [], rLen = 0;
    for (let i = 0, len = decorations.length; i < len; i++) {
      const d = decorations[i];
      const glyphMarginClassName = d.options.glyphMarginClassName;
      if (glyphMarginClassName) {
        r[rLen++] = new DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, glyphMarginClassName);
      }
    }
    return r;
  }
  prepareRender(ctx) {
    if (!this._glyphMargin) {
      this._renderResult = null;
      return;
    }
    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;
    const visibleEndLineNumber = ctx.visibleRange.endLineNumber;
    const toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));
    const lineHeight = this._lineHeight.toString();
    const left = this._glyphMarginLeft.toString();
    const width = this._glyphMarginWidth.toString();
    const common = '" style="left:' + left + "px;width:" + width + "px;height:" + lineHeight + 'px;"></div>';
    const output = [];
    for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
      const lineIndex = lineNumber - visibleStartLineNumber;
      const classNames = toRender[lineIndex];
      if (classNames.length === 0) {
        output[lineIndex] = "";
      } else {
        output[lineIndex] = '<div class="cgmr codicon ' + classNames.join(" ") + common;
      }
    }
    this._renderResult = output;
  }
  render(startLineNumber, lineNumber) {
    if (!this._renderResult) {
      return "";
    }
    const lineIndex = lineNumber - startLineNumber;
    if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
      return "";
    }
    return this._renderResult[lineIndex];
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/indentGuides/indentGuides.js
var IndentGuidesOverlay = class extends DynamicViewOverlay {
  constructor(context) {
    super();
    this._context = context;
    this._primaryLineNumber = 0;
    const options = this._context.configuration.options;
    const wrappingInfo = options.get(118);
    const fontInfo = options.get(36);
    this._lineHeight = options.get(51);
    this._spaceWidth = fontInfo.spaceWidth;
    this._enabled = options.get(75);
    this._activeIndentEnabled = options.get(45);
    this._maxIndentLeft = wrappingInfo.wrappingColumn === -1 ? -1 : wrappingInfo.wrappingColumn * fontInfo.typicalHalfwidthCharacterWidth;
    this._renderResult = null;
    this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this);
    this._renderResult = null;
    super.dispose();
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    const wrappingInfo = options.get(118);
    const fontInfo = options.get(36);
    this._lineHeight = options.get(51);
    this._spaceWidth = fontInfo.spaceWidth;
    this._enabled = options.get(75);
    this._activeIndentEnabled = options.get(45);
    this._maxIndentLeft = wrappingInfo.wrappingColumn === -1 ? -1 : wrappingInfo.wrappingColumn * fontInfo.typicalHalfwidthCharacterWidth;
    return true;
  }
  onCursorStateChanged(e) {
    const selection = e.selections[0];
    const newPrimaryLineNumber = selection.isEmpty() ? selection.positionLineNumber : 0;
    if (this._primaryLineNumber !== newPrimaryLineNumber) {
      this._primaryLineNumber = newPrimaryLineNumber;
      return true;
    }
    return false;
  }
  onDecorationsChanged(e) {
    return true;
  }
  onFlushed(e) {
    return true;
  }
  onLinesChanged(e) {
    return true;
  }
  onLinesDeleted(e) {
    return true;
  }
  onLinesInserted(e) {
    return true;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return true;
  }
  onLanguageConfigurationChanged(e) {
    return true;
  }
  prepareRender(ctx) {
    if (!this._enabled) {
      this._renderResult = null;
      return;
    }
    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;
    const visibleEndLineNumber = ctx.visibleRange.endLineNumber;
    const {indentSize} = this._context.model.getTextModelOptions();
    const indentWidth = indentSize * this._spaceWidth;
    const scrollWidth = ctx.scrollWidth;
    const lineHeight = this._lineHeight;
    const indents = this._context.model.getLinesIndentGuides(visibleStartLineNumber, visibleEndLineNumber);
    let activeIndentStartLineNumber = 0;
    let activeIndentEndLineNumber = 0;
    let activeIndentLevel = 0;
    if (this._activeIndentEnabled && this._primaryLineNumber) {
      const activeIndentInfo = this._context.model.getActiveIndentGuide(this._primaryLineNumber, visibleStartLineNumber, visibleEndLineNumber);
      activeIndentStartLineNumber = activeIndentInfo.startLineNumber;
      activeIndentEndLineNumber = activeIndentInfo.endLineNumber;
      activeIndentLevel = activeIndentInfo.indent;
    }
    const output = [];
    for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
      const containsActiveIndentGuide = activeIndentStartLineNumber <= lineNumber && lineNumber <= activeIndentEndLineNumber;
      const lineIndex = lineNumber - visibleStartLineNumber;
      const indent = indents[lineIndex];
      let result = "";
      if (indent >= 1) {
        const leftMostVisiblePosition = ctx.visibleRangeForPosition(new Position(lineNumber, 1));
        let left = leftMostVisiblePosition ? leftMostVisiblePosition.left : 0;
        for (let i = 1; i <= indent; i++) {
          const className = containsActiveIndentGuide && i === activeIndentLevel ? "cigra" : "cigr";
          result += `<div class="${className}" style="left:${left}px;height:${lineHeight}px;width:${indentWidth}px"></div>`;
          left += indentWidth;
          if (left > scrollWidth || this._maxIndentLeft > 0 && left > this._maxIndentLeft) {
            break;
          }
        }
      }
      output[lineIndex] = result;
    }
    this._renderResult = output;
  }
  render(startLineNumber, lineNumber) {
    if (!this._renderResult) {
      return "";
    }
    const lineIndex = lineNumber - startLineNumber;
    if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
      return "";
    }
    return this._renderResult[lineIndex];
  }
};
registerThemingParticipant((theme, collector) => {
  const editorIndentGuidesColor = theme.getColor(editorIndentGuides);
  if (editorIndentGuidesColor) {
    collector.addRule(`.monaco-editor .lines-content .cigr { box-shadow: 1px 0 0 0 ${editorIndentGuidesColor} inset; }`);
  }
  const editorActiveIndentGuidesColor = theme.getColor(editorActiveIndentGuides) || editorIndentGuidesColor;
  if (editorActiveIndentGuidesColor) {
    collector.addRule(`.monaco-editor .lines-content .cigra { box-shadow: 1px 0 0 0 ${editorActiveIndentGuidesColor} inset; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLines.js
var LastRenderedData = class {
  constructor() {
    this._currentVisibleRange = new Range(1, 1, 1, 1);
  }
  getCurrentVisibleRange() {
    return this._currentVisibleRange;
  }
  setCurrentVisibleRange(currentVisibleRange) {
    this._currentVisibleRange = currentVisibleRange;
  }
};
var HorizontalRevealRangeRequest = class {
  constructor(lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {
    this.lineNumber = lineNumber;
    this.startColumn = startColumn;
    this.endColumn = endColumn;
    this.startScrollTop = startScrollTop;
    this.stopScrollTop = stopScrollTop;
    this.scrollType = scrollType;
    this.type = "range";
    this.minLineNumber = lineNumber;
    this.maxLineNumber = lineNumber;
  }
};
var HorizontalRevealSelectionsRequest = class {
  constructor(selections, startScrollTop, stopScrollTop, scrollType) {
    this.selections = selections;
    this.startScrollTop = startScrollTop;
    this.stopScrollTop = stopScrollTop;
    this.scrollType = scrollType;
    this.type = "selections";
    let minLineNumber = selections[0].startLineNumber;
    let maxLineNumber = selections[0].endLineNumber;
    for (let i = 1, len = selections.length; i < len; i++) {
      const selection = selections[i];
      minLineNumber = Math.min(minLineNumber, selection.startLineNumber);
      maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);
    }
    this.minLineNumber = minLineNumber;
    this.maxLineNumber = maxLineNumber;
  }
};
var ViewLines = class extends ViewPart {
  constructor(context, linesContent) {
    super(context);
    this._linesContent = linesContent;
    this._textRangeRestingSpot = document.createElement("div");
    this._visibleLines = new VisibleLinesCollection(this);
    this.domNode = this._visibleLines.domNode;
    const conf = this._context.configuration;
    const options = this._context.configuration.options;
    const fontInfo = options.get(36);
    const wrappingInfo = options.get(118);
    this._lineHeight = options.get(51);
    this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;
    this._isViewportWrapping = wrappingInfo.isViewportWrapping;
    this._revealHorizontalRightPadding = options.get(81);
    this._cursorSurroundingLines = options.get(20);
    this._cursorSurroundingLinesStyle = options.get(21);
    this._canUseLayerHinting = !options.get(23);
    this._viewLineOptions = new ViewLineOptions(conf, this._context.theme.type);
    PartFingerprints.write(this.domNode, 7);
    this.domNode.setClassName(`view-lines ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);
    Configuration2.applyFontInfo(this.domNode, fontInfo);
    this._maxLineWidth = 0;
    this._asyncUpdateLineWidths = new RunOnceScheduler(() => {
      this._updateLineWidthsSlow();
    }, 200);
    this._asyncCheckMonospaceFontAssumptions = new RunOnceScheduler(() => {
      this._checkMonospaceFontAssumptions();
    }, 2e3);
    this._lastRenderedData = new LastRenderedData();
    this._horizontalRevealRequest = null;
  }
  dispose() {
    this._asyncUpdateLineWidths.dispose();
    this._asyncCheckMonospaceFontAssumptions.dispose();
    super.dispose();
  }
  getDomNode() {
    return this.domNode;
  }
  createVisibleLine() {
    return new ViewLine(this._viewLineOptions);
  }
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e);
    if (e.hasChanged(118)) {
      this._maxLineWidth = 0;
    }
    const options = this._context.configuration.options;
    const fontInfo = options.get(36);
    const wrappingInfo = options.get(118);
    this._lineHeight = options.get(51);
    this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;
    this._isViewportWrapping = wrappingInfo.isViewportWrapping;
    this._revealHorizontalRightPadding = options.get(81);
    this._cursorSurroundingLines = options.get(20);
    this._cursorSurroundingLinesStyle = options.get(21);
    this._canUseLayerHinting = !options.get(23);
    Configuration2.applyFontInfo(this.domNode, fontInfo);
    this._onOptionsMaybeChanged();
    if (e.hasChanged(117)) {
      this._maxLineWidth = 0;
    }
    return true;
  }
  _onOptionsMaybeChanged() {
    const conf = this._context.configuration;
    const newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);
    if (!this._viewLineOptions.equals(newViewLineOptions)) {
      this._viewLineOptions = newViewLineOptions;
      const startLineNumber = this._visibleLines.getStartLineNumber();
      const endLineNumber = this._visibleLines.getEndLineNumber();
      for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
        const line = this._visibleLines.getVisibleLine(lineNumber);
        line.onOptionsChanged(this._viewLineOptions);
      }
      return true;
    }
    return false;
  }
  onCursorStateChanged(e) {
    const rendStartLineNumber = this._visibleLines.getStartLineNumber();
    const rendEndLineNumber = this._visibleLines.getEndLineNumber();
    let r = false;
    for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
      r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;
    }
    return r;
  }
  onDecorationsChanged(e) {
    if (true) {
      const rendStartLineNumber = this._visibleLines.getStartLineNumber();
      const rendEndLineNumber = this._visibleLines.getEndLineNumber();
      for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
        this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();
      }
    }
    return true;
  }
  onFlushed(e) {
    const shouldRender = this._visibleLines.onFlushed(e);
    this._maxLineWidth = 0;
    return shouldRender;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onRevealRangeRequest(e) {
    const desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.range, e.selections, e.verticalType);
    if (desiredScrollTop === -1) {
      return false;
    }
    let newScrollPosition = this._context.viewLayout.validateScrollPosition({scrollTop: desiredScrollTop});
    if (e.revealHorizontal) {
      if (e.range && e.range.startLineNumber !== e.range.endLineNumber) {
        newScrollPosition = {
          scrollTop: newScrollPosition.scrollTop,
          scrollLeft: 0
        };
      } else if (e.range) {
        this._horizontalRevealRequest = new HorizontalRevealRangeRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);
      } else if (e.selections && e.selections.length > 0) {
        this._horizontalRevealRequest = new HorizontalRevealSelectionsRequest(e.selections, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);
      }
    } else {
      this._horizontalRevealRequest = null;
    }
    const scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);
    const scrollType = scrollTopDelta <= this._lineHeight ? 1 : e.scrollType;
    this._context.model.setScrollPosition(newScrollPosition, scrollType);
    return true;
  }
  onScrollChanged(e) {
    if (this._horizontalRevealRequest && e.scrollLeftChanged) {
      this._horizontalRevealRequest = null;
    }
    if (this._horizontalRevealRequest && e.scrollTopChanged) {
      const min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
      const max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
      if (e.scrollTop < min || e.scrollTop > max) {
        this._horizontalRevealRequest = null;
      }
    }
    this.domNode.setWidth(e.scrollWidth);
    return this._visibleLines.onScrollChanged(e) || true;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    this._context.model.setMaxLineWidth(this._maxLineWidth);
    return this._visibleLines.onZonesChanged(e);
  }
  onThemeChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  getPositionFromDOMInfo(spanNode, offset) {
    const viewLineDomNode = this._getViewLineDomNode(spanNode);
    if (viewLineDomNode === null) {
      return null;
    }
    const lineNumber = this._getLineNumberFor(viewLineDomNode);
    if (lineNumber === -1) {
      return null;
    }
    if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {
      return null;
    }
    if (this._context.model.getLineMaxColumn(lineNumber) === 1) {
      return new Position(lineNumber, 1);
    }
    const rendStartLineNumber = this._visibleLines.getStartLineNumber();
    const rendEndLineNumber = this._visibleLines.getEndLineNumber();
    if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
      return null;
    }
    let column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);
    const minColumn = this._context.model.getLineMinColumn(lineNumber);
    if (column < minColumn) {
      column = minColumn;
    }
    return new Position(lineNumber, column);
  }
  _getViewLineDomNode(node) {
    while (node && node.nodeType === 1) {
      if (node.className === ViewLine.CLASS_NAME) {
        return node;
      }
      node = node.parentElement;
    }
    return null;
  }
  _getLineNumberFor(domNode) {
    const startLineNumber = this._visibleLines.getStartLineNumber();
    const endLineNumber = this._visibleLines.getEndLineNumber();
    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      const line = this._visibleLines.getVisibleLine(lineNumber);
      if (domNode === line.getDomNode()) {
        return lineNumber;
      }
    }
    return -1;
  }
  getLineWidth(lineNumber) {
    const rendStartLineNumber = this._visibleLines.getStartLineNumber();
    const rendEndLineNumber = this._visibleLines.getEndLineNumber();
    if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
      return -1;
    }
    return this._visibleLines.getVisibleLine(lineNumber).getWidth();
  }
  linesVisibleRangesForRange(_range, includeNewLines) {
    if (this.shouldRender()) {
      return null;
    }
    const originalEndLineNumber = _range.endLineNumber;
    const range2 = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());
    if (!range2) {
      return null;
    }
    let visibleRanges = [], visibleRangesLen = 0;
    const domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);
    let nextLineModelLineNumber = 0;
    if (includeNewLines) {
      nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(range2.startLineNumber, 1)).lineNumber;
    }
    const rendStartLineNumber = this._visibleLines.getStartLineNumber();
    const rendEndLineNumber = this._visibleLines.getEndLineNumber();
    for (let lineNumber = range2.startLineNumber; lineNumber <= range2.endLineNumber; lineNumber++) {
      if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
        continue;
      }
      const startColumn = lineNumber === range2.startLineNumber ? range2.startColumn : 1;
      const endColumn = lineNumber === range2.endLineNumber ? range2.endColumn : this._context.model.getLineMaxColumn(lineNumber);
      const visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);
      if (!visibleRangesForLine) {
        continue;
      }
      if (includeNewLines && lineNumber < originalEndLineNumber) {
        const currentLineModelLineNumber = nextLineModelLineNumber;
        nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;
        if (currentLineModelLineNumber !== nextLineModelLineNumber) {
          visibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth;
        }
      }
      visibleRanges[visibleRangesLen++] = new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, visibleRangesForLine.ranges);
    }
    if (visibleRangesLen === 0) {
      return null;
    }
    return visibleRanges;
  }
  _visibleRangesForLineRange(lineNumber, startColumn, endColumn) {
    if (this.shouldRender()) {
      return null;
    }
    if (lineNumber < this._visibleLines.getStartLineNumber() || lineNumber > this._visibleLines.getEndLineNumber()) {
      return null;
    }
    return this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot));
  }
  visibleRangeForPosition(position) {
    const visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);
    if (!visibleRanges) {
      return null;
    }
    return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);
  }
  updateLineWidths() {
    this._updateLineWidths(false);
  }
  _updateLineWidthsFast() {
    return this._updateLineWidths(true);
  }
  _updateLineWidthsSlow() {
    this._updateLineWidths(false);
  }
  _updateLineWidths(fast) {
    const rendStartLineNumber = this._visibleLines.getStartLineNumber();
    const rendEndLineNumber = this._visibleLines.getEndLineNumber();
    let localMaxLineWidth = 1;
    let allWidthsComputed = true;
    for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
      const visibleLine = this._visibleLines.getVisibleLine(lineNumber);
      if (fast && !visibleLine.getWidthIsFast()) {
        allWidthsComputed = false;
        continue;
      }
      localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());
    }
    if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {
      this._maxLineWidth = 0;
    }
    this._ensureMaxLineWidth(localMaxLineWidth);
    return allWidthsComputed;
  }
  _checkMonospaceFontAssumptions() {
    let longestLineNumber = -1;
    let longestWidth = -1;
    const rendStartLineNumber = this._visibleLines.getStartLineNumber();
    const rendEndLineNumber = this._visibleLines.getEndLineNumber();
    for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
      const visibleLine = this._visibleLines.getVisibleLine(lineNumber);
      if (visibleLine.needsMonospaceFontCheck()) {
        const lineWidth = visibleLine.getWidth();
        if (lineWidth > longestWidth) {
          longestWidth = lineWidth;
          longestLineNumber = lineNumber;
        }
      }
    }
    if (longestLineNumber === -1) {
      return;
    }
    if (!this._visibleLines.getVisibleLine(longestLineNumber).monospaceAssumptionsAreValid()) {
      for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
        const visibleLine = this._visibleLines.getVisibleLine(lineNumber);
        visibleLine.onMonospaceAssumptionsInvalidated();
      }
    }
  }
  prepareRender() {
    throw new Error("Not supported");
  }
  render() {
    throw new Error("Not supported");
  }
  renderText(viewportData) {
    this._visibleLines.renderLines(viewportData);
    this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);
    this.domNode.setWidth(this._context.viewLayout.getScrollWidth());
    this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1e6));
    if (this._horizontalRevealRequest) {
      const horizontalRevealRequest = this._horizontalRevealRequest;
      if (viewportData.startLineNumber <= horizontalRevealRequest.minLineNumber && horizontalRevealRequest.maxLineNumber <= viewportData.endLineNumber) {
        this._horizontalRevealRequest = null;
        this.onDidRender();
        const newScrollLeft = this._computeScrollLeftToReveal(horizontalRevealRequest);
        if (newScrollLeft) {
          if (!this._isViewportWrapping) {
            this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);
          }
          this._context.model.setScrollPosition({
            scrollLeft: newScrollLeft.scrollLeft
          }, horizontalRevealRequest.scrollType);
        }
      }
    }
    if (!this._updateLineWidthsFast()) {
      this._asyncUpdateLineWidths.schedule();
    }
    if (isLinux && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {
      const rendStartLineNumber = this._visibleLines.getStartLineNumber();
      const rendEndLineNumber = this._visibleLines.getEndLineNumber();
      for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
        const visibleLine = this._visibleLines.getVisibleLine(lineNumber);
        if (visibleLine.needsMonospaceFontCheck()) {
          this._asyncCheckMonospaceFontAssumptions.schedule();
          break;
        }
      }
    }
    this._linesContent.setLayerHinting(this._canUseLayerHinting);
    this._linesContent.setContain("strict");
    const adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;
    this._linesContent.setTop(-adjustedScrollTop);
    this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());
  }
  _ensureMaxLineWidth(lineWidth) {
    const iLineWidth = Math.ceil(lineWidth);
    if (this._maxLineWidth < iLineWidth) {
      this._maxLineWidth = iLineWidth;
      this._context.model.setMaxLineWidth(this._maxLineWidth);
    }
  }
  _computeScrollTopToRevealRange(viewport, source, range2, selections, verticalType) {
    const viewportStartY = viewport.top;
    const viewportHeight = viewport.height;
    const viewportEndY = viewportStartY + viewportHeight;
    let boxIsSingleRange;
    let boxStartY;
    let boxEndY;
    if (selections && selections.length > 0) {
      let minLineNumber = selections[0].startLineNumber;
      let maxLineNumber = selections[0].endLineNumber;
      for (let i = 1, len = selections.length; i < len; i++) {
        const selection = selections[i];
        minLineNumber = Math.min(minLineNumber, selection.startLineNumber);
        maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);
      }
      boxIsSingleRange = false;
      boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(minLineNumber);
      boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(maxLineNumber) + this._lineHeight;
    } else if (range2) {
      boxIsSingleRange = true;
      boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range2.startLineNumber);
      boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range2.endLineNumber) + this._lineHeight;
    } else {
      return -1;
    }
    const shouldIgnoreScrollOff = source === "mouse" && this._cursorSurroundingLinesStyle === "default";
    if (!shouldIgnoreScrollOff) {
      const context = Math.min(viewportHeight / this._lineHeight / 2, this._cursorSurroundingLines);
      boxStartY -= context * this._lineHeight;
      boxEndY += Math.max(0, context - 1) * this._lineHeight;
    }
    if (verticalType === 0 || verticalType === 4) {
      boxEndY += this._lineHeight;
    }
    let newScrollTop;
    if (boxEndY - boxStartY > viewportHeight) {
      if (!boxIsSingleRange) {
        return -1;
      }
      newScrollTop = boxStartY;
    } else if (verticalType === 5 || verticalType === 6) {
      if (verticalType === 6 && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {
        newScrollTop = viewportStartY;
      } else {
        const desiredGapAbove = Math.max(5 * this._lineHeight, viewportHeight * 0.2);
        const desiredScrollTop = boxStartY - desiredGapAbove;
        const minScrollTop = boxEndY - viewportHeight;
        newScrollTop = Math.max(minScrollTop, desiredScrollTop);
      }
    } else if (verticalType === 1 || verticalType === 2) {
      if (verticalType === 2 && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {
        newScrollTop = viewportStartY;
      } else {
        const boxMiddleY = (boxStartY + boxEndY) / 2;
        newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);
      }
    } else {
      newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3, verticalType === 4);
    }
    return newScrollTop;
  }
  _computeScrollLeftToReveal(horizontalRevealRequest) {
    const viewport = this._context.viewLayout.getCurrentViewport();
    const viewportStartX = viewport.left;
    const viewportEndX = viewportStartX + viewport.width;
    let boxStartX = 1073741824;
    let boxEndX = 0;
    if (horizontalRevealRequest.type === "range") {
      const visibleRanges = this._visibleRangesForLineRange(horizontalRevealRequest.lineNumber, horizontalRevealRequest.startColumn, horizontalRevealRequest.endColumn);
      if (!visibleRanges) {
        return null;
      }
      for (const visibleRange of visibleRanges.ranges) {
        boxStartX = Math.min(boxStartX, visibleRange.left);
        boxEndX = Math.max(boxEndX, visibleRange.left + visibleRange.width);
      }
    } else {
      for (const selection of horizontalRevealRequest.selections) {
        if (selection.startLineNumber !== selection.endLineNumber) {
          return null;
        }
        const visibleRanges = this._visibleRangesForLineRange(selection.startLineNumber, selection.startColumn, selection.endColumn);
        if (!visibleRanges) {
          return null;
        }
        for (const visibleRange of visibleRanges.ranges) {
          boxStartX = Math.min(boxStartX, visibleRange.left);
          boxEndX = Math.max(boxEndX, visibleRange.left + visibleRange.width);
        }
      }
    }
    boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);
    boxEndX += this._revealHorizontalRightPadding;
    if (horizontalRevealRequest.type === "selections" && boxEndX - boxStartX > viewport.width) {
      return null;
    }
    const newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);
    return {
      scrollLeft: newScrollLeft,
      maxHorizontalOffset: boxEndX
    };
  }
  _computeMinimumScrolling(viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {
    viewportStart = viewportStart | 0;
    viewportEnd = viewportEnd | 0;
    boxStart = boxStart | 0;
    boxEnd = boxEnd | 0;
    revealAtStart = !!revealAtStart;
    revealAtEnd = !!revealAtEnd;
    const viewportLength = viewportEnd - viewportStart;
    const boxLength = boxEnd - boxStart;
    if (boxLength < viewportLength) {
      if (revealAtStart) {
        return boxStart;
      }
      if (revealAtEnd) {
        return Math.max(0, boxEnd - viewportLength);
      }
      if (boxStart < viewportStart) {
        return boxStart;
      } else if (boxEnd > viewportEnd) {
        return Math.max(0, boxEnd - viewportLength);
      }
    } else {
      return boxStart;
    }
    return viewportStart;
  }
};
ViewLines.HORIZONTAL_EXTRA_PX = 30;

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/linesDecorations/linesDecorations.js
var LinesDecorationsOverlay = class extends DedupOverlay {
  constructor(context) {
    super();
    this._context = context;
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._decorationsLeft = layoutInfo.decorationsLeft;
    this._decorationsWidth = layoutInfo.decorationsWidth;
    this._renderResult = null;
    this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this);
    this._renderResult = null;
    super.dispose();
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._decorationsLeft = layoutInfo.decorationsLeft;
    this._decorationsWidth = layoutInfo.decorationsWidth;
    return true;
  }
  onDecorationsChanged(e) {
    return true;
  }
  onFlushed(e) {
    return true;
  }
  onLinesChanged(e) {
    return true;
  }
  onLinesDeleted(e) {
    return true;
  }
  onLinesInserted(e) {
    return true;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return true;
  }
  _getDecorations(ctx) {
    const decorations = ctx.getDecorationsInViewport();
    let r = [], rLen = 0;
    for (let i = 0, len = decorations.length; i < len; i++) {
      const d = decorations[i];
      const linesDecorationsClassName = d.options.linesDecorationsClassName;
      if (linesDecorationsClassName) {
        r[rLen++] = new DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, linesDecorationsClassName);
      }
      const firstLineDecorationClassName = d.options.firstLineDecorationClassName;
      if (firstLineDecorationClassName) {
        r[rLen++] = new DecorationToRender(d.range.startLineNumber, d.range.startLineNumber, firstLineDecorationClassName);
      }
    }
    return r;
  }
  prepareRender(ctx) {
    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;
    const visibleEndLineNumber = ctx.visibleRange.endLineNumber;
    const toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));
    const left = this._decorationsLeft.toString();
    const width = this._decorationsWidth.toString();
    const common = '" style="left:' + left + "px;width:" + width + 'px;"></div>';
    const output = [];
    for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
      const lineIndex = lineNumber - visibleStartLineNumber;
      const classNames = toRender[lineIndex];
      let lineOutput = "";
      for (let i = 0, len = classNames.length; i < len; i++) {
        lineOutput += '<div class="cldr ' + classNames[i] + common;
      }
      output[lineIndex] = lineOutput;
    }
    this._renderResult = output;
  }
  render(startLineNumber, lineNumber) {
    if (!this._renderResult) {
      return "";
    }
    return this._renderResult[lineNumber - startLineNumber];
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/marginDecorations/marginDecorations.js
var MarginViewLineDecorationsOverlay = class extends DedupOverlay {
  constructor(context) {
    super();
    this._context = context;
    this._renderResult = null;
    this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this);
    this._renderResult = null;
    super.dispose();
  }
  onConfigurationChanged(e) {
    return true;
  }
  onDecorationsChanged(e) {
    return true;
  }
  onFlushed(e) {
    return true;
  }
  onLinesChanged(e) {
    return true;
  }
  onLinesDeleted(e) {
    return true;
  }
  onLinesInserted(e) {
    return true;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return true;
  }
  _getDecorations(ctx) {
    const decorations = ctx.getDecorationsInViewport();
    let r = [], rLen = 0;
    for (let i = 0, len = decorations.length; i < len; i++) {
      const d = decorations[i];
      const marginClassName = d.options.marginClassName;
      if (marginClassName) {
        r[rLen++] = new DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, marginClassName);
      }
    }
    return r;
  }
  prepareRender(ctx) {
    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;
    const visibleEndLineNumber = ctx.visibleRange.endLineNumber;
    const toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));
    const output = [];
    for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
      const lineIndex = lineNumber - visibleStartLineNumber;
      const classNames = toRender[lineIndex];
      let lineOutput = "";
      for (let i = 0, len = classNames.length; i < len; i++) {
        lineOutput += '<div class="cmdr ' + classNames[i] + '" style=""></div>';
      }
      output[lineIndex] = lineOutput;
    }
    this._renderResult = output;
  }
  render(startLineNumber, lineNumber) {
    if (!this._renderResult) {
      return "";
    }
    return this._renderResult[lineNumber - startLineNumber];
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/core/rgba.js
var RGBA8 = class {
  constructor(r, g, b, a) {
    this.r = RGBA8._clamp(r);
    this.g = RGBA8._clamp(g);
    this.b = RGBA8._clamp(b);
    this.a = RGBA8._clamp(a);
  }
  equals(other) {
    return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
  }
  static _clamp(c) {
    if (c < 0) {
      return 0;
    }
    if (c > 255) {
      return 255;
    }
    return c | 0;
  }
};
RGBA8.Empty = new RGBA8(0, 0, 0, 0);

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/minimapTokensColorTracker.js
var MinimapTokensColorTracker = class {
  constructor() {
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._updateColorMap();
    TokenizationRegistry.onDidChange((e) => {
      if (e.changedColorMap) {
        this._updateColorMap();
      }
    });
  }
  static getInstance() {
    if (!this._INSTANCE) {
      this._INSTANCE = new MinimapTokensColorTracker();
    }
    return this._INSTANCE;
  }
  _updateColorMap() {
    const colorMap = TokenizationRegistry.getColorMap();
    if (!colorMap) {
      this._colors = [RGBA8.Empty];
      this._backgroundIsLight = true;
      return;
    }
    this._colors = [RGBA8.Empty];
    for (let colorId = 1; colorId < colorMap.length; colorId++) {
      const source = colorMap[colorId].rgba;
      this._colors[colorId] = new RGBA8(source.r, source.g, source.b, Math.round(source.a * 255));
    }
    let backgroundLuminosity = colorMap[2].getRelativeLuminance();
    this._backgroundIsLight = backgroundLuminosity >= 0.5;
    this._onDidChange.fire(void 0);
  }
  getColor(colorId) {
    if (colorId < 1 || colorId >= this._colors.length) {
      colorId = 2;
    }
    return this._colors[colorId];
  }
  backgroundIsLight() {
    return this._backgroundIsLight;
  }
};
MinimapTokensColorTracker._INSTANCE = null;

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimapCharSheet.js
var allCharCodes = (() => {
  const v = [];
  for (let i = 32; i <= 126; i++) {
    v.push(i);
  }
  v.push(65533);
  return v;
})();
var getCharIndex = (chCode, fontScale) => {
  chCode -= 32;
  if (chCode < 0 || chCode > 96) {
    if (fontScale <= 2) {
      return (chCode + 96) % 96;
    }
    return 96 - 1;
  }
  return chCode;
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimapCharRenderer.js
var MinimapCharRenderer = class {
  constructor(charData, scale) {
    this.scale = scale;
    this.charDataNormal = MinimapCharRenderer.soften(charData, 12 / 15);
    this.charDataLight = MinimapCharRenderer.soften(charData, 50 / 60);
  }
  static soften(input, ratio) {
    let result = new Uint8ClampedArray(input.length);
    for (let i = 0, len = input.length; i < len; i++) {
      result[i] = toUint8(input[i] * ratio);
    }
    return result;
  }
  renderChar(target, dx, dy, chCode, color, backgroundColor, fontScale, useLighterFont, force1pxHeight) {
    const charWidth = 1 * this.scale;
    const charHeight = 2 * this.scale;
    const renderHeight = force1pxHeight ? 1 : charHeight;
    if (dx + charWidth > target.width || dy + renderHeight > target.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const charData = useLighterFont ? this.charDataLight : this.charDataNormal;
    const charIndex = getCharIndex(chCode, fontScale);
    const destWidth = target.width * 4;
    const backgroundR = backgroundColor.r;
    const backgroundG = backgroundColor.g;
    const backgroundB = backgroundColor.b;
    const deltaR = color.r - backgroundR;
    const deltaG = color.g - backgroundG;
    const deltaB = color.b - backgroundB;
    const dest = target.data;
    let sourceOffset = charIndex * charWidth * charHeight;
    let row = dy * destWidth + dx * 4;
    for (let y = 0; y < renderHeight; y++) {
      let column = row;
      for (let x = 0; x < charWidth; x++) {
        const c = charData[sourceOffset++] / 255;
        dest[column++] = backgroundR + deltaR * c;
        dest[column++] = backgroundG + deltaG * c;
        dest[column++] = backgroundB + deltaB * c;
        column++;
      }
      row += destWidth;
    }
  }
  blockRenderChar(target, dx, dy, color, backgroundColor, useLighterFont, force1pxHeight) {
    const charWidth = 1 * this.scale;
    const charHeight = 2 * this.scale;
    const renderHeight = force1pxHeight ? 1 : charHeight;
    if (dx + charWidth > target.width || dy + renderHeight > target.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const destWidth = target.width * 4;
    const c = 0.5;
    const backgroundR = backgroundColor.r;
    const backgroundG = backgroundColor.g;
    const backgroundB = backgroundColor.b;
    const deltaR = color.r - backgroundR;
    const deltaG = color.g - backgroundG;
    const deltaB = color.b - backgroundB;
    const colorR = backgroundR + deltaR * c;
    const colorG = backgroundG + deltaG * c;
    const colorB = backgroundB + deltaB * c;
    const dest = target.data;
    let row = dy * destWidth + dx * 4;
    for (let y = 0; y < renderHeight; y++) {
      let column = row;
      for (let x = 0; x < charWidth; x++) {
        dest[column++] = colorR;
        dest[column++] = colorG;
        dest[column++] = colorB;
        column++;
      }
      row += destWidth;
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/functional.js
function once2(fn) {
  const _this = this;
  let didCall = false;
  let result;
  return function() {
    if (didCall) {
      return result;
    }
    didCall = true;
    result = fn.apply(_this, arguments);
    return result;
  };
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimapPreBaked.js
var charTable = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
};
var decodeData = (str) => {
  const output = new Uint8ClampedArray(str.length / 2);
  for (let i = 0; i < str.length; i += 2) {
    output[i >> 1] = charTable[str[i]] << 4 | charTable[str[i + 1]] & 15;
  }
  return output;
};
var prebakedMiniMaps = {
  1: once2(() => decodeData("0000511D6300CF609C709645A78432005642574171487021003C451900274D35D762755E8B629C5BA856AF57BA649530C167D1512A272A3F6038604460398526BCA2A968DB6F8957C768BE5FBE2FB467CF5D8D5B795DC7625B5DFF50DE64C466DB2FC47CD860A65E9A2EB96CB54CE06DA763AB2EA26860524D3763536601005116008177A8705E53AB738E6A982F88BAA35B5F5B626D9C636B449B737E5B7B678598869A662F6B5B8542706C704C80736A607578685B70594A49715A4522E792")),
  2: once2(() => decodeData("000000000000000055394F383D2800008B8B1F210002000081B1CBCBCC820000847AAF6B9AAF2119BE08B8881AD60000A44FD07DCCF107015338130C00000000385972265F390B406E2437634B4B48031B12B8A0847000001E15B29A402F0000000000004B33460B00007A752C2A0000000000004D3900000084394B82013400ABA5CFC7AD9C0302A45A3E5A98AB000089A43382D97900008BA54AA087A70A0248A6A7AE6DBE0000BF6F94987EA40A01A06DCFA7A7A9030496C32F77891D0000A99FB1A0AFA80603B29AB9CA75930D010C0948354D3900000C0948354F37460D0028BE673D8400000000AF9D7B6E00002B007AA8933400007AA642675C2700007984CFB9C3985B768772A8A6B7B20000CAAECAAFC4B700009F94A6009F840009D09F9BA4CA9C0000CC8FC76DC87F0000C991C472A2000000A894A48CA7B501079BA2C9C69BA20000B19A5D3FA89000005CA6009DA2960901B0A7F0669FB200009D009E00B7890000DAD0F5D092820000D294D4C48BD10000B5A7A4A3B1A50402CAB6CBA6A2000000B5A7A4A3B1A8044FCDADD19D9CB00000B7778F7B8AAE0803C9AB5D3F5D3F00009EA09EA0BAB006039EA0989A8C7900009B9EF4D6B7C00000A9A7816CACA80000ABAC84705D3F000096DA635CDC8C00006F486F266F263D4784006124097B00374F6D2D6D2D6D4A3A95872322000000030000000000008D8939130000000000002E22A5C9CBC70600AB25C0B5C9B400061A2DB04CA67001082AA6BEBEBFC606002321DACBC19E03087AA08B6768380000282FBAC0B8CA7A88AD25BBA5A29900004C396C5894A6000040485A6E356E9442A32CD17EADA70000B4237923628600003E2DE9C1D7B500002F25BBA5A2990000231DB6AFB4A804023025C0B5CAB588062B2CBDBEC0C706882435A75CA20000002326BD6A82A908048B4B9A5A668000002423A09CB4BB060025259C9D8A7900001C1FCAB2C7C700002A2A9387ABA200002626A4A47D6E9D14333163A0C87500004B6F9C2D643A257049364936493647358A34438355497F1A0000A24C1D590000D38DFFBDD4CD3126"))
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimapCharRendererFactory.js
var MinimapCharRendererFactory = class {
  static create(scale, fontFamily) {
    if (this.lastCreated && scale === this.lastCreated.scale && fontFamily === this.lastFontFamily) {
      return this.lastCreated;
    }
    let factory;
    if (prebakedMiniMaps[scale]) {
      factory = new MinimapCharRenderer(prebakedMiniMaps[scale](), scale);
    } else {
      factory = MinimapCharRendererFactory.createFromSampleData(MinimapCharRendererFactory.createSampleData(fontFamily).data, scale);
    }
    this.lastFontFamily = fontFamily;
    this.lastCreated = factory;
    return factory;
  }
  static createSampleData(fontFamily) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.style.height = `${16}px`;
    canvas.height = 16;
    canvas.width = 96 * 10;
    canvas.style.width = 96 * 10 + "px";
    ctx.fillStyle = "#ffffff";
    ctx.font = `bold ${16}px ${fontFamily}`;
    ctx.textBaseline = "middle";
    let x = 0;
    for (const code of allCharCodes) {
      ctx.fillText(String.fromCharCode(code), x, 16 / 2);
      x += 10;
    }
    return ctx.getImageData(0, 0, 96 * 10, 16);
  }
  static createFromSampleData(source, scale) {
    const expectedLength = 16 * 10 * 4 * 96;
    if (source.length !== expectedLength) {
      throw new Error("Unexpected source in MinimapCharRenderer");
    }
    let charData = MinimapCharRendererFactory._downsample(source, scale);
    return new MinimapCharRenderer(charData, scale);
  }
  static _downsampleChar(source, sourceOffset, dest, destOffset, scale) {
    const width = 1 * scale;
    const height = 2 * scale;
    let targetIndex = destOffset;
    let brightest = 0;
    for (let y = 0; y < height; y++) {
      const sourceY1 = y / height * 16;
      const sourceY2 = (y + 1) / height * 16;
      for (let x = 0; x < width; x++) {
        const sourceX1 = x / width * 10;
        const sourceX2 = (x + 1) / width * 10;
        let value = 0;
        let samples = 0;
        for (let sy = sourceY1; sy < sourceY2; sy++) {
          const sourceRow = sourceOffset + Math.floor(sy) * 3840;
          const yBalance = 1 - (sy - Math.floor(sy));
          for (let sx = sourceX1; sx < sourceX2; sx++) {
            const xBalance = 1 - (sx - Math.floor(sx));
            const sourceIndex = sourceRow + Math.floor(sx) * 4;
            const weight = xBalance * yBalance;
            samples += weight;
            value += source[sourceIndex] * source[sourceIndex + 3] / 255 * weight;
          }
        }
        const final = value / samples;
        brightest = Math.max(brightest, final);
        dest[targetIndex++] = toUint8(final);
      }
    }
    return brightest;
  }
  static _downsample(data, scale) {
    const pixelsPerCharacter = 2 * scale * 1 * scale;
    const resultLen = pixelsPerCharacter * 96;
    const result = new Uint8ClampedArray(resultLen);
    let resultOffset = 0;
    let sourceOffset = 0;
    let brightest = 0;
    for (let charIndex = 0; charIndex < 96; charIndex++) {
      brightest = Math.max(brightest, this._downsampleChar(data, sourceOffset, result, resultOffset, scale));
      resultOffset += pixelsPerCharacter;
      sourceOffset += 10 * 4;
    }
    if (brightest > 0) {
      const adjust = 255 / brightest;
      for (let i = 0; i < resultLen; i++) {
        result[i] *= adjust;
      }
    }
    return result;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimap.js
var MOUSE_DRAG_RESET_DISTANCE2 = 140;
var GUTTER_DECORATION_WIDTH = 2;
var MinimapOptions = class {
  constructor(configuration, theme, tokensColorTracker) {
    const options = configuration.options;
    const pixelRatio = options.get(115);
    const layoutInfo = options.get(117);
    const minimapLayout = layoutInfo.minimap;
    const fontInfo = options.get(36);
    const minimapOpts = options.get(56);
    this.renderMinimap = minimapLayout.renderMinimap;
    this.size = minimapOpts.size;
    this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;
    this.scrollBeyondLastLine = options.get(86);
    this.showSlider = minimapOpts.showSlider;
    this.pixelRatio = pixelRatio;
    this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;
    this.lineHeight = options.get(51);
    this.minimapLeft = minimapLayout.minimapLeft;
    this.minimapWidth = minimapLayout.minimapWidth;
    this.minimapHeight = layoutInfo.height;
    this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;
    this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;
    this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;
    this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;
    this.isSampling = minimapLayout.minimapIsSampling;
    this.editorHeight = layoutInfo.height;
    this.fontScale = minimapLayout.minimapScale;
    this.minimapLineHeight = minimapLayout.minimapLineHeight;
    this.minimapCharWidth = 1 * this.fontScale;
    this.charRenderer = once2(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));
    this.backgroundColor = MinimapOptions._getMinimapBackground(theme, tokensColorTracker);
  }
  static _getMinimapBackground(theme, tokensColorTracker) {
    const themeColor = theme.getColor(minimapBackground);
    if (themeColor) {
      return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, themeColor.rgba.a);
    }
    return tokensColorTracker.getColor(2);
  }
  equals(other) {
    return this.renderMinimap === other.renderMinimap && this.size === other.size && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === other.scrollBeyondLastLine && this.showSlider === other.showSlider && this.pixelRatio === other.pixelRatio && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth && this.lineHeight === other.lineHeight && this.minimapLeft === other.minimapLeft && this.minimapWidth === other.minimapWidth && this.minimapHeight === other.minimapHeight && this.canvasInnerWidth === other.canvasInnerWidth && this.canvasInnerHeight === other.canvasInnerHeight && this.canvasOuterWidth === other.canvasOuterWidth && this.canvasOuterHeight === other.canvasOuterHeight && this.isSampling === other.isSampling && this.editorHeight === other.editorHeight && this.fontScale === other.fontScale && this.minimapLineHeight === other.minimapLineHeight && this.minimapCharWidth === other.minimapCharWidth && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor);
  }
};
var MinimapLayout = class {
  constructor(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber) {
    this.scrollTop = scrollTop;
    this.scrollHeight = scrollHeight;
    this.sliderNeeded = sliderNeeded;
    this._computedSliderRatio = computedSliderRatio;
    this.sliderTop = sliderTop;
    this.sliderHeight = sliderHeight;
    this.startLineNumber = startLineNumber;
    this.endLineNumber = endLineNumber;
  }
  getDesiredScrollTopFromDelta(delta) {
    const desiredSliderPosition = this.sliderTop + delta;
    return Math.round(desiredSliderPosition / this._computedSliderRatio);
  }
  getDesiredScrollTopFromTouchLocation(pageY) {
    return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);
  }
  static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {
    const pixelRatio = options.pixelRatio;
    const minimapLineHeight = options.minimapLineHeight;
    const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);
    const lineHeight = options.lineHeight;
    if (options.minimapHeightIsEditorHeight) {
      const logicalScrollHeight = realLineCount * options.lineHeight + (options.scrollBeyondLastLine ? viewportHeight - options.lineHeight : 0);
      const sliderHeight2 = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));
      const maxMinimapSliderTop2 = Math.max(0, options.minimapHeight - sliderHeight2);
      const computedSliderRatio2 = maxMinimapSliderTop2 / (scrollHeight - viewportHeight);
      const sliderTop2 = scrollTop * computedSliderRatio2;
      const sliderNeeded = maxMinimapSliderTop2 > 0;
      const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);
      return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio2, sliderTop2, sliderHeight2, 1, Math.min(lineCount, maxLinesFitting));
    }
    let sliderHeight;
    if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {
      const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;
      sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);
    } else {
      const expectedViewportLineCount = viewportHeight / lineHeight;
      sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);
    }
    let maxMinimapSliderTop;
    if (options.scrollBeyondLastLine) {
      maxMinimapSliderTop = (lineCount - 1) * minimapLineHeight / pixelRatio;
    } else {
      maxMinimapSliderTop = Math.max(0, lineCount * minimapLineHeight / pixelRatio - sliderHeight);
    }
    maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);
    const computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);
    const sliderTop = scrollTop * computedSliderRatio;
    let extraLinesAtTheBottom = 0;
    if (options.scrollBeyondLastLine) {
      const expectedViewportLineCount = viewportHeight / lineHeight;
      extraLinesAtTheBottom = expectedViewportLineCount - 1;
    }
    if (minimapLinesFitting >= lineCount + extraLinesAtTheBottom) {
      const startLineNumber = 1;
      const endLineNumber = lineCount;
      const sliderNeeded = maxMinimapSliderTop > 0;
      return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);
    } else {
      let startLineNumber = Math.max(1, Math.floor(viewportStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));
      if (previousLayout && previousLayout.scrollHeight === scrollHeight) {
        if (previousLayout.scrollTop > scrollTop) {
          startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);
        }
        if (previousLayout.scrollTop < scrollTop) {
          startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);
        }
      }
      const endLineNumber = Math.min(lineCount, startLineNumber + minimapLinesFitting - 1);
      return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);
    }
  }
};
var MinimapLine = class {
  constructor(dy) {
    this.dy = dy;
  }
  onContentChanged() {
    this.dy = -1;
  }
  onTokensChanged() {
    this.dy = -1;
  }
};
MinimapLine.INVALID = new MinimapLine(-1);
var RenderData = class {
  constructor(renderedLayout, imageData, lines) {
    this.renderedLayout = renderedLayout;
    this._imageData = imageData;
    this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);
    this._renderedLines._set(renderedLayout.startLineNumber, lines);
  }
  linesEquals(layout2) {
    if (!this.scrollEquals(layout2)) {
      return false;
    }
    const tmp = this._renderedLines._get();
    const lines = tmp.lines;
    for (let i = 0, len = lines.length; i < len; i++) {
      if (lines[i].dy === -1) {
        return false;
      }
    }
    return true;
  }
  scrollEquals(layout2) {
    return this.renderedLayout.startLineNumber === layout2.startLineNumber && this.renderedLayout.endLineNumber === layout2.endLineNumber;
  }
  _get() {
    const tmp = this._renderedLines._get();
    return {
      imageData: this._imageData,
      rendLineNumberStart: tmp.rendLineNumberStart,
      lines: tmp.lines
    };
  }
  onLinesChanged(changeFromLineNumber, changeToLineNumber) {
    return this._renderedLines.onLinesChanged(changeFromLineNumber, changeToLineNumber);
  }
  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {
    this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);
  }
  onLinesInserted(insertFromLineNumber, insertToLineNumber) {
    this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);
  }
  onTokensChanged(ranges) {
    return this._renderedLines.onTokensChanged(ranges);
  }
};
var MinimapBuffers = class {
  constructor(ctx, WIDTH, HEIGHT, background) {
    this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);
    this._buffers = [
      ctx.createImageData(WIDTH, HEIGHT),
      ctx.createImageData(WIDTH, HEIGHT)
    ];
    this._lastUsedBuffer = 0;
  }
  getBuffer() {
    this._lastUsedBuffer = 1 - this._lastUsedBuffer;
    const result = this._buffers[this._lastUsedBuffer];
    result.data.set(this._backgroundFillData);
    return result;
  }
  static _createBackgroundFillData(WIDTH, HEIGHT, background) {
    const backgroundR = background.r;
    const backgroundG = background.g;
    const backgroundB = background.b;
    const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);
    let offset = 0;
    for (let i = 0; i < HEIGHT; i++) {
      for (let j = 0; j < WIDTH; j++) {
        result[offset] = backgroundR;
        result[offset + 1] = backgroundG;
        result[offset + 2] = backgroundB;
        result[offset + 3] = 255;
        offset += 4;
      }
    }
    return result;
  }
};
var MinimapSamplingState = class {
  constructor(samplingRatio, minimapLines) {
    this.samplingRatio = samplingRatio;
    this.minimapLines = minimapLines;
  }
  static compute(options, viewLineCount, oldSamplingState) {
    if (options.renderMinimap === 0 || !options.isSampling) {
      return [null, []];
    }
    const pixelRatio = options.pixelRatio;
    const lineHeight = options.lineHeight;
    const scrollBeyondLastLine = options.scrollBeyondLastLine;
    const {minimapLineCount} = EditorLayoutInfoComputer.computeContainedMinimapLineCount({
      viewLineCount,
      scrollBeyondLastLine,
      height: options.editorHeight,
      lineHeight,
      pixelRatio
    });
    const ratio = viewLineCount / minimapLineCount;
    const halfRatio = ratio / 2;
    if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {
      let result2 = [];
      result2[0] = 1;
      if (minimapLineCount > 1) {
        for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {
          result2[i] = Math.round(i * ratio + halfRatio);
        }
        result2[minimapLineCount - 1] = viewLineCount;
      }
      return [new MinimapSamplingState(ratio, result2), []];
    }
    const oldMinimapLines = oldSamplingState.minimapLines;
    const oldLength = oldMinimapLines.length;
    let result = [];
    let oldIndex = 0;
    let oldDeltaLineCount = 0;
    let minViewLineNumber = 1;
    const MAX_EVENT_COUNT = 10;
    let events = [];
    let lastEvent = null;
    for (let i = 0; i < minimapLineCount; i++) {
      const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));
      const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));
      while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {
        if (events.length < MAX_EVENT_COUNT) {
          const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;
          if (lastEvent && lastEvent.type === "deleted" && lastEvent._oldIndex === oldIndex - 1) {
            lastEvent.deleteToLineNumber++;
          } else {
            lastEvent = {type: "deleted", _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber};
            events.push(lastEvent);
          }
          oldDeltaLineCount--;
        }
        oldIndex++;
      }
      let selectedViewLineNumber;
      if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {
        selectedViewLineNumber = oldMinimapLines[oldIndex];
        oldIndex++;
      } else {
        if (i === 0) {
          selectedViewLineNumber = 1;
        } else if (i + 1 === minimapLineCount) {
          selectedViewLineNumber = viewLineCount;
        } else {
          selectedViewLineNumber = Math.round(i * ratio + halfRatio);
        }
        if (events.length < MAX_EVENT_COUNT) {
          const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;
          if (lastEvent && lastEvent.type === "inserted" && lastEvent._i === i - 1) {
            lastEvent.insertToLineNumber++;
          } else {
            lastEvent = {type: "inserted", _i: i, insertFromLineNumber: oldMinimapLineNumber, insertToLineNumber: oldMinimapLineNumber};
            events.push(lastEvent);
          }
          oldDeltaLineCount++;
        }
      }
      result[i] = selectedViewLineNumber;
      minViewLineNumber = selectedViewLineNumber;
    }
    if (events.length < MAX_EVENT_COUNT) {
      while (oldIndex < oldLength) {
        const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;
        if (lastEvent && lastEvent.type === "deleted" && lastEvent._oldIndex === oldIndex - 1) {
          lastEvent.deleteToLineNumber++;
        } else {
          lastEvent = {type: "deleted", _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber};
          events.push(lastEvent);
        }
        oldDeltaLineCount--;
        oldIndex++;
      }
    } else {
      events = [{type: "flush"}];
    }
    return [new MinimapSamplingState(ratio, result), events];
  }
  modelLineToMinimapLine(lineNumber) {
    return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));
  }
  modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {
    let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;
    while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {
      fromLineIndex--;
    }
    let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;
    while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {
      toLineIndex++;
    }
    if (fromLineIndex === toLineIndex) {
      const sampledLineNumber = this.minimapLines[fromLineIndex];
      if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {
        return null;
      }
    }
    return [fromLineIndex + 1, toLineIndex + 1];
  }
  decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {
    let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);
    let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);
    if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {
      if (minimapLineEnd === this.minimapLines.length) {
        if (minimapLineStart > 1) {
          minimapLineStart--;
        }
      } else {
        minimapLineEnd++;
      }
    }
    return [minimapLineStart, minimapLineEnd];
  }
  onLinesDeleted(e) {
    const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;
    let changeStartIndex = this.minimapLines.length;
    let changeEndIndex = 0;
    for (let i = this.minimapLines.length - 1; i >= 0; i--) {
      if (this.minimapLines[i] < e.fromLineNumber) {
        break;
      }
      if (this.minimapLines[i] <= e.toLineNumber) {
        this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);
        changeStartIndex = Math.min(changeStartIndex, i);
        changeEndIndex = Math.max(changeEndIndex, i);
      } else {
        this.minimapLines[i] -= deletedLineCount;
      }
    }
    return [changeStartIndex, changeEndIndex];
  }
  onLinesInserted(e) {
    const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;
    for (let i = this.minimapLines.length - 1; i >= 0; i--) {
      if (this.minimapLines[i] < e.fromLineNumber) {
        break;
      }
      this.minimapLines[i] += insertedLineCount;
    }
  }
};
var Minimap = class extends ViewPart {
  constructor(context) {
    super(context);
    this.tokensColorTracker = MinimapTokensColorTracker.getInstance();
    this._selections = [];
    this._minimapSelections = null;
    this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);
    const [samplingState] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), null);
    this._samplingState = samplingState;
    this._shouldCheckSampling = false;
    this._actual = new InnerMinimap(context.theme, this);
  }
  dispose() {
    this._actual.dispose();
    super.dispose();
  }
  getDomNode() {
    return this._actual.getDomNode();
  }
  _onOptionsMaybeChanged() {
    const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);
    if (this.options.equals(opts)) {
      return false;
    }
    this.options = opts;
    this._recreateLineSampling();
    this._actual.onDidChangeOptions();
    return true;
  }
  onConfigurationChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  onCursorStateChanged(e) {
    this._selections = e.selections;
    this._minimapSelections = null;
    return this._actual.onSelectionChanged();
  }
  onDecorationsChanged(e) {
    if (e.affectsMinimap) {
      return this._actual.onDecorationsChanged();
    }
    return false;
  }
  onFlushed(e) {
    if (this._samplingState) {
      this._shouldCheckSampling = true;
    }
    return this._actual.onFlushed();
  }
  onLinesChanged(e) {
    if (this._samplingState) {
      const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.toLineNumber);
      if (minimapLineRange) {
        return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1]);
      } else {
        return false;
      }
    } else {
      return this._actual.onLinesChanged(e.fromLineNumber, e.toLineNumber);
    }
  }
  onLinesDeleted(e) {
    if (this._samplingState) {
      const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);
      if (changeStartIndex <= changeEndIndex) {
        this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex + 1);
      }
      this._shouldCheckSampling = true;
      return true;
    } else {
      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
    }
  }
  onLinesInserted(e) {
    if (this._samplingState) {
      this._samplingState.onLinesInserted(e);
      this._shouldCheckSampling = true;
      return true;
    } else {
      return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);
    }
  }
  onScrollChanged(e) {
    return this._actual.onScrollChanged();
  }
  onThemeChanged(e) {
    this._context.model.invalidateMinimapColorCache();
    this._actual.onThemeChanged();
    this._onOptionsMaybeChanged();
    return true;
  }
  onTokensChanged(e) {
    if (this._samplingState) {
      let ranges = [];
      for (const range2 of e.ranges) {
        const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range2.fromLineNumber, range2.toLineNumber);
        if (minimapLineRange) {
          ranges.push({fromLineNumber: minimapLineRange[0], toLineNumber: minimapLineRange[1]});
        }
      }
      if (ranges.length) {
        return this._actual.onTokensChanged(ranges);
      } else {
        return false;
      }
    } else {
      return this._actual.onTokensChanged(e.ranges);
    }
  }
  onTokensColorsChanged(e) {
    return this._actual.onTokensColorsChanged();
  }
  onZonesChanged(e) {
    return this._actual.onZonesChanged();
  }
  prepareRender(ctx) {
    if (this._shouldCheckSampling) {
      this._shouldCheckSampling = false;
      this._recreateLineSampling();
    }
  }
  render(ctx) {
    let viewportStartLineNumber = ctx.visibleRange.startLineNumber;
    let viewportEndLineNumber = ctx.visibleRange.endLineNumber;
    if (this._samplingState) {
      viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);
      viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);
    }
    const minimapCtx = {
      viewportContainsWhitespaceGaps: ctx.viewportData.whitespaceViewportData.length > 0,
      scrollWidth: ctx.scrollWidth,
      scrollHeight: ctx.scrollHeight,
      viewportStartLineNumber,
      viewportEndLineNumber,
      scrollTop: ctx.scrollTop,
      scrollLeft: ctx.scrollLeft,
      viewportWidth: ctx.viewportWidth,
      viewportHeight: ctx.viewportHeight
    };
    this._actual.render(minimapCtx);
  }
  _recreateLineSampling() {
    this._minimapSelections = null;
    const wasSampling = Boolean(this._samplingState);
    const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), this._samplingState);
    this._samplingState = samplingState;
    if (wasSampling && this._samplingState) {
      for (const event of events) {
        switch (event.type) {
          case "deleted":
            this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);
            break;
          case "inserted":
            this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);
            break;
          case "flush":
            this._actual.onFlushed();
            break;
        }
      }
    }
  }
  getLineCount() {
    if (this._samplingState) {
      return this._samplingState.minimapLines.length;
    }
    return this._context.model.getLineCount();
  }
  getRealLineCount() {
    return this._context.model.getLineCount();
  }
  getLineContent(lineNumber) {
    if (this._samplingState) {
      return this._context.model.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);
    }
    return this._context.model.getLineContent(lineNumber);
  }
  getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {
    if (this._samplingState) {
      let result = [];
      for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {
        if (needed[lineIndex]) {
          result[lineIndex] = this._context.model.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);
        } else {
          result[lineIndex] = null;
        }
      }
      return result;
    }
    return this._context.model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;
  }
  getSelections() {
    if (this._minimapSelections === null) {
      if (this._samplingState) {
        this._minimapSelections = [];
        for (const selection of this._selections) {
          const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);
          this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));
        }
      } else {
        this._minimapSelections = this._selections;
      }
    }
    return this._minimapSelections;
  }
  getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {
    let visibleRange;
    if (this._samplingState) {
      const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];
      const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];
      visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.model.getLineMaxColumn(modelEndLineNumber));
    } else {
      visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.model.getLineMaxColumn(endLineNumber));
    }
    const decorations = this._context.model.getDecorationsInViewport(visibleRange);
    if (this._samplingState) {
      let result = [];
      for (const decoration of decorations) {
        if (!decoration.options.minimap) {
          continue;
        }
        const range2 = decoration.range;
        const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range2.startLineNumber);
        const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range2.endLineNumber);
        result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range2.startColumn, minimapEndLineNumber, range2.endColumn), decoration.options));
      }
      return result;
    }
    return decorations;
  }
  getOptions() {
    return this._context.model.getTextModelOptions();
  }
  revealLineNumber(lineNumber) {
    if (this._samplingState) {
      lineNumber = this._samplingState.minimapLines[lineNumber - 1];
    }
    this._context.model.revealRange("mouse", false, new Range(lineNumber, 1, lineNumber, 1), 1, 0);
  }
  setScrollTop(scrollTop) {
    this._context.model.setScrollPosition({
      scrollTop
    }, 1);
  }
};
var InnerMinimap = class extends Disposable {
  constructor(theme, model2) {
    super();
    this._renderDecorations = false;
    this._gestureInProgress = false;
    this._theme = theme;
    this._model = model2;
    this._lastRenderData = null;
    this._buffers = null;
    this._selectionColor = this._theme.getColor(minimapSelection);
    this._domNode = createFastDomNode(document.createElement("div"));
    PartFingerprints.write(this._domNode, 8);
    this._domNode.setClassName(this._getMinimapDomNodeClassName());
    this._domNode.setPosition("absolute");
    this._domNode.setAttribute("role", "presentation");
    this._domNode.setAttribute("aria-hidden", "true");
    this._shadow = createFastDomNode(document.createElement("div"));
    this._shadow.setClassName("minimap-shadow-hidden");
    this._domNode.appendChild(this._shadow);
    this._canvas = createFastDomNode(document.createElement("canvas"));
    this._canvas.setPosition("absolute");
    this._canvas.setLeft(0);
    this._domNode.appendChild(this._canvas);
    this._decorationsCanvas = createFastDomNode(document.createElement("canvas"));
    this._decorationsCanvas.setPosition("absolute");
    this._decorationsCanvas.setClassName("minimap-decorations-layer");
    this._decorationsCanvas.setLeft(0);
    this._domNode.appendChild(this._decorationsCanvas);
    this._slider = createFastDomNode(document.createElement("div"));
    this._slider.setPosition("absolute");
    this._slider.setClassName("minimap-slider");
    this._slider.setLayerHinting(true);
    this._slider.setContain("strict");
    this._domNode.appendChild(this._slider);
    this._sliderHorizontal = createFastDomNode(document.createElement("div"));
    this._sliderHorizontal.setPosition("absolute");
    this._sliderHorizontal.setClassName("minimap-slider-horizontal");
    this._slider.appendChild(this._sliderHorizontal);
    this._applyLayout();
    this._mouseDownListener = addStandardDisposableListener(this._domNode.domNode, "mousedown", (e) => {
      e.preventDefault();
      const renderMinimap = this._model.options.renderMinimap;
      if (renderMinimap === 0) {
        return;
      }
      if (!this._lastRenderData) {
        return;
      }
      if (this._model.options.size !== "proportional") {
        if (e.leftButton && this._lastRenderData) {
          const position = getDomNodePagePosition(this._slider.domNode);
          const initialPosY = position.top + position.height / 2;
          this._startSliderDragging(e.buttons, e.posx, initialPosY, e.posy, this._lastRenderData.renderedLayout);
        }
        return;
      }
      const minimapLineHeight = this._model.options.minimapLineHeight;
      const internalOffsetY = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * e.browserEvent.offsetY;
      const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);
      let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber;
      lineNumber = Math.min(lineNumber, this._model.getLineCount());
      this._model.revealLineNumber(lineNumber);
    });
    this._sliderMouseMoveMonitor = new GlobalMouseMoveMonitor();
    this._sliderMouseDownListener = addStandardDisposableListener(this._slider.domNode, "mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.leftButton && this._lastRenderData) {
        this._startSliderDragging(e.buttons, e.posx, e.posy, e.posy, this._lastRenderData.renderedLayout);
      }
    });
    this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);
    this._sliderTouchStartListener = addDisposableListener(this._domNode.domNode, EventType2.Start, (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (this._lastRenderData) {
        this._slider.toggleClassName("active", true);
        this._gestureInProgress = true;
        this.scrollDueToTouchEvent(e);
      }
    }, {passive: false});
    this._sliderTouchMoveListener = addDisposableListener(this._domNode.domNode, EventType2.Change, (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (this._lastRenderData && this._gestureInProgress) {
        this.scrollDueToTouchEvent(e);
      }
    }, {passive: false});
    this._sliderTouchEndListener = addStandardDisposableListener(this._domNode.domNode, EventType2.End, (e) => {
      e.preventDefault();
      e.stopPropagation();
      this._gestureInProgress = false;
      this._slider.toggleClassName("active", false);
    });
  }
  _startSliderDragging(initialButtons, initialPosX, initialPosY, posy, initialSliderState) {
    this._slider.toggleClassName("active", true);
    const handleMouseMove = (posy2, posx) => {
      const mouseOrthogonalDelta = Math.abs(posx - initialPosX);
      if (isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE2) {
        this._model.setScrollTop(initialSliderState.scrollTop);
        return;
      }
      const mouseDelta = posy2 - initialPosY;
      this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(mouseDelta));
    };
    if (posy !== initialPosY) {
      handleMouseMove(posy, initialPosX);
    }
    this._sliderMouseMoveMonitor.startMonitoring(this._slider.domNode, initialButtons, standardMouseMoveMerger, (mouseMoveData) => handleMouseMove(mouseMoveData.posy, mouseMoveData.posx), () => {
      this._slider.toggleClassName("active", false);
    });
  }
  scrollDueToTouchEvent(touch) {
    const startY = this._domNode.domNode.getBoundingClientRect().top;
    const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);
    this._model.setScrollTop(scrollTop);
  }
  dispose() {
    this._mouseDownListener.dispose();
    this._sliderMouseMoveMonitor.dispose();
    this._sliderMouseDownListener.dispose();
    this._gestureDisposable.dispose();
    this._sliderTouchStartListener.dispose();
    this._sliderTouchMoveListener.dispose();
    this._sliderTouchEndListener.dispose();
    super.dispose();
  }
  _getMinimapDomNodeClassName() {
    if (this._model.options.showSlider === "always") {
      return "minimap slider-always";
    }
    return "minimap slider-mouseover";
  }
  getDomNode() {
    return this._domNode;
  }
  _applyLayout() {
    this._domNode.setLeft(this._model.options.minimapLeft);
    this._domNode.setWidth(this._model.options.minimapWidth);
    this._domNode.setHeight(this._model.options.minimapHeight);
    this._shadow.setHeight(this._model.options.minimapHeight);
    this._canvas.setWidth(this._model.options.canvasOuterWidth);
    this._canvas.setHeight(this._model.options.canvasOuterHeight);
    this._canvas.domNode.width = this._model.options.canvasInnerWidth;
    this._canvas.domNode.height = this._model.options.canvasInnerHeight;
    this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);
    this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);
    this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;
    this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;
    this._slider.setWidth(this._model.options.minimapWidth);
  }
  _getBuffer() {
    if (!this._buffers) {
      if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {
        this._buffers = new MinimapBuffers(this._canvas.domNode.getContext("2d"), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);
      }
    }
    return this._buffers ? this._buffers.getBuffer() : null;
  }
  onDidChangeOptions() {
    this._lastRenderData = null;
    this._buffers = null;
    this._applyLayout();
    this._domNode.setClassName(this._getMinimapDomNodeClassName());
  }
  onSelectionChanged() {
    this._renderDecorations = true;
    return true;
  }
  onDecorationsChanged() {
    this._renderDecorations = true;
    return true;
  }
  onFlushed() {
    this._lastRenderData = null;
    return true;
  }
  onLinesChanged(changeFromLineNumber, changeToLineNumber) {
    if (this._lastRenderData) {
      return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeToLineNumber);
    }
    return false;
  }
  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {
    if (this._lastRenderData) {
      this._lastRenderData.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);
    }
    return true;
  }
  onLinesInserted(insertFromLineNumber, insertToLineNumber) {
    if (this._lastRenderData) {
      this._lastRenderData.onLinesInserted(insertFromLineNumber, insertToLineNumber);
    }
    return true;
  }
  onScrollChanged() {
    this._renderDecorations = true;
    return true;
  }
  onThemeChanged() {
    this._selectionColor = this._theme.getColor(minimapSelection);
    this._renderDecorations = true;
    return true;
  }
  onTokensChanged(ranges) {
    if (this._lastRenderData) {
      return this._lastRenderData.onTokensChanged(ranges);
    }
    return false;
  }
  onTokensColorsChanged() {
    this._lastRenderData = null;
    this._buffers = null;
    return true;
  }
  onZonesChanged() {
    this._lastRenderData = null;
    return true;
  }
  render(renderingCtx) {
    const renderMinimap = this._model.options.renderMinimap;
    if (renderMinimap === 0) {
      this._shadow.setClassName("minimap-shadow-hidden");
      this._sliderHorizontal.setWidth(0);
      this._sliderHorizontal.setHeight(0);
      return;
    }
    if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {
      this._shadow.setClassName("minimap-shadow-hidden");
    } else {
      this._shadow.setClassName("minimap-shadow-visible");
    }
    const layout2 = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);
    this._slider.setDisplay(layout2.sliderNeeded ? "block" : "none");
    this._slider.setTop(layout2.sliderTop);
    this._slider.setHeight(layout2.sliderHeight);
    const scrollLeftChars = renderingCtx.scrollLeft / this._model.options.typicalHalfwidthCharacterWidth;
    const horizontalSliderLeft = Math.min(this._model.options.minimapWidth, Math.round(scrollLeftChars * this._model.options.minimapCharWidth / this._model.options.pixelRatio));
    this._sliderHorizontal.setLeft(horizontalSliderLeft);
    this._sliderHorizontal.setWidth(this._model.options.minimapWidth - horizontalSliderLeft);
    this._sliderHorizontal.setTop(0);
    this._sliderHorizontal.setHeight(layout2.sliderHeight);
    this.renderDecorations(layout2);
    this._lastRenderData = this.renderLines(layout2);
  }
  renderDecorations(layout2) {
    if (this._renderDecorations) {
      this._renderDecorations = false;
      const selections = this._model.getSelections();
      const decorations = this._model.getMinimapDecorationsInViewport(layout2.startLineNumber, layout2.endLineNumber);
      const {canvasInnerWidth, canvasInnerHeight} = this._model.options;
      const lineHeight = this._model.options.minimapLineHeight;
      const characterWidth = this._model.options.minimapCharWidth;
      const tabSize = this._model.getOptions().tabSize;
      const canvasContext = this._decorationsCanvas.domNode.getContext("2d");
      canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);
      const lineOffsetMap = new Map();
      for (let i = 0; i < selections.length; i++) {
        const selection = selections[i];
        for (let line = selection.startLineNumber; line <= selection.endLineNumber; line++) {
          this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout2, line, lineHeight, lineHeight, tabSize, characterWidth);
        }
      }
      for (let i = 0; i < decorations.length; i++) {
        const decoration = decorations[i];
        if (!decoration.options.minimap) {
          continue;
        }
        const decorationColor = decoration.options.minimap.getColor(this._theme);
        for (let line = decoration.range.startLineNumber; line <= decoration.range.endLineNumber; line++) {
          switch (decoration.options.minimap.position) {
            case MinimapPosition2.Inline:
              this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout2, line, lineHeight, lineHeight, tabSize, characterWidth);
              continue;
            case MinimapPosition2.Gutter:
              const y = (line - layout2.startLineNumber) * lineHeight;
              const x = 2;
              this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, lineHeight);
              continue;
          }
        }
      }
    }
  }
  renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout2, lineNumber, height, lineHeight, tabSize, charWidth) {
    const y = (lineNumber - layout2.startLineNumber) * lineHeight;
    if (y + height < 0 || y > this._model.options.canvasInnerHeight) {
      return;
    }
    let lineIndexToXOffset = lineOffsetMap.get(lineNumber);
    const isFirstDecorationForLine = !lineIndexToXOffset;
    if (!lineIndexToXOffset) {
      const lineData = this._model.getLineContent(lineNumber);
      lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];
      for (let i = 1; i < lineData.length + 1; i++) {
        const charCode = lineData.charCodeAt(i - 1);
        const dx = charCode === 9 ? tabSize * charWidth : isFullWidthCharacter(charCode) ? 2 * charWidth : charWidth;
        lineIndexToXOffset[i] = lineIndexToXOffset[i - 1] + dx;
      }
      lineOffsetMap.set(lineNumber, lineIndexToXOffset);
    }
    const {startColumn, endColumn, startLineNumber, endLineNumber} = decorationRange;
    const x = startLineNumber === lineNumber ? lineIndexToXOffset[startColumn - 1] : MINIMAP_GUTTER_WIDTH;
    const endColumnForLine = endLineNumber > lineNumber ? lineIndexToXOffset.length - 1 : endColumn - 1;
    if (endColumnForLine > 0) {
      const width = lineIndexToXOffset[endColumnForLine] - x || 2;
      this.renderDecoration(canvasContext, decorationColor, x, y, width, height);
    }
    if (isFirstDecorationForLine) {
      this.renderLineHighlight(canvasContext, decorationColor, y, height);
    }
  }
  renderLineHighlight(canvasContext, decorationColor, y, height) {
    canvasContext.fillStyle = decorationColor && decorationColor.transparent(0.5).toString() || "";
    canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, height);
  }
  renderDecoration(canvasContext, decorationColor, x, y, width, height) {
    canvasContext.fillStyle = decorationColor && decorationColor.toString() || "";
    canvasContext.fillRect(x, y, width, height);
  }
  renderLines(layout2) {
    const startLineNumber = layout2.startLineNumber;
    const endLineNumber = layout2.endLineNumber;
    const minimapLineHeight = this._model.options.minimapLineHeight;
    if (this._lastRenderData && this._lastRenderData.linesEquals(layout2)) {
      const _lastData = this._lastRenderData._get();
      return new RenderData(layout2, _lastData.imageData, _lastData.lines);
    }
    const imageData = this._getBuffer();
    if (!imageData) {
      return null;
    }
    let [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);
    const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);
    const tabSize = this._model.getOptions().tabSize;
    const background = this._model.options.backgroundColor;
    const tokensColorTracker = this._model.tokensColorTracker;
    const useLighterFont = tokensColorTracker.backgroundIsLight();
    const renderMinimap = this._model.options.renderMinimap;
    const charRenderer = this._model.options.charRenderer();
    const fontScale = this._model.options.fontScale;
    const minimapCharWidth = this._model.options.minimapCharWidth;
    const baseCharHeight = renderMinimap === 1 ? 2 : 2 + 1;
    const renderMinimapLineHeight = baseCharHeight * fontScale;
    const innerLinePadding = minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0;
    let dy = 0;
    const renderedLines = [];
    for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {
      if (needed[lineIndex]) {
        InnerMinimap._renderLine(imageData, background, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);
      }
      renderedLines[lineIndex] = new MinimapLine(dy);
      dy += minimapLineHeight;
    }
    const dirtyY1 = _dirtyY1 === -1 ? 0 : _dirtyY1;
    const dirtyY2 = _dirtyY2 === -1 ? imageData.height : _dirtyY2;
    const dirtyHeight = dirtyY2 - dirtyY1;
    const ctx = this._canvas.domNode.getContext("2d");
    ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);
    return new RenderData(layout2, imageData, renderedLines);
  }
  static _renderUntouchedLines(target, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {
    const needed = [];
    if (!lastRenderData) {
      for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {
        needed[i] = true;
      }
      return [-1, -1, needed];
    }
    const _lastData = lastRenderData._get();
    const lastTargetData = _lastData.imageData.data;
    const lastStartLineNumber = _lastData.rendLineNumberStart;
    const lastLines = _lastData.lines;
    const lastLinesLength = lastLines.length;
    const WIDTH = target.width;
    const targetData = target.data;
    const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;
    let dirtyPixel1 = -1;
    let dirtyPixel2 = -1;
    let copySourceStart = -1;
    let copySourceEnd = -1;
    let copyDestStart = -1;
    let copyDestEnd = -1;
    let dest_dy = 0;
    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      const lineIndex = lineNumber - startLineNumber;
      const lastLineIndex = lineNumber - lastStartLineNumber;
      const source_dy = lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1;
      if (source_dy === -1) {
        needed[lineIndex] = true;
        dest_dy += minimapLineHeight;
        continue;
      }
      const sourceStart = source_dy * WIDTH * 4;
      const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;
      const destStart = dest_dy * WIDTH * 4;
      const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;
      if (copySourceEnd === sourceStart && copyDestEnd === destStart) {
        copySourceEnd = sourceEnd;
        copyDestEnd = destEnd;
      } else {
        if (copySourceStart !== -1) {
          targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);
          if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {
            dirtyPixel1 = copySourceEnd;
          }
          if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {
            dirtyPixel2 = copySourceStart;
          }
        }
        copySourceStart = sourceStart;
        copySourceEnd = sourceEnd;
        copyDestStart = destStart;
        copyDestEnd = destEnd;
      }
      needed[lineIndex] = false;
      dest_dy += minimapLineHeight;
    }
    if (copySourceStart !== -1) {
      targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);
      if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {
        dirtyPixel1 = copySourceEnd;
      }
      if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {
        dirtyPixel2 = copySourceStart;
      }
    }
    const dirtyY1 = dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4);
    const dirtyY2 = dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4);
    return [dirtyY1, dirtyY2, needed];
  }
  static _renderLine(target, backgroundColor, useLighterFont, renderMinimap, charWidth, colorTracker, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {
    const content = lineData.content;
    const tokens = lineData.tokens;
    const maxDx = target.width - charWidth;
    const force1pxHeight = minimapLineHeight === 1;
    let dx = MINIMAP_GUTTER_WIDTH;
    let charIndex = 0;
    let tabsCharDelta = 0;
    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {
      const tokenEndIndex = tokens.getEndOffset(tokenIndex);
      const tokenColorId = tokens.getForeground(tokenIndex);
      const tokenColor = colorTracker.getColor(tokenColorId);
      for (; charIndex < tokenEndIndex; charIndex++) {
        if (dx > maxDx) {
          return;
        }
        const charCode = content.charCodeAt(charIndex);
        if (charCode === 9) {
          const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
          tabsCharDelta += insertSpacesCount - 1;
          dx += insertSpacesCount * charWidth;
        } else if (charCode === 32) {
          dx += charWidth;
        } else {
          const count = isFullWidthCharacter(charCode) ? 2 : 1;
          for (let i = 0; i < count; i++) {
            if (renderMinimap === 2) {
              minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, backgroundColor, useLighterFont, force1pxHeight);
            } else {
              minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, backgroundColor, fontScale, useLighterFont, force1pxHeight);
            }
            dx += charWidth;
            if (dx > maxDx) {
              return;
            }
          }
        }
      }
    }
  }
};
registerThemingParticipant((theme, collector) => {
  const minimapBackgroundValue = theme.getColor(minimapBackground);
  if (minimapBackgroundValue) {
    collector.addRule(`.monaco-editor .minimap > canvas { opacity: ${minimapBackgroundValue.rgba.a}; will-change: opacity; }`);
  }
  const sliderBackground = theme.getColor(minimapSliderBackground);
  if (sliderBackground) {
    collector.addRule(`.monaco-editor .minimap-slider .minimap-slider-horizontal { background: ${sliderBackground}; }`);
  }
  const sliderHoverBackground = theme.getColor(minimapSliderHoverBackground);
  if (sliderHoverBackground) {
    collector.addRule(`.monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: ${sliderHoverBackground}; }`);
  }
  const sliderActiveBackground = theme.getColor(minimapSliderActiveBackground);
  if (sliderActiveBackground) {
    collector.addRule(`.monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: ${sliderActiveBackground}; }`);
  }
  const shadow = theme.getColor(scrollbarShadow);
  if (shadow) {
    collector.addRule(`.monaco-editor .minimap-shadow-visible { box-shadow: ${shadow} -6px 0 6px -6px inset; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/overlayWidgets/overlayWidgets.js
var ViewOverlayWidgets = class extends ViewPart {
  constructor(context) {
    super(context);
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._widgets = {};
    this._verticalScrollbarWidth = layoutInfo.verticalScrollbarWidth;
    this._minimapWidth = layoutInfo.minimap.minimapWidth;
    this._horizontalScrollbarHeight = layoutInfo.horizontalScrollbarHeight;
    this._editorHeight = layoutInfo.height;
    this._editorWidth = layoutInfo.width;
    this._domNode = createFastDomNode(document.createElement("div"));
    PartFingerprints.write(this._domNode, 4);
    this._domNode.setClassName("overlayWidgets");
  }
  dispose() {
    super.dispose();
    this._widgets = {};
  }
  getDomNode() {
    return this._domNode;
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._verticalScrollbarWidth = layoutInfo.verticalScrollbarWidth;
    this._minimapWidth = layoutInfo.minimap.minimapWidth;
    this._horizontalScrollbarHeight = layoutInfo.horizontalScrollbarHeight;
    this._editorHeight = layoutInfo.height;
    this._editorWidth = layoutInfo.width;
    return true;
  }
  addWidget(widget) {
    const domNode = createFastDomNode(widget.getDomNode());
    this._widgets[widget.getId()] = {
      widget,
      preference: null,
      domNode
    };
    domNode.setPosition("absolute");
    domNode.setAttribute("widgetId", widget.getId());
    this._domNode.appendChild(domNode);
    this.setShouldRender();
  }
  setWidgetPosition(widget, preference) {
    const widgetData = this._widgets[widget.getId()];
    if (widgetData.preference === preference) {
      return false;
    }
    widgetData.preference = preference;
    this.setShouldRender();
    return true;
  }
  removeWidget(widget) {
    const widgetId = widget.getId();
    if (this._widgets.hasOwnProperty(widgetId)) {
      const widgetData = this._widgets[widgetId];
      const domNode = widgetData.domNode.domNode;
      delete this._widgets[widgetId];
      domNode.parentNode.removeChild(domNode);
      this.setShouldRender();
    }
  }
  _renderWidget(widgetData) {
    const domNode = widgetData.domNode;
    if (widgetData.preference === null) {
      domNode.unsetTop();
      return;
    }
    if (widgetData.preference === 0) {
      domNode.setTop(0);
      domNode.setRight(2 * this._verticalScrollbarWidth + this._minimapWidth);
    } else if (widgetData.preference === 1) {
      const widgetHeight = domNode.domNode.clientHeight;
      domNode.setTop(this._editorHeight - widgetHeight - 2 * this._horizontalScrollbarHeight);
      domNode.setRight(2 * this._verticalScrollbarWidth + this._minimapWidth);
    } else if (widgetData.preference === 2) {
      domNode.setTop(0);
      domNode.domNode.style.right = "50%";
    }
  }
  prepareRender(ctx) {
  }
  render(ctx) {
    this._domNode.setWidth(this._editorWidth);
    const keys = Object.keys(this._widgets);
    for (let i = 0, len = keys.length; i < len; i++) {
      const widgetId = keys[i];
      this._renderWidget(this._widgets[widgetId]);
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/overviewRuler/decorationsOverviewRuler.js
var Settings = class {
  constructor(config, theme) {
    const options = config.options;
    this.lineHeight = options.get(51);
    this.pixelRatio = options.get(115);
    this.overviewRulerLanes = options.get(65);
    this.renderBorder = options.get(64);
    const borderColor = theme.getColor(editorOverviewRulerBorder);
    this.borderColor = borderColor ? borderColor.toString() : null;
    this.hideCursor = options.get(44);
    const cursorColor = theme.getColor(editorCursorForeground);
    this.cursorColor = cursorColor ? cursorColor.transparent(0.7).toString() : null;
    this.themeType = theme.type;
    const minimapOpts = options.get(56);
    const minimapEnabled = minimapOpts.enabled;
    const minimapSide = minimapOpts.side;
    const backgroundColor = minimapEnabled ? theme.getColor(editorOverviewRulerBackground) || TokenizationRegistry.getDefaultBackground() : null;
    if (backgroundColor === null || minimapSide === "left") {
      this.backgroundColor = null;
    } else {
      this.backgroundColor = Color.Format.CSS.formatHex(backgroundColor);
    }
    const layoutInfo = options.get(117);
    const position = layoutInfo.overviewRuler;
    this.top = position.top;
    this.right = position.right;
    this.domWidth = position.width;
    this.domHeight = position.height;
    if (this.overviewRulerLanes === 0) {
      this.canvasWidth = 0;
      this.canvasHeight = 0;
    } else {
      this.canvasWidth = this.domWidth * this.pixelRatio | 0;
      this.canvasHeight = this.domHeight * this.pixelRatio | 0;
    }
    const [x, w] = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes);
    this.x = x;
    this.w = w;
  }
  _initLanes(canvasLeftOffset, canvasWidth, laneCount) {
    const remainingWidth = canvasWidth - canvasLeftOffset;
    if (laneCount >= 3) {
      const leftWidth = Math.floor(remainingWidth / 3);
      const rightWidth = Math.floor(remainingWidth / 3);
      const centerWidth = remainingWidth - leftWidth - rightWidth;
      const leftOffset = canvasLeftOffset;
      const centerOffset = leftOffset + leftWidth;
      const rightOffset = leftOffset + leftWidth + centerWidth;
      return [
        [
          0,
          leftOffset,
          centerOffset,
          leftOffset,
          rightOffset,
          leftOffset,
          centerOffset,
          leftOffset
        ],
        [
          0,
          leftWidth,
          centerWidth,
          leftWidth + centerWidth,
          rightWidth,
          leftWidth + centerWidth + rightWidth,
          centerWidth + rightWidth,
          leftWidth + centerWidth + rightWidth
        ]
      ];
    } else if (laneCount === 2) {
      const leftWidth = Math.floor(remainingWidth / 2);
      const rightWidth = remainingWidth - leftWidth;
      const leftOffset = canvasLeftOffset;
      const rightOffset = leftOffset + leftWidth;
      return [
        [
          0,
          leftOffset,
          leftOffset,
          leftOffset,
          rightOffset,
          leftOffset,
          leftOffset,
          leftOffset
        ],
        [
          0,
          leftWidth,
          leftWidth,
          leftWidth,
          rightWidth,
          leftWidth + rightWidth,
          leftWidth + rightWidth,
          leftWidth + rightWidth
        ]
      ];
    } else {
      const offset = canvasLeftOffset;
      const width = remainingWidth;
      return [
        [
          0,
          offset,
          offset,
          offset,
          offset,
          offset,
          offset,
          offset
        ],
        [
          0,
          width,
          width,
          width,
          width,
          width,
          width,
          width
        ]
      ];
    }
  }
  equals(other) {
    return this.lineHeight === other.lineHeight && this.pixelRatio === other.pixelRatio && this.overviewRulerLanes === other.overviewRulerLanes && this.renderBorder === other.renderBorder && this.borderColor === other.borderColor && this.hideCursor === other.hideCursor && this.cursorColor === other.cursorColor && this.themeType === other.themeType && this.backgroundColor === other.backgroundColor && this.top === other.top && this.right === other.right && this.domWidth === other.domWidth && this.domHeight === other.domHeight && this.canvasWidth === other.canvasWidth && this.canvasHeight === other.canvasHeight;
  }
};
var DecorationsOverviewRuler = class extends ViewPart {
  constructor(context) {
    super(context);
    this._domNode = createFastDomNode(document.createElement("canvas"));
    this._domNode.setClassName("decorationsOverviewRuler");
    this._domNode.setPosition("absolute");
    this._domNode.setLayerHinting(true);
    this._domNode.setContain("strict");
    this._domNode.setAttribute("aria-hidden", "true");
    this._updateSettings(false);
    this._tokensColorTrackerListener = TokenizationRegistry.onDidChange((e) => {
      if (e.changedColorMap) {
        this._updateSettings(true);
      }
    });
    this._cursorPositions = [];
  }
  dispose() {
    super.dispose();
    this._tokensColorTrackerListener.dispose();
  }
  _updateSettings(renderNow) {
    const newSettings = new Settings(this._context.configuration, this._context.theme);
    if (this._settings && this._settings.equals(newSettings)) {
      return false;
    }
    this._settings = newSettings;
    this._domNode.setTop(this._settings.top);
    this._domNode.setRight(this._settings.right);
    this._domNode.setWidth(this._settings.domWidth);
    this._domNode.setHeight(this._settings.domHeight);
    this._domNode.domNode.width = this._settings.canvasWidth;
    this._domNode.domNode.height = this._settings.canvasHeight;
    if (renderNow) {
      this._render();
    }
    return true;
  }
  onConfigurationChanged(e) {
    return this._updateSettings(false);
  }
  onCursorStateChanged(e) {
    this._cursorPositions = [];
    for (let i = 0, len = e.selections.length; i < len; i++) {
      this._cursorPositions[i] = e.selections[i].getPosition();
    }
    this._cursorPositions.sort(Position.compare);
    return true;
  }
  onDecorationsChanged(e) {
    if (e.affectsOverviewRuler) {
      return true;
    }
    return false;
  }
  onFlushed(e) {
    return true;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged;
  }
  onZonesChanged(e) {
    return true;
  }
  onThemeChanged(e) {
    this._context.model.invalidateOverviewRulerColorCache();
    return this._updateSettings(false);
  }
  getDomNode() {
    return this._domNode.domNode;
  }
  prepareRender(ctx) {
  }
  render(editorCtx) {
    this._render();
  }
  _render() {
    if (this._settings.overviewRulerLanes === 0) {
      this._domNode.setBackgroundColor(this._settings.backgroundColor ? this._settings.backgroundColor : "");
      return;
    }
    const canvasWidth = this._settings.canvasWidth;
    const canvasHeight = this._settings.canvasHeight;
    const lineHeight = this._settings.lineHeight;
    const viewLayout = this._context.viewLayout;
    const outerHeight = this._context.viewLayout.getScrollHeight();
    const heightRatio = canvasHeight / outerHeight;
    const decorations = this._context.model.getAllOverviewRulerDecorations(this._context.theme);
    const minDecorationHeight = 6 * this._settings.pixelRatio | 0;
    const halfMinDecorationHeight = minDecorationHeight / 2 | 0;
    const canvasCtx = this._domNode.domNode.getContext("2d");
    if (this._settings.backgroundColor === null) {
      canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
    } else {
      canvasCtx.fillStyle = this._settings.backgroundColor;
      canvasCtx.fillRect(0, 0, canvasWidth, canvasHeight);
    }
    const x = this._settings.x;
    const w = this._settings.w;
    const colors = Object.keys(decorations);
    colors.sort();
    for (let cIndex = 0, cLen = colors.length; cIndex < cLen; cIndex++) {
      const color = colors[cIndex];
      const colorDecorations = decorations[color];
      canvasCtx.fillStyle = color;
      let prevLane = 0;
      let prevY1 = 0;
      let prevY2 = 0;
      for (let i = 0, len = colorDecorations.length; i < len; i++) {
        const lane = colorDecorations[3 * i];
        const startLineNumber = colorDecorations[3 * i + 1];
        const endLineNumber = colorDecorations[3 * i + 2];
        let y1 = viewLayout.getVerticalOffsetForLineNumber(startLineNumber) * heightRatio | 0;
        let y2 = (viewLayout.getVerticalOffsetForLineNumber(endLineNumber) + lineHeight) * heightRatio | 0;
        const height = y2 - y1;
        if (height < minDecorationHeight) {
          let yCenter = (y1 + y2) / 2 | 0;
          if (yCenter < halfMinDecorationHeight) {
            yCenter = halfMinDecorationHeight;
          } else if (yCenter + halfMinDecorationHeight > canvasHeight) {
            yCenter = canvasHeight - halfMinDecorationHeight;
          }
          y1 = yCenter - halfMinDecorationHeight;
          y2 = yCenter + halfMinDecorationHeight;
        }
        if (y1 > prevY2 + 1 || lane !== prevLane) {
          if (i !== 0) {
            canvasCtx.fillRect(x[prevLane], prevY1, w[prevLane], prevY2 - prevY1);
          }
          prevLane = lane;
          prevY1 = y1;
          prevY2 = y2;
        } else {
          if (y2 > prevY2) {
            prevY2 = y2;
          }
        }
      }
      canvasCtx.fillRect(x[prevLane], prevY1, w[prevLane], prevY2 - prevY1);
    }
    if (!this._settings.hideCursor && this._settings.cursorColor) {
      const cursorHeight = 2 * this._settings.pixelRatio | 0;
      const halfCursorHeight = cursorHeight / 2 | 0;
      const cursorX = this._settings.x[7];
      const cursorW = this._settings.w[7];
      canvasCtx.fillStyle = this._settings.cursorColor;
      let prevY1 = -100;
      let prevY2 = -100;
      for (let i = 0, len = this._cursorPositions.length; i < len; i++) {
        const cursor = this._cursorPositions[i];
        let yCenter = viewLayout.getVerticalOffsetForLineNumber(cursor.lineNumber) * heightRatio | 0;
        if (yCenter < halfCursorHeight) {
          yCenter = halfCursorHeight;
        } else if (yCenter + halfCursorHeight > canvasHeight) {
          yCenter = canvasHeight - halfCursorHeight;
        }
        const y1 = yCenter - halfCursorHeight;
        const y2 = y1 + cursorHeight;
        if (y1 > prevY2 + 1) {
          if (i !== 0) {
            canvasCtx.fillRect(cursorX, prevY1, cursorW, prevY2 - prevY1);
          }
          prevY1 = y1;
          prevY2 = y2;
        } else {
          if (y2 > prevY2) {
            prevY2 = y2;
          }
        }
      }
      canvasCtx.fillRect(cursorX, prevY1, cursorW, prevY2 - prevY1);
    }
    if (this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0) {
      canvasCtx.beginPath();
      canvasCtx.lineWidth = 1;
      canvasCtx.strokeStyle = this._settings.borderColor;
      canvasCtx.moveTo(0, 0);
      canvasCtx.lineTo(0, canvasHeight);
      canvasCtx.stroke();
      canvasCtx.moveTo(0, 0);
      canvasCtx.lineTo(canvasWidth, 0);
      canvasCtx.stroke();
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/view/overviewZoneManager.js
var ColorZone = class {
  constructor(from, to, colorId) {
    this.from = from | 0;
    this.to = to | 0;
    this.colorId = colorId | 0;
  }
  static compare(a, b) {
    if (a.colorId === b.colorId) {
      if (a.from === b.from) {
        return a.to - b.to;
      }
      return a.from - b.from;
    }
    return a.colorId - b.colorId;
  }
};
var OverviewRulerZone = class {
  constructor(startLineNumber, endLineNumber, color) {
    this.startLineNumber = startLineNumber;
    this.endLineNumber = endLineNumber;
    this.color = color;
    this._colorZone = null;
  }
  static compare(a, b) {
    if (a.color === b.color) {
      if (a.startLineNumber === b.startLineNumber) {
        return a.endLineNumber - b.endLineNumber;
      }
      return a.startLineNumber - b.startLineNumber;
    }
    return a.color < b.color ? -1 : 1;
  }
  setColorZone(colorZone) {
    this._colorZone = colorZone;
  }
  getColorZones() {
    return this._colorZone;
  }
};
var OverviewZoneManager = class {
  constructor(getVerticalOffsetForLine) {
    this._getVerticalOffsetForLine = getVerticalOffsetForLine;
    this._zones = [];
    this._colorZonesInvalid = false;
    this._lineHeight = 0;
    this._domWidth = 0;
    this._domHeight = 0;
    this._outerHeight = 0;
    this._pixelRatio = 1;
    this._lastAssignedId = 0;
    this._color2Id = Object.create(null);
    this._id2Color = [];
  }
  getId2Color() {
    return this._id2Color;
  }
  setZones(newZones) {
    this._zones = newZones;
    this._zones.sort(OverviewRulerZone.compare);
  }
  setLineHeight(lineHeight) {
    if (this._lineHeight === lineHeight) {
      return false;
    }
    this._lineHeight = lineHeight;
    this._colorZonesInvalid = true;
    return true;
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this._colorZonesInvalid = true;
  }
  getDOMWidth() {
    return this._domWidth;
  }
  getCanvasWidth() {
    return this._domWidth * this._pixelRatio;
  }
  setDOMWidth(width) {
    if (this._domWidth === width) {
      return false;
    }
    this._domWidth = width;
    this._colorZonesInvalid = true;
    return true;
  }
  getDOMHeight() {
    return this._domHeight;
  }
  getCanvasHeight() {
    return this._domHeight * this._pixelRatio;
  }
  setDOMHeight(height) {
    if (this._domHeight === height) {
      return false;
    }
    this._domHeight = height;
    this._colorZonesInvalid = true;
    return true;
  }
  getOuterHeight() {
    return this._outerHeight;
  }
  setOuterHeight(outerHeight) {
    if (this._outerHeight === outerHeight) {
      return false;
    }
    this._outerHeight = outerHeight;
    this._colorZonesInvalid = true;
    return true;
  }
  resolveColorZones() {
    const colorZonesInvalid = this._colorZonesInvalid;
    const lineHeight = Math.floor(this._lineHeight);
    const totalHeight = Math.floor(this.getCanvasHeight());
    const outerHeight = Math.floor(this._outerHeight);
    const heightRatio = totalHeight / outerHeight;
    const halfMinimumHeight = Math.floor(4 * this._pixelRatio / 2);
    let allColorZones = [];
    for (let i = 0, len = this._zones.length; i < len; i++) {
      const zone = this._zones[i];
      if (!colorZonesInvalid) {
        const colorZone2 = zone.getColorZones();
        if (colorZone2) {
          allColorZones.push(colorZone2);
          continue;
        }
      }
      const y1 = Math.floor(heightRatio * this._getVerticalOffsetForLine(zone.startLineNumber));
      const y2 = Math.floor(heightRatio * (this._getVerticalOffsetForLine(zone.endLineNumber) + lineHeight));
      let ycenter = Math.floor((y1 + y2) / 2);
      let halfHeight = y2 - ycenter;
      if (halfHeight < halfMinimumHeight) {
        halfHeight = halfMinimumHeight;
      }
      if (ycenter - halfHeight < 0) {
        ycenter = halfHeight;
      }
      if (ycenter + halfHeight > totalHeight) {
        ycenter = totalHeight - halfHeight;
      }
      const color = zone.color;
      let colorId = this._color2Id[color];
      if (!colorId) {
        colorId = ++this._lastAssignedId;
        this._color2Id[color] = colorId;
        this._id2Color[colorId] = color;
      }
      const colorZone = new ColorZone(ycenter - halfHeight, ycenter + halfHeight, colorId);
      zone.setColorZone(colorZone);
      allColorZones.push(colorZone);
    }
    this._colorZonesInvalid = false;
    allColorZones.sort(ColorZone.compare);
    return allColorZones;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/overviewRuler/overviewRuler.js
var OverviewRuler = class extends ViewEventHandler {
  constructor(context, cssClassName) {
    super();
    this._context = context;
    const options = this._context.configuration.options;
    this._domNode = createFastDomNode(document.createElement("canvas"));
    this._domNode.setClassName(cssClassName);
    this._domNode.setPosition("absolute");
    this._domNode.setLayerHinting(true);
    this._domNode.setContain("strict");
    this._zoneManager = new OverviewZoneManager((lineNumber) => this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber));
    this._zoneManager.setDOMWidth(0);
    this._zoneManager.setDOMHeight(0);
    this._zoneManager.setOuterHeight(this._context.viewLayout.getScrollHeight());
    this._zoneManager.setLineHeight(options.get(51));
    this._zoneManager.setPixelRatio(options.get(115));
    this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this);
    super.dispose();
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    if (e.hasChanged(51)) {
      this._zoneManager.setLineHeight(options.get(51));
      this._render();
    }
    if (e.hasChanged(115)) {
      this._zoneManager.setPixelRatio(options.get(115));
      this._domNode.setWidth(this._zoneManager.getDOMWidth());
      this._domNode.setHeight(this._zoneManager.getDOMHeight());
      this._domNode.domNode.width = this._zoneManager.getCanvasWidth();
      this._domNode.domNode.height = this._zoneManager.getCanvasHeight();
      this._render();
    }
    return true;
  }
  onFlushed(e) {
    this._render();
    return true;
  }
  onScrollChanged(e) {
    if (e.scrollHeightChanged) {
      this._zoneManager.setOuterHeight(e.scrollHeight);
      this._render();
    }
    return true;
  }
  onZonesChanged(e) {
    this._render();
    return true;
  }
  getDomNode() {
    return this._domNode.domNode;
  }
  setLayout(position) {
    this._domNode.setTop(position.top);
    this._domNode.setRight(position.right);
    let hasChanged = false;
    hasChanged = this._zoneManager.setDOMWidth(position.width) || hasChanged;
    hasChanged = this._zoneManager.setDOMHeight(position.height) || hasChanged;
    if (hasChanged) {
      this._domNode.setWidth(this._zoneManager.getDOMWidth());
      this._domNode.setHeight(this._zoneManager.getDOMHeight());
      this._domNode.domNode.width = this._zoneManager.getCanvasWidth();
      this._domNode.domNode.height = this._zoneManager.getCanvasHeight();
      this._render();
    }
  }
  setZones(zones) {
    this._zoneManager.setZones(zones);
    this._render();
  }
  _render() {
    if (this._zoneManager.getOuterHeight() === 0) {
      return false;
    }
    const width = this._zoneManager.getCanvasWidth();
    const height = this._zoneManager.getCanvasHeight();
    const colorZones = this._zoneManager.resolveColorZones();
    const id2Color = this._zoneManager.getId2Color();
    const ctx = this._domNode.domNode.getContext("2d");
    ctx.clearRect(0, 0, width, height);
    if (colorZones.length > 0) {
      this._renderOneLane(ctx, colorZones, id2Color, width);
    }
    return true;
  }
  _renderOneLane(ctx, colorZones, id2Color, width) {
    let currentColorId = 0;
    let currentFrom = 0;
    let currentTo = 0;
    for (const zone of colorZones) {
      const zoneColorId = zone.colorId;
      const zoneFrom = zone.from;
      const zoneTo = zone.to;
      if (zoneColorId !== currentColorId) {
        ctx.fillRect(0, currentFrom, width, currentTo - currentFrom);
        currentColorId = zoneColorId;
        ctx.fillStyle = id2Color[currentColorId];
        currentFrom = zoneFrom;
        currentTo = zoneTo;
      } else {
        if (currentTo >= zoneFrom) {
          currentTo = Math.max(currentTo, zoneTo);
        } else {
          ctx.fillRect(0, currentFrom, width, currentTo - currentFrom);
          currentFrom = zoneFrom;
          currentTo = zoneTo;
        }
      }
    }
    ctx.fillRect(0, currentFrom, width, currentTo - currentFrom);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/rulers/rulers.js
var Rulers = class extends ViewPart {
  constructor(context) {
    super(context);
    this.domNode = createFastDomNode(document.createElement("div"));
    this.domNode.setAttribute("role", "presentation");
    this.domNode.setAttribute("aria-hidden", "true");
    this.domNode.setClassName("view-rulers");
    this._renderedRulers = [];
    const options = this._context.configuration.options;
    this._rulers = options.get(83);
    this._typicalHalfwidthCharacterWidth = options.get(36).typicalHalfwidthCharacterWidth;
  }
  dispose() {
    super.dispose();
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    this._rulers = options.get(83);
    this._typicalHalfwidthCharacterWidth = options.get(36).typicalHalfwidthCharacterWidth;
    return true;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged;
  }
  prepareRender(ctx) {
  }
  _ensureRulersCount() {
    const currentCount = this._renderedRulers.length;
    const desiredCount = this._rulers.length;
    if (currentCount === desiredCount) {
      return;
    }
    if (currentCount < desiredCount) {
      const {tabSize} = this._context.model.getTextModelOptions();
      const rulerWidth = tabSize;
      let addCount = desiredCount - currentCount;
      while (addCount > 0) {
        const node = createFastDomNode(document.createElement("div"));
        node.setClassName("view-ruler");
        node.setWidth(rulerWidth);
        this.domNode.appendChild(node);
        this._renderedRulers.push(node);
        addCount--;
      }
      return;
    }
    let removeCount = currentCount - desiredCount;
    while (removeCount > 0) {
      const node = this._renderedRulers.pop();
      this.domNode.removeChild(node);
      removeCount--;
    }
  }
  render(ctx) {
    this._ensureRulersCount();
    for (let i = 0, len = this._rulers.length; i < len; i++) {
      const node = this._renderedRulers[i];
      const ruler = this._rulers[i];
      node.setBoxShadow(ruler.color ? `1px 0 0 0 ${ruler.color} inset` : ``);
      node.setHeight(Math.min(ctx.scrollHeight, 1e6));
      node.setLeft(ruler.column * this._typicalHalfwidthCharacterWidth);
    }
  }
};
registerThemingParticipant((theme, collector) => {
  const rulerColor = theme.getColor(editorRuler);
  if (rulerColor) {
    collector.addRule(`.monaco-editor .view-ruler { box-shadow: 1px 0 0 0 ${rulerColor} inset; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/scrollDecoration/scrollDecoration.js
var ScrollDecorationViewPart = class extends ViewPart {
  constructor(context) {
    super(context);
    this._scrollTop = 0;
    this._width = 0;
    this._updateWidth();
    this._shouldShow = false;
    const options = this._context.configuration.options;
    const scrollbar = options.get(84);
    this._useShadows = scrollbar.useShadows;
    this._domNode = createFastDomNode(document.createElement("div"));
    this._domNode.setAttribute("role", "presentation");
    this._domNode.setAttribute("aria-hidden", "true");
  }
  dispose() {
    super.dispose();
  }
  _updateShouldShow() {
    const newShouldShow = this._useShadows && this._scrollTop > 0;
    if (this._shouldShow !== newShouldShow) {
      this._shouldShow = newShouldShow;
      return true;
    }
    return false;
  }
  getDomNode() {
    return this._domNode;
  }
  _updateWidth() {
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    if (layoutInfo.minimap.renderMinimap === 0 || layoutInfo.minimap.minimapWidth > 0 && layoutInfo.minimap.minimapLeft === 0) {
      this._width = layoutInfo.width;
    } else {
      this._width = layoutInfo.width - layoutInfo.minimap.minimapWidth - layoutInfo.verticalScrollbarWidth;
    }
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    const scrollbar = options.get(84);
    this._useShadows = scrollbar.useShadows;
    this._updateWidth();
    this._updateShouldShow();
    return true;
  }
  onScrollChanged(e) {
    this._scrollTop = e.scrollTop;
    return this._updateShouldShow();
  }
  prepareRender(ctx) {
  }
  render(ctx) {
    this._domNode.setWidth(this._width);
    this._domNode.setClassName(this._shouldShow ? "scroll-decoration" : "");
  }
};
registerThemingParticipant((theme, collector) => {
  const shadow = theme.getColor(scrollbarShadow);
  if (shadow) {
    collector.addRule(`.monaco-editor .scroll-decoration { box-shadow: ${shadow} 0 6px 6px -6px inset; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/selections/selections.js
var HorizontalRangeWithStyle = class {
  constructor(other) {
    this.left = other.left;
    this.width = other.width;
    this.startStyle = null;
    this.endStyle = null;
  }
};
var LineVisibleRangesWithStyle = class {
  constructor(lineNumber, ranges) {
    this.lineNumber = lineNumber;
    this.ranges = ranges;
  }
};
function toStyledRange(item) {
  return new HorizontalRangeWithStyle(item);
}
function toStyled(item) {
  return new LineVisibleRangesWithStyle(item.lineNumber, item.ranges.map(toStyledRange));
}
var isIEWithZoomingIssuesNearRoundedBorders = isEdge;
var SelectionsOverlay = class extends DynamicViewOverlay {
  constructor(context) {
    super();
    this._previousFrameVisibleRangesWithStyle = [];
    this._context = context;
    const options = this._context.configuration.options;
    this._lineHeight = options.get(51);
    this._roundedSelection = options.get(82);
    this._typicalHalfwidthCharacterWidth = options.get(36).typicalHalfwidthCharacterWidth;
    this._selections = [];
    this._renderResult = null;
    this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this);
    this._renderResult = null;
    super.dispose();
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    this._lineHeight = options.get(51);
    this._roundedSelection = options.get(82);
    this._typicalHalfwidthCharacterWidth = options.get(36).typicalHalfwidthCharacterWidth;
    return true;
  }
  onCursorStateChanged(e) {
    this._selections = e.selections.slice(0);
    return true;
  }
  onDecorationsChanged(e) {
    return true;
  }
  onFlushed(e) {
    return true;
  }
  onLinesChanged(e) {
    return true;
  }
  onLinesDeleted(e) {
    return true;
  }
  onLinesInserted(e) {
    return true;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return true;
  }
  _visibleRangesHaveGaps(linesVisibleRanges) {
    for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {
      const lineVisibleRanges = linesVisibleRanges[i];
      if (lineVisibleRanges.ranges.length > 1) {
        return true;
      }
    }
    return false;
  }
  _enrichVisibleRangesWithStyle(viewport, linesVisibleRanges, previousFrame) {
    const epsilon = this._typicalHalfwidthCharacterWidth / 4;
    let previousFrameTop = null;
    let previousFrameBottom = null;
    if (previousFrame && previousFrame.length > 0 && linesVisibleRanges.length > 0) {
      const topLineNumber = linesVisibleRanges[0].lineNumber;
      if (topLineNumber === viewport.startLineNumber) {
        for (let i = 0; !previousFrameTop && i < previousFrame.length; i++) {
          if (previousFrame[i].lineNumber === topLineNumber) {
            previousFrameTop = previousFrame[i].ranges[0];
          }
        }
      }
      const bottomLineNumber = linesVisibleRanges[linesVisibleRanges.length - 1].lineNumber;
      if (bottomLineNumber === viewport.endLineNumber) {
        for (let i = previousFrame.length - 1; !previousFrameBottom && i >= 0; i--) {
          if (previousFrame[i].lineNumber === bottomLineNumber) {
            previousFrameBottom = previousFrame[i].ranges[0];
          }
        }
      }
      if (previousFrameTop && !previousFrameTop.startStyle) {
        previousFrameTop = null;
      }
      if (previousFrameBottom && !previousFrameBottom.startStyle) {
        previousFrameBottom = null;
      }
    }
    for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {
      const curLineRange = linesVisibleRanges[i].ranges[0];
      const curLeft = curLineRange.left;
      const curRight = curLineRange.left + curLineRange.width;
      const startStyle = {
        top: 0,
        bottom: 0
      };
      const endStyle = {
        top: 0,
        bottom: 0
      };
      if (i > 0) {
        const prevLeft = linesVisibleRanges[i - 1].ranges[0].left;
        const prevRight = linesVisibleRanges[i - 1].ranges[0].left + linesVisibleRanges[i - 1].ranges[0].width;
        if (abs(curLeft - prevLeft) < epsilon) {
          startStyle.top = 2;
        } else if (curLeft > prevLeft) {
          startStyle.top = 1;
        }
        if (abs(curRight - prevRight) < epsilon) {
          endStyle.top = 2;
        } else if (prevLeft < curRight && curRight < prevRight) {
          endStyle.top = 1;
        }
      } else if (previousFrameTop) {
        startStyle.top = previousFrameTop.startStyle.top;
        endStyle.top = previousFrameTop.endStyle.top;
      }
      if (i + 1 < len) {
        const nextLeft = linesVisibleRanges[i + 1].ranges[0].left;
        const nextRight = linesVisibleRanges[i + 1].ranges[0].left + linesVisibleRanges[i + 1].ranges[0].width;
        if (abs(curLeft - nextLeft) < epsilon) {
          startStyle.bottom = 2;
        } else if (nextLeft < curLeft && curLeft < nextRight) {
          startStyle.bottom = 1;
        }
        if (abs(curRight - nextRight) < epsilon) {
          endStyle.bottom = 2;
        } else if (curRight < nextRight) {
          endStyle.bottom = 1;
        }
      } else if (previousFrameBottom) {
        startStyle.bottom = previousFrameBottom.startStyle.bottom;
        endStyle.bottom = previousFrameBottom.endStyle.bottom;
      }
      curLineRange.startStyle = startStyle;
      curLineRange.endStyle = endStyle;
    }
  }
  _getVisibleRangesWithStyle(selection, ctx, previousFrame) {
    const _linesVisibleRanges = ctx.linesVisibleRangesForRange(selection, true) || [];
    const linesVisibleRanges = _linesVisibleRanges.map(toStyled);
    const visibleRangesHaveGaps = this._visibleRangesHaveGaps(linesVisibleRanges);
    if (!isIEWithZoomingIssuesNearRoundedBorders && !visibleRangesHaveGaps && this._roundedSelection) {
      this._enrichVisibleRangesWithStyle(ctx.visibleRange, linesVisibleRanges, previousFrame);
    }
    return linesVisibleRanges;
  }
  _createSelectionPiece(top, height, className, left, width) {
    return '<div class="cslr ' + className + '" style="top:' + top.toString() + "px;left:" + left.toString() + "px;width:" + width.toString() + "px;height:" + height + 'px;"></div>';
  }
  _actualRenderOneSelection(output2, visibleStartLineNumber, hasMultipleSelections, visibleRanges) {
    if (visibleRanges.length === 0) {
      return;
    }
    const visibleRangesHaveStyle = !!visibleRanges[0].ranges[0].startStyle;
    const fullLineHeight = this._lineHeight.toString();
    const reducedLineHeight = (this._lineHeight - 1).toString();
    const firstLineNumber = visibleRanges[0].lineNumber;
    const lastLineNumber = visibleRanges[visibleRanges.length - 1].lineNumber;
    for (let i = 0, len = visibleRanges.length; i < len; i++) {
      const lineVisibleRanges = visibleRanges[i];
      const lineNumber = lineVisibleRanges.lineNumber;
      const lineIndex = lineNumber - visibleStartLineNumber;
      const lineHeight = hasMultipleSelections ? lineNumber === lastLineNumber || lineNumber === firstLineNumber ? reducedLineHeight : fullLineHeight : fullLineHeight;
      const top = hasMultipleSelections ? lineNumber === firstLineNumber ? 1 : 0 : 0;
      let innerCornerOutput = "";
      let restOfSelectionOutput = "";
      for (let j = 0, lenJ = lineVisibleRanges.ranges.length; j < lenJ; j++) {
        const visibleRange = lineVisibleRanges.ranges[j];
        if (visibleRangesHaveStyle) {
          const startStyle = visibleRange.startStyle;
          const endStyle = visibleRange.endStyle;
          if (startStyle.top === 1 || startStyle.bottom === 1) {
            innerCornerOutput += this._createSelectionPiece(top, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
            let className2 = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;
            if (startStyle.top === 1) {
              className2 += " " + SelectionsOverlay.SELECTION_TOP_RIGHT;
            }
            if (startStyle.bottom === 1) {
              className2 += " " + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;
            }
            innerCornerOutput += this._createSelectionPiece(top, lineHeight, className2, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
          }
          if (endStyle.top === 1 || endStyle.bottom === 1) {
            innerCornerOutput += this._createSelectionPiece(top, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
            let className2 = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;
            if (endStyle.top === 1) {
              className2 += " " + SelectionsOverlay.SELECTION_TOP_LEFT;
            }
            if (endStyle.bottom === 1) {
              className2 += " " + SelectionsOverlay.SELECTION_BOTTOM_LEFT;
            }
            innerCornerOutput += this._createSelectionPiece(top, lineHeight, className2, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
          }
        }
        let className = SelectionsOverlay.SELECTION_CLASS_NAME;
        if (visibleRangesHaveStyle) {
          const startStyle = visibleRange.startStyle;
          const endStyle = visibleRange.endStyle;
          if (startStyle.top === 0) {
            className += " " + SelectionsOverlay.SELECTION_TOP_LEFT;
          }
          if (startStyle.bottom === 0) {
            className += " " + SelectionsOverlay.SELECTION_BOTTOM_LEFT;
          }
          if (endStyle.top === 0) {
            className += " " + SelectionsOverlay.SELECTION_TOP_RIGHT;
          }
          if (endStyle.bottom === 0) {
            className += " " + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;
          }
        }
        restOfSelectionOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left, visibleRange.width);
      }
      output2[lineIndex][0] += innerCornerOutput;
      output2[lineIndex][1] += restOfSelectionOutput;
    }
  }
  prepareRender(ctx) {
    const output = [];
    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;
    const visibleEndLineNumber = ctx.visibleRange.endLineNumber;
    for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
      const lineIndex = lineNumber - visibleStartLineNumber;
      output[lineIndex] = ["", ""];
    }
    const thisFrameVisibleRangesWithStyle = [];
    for (let i = 0, len = this._selections.length; i < len; i++) {
      const selection = this._selections[i];
      if (selection.isEmpty()) {
        thisFrameVisibleRangesWithStyle[i] = null;
        continue;
      }
      const visibleRangesWithStyle = this._getVisibleRangesWithStyle(selection, ctx, this._previousFrameVisibleRangesWithStyle[i]);
      thisFrameVisibleRangesWithStyle[i] = visibleRangesWithStyle;
      this._actualRenderOneSelection(output, visibleStartLineNumber, this._selections.length > 1, visibleRangesWithStyle);
    }
    this._previousFrameVisibleRangesWithStyle = thisFrameVisibleRangesWithStyle;
    this._renderResult = output.map(([internalCorners, restOfSelection]) => internalCorners + restOfSelection);
  }
  render(startLineNumber, lineNumber) {
    if (!this._renderResult) {
      return "";
    }
    const lineIndex = lineNumber - startLineNumber;
    if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
      return "";
    }
    return this._renderResult[lineIndex];
  }
};
SelectionsOverlay.SELECTION_CLASS_NAME = "selected-text";
SelectionsOverlay.SELECTION_TOP_LEFT = "top-left-radius";
SelectionsOverlay.SELECTION_BOTTOM_LEFT = "bottom-left-radius";
SelectionsOverlay.SELECTION_TOP_RIGHT = "top-right-radius";
SelectionsOverlay.SELECTION_BOTTOM_RIGHT = "bottom-right-radius";
SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME = "monaco-editor-background";
SelectionsOverlay.ROUNDED_PIECE_WIDTH = 10;
registerThemingParticipant((theme, collector) => {
  const editorSelectionColor = theme.getColor(editorSelectionBackground);
  if (editorSelectionColor) {
    collector.addRule(`.monaco-editor .focused .selected-text { background-color: ${editorSelectionColor}; }`);
  }
  const editorInactiveSelectionColor = theme.getColor(editorInactiveSelection);
  if (editorInactiveSelectionColor) {
    collector.addRule(`.monaco-editor .selected-text { background-color: ${editorInactiveSelectionColor}; }`);
  }
  const editorSelectionForegroundColor = theme.getColor(editorSelectionForeground);
  if (editorSelectionForegroundColor && !editorSelectionForegroundColor.isTransparent()) {
    collector.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${editorSelectionForegroundColor}; }`);
  }
});
function abs(n) {
  return n < 0 ? -n : n;
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/viewCursors/viewCursor.js
var ViewCursorRenderData = class {
  constructor(top, left, width, height, textContent, textContentClassName) {
    this.top = top;
    this.left = left;
    this.width = width;
    this.height = height;
    this.textContent = textContent;
    this.textContentClassName = textContentClassName;
  }
};
var ViewCursor = class {
  constructor(context) {
    this._context = context;
    const options = this._context.configuration.options;
    const fontInfo = options.get(36);
    this._cursorStyle = options.get(19);
    this._lineHeight = options.get(51);
    this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;
    this._lineCursorWidth = Math.min(options.get(22), this._typicalHalfwidthCharacterWidth);
    this._isVisible = true;
    this._domNode = createFastDomNode(document.createElement("div"));
    this._domNode.setClassName(`cursor ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);
    this._domNode.setHeight(this._lineHeight);
    this._domNode.setTop(0);
    this._domNode.setLeft(0);
    Configuration2.applyFontInfo(this._domNode, fontInfo);
    this._domNode.setDisplay("none");
    this._position = new Position(1, 1);
    this._lastRenderedContent = "";
    this._renderData = null;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._position;
  }
  show() {
    if (!this._isVisible) {
      this._domNode.setVisibility("inherit");
      this._isVisible = true;
    }
  }
  hide() {
    if (this._isVisible) {
      this._domNode.setVisibility("hidden");
      this._isVisible = false;
    }
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    const fontInfo = options.get(36);
    this._cursorStyle = options.get(19);
    this._lineHeight = options.get(51);
    this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;
    this._lineCursorWidth = Math.min(options.get(22), this._typicalHalfwidthCharacterWidth);
    Configuration2.applyFontInfo(this._domNode, fontInfo);
    return true;
  }
  onCursorPositionChanged(position) {
    this._position = position;
    return true;
  }
  _prepareRender(ctx) {
    let textContent = "";
    if (this._cursorStyle === TextEditorCursorStyle.Line || this._cursorStyle === TextEditorCursorStyle.LineThin) {
      const visibleRange = ctx.visibleRangeForPosition(this._position);
      if (!visibleRange || visibleRange.outsideRenderedLine) {
        return null;
      }
      let width2;
      if (this._cursorStyle === TextEditorCursorStyle.Line) {
        width2 = computeScreenAwareSize(this._lineCursorWidth > 0 ? this._lineCursorWidth : 2);
        if (width2 > 2) {
          const lineContent2 = this._context.model.getLineContent(this._position.lineNumber);
          const nextCharLength3 = nextCharLength(lineContent2, this._position.column - 1);
          textContent = lineContent2.substr(this._position.column - 1, nextCharLength3);
        }
      } else {
        width2 = computeScreenAwareSize(1);
      }
      let left = visibleRange.left;
      if (width2 >= 2 && left >= 1) {
        left -= 1;
      }
      const top2 = ctx.getVerticalOffsetForLineNumber(this._position.lineNumber) - ctx.bigNumbersDelta;
      return new ViewCursorRenderData(top2, left, width2, this._lineHeight, textContent, "");
    }
    const lineContent = this._context.model.getLineContent(this._position.lineNumber);
    const nextCharLength2 = nextCharLength(lineContent, this._position.column - 1);
    const visibleRangeForCharacter = ctx.linesVisibleRangesForRange(new Range(this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column + nextCharLength2), false);
    if (!visibleRangeForCharacter || visibleRangeForCharacter.length === 0) {
      return null;
    }
    const firstVisibleRangeForCharacter = visibleRangeForCharacter[0];
    if (firstVisibleRangeForCharacter.outsideRenderedLine || firstVisibleRangeForCharacter.ranges.length === 0) {
      return null;
    }
    const range2 = firstVisibleRangeForCharacter.ranges[0];
    const width = range2.width < 1 ? this._typicalHalfwidthCharacterWidth : range2.width;
    let textContentClassName = "";
    if (this._cursorStyle === TextEditorCursorStyle.Block) {
      const lineData = this._context.model.getViewLineData(this._position.lineNumber);
      textContent = lineContent.substr(this._position.column - 1, nextCharLength2);
      const tokenIndex = lineData.tokens.findTokenIndexAtOffset(this._position.column - 1);
      textContentClassName = lineData.tokens.getClassName(tokenIndex);
    }
    let top = ctx.getVerticalOffsetForLineNumber(this._position.lineNumber) - ctx.bigNumbersDelta;
    let height = this._lineHeight;
    if (this._cursorStyle === TextEditorCursorStyle.Underline || this._cursorStyle === TextEditorCursorStyle.UnderlineThin) {
      top += this._lineHeight - 2;
      height = 2;
    }
    return new ViewCursorRenderData(top, range2.left, width, height, textContent, textContentClassName);
  }
  prepareRender(ctx) {
    this._renderData = this._prepareRender(ctx);
  }
  render(ctx) {
    if (!this._renderData) {
      this._domNode.setDisplay("none");
      return null;
    }
    if (this._lastRenderedContent !== this._renderData.textContent) {
      this._lastRenderedContent = this._renderData.textContent;
      this._domNode.domNode.textContent = this._lastRenderedContent;
    }
    this._domNode.setClassName(`cursor ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME} ${this._renderData.textContentClassName}`);
    this._domNode.setDisplay("block");
    this._domNode.setTop(this._renderData.top);
    this._domNode.setLeft(this._renderData.left);
    this._domNode.setWidth(this._renderData.width);
    this._domNode.setLineHeight(this._renderData.height);
    this._domNode.setHeight(this._renderData.height);
    return {
      domNode: this._domNode.domNode,
      position: this._position,
      contentLeft: this._renderData.left,
      height: this._renderData.height,
      width: 2
    };
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/viewCursors/viewCursors.js
var ViewCursors = class extends ViewPart {
  constructor(context) {
    super(context);
    const options = this._context.configuration.options;
    this._readOnly = options.get(72);
    this._cursorBlinking = options.get(17);
    this._cursorStyle = options.get(19);
    this._cursorSmoothCaretAnimation = options.get(18);
    this._selectionIsEmpty = true;
    this._isVisible = false;
    this._primaryCursor = new ViewCursor(this._context);
    this._secondaryCursors = [];
    this._renderData = [];
    this._domNode = createFastDomNode(document.createElement("div"));
    this._domNode.setAttribute("role", "presentation");
    this._domNode.setAttribute("aria-hidden", "true");
    this._updateDomClassName();
    this._domNode.appendChild(this._primaryCursor.getDomNode());
    this._startCursorBlinkAnimation = new TimeoutTimer();
    this._cursorFlatBlinkInterval = new IntervalTimer();
    this._blinkingEnabled = false;
    this._editorHasFocus = false;
    this._updateBlinking();
  }
  dispose() {
    super.dispose();
    this._startCursorBlinkAnimation.dispose();
    this._cursorFlatBlinkInterval.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    this._readOnly = options.get(72);
    this._cursorBlinking = options.get(17);
    this._cursorStyle = options.get(19);
    this._cursorSmoothCaretAnimation = options.get(18);
    this._updateBlinking();
    this._updateDomClassName();
    this._primaryCursor.onConfigurationChanged(e);
    for (let i = 0, len = this._secondaryCursors.length; i < len; i++) {
      this._secondaryCursors[i].onConfigurationChanged(e);
    }
    return true;
  }
  _onCursorPositionChanged(position, secondaryPositions) {
    this._primaryCursor.onCursorPositionChanged(position);
    this._updateBlinking();
    if (this._secondaryCursors.length < secondaryPositions.length) {
      const addCnt = secondaryPositions.length - this._secondaryCursors.length;
      for (let i = 0; i < addCnt; i++) {
        const newCursor = new ViewCursor(this._context);
        this._domNode.domNode.insertBefore(newCursor.getDomNode().domNode, this._primaryCursor.getDomNode().domNode.nextSibling);
        this._secondaryCursors.push(newCursor);
      }
    } else if (this._secondaryCursors.length > secondaryPositions.length) {
      const removeCnt = this._secondaryCursors.length - secondaryPositions.length;
      for (let i = 0; i < removeCnt; i++) {
        this._domNode.removeChild(this._secondaryCursors[0].getDomNode());
        this._secondaryCursors.splice(0, 1);
      }
    }
    for (let i = 0; i < secondaryPositions.length; i++) {
      this._secondaryCursors[i].onCursorPositionChanged(secondaryPositions[i]);
    }
  }
  onCursorStateChanged(e) {
    const positions = [];
    for (let i = 0, len = e.selections.length; i < len; i++) {
      positions[i] = e.selections[i].getPosition();
    }
    this._onCursorPositionChanged(positions[0], positions.slice(1));
    const selectionIsEmpty = e.selections[0].isEmpty();
    if (this._selectionIsEmpty !== selectionIsEmpty) {
      this._selectionIsEmpty = selectionIsEmpty;
      this._updateDomClassName();
    }
    return true;
  }
  onDecorationsChanged(e) {
    return true;
  }
  onFlushed(e) {
    return true;
  }
  onFocusChanged(e) {
    this._editorHasFocus = e.isFocused;
    this._updateBlinking();
    return false;
  }
  onLinesChanged(e) {
    return true;
  }
  onLinesDeleted(e) {
    return true;
  }
  onLinesInserted(e) {
    return true;
  }
  onScrollChanged(e) {
    return true;
  }
  onTokensChanged(e) {
    const shouldRender = (position) => {
      for (let i = 0, len = e.ranges.length; i < len; i++) {
        if (e.ranges[i].fromLineNumber <= position.lineNumber && position.lineNumber <= e.ranges[i].toLineNumber) {
          return true;
        }
      }
      return false;
    };
    if (shouldRender(this._primaryCursor.getPosition())) {
      return true;
    }
    for (const secondaryCursor of this._secondaryCursors) {
      if (shouldRender(secondaryCursor.getPosition())) {
        return true;
      }
    }
    return false;
  }
  onZonesChanged(e) {
    return true;
  }
  _getCursorBlinking() {
    if (!this._editorHasFocus) {
      return 0;
    }
    if (this._readOnly) {
      return 5;
    }
    return this._cursorBlinking;
  }
  _updateBlinking() {
    this._startCursorBlinkAnimation.cancel();
    this._cursorFlatBlinkInterval.cancel();
    const blinkingStyle = this._getCursorBlinking();
    const isHidden = blinkingStyle === 0;
    const isSolid = blinkingStyle === 5;
    if (isHidden) {
      this._hide();
    } else {
      this._show();
    }
    this._blinkingEnabled = false;
    this._updateDomClassName();
    if (!isHidden && !isSolid) {
      if (blinkingStyle === 1) {
        this._cursorFlatBlinkInterval.cancelAndSet(() => {
          if (this._isVisible) {
            this._hide();
          } else {
            this._show();
          }
        }, ViewCursors.BLINK_INTERVAL);
      } else {
        this._startCursorBlinkAnimation.setIfNotSet(() => {
          this._blinkingEnabled = true;
          this._updateDomClassName();
        }, ViewCursors.BLINK_INTERVAL);
      }
    }
  }
  _updateDomClassName() {
    this._domNode.setClassName(this._getClassName());
  }
  _getClassName() {
    let result = "cursors-layer";
    if (!this._selectionIsEmpty) {
      result += " has-selection";
    }
    switch (this._cursorStyle) {
      case TextEditorCursorStyle.Line:
        result += " cursor-line-style";
        break;
      case TextEditorCursorStyle.Block:
        result += " cursor-block-style";
        break;
      case TextEditorCursorStyle.Underline:
        result += " cursor-underline-style";
        break;
      case TextEditorCursorStyle.LineThin:
        result += " cursor-line-thin-style";
        break;
      case TextEditorCursorStyle.BlockOutline:
        result += " cursor-block-outline-style";
        break;
      case TextEditorCursorStyle.UnderlineThin:
        result += " cursor-underline-thin-style";
        break;
      default:
        result += " cursor-line-style";
    }
    if (this._blinkingEnabled) {
      switch (this._getCursorBlinking()) {
        case 1:
          result += " cursor-blink";
          break;
        case 2:
          result += " cursor-smooth";
          break;
        case 3:
          result += " cursor-phase";
          break;
        case 4:
          result += " cursor-expand";
          break;
        case 5:
          result += " cursor-solid";
          break;
        default:
          result += " cursor-solid";
      }
    } else {
      result += " cursor-solid";
    }
    if (this._cursorSmoothCaretAnimation) {
      result += " cursor-smooth-caret-animation";
    }
    return result;
  }
  _show() {
    this._primaryCursor.show();
    for (let i = 0, len = this._secondaryCursors.length; i < len; i++) {
      this._secondaryCursors[i].show();
    }
    this._isVisible = true;
  }
  _hide() {
    this._primaryCursor.hide();
    for (let i = 0, len = this._secondaryCursors.length; i < len; i++) {
      this._secondaryCursors[i].hide();
    }
    this._isVisible = false;
  }
  prepareRender(ctx) {
    this._primaryCursor.prepareRender(ctx);
    for (let i = 0, len = this._secondaryCursors.length; i < len; i++) {
      this._secondaryCursors[i].prepareRender(ctx);
    }
  }
  render(ctx) {
    let renderData = [], renderDataLen = 0;
    const primaryRenderData = this._primaryCursor.render(ctx);
    if (primaryRenderData) {
      renderData[renderDataLen++] = primaryRenderData;
    }
    for (let i = 0, len = this._secondaryCursors.length; i < len; i++) {
      const secondaryRenderData = this._secondaryCursors[i].render(ctx);
      if (secondaryRenderData) {
        renderData[renderDataLen++] = secondaryRenderData;
      }
    }
    this._renderData = renderData;
  }
  getLastRenderData() {
    return this._renderData;
  }
};
ViewCursors.BLINK_INTERVAL = 500;
registerThemingParticipant((theme, collector) => {
  const caret = theme.getColor(editorCursorForeground);
  if (caret) {
    let caretBackground = theme.getColor(editorCursorBackground);
    if (!caretBackground) {
      caretBackground = caret.opposite();
    }
    collector.addRule(`.monaco-editor .cursors-layer .cursor { background-color: ${caret}; border-color: ${caret}; color: ${caretBackground}; }`);
    if (theme.type === "hc") {
      collector.addRule(`.monaco-editor .cursors-layer.has-selection .cursor { border-left: 1px solid ${caretBackground}; border-right: 1px solid ${caretBackground}; }`);
    }
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/browser/viewParts/viewZones/viewZones.js
var invalidFunc2 = () => {
  throw new Error(`Invalid change accessor`);
};
var ViewZones = class extends ViewPart {
  constructor(context) {
    super(context);
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._lineHeight = options.get(51);
    this._contentWidth = layoutInfo.contentWidth;
    this._contentLeft = layoutInfo.contentLeft;
    this.domNode = createFastDomNode(document.createElement("div"));
    this.domNode.setClassName("view-zones");
    this.domNode.setPosition("absolute");
    this.domNode.setAttribute("role", "presentation");
    this.domNode.setAttribute("aria-hidden", "true");
    this.marginDomNode = createFastDomNode(document.createElement("div"));
    this.marginDomNode.setClassName("margin-view-zones");
    this.marginDomNode.setPosition("absolute");
    this.marginDomNode.setAttribute("role", "presentation");
    this.marginDomNode.setAttribute("aria-hidden", "true");
    this._zones = {};
  }
  dispose() {
    super.dispose();
    this._zones = {};
  }
  _recomputeWhitespacesProps() {
    const whitespaces = this._context.viewLayout.getWhitespaces();
    const oldWhitespaces = new Map();
    for (const whitespace of whitespaces) {
      oldWhitespaces.set(whitespace.id, whitespace);
    }
    let hadAChange = false;
    this._context.model.changeWhitespace((whitespaceAccessor) => {
      const keys = Object.keys(this._zones);
      for (let i = 0, len = keys.length; i < len; i++) {
        const id = keys[i];
        const zone = this._zones[id];
        const props = this._computeWhitespaceProps(zone.delegate);
        const oldWhitespace = oldWhitespaces.get(id);
        if (oldWhitespace && (oldWhitespace.afterLineNumber !== props.afterViewLineNumber || oldWhitespace.height !== props.heightInPx)) {
          whitespaceAccessor.changeOneWhitespace(id, props.afterViewLineNumber, props.heightInPx);
          this._safeCallOnComputedHeight(zone.delegate, props.heightInPx);
          hadAChange = true;
        }
      }
    });
    return hadAChange;
  }
  onConfigurationChanged(e) {
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this._lineHeight = options.get(51);
    this._contentWidth = layoutInfo.contentWidth;
    this._contentLeft = layoutInfo.contentLeft;
    if (e.hasChanged(51)) {
      this._recomputeWhitespacesProps();
    }
    return true;
  }
  onLineMappingChanged(e) {
    return this._recomputeWhitespacesProps();
  }
  onLinesDeleted(e) {
    return true;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return true;
  }
  onLinesInserted(e) {
    return true;
  }
  _getZoneOrdinal(zone) {
    if (typeof zone.afterColumn !== "undefined") {
      return zone.afterColumn;
    }
    return 1e4;
  }
  _computeWhitespaceProps(zone) {
    if (zone.afterLineNumber === 0) {
      return {
        afterViewLineNumber: 0,
        heightInPx: this._heightInPixels(zone),
        minWidthInPx: this._minWidthInPixels(zone)
      };
    }
    let zoneAfterModelPosition;
    if (typeof zone.afterColumn !== "undefined") {
      zoneAfterModelPosition = this._context.model.validateModelPosition({
        lineNumber: zone.afterLineNumber,
        column: zone.afterColumn
      });
    } else {
      const validAfterLineNumber = this._context.model.validateModelPosition({
        lineNumber: zone.afterLineNumber,
        column: 1
      }).lineNumber;
      zoneAfterModelPosition = new Position(validAfterLineNumber, this._context.model.getModelLineMaxColumn(validAfterLineNumber));
    }
    let zoneBeforeModelPosition;
    if (zoneAfterModelPosition.column === this._context.model.getModelLineMaxColumn(zoneAfterModelPosition.lineNumber)) {
      zoneBeforeModelPosition = this._context.model.validateModelPosition({
        lineNumber: zoneAfterModelPosition.lineNumber + 1,
        column: 1
      });
    } else {
      zoneBeforeModelPosition = this._context.model.validateModelPosition({
        lineNumber: zoneAfterModelPosition.lineNumber,
        column: zoneAfterModelPosition.column + 1
      });
    }
    const viewPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(zoneAfterModelPosition);
    const isVisible = this._context.model.coordinatesConverter.modelPositionIsVisible(zoneBeforeModelPosition);
    return {
      afterViewLineNumber: viewPosition.lineNumber,
      heightInPx: isVisible ? this._heightInPixels(zone) : 0,
      minWidthInPx: this._minWidthInPixels(zone)
    };
  }
  changeViewZones(callback) {
    let zonesHaveChanged = false;
    this._context.model.changeWhitespace((whitespaceAccessor) => {
      const changeAccessor = {
        addZone: (zone) => {
          zonesHaveChanged = true;
          return this._addZone(whitespaceAccessor, zone);
        },
        removeZone: (id) => {
          if (!id) {
            return;
          }
          zonesHaveChanged = this._removeZone(whitespaceAccessor, id) || zonesHaveChanged;
        },
        layoutZone: (id) => {
          if (!id) {
            return;
          }
          zonesHaveChanged = this._layoutZone(whitespaceAccessor, id) || zonesHaveChanged;
        }
      };
      safeInvoke1Arg(callback, changeAccessor);
      changeAccessor.addZone = invalidFunc2;
      changeAccessor.removeZone = invalidFunc2;
      changeAccessor.layoutZone = invalidFunc2;
    });
    return zonesHaveChanged;
  }
  _addZone(whitespaceAccessor, zone) {
    const props = this._computeWhitespaceProps(zone);
    const whitespaceId = whitespaceAccessor.insertWhitespace(props.afterViewLineNumber, this._getZoneOrdinal(zone), props.heightInPx, props.minWidthInPx);
    const myZone = {
      whitespaceId,
      delegate: zone,
      isVisible: false,
      domNode: createFastDomNode(zone.domNode),
      marginDomNode: zone.marginDomNode ? createFastDomNode(zone.marginDomNode) : null
    };
    this._safeCallOnComputedHeight(myZone.delegate, props.heightInPx);
    myZone.domNode.setPosition("absolute");
    myZone.domNode.domNode.style.width = "100%";
    myZone.domNode.setDisplay("none");
    myZone.domNode.setAttribute("monaco-view-zone", myZone.whitespaceId);
    this.domNode.appendChild(myZone.domNode);
    if (myZone.marginDomNode) {
      myZone.marginDomNode.setPosition("absolute");
      myZone.marginDomNode.domNode.style.width = "100%";
      myZone.marginDomNode.setDisplay("none");
      myZone.marginDomNode.setAttribute("monaco-view-zone", myZone.whitespaceId);
      this.marginDomNode.appendChild(myZone.marginDomNode);
    }
    this._zones[myZone.whitespaceId] = myZone;
    this.setShouldRender();
    return myZone.whitespaceId;
  }
  _removeZone(whitespaceAccessor, id) {
    if (this._zones.hasOwnProperty(id)) {
      const zone = this._zones[id];
      delete this._zones[id];
      whitespaceAccessor.removeWhitespace(zone.whitespaceId);
      zone.domNode.removeAttribute("monaco-visible-view-zone");
      zone.domNode.removeAttribute("monaco-view-zone");
      zone.domNode.domNode.parentNode.removeChild(zone.domNode.domNode);
      if (zone.marginDomNode) {
        zone.marginDomNode.removeAttribute("monaco-visible-view-zone");
        zone.marginDomNode.removeAttribute("monaco-view-zone");
        zone.marginDomNode.domNode.parentNode.removeChild(zone.marginDomNode.domNode);
      }
      this.setShouldRender();
      return true;
    }
    return false;
  }
  _layoutZone(whitespaceAccessor, id) {
    if (this._zones.hasOwnProperty(id)) {
      const zone = this._zones[id];
      const props = this._computeWhitespaceProps(zone.delegate);
      whitespaceAccessor.changeOneWhitespace(zone.whitespaceId, props.afterViewLineNumber, props.heightInPx);
      this._safeCallOnComputedHeight(zone.delegate, props.heightInPx);
      this.setShouldRender();
      return true;
    }
    return false;
  }
  shouldSuppressMouseDownOnViewZone(id) {
    if (this._zones.hasOwnProperty(id)) {
      const zone = this._zones[id];
      return Boolean(zone.delegate.suppressMouseDown);
    }
    return false;
  }
  _heightInPixels(zone) {
    if (typeof zone.heightInPx === "number") {
      return zone.heightInPx;
    }
    if (typeof zone.heightInLines === "number") {
      return this._lineHeight * zone.heightInLines;
    }
    return this._lineHeight;
  }
  _minWidthInPixels(zone) {
    if (typeof zone.minWidthInPx === "number") {
      return zone.minWidthInPx;
    }
    return 0;
  }
  _safeCallOnComputedHeight(zone, height) {
    if (typeof zone.onComputedHeight === "function") {
      try {
        zone.onComputedHeight(height);
      } catch (e) {
        onUnexpectedError(e);
      }
    }
  }
  _safeCallOnDomNodeTop(zone, top) {
    if (typeof zone.onDomNodeTop === "function") {
      try {
        zone.onDomNodeTop(top);
      } catch (e) {
        onUnexpectedError(e);
      }
    }
  }
  prepareRender(ctx) {
  }
  render(ctx) {
    const visibleWhitespaces = ctx.viewportData.whitespaceViewportData;
    const visibleZones = {};
    let hasVisibleZone = false;
    for (let i = 0, len = visibleWhitespaces.length; i < len; i++) {
      visibleZones[visibleWhitespaces[i].id] = visibleWhitespaces[i];
      hasVisibleZone = true;
    }
    const keys = Object.keys(this._zones);
    for (let i = 0, len = keys.length; i < len; i++) {
      const id = keys[i];
      const zone = this._zones[id];
      let newTop = 0;
      let newHeight = 0;
      let newDisplay = "none";
      if (visibleZones.hasOwnProperty(id)) {
        newTop = visibleZones[id].verticalOffset - ctx.bigNumbersDelta;
        newHeight = visibleZones[id].height;
        newDisplay = "block";
        if (!zone.isVisible) {
          zone.domNode.setAttribute("monaco-visible-view-zone", "true");
          zone.isVisible = true;
        }
        this._safeCallOnDomNodeTop(zone.delegate, ctx.getScrolledTopFromAbsoluteTop(visibleZones[id].verticalOffset));
      } else {
        if (zone.isVisible) {
          zone.domNode.removeAttribute("monaco-visible-view-zone");
          zone.isVisible = false;
        }
        this._safeCallOnDomNodeTop(zone.delegate, ctx.getScrolledTopFromAbsoluteTop(-1e6));
      }
      zone.domNode.setTop(newTop);
      zone.domNode.setHeight(newHeight);
      zone.domNode.setDisplay(newDisplay);
      if (zone.marginDomNode) {
        zone.marginDomNode.setTop(newTop);
        zone.marginDomNode.setHeight(newHeight);
        zone.marginDomNode.setDisplay(newDisplay);
      }
    }
    if (hasVisibleZone) {
      this.domNode.setWidth(Math.max(ctx.scrollWidth, this._contentWidth));
      this.marginDomNode.setWidth(this._contentLeft);
    }
  }
};
function safeInvoke1Arg(func, arg1) {
  try {
    return func(arg1);
  } catch (e) {
    onUnexpectedError(e);
  }
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/view/viewContext.js
var EditorTheme = class {
  constructor(theme) {
    this._theme = theme;
  }
  get type() {
    return this._theme.type;
  }
  update(theme) {
    this._theme = theme;
  }
  getColor(color) {
    return this._theme.getColor(color);
  }
};
var ViewContext = class {
  constructor(configuration, theme, model2) {
    this.configuration = configuration;
    this.theme = new EditorTheme(theme);
    this.model = model2;
    this.viewLayout = model2.viewLayout;
  }
  addEventHandler(eventHandler) {
    this.model.addViewEventHandler(eventHandler);
  }
  removeEventHandler(eventHandler) {
    this.model.removeViewEventHandler(eventHandler);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLinesViewportData.js
var ViewportData = class {
  constructor(selections, partialData, whitespaceViewportData, model2) {
    this.selections = selections;
    this.startLineNumber = partialData.startLineNumber | 0;
    this.endLineNumber = partialData.endLineNumber | 0;
    this.relativeVerticalOffset = partialData.relativeVerticalOffset;
    this.bigNumbersDelta = partialData.bigNumbersDelta | 0;
    this.whitespaceViewportData = whitespaceViewportData;
    this._model = model2;
    this.visibleRange = new Range(partialData.startLineNumber, this._model.getLineMinColumn(partialData.startLineNumber), partialData.endLineNumber, this._model.getLineMaxColumn(partialData.endLineNumber));
  }
  getViewLineRenderingData(lineNumber) {
    return this._model.getViewLineRenderingData(this.visibleRange, lineNumber);
  }
  getDecorationsInViewport() {
    return this._model.getDecorationsInViewport(this.visibleRange);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/view/viewImpl.js
var View = class extends ViewEventHandler {
  constructor(commandDelegate, configuration, themeService, model2, userInputEvents, overflowWidgetsDomNode) {
    super();
    this._selections = [new Selection(1, 1, 1, 1)];
    this._renderAnimationFrame = null;
    const viewController = new ViewController(configuration, model2, userInputEvents, commandDelegate);
    this._context = new ViewContext(configuration, themeService.getColorTheme(), model2);
    this._context.addEventHandler(this);
    this._register(themeService.onDidColorThemeChange((theme) => {
      this._context.theme.update(theme);
      this._context.model.onDidColorThemeChange();
      this.render(true, false);
    }));
    this._viewParts = [];
    this._textAreaHandler = new TextAreaHandler(this._context, viewController, this._createTextAreaHandlerHelper());
    this._viewParts.push(this._textAreaHandler);
    this._linesContent = createFastDomNode(document.createElement("div"));
    this._linesContent.setClassName("lines-content monaco-editor-background");
    this._linesContent.setPosition("absolute");
    this.domNode = createFastDomNode(document.createElement("div"));
    this.domNode.setClassName(this._getEditorClassName());
    this.domNode.setAttribute("role", "code");
    this._overflowGuardContainer = createFastDomNode(document.createElement("div"));
    PartFingerprints.write(this._overflowGuardContainer, 3);
    this._overflowGuardContainer.setClassName("overflow-guard");
    this._scrollbar = new EditorScrollbar2(this._context, this._linesContent, this.domNode, this._overflowGuardContainer);
    this._viewParts.push(this._scrollbar);
    this._viewLines = new ViewLines(this._context, this._linesContent);
    this._viewZones = new ViewZones(this._context);
    this._viewParts.push(this._viewZones);
    const decorationsOverviewRuler = new DecorationsOverviewRuler(this._context);
    this._viewParts.push(decorationsOverviewRuler);
    const scrollDecoration = new ScrollDecorationViewPart(this._context);
    this._viewParts.push(scrollDecoration);
    const contentViewOverlays = new ContentViewOverlays(this._context);
    this._viewParts.push(contentViewOverlays);
    contentViewOverlays.addDynamicOverlay(new CurrentLineHighlightOverlay(this._context));
    contentViewOverlays.addDynamicOverlay(new SelectionsOverlay(this._context));
    contentViewOverlays.addDynamicOverlay(new IndentGuidesOverlay(this._context));
    contentViewOverlays.addDynamicOverlay(new DecorationsOverlay(this._context));
    const marginViewOverlays = new MarginViewOverlays(this._context);
    this._viewParts.push(marginViewOverlays);
    marginViewOverlays.addDynamicOverlay(new CurrentLineMarginHighlightOverlay(this._context));
    marginViewOverlays.addDynamicOverlay(new GlyphMarginOverlay(this._context));
    marginViewOverlays.addDynamicOverlay(new MarginViewLineDecorationsOverlay(this._context));
    marginViewOverlays.addDynamicOverlay(new LinesDecorationsOverlay(this._context));
    marginViewOverlays.addDynamicOverlay(new LineNumbersOverlay(this._context));
    const margin = new Margin(this._context);
    margin.getDomNode().appendChild(this._viewZones.marginDomNode);
    margin.getDomNode().appendChild(marginViewOverlays.getDomNode());
    this._viewParts.push(margin);
    this._contentWidgets = new ViewContentWidgets(this._context, this.domNode);
    this._viewParts.push(this._contentWidgets);
    this._viewCursors = new ViewCursors(this._context);
    this._viewParts.push(this._viewCursors);
    this._overlayWidgets = new ViewOverlayWidgets(this._context);
    this._viewParts.push(this._overlayWidgets);
    const rulers = new Rulers(this._context);
    this._viewParts.push(rulers);
    const minimap = new Minimap(this._context);
    this._viewParts.push(minimap);
    if (decorationsOverviewRuler) {
      const overviewRulerData = this._scrollbar.getOverviewRulerLayoutInfo();
      overviewRulerData.parent.insertBefore(decorationsOverviewRuler.getDomNode(), overviewRulerData.insertBefore);
    }
    this._linesContent.appendChild(contentViewOverlays.getDomNode());
    this._linesContent.appendChild(rulers.domNode);
    this._linesContent.appendChild(this._viewZones.domNode);
    this._linesContent.appendChild(this._viewLines.getDomNode());
    this._linesContent.appendChild(this._contentWidgets.domNode);
    this._linesContent.appendChild(this._viewCursors.getDomNode());
    this._overflowGuardContainer.appendChild(margin.getDomNode());
    this._overflowGuardContainer.appendChild(this._scrollbar.getDomNode());
    this._overflowGuardContainer.appendChild(scrollDecoration.getDomNode());
    this._overflowGuardContainer.appendChild(this._textAreaHandler.textArea);
    this._overflowGuardContainer.appendChild(this._textAreaHandler.textAreaCover);
    this._overflowGuardContainer.appendChild(this._overlayWidgets.getDomNode());
    this._overflowGuardContainer.appendChild(minimap.getDomNode());
    this.domNode.appendChild(this._overflowGuardContainer);
    if (overflowWidgetsDomNode) {
      overflowWidgetsDomNode.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode.domNode);
    } else {
      this.domNode.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode);
    }
    this._applyLayout();
    this._pointerHandler = this._register(new PointerHandler(this._context, viewController, this._createPointerHandlerHelper()));
  }
  _flushAccumulatedAndRenderNow() {
    this._renderNow();
  }
  _createPointerHandlerHelper() {
    return {
      viewDomNode: this.domNode.domNode,
      linesContentDomNode: this._linesContent.domNode,
      focusTextArea: () => {
        this.focus();
      },
      getLastRenderData: () => {
        const lastViewCursorsRenderData = this._viewCursors.getLastRenderData() || [];
        const lastTextareaPosition = this._textAreaHandler.getLastRenderData();
        return new PointerHandlerLastRenderData(lastViewCursorsRenderData, lastTextareaPosition);
      },
      shouldSuppressMouseDownOnViewZone: (viewZoneId) => {
        return this._viewZones.shouldSuppressMouseDownOnViewZone(viewZoneId);
      },
      shouldSuppressMouseDownOnWidget: (widgetId) => {
        return this._contentWidgets.shouldSuppressMouseDownOnWidget(widgetId);
      },
      getPositionFromDOMInfo: (spanNode, offset) => {
        this._flushAccumulatedAndRenderNow();
        return this._viewLines.getPositionFromDOMInfo(spanNode, offset);
      },
      visibleRangeForPosition: (lineNumber, column) => {
        this._flushAccumulatedAndRenderNow();
        return this._viewLines.visibleRangeForPosition(new Position(lineNumber, column));
      },
      getLineWidth: (lineNumber) => {
        this._flushAccumulatedAndRenderNow();
        return this._viewLines.getLineWidth(lineNumber);
      }
    };
  }
  _createTextAreaHandlerHelper() {
    return {
      visibleRangeForPositionRelativeToEditor: (lineNumber, column) => {
        this._flushAccumulatedAndRenderNow();
        return this._viewLines.visibleRangeForPosition(new Position(lineNumber, column));
      }
    };
  }
  _applyLayout() {
    const options = this._context.configuration.options;
    const layoutInfo = options.get(117);
    this.domNode.setWidth(layoutInfo.width);
    this.domNode.setHeight(layoutInfo.height);
    this._overflowGuardContainer.setWidth(layoutInfo.width);
    this._overflowGuardContainer.setHeight(layoutInfo.height);
    this._linesContent.setWidth(1e6);
    this._linesContent.setHeight(1e6);
  }
  _getEditorClassName() {
    const focused = this._textAreaHandler.isFocused() ? " focused" : "";
    return this._context.configuration.options.get(114) + " " + getThemeTypeSelector(this._context.theme.type) + focused;
  }
  handleEvents(events) {
    super.handleEvents(events);
    this._scheduleRender();
  }
  onConfigurationChanged(e) {
    this.domNode.setClassName(this._getEditorClassName());
    this._applyLayout();
    return false;
  }
  onCursorStateChanged(e) {
    this._selections = e.selections;
    return false;
  }
  onFocusChanged(e) {
    this.domNode.setClassName(this._getEditorClassName());
    return false;
  }
  onThemeChanged(e) {
    this.domNode.setClassName(this._getEditorClassName());
    return false;
  }
  dispose() {
    if (this._renderAnimationFrame !== null) {
      this._renderAnimationFrame.dispose();
      this._renderAnimationFrame = null;
    }
    this._contentWidgets.overflowingContentWidgetsDomNode.domNode.remove();
    this._context.removeEventHandler(this);
    this._viewLines.dispose();
    for (let i = 0, len = this._viewParts.length; i < len; i++) {
      this._viewParts[i].dispose();
    }
    super.dispose();
  }
  _scheduleRender() {
    if (this._renderAnimationFrame === null) {
      this._renderAnimationFrame = runAtThisOrScheduleAtNextAnimationFrame(this._onRenderScheduled.bind(this), 100);
    }
  }
  _onRenderScheduled() {
    this._renderAnimationFrame = null;
    this._flushAccumulatedAndRenderNow();
  }
  _renderNow() {
    safeInvokeNoArg(() => this._actualRender());
  }
  _getViewPartsToRender() {
    let result = [], resultLen = 0;
    for (let i = 0, len = this._viewParts.length; i < len; i++) {
      const viewPart = this._viewParts[i];
      if (viewPart.shouldRender()) {
        result[resultLen++] = viewPart;
      }
    }
    return result;
  }
  _actualRender() {
    if (!isInDOM(this.domNode.domNode)) {
      return;
    }
    let viewPartsToRender = this._getViewPartsToRender();
    if (!this._viewLines.shouldRender() && viewPartsToRender.length === 0) {
      return;
    }
    const partialViewportData = this._context.viewLayout.getLinesViewportData();
    this._context.model.setViewport(partialViewportData.startLineNumber, partialViewportData.endLineNumber, partialViewportData.centeredLineNumber);
    const viewportData = new ViewportData(this._selections, partialViewportData, this._context.viewLayout.getWhitespaceViewportData(), this._context.model);
    if (this._contentWidgets.shouldRender()) {
      this._contentWidgets.onBeforeRender(viewportData);
    }
    if (this._viewLines.shouldRender()) {
      this._viewLines.renderText(viewportData);
      this._viewLines.onDidRender();
      viewPartsToRender = this._getViewPartsToRender();
    }
    const renderingContext = new RenderingContext(this._context.viewLayout, viewportData, this._viewLines);
    for (let i = 0, len = viewPartsToRender.length; i < len; i++) {
      const viewPart = viewPartsToRender[i];
      viewPart.prepareRender(renderingContext);
    }
    for (let i = 0, len = viewPartsToRender.length; i < len; i++) {
      const viewPart = viewPartsToRender[i];
      viewPart.render(renderingContext);
      viewPart.onDidRender();
    }
  }
  delegateVerticalScrollbarMouseDown(browserEvent) {
    this._scrollbar.delegateVerticalScrollbarMouseDown(browserEvent);
  }
  restoreState(scrollPosition) {
    this._context.model.setScrollPosition({scrollTop: scrollPosition.scrollTop}, 1);
    this._context.model.tokenizeViewport();
    this._renderNow();
    this._viewLines.updateLineWidths();
    this._context.model.setScrollPosition({scrollLeft: scrollPosition.scrollLeft}, 1);
  }
  getOffsetForColumn(modelLineNumber, modelColumn) {
    const modelPosition = this._context.model.validateModelPosition({
      lineNumber: modelLineNumber,
      column: modelColumn
    });
    const viewPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);
    this._flushAccumulatedAndRenderNow();
    const visibleRange = this._viewLines.visibleRangeForPosition(new Position(viewPosition.lineNumber, viewPosition.column));
    if (!visibleRange) {
      return -1;
    }
    return visibleRange.left;
  }
  getTargetAtClientPoint(clientX, clientY) {
    const mouseTarget = this._pointerHandler.getTargetAtClientPoint(clientX, clientY);
    if (!mouseTarget) {
      return null;
    }
    return ViewUserInputEvents.convertViewToModelMouseTarget(mouseTarget, this._context.model.coordinatesConverter);
  }
  createOverviewRuler(cssClassName) {
    return new OverviewRuler(this._context, cssClassName);
  }
  change(callback) {
    this._viewZones.changeViewZones(callback);
    this._scheduleRender();
  }
  render(now, everything) {
    if (everything) {
      this._viewLines.forceShouldRender();
      for (let i = 0, len = this._viewParts.length; i < len; i++) {
        const viewPart = this._viewParts[i];
        viewPart.forceShouldRender();
      }
    }
    if (now) {
      this._flushAccumulatedAndRenderNow();
    } else {
      this._scheduleRender();
    }
  }
  focus() {
    this._textAreaHandler.focusTextArea();
  }
  isFocused() {
    return this._textAreaHandler.isFocused();
  }
  setAriaOptions(options) {
    this._textAreaHandler.setAriaOptions(options);
  }
  addContentWidget(widgetData) {
    this._contentWidgets.addWidget(widgetData.widget);
    this.layoutContentWidget(widgetData);
    this._scheduleRender();
  }
  layoutContentWidget(widgetData) {
    let newRange = widgetData.position ? widgetData.position.range || null : null;
    if (newRange === null) {
      const newPosition = widgetData.position ? widgetData.position.position : null;
      if (newPosition !== null) {
        newRange = new Range(newPosition.lineNumber, newPosition.column, newPosition.lineNumber, newPosition.column);
      }
    }
    const newPreference = widgetData.position ? widgetData.position.preference : null;
    this._contentWidgets.setWidgetPosition(widgetData.widget, newRange, newPreference);
    this._scheduleRender();
  }
  removeContentWidget(widgetData) {
    this._contentWidgets.removeWidget(widgetData.widget);
    this._scheduleRender();
  }
  addOverlayWidget(widgetData) {
    this._overlayWidgets.addWidget(widgetData.widget);
    this.layoutOverlayWidget(widgetData);
    this._scheduleRender();
  }
  layoutOverlayWidget(widgetData) {
    const newPreference = widgetData.position ? widgetData.position.preference : null;
    const shouldRender = this._overlayWidgets.setWidgetPosition(widgetData.widget, newPreference);
    if (shouldRender) {
      this._scheduleRender();
    }
  }
  removeOverlayWidget(widgetData) {
    this._overlayWidgets.removeWidget(widgetData.widget);
    this._scheduleRender();
  }
};
function safeInvokeNoArg(func) {
  try {
    return func();
  } catch (e) {
    onUnexpectedError(e);
  }
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/controller/oneCursor.js
var OneCursor = class {
  constructor(context) {
    this._selTrackedRange = null;
    this._trackSelection = true;
    this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0));
  }
  dispose(context) {
    this._removeTrackedRange(context);
  }
  startTrackingSelection(context) {
    this._trackSelection = true;
    this._updateTrackedRange(context);
  }
  stopTrackingSelection(context) {
    this._trackSelection = false;
    this._removeTrackedRange(context);
  }
  _updateTrackedRange(context) {
    if (!this._trackSelection) {
      return;
    }
    this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0);
  }
  _removeTrackedRange(context) {
    this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0);
  }
  asCursorState() {
    return new CursorState(this.modelState, this.viewState);
  }
  readSelectionFromMarkers(context) {
    const range2 = context.model._getTrackedRange(this._selTrackedRange);
    if (this.modelState.selection.getDirection() === 0) {
      return new Selection(range2.startLineNumber, range2.startColumn, range2.endLineNumber, range2.endColumn);
    }
    return new Selection(range2.endLineNumber, range2.endColumn, range2.startLineNumber, range2.startColumn);
  }
  ensureValidState(context) {
    this._setState(context, this.modelState, this.viewState);
  }
  setState(context, modelState, viewState) {
    this._setState(context, modelState, viewState);
  }
  _setState(context, modelState, viewState) {
    if (!modelState) {
      if (!viewState) {
        return;
      }
      const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));
      const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));
      modelState = new SingleCursorState(selectionStart, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);
    } else {
      const selectionStart = context.model.validateRange(modelState.selectionStart);
      const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;
      const position = context.model.validatePosition(modelState.position);
      const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;
      modelState = new SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);
    }
    if (!viewState) {
      const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));
      const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));
      const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);
      const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);
      viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);
    } else {
      const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);
      const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);
      viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);
    }
    this.modelState = modelState;
    this.viewState = viewState;
    this._updateTrackedRange(context);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursorCollection.js
var CursorCollection = class {
  constructor(context) {
    this.context = context;
    this.primaryCursor = new OneCursor(context);
    this.secondaryCursors = [];
    this.lastAddedCursorIndex = 0;
  }
  dispose() {
    this.primaryCursor.dispose(this.context);
    this.killSecondaryCursors();
  }
  startTrackingSelections() {
    this.primaryCursor.startTrackingSelection(this.context);
    for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {
      this.secondaryCursors[i].startTrackingSelection(this.context);
    }
  }
  stopTrackingSelections() {
    this.primaryCursor.stopTrackingSelection(this.context);
    for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {
      this.secondaryCursors[i].stopTrackingSelection(this.context);
    }
  }
  updateContext(context) {
    this.context = context;
  }
  ensureValidState() {
    this.primaryCursor.ensureValidState(this.context);
    for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {
      this.secondaryCursors[i].ensureValidState(this.context);
    }
  }
  readSelectionFromMarkers() {
    let result = [];
    result[0] = this.primaryCursor.readSelectionFromMarkers(this.context);
    for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {
      result[i + 1] = this.secondaryCursors[i].readSelectionFromMarkers(this.context);
    }
    return result;
  }
  getAll() {
    let result = [];
    result[0] = this.primaryCursor.asCursorState();
    for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {
      result[i + 1] = this.secondaryCursors[i].asCursorState();
    }
    return result;
  }
  getViewPositions() {
    let result = [];
    result[0] = this.primaryCursor.viewState.position;
    for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {
      result[i + 1] = this.secondaryCursors[i].viewState.position;
    }
    return result;
  }
  getTopMostViewPosition() {
    let result = this.primaryCursor.viewState.position;
    for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {
      const viewPosition = this.secondaryCursors[i].viewState.position;
      if (viewPosition.isBefore(result)) {
        result = viewPosition;
      }
    }
    return result;
  }
  getBottomMostViewPosition() {
    let result = this.primaryCursor.viewState.position;
    for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {
      const viewPosition = this.secondaryCursors[i].viewState.position;
      if (result.isBeforeOrEqual(viewPosition)) {
        result = viewPosition;
      }
    }
    return result;
  }
  getSelections() {
    let result = [];
    result[0] = this.primaryCursor.modelState.selection;
    for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {
      result[i + 1] = this.secondaryCursors[i].modelState.selection;
    }
    return result;
  }
  getViewSelections() {
    let result = [];
    result[0] = this.primaryCursor.viewState.selection;
    for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {
      result[i + 1] = this.secondaryCursors[i].viewState.selection;
    }
    return result;
  }
  setSelections(selections) {
    this.setStates(CursorState.fromModelSelections(selections));
  }
  getPrimaryCursor() {
    return this.primaryCursor.asCursorState();
  }
  setStates(states) {
    if (states === null) {
      return;
    }
    this.primaryCursor.setState(this.context, states[0].modelState, states[0].viewState);
    this._setSecondaryStates(states.slice(1));
  }
  _setSecondaryStates(secondaryStates) {
    const secondaryCursorsLength = this.secondaryCursors.length;
    const secondaryStatesLength = secondaryStates.length;
    if (secondaryCursorsLength < secondaryStatesLength) {
      let createCnt = secondaryStatesLength - secondaryCursorsLength;
      for (let i = 0; i < createCnt; i++) {
        this._addSecondaryCursor();
      }
    } else if (secondaryCursorsLength > secondaryStatesLength) {
      let removeCnt = secondaryCursorsLength - secondaryStatesLength;
      for (let i = 0; i < removeCnt; i++) {
        this._removeSecondaryCursor(this.secondaryCursors.length - 1);
      }
    }
    for (let i = 0; i < secondaryStatesLength; i++) {
      this.secondaryCursors[i].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);
    }
  }
  killSecondaryCursors() {
    this._setSecondaryStates([]);
  }
  _addSecondaryCursor() {
    this.secondaryCursors.push(new OneCursor(this.context));
    this.lastAddedCursorIndex = this.secondaryCursors.length;
  }
  getLastAddedCursorIndex() {
    if (this.secondaryCursors.length === 0 || this.lastAddedCursorIndex === 0) {
      return 0;
    }
    return this.lastAddedCursorIndex;
  }
  _removeSecondaryCursor(removeIndex) {
    if (this.lastAddedCursorIndex >= removeIndex + 1) {
      this.lastAddedCursorIndex--;
    }
    this.secondaryCursors[removeIndex].dispose(this.context);
    this.secondaryCursors.splice(removeIndex, 1);
  }
  _getAll() {
    let result = [];
    result[0] = this.primaryCursor;
    for (let i = 0, len = this.secondaryCursors.length; i < len; i++) {
      result[i + 1] = this.secondaryCursors[i];
    }
    return result;
  }
  normalize() {
    if (this.secondaryCursors.length === 0) {
      return;
    }
    let cursors = this._getAll();
    let sortedCursors = [];
    for (let i = 0, len = cursors.length; i < len; i++) {
      sortedCursors.push({
        index: i,
        selection: cursors[i].modelState.selection
      });
    }
    sortedCursors.sort((a, b) => {
      if (a.selection.startLineNumber === b.selection.startLineNumber) {
        return a.selection.startColumn - b.selection.startColumn;
      }
      return a.selection.startLineNumber - b.selection.startLineNumber;
    });
    for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {
      const current = sortedCursors[sortedCursorIndex];
      const next = sortedCursors[sortedCursorIndex + 1];
      const currentSelection = current.selection;
      const nextSelection = next.selection;
      if (!this.context.cursorConfig.multiCursorMergeOverlapping) {
        continue;
      }
      let shouldMergeCursors;
      if (nextSelection.isEmpty() || currentSelection.isEmpty()) {
        shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());
      } else {
        shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());
      }
      if (shouldMergeCursors) {
        const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;
        const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;
        const looserIndex = sortedCursors[looserSortedCursorIndex].index;
        const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;
        const looserSelection = sortedCursors[looserSortedCursorIndex].selection;
        const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;
        if (!looserSelection.equalsSelection(winnerSelection)) {
          const resultingRange = looserSelection.plusRange(winnerSelection);
          const looserSelectionIsLTR = looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn;
          const winnerSelectionIsLTR = winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn;
          let resultingSelectionIsLTR;
          if (looserIndex === this.lastAddedCursorIndex) {
            resultingSelectionIsLTR = looserSelectionIsLTR;
            this.lastAddedCursorIndex = winnerIndex;
          } else {
            resultingSelectionIsLTR = winnerSelectionIsLTR;
          }
          let resultingSelection;
          if (resultingSelectionIsLTR) {
            resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);
          } else {
            resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);
          }
          sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;
          const resultingState = CursorState.fromModelSelection(resultingSelection);
          cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);
        }
        for (const sortedCursor of sortedCursors) {
          if (sortedCursor.index > looserIndex) {
            sortedCursor.index--;
          }
        }
        cursors.splice(looserIndex, 1);
        sortedCursors.splice(looserSortedCursorIndex, 1);
        this._removeSecondaryCursor(looserIndex - 1);
        sortedCursorIndex--;
      }
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/view/viewEvents.js
var ViewConfigurationChangedEvent = class {
  constructor(source) {
    this.type = 0;
    this._source = source;
  }
  hasChanged(id) {
    return this._source.hasChanged(id);
  }
};
var ViewCursorStateChangedEvent = class {
  constructor(selections, modelSelections) {
    this.type = 1;
    this.selections = selections;
    this.modelSelections = modelSelections;
  }
};
var ViewDecorationsChangedEvent = class {
  constructor(source) {
    this.type = 2;
    if (source) {
      this.affectsMinimap = source.affectsMinimap;
      this.affectsOverviewRuler = source.affectsOverviewRuler;
    } else {
      this.affectsMinimap = true;
      this.affectsOverviewRuler = true;
    }
  }
};
var ViewFlushedEvent = class {
  constructor() {
    this.type = 3;
  }
};
var ViewFocusChangedEvent = class {
  constructor(isFocused) {
    this.type = 4;
    this.isFocused = isFocused;
  }
};
var ViewLanguageConfigurationEvent = class {
  constructor() {
    this.type = 5;
  }
};
var ViewLineMappingChangedEvent = class {
  constructor() {
    this.type = 6;
  }
};
var ViewLinesChangedEvent = class {
  constructor(fromLineNumber, toLineNumber) {
    this.type = 7;
    this.fromLineNumber = fromLineNumber;
    this.toLineNumber = toLineNumber;
  }
};
var ViewLinesDeletedEvent = class {
  constructor(fromLineNumber, toLineNumber) {
    this.type = 8;
    this.fromLineNumber = fromLineNumber;
    this.toLineNumber = toLineNumber;
  }
};
var ViewLinesInsertedEvent = class {
  constructor(fromLineNumber, toLineNumber) {
    this.type = 9;
    this.fromLineNumber = fromLineNumber;
    this.toLineNumber = toLineNumber;
  }
};
var ViewRevealRangeRequestEvent = class {
  constructor(source, range2, selections, verticalType, revealHorizontal, scrollType) {
    this.type = 10;
    this.source = source;
    this.range = range2;
    this.selections = selections;
    this.verticalType = verticalType;
    this.revealHorizontal = revealHorizontal;
    this.scrollType = scrollType;
  }
};
var ViewScrollChangedEvent = class {
  constructor(source) {
    this.type = 11;
    this.scrollWidth = source.scrollWidth;
    this.scrollLeft = source.scrollLeft;
    this.scrollHeight = source.scrollHeight;
    this.scrollTop = source.scrollTop;
    this.scrollWidthChanged = source.scrollWidthChanged;
    this.scrollLeftChanged = source.scrollLeftChanged;
    this.scrollHeightChanged = source.scrollHeightChanged;
    this.scrollTopChanged = source.scrollTopChanged;
  }
};
var ViewThemeChangedEvent = class {
  constructor() {
    this.type = 12;
  }
};
var ViewTokensChangedEvent = class {
  constructor(ranges) {
    this.type = 13;
    this.ranges = ranges;
  }
};
var ViewTokensColorsChangedEvent = class {
  constructor() {
    this.type = 14;
  }
};
var ViewZonesChangedEvent = class {
  constructor() {
    this.type = 15;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelEventDispatcher.js
var ViewModelEventDispatcher = class extends Disposable {
  constructor() {
    super();
    this._onEvent = this._register(new Emitter());
    this.onEvent = this._onEvent.event;
    this._eventHandlers = [];
    this._viewEventQueue = null;
    this._isConsumingViewEventQueue = false;
    this._collector = null;
    this._collectorCnt = 0;
    this._outgoingEvents = [];
  }
  emitOutgoingEvent(e) {
    this._addOutgoingEvent(e);
    this._emitOugoingEvents();
  }
  _addOutgoingEvent(e) {
    for (let i = 0, len = this._outgoingEvents.length; i < len; i++) {
      if (this._outgoingEvents[i].kind === e.kind) {
        this._outgoingEvents[i] = this._outgoingEvents[i].merge(e);
        return;
      }
    }
    this._outgoingEvents.push(e);
  }
  _emitOugoingEvents() {
    while (this._outgoingEvents.length > 0) {
      if (this._collector || this._isConsumingViewEventQueue) {
        return;
      }
      const event = this._outgoingEvents.shift();
      if (event.isNoOp()) {
        continue;
      }
      this._onEvent.fire(event);
    }
  }
  addViewEventHandler(eventHandler) {
    for (let i = 0, len = this._eventHandlers.length; i < len; i++) {
      if (this._eventHandlers[i] === eventHandler) {
        console.warn("Detected duplicate listener in ViewEventDispatcher", eventHandler);
      }
    }
    this._eventHandlers.push(eventHandler);
  }
  removeViewEventHandler(eventHandler) {
    for (let i = 0; i < this._eventHandlers.length; i++) {
      if (this._eventHandlers[i] === eventHandler) {
        this._eventHandlers.splice(i, 1);
        break;
      }
    }
  }
  beginEmitViewEvents() {
    this._collectorCnt++;
    if (this._collectorCnt === 1) {
      this._collector = new ViewModelEventsCollector();
    }
    return this._collector;
  }
  endEmitViewEvents() {
    this._collectorCnt--;
    if (this._collectorCnt === 0) {
      const outgoingEvents = this._collector.outgoingEvents;
      const viewEvents3 = this._collector.viewEvents;
      this._collector = null;
      for (const outgoingEvent of outgoingEvents) {
        this._addOutgoingEvent(outgoingEvent);
      }
      if (viewEvents3.length > 0) {
        this._emitMany(viewEvents3);
      }
    }
    this._emitOugoingEvents();
  }
  emitSingleViewEvent(event) {
    try {
      const eventsCollector = this.beginEmitViewEvents();
      eventsCollector.emitViewEvent(event);
    } finally {
      this.endEmitViewEvents();
    }
  }
  _emitMany(events) {
    if (this._viewEventQueue) {
      this._viewEventQueue = this._viewEventQueue.concat(events);
    } else {
      this._viewEventQueue = events;
    }
    if (!this._isConsumingViewEventQueue) {
      this._consumeViewEventQueue();
    }
  }
  _consumeViewEventQueue() {
    try {
      this._isConsumingViewEventQueue = true;
      this._doConsumeQueue();
    } finally {
      this._isConsumingViewEventQueue = false;
    }
  }
  _doConsumeQueue() {
    while (this._viewEventQueue) {
      const events = this._viewEventQueue;
      this._viewEventQueue = null;
      const eventHandlers = this._eventHandlers.slice(0);
      for (const eventHandler of eventHandlers) {
        eventHandler.handleEvents(events);
      }
    }
  }
};
var ViewModelEventsCollector = class {
  constructor() {
    this.viewEvents = [];
    this.outgoingEvents = [];
  }
  emitViewEvent(event) {
    this.viewEvents.push(event);
  }
  emitOutgoingEvent(e) {
    this.outgoingEvents.push(e);
  }
};
var ContentSizeChangedEvent = class {
  constructor(oldContentWidth, oldContentHeight, contentWidth, contentHeight) {
    this.kind = 0;
    this._oldContentWidth = oldContentWidth;
    this._oldContentHeight = oldContentHeight;
    this.contentWidth = contentWidth;
    this.contentHeight = contentHeight;
    this.contentWidthChanged = this._oldContentWidth !== this.contentWidth;
    this.contentHeightChanged = this._oldContentHeight !== this.contentHeight;
  }
  isNoOp() {
    return !this.contentWidthChanged && !this.contentHeightChanged;
  }
  merge(other) {
    if (other.kind !== 0) {
      return this;
    }
    return new ContentSizeChangedEvent(this._oldContentWidth, this._oldContentHeight, other.contentWidth, other.contentHeight);
  }
};
var FocusChangedEvent = class {
  constructor(oldHasFocus, hasFocus) {
    this.kind = 1;
    this.oldHasFocus = oldHasFocus;
    this.hasFocus = hasFocus;
  }
  isNoOp() {
    return this.oldHasFocus === this.hasFocus;
  }
  merge(other) {
    if (other.kind !== 1) {
      return this;
    }
    return new FocusChangedEvent(this.oldHasFocus, other.hasFocus);
  }
};
var ScrollChangedEvent = class {
  constructor(oldScrollWidth, oldScrollLeft, oldScrollHeight, oldScrollTop, scrollWidth, scrollLeft, scrollHeight, scrollTop) {
    this.kind = 2;
    this._oldScrollWidth = oldScrollWidth;
    this._oldScrollLeft = oldScrollLeft;
    this._oldScrollHeight = oldScrollHeight;
    this._oldScrollTop = oldScrollTop;
    this.scrollWidth = scrollWidth;
    this.scrollLeft = scrollLeft;
    this.scrollHeight = scrollHeight;
    this.scrollTop = scrollTop;
    this.scrollWidthChanged = this._oldScrollWidth !== this.scrollWidth;
    this.scrollLeftChanged = this._oldScrollLeft !== this.scrollLeft;
    this.scrollHeightChanged = this._oldScrollHeight !== this.scrollHeight;
    this.scrollTopChanged = this._oldScrollTop !== this.scrollTop;
  }
  isNoOp() {
    return !this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged;
  }
  merge(other) {
    if (other.kind !== 2) {
      return this;
    }
    return new ScrollChangedEvent(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, other.scrollWidth, other.scrollLeft, other.scrollHeight, other.scrollTop);
  }
};
var ViewZonesChangedEvent2 = class {
  constructor() {
    this.kind = 3;
  }
  isNoOp() {
    return false;
  }
  merge(other) {
    return this;
  }
};
var CursorStateChangedEvent = class {
  constructor(oldSelections, selections, oldModelVersionId, modelVersionId, source, reason, reachedMaxCursorCount) {
    this.kind = 5;
    this.oldSelections = oldSelections;
    this.selections = selections;
    this.oldModelVersionId = oldModelVersionId;
    this.modelVersionId = modelVersionId;
    this.source = source;
    this.reason = reason;
    this.reachedMaxCursorCount = reachedMaxCursorCount;
  }
  static _selectionsAreEqual(a, b) {
    if (!a && !b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    const aLen = a.length;
    const bLen = b.length;
    if (aLen !== bLen) {
      return false;
    }
    for (let i = 0; i < aLen; i++) {
      if (!a[i].equalsSelection(b[i])) {
        return false;
      }
    }
    return true;
  }
  isNoOp() {
    return CursorStateChangedEvent._selectionsAreEqual(this.oldSelections, this.selections) && this.oldModelVersionId === this.modelVersionId;
  }
  merge(other) {
    if (other.kind !== 5) {
      return this;
    }
    return new CursorStateChangedEvent(this.oldSelections, other.selections, this.oldModelVersionId, other.modelVersionId, other.source, other.reason, this.reachedMaxCursorCount || other.reachedMaxCursorCount);
  }
};
var ReadOnlyEditAttemptEvent = class {
  constructor() {
    this.kind = 4;
  }
  isNoOp() {
    return false;
  }
  merge(other) {
    return this;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/controller/cursor.js
var CursorModelState = class {
  constructor(model2, cursor) {
    this.modelVersionId = model2.getVersionId();
    this.cursorState = cursor.getCursorStates();
  }
  equals(other) {
    if (!other) {
      return false;
    }
    if (this.modelVersionId !== other.modelVersionId) {
      return false;
    }
    if (this.cursorState.length !== other.cursorState.length) {
      return false;
    }
    for (let i = 0, len = this.cursorState.length; i < len; i++) {
      if (!this.cursorState[i].equals(other.cursorState[i])) {
        return false;
      }
    }
    return true;
  }
};
var AutoClosedAction = class {
  constructor(model2, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {
    this._model = model2;
    this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;
    this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;
  }
  static getAllAutoClosedCharacters(autoClosedActions) {
    let autoClosedCharacters = [];
    for (const autoClosedAction of autoClosedActions) {
      autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());
    }
    return autoClosedCharacters;
  }
  dispose() {
    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);
    this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);
  }
  getAutoClosedCharactersRanges() {
    let result = [];
    for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {
      const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);
      if (decorationRange) {
        result.push(decorationRange);
      }
    }
    return result;
  }
  isValid(selections) {
    let enclosingRanges = [];
    for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {
      const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);
      if (decorationRange) {
        enclosingRanges.push(decorationRange);
        if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {
          return false;
        }
      }
    }
    enclosingRanges.sort(Range.compareRangesUsingStarts);
    selections.sort(Range.compareRangesUsingStarts);
    for (let i = 0; i < selections.length; i++) {
      if (i >= enclosingRanges.length) {
        return false;
      }
      if (!enclosingRanges[i].strictContainsRange(selections[i])) {
        return false;
      }
    }
    return true;
  }
};
var Cursor = class extends Disposable {
  constructor(model2, viewModel, coordinatesConverter, cursorConfig) {
    super();
    this._model = model2;
    this._knownModelVersionId = this._model.getVersionId();
    this._viewModel = viewModel;
    this._coordinatesConverter = coordinatesConverter;
    this.context = new CursorContext(this._model, this._coordinatesConverter, cursorConfig);
    this._cursors = new CursorCollection(this.context);
    this._hasFocus = false;
    this._isHandling = false;
    this._isDoingComposition = false;
    this._selectionsWhenCompositionStarted = null;
    this._columnSelectData = null;
    this._autoClosedActions = [];
    this._prevEditOperationType = 0;
  }
  dispose() {
    this._cursors.dispose();
    this._autoClosedActions = dispose(this._autoClosedActions);
    super.dispose();
  }
  updateConfiguration(cursorConfig) {
    this.context = new CursorContext(this._model, this._coordinatesConverter, cursorConfig);
    this._cursors.updateContext(this.context);
  }
  onLineMappingChanged(eventsCollector) {
    if (this._knownModelVersionId !== this._model.getVersionId()) {
      return;
    }
    this.setStates(eventsCollector, "viewModel", 0, this.getCursorStates());
  }
  setHasFocus(hasFocus) {
    this._hasFocus = hasFocus;
  }
  _validateAutoClosedActions() {
    if (this._autoClosedActions.length > 0) {
      let selections = this._cursors.getSelections();
      for (let i = 0; i < this._autoClosedActions.length; i++) {
        const autoClosedAction = this._autoClosedActions[i];
        if (!autoClosedAction.isValid(selections)) {
          autoClosedAction.dispose();
          this._autoClosedActions.splice(i, 1);
          i--;
        }
      }
    }
  }
  getPrimaryCursorState() {
    return this._cursors.getPrimaryCursor();
  }
  getLastAddedCursorIndex() {
    return this._cursors.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursors.getAll();
  }
  setStates(eventsCollector, source, reason, states) {
    let reachedMaxCursorCount = false;
    if (states !== null && states.length > Cursor.MAX_CURSOR_COUNT) {
      states = states.slice(0, Cursor.MAX_CURSOR_COUNT);
      reachedMaxCursorCount = true;
    }
    const oldState = new CursorModelState(this._model, this);
    this._cursors.setStates(states);
    this._cursors.normalize();
    this._columnSelectData = null;
    this._validateAutoClosedActions();
    return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);
  }
  setCursorColumnSelectData(columnSelectData) {
    this._columnSelectData = columnSelectData;
  }
  revealPrimary(eventsCollector, source, revealHorizontal, scrollType) {
    const viewPositions = this._cursors.getViewPositions();
    if (viewPositions.length > 1) {
      this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), 0, revealHorizontal, scrollType);
      return;
    } else {
      const viewPosition = viewPositions[0];
      const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);
      this._emitCursorRevealRange(eventsCollector, source, viewRange, null, 0, revealHorizontal, scrollType);
    }
  }
  _revealPrimaryCursor(eventsCollector, source, verticalType, revealHorizontal, scrollType) {
    const viewPositions = this._cursors.getViewPositions();
    if (viewPositions.length > 1) {
      this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), verticalType, revealHorizontal, scrollType);
    } else {
      const viewPosition = viewPositions[0];
      const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);
      this._emitCursorRevealRange(eventsCollector, source, viewRange, null, verticalType, revealHorizontal, scrollType);
    }
  }
  _emitCursorRevealRange(eventsCollector, source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType) {
    eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType));
  }
  saveState() {
    let result = [];
    const selections = this._cursors.getSelections();
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      result.push({
        inSelectionMode: !selection.isEmpty(),
        selectionStart: {
          lineNumber: selection.selectionStartLineNumber,
          column: selection.selectionStartColumn
        },
        position: {
          lineNumber: selection.positionLineNumber,
          column: selection.positionColumn
        }
      });
    }
    return result;
  }
  restoreState(eventsCollector, states) {
    let desiredSelections = [];
    for (let i = 0, len = states.length; i < len; i++) {
      const state = states[i];
      let positionLineNumber = 1;
      let positionColumn = 1;
      if (state.position && state.position.lineNumber) {
        positionLineNumber = state.position.lineNumber;
      }
      if (state.position && state.position.column) {
        positionColumn = state.position.column;
      }
      let selectionStartLineNumber = positionLineNumber;
      let selectionStartColumn = positionColumn;
      if (state.selectionStart && state.selectionStart.lineNumber) {
        selectionStartLineNumber = state.selectionStart.lineNumber;
      }
      if (state.selectionStart && state.selectionStart.column) {
        selectionStartColumn = state.selectionStart.column;
      }
      desiredSelections.push({
        selectionStartLineNumber,
        selectionStartColumn,
        positionLineNumber,
        positionColumn
      });
    }
    this.setStates(eventsCollector, "restoreState", 0, CursorState.fromModelSelections(desiredSelections));
    this.revealPrimary(eventsCollector, "restoreState", true, 1);
  }
  onModelContentChanged(eventsCollector, e) {
    this._knownModelVersionId = e.versionId;
    if (this._isHandling) {
      return;
    }
    const hadFlushEvent = e.containsEvent(1);
    this._prevEditOperationType = 0;
    if (hadFlushEvent) {
      this._cursors.dispose();
      this._cursors = new CursorCollection(this.context);
      this._validateAutoClosedActions();
      this._emitStateChangedIfNecessary(eventsCollector, "model", 1, null, false);
    } else {
      if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {
        const cursorState = CursorState.fromModelSelections(e.resultingSelection);
        if (this.setStates(eventsCollector, "modelChange", e.isUndoing ? 5 : e.isRedoing ? 6 : 2, cursorState)) {
          this._revealPrimaryCursor(eventsCollector, "modelChange", 0, true, 0);
        }
      } else {
        const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();
        this.setStates(eventsCollector, "modelChange", 2, CursorState.fromModelSelections(selectionsFromMarkers));
      }
    }
  }
  getSelection() {
    return this._cursors.getPrimaryCursor().modelState.selection;
  }
  getTopMostViewPosition() {
    return this._cursors.getTopMostViewPosition();
  }
  getBottomMostViewPosition() {
    return this._cursors.getBottomMostViewPosition();
  }
  getCursorColumnSelectData() {
    if (this._columnSelectData) {
      return this._columnSelectData;
    }
    const primaryCursor = this._cursors.getPrimaryCursor();
    const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();
    const viewPosition = primaryCursor.viewState.position;
    return {
      isReal: false,
      fromViewLineNumber: viewSelectionStart.lineNumber,
      fromViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewSelectionStart),
      toViewLineNumber: viewPosition.lineNumber,
      toViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewPosition)
    };
  }
  getSelections() {
    return this._cursors.getSelections();
  }
  setSelections(eventsCollector, source, selections) {
    this.setStates(eventsCollector, source, 0, CursorState.fromModelSelections(selections));
  }
  getPrevEditOperationType() {
    return this._prevEditOperationType;
  }
  setPrevEditOperationType(type) {
    this._prevEditOperationType = type;
  }
  _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {
    let autoClosedCharactersDeltaDecorations = [];
    let autoClosedEnclosingDeltaDecorations = [];
    for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {
      autoClosedCharactersDeltaDecorations.push({
        range: autoClosedCharactersRanges[i],
        options: {
          inlineClassName: "auto-closed-character",
          stickiness: 1
        }
      });
      autoClosedEnclosingDeltaDecorations.push({
        range: autoClosedEnclosingRanges[i],
        options: {
          stickiness: 1
        }
      });
    }
    const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);
    const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);
    this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));
  }
  _executeEditOperation(opResult) {
    if (!opResult) {
      return;
    }
    if (opResult.shouldPushStackElementBefore) {
      this._model.pushStackElement();
    }
    const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);
    if (result) {
      this._interpretCommandResult(result);
      let autoClosedCharactersRanges = [];
      let autoClosedEnclosingRanges = [];
      for (let i = 0; i < opResult.commands.length; i++) {
        const command = opResult.commands[i];
        if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {
          autoClosedCharactersRanges.push(command.closeCharacterRange);
          autoClosedEnclosingRanges.push(command.enclosingRange);
        }
      }
      if (autoClosedCharactersRanges.length > 0) {
        this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);
      }
      this._prevEditOperationType = opResult.type;
    }
    if (opResult.shouldPushStackElementAfter) {
      this._model.pushStackElement();
    }
  }
  _interpretCommandResult(cursorState) {
    if (!cursorState || cursorState.length === 0) {
      cursorState = this._cursors.readSelectionFromMarkers();
    }
    this._columnSelectData = null;
    this._cursors.setSelections(cursorState);
    this._cursors.normalize();
  }
  _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {
    const newState = new CursorModelState(this._model, this);
    if (newState.equals(oldState)) {
      return false;
    }
    const selections = this._cursors.getSelections();
    const viewSelections = this._cursors.getViewSelections();
    eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections));
    if (!oldState || oldState.cursorState.length !== newState.cursorState.length || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {
      const oldSelections = oldState ? oldState.cursorState.map((s) => s.modelState.selection) : null;
      const oldModelVersionId = oldState ? oldState.modelVersionId : 0;
      eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || "keyboard", reason, reachedMaxCursorCount));
    }
    return true;
  }
  _findAutoClosingPairs(edits) {
    if (!edits.length) {
      return null;
    }
    let indices = [];
    for (let i = 0, len = edits.length; i < len; i++) {
      const edit = edits[i];
      if (!edit.text || edit.text.indexOf("\n") >= 0) {
        return null;
      }
      const m = edit.text.match(/([)\]}>'"`])([^)\]}>'"`]*)$/);
      if (!m) {
        return null;
      }
      const closeChar = m[1];
      const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairsClose2.get(closeChar);
      if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {
        return null;
      }
      const openChar = autoClosingPairsCandidates[0].open;
      const closeCharIndex = edit.text.length - m[2].length - 1;
      const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);
      if (openCharIndex === -1) {
        return null;
      }
      indices.push([openCharIndex, closeCharIndex]);
    }
    return indices;
  }
  executeEdits(eventsCollector, source, edits, cursorStateComputer) {
    let autoClosingIndices = null;
    if (source === "snippet") {
      autoClosingIndices = this._findAutoClosingPairs(edits);
    }
    if (autoClosingIndices) {
      edits[0]._isTracked = true;
    }
    let autoClosedCharactersRanges = [];
    let autoClosedEnclosingRanges = [];
    const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {
      if (autoClosingIndices) {
        for (let i = 0, len = autoClosingIndices.length; i < len; i++) {
          const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];
          const undoEdit = undoEdits[i];
          const lineNumber = undoEdit.range.startLineNumber;
          const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;
          const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;
          autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));
          autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));
        }
      }
      const selections2 = cursorStateComputer(undoEdits);
      if (selections2) {
        this._isHandling = true;
      }
      return selections2;
    });
    if (selections) {
      this._isHandling = false;
      this.setSelections(eventsCollector, source, selections);
    }
    if (autoClosedCharactersRanges.length > 0) {
      this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);
    }
  }
  _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0) {
    if (this.context.cursorConfig.readOnly) {
      return;
    }
    const oldState = new CursorModelState(this._model, this);
    this._cursors.stopTrackingSelections();
    this._isHandling = true;
    try {
      this._cursors.ensureValidState();
      callback();
    } catch (err) {
      onUnexpectedError(err);
    }
    this._isHandling = false;
    this._cursors.startTrackingSelections();
    this._validateAutoClosedActions();
    if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {
      this._revealPrimaryCursor(eventsCollector, source, 0, true, 0);
    }
  }
  setIsDoingComposition(isDoingComposition) {
    this._isDoingComposition = isDoingComposition;
  }
  startComposition(eventsCollector) {
    this._selectionsWhenCompositionStarted = this.getSelections().slice(0);
  }
  endComposition(eventsCollector, source) {
    this._executeEdit(() => {
      if (source === "keyboard") {
        const autoClosedCharacters = AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);
        this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this._selectionsWhenCompositionStarted, this.getSelections(), autoClosedCharacters));
        this._selectionsWhenCompositionStarted = null;
      }
    }, eventsCollector, source);
  }
  type(eventsCollector, text, source) {
    this._executeEdit(() => {
      if (source === "keyboard") {
        const len = text.length;
        let offset = 0;
        while (offset < len) {
          const charLength = nextCharLength(text, offset);
          const chr = text.substr(offset, charLength);
          const autoClosedCharacters = AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);
          this._executeEditOperation(TypeOperations.typeWithInterceptors(this._isDoingComposition, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), autoClosedCharacters, chr));
          offset += charLength;
        }
      } else {
        this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));
      }
    }, eventsCollector, source);
  }
  replacePreviousChar(eventsCollector, text, replaceCharCnt, source) {
    this._executeEdit(() => {
      this._executeEditOperation(TypeOperations.replacePreviousChar(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replaceCharCnt));
    }, eventsCollector, source);
  }
  paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {
    this._executeEdit(() => {
      this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));
    }, eventsCollector, source, 4);
  }
  cut(eventsCollector, source) {
    this._executeEdit(() => {
      this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));
    }, eventsCollector, source);
  }
  executeCommand(eventsCollector, command, source) {
    this._executeEdit(() => {
      this._cursors.killSecondaryCursors();
      this._executeEditOperation(new EditOperationResult(0, [command], {
        shouldPushStackElementBefore: false,
        shouldPushStackElementAfter: false
      }));
    }, eventsCollector, source);
  }
  executeCommands(eventsCollector, commands, source) {
    this._executeEdit(() => {
      this._executeEditOperation(new EditOperationResult(0, commands, {
        shouldPushStackElementBefore: false,
        shouldPushStackElementAfter: false
      }));
    }, eventsCollector, source);
  }
};
Cursor.MAX_CURSOR_COUNT = 1e4;
var CommandExecutor = class {
  static executeCommands(model2, selectionsBefore, commands) {
    const ctx = {
      model: model2,
      selectionsBefore,
      trackedRanges: [],
      trackedRangesDirection: []
    };
    const result = this._innerExecuteCommands(ctx, commands);
    for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {
      ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0);
    }
    return result;
  }
  static _innerExecuteCommands(ctx, commands) {
    if (this._arrayIsEmpty(commands)) {
      return null;
    }
    const commandsData = this._getEditOperations(ctx, commands);
    if (commandsData.operations.length === 0) {
      return null;
    }
    const rawOperations = commandsData.operations;
    const loserCursorsMap = this._getLoserCursorMap(rawOperations);
    if (loserCursorsMap.hasOwnProperty("0")) {
      console.warn("Ignoring commands");
      return null;
    }
    let filteredOperations = [];
    for (let i = 0, len = rawOperations.length; i < len; i++) {
      if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {
        filteredOperations.push(rawOperations[i]);
      }
    }
    if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {
      filteredOperations[0]._isTracked = true;
    }
    let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {
      let groupedInverseEditOperations = [];
      for (let i = 0; i < ctx.selectionsBefore.length; i++) {
        groupedInverseEditOperations[i] = [];
      }
      for (const op of inverseEditOperations) {
        if (!op.identifier) {
          continue;
        }
        groupedInverseEditOperations[op.identifier.major].push(op);
      }
      const minorBasedSorter = (a, b) => {
        return a.identifier.minor - b.identifier.minor;
      };
      let cursorSelections = [];
      for (let i = 0; i < ctx.selectionsBefore.length; i++) {
        if (groupedInverseEditOperations[i].length > 0) {
          groupedInverseEditOperations[i].sort(minorBasedSorter);
          cursorSelections[i] = commands[i].computeCursorState(ctx.model, {
            getInverseEditOperations: () => {
              return groupedInverseEditOperations[i];
            },
            getTrackedSelection: (id) => {
              const idx = parseInt(id, 10);
              const range2 = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);
              if (ctx.trackedRangesDirection[idx] === 0) {
                return new Selection(range2.startLineNumber, range2.startColumn, range2.endLineNumber, range2.endColumn);
              }
              return new Selection(range2.endLineNumber, range2.endColumn, range2.startLineNumber, range2.startColumn);
            }
          });
        } else {
          cursorSelections[i] = ctx.selectionsBefore[i];
        }
      }
      return cursorSelections;
    });
    if (!selectionsAfter) {
      selectionsAfter = ctx.selectionsBefore;
    }
    let losingCursors = [];
    for (let losingCursorIndex in loserCursorsMap) {
      if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {
        losingCursors.push(parseInt(losingCursorIndex, 10));
      }
    }
    losingCursors.sort((a, b) => {
      return b - a;
    });
    for (const losingCursor of losingCursors) {
      selectionsAfter.splice(losingCursor, 1);
    }
    return selectionsAfter;
  }
  static _arrayIsEmpty(commands) {
    for (let i = 0, len = commands.length; i < len; i++) {
      if (commands[i]) {
        return false;
      }
    }
    return true;
  }
  static _getEditOperations(ctx, commands) {
    let operations = [];
    let hadTrackedEditOperation = false;
    for (let i = 0, len = commands.length; i < len; i++) {
      const command = commands[i];
      if (command) {
        const r = this._getEditOperationsFromCommand(ctx, i, command);
        operations = operations.concat(r.operations);
        hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;
      }
    }
    return {
      operations,
      hadTrackedEditOperation
    };
  }
  static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {
    let operations = [];
    let operationMinor = 0;
    const addEditOperation = (range2, text, forceMoveMarkers = false) => {
      if (Range.isEmpty(range2) && text === "") {
        return;
      }
      operations.push({
        identifier: {
          major: majorIdentifier,
          minor: operationMinor++
        },
        range: range2,
        text,
        forceMoveMarkers,
        isAutoWhitespaceEdit: command.insertsAutoWhitespace
      });
    };
    let hadTrackedEditOperation = false;
    const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {
      hadTrackedEditOperation = true;
      addEditOperation(selection, text, forceMoveMarkers);
    };
    const trackSelection = (_selection, trackPreviousOnEmpty) => {
      const selection = Selection.liftSelection(_selection);
      let stickiness;
      if (selection.isEmpty()) {
        if (typeof trackPreviousOnEmpty === "boolean") {
          if (trackPreviousOnEmpty) {
            stickiness = 2;
          } else {
            stickiness = 3;
          }
        } else {
          const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);
          if (selection.startColumn === maxLineColumn) {
            stickiness = 2;
          } else {
            stickiness = 3;
          }
        }
      } else {
        stickiness = 1;
      }
      const l = ctx.trackedRanges.length;
      const id = ctx.model._setTrackedRange(null, selection, stickiness);
      ctx.trackedRanges[l] = id;
      ctx.trackedRangesDirection[l] = selection.getDirection();
      return l.toString();
    };
    const editOperationBuilder = {
      addEditOperation,
      addTrackedEditOperation,
      trackSelection
    };
    try {
      command.getEditOperations(ctx.model, editOperationBuilder);
    } catch (e) {
      onUnexpectedError(e);
      return {
        operations: [],
        hadTrackedEditOperation: false
      };
    }
    return {
      operations,
      hadTrackedEditOperation
    };
  }
  static _getLoserCursorMap(operations) {
    operations = operations.slice(0);
    operations.sort((a, b) => {
      return -Range.compareRangesUsingEnds(a.range, b.range);
    });
    let loserCursorsMap = {};
    for (let i = 1; i < operations.length; i++) {
      const previousOp = operations[i - 1];
      const currentOp = operations[i];
      if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {
        let loserMajor;
        if (previousOp.identifier.major > currentOp.identifier.major) {
          loserMajor = previousOp.identifier.major;
        } else {
          loserMajor = currentOp.identifier.major;
        }
        loserCursorsMap[loserMajor.toString()] = true;
        for (let j = 0; j < operations.length; j++) {
          if (operations[j].identifier.major === loserMajor) {
            operations.splice(j, 1);
            if (j < i) {
              i--;
            }
            j--;
          }
        }
        if (i > 0) {
          i--;
        }
      }
    }
    return loserCursorsMap;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js
var InternalEditorAction = class {
  constructor(id, label, alias, precondition, run, contextKeyService) {
    this.id = id;
    this.label = label;
    this.alias = alias;
    this._precondition = precondition;
    this._run = run;
    this._contextKeyService = contextKeyService;
  }
  isSupported() {
    return this._contextKeyService.contextMatchesRules(this._precondition);
  }
  run() {
    if (!this.isSupported()) {
      return Promise.resolve(void 0);
    }
    return this._run();
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/textToHtmlTokenizer.js
function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {
  let result = `<div>`;
  let charIndex = startOffset;
  let tabsCharDelta = 0;
  for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {
    const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);
    if (tokenEndIndex <= startOffset) {
      continue;
    }
    let partContent = "";
    for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {
      const charCode = text.charCodeAt(charIndex);
      switch (charCode) {
        case 9:
          let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
          tabsCharDelta += insertSpacesCount - 1;
          while (insertSpacesCount > 0) {
            partContent += useNbsp ? "&#160;" : " ";
            insertSpacesCount--;
          }
          break;
        case 60:
          partContent += "&lt;";
          break;
        case 62:
          partContent += "&gt;";
          break;
        case 38:
          partContent += "&amp;";
          break;
        case 0:
          partContent += "&#00;";
          break;
        case 65279:
        case 8232:
        case 8233:
        case 133:
          partContent += "\uFFFD";
          break;
        case 13:
          partContent += "&#8203";
          break;
        case 32:
          partContent += useNbsp ? "&#160;" : " ";
          break;
        default:
          partContent += String.fromCharCode(charCode);
      }
    }
    result += `<span style="${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}">${partContent}</span>`;
    if (tokenEndIndex > endOffset || charIndex >= endOffset) {
      break;
    }
  }
  result += `</div>`;
  return result;
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js
var PendingChanges = class {
  constructor() {
    this._hasPending = false;
    this._inserts = [];
    this._changes = [];
    this._removes = [];
  }
  insert(x) {
    this._hasPending = true;
    this._inserts.push(x);
  }
  change(x) {
    this._hasPending = true;
    this._changes.push(x);
  }
  remove(x) {
    this._hasPending = true;
    this._removes.push(x);
  }
  mustCommit() {
    return this._hasPending;
  }
  commit(linesLayout) {
    if (!this._hasPending) {
      return;
    }
    const inserts = this._inserts;
    const changes = this._changes;
    const removes = this._removes;
    this._hasPending = false;
    this._inserts = [];
    this._changes = [];
    this._removes = [];
    linesLayout._commitPendingChanges(inserts, changes, removes);
  }
};
var EditorWhitespace = class {
  constructor(id, afterLineNumber, ordinal, height, minWidth) {
    this.id = id;
    this.afterLineNumber = afterLineNumber;
    this.ordinal = ordinal;
    this.height = height;
    this.minWidth = minWidth;
    this.prefixSum = 0;
  }
};
var LinesLayout = class {
  constructor(lineCount, lineHeight, paddingTop, paddingBottom) {
    this._instanceId = singleLetterHash(++LinesLayout.INSTANCE_COUNT);
    this._pendingChanges = new PendingChanges();
    this._lastWhitespaceId = 0;
    this._arr = [];
    this._prefixSumValidIndex = -1;
    this._minWidth = -1;
    this._lineCount = lineCount;
    this._lineHeight = lineHeight;
    this._paddingTop = paddingTop;
    this._paddingBottom = paddingBottom;
  }
  static findInsertionIndex(arr, afterLineNumber, ordinal) {
    let low = 0;
    let high = arr.length;
    while (low < high) {
      const mid = low + high >>> 1;
      if (afterLineNumber === arr[mid].afterLineNumber) {
        if (ordinal < arr[mid].ordinal) {
          high = mid;
        } else {
          low = mid + 1;
        }
      } else if (afterLineNumber < arr[mid].afterLineNumber) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    return low;
  }
  setLineHeight(lineHeight) {
    this._checkPendingChanges();
    this._lineHeight = lineHeight;
  }
  setPadding(paddingTop, paddingBottom) {
    this._paddingTop = paddingTop;
    this._paddingBottom = paddingBottom;
  }
  onFlushed(lineCount) {
    this._checkPendingChanges();
    this._lineCount = lineCount;
  }
  changeWhitespace(callback) {
    let hadAChange = false;
    try {
      const accessor = {
        insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {
          hadAChange = true;
          afterLineNumber = afterLineNumber | 0;
          ordinal = ordinal | 0;
          heightInPx = heightInPx | 0;
          minWidth = minWidth | 0;
          const id = this._instanceId + ++this._lastWhitespaceId;
          this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));
          return id;
        },
        changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {
          hadAChange = true;
          newAfterLineNumber = newAfterLineNumber | 0;
          newHeight = newHeight | 0;
          this._pendingChanges.change({id, newAfterLineNumber, newHeight});
        },
        removeWhitespace: (id) => {
          hadAChange = true;
          this._pendingChanges.remove({id});
        }
      };
      callback(accessor);
    } finally {
      this._pendingChanges.commit(this);
    }
    return hadAChange;
  }
  _commitPendingChanges(inserts, changes, removes) {
    if (inserts.length > 0 || removes.length > 0) {
      this._minWidth = -1;
    }
    if (inserts.length + changes.length + removes.length <= 1) {
      for (const insert of inserts) {
        this._insertWhitespace(insert);
      }
      for (const change of changes) {
        this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);
      }
      for (const remove of removes) {
        const index = this._findWhitespaceIndex(remove.id);
        if (index === -1) {
          continue;
        }
        this._removeWhitespace(index);
      }
      return;
    }
    const toRemove = new Set();
    for (const remove of removes) {
      toRemove.add(remove.id);
    }
    const toChange = new Map();
    for (const change of changes) {
      toChange.set(change.id, change);
    }
    const applyRemoveAndChange = (whitespaces) => {
      let result2 = [];
      for (const whitespace of whitespaces) {
        if (toRemove.has(whitespace.id)) {
          continue;
        }
        if (toChange.has(whitespace.id)) {
          const change = toChange.get(whitespace.id);
          whitespace.afterLineNumber = change.newAfterLineNumber;
          whitespace.height = change.newHeight;
        }
        result2.push(whitespace);
      }
      return result2;
    };
    const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));
    result.sort((a, b) => {
      if (a.afterLineNumber === b.afterLineNumber) {
        return a.ordinal - b.ordinal;
      }
      return a.afterLineNumber - b.afterLineNumber;
    });
    this._arr = result;
    this._prefixSumValidIndex = -1;
  }
  _checkPendingChanges() {
    if (this._pendingChanges.mustCommit()) {
      this._pendingChanges.commit(this);
    }
  }
  _insertWhitespace(whitespace) {
    const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);
    this._arr.splice(insertIndex, 0, whitespace);
    this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);
  }
  _findWhitespaceIndex(id) {
    const arr = this._arr;
    for (let i = 0, len = arr.length; i < len; i++) {
      if (arr[i].id === id) {
        return i;
      }
    }
    return -1;
  }
  _changeOneWhitespace(id, newAfterLineNumber, newHeight) {
    const index = this._findWhitespaceIndex(id);
    if (index === -1) {
      return;
    }
    if (this._arr[index].height !== newHeight) {
      this._arr[index].height = newHeight;
      this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);
    }
    if (this._arr[index].afterLineNumber !== newAfterLineNumber) {
      const whitespace = this._arr[index];
      this._removeWhitespace(index);
      whitespace.afterLineNumber = newAfterLineNumber;
      this._insertWhitespace(whitespace);
    }
  }
  _removeWhitespace(removeIndex) {
    this._arr.splice(removeIndex, 1);
    this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);
  }
  onLinesDeleted(fromLineNumber, toLineNumber) {
    this._checkPendingChanges();
    fromLineNumber = fromLineNumber | 0;
    toLineNumber = toLineNumber | 0;
    this._lineCount -= toLineNumber - fromLineNumber + 1;
    for (let i = 0, len = this._arr.length; i < len; i++) {
      const afterLineNumber = this._arr[i].afterLineNumber;
      if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {
        this._arr[i].afterLineNumber = fromLineNumber - 1;
      } else if (afterLineNumber > toLineNumber) {
        this._arr[i].afterLineNumber -= toLineNumber - fromLineNumber + 1;
      }
    }
  }
  onLinesInserted(fromLineNumber, toLineNumber) {
    this._checkPendingChanges();
    fromLineNumber = fromLineNumber | 0;
    toLineNumber = toLineNumber | 0;
    this._lineCount += toLineNumber - fromLineNumber + 1;
    for (let i = 0, len = this._arr.length; i < len; i++) {
      const afterLineNumber = this._arr[i].afterLineNumber;
      if (fromLineNumber <= afterLineNumber) {
        this._arr[i].afterLineNumber += toLineNumber - fromLineNumber + 1;
      }
    }
  }
  getWhitespacesTotalHeight() {
    this._checkPendingChanges();
    if (this._arr.length === 0) {
      return 0;
    }
    return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);
  }
  getWhitespacesAccumulatedHeight(index) {
    this._checkPendingChanges();
    index = index | 0;
    let startIndex = Math.max(0, this._prefixSumValidIndex + 1);
    if (startIndex === 0) {
      this._arr[0].prefixSum = this._arr[0].height;
      startIndex++;
    }
    for (let i = startIndex; i <= index; i++) {
      this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;
    }
    this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);
    return this._arr[index].prefixSum;
  }
  getLinesTotalHeight() {
    this._checkPendingChanges();
    const linesHeight = this._lineHeight * this._lineCount;
    const whitespacesHeight = this.getWhitespacesTotalHeight();
    return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;
  }
  getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {
    this._checkPendingChanges();
    lineNumber = lineNumber | 0;
    const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);
    if (lastWhitespaceBeforeLineNumber === -1) {
      return 0;
    }
    return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);
  }
  _findLastWhitespaceBeforeLineNumber(lineNumber) {
    lineNumber = lineNumber | 0;
    const arr = this._arr;
    let low = 0;
    let high = arr.length - 1;
    while (low <= high) {
      const delta = high - low | 0;
      const halfDelta = delta / 2 | 0;
      const mid = low + halfDelta | 0;
      if (arr[mid].afterLineNumber < lineNumber) {
        if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {
          return mid;
        } else {
          low = mid + 1 | 0;
        }
      } else {
        high = mid - 1 | 0;
      }
    }
    return -1;
  }
  _findFirstWhitespaceAfterLineNumber(lineNumber) {
    lineNumber = lineNumber | 0;
    const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);
    const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;
    if (firstWhitespaceAfterLineNumber < this._arr.length) {
      return firstWhitespaceAfterLineNumber;
    }
    return -1;
  }
  getFirstWhitespaceIndexAfterLineNumber(lineNumber) {
    this._checkPendingChanges();
    lineNumber = lineNumber | 0;
    return this._findFirstWhitespaceAfterLineNumber(lineNumber);
  }
  getVerticalOffsetForLineNumber(lineNumber) {
    this._checkPendingChanges();
    lineNumber = lineNumber | 0;
    let previousLinesHeight;
    if (lineNumber > 1) {
      previousLinesHeight = this._lineHeight * (lineNumber - 1);
    } else {
      previousLinesHeight = 0;
    }
    const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber);
    return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;
  }
  getWhitespaceMinWidth() {
    this._checkPendingChanges();
    if (this._minWidth === -1) {
      let minWidth = 0;
      for (let i = 0, len = this._arr.length; i < len; i++) {
        minWidth = Math.max(minWidth, this._arr[i].minWidth);
      }
      this._minWidth = minWidth;
    }
    return this._minWidth;
  }
  isAfterLines(verticalOffset) {
    this._checkPendingChanges();
    const totalHeight = this.getLinesTotalHeight();
    return verticalOffset > totalHeight;
  }
  getLineNumberAtOrAfterVerticalOffset(verticalOffset) {
    this._checkPendingChanges();
    verticalOffset = verticalOffset | 0;
    if (verticalOffset < 0) {
      return 1;
    }
    const linesCount = this._lineCount | 0;
    const lineHeight = this._lineHeight;
    let minLineNumber = 1;
    let maxLineNumber = linesCount;
    while (minLineNumber < maxLineNumber) {
      const midLineNumber = (minLineNumber + maxLineNumber) / 2 | 0;
      const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;
      if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {
        minLineNumber = midLineNumber + 1;
      } else if (verticalOffset >= midLineNumberVerticalOffset) {
        return midLineNumber;
      } else {
        maxLineNumber = midLineNumber;
      }
    }
    if (minLineNumber > linesCount) {
      return linesCount;
    }
    return minLineNumber;
  }
  getLinesViewportData(verticalOffset1, verticalOffset2) {
    this._checkPendingChanges();
    verticalOffset1 = verticalOffset1 | 0;
    verticalOffset2 = verticalOffset2 | 0;
    const lineHeight = this._lineHeight;
    const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;
    const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;
    let endLineNumber = this._lineCount | 0;
    let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;
    const whitespaceCount = this.getWhitespacesCount() | 0;
    let currentWhitespaceHeight;
    let currentWhitespaceAfterLineNumber;
    if (whitespaceIndex === -1) {
      whitespaceIndex = whitespaceCount;
      currentWhitespaceAfterLineNumber = endLineNumber + 1;
      currentWhitespaceHeight = 0;
    } else {
      currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;
      currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;
    }
    let currentVerticalOffset = startLineNumberVerticalOffset;
    let currentLineRelativeOffset = currentVerticalOffset;
    const STEP_SIZE = 5e5;
    let bigNumbersDelta = 0;
    if (startLineNumberVerticalOffset >= STEP_SIZE) {
      bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;
      bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;
      currentLineRelativeOffset -= bigNumbersDelta;
    }
    const linesOffsets = [];
    const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;
    let centeredLineNumber = -1;
    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      if (centeredLineNumber === -1) {
        const currentLineTop = currentVerticalOffset;
        const currentLineBottom = currentVerticalOffset + lineHeight;
        if (currentLineTop <= verticalCenter && verticalCenter < currentLineBottom || currentLineTop > verticalCenter) {
          centeredLineNumber = lineNumber;
        }
      }
      currentVerticalOffset += lineHeight;
      linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;
      currentLineRelativeOffset += lineHeight;
      while (currentWhitespaceAfterLineNumber === lineNumber) {
        currentLineRelativeOffset += currentWhitespaceHeight;
        currentVerticalOffset += currentWhitespaceHeight;
        whitespaceIndex++;
        if (whitespaceIndex >= whitespaceCount) {
          currentWhitespaceAfterLineNumber = endLineNumber + 1;
        } else {
          currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;
          currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;
        }
      }
      if (currentVerticalOffset >= verticalOffset2) {
        endLineNumber = lineNumber;
        break;
      }
    }
    if (centeredLineNumber === -1) {
      centeredLineNumber = endLineNumber;
    }
    const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;
    let completelyVisibleStartLineNumber = startLineNumber;
    let completelyVisibleEndLineNumber = endLineNumber;
    if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {
      if (startLineNumberVerticalOffset < verticalOffset1) {
        completelyVisibleStartLineNumber++;
      }
    }
    if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {
      if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {
        completelyVisibleEndLineNumber--;
      }
    }
    return {
      bigNumbersDelta,
      startLineNumber,
      endLineNumber,
      relativeVerticalOffset: linesOffsets,
      centeredLineNumber,
      completelyVisibleStartLineNumber,
      completelyVisibleEndLineNumber
    };
  }
  getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {
    this._checkPendingChanges();
    whitespaceIndex = whitespaceIndex | 0;
    const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);
    let previousLinesHeight;
    if (afterLineNumber >= 1) {
      previousLinesHeight = this._lineHeight * afterLineNumber;
    } else {
      previousLinesHeight = 0;
    }
    let previousWhitespacesHeight;
    if (whitespaceIndex > 0) {
      previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);
    } else {
      previousWhitespacesHeight = 0;
    }
    return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;
  }
  getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {
    this._checkPendingChanges();
    verticalOffset = verticalOffset | 0;
    let minWhitespaceIndex = 0;
    let maxWhitespaceIndex = this.getWhitespacesCount() - 1;
    if (maxWhitespaceIndex < 0) {
      return -1;
    }
    const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);
    const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);
    if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {
      return -1;
    }
    while (minWhitespaceIndex < maxWhitespaceIndex) {
      const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);
      const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);
      const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);
      if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {
        minWhitespaceIndex = midWhitespaceIndex + 1;
      } else if (verticalOffset >= midWhitespaceVerticalOffset) {
        return midWhitespaceIndex;
      } else {
        maxWhitespaceIndex = midWhitespaceIndex;
      }
    }
    return minWhitespaceIndex;
  }
  getWhitespaceAtVerticalOffset(verticalOffset) {
    this._checkPendingChanges();
    verticalOffset = verticalOffset | 0;
    const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);
    if (candidateIndex < 0) {
      return null;
    }
    if (candidateIndex >= this.getWhitespacesCount()) {
      return null;
    }
    const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);
    if (candidateTop > verticalOffset) {
      return null;
    }
    const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);
    const candidateId = this.getIdForWhitespaceIndex(candidateIndex);
    const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);
    return {
      id: candidateId,
      afterLineNumber: candidateAfterLineNumber,
      verticalOffset: candidateTop,
      height: candidateHeight
    };
  }
  getWhitespaceViewportData(verticalOffset1, verticalOffset2) {
    this._checkPendingChanges();
    verticalOffset1 = verticalOffset1 | 0;
    verticalOffset2 = verticalOffset2 | 0;
    const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);
    const endIndex = this.getWhitespacesCount() - 1;
    if (startIndex < 0) {
      return [];
    }
    let result = [];
    for (let i = startIndex; i <= endIndex; i++) {
      const top = this.getVerticalOffsetForWhitespaceIndex(i);
      const height = this.getHeightForWhitespaceIndex(i);
      if (top >= verticalOffset2) {
        break;
      }
      result.push({
        id: this.getIdForWhitespaceIndex(i),
        afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),
        verticalOffset: top,
        height
      });
    }
    return result;
  }
  getWhitespaces() {
    this._checkPendingChanges();
    return this._arr.slice(0);
  }
  getWhitespacesCount() {
    this._checkPendingChanges();
    return this._arr.length;
  }
  getIdForWhitespaceIndex(index) {
    this._checkPendingChanges();
    index = index | 0;
    return this._arr[index].id;
  }
  getAfterLineNumberForWhitespaceIndex(index) {
    this._checkPendingChanges();
    index = index | 0;
    return this._arr[index].afterLineNumber;
  }
  getHeightForWhitespaceIndex(index) {
    this._checkPendingChanges();
    index = index | 0;
    return this._arr[index].height;
  }
};
LinesLayout.INSTANCE_COUNT = 0;

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLayout.js
var SMOOTH_SCROLLING_TIME = 125;
var EditorScrollDimensions = class {
  constructor(width, contentWidth, height, contentHeight) {
    width = width | 0;
    contentWidth = contentWidth | 0;
    height = height | 0;
    contentHeight = contentHeight | 0;
    if (width < 0) {
      width = 0;
    }
    if (contentWidth < 0) {
      contentWidth = 0;
    }
    if (height < 0) {
      height = 0;
    }
    if (contentHeight < 0) {
      contentHeight = 0;
    }
    this.width = width;
    this.contentWidth = contentWidth;
    this.scrollWidth = Math.max(width, contentWidth);
    this.height = height;
    this.contentHeight = contentHeight;
    this.scrollHeight = Math.max(height, contentHeight);
  }
  equals(other) {
    return this.width === other.width && this.contentWidth === other.contentWidth && this.height === other.height && this.contentHeight === other.contentHeight;
  }
};
var EditorScrollable = class extends Disposable {
  constructor(smoothScrollDuration, scheduleAtNextAnimationFrame2) {
    super();
    this._onDidContentSizeChange = this._register(new Emitter());
    this.onDidContentSizeChange = this._onDidContentSizeChange.event;
    this._dimensions = new EditorScrollDimensions(0, 0, 0, 0);
    this._scrollable = this._register(new Scrollable(smoothScrollDuration, scheduleAtNextAnimationFrame2));
    this.onDidScroll = this._scrollable.onScroll;
  }
  getScrollable() {
    return this._scrollable;
  }
  setSmoothScrollDuration(smoothScrollDuration) {
    this._scrollable.setSmoothScrollDuration(smoothScrollDuration);
  }
  validateScrollPosition(scrollPosition) {
    return this._scrollable.validateScrollPosition(scrollPosition);
  }
  getScrollDimensions() {
    return this._dimensions;
  }
  setScrollDimensions(dimensions) {
    if (this._dimensions.equals(dimensions)) {
      return;
    }
    const oldDimensions = this._dimensions;
    this._dimensions = dimensions;
    this._scrollable.setScrollDimensions({
      width: dimensions.width,
      scrollWidth: dimensions.scrollWidth,
      height: dimensions.height,
      scrollHeight: dimensions.scrollHeight
    }, true);
    const contentWidthChanged = oldDimensions.contentWidth !== dimensions.contentWidth;
    const contentHeightChanged = oldDimensions.contentHeight !== dimensions.contentHeight;
    if (contentWidthChanged || contentHeightChanged) {
      this._onDidContentSizeChange.fire(new ContentSizeChangedEvent(oldDimensions.contentWidth, oldDimensions.contentHeight, dimensions.contentWidth, dimensions.contentHeight));
    }
  }
  getFutureScrollPosition() {
    return this._scrollable.getFutureScrollPosition();
  }
  getCurrentScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  setScrollPositionNow(update) {
    this._scrollable.setScrollPositionNow(update);
  }
  setScrollPositionSmooth(update) {
    this._scrollable.setScrollPositionSmooth(update);
  }
};
var ViewLayout = class extends Disposable {
  constructor(configuration, lineCount, scheduleAtNextAnimationFrame2) {
    super();
    this._configuration = configuration;
    const options = this._configuration.options;
    const layoutInfo = options.get(117);
    const padding = options.get(66);
    this._linesLayout = new LinesLayout(lineCount, options.get(51), padding.top, padding.bottom);
    this._scrollable = this._register(new EditorScrollable(0, scheduleAtNextAnimationFrame2));
    this._configureSmoothScrollDuration();
    this._scrollable.setScrollDimensions(new EditorScrollDimensions(layoutInfo.contentWidth, 0, layoutInfo.height, 0));
    this.onDidScroll = this._scrollable.onDidScroll;
    this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange;
    this._updateHeight();
  }
  dispose() {
    super.dispose();
  }
  getScrollable() {
    return this._scrollable.getScrollable();
  }
  onHeightMaybeChanged() {
    this._updateHeight();
  }
  _configureSmoothScrollDuration() {
    this._scrollable.setSmoothScrollDuration(this._configuration.options.get(94) ? SMOOTH_SCROLLING_TIME : 0);
  }
  onConfigurationChanged(e) {
    const options = this._configuration.options;
    if (e.hasChanged(51)) {
      this._linesLayout.setLineHeight(options.get(51));
    }
    if (e.hasChanged(66)) {
      const padding = options.get(66);
      this._linesLayout.setPadding(padding.top, padding.bottom);
    }
    if (e.hasChanged(117)) {
      const layoutInfo = options.get(117);
      const width = layoutInfo.contentWidth;
      const height = layoutInfo.height;
      const scrollDimensions = this._scrollable.getScrollDimensions();
      const contentWidth = scrollDimensions.contentWidth;
      this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));
    } else {
      this._updateHeight();
    }
    if (e.hasChanged(94)) {
      this._configureSmoothScrollDuration();
    }
  }
  onFlushed(lineCount) {
    this._linesLayout.onFlushed(lineCount);
  }
  onLinesDeleted(fromLineNumber, toLineNumber) {
    this._linesLayout.onLinesDeleted(fromLineNumber, toLineNumber);
  }
  onLinesInserted(fromLineNumber, toLineNumber) {
    this._linesLayout.onLinesInserted(fromLineNumber, toLineNumber);
  }
  _getHorizontalScrollbarHeight(width, scrollWidth) {
    const options = this._configuration.options;
    const scrollbar = options.get(84);
    if (scrollbar.horizontal === 2) {
      return 0;
    }
    if (width >= scrollWidth) {
      return 0;
    }
    return scrollbar.horizontalScrollbarSize;
  }
  _getContentHeight(width, height, contentWidth) {
    const options = this._configuration.options;
    let result = this._linesLayout.getLinesTotalHeight();
    if (options.get(86)) {
      result += height - options.get(51);
    } else {
      result += this._getHorizontalScrollbarHeight(width, contentWidth);
    }
    return result;
  }
  _updateHeight() {
    const scrollDimensions = this._scrollable.getScrollDimensions();
    const width = scrollDimensions.width;
    const height = scrollDimensions.height;
    const contentWidth = scrollDimensions.contentWidth;
    this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));
  }
  getCurrentViewport() {
    const scrollDimensions = this._scrollable.getScrollDimensions();
    const currentScrollPosition = this._scrollable.getCurrentScrollPosition();
    return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);
  }
  getFutureViewport() {
    const scrollDimensions = this._scrollable.getScrollDimensions();
    const currentScrollPosition = this._scrollable.getFutureScrollPosition();
    return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);
  }
  _computeContentWidth(maxLineWidth) {
    const options = this._configuration.options;
    const wrappingInfo = options.get(118);
    const fontInfo = options.get(36);
    if (wrappingInfo.isViewportWrapping) {
      const layoutInfo = options.get(117);
      const minimap = options.get(56);
      if (maxLineWidth > layoutInfo.contentWidth + fontInfo.typicalHalfwidthCharacterWidth) {
        if (minimap.enabled && minimap.side === "right") {
          return maxLineWidth + layoutInfo.verticalScrollbarWidth;
        }
      }
      return maxLineWidth;
    } else {
      const extraHorizontalSpace = options.get(85) * fontInfo.typicalHalfwidthCharacterWidth;
      const whitespaceMinWidth = this._linesLayout.getWhitespaceMinWidth();
      return Math.max(maxLineWidth + extraHorizontalSpace, whitespaceMinWidth);
    }
  }
  setMaxLineWidth(maxLineWidth) {
    const scrollDimensions = this._scrollable.getScrollDimensions();
    this._scrollable.setScrollDimensions(new EditorScrollDimensions(scrollDimensions.width, this._computeContentWidth(maxLineWidth), scrollDimensions.height, scrollDimensions.contentHeight));
    this._updateHeight();
  }
  saveState() {
    const currentScrollPosition = this._scrollable.getFutureScrollPosition();
    let scrollTop = currentScrollPosition.scrollTop;
    let firstLineNumberInViewport = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);
    let whitespaceAboveFirstLine = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);
    return {
      scrollTop,
      scrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,
      scrollLeft: currentScrollPosition.scrollLeft
    };
  }
  changeWhitespace(callback) {
    const hadAChange = this._linesLayout.changeWhitespace(callback);
    if (hadAChange) {
      this.onHeightMaybeChanged();
    }
    return hadAChange;
  }
  getVerticalOffsetForLineNumber(lineNumber) {
    return this._linesLayout.getVerticalOffsetForLineNumber(lineNumber);
  }
  isAfterLines(verticalOffset) {
    return this._linesLayout.isAfterLines(verticalOffset);
  }
  getLineNumberAtVerticalOffset(verticalOffset) {
    return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);
  }
  getWhitespaceAtVerticalOffset(verticalOffset) {
    return this._linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);
  }
  getLinesViewportData() {
    const visibleBox = this.getCurrentViewport();
    return this._linesLayout.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height);
  }
  getLinesViewportDataAtScrollTop(scrollTop) {
    const scrollDimensions = this._scrollable.getScrollDimensions();
    if (scrollTop + scrollDimensions.height > scrollDimensions.scrollHeight) {
      scrollTop = scrollDimensions.scrollHeight - scrollDimensions.height;
    }
    if (scrollTop < 0) {
      scrollTop = 0;
    }
    return this._linesLayout.getLinesViewportData(scrollTop, scrollTop + scrollDimensions.height);
  }
  getWhitespaceViewportData() {
    const visibleBox = this.getCurrentViewport();
    return this._linesLayout.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height);
  }
  getWhitespaces() {
    return this._linesLayout.getWhitespaces();
  }
  getContentWidth() {
    const scrollDimensions = this._scrollable.getScrollDimensions();
    return scrollDimensions.contentWidth;
  }
  getScrollWidth() {
    const scrollDimensions = this._scrollable.getScrollDimensions();
    return scrollDimensions.scrollWidth;
  }
  getContentHeight() {
    const scrollDimensions = this._scrollable.getScrollDimensions();
    return scrollDimensions.contentHeight;
  }
  getScrollHeight() {
    const scrollDimensions = this._scrollable.getScrollDimensions();
    return scrollDimensions.scrollHeight;
  }
  getCurrentScrollLeft() {
    const currentScrollPosition = this._scrollable.getCurrentScrollPosition();
    return currentScrollPosition.scrollLeft;
  }
  getCurrentScrollTop() {
    const currentScrollPosition = this._scrollable.getCurrentScrollPosition();
    return currentScrollPosition.scrollTop;
  }
  validateScrollPosition(scrollPosition) {
    return this._scrollable.validateScrollPosition(scrollPosition);
  }
  setScrollPosition(position, type) {
    if (type === 1) {
      this._scrollable.setScrollPositionNow(position);
    } else {
      this._scrollable.setScrollPositionSmooth(position);
    }
  }
  deltaScrollNow(deltaScrollLeft, deltaScrollTop) {
    const currentScrollPosition = this._scrollable.getCurrentScrollPosition();
    this._scrollable.setScrollPositionNow({
      scrollLeft: currentScrollPosition.scrollLeft + deltaScrollLeft,
      scrollTop: currentScrollPosition.scrollTop + deltaScrollTop
    });
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/splitLinesCollection.js
var OutputPosition = class {
  constructor(outputLineIndex, outputOffset) {
    this.outputLineIndex = outputLineIndex;
    this.outputOffset = outputOffset;
  }
};
var LineBreakData = class {
  constructor(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength) {
    this.breakOffsets = breakOffsets;
    this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;
    this.wrappedTextIndentLength = wrappedTextIndentLength;
  }
  static getInputOffsetOfOutputPosition(breakOffsets, outputLineIndex, outputOffset) {
    if (outputLineIndex === 0) {
      return outputOffset;
    } else {
      return breakOffsets[outputLineIndex - 1] + outputOffset;
    }
  }
  static getOutputPositionOfInputOffset(breakOffsets, inputOffset) {
    let low = 0;
    let high = breakOffsets.length - 1;
    let mid = 0;
    let midStart = 0;
    while (low <= high) {
      mid = low + (high - low) / 2 | 0;
      const midStop = breakOffsets[mid];
      midStart = mid > 0 ? breakOffsets[mid - 1] : 0;
      if (inputOffset < midStart) {
        high = mid - 1;
      } else if (inputOffset >= midStop) {
        low = mid + 1;
      } else {
        break;
      }
    }
    return new OutputPosition(mid, inputOffset - midStart);
  }
};
var CoordinatesConverter = class {
  constructor(lines) {
    this._lines = lines;
  }
  convertViewPositionToModelPosition(viewPosition) {
    return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);
  }
  convertViewRangeToModelRange(viewRange) {
    return this._lines.convertViewRangeToModelRange(viewRange);
  }
  validateViewPosition(viewPosition, expectedModelPosition) {
    return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);
  }
  validateViewRange(viewRange, expectedModelRange) {
    return this._lines.validateViewRange(viewRange, expectedModelRange);
  }
  convertModelPositionToViewPosition(modelPosition) {
    return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);
  }
  convertModelRangeToViewRange(modelRange) {
    return this._lines.convertModelRangeToViewRange(modelRange);
  }
  modelPositionIsVisible(modelPosition) {
    return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);
  }
};
var LineNumberMapper = class {
  constructor(viewLineCounts) {
    this._counts = viewLineCounts;
    this._isValid = false;
    this._validEndIndex = -1;
    this._modelToView = [];
    this._viewToModel = [];
  }
  _invalidate(index) {
    this._isValid = false;
    this._validEndIndex = Math.min(this._validEndIndex, index - 1);
  }
  _ensureValid() {
    if (this._isValid) {
      return;
    }
    for (let i = this._validEndIndex + 1, len = this._counts.length; i < len; i++) {
      const viewLineCount = this._counts[i];
      const viewLinesAbove = i > 0 ? this._modelToView[i - 1] : 0;
      this._modelToView[i] = viewLinesAbove + viewLineCount;
      for (let j = 0; j < viewLineCount; j++) {
        this._viewToModel[viewLinesAbove + j] = i;
      }
    }
    this._modelToView.length = this._counts.length;
    this._viewToModel.length = this._modelToView[this._modelToView.length - 1];
    this._isValid = true;
    this._validEndIndex = this._counts.length - 1;
  }
  changeValue(index, value) {
    if (this._counts[index] === value) {
      return;
    }
    this._counts[index] = value;
    this._invalidate(index);
  }
  removeValues(start, deleteCount) {
    this._counts.splice(start, deleteCount);
    this._invalidate(start);
  }
  insertValues(insertIndex, insertArr) {
    this._counts = arrayInsert(this._counts, insertIndex, insertArr);
    this._invalidate(insertIndex);
  }
  getTotalValue() {
    this._ensureValid();
    return this._viewToModel.length;
  }
  getAccumulatedValue(index) {
    this._ensureValid();
    return this._modelToView[index];
  }
  getIndexOf(accumulatedValue) {
    this._ensureValid();
    const modelLineIndex = this._viewToModel[accumulatedValue];
    const viewLinesAbove = modelLineIndex > 0 ? this._modelToView[modelLineIndex - 1] : 0;
    return new PrefixSumIndexOfResult(modelLineIndex, accumulatedValue - viewLinesAbove);
  }
};
var SplitLinesCollection = class {
  constructor(model2, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {
    this.model = model2;
    this._validModelVersionId = -1;
    this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;
    this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;
    this.fontInfo = fontInfo;
    this.tabSize = tabSize;
    this.wrappingStrategy = wrappingStrategy;
    this.wrappingColumn = wrappingColumn;
    this.wrappingIndent = wrappingIndent;
    this._constructLines(true, null);
  }
  dispose() {
    this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);
  }
  createCoordinatesConverter() {
    return new CoordinatesConverter(this);
  }
  _constructLines(resetHiddenAreas, previousLineBreaks) {
    this.lines = [];
    if (resetHiddenAreas) {
      this.hiddenAreasIds = [];
    }
    let linesContent = this.model.getLinesContent();
    const lineCount = linesContent.length;
    const lineBreaksComputer = this.createLineBreaksComputer();
    for (let i = 0; i < lineCount; i++) {
      lineBreaksComputer.addRequest(linesContent[i], previousLineBreaks ? previousLineBreaks[i] : null);
    }
    const linesBreaks = lineBreaksComputer.finalize();
    let values = [];
    let hiddenAreas = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);
    let hiddenAreaStart = 1, hiddenAreaEnd = 0;
    let hiddenAreaIdx = -1;
    let nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;
    for (let i = 0; i < lineCount; i++) {
      let lineNumber = i + 1;
      if (lineNumber === nextLineNumberToUpdateHiddenArea) {
        hiddenAreaIdx++;
        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;
        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;
        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;
      }
      let isInHiddenArea = lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd;
      let line = createSplitLine(linesBreaks[i], !isInHiddenArea);
      values[i] = line.getViewLineCount();
      this.lines[i] = line;
    }
    this._validModelVersionId = this.model.getVersionId();
    this.prefixSumComputer = new LineNumberMapper(values);
  }
  getHiddenAreas() {
    return this.hiddenAreasIds.map((decId) => {
      return this.model.getDecorationRange(decId);
    });
  }
  _reduceRanges(_ranges) {
    if (_ranges.length === 0) {
      return [];
    }
    let ranges = _ranges.map((r) => this.model.validateRange(r)).sort(Range.compareRangesUsingStarts);
    let result = [];
    let currentRangeStart = ranges[0].startLineNumber;
    let currentRangeEnd = ranges[0].endLineNumber;
    for (let i = 1, len = ranges.length; i < len; i++) {
      let range2 = ranges[i];
      if (range2.startLineNumber > currentRangeEnd + 1) {
        result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));
        currentRangeStart = range2.startLineNumber;
        currentRangeEnd = range2.endLineNumber;
      } else if (range2.endLineNumber > currentRangeEnd) {
        currentRangeEnd = range2.endLineNumber;
      }
    }
    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));
    return result;
  }
  setHiddenAreas(_ranges) {
    let newRanges = this._reduceRanges(_ranges);
    let oldRanges = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);
    if (newRanges.length === oldRanges.length) {
      let hasDifference = false;
      for (let i = 0; i < newRanges.length; i++) {
        if (!newRanges[i].equalsRange(oldRanges[i])) {
          hasDifference = true;
          break;
        }
      }
      if (!hasDifference) {
        return false;
      }
    }
    let newDecorations = [];
    for (const newRange of newRanges) {
      newDecorations.push({
        range: newRange,
        options: ModelDecorationOptions.EMPTY
      });
    }
    this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);
    let hiddenAreas = newRanges;
    let hiddenAreaStart = 1, hiddenAreaEnd = 0;
    let hiddenAreaIdx = -1;
    let nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.lines.length + 2;
    let hasVisibleLine = false;
    for (let i = 0; i < this.lines.length; i++) {
      let lineNumber = i + 1;
      if (lineNumber === nextLineNumberToUpdateHiddenArea) {
        hiddenAreaIdx++;
        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;
        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;
        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.lines.length + 2;
      }
      let lineChanged = false;
      if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {
        if (this.lines[i].isVisible()) {
          this.lines[i] = this.lines[i].setVisible(false);
          lineChanged = true;
        }
      } else {
        hasVisibleLine = true;
        if (!this.lines[i].isVisible()) {
          this.lines[i] = this.lines[i].setVisible(true);
          lineChanged = true;
        }
      }
      if (lineChanged) {
        let newOutputLineCount = this.lines[i].getViewLineCount();
        this.prefixSumComputer.changeValue(i, newOutputLineCount);
      }
    }
    if (!hasVisibleLine) {
      this.setHiddenAreas([]);
    }
    return true;
  }
  modelPositionIsVisible(modelLineNumber, _modelColumn) {
    if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {
      return false;
    }
    return this.lines[modelLineNumber - 1].isVisible();
  }
  setTabSize(newTabSize) {
    if (this.tabSize === newTabSize) {
      return false;
    }
    this.tabSize = newTabSize;
    this._constructLines(false, null);
    return true;
  }
  setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {
    const equalFontInfo = this.fontInfo.equals(fontInfo);
    const equalWrappingStrategy = this.wrappingStrategy === wrappingStrategy;
    const equalWrappingColumn = this.wrappingColumn === wrappingColumn;
    const equalWrappingIndent = this.wrappingIndent === wrappingIndent;
    if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {
      return false;
    }
    const onlyWrappingColumnChanged = equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent;
    this.fontInfo = fontInfo;
    this.wrappingStrategy = wrappingStrategy;
    this.wrappingColumn = wrappingColumn;
    this.wrappingIndent = wrappingIndent;
    let previousLineBreaks = null;
    if (onlyWrappingColumnChanged) {
      previousLineBreaks = [];
      for (let i = 0, len = this.lines.length; i < len; i++) {
        previousLineBreaks[i] = this.lines[i].getLineBreakData();
      }
    }
    this._constructLines(false, previousLineBreaks);
    return true;
  }
  createLineBreaksComputer() {
    const lineBreaksComputerFactory = this.wrappingStrategy === "advanced" ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory;
    return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);
  }
  onModelFlushed() {
    this._constructLines(true, null);
  }
  onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {
    if (versionId <= this._validModelVersionId) {
      return null;
    }
    let outputFromLineNumber = fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1;
    let outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);
    this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);
    this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);
    return new ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);
  }
  onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {
    if (versionId <= this._validModelVersionId) {
      return null;
    }
    let hiddenAreas = this.getHiddenAreas();
    let isInHiddenArea = false;
    let testPosition = new Position(fromLineNumber, 1);
    for (const hiddenArea of hiddenAreas) {
      if (hiddenArea.containsPosition(testPosition)) {
        isInHiddenArea = true;
        break;
      }
    }
    let outputFromLineNumber = fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1;
    let totalOutputLineCount = 0;
    let insertLines = [];
    let insertPrefixSumValues = [];
    for (let i = 0, len = lineBreaks.length; i < len; i++) {
      let line = createSplitLine(lineBreaks[i], !isInHiddenArea);
      insertLines.push(line);
      let outputLineCount = line.getViewLineCount();
      totalOutputLineCount += outputLineCount;
      insertPrefixSumValues[i] = outputLineCount;
    }
    this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));
    this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);
    return new ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);
  }
  onModelLineChanged(versionId, lineNumber, lineBreakData) {
    if (versionId <= this._validModelVersionId) {
      return [false, null, null, null];
    }
    let lineIndex = lineNumber - 1;
    let oldOutputLineCount = this.lines[lineIndex].getViewLineCount();
    let isVisible = this.lines[lineIndex].isVisible();
    let line = createSplitLine(lineBreakData, isVisible);
    this.lines[lineIndex] = line;
    let newOutputLineCount = this.lines[lineIndex].getViewLineCount();
    let lineMappingChanged = false;
    let changeFrom = 0;
    let changeTo = -1;
    let insertFrom = 0;
    let insertTo = -1;
    let deleteFrom = 0;
    let deleteTo = -1;
    if (oldOutputLineCount > newOutputLineCount) {
      changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;
      changeTo = changeFrom + newOutputLineCount - 1;
      deleteFrom = changeTo + 1;
      deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;
      lineMappingChanged = true;
    } else if (oldOutputLineCount < newOutputLineCount) {
      changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;
      changeTo = changeFrom + oldOutputLineCount - 1;
      insertFrom = changeTo + 1;
      insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;
      lineMappingChanged = true;
    } else {
      changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;
      changeTo = changeFrom + newOutputLineCount - 1;
    }
    this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);
    const viewLinesChangedEvent = changeFrom <= changeTo ? new ViewLinesChangedEvent(changeFrom, changeTo) : null;
    const viewLinesInsertedEvent = insertFrom <= insertTo ? new ViewLinesInsertedEvent(insertFrom, insertTo) : null;
    const viewLinesDeletedEvent = deleteFrom <= deleteTo ? new ViewLinesDeletedEvent(deleteFrom, deleteTo) : null;
    return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];
  }
  acceptVersionId(versionId) {
    this._validModelVersionId = versionId;
    if (this.lines.length === 1 && !this.lines[0].isVisible()) {
      this.setHiddenAreas([]);
    }
  }
  getViewLineCount() {
    return this.prefixSumComputer.getTotalValue();
  }
  _toValidViewLineNumber(viewLineNumber) {
    if (viewLineNumber < 1) {
      return 1;
    }
    const viewLineCount = this.getViewLineCount();
    if (viewLineNumber > viewLineCount) {
      return viewLineCount;
    }
    return viewLineNumber | 0;
  }
  getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {
    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
    minLineNumber = this._toValidViewLineNumber(minLineNumber);
    maxLineNumber = this._toValidViewLineNumber(maxLineNumber);
    const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));
    const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));
    const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));
    const result = this.model.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);
    const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);
    const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));
    return {
      startLineNumber: viewStartPosition.lineNumber,
      endLineNumber: viewEndPosition.lineNumber,
      indent: result.indent
    };
  }
  getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {
    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);
    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);
    const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));
    const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));
    let result = [];
    let resultRepeatCount = [];
    let resultRepeatOption = [];
    const modelStartLineIndex = modelStart.lineNumber - 1;
    const modelEndLineIndex = modelEnd.lineNumber - 1;
    let reqStart = null;
    for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {
      const line = this.lines[modelLineIndex];
      if (line.isVisible()) {
        let viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);
        let viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));
        let count = viewLineEndIndex - viewLineStartIndex + 1;
        let option = 0;
        if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {
          option = viewLineStartIndex === 0 ? 1 : 2;
        }
        resultRepeatCount.push(count);
        resultRepeatOption.push(option);
        if (reqStart === null) {
          reqStart = new Position(modelLineIndex + 1, 0);
        }
      } else {
        if (reqStart !== null) {
          result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));
          reqStart = null;
        }
      }
    }
    if (reqStart !== null) {
      result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));
      reqStart = null;
    }
    const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;
    let viewIndents = new Array(viewLineCount);
    let currIndex = 0;
    for (let i = 0, len = result.length; i < len; i++) {
      let value = result[i];
      let count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);
      let option = resultRepeatOption[i];
      let blockAtIndex;
      if (option === 2) {
        blockAtIndex = 0;
      } else if (option === 1) {
        blockAtIndex = 1;
      } else {
        blockAtIndex = count;
      }
      for (let j = 0; j < count; j++) {
        if (j === blockAtIndex) {
          value = 0;
        }
        viewIndents[currIndex++] = value;
      }
    }
    return viewIndents;
  }
  getViewLineContent(viewLineNumber) {
    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
    let lineIndex = r.index;
    let remainder = r.remainder;
    return this.lines[lineIndex].getViewLineContent(this.model, lineIndex + 1, remainder);
  }
  getViewLineLength(viewLineNumber) {
    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
    let lineIndex = r.index;
    let remainder = r.remainder;
    return this.lines[lineIndex].getViewLineLength(this.model, lineIndex + 1, remainder);
  }
  getViewLineMinColumn(viewLineNumber) {
    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
    let lineIndex = r.index;
    let remainder = r.remainder;
    return this.lines[lineIndex].getViewLineMinColumn(this.model, lineIndex + 1, remainder);
  }
  getViewLineMaxColumn(viewLineNumber) {
    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
    let lineIndex = r.index;
    let remainder = r.remainder;
    return this.lines[lineIndex].getViewLineMaxColumn(this.model, lineIndex + 1, remainder);
  }
  getViewLineData(viewLineNumber) {
    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
    let lineIndex = r.index;
    let remainder = r.remainder;
    return this.lines[lineIndex].getViewLineData(this.model, lineIndex + 1, remainder);
  }
  getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {
    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);
    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);
    let start = this.prefixSumComputer.getIndexOf(viewStartLineNumber - 1);
    let viewLineNumber = viewStartLineNumber;
    let startModelLineIndex = start.index;
    let startRemainder = start.remainder;
    let result = [];
    for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {
      let line = this.lines[modelLineIndex];
      if (!line.isVisible()) {
        continue;
      }
      let fromViewLineIndex = modelLineIndex === startModelLineIndex ? startRemainder : 0;
      let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;
      let lastLine = false;
      if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {
        lastLine = true;
        remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;
      }
      let toViewLineIndex = fromViewLineIndex + remainingViewLineCount;
      line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, toViewLineIndex, viewLineNumber - viewStartLineNumber, needed, result);
      viewLineNumber += remainingViewLineCount;
      if (lastLine) {
        break;
      }
    }
    return result;
  }
  validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {
    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
    let lineIndex = r.index;
    let remainder = r.remainder;
    let line = this.lines[lineIndex];
    let minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);
    let maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);
    if (viewColumn < minColumn) {
      viewColumn = minColumn;
    }
    if (viewColumn > maxColumn) {
      viewColumn = maxColumn;
    }
    let computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);
    let computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));
    if (computedModelPosition.equals(expectedModelPosition)) {
      return new Position(viewLineNumber, viewColumn);
    }
    return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);
  }
  validateViewRange(viewRange, expectedModelRange) {
    const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());
    const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());
    return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);
  }
  convertViewPositionToModelPosition(viewLineNumber, viewColumn) {
    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
    let lineIndex = r.index;
    let remainder = r.remainder;
    let inputColumn = this.lines[lineIndex].getModelColumnOfViewPosition(remainder, viewColumn);
    return this.model.validatePosition(new Position(lineIndex + 1, inputColumn));
  }
  convertViewRangeToModelRange(viewRange) {
    const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);
    const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);
    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
  }
  convertModelPositionToViewPosition(_modelLineNumber, _modelColumn) {
    const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));
    const inputLineNumber = validPosition.lineNumber;
    const inputColumn = validPosition.column;
    let lineIndex = inputLineNumber - 1, lineIndexChanged = false;
    while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {
      lineIndex--;
      lineIndexChanged = true;
    }
    if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {
      return new Position(1, 1);
    }
    const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));
    let r;
    if (lineIndexChanged) {
      r = this.lines[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));
    } else {
      r = this.lines[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn);
    }
    return r;
  }
  convertModelRangeToViewRange(modelRange) {
    let start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);
    let end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);
    if (modelRange.startLineNumber === modelRange.endLineNumber && start.lineNumber !== end.lineNumber) {
      if (end.column === this.getViewLineMinColumn(end.lineNumber)) {
        return new Range(start.lineNumber, start.column, end.lineNumber - 1, this.getViewLineMaxColumn(end.lineNumber - 1));
      }
    }
    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
  }
  _getViewLineNumberForModelPosition(inputLineNumber, inputColumn) {
    let lineIndex = inputLineNumber - 1;
    if (this.lines[lineIndex].isVisible()) {
      const deltaLineNumber2 = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));
      return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber2, inputColumn);
    }
    while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {
      lineIndex--;
    }
    if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {
      return 1;
    }
    const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));
    return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));
  }
  getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {
    const decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);
    const result = new OverviewRulerDecorations();
    for (const decoration of decorations) {
      const opts = decoration.options.overviewRuler;
      const lane = opts ? opts.position : 0;
      if (lane === 0) {
        continue;
      }
      const color = opts.getColor(theme);
      const viewStartLineNumber = this._getViewLineNumberForModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);
      const viewEndLineNumber = this._getViewLineNumberForModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);
      result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);
    }
    return result.result;
  }
  getDecorationsInRange(range2, ownerId, filterOutValidation) {
    const modelStart = this.convertViewPositionToModelPosition(range2.startLineNumber, range2.startColumn);
    const modelEnd = this.convertViewPositionToModelPosition(range2.endLineNumber, range2.endColumn);
    if (modelEnd.lineNumber - modelStart.lineNumber <= range2.endLineNumber - range2.startLineNumber) {
      return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);
    }
    let result = [];
    const modelStartLineIndex = modelStart.lineNumber - 1;
    const modelEndLineIndex = modelEnd.lineNumber - 1;
    let reqStart = null;
    for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {
      const line = this.lines[modelLineIndex];
      if (line.isVisible()) {
        if (reqStart === null) {
          reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);
        }
      } else {
        if (reqStart !== null) {
          const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);
          result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));
          reqStart = null;
        }
      }
    }
    if (reqStart !== null) {
      result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));
      reqStart = null;
    }
    result.sort((a, b) => {
      const res = Range.compareRangesUsingStarts(a.range, b.range);
      if (res === 0) {
        if (a.id < b.id) {
          return -1;
        }
        if (a.id > b.id) {
          return 1;
        }
        return 0;
      }
      return res;
    });
    let finalResult = [], finalResultLen = 0;
    let prevDecId = null;
    for (const dec of result) {
      const decId = dec.id;
      if (prevDecId === decId) {
        continue;
      }
      prevDecId = decId;
      finalResult[finalResultLen++] = dec;
    }
    return finalResult;
  }
};
var VisibleIdentitySplitLine = class {
  constructor() {
  }
  isVisible() {
    return true;
  }
  setVisible(isVisible) {
    if (isVisible) {
      return this;
    }
    return InvisibleIdentitySplitLine.INSTANCE;
  }
  getLineBreakData() {
    return null;
  }
  getViewLineCount() {
    return 1;
  }
  getViewLineContent(model2, modelLineNumber, _outputLineIndex) {
    return model2.getLineContent(modelLineNumber);
  }
  getViewLineLength(model2, modelLineNumber, _outputLineIndex) {
    return model2.getLineLength(modelLineNumber);
  }
  getViewLineMinColumn(model2, modelLineNumber, _outputLineIndex) {
    return model2.getLineMinColumn(modelLineNumber);
  }
  getViewLineMaxColumn(model2, modelLineNumber, _outputLineIndex) {
    return model2.getLineMaxColumn(modelLineNumber);
  }
  getViewLineData(model2, modelLineNumber, _outputLineIndex) {
    let lineTokens = model2.getLineTokens(modelLineNumber);
    let lineContent = lineTokens.getLineContent();
    return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate());
  }
  getViewLinesData(model2, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {
    if (!needed[globalStartIndex]) {
      result[globalStartIndex] = null;
      return;
    }
    result[globalStartIndex] = this.getViewLineData(model2, modelLineNumber, 0);
  }
  getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {
    return outputColumn;
  }
  getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {
    return new Position(deltaLineNumber, inputColumn);
  }
  getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {
    return deltaLineNumber;
  }
};
VisibleIdentitySplitLine.INSTANCE = new VisibleIdentitySplitLine();
var InvisibleIdentitySplitLine = class {
  constructor() {
  }
  isVisible() {
    return false;
  }
  setVisible(isVisible) {
    if (!isVisible) {
      return this;
    }
    return VisibleIdentitySplitLine.INSTANCE;
  }
  getLineBreakData() {
    return null;
  }
  getViewLineCount() {
    return 0;
  }
  getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {
    throw new Error("Not supported");
  }
  getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {
    throw new Error("Not supported");
  }
  getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {
    throw new Error("Not supported");
  }
  getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {
    throw new Error("Not supported");
  }
  getViewLineData(_model, _modelLineNumber, _outputLineIndex) {
    throw new Error("Not supported");
  }
  getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {
    throw new Error("Not supported");
  }
  getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {
    throw new Error("Not supported");
  }
  getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {
    throw new Error("Not supported");
  }
  getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {
    throw new Error("Not supported");
  }
};
InvisibleIdentitySplitLine.INSTANCE = new InvisibleIdentitySplitLine();
var SplitLine = class {
  constructor(lineBreakData, isVisible) {
    this._lineBreakData = lineBreakData;
    this._isVisible = isVisible;
  }
  isVisible() {
    return this._isVisible;
  }
  setVisible(isVisible) {
    this._isVisible = isVisible;
    return this;
  }
  getLineBreakData() {
    return this._lineBreakData;
  }
  getViewLineCount() {
    if (!this._isVisible) {
      return 0;
    }
    return this._lineBreakData.breakOffsets.length;
  }
  getInputStartOffsetOfOutputLineIndex(outputLineIndex) {
    return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex, 0);
  }
  getInputEndOffsetOfOutputLineIndex(model2, modelLineNumber, outputLineIndex) {
    if (outputLineIndex + 1 === this._lineBreakData.breakOffsets.length) {
      return model2.getLineMaxColumn(modelLineNumber) - 1;
    }
    return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex + 1, 0);
  }
  getViewLineContent(model2, modelLineNumber, outputLineIndex) {
    if (!this._isVisible) {
      throw new Error("Not supported");
    }
    let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);
    let endOffset = this.getInputEndOffsetOfOutputLineIndex(model2, modelLineNumber, outputLineIndex);
    let r = model2.getValueInRange({
      startLineNumber: modelLineNumber,
      startColumn: startOffset + 1,
      endLineNumber: modelLineNumber,
      endColumn: endOffset + 1
    });
    if (outputLineIndex > 0) {
      r = spaces(this._lineBreakData.wrappedTextIndentLength) + r;
    }
    return r;
  }
  getViewLineLength(model2, modelLineNumber, outputLineIndex) {
    if (!this._isVisible) {
      throw new Error("Not supported");
    }
    let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);
    let endOffset = this.getInputEndOffsetOfOutputLineIndex(model2, modelLineNumber, outputLineIndex);
    let r = endOffset - startOffset;
    if (outputLineIndex > 0) {
      r = this._lineBreakData.wrappedTextIndentLength + r;
    }
    return r;
  }
  getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {
    if (!this._isVisible) {
      throw new Error("Not supported");
    }
    if (outputLineIndex > 0) {
      return this._lineBreakData.wrappedTextIndentLength + 1;
    }
    return 1;
  }
  getViewLineMaxColumn(model2, modelLineNumber, outputLineIndex) {
    if (!this._isVisible) {
      throw new Error("Not supported");
    }
    return this.getViewLineContent(model2, modelLineNumber, outputLineIndex).length + 1;
  }
  getViewLineData(model2, modelLineNumber, outputLineIndex) {
    if (!this._isVisible) {
      throw new Error("Not supported");
    }
    let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);
    let endOffset = this.getInputEndOffsetOfOutputLineIndex(model2, modelLineNumber, outputLineIndex);
    let lineContent = model2.getValueInRange({
      startLineNumber: modelLineNumber,
      startColumn: startOffset + 1,
      endLineNumber: modelLineNumber,
      endColumn: endOffset + 1
    });
    if (outputLineIndex > 0) {
      lineContent = spaces(this._lineBreakData.wrappedTextIndentLength) + lineContent;
    }
    let minColumn = outputLineIndex > 0 ? this._lineBreakData.wrappedTextIndentLength + 1 : 1;
    let maxColumn = lineContent.length + 1;
    let continuesWithWrappedLine = outputLineIndex + 1 < this.getViewLineCount();
    let deltaStartIndex = 0;
    if (outputLineIndex > 0) {
      deltaStartIndex = this._lineBreakData.wrappedTextIndentLength;
    }
    let lineTokens = model2.getLineTokens(modelLineNumber);
    const startVisibleColumn = outputLineIndex === 0 ? 0 : this._lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1];
    return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, lineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex));
  }
  getViewLinesData(model2, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {
    if (!this._isVisible) {
      throw new Error("Not supported");
    }
    for (let outputLineIndex = fromOuputLineIndex; outputLineIndex < toOutputLineIndex; outputLineIndex++) {
      let globalIndex = globalStartIndex + outputLineIndex - fromOuputLineIndex;
      if (!needed[globalIndex]) {
        result[globalIndex] = null;
        continue;
      }
      result[globalIndex] = this.getViewLineData(model2, modelLineNumber, outputLineIndex);
    }
  }
  getModelColumnOfViewPosition(outputLineIndex, outputColumn) {
    if (!this._isVisible) {
      throw new Error("Not supported");
    }
    let adjustedColumn = outputColumn - 1;
    if (outputLineIndex > 0) {
      if (adjustedColumn < this._lineBreakData.wrappedTextIndentLength) {
        adjustedColumn = 0;
      } else {
        adjustedColumn -= this._lineBreakData.wrappedTextIndentLength;
      }
    }
    return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex, adjustedColumn) + 1;
  }
  getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {
    if (!this._isVisible) {
      throw new Error("Not supported");
    }
    let r = LineBreakData.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, inputColumn - 1);
    let outputLineIndex = r.outputLineIndex;
    let outputColumn = r.outputOffset + 1;
    if (outputLineIndex > 0) {
      outputColumn += this._lineBreakData.wrappedTextIndentLength;
    }
    return new Position(deltaLineNumber + outputLineIndex, outputColumn);
  }
  getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {
    if (!this._isVisible) {
      throw new Error("Not supported");
    }
    const r = LineBreakData.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, inputColumn - 1);
    return deltaLineNumber + r.outputLineIndex;
  }
};
var _spaces = [""];
function spaces(count) {
  if (count >= _spaces.length) {
    for (let i = 1; i <= count; i++) {
      _spaces[i] = _makeSpaces(i);
    }
  }
  return _spaces[count];
}
function _makeSpaces(count) {
  return new Array(count + 1).join(" ");
}
function createSplitLine(lineBreakData, isVisible) {
  if (lineBreakData === null) {
    if (isVisible) {
      return VisibleIdentitySplitLine.INSTANCE;
    }
    return InvisibleIdentitySplitLine.INSTANCE;
  } else {
    return new SplitLine(lineBreakData, isVisible);
  }
}
var IdentityCoordinatesConverter = class {
  constructor(lines) {
    this._lines = lines;
  }
  _validPosition(pos) {
    return this._lines.model.validatePosition(pos);
  }
  _validRange(range2) {
    return this._lines.model.validateRange(range2);
  }
  convertViewPositionToModelPosition(viewPosition) {
    return this._validPosition(viewPosition);
  }
  convertViewRangeToModelRange(viewRange) {
    return this._validRange(viewRange);
  }
  validateViewPosition(_viewPosition, expectedModelPosition) {
    return this._validPosition(expectedModelPosition);
  }
  validateViewRange(_viewRange, expectedModelRange) {
    return this._validRange(expectedModelRange);
  }
  convertModelPositionToViewPosition(modelPosition) {
    return this._validPosition(modelPosition);
  }
  convertModelRangeToViewRange(modelRange) {
    return this._validRange(modelRange);
  }
  modelPositionIsVisible(modelPosition) {
    const lineCount = this._lines.model.getLineCount();
    if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {
      return false;
    }
    return true;
  }
};
var IdentityLinesCollection = class {
  constructor(model2) {
    this.model = model2;
  }
  dispose() {
  }
  createCoordinatesConverter() {
    return new IdentityCoordinatesConverter(this);
  }
  getHiddenAreas() {
    return [];
  }
  setHiddenAreas(_ranges) {
    return false;
  }
  setTabSize(_newTabSize) {
    return false;
  }
  setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {
    return false;
  }
  createLineBreaksComputer() {
    let result = [];
    return {
      addRequest: (lineText, previousLineBreakData) => {
        result.push(null);
      },
      finalize: () => {
        return result;
      }
    };
  }
  onModelFlushed() {
  }
  onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {
    return new ViewLinesDeletedEvent(fromLineNumber, toLineNumber);
  }
  onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {
    return new ViewLinesInsertedEvent(fromLineNumber, toLineNumber);
  }
  onModelLineChanged(_versionId, lineNumber, lineBreakData) {
    return [false, new ViewLinesChangedEvent(lineNumber, lineNumber), null, null];
  }
  acceptVersionId(_versionId) {
  }
  getViewLineCount() {
    return this.model.getLineCount();
  }
  getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {
    return {
      startLineNumber: viewLineNumber,
      endLineNumber: viewLineNumber,
      indent: 0
    };
  }
  getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {
    const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;
    let result = new Array(viewLineCount);
    for (let i = 0; i < viewLineCount; i++) {
      result[i] = 0;
    }
    return result;
  }
  getViewLineContent(viewLineNumber) {
    return this.model.getLineContent(viewLineNumber);
  }
  getViewLineLength(viewLineNumber) {
    return this.model.getLineLength(viewLineNumber);
  }
  getViewLineMinColumn(viewLineNumber) {
    return this.model.getLineMinColumn(viewLineNumber);
  }
  getViewLineMaxColumn(viewLineNumber) {
    return this.model.getLineMaxColumn(viewLineNumber);
  }
  getViewLineData(viewLineNumber) {
    let lineTokens = this.model.getLineTokens(viewLineNumber);
    let lineContent = lineTokens.getLineContent();
    return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate());
  }
  getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {
    const lineCount = this.model.getLineCount();
    viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);
    viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);
    let result = [];
    for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {
      let idx = lineNumber - viewStartLineNumber;
      if (!needed[idx]) {
        result[idx] = null;
      }
      result[idx] = this.getViewLineData(lineNumber);
    }
    return result;
  }
  getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {
    const decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);
    const result = new OverviewRulerDecorations();
    for (const decoration of decorations) {
      const opts = decoration.options.overviewRuler;
      const lane = opts ? opts.position : 0;
      if (lane === 0) {
        continue;
      }
      const color = opts.getColor(theme);
      const viewStartLineNumber = decoration.range.startLineNumber;
      const viewEndLineNumber = decoration.range.endLineNumber;
      result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);
    }
    return result.result;
  }
  getDecorationsInRange(range2, ownerId, filterOutValidation) {
    return this.model.getDecorationsInRange(range2, ownerId, filterOutValidation);
  }
};
var OverviewRulerDecorations = class {
  constructor() {
    this.result = Object.create(null);
  }
  accept(color, startLineNumber, endLineNumber, lane) {
    let prev = this.result[color];
    if (prev) {
      const prevLane = prev[prev.length - 3];
      const prevEndLineNumber = prev[prev.length - 1];
      if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {
        if (endLineNumber > prevEndLineNumber) {
          prev[prev.length - 1] = endLineNumber;
        }
        return;
      }
      prev.push(lane, startLineNumber, endLineNumber);
    } else {
      this.result[color] = [lane, startLineNumber, endLineNumber];
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelDecorations.js
var ViewModelDecorations = class {
  constructor(editorId, model2, configuration, linesCollection, coordinatesConverter) {
    this.editorId = editorId;
    this.model = model2;
    this.configuration = configuration;
    this._linesCollection = linesCollection;
    this._coordinatesConverter = coordinatesConverter;
    this._decorationsCache = Object.create(null);
    this._cachedModelDecorationsResolver = null;
    this._cachedModelDecorationsResolverViewRange = null;
  }
  _clearCachedModelDecorationsResolver() {
    this._cachedModelDecorationsResolver = null;
    this._cachedModelDecorationsResolverViewRange = null;
  }
  dispose() {
    this._decorationsCache = Object.create(null);
    this._clearCachedModelDecorationsResolver();
  }
  reset() {
    this._decorationsCache = Object.create(null);
    this._clearCachedModelDecorationsResolver();
  }
  onModelDecorationsChanged() {
    this._decorationsCache = Object.create(null);
    this._clearCachedModelDecorationsResolver();
  }
  onLineMappingChanged() {
    this._decorationsCache = Object.create(null);
    this._clearCachedModelDecorationsResolver();
  }
  _getOrCreateViewModelDecoration(modelDecoration) {
    const id = modelDecoration.id;
    let r = this._decorationsCache[id];
    if (!r) {
      const modelRange = modelDecoration.range;
      const options = modelDecoration.options;
      let viewRange;
      if (options.isWholeLine) {
        const start = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.startLineNumber, 1));
        const end = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber)));
        viewRange = new Range(start.lineNumber, start.column, end.lineNumber, end.column);
      } else {
        viewRange = this._coordinatesConverter.convertModelRangeToViewRange(modelRange);
      }
      r = new ViewModelDecoration(viewRange, options);
      this._decorationsCache[id] = r;
    }
    return r;
  }
  getDecorationsViewportData(viewRange) {
    let cacheIsValid = this._cachedModelDecorationsResolver !== null;
    cacheIsValid = cacheIsValid && viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange);
    if (!cacheIsValid) {
      this._cachedModelDecorationsResolver = this._getDecorationsViewportData(viewRange);
      this._cachedModelDecorationsResolverViewRange = viewRange;
    }
    return this._cachedModelDecorationsResolver;
  }
  _getDecorationsViewportData(viewportRange) {
    const modelDecorations = this._linesCollection.getDecorationsInRange(viewportRange, this.editorId, filterValidationDecorations(this.configuration.options));
    const startLineNumber = viewportRange.startLineNumber;
    const endLineNumber = viewportRange.endLineNumber;
    let decorationsInViewport = [], decorationsInViewportLen = 0;
    let inlineDecorations = [];
    for (let j = startLineNumber; j <= endLineNumber; j++) {
      inlineDecorations[j - startLineNumber] = [];
    }
    for (let i = 0, len = modelDecorations.length; i < len; i++) {
      let modelDecoration = modelDecorations[i];
      let decorationOptions = modelDecoration.options;
      let viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);
      let viewRange = viewModelDecoration.range;
      decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;
      if (decorationOptions.inlineClassName) {
        let inlineDecoration = new InlineDecoration(viewRange, decorationOptions.inlineClassName, decorationOptions.inlineClassNameAffectsLetterSpacing ? 3 : 0);
        let intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);
        let intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);
        for (let j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {
          inlineDecorations[j - startLineNumber].push(inlineDecoration);
        }
      }
      if (decorationOptions.beforeContentClassName) {
        if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {
          let inlineDecoration = new InlineDecoration(new Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn), decorationOptions.beforeContentClassName, 1);
          inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);
        }
      }
      if (decorationOptions.afterContentClassName) {
        if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber) {
          let inlineDecoration = new InlineDecoration(new Range(viewRange.endLineNumber, viewRange.endColumn, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, 2);
          inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);
        }
      }
    }
    return {
      decorations: decorationsInViewport,
      inlineDecorations
    };
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js
var USE_IDENTITY_LINES_COLLECTION = true;
var ViewModel = class extends Disposable {
  constructor(editorId, configuration, model2, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame2) {
    super();
    this._editorId = editorId;
    this._configuration = configuration;
    this.model = model2;
    this._eventDispatcher = new ViewModelEventDispatcher();
    this.onEvent = this._eventDispatcher.onEvent;
    this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);
    this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));
    this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));
    this._hasFocus = false;
    this._viewportStartLine = -1;
    this._viewportStartLineTrackedRange = null;
    this._viewportStartLineDelta = 0;
    if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {
      this._lines = new IdentityLinesCollection(this.model);
    } else {
      const options = this._configuration.options;
      const fontInfo = options.get(36);
      const wrappingStrategy = options.get(112);
      const wrappingInfo = options.get(118);
      const wrappingIndent = options.get(111);
      this._lines = new SplitLinesCollection(this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);
    }
    this.coordinatesConverter = this._lines.createCoordinatesConverter();
    this._cursor = this._register(new Cursor(model2, this, this.coordinatesConverter, this.cursorConfig));
    this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame2));
    this._register(this.viewLayout.onDidScroll((e) => {
      if (e.scrollTopChanged) {
        this._tokenizeViewportSoon.schedule();
      }
      this._eventDispatcher.emitSingleViewEvent(new ViewScrollChangedEvent(e));
      this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));
    }));
    this._register(this.viewLayout.onDidContentSizeChange((e) => {
      this._eventDispatcher.emitOutgoingEvent(e);
    }));
    this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);
    this._registerModelEvents();
    this._register(this._configuration.onDidChangeFast((e) => {
      try {
        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();
        this._onConfigurationChanged(eventsCollector, e);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    }));
    this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {
      this._eventDispatcher.emitSingleViewEvent(new ViewTokensColorsChangedEvent());
    }));
    this._updateConfigurationViewLineCountNow();
  }
  dispose() {
    super.dispose();
    this._decorations.dispose();
    this._lines.dispose();
    this.invalidateMinimapColorCache();
    this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, null, 1);
    this._eventDispatcher.dispose();
  }
  addViewEventHandler(eventHandler) {
    this._eventDispatcher.addViewEventHandler(eventHandler);
  }
  removeViewEventHandler(eventHandler) {
    this._eventDispatcher.removeViewEventHandler(eventHandler);
  }
  _updateConfigurationViewLineCountNow() {
    this._configuration.setViewLineCount(this._lines.getViewLineCount());
  }
  tokenizeViewport() {
    const linesViewportData = this.viewLayout.getLinesViewportData();
    const startPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(linesViewportData.startLineNumber, 1));
    const endPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(linesViewportData.endLineNumber, 1));
    this.model.tokenizeViewport(startPosition.lineNumber, endPosition.lineNumber);
  }
  setHasFocus(hasFocus) {
    this._hasFocus = hasFocus;
    this._cursor.setHasFocus(hasFocus);
    this._eventDispatcher.emitSingleViewEvent(new ViewFocusChangedEvent(hasFocus));
    this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));
  }
  onDidColorThemeChange() {
    this._eventDispatcher.emitSingleViewEvent(new ViewThemeChangedEvent());
  }
  _onConfigurationChanged(eventsCollector, e) {
    let previousViewportStartModelPosition = null;
    if (this._viewportStartLine !== -1) {
      let previousViewportStartViewPosition = new Position(this._viewportStartLine, this.getLineMinColumn(this._viewportStartLine));
      previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);
    }
    let restorePreviousViewportStart = false;
    const options = this._configuration.options;
    const fontInfo = options.get(36);
    const wrappingStrategy = options.get(112);
    const wrappingInfo = options.get(118);
    const wrappingIndent = options.get(111);
    if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {
      eventsCollector.emitViewEvent(new ViewFlushedEvent());
      eventsCollector.emitViewEvent(new ViewLineMappingChangedEvent());
      eventsCollector.emitViewEvent(new ViewDecorationsChangedEvent(null));
      this._cursor.onLineMappingChanged(eventsCollector);
      this._decorations.onLineMappingChanged();
      this.viewLayout.onFlushed(this.getLineCount());
      if (this.viewLayout.getCurrentScrollTop() !== 0) {
        restorePreviousViewportStart = true;
      }
      this._updateConfigurationViewLineCount.schedule();
    }
    if (e.hasChanged(72)) {
      this._decorations.reset();
      eventsCollector.emitViewEvent(new ViewDecorationsChangedEvent(null));
    }
    eventsCollector.emitViewEvent(new ViewConfigurationChangedEvent(e));
    this.viewLayout.onConfigurationChanged(e);
    if (restorePreviousViewportStart && previousViewportStartModelPosition) {
      const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);
      const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);
      this.viewLayout.setScrollPosition({scrollTop: viewPositionTop + this._viewportStartLineDelta}, 1);
    }
    if (CursorConfiguration.shouldRecreate(e)) {
      this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);
      this._cursor.updateConfiguration(this.cursorConfig);
    }
  }
  _registerModelEvents() {
    this._register(this.model.onDidChangeRawContentFast((e) => {
      try {
        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();
        let hadOtherModelChange = false;
        let hadModelLineChangeThatChangedLineMapping = false;
        const changes = e.changes;
        const versionId = e.versionId;
        const lineBreaksComputer = this._lines.createLineBreaksComputer();
        for (const change of changes) {
          switch (change.changeType) {
            case 4: {
              for (const line of change.detail) {
                lineBreaksComputer.addRequest(line, null);
              }
              break;
            }
            case 2: {
              lineBreaksComputer.addRequest(change.detail, null);
              break;
            }
          }
        }
        const lineBreaks = lineBreaksComputer.finalize();
        let lineBreaksOffset = 0;
        for (const change of changes) {
          switch (change.changeType) {
            case 1: {
              this._lines.onModelFlushed();
              eventsCollector.emitViewEvent(new ViewFlushedEvent());
              this._decorations.reset();
              this.viewLayout.onFlushed(this.getLineCount());
              hadOtherModelChange = true;
              break;
            }
            case 3: {
              const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);
              if (linesDeletedEvent !== null) {
                eventsCollector.emitViewEvent(linesDeletedEvent);
                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);
              }
              hadOtherModelChange = true;
              break;
            }
            case 4: {
              const insertedLineBreaks = lineBreaks.slice(lineBreaksOffset, lineBreaksOffset + change.detail.length);
              lineBreaksOffset += change.detail.length;
              const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);
              if (linesInsertedEvent !== null) {
                eventsCollector.emitViewEvent(linesInsertedEvent);
                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);
              }
              hadOtherModelChange = true;
              break;
            }
            case 2: {
              const changedLineBreakData = lineBreaks[lineBreaksOffset];
              lineBreaksOffset++;
              const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);
              hadModelLineChangeThatChangedLineMapping = lineMappingChanged;
              if (linesChangedEvent) {
                eventsCollector.emitViewEvent(linesChangedEvent);
              }
              if (linesInsertedEvent) {
                eventsCollector.emitViewEvent(linesInsertedEvent);
                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);
              }
              if (linesDeletedEvent) {
                eventsCollector.emitViewEvent(linesDeletedEvent);
                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);
              }
              break;
            }
            case 5: {
              break;
            }
          }
        }
        this._lines.acceptVersionId(versionId);
        this.viewLayout.onHeightMaybeChanged();
        if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {
          eventsCollector.emitViewEvent(new ViewLineMappingChangedEvent());
          eventsCollector.emitViewEvent(new ViewDecorationsChangedEvent(null));
          this._cursor.onLineMappingChanged(eventsCollector);
          this._decorations.onLineMappingChanged();
        }
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      this._viewportStartLine = -1;
      this._configuration.setMaxLineNumber(this.model.getLineCount());
      this._updateConfigurationViewLineCountNow();
      if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && this._viewportStartLineTrackedRange) {
        const modelRange = this.model._getTrackedRange(this._viewportStartLineTrackedRange);
        if (modelRange) {
          const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());
          const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);
          this.viewLayout.setScrollPosition({scrollTop: viewPositionTop + this._viewportStartLineDelta}, 1);
        }
      }
      try {
        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();
        this._cursor.onModelContentChanged(eventsCollector, e);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    }));
    this._register(this.model.onDidChangeTokens((e) => {
      let viewRanges = [];
      for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {
        const modelRange = e.ranges[j];
        const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;
        const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;
        viewRanges[j] = {
          fromLineNumber: viewStartLineNumber,
          toLineNumber: viewEndLineNumber
        };
      }
      this._eventDispatcher.emitSingleViewEvent(new ViewTokensChangedEvent(viewRanges));
      if (e.tokenizationSupportChanged) {
        this._tokenizeViewportSoon.schedule();
      }
    }));
    this._register(this.model.onDidChangeLanguageConfiguration((e) => {
      this._eventDispatcher.emitSingleViewEvent(new ViewLanguageConfigurationEvent());
      this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);
      this._cursor.updateConfiguration(this.cursorConfig);
    }));
    this._register(this.model.onDidChangeLanguage((e) => {
      this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);
      this._cursor.updateConfiguration(this.cursorConfig);
    }));
    this._register(this.model.onDidChangeOptions((e) => {
      if (this._lines.setTabSize(this.model.getOptions().tabSize)) {
        try {
          const eventsCollector = this._eventDispatcher.beginEmitViewEvents();
          eventsCollector.emitViewEvent(new ViewFlushedEvent());
          eventsCollector.emitViewEvent(new ViewLineMappingChangedEvent());
          eventsCollector.emitViewEvent(new ViewDecorationsChangedEvent(null));
          this._cursor.onLineMappingChanged(eventsCollector);
          this._decorations.onLineMappingChanged();
          this.viewLayout.onFlushed(this.getLineCount());
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
        this._updateConfigurationViewLineCount.schedule();
      }
      this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);
      this._cursor.updateConfiguration(this.cursorConfig);
    }));
    this._register(this.model.onDidChangeDecorations((e) => {
      this._decorations.onModelDecorationsChanged();
      this._eventDispatcher.emitSingleViewEvent(new ViewDecorationsChangedEvent(e));
    }));
  }
  setHiddenAreas(ranges) {
    try {
      const eventsCollector = this._eventDispatcher.beginEmitViewEvents();
      let lineMappingChanged = this._lines.setHiddenAreas(ranges);
      if (lineMappingChanged) {
        eventsCollector.emitViewEvent(new ViewFlushedEvent());
        eventsCollector.emitViewEvent(new ViewLineMappingChangedEvent());
        eventsCollector.emitViewEvent(new ViewDecorationsChangedEvent(null));
        this._cursor.onLineMappingChanged(eventsCollector);
        this._decorations.onLineMappingChanged();
        this.viewLayout.onFlushed(this.getLineCount());
        this.viewLayout.onHeightMaybeChanged();
      }
    } finally {
      this._eventDispatcher.endEmitViewEvents();
    }
    this._updateConfigurationViewLineCount.schedule();
  }
  getVisibleRangesPlusViewportAboveBelow() {
    const layoutInfo = this._configuration.options.get(117);
    const lineHeight = this._configuration.options.get(51);
    const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));
    const partialData = this.viewLayout.getLinesViewportData();
    const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);
    const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);
    return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));
  }
  getVisibleRanges() {
    const visibleViewRange = this.getCompletelyVisibleViewRange();
    return this._toModelVisibleRanges(visibleViewRange);
  }
  _toModelVisibleRanges(visibleViewRange) {
    const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);
    const hiddenAreas = this._lines.getHiddenAreas();
    if (hiddenAreas.length === 0) {
      return [visibleRange];
    }
    let result = [], resultLen = 0;
    let startLineNumber = visibleRange.startLineNumber;
    let startColumn = visibleRange.startColumn;
    let endLineNumber = visibleRange.endLineNumber;
    let endColumn = visibleRange.endColumn;
    for (let i = 0, len = hiddenAreas.length; i < len; i++) {
      const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;
      const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;
      if (hiddenEndLineNumber < startLineNumber) {
        continue;
      }
      if (hiddenStartLineNumber > endLineNumber) {
        continue;
      }
      if (startLineNumber < hiddenStartLineNumber) {
        result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));
      }
      startLineNumber = hiddenEndLineNumber + 1;
      startColumn = 1;
    }
    if (startLineNumber < endLineNumber || startLineNumber === endLineNumber && startColumn < endColumn) {
      result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    return result;
  }
  getCompletelyVisibleViewRange() {
    const partialData = this.viewLayout.getLinesViewportData();
    const startViewLineNumber = partialData.completelyVisibleStartLineNumber;
    const endViewLineNumber = partialData.completelyVisibleEndLineNumber;
    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));
  }
  getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {
    const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);
    const startViewLineNumber = partialData.completelyVisibleStartLineNumber;
    const endViewLineNumber = partialData.completelyVisibleEndLineNumber;
    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));
  }
  saveState() {
    const compatViewState = this.viewLayout.saveState();
    const scrollTop = compatViewState.scrollTop;
    const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);
    const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));
    const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;
    return {
      scrollLeft: compatViewState.scrollLeft,
      firstPosition,
      firstPositionDeltaTop
    };
  }
  reduceRestoreState(state) {
    if (typeof state.firstPosition === "undefined") {
      return this._reduceRestoreStateCompatibility(state);
    }
    const modelPosition = this.model.validatePosition(state.firstPosition);
    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);
    const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;
    return {
      scrollLeft: state.scrollLeft,
      scrollTop
    };
  }
  _reduceRestoreStateCompatibility(state) {
    return {
      scrollLeft: state.scrollLeft,
      scrollTop: state.scrollTopWithoutViewZones
    };
  }
  getTabSize() {
    return this.model.getOptions().tabSize;
  }
  getTextModelOptions() {
    return this.model.getOptions();
  }
  getLineCount() {
    return this._lines.getViewLineCount();
  }
  setViewport(startLineNumber, endLineNumber, centeredLineNumber) {
    this._viewportStartLine = startLineNumber;
    let position = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, this.getLineMinColumn(startLineNumber)));
    this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1);
    const viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);
    const scrollTop = this.viewLayout.getCurrentScrollTop();
    this._viewportStartLineDelta = scrollTop - viewportStartLineTop;
  }
  getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {
    return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);
  }
  getLinesIndentGuides(startLineNumber, endLineNumber) {
    return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);
  }
  getLineContent(lineNumber) {
    return this._lines.getViewLineContent(lineNumber);
  }
  getLineLength(lineNumber) {
    return this._lines.getViewLineLength(lineNumber);
  }
  getLineMinColumn(lineNumber) {
    return this._lines.getViewLineMinColumn(lineNumber);
  }
  getLineMaxColumn(lineNumber) {
    return this._lines.getViewLineMaxColumn(lineNumber);
  }
  getLineFirstNonWhitespaceColumn(lineNumber) {
    const result = firstNonWhitespaceIndex(this.getLineContent(lineNumber));
    if (result === -1) {
      return 0;
    }
    return result + 1;
  }
  getLineLastNonWhitespaceColumn(lineNumber) {
    const result = lastNonWhitespaceIndex(this.getLineContent(lineNumber));
    if (result === -1) {
      return 0;
    }
    return result + 2;
  }
  getDecorationsInViewport(visibleRange) {
    return this._decorations.getDecorationsViewportData(visibleRange).decorations;
  }
  getViewLineRenderingData(visibleRange, lineNumber) {
    let mightContainRTL = this.model.mightContainRTL();
    let mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();
    let tabSize = this.getTabSize();
    let lineData = this._lines.getViewLineData(lineNumber);
    let allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;
    let inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];
    return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);
  }
  getViewLineData(lineNumber) {
    return this._lines.getViewLineData(lineNumber);
  }
  getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {
    let result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);
    return new MinimapLinesRenderingData(this.getTabSize(), result);
  }
  getAllOverviewRulerDecorations(theme) {
    return this._lines.getAllOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options), theme);
  }
  invalidateOverviewRulerColorCache() {
    const decorations = this.model.getOverviewRulerDecorations();
    for (const decoration of decorations) {
      const opts = decoration.options.overviewRuler;
      if (opts) {
        opts.invalidateCachedColor();
      }
    }
  }
  invalidateMinimapColorCache() {
    const decorations = this.model.getAllDecorations();
    for (const decoration of decorations) {
      const opts = decoration.options.minimap;
      if (opts) {
        opts.invalidateCachedColor();
      }
    }
  }
  getValueInRange(range2, eol) {
    const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range2);
    return this.model.getValueInRange(modelRange, eol);
  }
  getModelLineMaxColumn(modelLineNumber) {
    return this.model.getLineMaxColumn(modelLineNumber);
  }
  validateModelPosition(position) {
    return this.model.validatePosition(position);
  }
  validateModelRange(range2) {
    return this.model.validateRange(range2);
  }
  deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {
    const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);
    if (this.model.getEOL().length === 2) {
      if (deltaOffset < 0) {
        deltaOffset -= lineFeedCnt;
      } else {
        deltaOffset += lineFeedCnt;
      }
    }
    const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);
    const resultOffset = modelAnchorOffset + deltaOffset;
    return this.model.getPositionAt(resultOffset);
  }
  getEOL() {
    return this.model.getEOL();
  }
  getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {
    const newLineCharacter = forceCRLF ? "\r\n" : this.model.getEOL();
    modelRanges = modelRanges.slice(0);
    modelRanges.sort(Range.compareRangesUsingStarts);
    let hasEmptyRange = false;
    let hasNonEmptyRange = false;
    for (const range2 of modelRanges) {
      if (range2.isEmpty()) {
        hasEmptyRange = true;
      } else {
        hasNonEmptyRange = true;
      }
    }
    if (!hasNonEmptyRange) {
      if (!emptySelectionClipboard) {
        return "";
      }
      const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);
      let result2 = "";
      for (let i = 0; i < modelLineNumbers.length; i++) {
        if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {
          continue;
        }
        result2 += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;
      }
      return result2;
    }
    if (hasEmptyRange && emptySelectionClipboard) {
      let result2 = [];
      let prevModelLineNumber = 0;
      for (const modelRange of modelRanges) {
        const modelLineNumber = modelRange.startLineNumber;
        if (modelRange.isEmpty()) {
          if (modelLineNumber !== prevModelLineNumber) {
            result2.push(this.model.getLineContent(modelLineNumber));
          }
        } else {
          result2.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 : 0));
        }
        prevModelLineNumber = modelLineNumber;
      }
      return result2.length === 1 ? result2[0] : result2;
    }
    let result = [];
    for (const modelRange of modelRanges) {
      if (!modelRange.isEmpty()) {
        result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 : 0));
      }
    }
    return result.length === 1 ? result[0] : result;
  }
  getRichTextToCopy(modelRanges, emptySelectionClipboard) {
    const languageId = this.model.getLanguageIdentifier();
    if (languageId.id === 1) {
      return null;
    }
    if (modelRanges.length !== 1) {
      return null;
    }
    let range2 = modelRanges[0];
    if (range2.isEmpty()) {
      if (!emptySelectionClipboard) {
        return null;
      }
      const lineNumber = range2.startLineNumber;
      range2 = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));
    }
    const fontInfo = this._configuration.options.get(36);
    const colorMap = this._getColorMap();
    const fontFamily = fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily ? fontInfo.fontFamily : `'${fontInfo.fontFamily}', ${EDITOR_FONT_DEFAULTS.fontFamily}`;
    return {
      mode: languageId.language,
      html: `<div style="color: ${colorMap[1]};background-color: ${colorMap[2]};font-family: ${fontFamily};font-weight: ${fontInfo.fontWeight};font-size: ${fontInfo.fontSize}px;line-height: ${fontInfo.lineHeight}px;white-space: pre;">` + this._getHTMLToCopy(range2, colorMap) + "</div>"
    };
  }
  _getHTMLToCopy(modelRange, colorMap) {
    const startLineNumber = modelRange.startLineNumber;
    const startColumn = modelRange.startColumn;
    const endLineNumber = modelRange.endLineNumber;
    const endColumn = modelRange.endColumn;
    const tabSize = this.getTabSize();
    let result = "";
    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      const lineTokens = this.model.getLineTokens(lineNumber);
      const lineContent = lineTokens.getLineContent();
      const startOffset = lineNumber === startLineNumber ? startColumn - 1 : 0;
      const endOffset = lineNumber === endLineNumber ? endColumn - 1 : lineContent.length;
      if (lineContent === "") {
        result += "<br>";
      } else {
        result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, isWindows);
      }
    }
    return result;
  }
  _getColorMap() {
    let colorMap = TokenizationRegistry.getColorMap();
    let result = ["#000000"];
    if (colorMap) {
      for (let i = 1, len = colorMap.length; i < len; i++) {
        result[i] = Color.Format.CSS.formatHex(colorMap[i]);
      }
    }
    return result;
  }
  pushStackElement() {
    this.model.pushStackElement();
  }
  getPrimaryCursorState() {
    return this._cursor.getPrimaryCursorState();
  }
  getLastAddedCursorIndex() {
    return this._cursor.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursor.getCursorStates();
  }
  setCursorStates(source, reason, states) {
    this._withViewEventsCollector((eventsCollector) => this._cursor.setStates(eventsCollector, source, reason, states));
  }
  getCursorColumnSelectData() {
    return this._cursor.getCursorColumnSelectData();
  }
  setCursorColumnSelectData(columnSelectData) {
    this._cursor.setCursorColumnSelectData(columnSelectData);
  }
  getPrevEditOperationType() {
    return this._cursor.getPrevEditOperationType();
  }
  setPrevEditOperationType(type) {
    this._cursor.setPrevEditOperationType(type);
  }
  getSelection() {
    return this._cursor.getSelection();
  }
  getSelections() {
    return this._cursor.getSelections();
  }
  getPosition() {
    return this._cursor.getPrimaryCursorState().modelState.position;
  }
  setSelections(source, selections) {
    this._withViewEventsCollector((eventsCollector) => this._cursor.setSelections(eventsCollector, source, selections));
  }
  saveCursorState() {
    return this._cursor.saveState();
  }
  restoreCursorState(states) {
    this._withViewEventsCollector((eventsCollector) => this._cursor.restoreState(eventsCollector, states));
  }
  _executeCursorEdit(callback) {
    if (this._cursor.context.cursorConfig.readOnly) {
      this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());
      return;
    }
    this._withViewEventsCollector(callback);
  }
  executeEdits(source, edits, cursorStateComputer) {
    this._executeCursorEdit((eventsCollector) => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));
  }
  startComposition() {
    this._cursor.setIsDoingComposition(true);
    this._executeCursorEdit((eventsCollector) => this._cursor.startComposition(eventsCollector));
  }
  endComposition(source) {
    this._cursor.setIsDoingComposition(false);
    this._executeCursorEdit((eventsCollector) => this._cursor.endComposition(eventsCollector, source));
  }
  type(text, source) {
    this._executeCursorEdit((eventsCollector) => this._cursor.type(eventsCollector, text, source));
  }
  replacePreviousChar(text, replaceCharCnt, source) {
    this._executeCursorEdit((eventsCollector) => this._cursor.replacePreviousChar(eventsCollector, text, replaceCharCnt, source));
  }
  paste(text, pasteOnNewLine, multicursorText, source) {
    this._executeCursorEdit((eventsCollector) => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));
  }
  cut(source) {
    this._executeCursorEdit((eventsCollector) => this._cursor.cut(eventsCollector, source));
  }
  executeCommand(command, source) {
    this._executeCursorEdit((eventsCollector) => this._cursor.executeCommand(eventsCollector, command, source));
  }
  executeCommands(commands, source) {
    this._executeCursorEdit((eventsCollector) => this._cursor.executeCommands(eventsCollector, commands, source));
  }
  revealPrimaryCursor(source, revealHorizontal) {
    this._withViewEventsCollector((eventsCollector) => this._cursor.revealPrimary(eventsCollector, source, revealHorizontal, 0));
  }
  revealTopMostCursor(source) {
    const viewPosition = this._cursor.getTopMostViewPosition();
    const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);
    this._withViewEventsCollector((eventsCollector) => eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, viewRange, null, 0, true, 0)));
  }
  revealBottomMostCursor(source) {
    const viewPosition = this._cursor.getBottomMostViewPosition();
    const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);
    this._withViewEventsCollector((eventsCollector) => eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, viewRange, null, 0, true, 0)));
  }
  revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {
    this._withViewEventsCollector((eventsCollector) => eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, viewRange, null, verticalType, revealHorizontal, scrollType)));
  }
  getVerticalOffsetForLineNumber(viewLineNumber) {
    return this.viewLayout.getVerticalOffsetForLineNumber(viewLineNumber);
  }
  getScrollTop() {
    return this.viewLayout.getCurrentScrollTop();
  }
  setScrollTop(newScrollTop, scrollType) {
    this.viewLayout.setScrollPosition({scrollTop: newScrollTop}, scrollType);
  }
  setScrollPosition(position, type) {
    this.viewLayout.setScrollPosition(position, type);
  }
  deltaScrollNow(deltaScrollLeft, deltaScrollTop) {
    this.viewLayout.deltaScrollNow(deltaScrollLeft, deltaScrollTop);
  }
  changeWhitespace(callback) {
    const hadAChange = this.viewLayout.changeWhitespace(callback);
    if (hadAChange) {
      this._eventDispatcher.emitSingleViewEvent(new ViewZonesChangedEvent());
      this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent2());
    }
  }
  setMaxLineWidth(maxLineWidth) {
    this.viewLayout.setMaxLineWidth(maxLineWidth);
  }
  _withViewEventsCollector(callback) {
    try {
      const eventsCollector = this._eventDispatcher.beginEmitViewEvents();
      callback(eventsCollector);
    } finally {
      this._eventDispatcher.endEmitViewEvents();
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/serviceCollection.js
var ServiceCollection = class {
  constructor(...entries) {
    this._entries = new Map();
    for (let [id, service] of entries) {
      this.set(id, service);
    }
  }
  set(id, instanceOrDescriptor) {
    const result = this._entries.get(id);
    this._entries.set(id, instanceOrDescriptor);
    return result;
  }
  has(id) {
    return this._entries.has(id);
  }
  get(id) {
    return this._entries.get(id);
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/accessibility/common/accessibility.js
var IAccessibilityService = createDecorator("accessibilityService");
var CONTEXT_ACCESSIBILITY_MODE_ENABLED = new RawContextKey("accessibilityModeEnabled", false);

// ../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js
var WrappingCharacterClassifier = class extends CharacterClassifier {
  constructor(BREAK_BEFORE, BREAK_AFTER) {
    super(0);
    for (let i = 0; i < BREAK_BEFORE.length; i++) {
      this.set(BREAK_BEFORE.charCodeAt(i), 1);
    }
    for (let i = 0; i < BREAK_AFTER.length; i++) {
      this.set(BREAK_AFTER.charCodeAt(i), 2);
    }
  }
  get(charCode) {
    if (charCode >= 0 && charCode < 256) {
      return this._asciiMap[charCode];
    } else {
      if (charCode >= 12352 && charCode <= 12543 || charCode >= 13312 && charCode <= 19903 || charCode >= 19968 && charCode <= 40959) {
        return 3;
      }
      return this._map.get(charCode) || this._defaultValue;
    }
  }
};
var arrPool1 = [];
var arrPool2 = [];
var MonospaceLineBreaksComputerFactory = class {
  constructor(breakBeforeChars, breakAfterChars) {
    this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);
  }
  static create(options) {
    return new MonospaceLineBreaksComputerFactory(options.get(108), options.get(107));
  }
  createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {
    tabSize = tabSize | 0;
    wrappingColumn = +wrappingColumn;
    let requests = [];
    let previousBreakingData = [];
    return {
      addRequest: (lineText, previousLineBreakData) => {
        requests.push(lineText);
        previousBreakingData.push(previousLineBreakData);
      },
      finalize: () => {
        const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;
        let result = [];
        for (let i = 0, len = requests.length; i < len; i++) {
          const previousLineBreakData = previousBreakingData[i];
          if (previousLineBreakData) {
            result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);
          } else {
            result[i] = createLineBreaks(this.classifier, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);
          }
        }
        arrPool1.length = 0;
        arrPool2.length = 0;
        return result;
      }
    };
  }
};
function createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {
  if (firstLineBreakColumn === -1) {
    return null;
  }
  const len = lineText.length;
  if (len <= 1) {
    return null;
  }
  const prevBreakingOffsets = previousBreakingData.breakOffsets;
  const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;
  const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);
  const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;
  let breakingOffsets = arrPool1;
  let breakingOffsetsVisibleColumn = arrPool2;
  let breakingOffsetsCount = 0;
  let lastBreakingOffset = 0;
  let lastBreakingOffsetVisibleColumn = 0;
  let breakingColumn = firstLineBreakColumn;
  const prevLen = prevBreakingOffsets.length;
  let prevIndex = 0;
  if (prevIndex >= 0) {
    let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);
    while (prevIndex + 1 < prevLen) {
      const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);
      if (distance >= bestDistance) {
        break;
      }
      bestDistance = distance;
      prevIndex++;
    }
  }
  while (prevIndex < prevLen) {
    let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];
    let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];
    if (lastBreakingOffset > prevBreakOffset) {
      prevBreakOffset = lastBreakingOffset;
      prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;
    }
    let breakOffset = 0;
    let breakOffsetVisibleColumn = 0;
    let forcedBreakOffset = 0;
    let forcedBreakOffsetVisibleColumn = 0;
    if (prevBreakOffsetVisibleColumn <= breakingColumn) {
      let visibleColumn = prevBreakOffsetVisibleColumn;
      let prevCharCode = prevBreakOffset === 0 ? 0 : lineText.charCodeAt(prevBreakOffset - 1);
      let prevCharCodeClass = prevBreakOffset === 0 ? 0 : classifier.get(prevCharCode);
      let entireLineFits = true;
      for (let i = prevBreakOffset; i < len; i++) {
        const charStartOffset = i;
        const charCode = lineText.charCodeAt(i);
        let charCodeClass;
        let charWidth;
        if (isHighSurrogate(charCode)) {
          i++;
          charCodeClass = 0;
          charWidth = 2;
        } else {
          charCodeClass = classifier.get(charCode);
          charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);
        }
        if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {
          breakOffset = charStartOffset;
          breakOffsetVisibleColumn = visibleColumn;
        }
        visibleColumn += charWidth;
        if (visibleColumn > breakingColumn) {
          if (charStartOffset > lastBreakingOffset) {
            forcedBreakOffset = charStartOffset;
            forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;
          } else {
            forcedBreakOffset = i + 1;
            forcedBreakOffsetVisibleColumn = visibleColumn;
          }
          if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {
            breakOffset = 0;
          }
          entireLineFits = false;
          break;
        }
        prevCharCode = charCode;
        prevCharCodeClass = charCodeClass;
      }
      if (entireLineFits) {
        if (breakingOffsetsCount > 0) {
          breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];
          breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];
          breakingOffsetsCount++;
        }
        break;
      }
    }
    if (breakOffset === 0) {
      let visibleColumn = prevBreakOffsetVisibleColumn;
      let charCode = lineText.charCodeAt(prevBreakOffset);
      let charCodeClass = classifier.get(charCode);
      let hitATabCharacter = false;
      for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {
        const charStartOffset = i + 1;
        const prevCharCode = lineText.charCodeAt(i);
        if (prevCharCode === 9) {
          hitATabCharacter = true;
          break;
        }
        let prevCharCodeClass;
        let prevCharWidth;
        if (isLowSurrogate(prevCharCode)) {
          i--;
          prevCharCodeClass = 0;
          prevCharWidth = 2;
        } else {
          prevCharCodeClass = classifier.get(prevCharCode);
          prevCharWidth = isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1;
        }
        if (visibleColumn <= breakingColumn) {
          if (forcedBreakOffset === 0) {
            forcedBreakOffset = charStartOffset;
            forcedBreakOffsetVisibleColumn = visibleColumn;
          }
          if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {
            break;
          }
          if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {
            breakOffset = charStartOffset;
            breakOffsetVisibleColumn = visibleColumn;
            break;
          }
        }
        visibleColumn -= prevCharWidth;
        charCode = prevCharCode;
        charCodeClass = prevCharCodeClass;
      }
      if (breakOffset !== 0) {
        const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);
        if (remainingWidthOfNextLine <= tabSize) {
          const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);
          let charWidth;
          if (isHighSurrogate(charCodeAtForcedBreakOffset)) {
            charWidth = 2;
          } else {
            charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);
          }
          if (remainingWidthOfNextLine - charWidth < 0) {
            breakOffset = 0;
          }
        }
      }
      if (hitATabCharacter) {
        prevIndex--;
        continue;
      }
    }
    if (breakOffset === 0) {
      breakOffset = forcedBreakOffset;
      breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;
    }
    lastBreakingOffset = breakOffset;
    breakingOffsets[breakingOffsetsCount] = breakOffset;
    lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;
    breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;
    breakingOffsetsCount++;
    breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;
    while (prevIndex < 0 || prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn) {
      prevIndex++;
    }
    let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);
    while (prevIndex + 1 < prevLen) {
      const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);
      if (distance >= bestDistance) {
        break;
      }
      bestDistance = distance;
      prevIndex++;
    }
  }
  if (breakingOffsetsCount === 0) {
    return null;
  }
  breakingOffsets.length = breakingOffsetsCount;
  breakingOffsetsVisibleColumn.length = breakingOffsetsCount;
  arrPool1 = previousBreakingData.breakOffsets;
  arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;
  previousBreakingData.breakOffsets = breakingOffsets;
  previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;
  previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;
  return previousBreakingData;
}
function createLineBreaks(classifier, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {
  if (firstLineBreakColumn === -1) {
    return null;
  }
  const len = lineText.length;
  if (len <= 1) {
    return null;
  }
  const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);
  const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;
  let breakingOffsets = [];
  let breakingOffsetsVisibleColumn = [];
  let breakingOffsetsCount = 0;
  let breakOffset = 0;
  let breakOffsetVisibleColumn = 0;
  let breakingColumn = firstLineBreakColumn;
  let prevCharCode = lineText.charCodeAt(0);
  let prevCharCodeClass = classifier.get(prevCharCode);
  let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);
  let startOffset = 1;
  if (isHighSurrogate(prevCharCode)) {
    visibleColumn += 1;
    prevCharCode = lineText.charCodeAt(1);
    prevCharCodeClass = classifier.get(prevCharCode);
    startOffset++;
  }
  for (let i = startOffset; i < len; i++) {
    const charStartOffset = i;
    const charCode = lineText.charCodeAt(i);
    let charCodeClass;
    let charWidth;
    if (isHighSurrogate(charCode)) {
      i++;
      charCodeClass = 0;
      charWidth = 2;
    } else {
      charCodeClass = classifier.get(charCode);
      charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);
    }
    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {
      breakOffset = charStartOffset;
      breakOffsetVisibleColumn = visibleColumn;
    }
    visibleColumn += charWidth;
    if (visibleColumn > breakingColumn) {
      if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {
        breakOffset = charStartOffset;
        breakOffsetVisibleColumn = visibleColumn - charWidth;
      }
      breakingOffsets[breakingOffsetsCount] = breakOffset;
      breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;
      breakingOffsetsCount++;
      breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;
      breakOffset = 0;
    }
    prevCharCode = charCode;
    prevCharCodeClass = charCodeClass;
  }
  if (breakingOffsetsCount === 0) {
    return null;
  }
  breakingOffsets[breakingOffsetsCount] = len;
  breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;
  return new LineBreakData(breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);
}
function computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {
  if (charCode === 9) {
    return tabSize - visibleColumn % tabSize;
  }
  if (isFullWidthCharacter(charCode)) {
    return columnsForFullWidthChar;
  }
  return 1;
}
function tabCharacterWidth(visibleColumn, tabSize) {
  return tabSize - visibleColumn % tabSize;
}
function canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass) {
  return charCode !== 32 && (prevCharCodeClass === 2 || prevCharCodeClass === 3 && charCodeClass !== 2 || charCodeClass === 1 || charCodeClass === 3 && prevCharCodeClass !== 1);
}
function computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {
  let wrappedTextIndentLength = 0;
  if (wrappingIndent !== 0) {
    const firstNonWhitespaceIndex2 = firstNonWhitespaceIndex(lineText);
    if (firstNonWhitespaceIndex2 !== -1) {
      for (let i = 0; i < firstNonWhitespaceIndex2; i++) {
        const charWidth = lineText.charCodeAt(i) === 9 ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1;
        wrappedTextIndentLength += charWidth;
      }
      const numberOfAdditionalTabs = wrappingIndent === 3 ? 2 : wrappingIndent === 2 ? 1 : 0;
      for (let i = 0; i < numberOfAdditionalTabs; i++) {
        const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);
        wrappedTextIndentLength += charWidth;
      }
      if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {
        wrappedTextIndentLength = 0;
      }
    }
  }
  return wrappedTextIndentLength;
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/view/domLineBreaksComputer.js
var DOMLineBreaksComputerFactory = class {
  static create() {
    return new DOMLineBreaksComputerFactory();
  }
  constructor() {
  }
  createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {
    tabSize = tabSize | 0;
    wrappingColumn = +wrappingColumn;
    let requests = [];
    return {
      addRequest: (lineText, previousLineBreakData) => {
        requests.push(lineText);
      },
      finalize: () => {
        return createLineBreaks2(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent);
      }
    };
  }
};
function createLineBreaks2(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent) {
  if (firstLineBreakColumn === -1) {
    const result2 = [];
    for (let i = 0, len = requests.length; i < len; i++) {
      result2[i] = null;
    }
    return result2;
  }
  const overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);
  if (wrappingIndent === 2 || wrappingIndent === 3) {
    wrappingIndent = 1;
  }
  const containerDomNode = document.createElement("div");
  Configuration2.applyFontInfoSlow(containerDomNode, fontInfo);
  const sb = createStringBuilder(1e4);
  const firstNonWhitespaceIndices = [];
  const wrappedTextIndentLengths = [];
  const renderLineContents = [];
  const allCharOffsets = [];
  const allVisibleColumns = [];
  for (let i = 0; i < requests.length; i++) {
    const lineContent = requests[i];
    let firstNonWhitespaceIndex2 = 0;
    let wrappedTextIndentLength = 0;
    let width = overallWidth;
    if (wrappingIndent !== 0) {
      firstNonWhitespaceIndex2 = firstNonWhitespaceIndex(lineContent);
      if (firstNonWhitespaceIndex2 === -1) {
        firstNonWhitespaceIndex2 = 0;
      } else {
        for (let i2 = 0; i2 < firstNonWhitespaceIndex2; i2++) {
          const charWidth = lineContent.charCodeAt(i2) === 9 ? tabSize - wrappedTextIndentLength % tabSize : 1;
          wrappedTextIndentLength += charWidth;
        }
        const indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);
        if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {
          firstNonWhitespaceIndex2 = 0;
          wrappedTextIndentLength = 0;
        } else {
          width = overallWidth - indentWidth;
        }
      }
    }
    const renderLineContent = lineContent.substr(firstNonWhitespaceIndex2);
    const tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb);
    firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex2;
    wrappedTextIndentLengths[i] = wrappedTextIndentLength;
    renderLineContents[i] = renderLineContent;
    allCharOffsets[i] = tmp[0];
    allVisibleColumns[i] = tmp[1];
  }
  containerDomNode.innerHTML = sb.build();
  containerDomNode.style.position = "absolute";
  containerDomNode.style.top = "10000";
  containerDomNode.style.wordWrap = "break-word";
  document.body.appendChild(containerDomNode);
  let range2 = document.createRange();
  const lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);
  let result = [];
  for (let i = 0; i < requests.length; i++) {
    const lineDomNode = lineDomNodes[i];
    const breakOffsets = readLineBreaks(range2, lineDomNode, renderLineContents[i], allCharOffsets[i]);
    if (breakOffsets === null) {
      result[i] = null;
      continue;
    }
    const firstNonWhitespaceIndex2 = firstNonWhitespaceIndices[i];
    const wrappedTextIndentLength = wrappedTextIndentLengths[i];
    const visibleColumns = allVisibleColumns[i];
    const breakOffsetsVisibleColumn = [];
    for (let j = 0, len = breakOffsets.length; j < len; j++) {
      breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];
    }
    if (firstNonWhitespaceIndex2 !== 0) {
      for (let j = 0, len = breakOffsets.length; j < len; j++) {
        breakOffsets[j] += firstNonWhitespaceIndex2;
      }
    }
    result[i] = new LineBreakData(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);
  }
  document.body.removeChild(containerDomNode);
  return result;
}
function renderLine(lineContent, initialVisibleColumn, tabSize, width, sb) {
  sb.appendASCIIString('<div style="width:');
  sb.appendASCIIString(String(width));
  sb.appendASCIIString('px;">');
  const len = lineContent.length;
  let visibleColumn = initialVisibleColumn;
  let charOffset = 0;
  let charOffsets = [];
  let visibleColumns = [];
  let nextCharCode = 0 < len ? lineContent.charCodeAt(0) : 0;
  sb.appendASCIIString("<span>");
  for (let charIndex = 0; charIndex < len; charIndex++) {
    if (charIndex !== 0 && charIndex % 16384 === 0) {
      sb.appendASCIIString("</span><span>");
    }
    charOffsets[charIndex] = charOffset;
    visibleColumns[charIndex] = visibleColumn;
    const charCode = nextCharCode;
    nextCharCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0;
    let producedCharacters = 1;
    let charWidth = 1;
    switch (charCode) {
      case 9:
        producedCharacters = tabSize - visibleColumn % tabSize;
        charWidth = producedCharacters;
        for (let space = 1; space <= producedCharacters; space++) {
          if (space < producedCharacters) {
            sb.write1(160);
          } else {
            sb.appendASCII(32);
          }
        }
        break;
      case 32:
        if (nextCharCode === 32) {
          sb.write1(160);
        } else {
          sb.appendASCII(32);
        }
        break;
      case 60:
        sb.appendASCIIString("&lt;");
        break;
      case 62:
        sb.appendASCIIString("&gt;");
        break;
      case 38:
        sb.appendASCIIString("&amp;");
        break;
      case 0:
        sb.appendASCIIString("&#00;");
        break;
      case 65279:
      case 8232:
      case 8233:
      case 133:
        sb.write1(65533);
        break;
      default:
        if (isFullWidthCharacter(charCode)) {
          charWidth++;
        }
        sb.write1(charCode);
    }
    charOffset += producedCharacters;
    visibleColumn += charWidth;
  }
  sb.appendASCIIString("</span>");
  charOffsets[lineContent.length] = charOffset;
  visibleColumns[lineContent.length] = visibleColumn;
  sb.appendASCIIString("</div>");
  return [charOffsets, visibleColumns];
}
function readLineBreaks(range2, lineDomNode, lineContent, charOffsets) {
  if (lineContent.length <= 1) {
    return null;
  }
  const spans = Array.prototype.slice.call(lineDomNode.children, 0);
  const breakOffsets = [];
  try {
    discoverBreaks(range2, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);
  } catch (err) {
    console.log(err);
    return null;
  }
  if (breakOffsets.length === 0) {
    return null;
  }
  breakOffsets.push(lineContent.length);
  return breakOffsets;
}
function discoverBreaks(range2, spans, charOffsets, low, lowRects, high, highRects, result) {
  if (low === high) {
    return;
  }
  lowRects = lowRects || readClientRect(range2, spans, charOffsets[low], charOffsets[low + 1]);
  highRects = highRects || readClientRect(range2, spans, charOffsets[high], charOffsets[high + 1]);
  if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {
    return;
  }
  if (low + 1 === high) {
    result.push(high);
    return;
  }
  const mid = low + (high - low) / 2 | 0;
  const midRects = readClientRect(range2, spans, charOffsets[mid], charOffsets[mid + 1]);
  discoverBreaks(range2, spans, charOffsets, low, lowRects, mid, midRects, result);
  discoverBreaks(range2, spans, charOffsets, mid, midRects, high, highRects, result);
}
function readClientRect(range2, spans, startOffset, endOffset) {
  range2.setStart(spans[startOffset / 16384 | 0].firstChild, startOffset % 16384);
  range2.setEnd(spans[endOffset / 16384 | 0].firstChild, endOffset % 16384);
  return range2.getClientRects();
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/widget/codeEditorWidget.js
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var EDITOR_ID = 0;
var ModelData = class {
  constructor(model2, viewModel, view, hasRealView, listenersToRemove) {
    this.model = model2;
    this.viewModel = viewModel;
    this.view = view;
    this.hasRealView = hasRealView;
    this.listenersToRemove = listenersToRemove;
  }
  dispose() {
    dispose(this.listenersToRemove);
    this.model.onBeforeDetached();
    if (this.hasRealView) {
      this.view.dispose();
    }
    this.viewModel.dispose();
  }
};
var CodeEditorWidget = class CodeEditorWidget2 extends Disposable {
  constructor(domElement, options, codeEditorWidgetOptions, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService) {
    super();
    this._onDidDispose = this._register(new Emitter());
    this.onDidDispose = this._onDidDispose.event;
    this._onDidChangeModelContent = this._register(new Emitter());
    this.onDidChangeModelContent = this._onDidChangeModelContent.event;
    this._onDidChangeModelLanguage = this._register(new Emitter());
    this.onDidChangeModelLanguage = this._onDidChangeModelLanguage.event;
    this._onDidChangeModelLanguageConfiguration = this._register(new Emitter());
    this.onDidChangeModelLanguageConfiguration = this._onDidChangeModelLanguageConfiguration.event;
    this._onDidChangeModelOptions = this._register(new Emitter());
    this.onDidChangeModelOptions = this._onDidChangeModelOptions.event;
    this._onDidChangeModelDecorations = this._register(new Emitter());
    this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event;
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this._onDidChangeModel = this._register(new Emitter());
    this.onDidChangeModel = this._onDidChangeModel.event;
    this._onDidChangeCursorPosition = this._register(new Emitter());
    this.onDidChangeCursorPosition = this._onDidChangeCursorPosition.event;
    this._onDidChangeCursorSelection = this._register(new Emitter());
    this.onDidChangeCursorSelection = this._onDidChangeCursorSelection.event;
    this._onDidAttemptReadOnlyEdit = this._register(new Emitter());
    this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event;
    this._onDidLayoutChange = this._register(new Emitter());
    this.onDidLayoutChange = this._onDidLayoutChange.event;
    this._editorTextFocus = this._register(new BooleanEventEmitter());
    this.onDidFocusEditorText = this._editorTextFocus.onDidChangeToTrue;
    this.onDidBlurEditorText = this._editorTextFocus.onDidChangeToFalse;
    this._editorWidgetFocus = this._register(new BooleanEventEmitter());
    this.onDidFocusEditorWidget = this._editorWidgetFocus.onDidChangeToTrue;
    this.onDidBlurEditorWidget = this._editorWidgetFocus.onDidChangeToFalse;
    this._onWillType = this._register(new Emitter());
    this.onWillType = this._onWillType.event;
    this._onDidType = this._register(new Emitter());
    this.onDidType = this._onDidType.event;
    this._onDidCompositionStart = this._register(new Emitter());
    this.onDidCompositionStart = this._onDidCompositionStart.event;
    this._onDidCompositionEnd = this._register(new Emitter());
    this.onDidCompositionEnd = this._onDidCompositionEnd.event;
    this._onDidPaste = this._register(new Emitter());
    this.onDidPaste = this._onDidPaste.event;
    this._onMouseUp = this._register(new Emitter());
    this.onMouseUp = this._onMouseUp.event;
    this._onMouseDown = this._register(new Emitter());
    this.onMouseDown = this._onMouseDown.event;
    this._onMouseDrag = this._register(new Emitter());
    this.onMouseDrag = this._onMouseDrag.event;
    this._onMouseDrop = this._register(new Emitter());
    this.onMouseDrop = this._onMouseDrop.event;
    this._onContextMenu = this._register(new Emitter());
    this.onContextMenu = this._onContextMenu.event;
    this._onMouseMove = this._register(new Emitter());
    this.onMouseMove = this._onMouseMove.event;
    this._onMouseLeave = this._register(new Emitter());
    this.onMouseLeave = this._onMouseLeave.event;
    this._onMouseWheel = this._register(new Emitter());
    this.onMouseWheel = this._onMouseWheel.event;
    this._onKeyUp = this._register(new Emitter());
    this.onKeyUp = this._onKeyUp.event;
    this._onKeyDown = this._register(new Emitter());
    this.onKeyDown = this._onKeyDown.event;
    this._onDidContentSizeChange = this._register(new Emitter());
    this.onDidContentSizeChange = this._onDidContentSizeChange.event;
    this._onDidScrollChange = this._register(new Emitter());
    this.onDidScrollChange = this._onDidScrollChange.event;
    this._onDidChangeViewZones = this._register(new Emitter());
    this.onDidChangeViewZones = this._onDidChangeViewZones.event;
    options = options || {};
    this._domElement = domElement;
    this._overflowWidgetsDomNode = options.overflowWidgetsDomNode;
    this._id = ++EDITOR_ID;
    this._decorationTypeKeysToIds = {};
    this._decorationTypeSubtypes = {};
    this.isSimpleWidget = codeEditorWidgetOptions.isSimpleWidget || false;
    this._telemetryData = codeEditorWidgetOptions.telemetryData;
    this._configuration = this._register(this._createConfiguration(options, accessibilityService));
    this._register(this._configuration.onDidChange((e) => {
      this._onDidChangeConfiguration.fire(e);
      const options2 = this._configuration.options;
      if (e.hasChanged(117)) {
        const layoutInfo = options2.get(117);
        this._onDidLayoutChange.fire(layoutInfo);
      }
    }));
    this._contextKeyService = this._register(contextKeyService.createScoped(this._domElement));
    this._notificationService = notificationService;
    this._codeEditorService = codeEditorService;
    this._commandService = commandService;
    this._themeService = themeService;
    this._register(new EditorContextKeysManager(this, this._contextKeyService));
    this._register(new EditorModeContext(this, this._contextKeyService));
    this._instantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, this._contextKeyService]));
    this._modelData = null;
    this._contributions = {};
    this._actions = {};
    this._focusTracker = new CodeEditorWidgetFocusTracker(domElement);
    this._focusTracker.onChange(() => {
      this._editorWidgetFocus.setValue(this._focusTracker.hasFocus());
    });
    this._contentWidgets = {};
    this._overlayWidgets = {};
    let contributions;
    if (Array.isArray(codeEditorWidgetOptions.contributions)) {
      contributions = codeEditorWidgetOptions.contributions;
    } else {
      contributions = EditorExtensionsRegistry.getEditorContributions();
    }
    for (const desc of contributions) {
      try {
        const contribution = this._instantiationService.createInstance(desc.ctor, this);
        this._contributions[desc.id] = contribution;
      } catch (err) {
        onUnexpectedError(err);
      }
    }
    EditorExtensionsRegistry.getEditorActions().forEach((action) => {
      const internalAction = new InternalEditorAction(action.id, action.label, action.alias, withNullAsUndefined(action.precondition), () => {
        return this._instantiationService.invokeFunction((accessor) => {
          return Promise.resolve(action.runEditorCommand(accessor, this, null));
        });
      }, this._contextKeyService);
      this._actions[internalAction.id] = internalAction;
    });
    this._codeEditorService.addCodeEditor(this);
  }
  _createConfiguration(options, accessibilityService) {
    return new Configuration2(this.isSimpleWidget, options, this._domElement, accessibilityService);
  }
  getId() {
    return this.getEditorType() + ":" + this._id;
  }
  getEditorType() {
    return EditorType.ICodeEditor;
  }
  dispose() {
    this._codeEditorService.removeCodeEditor(this);
    this._focusTracker.dispose();
    const keys = Object.keys(this._contributions);
    for (let i = 0, len = keys.length; i < len; i++) {
      const contributionId = keys[i];
      this._contributions[contributionId].dispose();
    }
    this._removeDecorationTypes();
    this._postDetachModelCleanup(this._detachModel());
    this._onDidDispose.fire();
    super.dispose();
  }
  invokeWithinContext(fn) {
    return this._instantiationService.invokeFunction(fn);
  }
  updateOptions(newOptions) {
    this._configuration.updateOptions(newOptions);
  }
  getOptions() {
    return this._configuration.options;
  }
  getOption(id) {
    return this._configuration.options.get(id);
  }
  getRawOptions() {
    return this._configuration.getRawOptions();
  }
  getOverflowWidgetsDomNode() {
    return this._overflowWidgetsDomNode;
  }
  getConfiguredWordAtPosition(position) {
    if (!this._modelData) {
      return null;
    }
    return WordOperations.getWordAtPosition(this._modelData.model, this._configuration.options.get(105), position);
  }
  getValue(options = null) {
    if (!this._modelData) {
      return "";
    }
    const preserveBOM = options && options.preserveBOM ? true : false;
    let eolPreference = 0;
    if (options && options.lineEnding && options.lineEnding === "\n") {
      eolPreference = 1;
    } else if (options && options.lineEnding && options.lineEnding === "\r\n") {
      eolPreference = 2;
    }
    return this._modelData.model.getValue(eolPreference, preserveBOM);
  }
  setValue(newValue) {
    if (!this._modelData) {
      return;
    }
    this._modelData.model.setValue(newValue);
  }
  getModel() {
    if (!this._modelData) {
      return null;
    }
    return this._modelData.model;
  }
  setModel(_model = null) {
    const model2 = _model;
    if (this._modelData === null && model2 === null) {
      return;
    }
    if (this._modelData && this._modelData.model === model2) {
      return;
    }
    const hasTextFocus = this.hasTextFocus();
    const detachedModel = this._detachModel();
    this._attachModel(model2);
    if (hasTextFocus && this.hasModel()) {
      this.focus();
    }
    const e = {
      oldModelUrl: detachedModel ? detachedModel.uri : null,
      newModelUrl: model2 ? model2.uri : null
    };
    this._removeDecorationTypes();
    this._onDidChangeModel.fire(e);
    this._postDetachModelCleanup(detachedModel);
  }
  _removeDecorationTypes() {
    this._decorationTypeKeysToIds = {};
    if (this._decorationTypeSubtypes) {
      for (let decorationType in this._decorationTypeSubtypes) {
        const subTypes = this._decorationTypeSubtypes[decorationType];
        for (let subType in subTypes) {
          this._removeDecorationType(decorationType + "-" + subType);
        }
      }
      this._decorationTypeSubtypes = {};
    }
  }
  getVisibleRanges() {
    if (!this._modelData) {
      return [];
    }
    return this._modelData.viewModel.getVisibleRanges();
  }
  getVisibleRangesPlusViewportAboveBelow() {
    if (!this._modelData) {
      return [];
    }
    return this._modelData.viewModel.getVisibleRangesPlusViewportAboveBelow();
  }
  getWhitespaces() {
    if (!this._modelData) {
      return [];
    }
    return this._modelData.viewModel.viewLayout.getWhitespaces();
  }
  static _getVerticalOffsetForPosition(modelData, modelLineNumber, modelColumn) {
    const modelPosition = modelData.model.validatePosition({
      lineNumber: modelLineNumber,
      column: modelColumn
    });
    const viewPosition = modelData.viewModel.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);
    return modelData.viewModel.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);
  }
  getTopForLineNumber(lineNumber) {
    if (!this._modelData) {
      return -1;
    }
    return CodeEditorWidget2._getVerticalOffsetForPosition(this._modelData, lineNumber, 1);
  }
  getTopForPosition(lineNumber, column) {
    if (!this._modelData) {
      return -1;
    }
    return CodeEditorWidget2._getVerticalOffsetForPosition(this._modelData, lineNumber, column);
  }
  setHiddenAreas(ranges) {
    if (this._modelData) {
      this._modelData.viewModel.setHiddenAreas(ranges.map((r) => Range.lift(r)));
    }
  }
  getVisibleColumnFromPosition(rawPosition) {
    if (!this._modelData) {
      return rawPosition.column;
    }
    const position = this._modelData.model.validatePosition(rawPosition);
    const tabSize = this._modelData.model.getOptions().tabSize;
    return CursorColumns.visibleColumnFromColumn(this._modelData.model.getLineContent(position.lineNumber), position.column, tabSize) + 1;
  }
  getPosition() {
    if (!this._modelData) {
      return null;
    }
    return this._modelData.viewModel.getPosition();
  }
  setPosition(position) {
    if (!this._modelData) {
      return;
    }
    if (!Position.isIPosition(position)) {
      throw new Error("Invalid arguments");
    }
    this._modelData.viewModel.setSelections("api", [{
      selectionStartLineNumber: position.lineNumber,
      selectionStartColumn: position.column,
      positionLineNumber: position.lineNumber,
      positionColumn: position.column
    }]);
  }
  _sendRevealRange(modelRange, verticalType, revealHorizontal, scrollType) {
    if (!this._modelData) {
      return;
    }
    if (!Range.isIRange(modelRange)) {
      throw new Error("Invalid arguments");
    }
    const validatedModelRange = this._modelData.model.validateRange(modelRange);
    const viewRange = this._modelData.viewModel.coordinatesConverter.convertModelRangeToViewRange(validatedModelRange);
    this._modelData.viewModel.revealRange("api", revealHorizontal, viewRange, verticalType, scrollType);
  }
  revealLine(lineNumber, scrollType = 0) {
    this._revealLine(lineNumber, 0, scrollType);
  }
  revealLineInCenter(lineNumber, scrollType = 0) {
    this._revealLine(lineNumber, 1, scrollType);
  }
  revealLineInCenterIfOutsideViewport(lineNumber, scrollType = 0) {
    this._revealLine(lineNumber, 2, scrollType);
  }
  revealLineNearTop(lineNumber, scrollType = 0) {
    this._revealLine(lineNumber, 5, scrollType);
  }
  _revealLine(lineNumber, revealType, scrollType) {
    if (typeof lineNumber !== "number") {
      throw new Error("Invalid arguments");
    }
    this._sendRevealRange(new Range(lineNumber, 1, lineNumber, 1), revealType, false, scrollType);
  }
  revealPosition(position, scrollType = 0) {
    this._revealPosition(position, 0, true, scrollType);
  }
  revealPositionInCenter(position, scrollType = 0) {
    this._revealPosition(position, 1, true, scrollType);
  }
  revealPositionInCenterIfOutsideViewport(position, scrollType = 0) {
    this._revealPosition(position, 2, true, scrollType);
  }
  revealPositionNearTop(position, scrollType = 0) {
    this._revealPosition(position, 5, true, scrollType);
  }
  _revealPosition(position, verticalType, revealHorizontal, scrollType) {
    if (!Position.isIPosition(position)) {
      throw new Error("Invalid arguments");
    }
    this._sendRevealRange(new Range(position.lineNumber, position.column, position.lineNumber, position.column), verticalType, revealHorizontal, scrollType);
  }
  getSelection() {
    if (!this._modelData) {
      return null;
    }
    return this._modelData.viewModel.getSelection();
  }
  getSelections() {
    if (!this._modelData) {
      return null;
    }
    return this._modelData.viewModel.getSelections();
  }
  setSelection(something) {
    const isSelection = Selection.isISelection(something);
    const isRange = Range.isIRange(something);
    if (!isSelection && !isRange) {
      throw new Error("Invalid arguments");
    }
    if (isSelection) {
      this._setSelectionImpl(something);
    } else if (isRange) {
      const selection = {
        selectionStartLineNumber: something.startLineNumber,
        selectionStartColumn: something.startColumn,
        positionLineNumber: something.endLineNumber,
        positionColumn: something.endColumn
      };
      this._setSelectionImpl(selection);
    }
  }
  _setSelectionImpl(sel) {
    if (!this._modelData) {
      return;
    }
    const selection = new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
    this._modelData.viewModel.setSelections("api", [selection]);
  }
  revealLines(startLineNumber, endLineNumber, scrollType = 0) {
    this._revealLines(startLineNumber, endLineNumber, 0, scrollType);
  }
  revealLinesInCenter(startLineNumber, endLineNumber, scrollType = 0) {
    this._revealLines(startLineNumber, endLineNumber, 1, scrollType);
  }
  revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType = 0) {
    this._revealLines(startLineNumber, endLineNumber, 2, scrollType);
  }
  revealLinesNearTop(startLineNumber, endLineNumber, scrollType = 0) {
    this._revealLines(startLineNumber, endLineNumber, 5, scrollType);
  }
  _revealLines(startLineNumber, endLineNumber, verticalType, scrollType) {
    if (typeof startLineNumber !== "number" || typeof endLineNumber !== "number") {
      throw new Error("Invalid arguments");
    }
    this._sendRevealRange(new Range(startLineNumber, 1, endLineNumber, 1), verticalType, false, scrollType);
  }
  revealRange(range2, scrollType = 0, revealVerticalInCenter = false, revealHorizontal = true) {
    this._revealRange(range2, revealVerticalInCenter ? 1 : 0, revealHorizontal, scrollType);
  }
  revealRangeInCenter(range2, scrollType = 0) {
    this._revealRange(range2, 1, true, scrollType);
  }
  revealRangeInCenterIfOutsideViewport(range2, scrollType = 0) {
    this._revealRange(range2, 2, true, scrollType);
  }
  revealRangeNearTop(range2, scrollType = 0) {
    this._revealRange(range2, 5, true, scrollType);
  }
  revealRangeNearTopIfOutsideViewport(range2, scrollType = 0) {
    this._revealRange(range2, 6, true, scrollType);
  }
  revealRangeAtTop(range2, scrollType = 0) {
    this._revealRange(range2, 3, true, scrollType);
  }
  _revealRange(range2, verticalType, revealHorizontal, scrollType) {
    if (!Range.isIRange(range2)) {
      throw new Error("Invalid arguments");
    }
    this._sendRevealRange(Range.lift(range2), verticalType, revealHorizontal, scrollType);
  }
  setSelections(ranges, source = "api") {
    if (!this._modelData) {
      return;
    }
    if (!ranges || ranges.length === 0) {
      throw new Error("Invalid arguments");
    }
    for (let i = 0, len = ranges.length; i < len; i++) {
      if (!Selection.isISelection(ranges[i])) {
        throw new Error("Invalid arguments");
      }
    }
    this._modelData.viewModel.setSelections(source, ranges);
  }
  getContentWidth() {
    if (!this._modelData) {
      return -1;
    }
    return this._modelData.viewModel.viewLayout.getContentWidth();
  }
  getScrollWidth() {
    if (!this._modelData) {
      return -1;
    }
    return this._modelData.viewModel.viewLayout.getScrollWidth();
  }
  getScrollLeft() {
    if (!this._modelData) {
      return -1;
    }
    return this._modelData.viewModel.viewLayout.getCurrentScrollLeft();
  }
  getContentHeight() {
    if (!this._modelData) {
      return -1;
    }
    return this._modelData.viewModel.viewLayout.getContentHeight();
  }
  getScrollHeight() {
    if (!this._modelData) {
      return -1;
    }
    return this._modelData.viewModel.viewLayout.getScrollHeight();
  }
  getScrollTop() {
    if (!this._modelData) {
      return -1;
    }
    return this._modelData.viewModel.viewLayout.getCurrentScrollTop();
  }
  setScrollLeft(newScrollLeft, scrollType = 1) {
    if (!this._modelData) {
      return;
    }
    if (typeof newScrollLeft !== "number") {
      throw new Error("Invalid arguments");
    }
    this._modelData.viewModel.setScrollPosition({
      scrollLeft: newScrollLeft
    }, scrollType);
  }
  setScrollTop(newScrollTop, scrollType = 1) {
    if (!this._modelData) {
      return;
    }
    if (typeof newScrollTop !== "number") {
      throw new Error("Invalid arguments");
    }
    this._modelData.viewModel.setScrollPosition({
      scrollTop: newScrollTop
    }, scrollType);
  }
  setScrollPosition(position, scrollType = 1) {
    if (!this._modelData) {
      return;
    }
    this._modelData.viewModel.setScrollPosition(position, scrollType);
  }
  saveViewState() {
    if (!this._modelData) {
      return null;
    }
    const contributionsState = {};
    const keys = Object.keys(this._contributions);
    for (const id of keys) {
      const contribution = this._contributions[id];
      if (typeof contribution.saveViewState === "function") {
        contributionsState[id] = contribution.saveViewState();
      }
    }
    const cursorState = this._modelData.viewModel.saveCursorState();
    const viewState = this._modelData.viewModel.saveState();
    return {
      cursorState,
      viewState,
      contributionsState
    };
  }
  restoreViewState(s) {
    if (!this._modelData || !this._modelData.hasRealView) {
      return;
    }
    const codeEditorState = s;
    if (codeEditorState && codeEditorState.cursorState && codeEditorState.viewState) {
      const cursorState = codeEditorState.cursorState;
      if (Array.isArray(cursorState)) {
        this._modelData.viewModel.restoreCursorState(cursorState);
      } else {
        this._modelData.viewModel.restoreCursorState([cursorState]);
      }
      const contributionsState = codeEditorState.contributionsState || {};
      const keys = Object.keys(this._contributions);
      for (let i = 0, len = keys.length; i < len; i++) {
        const id = keys[i];
        const contribution = this._contributions[id];
        if (typeof contribution.restoreViewState === "function") {
          contribution.restoreViewState(contributionsState[id]);
        }
      }
      const reducedState = this._modelData.viewModel.reduceRestoreState(codeEditorState.viewState);
      this._modelData.view.restoreState(reducedState);
    }
  }
  getContribution(id) {
    return this._contributions[id] || null;
  }
  getActions() {
    const result = [];
    const keys = Object.keys(this._actions);
    for (let i = 0, len = keys.length; i < len; i++) {
      const id = keys[i];
      result.push(this._actions[id]);
    }
    return result;
  }
  getSupportedActions() {
    let result = this.getActions();
    result = result.filter((action) => action.isSupported());
    return result;
  }
  getAction(id) {
    return this._actions[id] || null;
  }
  trigger(source, handlerId, payload) {
    payload = payload || {};
    switch (handlerId) {
      case "compositionStart":
        this._startComposition();
        return;
      case "compositionEnd":
        this._endComposition(source);
        return;
      case "type": {
        const args = payload;
        this._type(source, args.text || "");
        return;
      }
      case "replacePreviousChar": {
        const args = payload;
        this._replacePreviousChar(source, args.text || "", args.replaceCharCnt || 0);
        return;
      }
      case "paste": {
        const args = payload;
        this._paste(source, args.text || "", args.pasteOnNewLine || false, args.multicursorText || null, args.mode || null);
        return;
      }
      case "cut":
        this._cut(source);
        return;
    }
    const action = this.getAction(handlerId);
    if (action) {
      Promise.resolve(action.run()).then(void 0, onUnexpectedError);
      return;
    }
    if (!this._modelData) {
      return;
    }
    if (this._triggerEditorCommand(source, handlerId, payload)) {
      return;
    }
  }
  _startComposition() {
    if (!this._modelData) {
      return;
    }
    this._modelData.viewModel.startComposition();
    this._onDidCompositionStart.fire();
  }
  _endComposition(source) {
    if (!this._modelData) {
      return;
    }
    this._modelData.viewModel.endComposition(source);
    this._onDidCompositionEnd.fire();
  }
  _type(source, text) {
    if (!this._modelData || text.length === 0) {
      return;
    }
    if (source === "keyboard") {
      this._onWillType.fire(text);
    }
    this._modelData.viewModel.type(text, source);
    if (source === "keyboard") {
      this._onDidType.fire(text);
    }
  }
  _replacePreviousChar(source, text, replaceCharCnt) {
    if (!this._modelData) {
      return;
    }
    this._modelData.viewModel.replacePreviousChar(text, replaceCharCnt, source);
  }
  _paste(source, text, pasteOnNewLine, multicursorText, mode) {
    if (!this._modelData || text.length === 0) {
      return;
    }
    const startPosition = this._modelData.viewModel.getSelection().getStartPosition();
    this._modelData.viewModel.paste(text, pasteOnNewLine, multicursorText, source);
    const endPosition = this._modelData.viewModel.getSelection().getStartPosition();
    if (source === "keyboard") {
      this._onDidPaste.fire({
        range: new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column),
        mode
      });
    }
  }
  _cut(source) {
    if (!this._modelData) {
      return;
    }
    this._modelData.viewModel.cut(source);
  }
  _triggerEditorCommand(source, handlerId, payload) {
    const command = EditorExtensionsRegistry.getEditorCommand(handlerId);
    if (command) {
      payload = payload || {};
      payload.source = source;
      this._instantiationService.invokeFunction((accessor) => {
        Promise.resolve(command.runEditorCommand(accessor, this, payload)).then(void 0, onUnexpectedError);
      });
      return true;
    }
    return false;
  }
  _getViewModel() {
    if (!this._modelData) {
      return null;
    }
    return this._modelData.viewModel;
  }
  pushUndoStop() {
    if (!this._modelData) {
      return false;
    }
    if (this._configuration.options.get(72)) {
      return false;
    }
    this._modelData.model.pushStackElement();
    return true;
  }
  executeEdits(source, edits, endCursorState) {
    if (!this._modelData) {
      return false;
    }
    if (this._configuration.options.get(72)) {
      return false;
    }
    let cursorStateComputer;
    if (!endCursorState) {
      cursorStateComputer = () => null;
    } else if (Array.isArray(endCursorState)) {
      cursorStateComputer = () => endCursorState;
    } else {
      cursorStateComputer = endCursorState;
    }
    this._modelData.viewModel.executeEdits(source, edits, cursorStateComputer);
    return true;
  }
  executeCommand(source, command) {
    if (!this._modelData) {
      return;
    }
    this._modelData.viewModel.executeCommand(command, source);
  }
  executeCommands(source, commands) {
    if (!this._modelData) {
      return;
    }
    this._modelData.viewModel.executeCommands(commands, source);
  }
  changeDecorations(callback) {
    if (!this._modelData) {
      return null;
    }
    return this._modelData.model.changeDecorations(callback, this._id);
  }
  getLineDecorations(lineNumber) {
    if (!this._modelData) {
      return null;
    }
    return this._modelData.model.getLineDecorations(lineNumber, this._id, filterValidationDecorations(this._configuration.options));
  }
  deltaDecorations(oldDecorations, newDecorations) {
    if (!this._modelData) {
      return [];
    }
    if (oldDecorations.length === 0 && newDecorations.length === 0) {
      return oldDecorations;
    }
    return this._modelData.model.deltaDecorations(oldDecorations, newDecorations, this._id);
  }
  removeDecorations(decorationTypeKey) {
    const oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey];
    if (oldDecorationsIds) {
      this.deltaDecorations(oldDecorationsIds, []);
    }
    if (this._decorationTypeKeysToIds.hasOwnProperty(decorationTypeKey)) {
      delete this._decorationTypeKeysToIds[decorationTypeKey];
    }
    if (this._decorationTypeSubtypes.hasOwnProperty(decorationTypeKey)) {
      delete this._decorationTypeSubtypes[decorationTypeKey];
    }
  }
  getLayoutInfo() {
    const options = this._configuration.options;
    const layoutInfo = options.get(117);
    return layoutInfo;
  }
  createOverviewRuler(cssClassName) {
    if (!this._modelData || !this._modelData.hasRealView) {
      return null;
    }
    return this._modelData.view.createOverviewRuler(cssClassName);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getDomNode() {
    if (!this._modelData || !this._modelData.hasRealView) {
      return null;
    }
    return this._modelData.view.domNode.domNode;
  }
  delegateVerticalScrollbarMouseDown(browserEvent) {
    if (!this._modelData || !this._modelData.hasRealView) {
      return;
    }
    this._modelData.view.delegateVerticalScrollbarMouseDown(browserEvent);
  }
  layout(dimension) {
    this._configuration.observeReferenceElement(dimension);
    this.render();
  }
  focus() {
    if (!this._modelData || !this._modelData.hasRealView) {
      return;
    }
    this._modelData.view.focus();
  }
  hasTextFocus() {
    if (!this._modelData || !this._modelData.hasRealView) {
      return false;
    }
    return this._modelData.view.isFocused();
  }
  hasWidgetFocus() {
    return this._focusTracker && this._focusTracker.hasFocus();
  }
  addContentWidget(widget) {
    const widgetData = {
      widget,
      position: widget.getPosition()
    };
    if (this._contentWidgets.hasOwnProperty(widget.getId())) {
      console.warn("Overwriting a content widget with the same id.");
    }
    this._contentWidgets[widget.getId()] = widgetData;
    if (this._modelData && this._modelData.hasRealView) {
      this._modelData.view.addContentWidget(widgetData);
    }
  }
  layoutContentWidget(widget) {
    const widgetId = widget.getId();
    if (this._contentWidgets.hasOwnProperty(widgetId)) {
      const widgetData = this._contentWidgets[widgetId];
      widgetData.position = widget.getPosition();
      if (this._modelData && this._modelData.hasRealView) {
        this._modelData.view.layoutContentWidget(widgetData);
      }
    }
  }
  removeContentWidget(widget) {
    const widgetId = widget.getId();
    if (this._contentWidgets.hasOwnProperty(widgetId)) {
      const widgetData = this._contentWidgets[widgetId];
      delete this._contentWidgets[widgetId];
      if (this._modelData && this._modelData.hasRealView) {
        this._modelData.view.removeContentWidget(widgetData);
      }
    }
  }
  addOverlayWidget(widget) {
    const widgetData = {
      widget,
      position: widget.getPosition()
    };
    if (this._overlayWidgets.hasOwnProperty(widget.getId())) {
      console.warn("Overwriting an overlay widget with the same id.");
    }
    this._overlayWidgets[widget.getId()] = widgetData;
    if (this._modelData && this._modelData.hasRealView) {
      this._modelData.view.addOverlayWidget(widgetData);
    }
  }
  layoutOverlayWidget(widget) {
    const widgetId = widget.getId();
    if (this._overlayWidgets.hasOwnProperty(widgetId)) {
      const widgetData = this._overlayWidgets[widgetId];
      widgetData.position = widget.getPosition();
      if (this._modelData && this._modelData.hasRealView) {
        this._modelData.view.layoutOverlayWidget(widgetData);
      }
    }
  }
  removeOverlayWidget(widget) {
    const widgetId = widget.getId();
    if (this._overlayWidgets.hasOwnProperty(widgetId)) {
      const widgetData = this._overlayWidgets[widgetId];
      delete this._overlayWidgets[widgetId];
      if (this._modelData && this._modelData.hasRealView) {
        this._modelData.view.removeOverlayWidget(widgetData);
      }
    }
  }
  changeViewZones(callback) {
    if (!this._modelData || !this._modelData.hasRealView) {
      return;
    }
    this._modelData.view.change(callback);
  }
  getTargetAtClientPoint(clientX, clientY) {
    if (!this._modelData || !this._modelData.hasRealView) {
      return null;
    }
    return this._modelData.view.getTargetAtClientPoint(clientX, clientY);
  }
  getScrolledVisiblePosition(rawPosition) {
    if (!this._modelData || !this._modelData.hasRealView) {
      return null;
    }
    const position = this._modelData.model.validatePosition(rawPosition);
    const options = this._configuration.options;
    const layoutInfo = options.get(117);
    const top = CodeEditorWidget2._getVerticalOffsetForPosition(this._modelData, position.lineNumber, position.column) - this.getScrollTop();
    const left = this._modelData.view.getOffsetForColumn(position.lineNumber, position.column) + layoutInfo.glyphMarginWidth + layoutInfo.lineNumbersWidth + layoutInfo.decorationsWidth - this.getScrollLeft();
    return {
      top,
      left,
      height: options.get(51)
    };
  }
  getOffsetForColumn(lineNumber, column) {
    if (!this._modelData || !this._modelData.hasRealView) {
      return -1;
    }
    return this._modelData.view.getOffsetForColumn(lineNumber, column);
  }
  render(forceRedraw = false) {
    if (!this._modelData || !this._modelData.hasRealView) {
      return;
    }
    this._modelData.view.render(true, forceRedraw);
  }
  setAriaOptions(options) {
    if (!this._modelData || !this._modelData.hasRealView) {
      return;
    }
    this._modelData.view.setAriaOptions(options);
  }
  applyFontInfo(target) {
    Configuration2.applyFontInfoSlow(target, this._configuration.options.get(36));
  }
  _attachModel(model2) {
    if (!model2) {
      this._modelData = null;
      return;
    }
    const listenersToRemove = [];
    this._domElement.setAttribute("data-mode-id", model2.getLanguageIdentifier().language);
    this._configuration.setIsDominatedByLongLines(model2.isDominatedByLongLines());
    this._configuration.setMaxLineNumber(model2.getLineCount());
    model2.onBeforeAttached();
    const viewModel = new ViewModel(this._id, this._configuration, model2, DOMLineBreaksComputerFactory.create(), MonospaceLineBreaksComputerFactory.create(this._configuration.options), (callback) => scheduleAtNextAnimationFrame(callback));
    listenersToRemove.push(model2.onDidChangeDecorations((e) => this._onDidChangeModelDecorations.fire(e)));
    listenersToRemove.push(model2.onDidChangeLanguage((e) => {
      this._domElement.setAttribute("data-mode-id", model2.getLanguageIdentifier().language);
      this._onDidChangeModelLanguage.fire(e);
    }));
    listenersToRemove.push(model2.onDidChangeLanguageConfiguration((e) => this._onDidChangeModelLanguageConfiguration.fire(e)));
    listenersToRemove.push(model2.onDidChangeContent((e) => this._onDidChangeModelContent.fire(e)));
    listenersToRemove.push(model2.onDidChangeOptions((e) => this._onDidChangeModelOptions.fire(e)));
    listenersToRemove.push(model2.onWillDispose(() => this.setModel(null)));
    listenersToRemove.push(viewModel.onEvent((e) => {
      switch (e.kind) {
        case 0:
          this._onDidContentSizeChange.fire(e);
          break;
        case 1:
          this._editorTextFocus.setValue(e.hasFocus);
          break;
        case 2:
          this._onDidScrollChange.fire(e);
          break;
        case 3:
          this._onDidChangeViewZones.fire();
          break;
        case 4:
          this._onDidAttemptReadOnlyEdit.fire();
          break;
        case 5: {
          if (e.reachedMaxCursorCount) {
            this._notificationService.warn(localize("cursors.maximum", "The number of cursors has been limited to {0}.", Cursor.MAX_CURSOR_COUNT));
          }
          const positions = [];
          for (let i = 0, len = e.selections.length; i < len; i++) {
            positions[i] = e.selections[i].getPosition();
          }
          const e1 = {
            position: positions[0],
            secondaryPositions: positions.slice(1),
            reason: e.reason,
            source: e.source
          };
          this._onDidChangeCursorPosition.fire(e1);
          const e2 = {
            selection: e.selections[0],
            secondarySelections: e.selections.slice(1),
            modelVersionId: e.modelVersionId,
            oldSelections: e.oldSelections,
            oldModelVersionId: e.oldModelVersionId,
            source: e.source,
            reason: e.reason
          };
          this._onDidChangeCursorSelection.fire(e2);
          break;
        }
      }
    }));
    const [view, hasRealView] = this._createView(viewModel);
    if (hasRealView) {
      this._domElement.appendChild(view.domNode.domNode);
      let keys = Object.keys(this._contentWidgets);
      for (let i = 0, len = keys.length; i < len; i++) {
        const widgetId = keys[i];
        view.addContentWidget(this._contentWidgets[widgetId]);
      }
      keys = Object.keys(this._overlayWidgets);
      for (let i = 0, len = keys.length; i < len; i++) {
        const widgetId = keys[i];
        view.addOverlayWidget(this._overlayWidgets[widgetId]);
      }
      view.render(false, true);
      view.domNode.domNode.setAttribute("data-uri", model2.uri.toString());
    }
    this._modelData = new ModelData(model2, viewModel, view, hasRealView, listenersToRemove);
  }
  _createView(viewModel) {
    let commandDelegate;
    if (this.isSimpleWidget) {
      commandDelegate = {
        paste: (text, pasteOnNewLine, multicursorText, mode) => {
          this._paste("keyboard", text, pasteOnNewLine, multicursorText, mode);
        },
        type: (text) => {
          this._type("keyboard", text);
        },
        replacePreviousChar: (text, replaceCharCnt) => {
          this._replacePreviousChar("keyboard", text, replaceCharCnt);
        },
        startComposition: () => {
          this._startComposition();
        },
        endComposition: () => {
          this._endComposition("keyboard");
        },
        cut: () => {
          this._cut("keyboard");
        }
      };
    } else {
      commandDelegate = {
        paste: (text, pasteOnNewLine, multicursorText, mode) => {
          const payload = {text, pasteOnNewLine, multicursorText, mode};
          this._commandService.executeCommand("paste", payload);
        },
        type: (text) => {
          const payload = {text};
          this._commandService.executeCommand("type", payload);
        },
        replacePreviousChar: (text, replaceCharCnt) => {
          const payload = {text, replaceCharCnt};
          this._commandService.executeCommand("replacePreviousChar", payload);
        },
        startComposition: () => {
          this._commandService.executeCommand("compositionStart", {});
        },
        endComposition: () => {
          this._commandService.executeCommand("compositionEnd", {});
        },
        cut: () => {
          this._commandService.executeCommand("cut", {});
        }
      };
    }
    const viewUserInputEvents = new ViewUserInputEvents(viewModel.coordinatesConverter);
    viewUserInputEvents.onKeyDown = (e) => this._onKeyDown.fire(e);
    viewUserInputEvents.onKeyUp = (e) => this._onKeyUp.fire(e);
    viewUserInputEvents.onContextMenu = (e) => this._onContextMenu.fire(e);
    viewUserInputEvents.onMouseMove = (e) => this._onMouseMove.fire(e);
    viewUserInputEvents.onMouseLeave = (e) => this._onMouseLeave.fire(e);
    viewUserInputEvents.onMouseDown = (e) => this._onMouseDown.fire(e);
    viewUserInputEvents.onMouseUp = (e) => this._onMouseUp.fire(e);
    viewUserInputEvents.onMouseDrag = (e) => this._onMouseDrag.fire(e);
    viewUserInputEvents.onMouseDrop = (e) => this._onMouseDrop.fire(e);
    viewUserInputEvents.onMouseWheel = (e) => this._onMouseWheel.fire(e);
    const view = new View(commandDelegate, this._configuration, this._themeService, viewModel, viewUserInputEvents, this._overflowWidgetsDomNode);
    return [view, true];
  }
  _postDetachModelCleanup(detachedModel) {
    if (detachedModel) {
      detachedModel.removeAllDecorationsWithOwnerId(this._id);
    }
  }
  _detachModel() {
    if (!this._modelData) {
      return null;
    }
    const model2 = this._modelData.model;
    const removeDomNode = this._modelData.hasRealView ? this._modelData.view.domNode.domNode : null;
    this._modelData.dispose();
    this._modelData = null;
    this._domElement.removeAttribute("data-mode-id");
    if (removeDomNode && this._domElement.contains(removeDomNode)) {
      this._domElement.removeChild(removeDomNode);
    }
    return model2;
  }
  _removeDecorationType(key) {
    this._codeEditorService.removeDecorationType(key);
  }
  hasModel() {
    return this._modelData !== null;
  }
};
CodeEditorWidget = __decorate6([
  __param5(3, IInstantiationService),
  __param5(4, ICodeEditorService),
  __param5(5, ICommandService),
  __param5(6, IContextKeyService),
  __param5(7, IThemeService),
  __param5(8, INotificationService),
  __param5(9, IAccessibilityService)
], CodeEditorWidget);
var BooleanEventEmitter = class extends Disposable {
  constructor() {
    super();
    this._onDidChangeToTrue = this._register(new Emitter());
    this.onDidChangeToTrue = this._onDidChangeToTrue.event;
    this._onDidChangeToFalse = this._register(new Emitter());
    this.onDidChangeToFalse = this._onDidChangeToFalse.event;
    this._value = 0;
  }
  setValue(_value) {
    const value = _value ? 2 : 1;
    if (this._value === value) {
      return;
    }
    this._value = value;
    if (this._value === 2) {
      this._onDidChangeToTrue.fire();
    } else if (this._value === 1) {
      this._onDidChangeToFalse.fire();
    }
  }
};
var EditorContextKeysManager = class extends Disposable {
  constructor(editor2, contextKeyService) {
    super();
    this._editor = editor2;
    contextKeyService.createKey("editorId", editor2.getId());
    this._editorSimpleInput = EditorContextKeys.editorSimpleInput.bindTo(contextKeyService);
    this._editorFocus = EditorContextKeys.focus.bindTo(contextKeyService);
    this._textInputFocus = EditorContextKeys.textInputFocus.bindTo(contextKeyService);
    this._editorTextFocus = EditorContextKeys.editorTextFocus.bindTo(contextKeyService);
    this._editorTabMovesFocus = EditorContextKeys.tabMovesFocus.bindTo(contextKeyService);
    this._editorReadonly = EditorContextKeys.readOnly.bindTo(contextKeyService);
    this._editorColumnSelection = EditorContextKeys.columnSelection.bindTo(contextKeyService);
    this._hasMultipleSelections = EditorContextKeys.hasMultipleSelections.bindTo(contextKeyService);
    this._hasNonEmptySelection = EditorContextKeys.hasNonEmptySelection.bindTo(contextKeyService);
    this._canUndo = EditorContextKeys.canUndo.bindTo(contextKeyService);
    this._canRedo = EditorContextKeys.canRedo.bindTo(contextKeyService);
    this._register(this._editor.onDidChangeConfiguration(() => this._updateFromConfig()));
    this._register(this._editor.onDidChangeCursorSelection(() => this._updateFromSelection()));
    this._register(this._editor.onDidFocusEditorWidget(() => this._updateFromFocus()));
    this._register(this._editor.onDidBlurEditorWidget(() => this._updateFromFocus()));
    this._register(this._editor.onDidFocusEditorText(() => this._updateFromFocus()));
    this._register(this._editor.onDidBlurEditorText(() => this._updateFromFocus()));
    this._register(this._editor.onDidChangeModel(() => this._updateFromModel()));
    this._register(this._editor.onDidChangeConfiguration(() => this._updateFromModel()));
    this._updateFromConfig();
    this._updateFromSelection();
    this._updateFromFocus();
    this._updateFromModel();
    this._editorSimpleInput.set(this._editor.isSimpleWidget);
  }
  _updateFromConfig() {
    const options = this._editor.getOptions();
    this._editorTabMovesFocus.set(options.get(116));
    this._editorReadonly.set(options.get(72));
    this._editorColumnSelection.set(options.get(13));
  }
  _updateFromSelection() {
    const selections = this._editor.getSelections();
    if (!selections) {
      this._hasMultipleSelections.reset();
      this._hasNonEmptySelection.reset();
    } else {
      this._hasMultipleSelections.set(selections.length > 1);
      this._hasNonEmptySelection.set(selections.some((s) => !s.isEmpty()));
    }
  }
  _updateFromFocus() {
    this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget);
    this._editorTextFocus.set(this._editor.hasTextFocus() && !this._editor.isSimpleWidget);
    this._textInputFocus.set(this._editor.hasTextFocus());
  }
  _updateFromModel() {
    const model2 = this._editor.getModel();
    this._canUndo.set(Boolean(model2 && model2.canUndo()));
    this._canRedo.set(Boolean(model2 && model2.canRedo()));
  }
};
var EditorModeContext = class extends Disposable {
  constructor(_editor, _contextKeyService) {
    super();
    this._editor = _editor;
    this._contextKeyService = _contextKeyService;
    this._langId = EditorContextKeys.languageId.bindTo(_contextKeyService);
    this._hasCompletionItemProvider = EditorContextKeys.hasCompletionItemProvider.bindTo(_contextKeyService);
    this._hasCodeActionsProvider = EditorContextKeys.hasCodeActionsProvider.bindTo(_contextKeyService);
    this._hasCodeLensProvider = EditorContextKeys.hasCodeLensProvider.bindTo(_contextKeyService);
    this._hasDefinitionProvider = EditorContextKeys.hasDefinitionProvider.bindTo(_contextKeyService);
    this._hasDeclarationProvider = EditorContextKeys.hasDeclarationProvider.bindTo(_contextKeyService);
    this._hasImplementationProvider = EditorContextKeys.hasImplementationProvider.bindTo(_contextKeyService);
    this._hasTypeDefinitionProvider = EditorContextKeys.hasTypeDefinitionProvider.bindTo(_contextKeyService);
    this._hasHoverProvider = EditorContextKeys.hasHoverProvider.bindTo(_contextKeyService);
    this._hasDocumentHighlightProvider = EditorContextKeys.hasDocumentHighlightProvider.bindTo(_contextKeyService);
    this._hasDocumentSymbolProvider = EditorContextKeys.hasDocumentSymbolProvider.bindTo(_contextKeyService);
    this._hasReferenceProvider = EditorContextKeys.hasReferenceProvider.bindTo(_contextKeyService);
    this._hasRenameProvider = EditorContextKeys.hasRenameProvider.bindTo(_contextKeyService);
    this._hasSignatureHelpProvider = EditorContextKeys.hasSignatureHelpProvider.bindTo(_contextKeyService);
    this._hasDocumentFormattingProvider = EditorContextKeys.hasDocumentFormattingProvider.bindTo(_contextKeyService);
    this._hasDocumentSelectionFormattingProvider = EditorContextKeys.hasDocumentSelectionFormattingProvider.bindTo(_contextKeyService);
    this._hasMultipleDocumentFormattingProvider = EditorContextKeys.hasMultipleDocumentFormattingProvider.bindTo(_contextKeyService);
    this._hasMultipleDocumentSelectionFormattingProvider = EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider.bindTo(_contextKeyService);
    this._isInWalkThrough = EditorContextKeys.isInWalkThroughSnippet.bindTo(_contextKeyService);
    const update = () => this._update();
    this._register(_editor.onDidChangeModel(update));
    this._register(_editor.onDidChangeModelLanguage(update));
    this._register(CompletionProviderRegistry.onDidChange(update));
    this._register(CodeActionProviderRegistry.onDidChange(update));
    this._register(CodeLensProviderRegistry.onDidChange(update));
    this._register(DefinitionProviderRegistry.onDidChange(update));
    this._register(DeclarationProviderRegistry.onDidChange(update));
    this._register(ImplementationProviderRegistry.onDidChange(update));
    this._register(TypeDefinitionProviderRegistry.onDidChange(update));
    this._register(HoverProviderRegistry.onDidChange(update));
    this._register(DocumentHighlightProviderRegistry.onDidChange(update));
    this._register(DocumentSymbolProviderRegistry.onDidChange(update));
    this._register(ReferenceProviderRegistry.onDidChange(update));
    this._register(RenameProviderRegistry.onDidChange(update));
    this._register(DocumentFormattingEditProviderRegistry.onDidChange(update));
    this._register(DocumentRangeFormattingEditProviderRegistry.onDidChange(update));
    this._register(SignatureHelpProviderRegistry.onDidChange(update));
    update();
  }
  dispose() {
    super.dispose();
  }
  reset() {
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.reset();
      this._hasCompletionItemProvider.reset();
      this._hasCodeActionsProvider.reset();
      this._hasCodeLensProvider.reset();
      this._hasDefinitionProvider.reset();
      this._hasDeclarationProvider.reset();
      this._hasImplementationProvider.reset();
      this._hasTypeDefinitionProvider.reset();
      this._hasHoverProvider.reset();
      this._hasDocumentHighlightProvider.reset();
      this._hasDocumentSymbolProvider.reset();
      this._hasReferenceProvider.reset();
      this._hasRenameProvider.reset();
      this._hasDocumentFormattingProvider.reset();
      this._hasDocumentSelectionFormattingProvider.reset();
      this._hasSignatureHelpProvider.reset();
      this._isInWalkThrough.reset();
    });
  }
  _update() {
    const model2 = this._editor.getModel();
    if (!model2) {
      this.reset();
      return;
    }
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.set(model2.getLanguageIdentifier().language);
      this._hasCompletionItemProvider.set(CompletionProviderRegistry.has(model2));
      this._hasCodeActionsProvider.set(CodeActionProviderRegistry.has(model2));
      this._hasCodeLensProvider.set(CodeLensProviderRegistry.has(model2));
      this._hasDefinitionProvider.set(DefinitionProviderRegistry.has(model2));
      this._hasDeclarationProvider.set(DeclarationProviderRegistry.has(model2));
      this._hasImplementationProvider.set(ImplementationProviderRegistry.has(model2));
      this._hasTypeDefinitionProvider.set(TypeDefinitionProviderRegistry.has(model2));
      this._hasHoverProvider.set(HoverProviderRegistry.has(model2));
      this._hasDocumentHighlightProvider.set(DocumentHighlightProviderRegistry.has(model2));
      this._hasDocumentSymbolProvider.set(DocumentSymbolProviderRegistry.has(model2));
      this._hasReferenceProvider.set(ReferenceProviderRegistry.has(model2));
      this._hasRenameProvider.set(RenameProviderRegistry.has(model2));
      this._hasSignatureHelpProvider.set(SignatureHelpProviderRegistry.has(model2));
      this._hasDocumentFormattingProvider.set(DocumentFormattingEditProviderRegistry.has(model2) || DocumentRangeFormattingEditProviderRegistry.has(model2));
      this._hasDocumentSelectionFormattingProvider.set(DocumentRangeFormattingEditProviderRegistry.has(model2));
      this._hasMultipleDocumentFormattingProvider.set(DocumentFormattingEditProviderRegistry.all(model2).length + DocumentRangeFormattingEditProviderRegistry.all(model2).length > 1);
      this._hasMultipleDocumentSelectionFormattingProvider.set(DocumentRangeFormattingEditProviderRegistry.all(model2).length > 1);
      this._isInWalkThrough.set(model2.uri.scheme === Schemas.walkThroughSnippet);
    });
  }
};
var CodeEditorWidgetFocusTracker = class extends Disposable {
  constructor(domElement) {
    super();
    this._onChange = this._register(new Emitter());
    this.onChange = this._onChange.event;
    this._hasFocus = false;
    this._domFocusTracker = this._register(trackFocus(domElement));
    this._register(this._domFocusTracker.onDidFocus(() => {
      this._hasFocus = true;
      this._onChange.fire(void 0);
    }));
    this._register(this._domFocusTracker.onDidBlur(() => {
      this._hasFocus = false;
      this._onChange.fire(void 0);
    }));
  }
  hasFocus() {
    return this._hasFocus;
  }
};
var squigglyStart = encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='`);
var squigglyEnd = encodeURIComponent(`'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>`);
function getSquigglySVGData(color) {
  return squigglyStart + encodeURIComponent(color.toString()) + squigglyEnd;
}
var dotdotdotStart = encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" height="3" width="12"><g fill="`);
var dotdotdotEnd = encodeURIComponent(`"><circle cx="1" cy="1" r="1"/><circle cx="5" cy="1" r="1"/><circle cx="9" cy="1" r="1"/></g></svg>`);
function getDotDotDotSVGData(color) {
  return dotdotdotStart + encodeURIComponent(color.toString()) + dotdotdotEnd;
}
registerThemingParticipant((theme, collector) => {
  const errorBorderColor = theme.getColor(editorErrorBorder);
  if (errorBorderColor) {
    collector.addRule(`.monaco-editor .${"squiggly-error"} { border-bottom: 4px double ${errorBorderColor}; }`);
  }
  const errorForeground2 = theme.getColor(editorErrorForeground);
  if (errorForeground2) {
    collector.addRule(`.monaco-editor .${"squiggly-error"} { background: url("data:image/svg+xml,${getSquigglySVGData(errorForeground2)}") repeat-x bottom left; }`);
  }
  const warningBorderColor = theme.getColor(editorWarningBorder);
  if (warningBorderColor) {
    collector.addRule(`.monaco-editor .${"squiggly-warning"} { border-bottom: 4px double ${warningBorderColor}; }`);
  }
  const warningForeground = theme.getColor(editorWarningForeground);
  if (warningForeground) {
    collector.addRule(`.monaco-editor .${"squiggly-warning"} { background: url("data:image/svg+xml,${getSquigglySVGData(warningForeground)}") repeat-x bottom left; }`);
  }
  const infoBorderColor = theme.getColor(editorInfoBorder);
  if (infoBorderColor) {
    collector.addRule(`.monaco-editor .${"squiggly-info"} { border-bottom: 4px double ${infoBorderColor}; }`);
  }
  const infoForeground = theme.getColor(editorInfoForeground);
  if (infoForeground) {
    collector.addRule(`.monaco-editor .${"squiggly-info"} { background: url("data:image/svg+xml,${getSquigglySVGData(infoForeground)}") repeat-x bottom left; }`);
  }
  const hintBorderColor = theme.getColor(editorHintBorder);
  if (hintBorderColor) {
    collector.addRule(`.monaco-editor .${"squiggly-hint"} { border-bottom: 2px dotted ${hintBorderColor}; }`);
  }
  const hintForeground = theme.getColor(editorHintForeground);
  if (hintForeground) {
    collector.addRule(`.monaco-editor .${"squiggly-hint"} { background: url("data:image/svg+xml,${getDotDotDotSVGData(hintForeground)}") no-repeat bottom left; }`);
  }
  const unnecessaryForeground = theme.getColor(editorUnnecessaryCodeOpacity);
  if (unnecessaryForeground) {
    collector.addRule(`.monaco-editor.showUnused .${"squiggly-inline-unnecessary"} { opacity: ${unnecessaryForeground.rgba.a}; }`);
  }
  const unnecessaryBorder = theme.getColor(editorUnnecessaryCodeBorder);
  if (unnecessaryBorder) {
    collector.addRule(`.monaco-editor.showUnused .${"squiggly-unnecessary"} { border-bottom: 2px dashed ${unnecessaryBorder}; }`);
  }
  const deprecatedForeground = theme.getColor(editorForeground) || "inherit";
  collector.addRule(`.monaco-editor.showDeprecated .${"squiggly-inline-deprecated"} { text-decoration: line-through; text-decoration-color: ${deprecatedForeground}}`);
});

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/sash/sash.js
var DEBUG = false;
var globalSize = 4;
var onDidChangeGlobalSize = new Emitter();
var Sash = class extends Disposable {
  constructor(container, layoutProvider, options) {
    super();
    this._state = 3;
    this._onDidEnablementChange = this._register(new Emitter());
    this.onDidEnablementChange = this._onDidEnablementChange.event;
    this._onDidStart = this._register(new Emitter());
    this.onDidStart = this._onDidStart.event;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._onDidReset = this._register(new Emitter());
    this.onDidReset = this._onDidReset.event;
    this._onDidEnd = this._register(new Emitter());
    this.onDidEnd = this._onDidEnd.event;
    this.linkedSash = void 0;
    this.orthogonalStartSashDisposables = this._register(new DisposableStore());
    this.orthogonalEndSashDisposables = this._register(new DisposableStore());
    this.el = append(container, $(".monaco-sash"));
    if (isMacintosh) {
      addClass(this.el, "mac");
    }
    this._register(domEvent(this.el, "mousedown")(this.onMouseDown, this));
    this._register(domEvent(this.el, "dblclick")(this.onMouseDoubleClick, this));
    this._register(Gesture.addTarget(this.el));
    this._register(domEvent(this.el, EventType2.Start)(this.onTouchStart, this));
    if (typeof options.size === "number") {
      this.size = options.size;
      if (options.orientation === 0) {
        this.el.style.width = `${this.size}px`;
      } else {
        this.el.style.height = `${this.size}px`;
      }
    } else {
      this.size = globalSize;
      this._register(onDidChangeGlobalSize.event((size) => {
        this.size = size;
        this.layout();
      }));
    }
    this.hidden = false;
    this.layoutProvider = layoutProvider;
    this.orthogonalStartSash = options.orthogonalStartSash;
    this.orthogonalEndSash = options.orthogonalEndSash;
    this.orientation = options.orientation || 0;
    if (this.orientation === 1) {
      addClass(this.el, "horizontal");
      removeClass(this.el, "vertical");
    } else {
      removeClass(this.el, "horizontal");
      addClass(this.el, "vertical");
    }
    toggleClass(this.el, "debug", DEBUG);
    this.layout();
  }
  get state() {
    return this._state;
  }
  set state(state) {
    if (this._state === state) {
      return;
    }
    toggleClass(this.el, "disabled", state === 0);
    toggleClass(this.el, "minimum", state === 1);
    toggleClass(this.el, "maximum", state === 2);
    this._state = state;
    this._onDidEnablementChange.fire(state);
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  set orthogonalStartSash(sash) {
    this.orthogonalStartSashDisposables.clear();
    if (sash) {
      this.orthogonalStartSashDisposables.add(sash.onDidEnablementChange(this.onOrthogonalStartSashEnablementChange, this));
      this.onOrthogonalStartSashEnablementChange(sash.state);
    } else {
      this.onOrthogonalStartSashEnablementChange(0);
    }
    this._orthogonalStartSash = sash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  set orthogonalEndSash(sash) {
    this.orthogonalEndSashDisposables.clear();
    if (sash) {
      this.orthogonalEndSashDisposables.add(sash.onDidEnablementChange(this.onOrthogonalEndSashEnablementChange, this));
      this.onOrthogonalEndSashEnablementChange(sash.state);
    } else {
      this.onOrthogonalEndSashEnablementChange(0);
    }
    this._orthogonalEndSash = sash;
  }
  onMouseDown(e) {
    EventHelper.stop(e, false);
    let isMultisashResize = false;
    if (!e.__orthogonalSashEvent) {
      const orthogonalSash = this.getOrthogonalSash(e);
      if (orthogonalSash) {
        isMultisashResize = true;
        e.__orthogonalSashEvent = true;
        orthogonalSash.onMouseDown(e);
      }
    }
    if (this.linkedSash && !e.__linkedSashEvent) {
      e.__linkedSashEvent = true;
      this.linkedSash.onMouseDown(e);
    }
    if (!this.state) {
      return;
    }
    const iframes = [
      ...getElementsByTagName("iframe"),
      ...getElementsByTagName("webview")
    ];
    for (const iframe of iframes) {
      iframe.style.pointerEvents = "none";
    }
    const mouseDownEvent = new StandardMouseEvent(e);
    const startX = mouseDownEvent.posx;
    const startY = mouseDownEvent.posy;
    const altKey = mouseDownEvent.altKey;
    const startEvent = {startX, currentX: startX, startY, currentY: startY, altKey};
    addClass(this.el, "active");
    this._onDidStart.fire(startEvent);
    const style = createStyleSheet(this.el);
    const updateStyle = () => {
      let cursor = "";
      if (isMultisashResize) {
        cursor = "all-scroll";
      } else if (this.orientation === 1) {
        if (this.state === 1) {
          cursor = "s-resize";
        } else if (this.state === 2) {
          cursor = "n-resize";
        } else {
          cursor = isMacintosh ? "row-resize" : "ns-resize";
        }
      } else {
        if (this.state === 1) {
          cursor = "e-resize";
        } else if (this.state === 2) {
          cursor = "w-resize";
        } else {
          cursor = isMacintosh ? "col-resize" : "ew-resize";
        }
      }
      style.innerHTML = `* { cursor: ${cursor} !important; }`;
    };
    const disposables = new DisposableStore();
    updateStyle();
    if (!isMultisashResize) {
      this.onDidEnablementChange(updateStyle, null, disposables);
    }
    const onMouseMove = (e2) => {
      EventHelper.stop(e2, false);
      const mouseMoveEvent = new StandardMouseEvent(e2);
      const event = {startX, currentX: mouseMoveEvent.posx, startY, currentY: mouseMoveEvent.posy, altKey};
      this._onDidChange.fire(event);
    };
    const onMouseUp = (e2) => {
      EventHelper.stop(e2, false);
      this.el.removeChild(style);
      removeClass(this.el, "active");
      this._onDidEnd.fire();
      disposables.dispose();
      for (const iframe of iframes) {
        iframe.style.pointerEvents = "auto";
      }
    };
    domEvent(window, "mousemove")(onMouseMove, null, disposables);
    domEvent(window, "mouseup")(onMouseUp, null, disposables);
  }
  onMouseDoubleClick(e) {
    const orthogonalSash = this.getOrthogonalSash(e);
    if (orthogonalSash) {
      orthogonalSash._onDidReset.fire();
    }
    if (this.linkedSash) {
      this.linkedSash._onDidReset.fire();
    }
    this._onDidReset.fire();
  }
  onTouchStart(event) {
    EventHelper.stop(event);
    const listeners = [];
    const startX = event.pageX;
    const startY = event.pageY;
    const altKey = event.altKey;
    this._onDidStart.fire({
      startX,
      currentX: startX,
      startY,
      currentY: startY,
      altKey
    });
    listeners.push(addDisposableListener(this.el, EventType2.Change, (event2) => {
      if (isNumber(event2.pageX) && isNumber(event2.pageY)) {
        this._onDidChange.fire({
          startX,
          currentX: event2.pageX,
          startY,
          currentY: event2.pageY,
          altKey
        });
      }
    }));
    listeners.push(addDisposableListener(this.el, EventType2.End, (event2) => {
      this._onDidEnd.fire();
      dispose(listeners);
    }));
  }
  layout() {
    if (this.orientation === 0) {
      const verticalProvider = this.layoutProvider;
      this.el.style.left = verticalProvider.getVerticalSashLeft(this) - this.size / 2 + "px";
      if (verticalProvider.getVerticalSashTop) {
        this.el.style.top = verticalProvider.getVerticalSashTop(this) + "px";
      }
      if (verticalProvider.getVerticalSashHeight) {
        this.el.style.height = verticalProvider.getVerticalSashHeight(this) + "px";
      }
    } else {
      const horizontalProvider = this.layoutProvider;
      this.el.style.top = horizontalProvider.getHorizontalSashTop(this) - this.size / 2 + "px";
      if (horizontalProvider.getHorizontalSashLeft) {
        this.el.style.left = horizontalProvider.getHorizontalSashLeft(this) + "px";
      }
      if (horizontalProvider.getHorizontalSashWidth) {
        this.el.style.width = horizontalProvider.getHorizontalSashWidth(this) + "px";
      }
    }
  }
  hide() {
    this.hidden = true;
    this.el.style.display = "none";
    this.el.setAttribute("aria-hidden", "true");
  }
  onOrthogonalStartSashEnablementChange(state) {
    toggleClass(this.el, "orthogonal-start", state !== 0);
  }
  onOrthogonalEndSashEnablementChange(state) {
    toggleClass(this.el, "orthogonal-end", state !== 0);
  }
  getOrthogonalSash(e) {
    if (this.orientation === 0) {
      if (e.offsetY <= this.size) {
        return this.orthogonalStartSash;
      } else if (e.offsetY >= this.el.clientHeight - this.size) {
        return this.orthogonalEndSash;
      }
    } else {
      if (e.offsetX <= this.size) {
        return this.orthogonalStartSash;
      } else if (e.offsetX >= this.el.clientWidth - this.size) {
        return this.orthogonalEndSash;
      }
    }
    return void 0;
  }
  dispose() {
    super.dispose();
    this.el.remove();
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js
var SyncDescriptor = class {
  constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {
    this.ctor = ctor;
    this.staticArguments = staticArguments;
    this.supportsDelayedInstantiation = supportsDelayedInstantiation;
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js
var _registry2 = [];
function registerSingleton(id, ctor, supportsDelayedInstantiation) {
  _registry2.push([id, new SyncDescriptor(ctor, [], supportsDelayedInstantiation)]);
}
function getSingletonServiceDescriptors() {
  return _registry2;
}

// ../../node_modules/monaco-editor/esm/vs/editor/browser/core/keybindingCancellation.js
var IEditorCancellationTokens = createDecorator("IEditorCancelService");
var ctxCancellableOperation = new RawContextKey("cancellableOperation", false);
registerSingleton(IEditorCancellationTokens, class {
  constructor() {
    this._tokens = new WeakMap();
  }
  add(editor2, cts) {
    let data = this._tokens.get(editor2);
    if (!data) {
      data = editor2.invokeWithinContext((accessor) => {
        const key = ctxCancellableOperation.bindTo(accessor.get(IContextKeyService));
        const tokens = new LinkedList();
        return {key, tokens};
      });
      this._tokens.set(editor2, data);
    }
    let removeFn;
    data.key.set(true);
    removeFn = data.tokens.push(cts);
    return () => {
      if (removeFn) {
        removeFn();
        data.key.set(!data.tokens.isEmpty());
        removeFn = void 0;
      }
    };
  }
  cancel(editor2) {
    const data = this._tokens.get(editor2);
    if (!data) {
      return;
    }
    const cts = data.tokens.pop();
    if (cts) {
      cts.cancel();
      data.key.set(!data.tokens.isEmpty());
    }
  }
}, true);
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: "editor.cancelOperation",
      kbOpts: {
        weight: 100,
        primary: 9
      },
      precondition: ctxCancellableOperation
    });
  }
  runEditorCommand(accessor, editor2) {
    accessor.get(IEditorCancellationTokens).cancel(editor2);
  }
}());

// ../../node_modules/monaco-editor/esm/vs/editor/browser/core/editorState.js
var StableEditorScrollState = class {
  constructor(_visiblePosition, _visiblePositionScrollDelta, _cursorPosition) {
    this._visiblePosition = _visiblePosition;
    this._visiblePositionScrollDelta = _visiblePositionScrollDelta;
    this._cursorPosition = _cursorPosition;
  }
  static capture(editor2) {
    let visiblePosition = null;
    let visiblePositionScrollDelta = 0;
    if (editor2.getScrollTop() !== 0) {
      const visibleRanges = editor2.getVisibleRanges();
      if (visibleRanges.length > 0) {
        visiblePosition = visibleRanges[0].getStartPosition();
        const visiblePositionScrollTop = editor2.getTopForPosition(visiblePosition.lineNumber, visiblePosition.column);
        visiblePositionScrollDelta = editor2.getScrollTop() - visiblePositionScrollTop;
      }
    }
    return new StableEditorScrollState(visiblePosition, visiblePositionScrollDelta, editor2.getPosition());
  }
  restore(editor2) {
    if (this._visiblePosition) {
      const visiblePositionScrollTop = editor2.getTopForPosition(this._visiblePosition.lineNumber, this._visiblePosition.column);
      editor2.setScrollTop(visiblePositionScrollTop + this._visiblePositionScrollDelta);
    }
  }
  restoreRelativeVerticalPositionOfCursor(editor2) {
    const currentCursorPosition = editor2.getPosition();
    if (!this._cursorPosition || !currentCursorPosition) {
      return;
    }
    const offset = editor2.getTopForLineNumber(currentCursorPosition.lineNumber) - editor2.getTopForLineNumber(this._cursorPosition.lineNumber);
    editor2.setScrollTop(editor2.getScrollTop() + offset);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/dnd.js
var DataTransfers = {
  RESOURCES: "ResourceURLs",
  DOWNLOAD_URL: "DownloadURL",
  FILES: "Files",
  TEXT: "text/plain"
};
var DragAndDropData = class {
  constructor(data) {
    this.data = data;
  }
  update() {
  }
  getData() {
    return this.data;
  }
};
var StaticDND = {
  CurrentDragAndDropData: void 0
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionViewItems.js
var BaseActionViewItem = class extends Disposable {
  constructor(context, action, options = {}) {
    super();
    this.options = options;
    this._context = context || this;
    this._action = action;
    if (action instanceof Action) {
      this._register(action.onDidChange((event) => {
        if (!this.element) {
          return;
        }
        this.handleActionChangeEvent(event);
      }));
    }
  }
  handleActionChangeEvent(event) {
    if (event.enabled !== void 0) {
      this.updateEnabled();
    }
    if (event.checked !== void 0) {
      this.updateChecked();
    }
    if (event.class !== void 0) {
      this.updateClass();
    }
    if (event.label !== void 0) {
      this.updateLabel();
      this.updateTooltip();
    }
    if (event.tooltip !== void 0) {
      this.updateTooltip();
    }
  }
  get actionRunner() {
    if (!this._actionRunner) {
      this._actionRunner = this._register(new ActionRunner());
    }
    return this._actionRunner;
  }
  set actionRunner(actionRunner) {
    this._actionRunner = actionRunner;
  }
  getAction() {
    return this._action;
  }
  isEnabled() {
    return this._action.enabled;
  }
  setActionContext(newContext) {
    this._context = newContext;
  }
  render(container) {
    const element = this.element = container;
    this._register(Gesture.addTarget(container));
    const enableDragging = this.options && this.options.draggable;
    if (enableDragging) {
      container.draggable = true;
      if (isFirefox) {
        this._register(addDisposableListener(container, EventType.DRAG_START, (e) => {
          var _a;
          return (_a = e.dataTransfer) === null || _a === void 0 ? void 0 : _a.setData(DataTransfers.TEXT, this._action.label);
        }));
      }
    }
    this._register(addDisposableListener(element, EventType2.Tap, (e) => this.onClick(e)));
    this._register(addDisposableListener(element, EventType.MOUSE_DOWN, (e) => {
      if (!enableDragging) {
        EventHelper.stop(e, true);
      }
      if (this._action.enabled && e.button === 0) {
        addClass(element, "active");
      }
    }));
    if (isMacintosh) {
      this._register(addDisposableListener(element, EventType.CONTEXT_MENU, (e) => {
        if (e.button === 0 && e.ctrlKey === true) {
          this.onClick(e);
        }
      }));
    }
    this._register(addDisposableListener(element, EventType.CLICK, (e) => {
      EventHelper.stop(e, true);
      if (!(this.options && this.options.isMenu)) {
        setImmediate(() => this.onClick(e));
      }
    }));
    this._register(addDisposableListener(element, EventType.DBLCLICK, (e) => {
      EventHelper.stop(e, true);
    }));
    [EventType.MOUSE_UP, EventType.MOUSE_OUT].forEach((event) => {
      this._register(addDisposableListener(element, event, (e) => {
        EventHelper.stop(e);
        removeClass(element, "active");
      }));
    });
  }
  onClick(event) {
    var _a;
    EventHelper.stop(event, true);
    const context = isUndefinedOrNull(this._context) ? ((_a = this.options) === null || _a === void 0 ? void 0 : _a.useEventAsContext) ? event : void 0 : this._context;
    this.actionRunner.run(this._action, context);
  }
  focus() {
    if (this.element) {
      this.element.focus();
      addClass(this.element, "focused");
    }
  }
  blur() {
    if (this.element) {
      this.element.blur();
      removeClass(this.element, "focused");
    }
  }
  updateEnabled() {
  }
  updateLabel() {
  }
  updateTooltip() {
  }
  updateClass() {
  }
  updateChecked() {
  }
  dispose() {
    if (this.element) {
      removeNode(this.element);
      this.element = void 0;
    }
    super.dispose();
  }
};
var ActionViewItem = class extends BaseActionViewItem {
  constructor(context, action, options = {}) {
    super(context, action, options);
    this.options = options;
    this.options.icon = options.icon !== void 0 ? options.icon : false;
    this.options.label = options.label !== void 0 ? options.label : true;
    this.cssClass = "";
  }
  render(container) {
    super.render(container);
    if (this.element) {
      this.label = append(this.element, $("a.action-label"));
    }
    if (this.label) {
      if (this._action.id === Separator.ID) {
        this.label.setAttribute("role", "presentation");
      } else {
        if (this.options.isMenu) {
          this.label.setAttribute("role", "menuitem");
        } else {
          this.label.setAttribute("role", "button");
        }
      }
    }
    if (this.options.label && this.options.keybinding && this.element) {
      append(this.element, $("span.keybinding")).textContent = this.options.keybinding;
    }
    this.updateClass();
    this.updateLabel();
    this.updateTooltip();
    this.updateEnabled();
    this.updateChecked();
  }
  focus() {
    super.focus();
    if (this.label) {
      this.label.focus();
    }
  }
  updateLabel() {
    if (this.options.label && this.label) {
      this.label.textContent = this.getAction().label;
    }
  }
  updateTooltip() {
    let title = null;
    if (this.getAction().tooltip) {
      title = this.getAction().tooltip;
    } else if (!this.options.label && this.getAction().label && this.options.icon) {
      title = this.getAction().label;
      if (this.options.keybinding) {
        title = localize({key: "titleLabel", comment: ["action title", "action keybinding"]}, "{0} ({1})", title, this.options.keybinding);
      }
    }
    if (title && this.label) {
      this.label.title = title;
    }
  }
  updateClass() {
    if (this.cssClass && this.label) {
      removeClasses(this.label, this.cssClass);
    }
    if (this.options.icon) {
      this.cssClass = this.getAction().class;
      if (this.label) {
        addClass(this.label, "codicon");
        if (this.cssClass) {
          addClasses(this.label, this.cssClass);
        }
      }
      this.updateEnabled();
    } else {
      if (this.label) {
        removeClass(this.label, "codicon");
      }
    }
  }
  updateEnabled() {
    if (this.getAction().enabled) {
      if (this.label) {
        this.label.removeAttribute("aria-disabled");
        removeClass(this.label, "disabled");
        this.label.tabIndex = 0;
      }
      if (this.element) {
        removeClass(this.element, "disabled");
      }
    } else {
      if (this.label) {
        this.label.setAttribute("aria-disabled", "true");
        addClass(this.label, "disabled");
        removeTabIndexAndUpdateFocus(this.label);
      }
      if (this.element) {
        addClass(this.element, "disabled");
      }
    }
  }
  updateChecked() {
    if (this.label) {
      if (this.getAction().checked) {
        addClass(this.label, "checked");
      } else {
        removeClass(this.label, "checked");
      }
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js
var ActionBar = class extends Disposable {
  constructor(container, options = {}) {
    var _a, _b, _c;
    super();
    this._onDidBlur = this._register(new Emitter());
    this.onDidBlur = this._onDidBlur.event;
    this._onDidCancel = this._register(new Emitter());
    this.onDidCancel = this._onDidCancel.event;
    this._onDidRun = this._register(new Emitter());
    this.onDidRun = this._onDidRun.event;
    this._onDidBeforeRun = this._register(new Emitter());
    this.onDidBeforeRun = this._onDidBeforeRun.event;
    this.options = options;
    this._context = (_a = options.context) !== null && _a !== void 0 ? _a : null;
    this._orientation = (_b = this.options.orientation) !== null && _b !== void 0 ? _b : 0;
    this._triggerKeys = (_c = this.options.triggerKeys) !== null && _c !== void 0 ? _c : {
      keys: [3, 10],
      keyDown: false
    };
    if (this.options.actionRunner) {
      this._actionRunner = this.options.actionRunner;
    } else {
      this._actionRunner = new ActionRunner();
      this._register(this._actionRunner);
    }
    this._register(this._actionRunner.onDidRun((e) => this._onDidRun.fire(e)));
    this._register(this._actionRunner.onDidBeforeRun((e) => this._onDidBeforeRun.fire(e)));
    this.viewItems = [];
    this.focusedItem = void 0;
    this.domNode = document.createElement("div");
    this.domNode.className = "monaco-action-bar";
    if (options.animated !== false) {
      addClass(this.domNode, "animated");
    }
    let previousKey;
    let nextKey;
    switch (this._orientation) {
      case 0:
        previousKey = 15;
        nextKey = 17;
        break;
      case 1:
        previousKey = 17;
        nextKey = 15;
        this.domNode.className += " reverse";
        break;
      case 2:
        previousKey = 16;
        nextKey = 18;
        this.domNode.className += " vertical";
        break;
      case 3:
        previousKey = 18;
        nextKey = 16;
        this.domNode.className += " vertical reverse";
        break;
    }
    this._register(addDisposableListener(this.domNode, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      let eventHandled = true;
      if (event.equals(previousKey)) {
        eventHandled = this.focusPrevious();
      } else if (event.equals(nextKey)) {
        eventHandled = this.focusNext();
      } else if (event.equals(9)) {
        this._onDidCancel.fire();
      } else if (this.isTriggerKeyEvent(event)) {
        if (this._triggerKeys.keyDown) {
          this.doTrigger(event);
        }
      } else {
        eventHandled = false;
      }
      if (eventHandled) {
        event.preventDefault();
        event.stopPropagation();
      }
    }));
    this._register(addDisposableListener(this.domNode, EventType.KEY_UP, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (this.isTriggerKeyEvent(event)) {
        if (!this._triggerKeys.keyDown) {
          this.doTrigger(event);
        }
        event.preventDefault();
        event.stopPropagation();
      } else if (event.equals(2) || event.equals(1024 | 2)) {
        this.updateFocusedItem();
      }
    }));
    this.focusTracker = this._register(trackFocus(this.domNode));
    this._register(this.focusTracker.onDidBlur(() => {
      if (getActiveElement() === this.domNode || !isAncestor(getActiveElement(), this.domNode)) {
        this._onDidBlur.fire();
        this.focusedItem = void 0;
      }
    }));
    this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem()));
    this.actionsList = document.createElement("ul");
    this.actionsList.className = "actions-container";
    this.actionsList.setAttribute("role", "toolbar");
    if (this.options.ariaLabel) {
      this.actionsList.setAttribute("aria-label", this.options.ariaLabel);
    }
    this.domNode.appendChild(this.actionsList);
    container.appendChild(this.domNode);
  }
  isTriggerKeyEvent(event) {
    let ret = false;
    this._triggerKeys.keys.forEach((keyCode) => {
      ret = ret || event.equals(keyCode);
    });
    return ret;
  }
  updateFocusedItem() {
    for (let i = 0; i < this.actionsList.children.length; i++) {
      const elem = this.actionsList.children[i];
      if (isAncestor(getActiveElement(), elem)) {
        this.focusedItem = i;
        break;
      }
    }
  }
  get context() {
    return this._context;
  }
  set context(context) {
    this._context = context;
    this.viewItems.forEach((i) => i.setActionContext(context));
  }
  get actionRunner() {
    return this._actionRunner;
  }
  set actionRunner(actionRunner) {
    if (actionRunner) {
      this._actionRunner = actionRunner;
      this.viewItems.forEach((item) => item.actionRunner = actionRunner);
    }
  }
  getContainer() {
    return this.domNode;
  }
  push(arg, options = {}) {
    const actions = Array.isArray(arg) ? arg : [arg];
    let index = isNumber(options.index) ? options.index : null;
    actions.forEach((action) => {
      const actionViewItemElement = document.createElement("li");
      actionViewItemElement.className = "action-item";
      actionViewItemElement.setAttribute("role", "presentation");
      if (!this.options.allowContextMenu) {
        this._register(addDisposableListener(actionViewItemElement, EventType.CONTEXT_MENU, (e) => {
          EventHelper.stop(e, true);
        }));
      }
      let item;
      if (this.options.actionViewItemProvider) {
        item = this.options.actionViewItemProvider(action);
      }
      if (!item) {
        item = new ActionViewItem(this.context, action, options);
      }
      item.actionRunner = this._actionRunner;
      item.setActionContext(this.context);
      item.render(actionViewItemElement);
      if (index === null || index < 0 || index >= this.actionsList.children.length) {
        this.actionsList.appendChild(actionViewItemElement);
        this.viewItems.push(item);
      } else {
        this.actionsList.insertBefore(actionViewItemElement, this.actionsList.children[index]);
        this.viewItems.splice(index, 0, item);
        index++;
      }
    });
    if (this.focusedItem) {
      this.focus(this.focusedItem);
    }
  }
  clear() {
    dispose(this.viewItems);
    this.viewItems = [];
    clearNode(this.actionsList);
  }
  focus(arg) {
    let selectFirst = false;
    let index = void 0;
    if (arg === void 0) {
      selectFirst = true;
    } else if (typeof arg === "number") {
      index = arg;
    } else if (typeof arg === "boolean") {
      selectFirst = arg;
    }
    if (selectFirst && typeof this.focusedItem === "undefined") {
      this.focusedItem = -1;
      this.focusNext();
    } else {
      if (index !== void 0) {
        this.focusedItem = index;
      }
      this.updateFocus();
    }
  }
  focusNext() {
    if (typeof this.focusedItem === "undefined") {
      this.focusedItem = this.viewItems.length - 1;
    }
    const startIndex = this.focusedItem;
    let item;
    do {
      if (this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length) {
        this.focusedItem = startIndex;
        return false;
      }
      this.focusedItem = (this.focusedItem + 1) % this.viewItems.length;
      item = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== startIndex && !item.isEnabled());
    if (this.focusedItem === startIndex && !item.isEnabled()) {
      this.focusedItem = void 0;
    }
    this.updateFocus();
    return true;
  }
  focusPrevious() {
    if (typeof this.focusedItem === "undefined") {
      this.focusedItem = 0;
    }
    const startIndex = this.focusedItem;
    let item;
    do {
      this.focusedItem = this.focusedItem - 1;
      if (this.focusedItem < 0) {
        if (this.options.preventLoopNavigation) {
          this.focusedItem = startIndex;
          return false;
        }
        this.focusedItem = this.viewItems.length - 1;
      }
      item = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== startIndex && !item.isEnabled());
    if (this.focusedItem === startIndex && !item.isEnabled()) {
      this.focusedItem = void 0;
    }
    this.updateFocus(true);
    return true;
  }
  updateFocus(fromRight, preventScroll) {
    if (typeof this.focusedItem === "undefined") {
      this.actionsList.focus({preventScroll});
    }
    for (let i = 0; i < this.viewItems.length; i++) {
      const item = this.viewItems[i];
      const actionViewItem = item;
      if (i === this.focusedItem) {
        if (isFunction(actionViewItem.isEnabled)) {
          if (actionViewItem.isEnabled() && isFunction(actionViewItem.focus)) {
            actionViewItem.focus(fromRight);
          } else {
            this.actionsList.focus({preventScroll});
          }
        }
      } else {
        if (isFunction(actionViewItem.blur)) {
          actionViewItem.blur();
        }
      }
    }
  }
  doTrigger(event) {
    if (typeof this.focusedItem === "undefined") {
      return;
    }
    const actionViewItem = this.viewItems[this.focusedItem];
    if (actionViewItem instanceof BaseActionViewItem) {
      const context = actionViewItem._context === null || actionViewItem._context === void 0 ? event : actionViewItem._context;
      this.run(actionViewItem._action, context);
    }
  }
  run(action, context) {
    return this._actionRunner.run(action, context);
  }
  dispose() {
    dispose(this.viewItems);
    this.viewItems = [];
    removeNode(this.getContainer());
    super.dispose();
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/widget/diffReview.js
var DIFF_LINES_PADDING = 3;
var DiffEntry = class {
  constructor(originalLineStart, originalLineEnd, modifiedLineStart, modifiedLineEnd) {
    this.originalLineStart = originalLineStart;
    this.originalLineEnd = originalLineEnd;
    this.modifiedLineStart = modifiedLineStart;
    this.modifiedLineEnd = modifiedLineEnd;
  }
  getType() {
    if (this.originalLineStart === 0) {
      return 1;
    }
    if (this.modifiedLineStart === 0) {
      return 2;
    }
    return 0;
  }
};
var Diff = class {
  constructor(entries) {
    this.entries = entries;
  }
};
var diffReviewInsertIcon = registerIcon("diff-review-insert", Codicon.add);
var diffReviewRemoveIcon = registerIcon("diff-review-remove", Codicon.remove);
var diffReviewCloseIcon = registerIcon("diff-review-close", Codicon.close);
var DiffReview = class extends Disposable {
  constructor(diffEditor) {
    super();
    this._width = 0;
    this._diffEditor = diffEditor;
    this._isVisible = false;
    this.shadow = createFastDomNode(document.createElement("div"));
    this.shadow.setClassName("diff-review-shadow");
    this.actionBarContainer = createFastDomNode(document.createElement("div"));
    this.actionBarContainer.setClassName("diff-review-actions");
    this._actionBar = this._register(new ActionBar(this.actionBarContainer.domNode));
    this._actionBar.push(new Action("diffreview.close", localize("label.close", "Close"), "close-diff-review " + diffReviewCloseIcon.classNames, true, () => {
      this.hide();
      return Promise.resolve(null);
    }), {label: false, icon: true});
    this.domNode = createFastDomNode(document.createElement("div"));
    this.domNode.setClassName("diff-review monaco-editor-background");
    this._content = createFastDomNode(document.createElement("div"));
    this._content.setClassName("diff-review-content");
    this._content.setAttribute("role", "code");
    this.scrollbar = this._register(new DomScrollableElement(this._content.domNode, {}));
    this.domNode.domNode.appendChild(this.scrollbar.getDomNode());
    this._register(diffEditor.onDidUpdateDiff(() => {
      if (!this._isVisible) {
        return;
      }
      this._diffs = this._compute();
      this._render();
    }));
    this._register(diffEditor.getModifiedEditor().onDidChangeCursorPosition(() => {
      if (!this._isVisible) {
        return;
      }
      this._render();
    }));
    this._register(addStandardDisposableListener(this.domNode.domNode, "click", (e) => {
      e.preventDefault();
      let row = findParentWithClass(e.target, "diff-review-row");
      if (row) {
        this._goToRow(row);
      }
    }));
    this._register(addStandardDisposableListener(this.domNode.domNode, "keydown", (e) => {
      if (e.equals(18) || e.equals(2048 | 18) || e.equals(512 | 18)) {
        e.preventDefault();
        this._goToRow(this._getNextRow());
      }
      if (e.equals(16) || e.equals(2048 | 16) || e.equals(512 | 16)) {
        e.preventDefault();
        this._goToRow(this._getPrevRow());
      }
      if (e.equals(9) || e.equals(2048 | 9) || e.equals(512 | 9) || e.equals(1024 | 9)) {
        e.preventDefault();
        this.hide();
      }
      if (e.equals(10) || e.equals(3)) {
        e.preventDefault();
        this.accept();
      }
    }));
    this._diffs = [];
    this._currentDiff = null;
  }
  prev() {
    let index = 0;
    if (!this._isVisible) {
      this._diffs = this._compute();
    }
    if (this._isVisible) {
      let currentIndex = -1;
      for (let i = 0, len = this._diffs.length; i < len; i++) {
        if (this._diffs[i] === this._currentDiff) {
          currentIndex = i;
          break;
        }
      }
      index = this._diffs.length + currentIndex - 1;
    } else {
      index = this._findDiffIndex(this._diffEditor.getPosition());
    }
    if (this._diffs.length === 0) {
      return;
    }
    index = index % this._diffs.length;
    const entries = this._diffs[index].entries;
    this._diffEditor.setPosition(new Position(entries[0].modifiedLineStart, 1));
    this._diffEditor.setSelection({startColumn: 1, startLineNumber: entries[0].modifiedLineStart, endColumn: 1073741824, endLineNumber: entries[entries.length - 1].modifiedLineEnd});
    this._isVisible = true;
    this._diffEditor.doLayout();
    this._render();
    this._goToRow(this._getNextRow());
  }
  next() {
    let index = 0;
    if (!this._isVisible) {
      this._diffs = this._compute();
    }
    if (this._isVisible) {
      let currentIndex = -1;
      for (let i = 0, len = this._diffs.length; i < len; i++) {
        if (this._diffs[i] === this._currentDiff) {
          currentIndex = i;
          break;
        }
      }
      index = currentIndex + 1;
    } else {
      index = this._findDiffIndex(this._diffEditor.getPosition());
    }
    if (this._diffs.length === 0) {
      return;
    }
    index = index % this._diffs.length;
    const entries = this._diffs[index].entries;
    this._diffEditor.setPosition(new Position(entries[0].modifiedLineStart, 1));
    this._diffEditor.setSelection({startColumn: 1, startLineNumber: entries[0].modifiedLineStart, endColumn: 1073741824, endLineNumber: entries[entries.length - 1].modifiedLineEnd});
    this._isVisible = true;
    this._diffEditor.doLayout();
    this._render();
    this._goToRow(this._getNextRow());
  }
  accept() {
    let jumpToLineNumber = -1;
    let current = this._getCurrentFocusedRow();
    if (current) {
      let lineNumber = parseInt(current.getAttribute("data-line"), 10);
      if (!isNaN(lineNumber)) {
        jumpToLineNumber = lineNumber;
      }
    }
    this.hide();
    if (jumpToLineNumber !== -1) {
      this._diffEditor.setPosition(new Position(jumpToLineNumber, 1));
      this._diffEditor.revealPosition(new Position(jumpToLineNumber, 1), 1);
    }
  }
  hide() {
    this._isVisible = false;
    this._diffEditor.updateOptions({readOnly: false});
    this._diffEditor.focus();
    this._diffEditor.doLayout();
    this._render();
  }
  _getPrevRow() {
    let current = this._getCurrentFocusedRow();
    if (!current) {
      return this._getFirstRow();
    }
    if (current.previousElementSibling) {
      return current.previousElementSibling;
    }
    return current;
  }
  _getNextRow() {
    let current = this._getCurrentFocusedRow();
    if (!current) {
      return this._getFirstRow();
    }
    if (current.nextElementSibling) {
      return current.nextElementSibling;
    }
    return current;
  }
  _getFirstRow() {
    return this.domNode.domNode.querySelector(".diff-review-row");
  }
  _getCurrentFocusedRow() {
    let result = document.activeElement;
    if (result && /diff-review-row/.test(result.className)) {
      return result;
    }
    return null;
  }
  _goToRow(row) {
    let prev = this._getCurrentFocusedRow();
    row.tabIndex = 0;
    row.focus();
    if (prev && prev !== row) {
      prev.tabIndex = -1;
    }
    this.scrollbar.scanDomNode();
  }
  isVisible() {
    return this._isVisible;
  }
  layout(top, width, height) {
    this._width = width;
    this.shadow.setTop(top - 6);
    this.shadow.setWidth(width);
    this.shadow.setHeight(this._isVisible ? 6 : 0);
    this.domNode.setTop(top);
    this.domNode.setWidth(width);
    this.domNode.setHeight(height);
    this._content.setHeight(height);
    this._content.setWidth(width);
    if (this._isVisible) {
      this.actionBarContainer.setAttribute("aria-hidden", "false");
      this.actionBarContainer.setDisplay("block");
    } else {
      this.actionBarContainer.setAttribute("aria-hidden", "true");
      this.actionBarContainer.setDisplay("none");
    }
  }
  _compute() {
    const lineChanges = this._diffEditor.getLineChanges();
    if (!lineChanges || lineChanges.length === 0) {
      return [];
    }
    const originalModel = this._diffEditor.getOriginalEditor().getModel();
    const modifiedModel = this._diffEditor.getModifiedEditor().getModel();
    if (!originalModel || !modifiedModel) {
      return [];
    }
    return DiffReview._mergeAdjacent(lineChanges, originalModel.getLineCount(), modifiedModel.getLineCount());
  }
  static _mergeAdjacent(lineChanges, originalLineCount, modifiedLineCount) {
    if (!lineChanges || lineChanges.length === 0) {
      return [];
    }
    let diffs = [], diffsLength = 0;
    for (let i = 0, len = lineChanges.length; i < len; i++) {
      const lineChange = lineChanges[i];
      const originalStart = lineChange.originalStartLineNumber;
      const originalEnd = lineChange.originalEndLineNumber;
      const modifiedStart = lineChange.modifiedStartLineNumber;
      const modifiedEnd = lineChange.modifiedEndLineNumber;
      let r2 = [], rLength2 = 0;
      {
        const originalEqualAbove = originalEnd === 0 ? originalStart : originalStart - 1;
        const modifiedEqualAbove = modifiedEnd === 0 ? modifiedStart : modifiedStart - 1;
        let minOriginal = 1;
        let minModified = 1;
        if (i > 0) {
          const prevLineChange = lineChanges[i - 1];
          if (prevLineChange.originalEndLineNumber === 0) {
            minOriginal = prevLineChange.originalStartLineNumber + 1;
          } else {
            minOriginal = prevLineChange.originalEndLineNumber + 1;
          }
          if (prevLineChange.modifiedEndLineNumber === 0) {
            minModified = prevLineChange.modifiedStartLineNumber + 1;
          } else {
            minModified = prevLineChange.modifiedEndLineNumber + 1;
          }
        }
        let fromOriginal = originalEqualAbove - DIFF_LINES_PADDING + 1;
        let fromModified = modifiedEqualAbove - DIFF_LINES_PADDING + 1;
        if (fromOriginal < minOriginal) {
          const delta = minOriginal - fromOriginal;
          fromOriginal = fromOriginal + delta;
          fromModified = fromModified + delta;
        }
        if (fromModified < minModified) {
          const delta = minModified - fromModified;
          fromOriginal = fromOriginal + delta;
          fromModified = fromModified + delta;
        }
        r2[rLength2++] = new DiffEntry(fromOriginal, originalEqualAbove, fromModified, modifiedEqualAbove);
      }
      {
        if (originalEnd !== 0) {
          r2[rLength2++] = new DiffEntry(originalStart, originalEnd, 0, 0);
        }
      }
      {
        if (modifiedEnd !== 0) {
          r2[rLength2++] = new DiffEntry(0, 0, modifiedStart, modifiedEnd);
        }
      }
      {
        const originalEqualBelow = originalEnd === 0 ? originalStart + 1 : originalEnd + 1;
        const modifiedEqualBelow = modifiedEnd === 0 ? modifiedStart + 1 : modifiedEnd + 1;
        let maxOriginal = originalLineCount;
        let maxModified = modifiedLineCount;
        if (i + 1 < len) {
          const nextLineChange = lineChanges[i + 1];
          if (nextLineChange.originalEndLineNumber === 0) {
            maxOriginal = nextLineChange.originalStartLineNumber;
          } else {
            maxOriginal = nextLineChange.originalStartLineNumber - 1;
          }
          if (nextLineChange.modifiedEndLineNumber === 0) {
            maxModified = nextLineChange.modifiedStartLineNumber;
          } else {
            maxModified = nextLineChange.modifiedStartLineNumber - 1;
          }
        }
        let toOriginal = originalEqualBelow + DIFF_LINES_PADDING - 1;
        let toModified = modifiedEqualBelow + DIFF_LINES_PADDING - 1;
        if (toOriginal > maxOriginal) {
          const delta = maxOriginal - toOriginal;
          toOriginal = toOriginal + delta;
          toModified = toModified + delta;
        }
        if (toModified > maxModified) {
          const delta = maxModified - toModified;
          toOriginal = toOriginal + delta;
          toModified = toModified + delta;
        }
        r2[rLength2++] = new DiffEntry(originalEqualBelow, toOriginal, modifiedEqualBelow, toModified);
      }
      diffs[diffsLength++] = new Diff(r2);
    }
    let curr = diffs[0].entries;
    let r = [], rLength = 0;
    for (let i = 1, len = diffs.length; i < len; i++) {
      const thisDiff = diffs[i].entries;
      const currLast = curr[curr.length - 1];
      const thisFirst = thisDiff[0];
      if (currLast.getType() === 0 && thisFirst.getType() === 0 && thisFirst.originalLineStart <= currLast.originalLineEnd) {
        curr[curr.length - 1] = new DiffEntry(currLast.originalLineStart, thisFirst.originalLineEnd, currLast.modifiedLineStart, thisFirst.modifiedLineEnd);
        curr = curr.concat(thisDiff.slice(1));
        continue;
      }
      r[rLength++] = new Diff(curr);
      curr = thisDiff;
    }
    r[rLength++] = new Diff(curr);
    return r;
  }
  _findDiffIndex(pos) {
    const lineNumber = pos.lineNumber;
    for (let i = 0, len = this._diffs.length; i < len; i++) {
      const diff = this._diffs[i].entries;
      const lastModifiedLine = diff[diff.length - 1].modifiedLineEnd;
      if (lineNumber <= lastModifiedLine) {
        return i;
      }
    }
    return 0;
  }
  _render() {
    const originalOptions = this._diffEditor.getOriginalEditor().getOptions();
    const modifiedOptions = this._diffEditor.getModifiedEditor().getOptions();
    const originalModel = this._diffEditor.getOriginalEditor().getModel();
    const modifiedModel = this._diffEditor.getModifiedEditor().getModel();
    const originalModelOpts = originalModel.getOptions();
    const modifiedModelOpts = modifiedModel.getOptions();
    if (!this._isVisible || !originalModel || !modifiedModel) {
      clearNode(this._content.domNode);
      this._currentDiff = null;
      this.scrollbar.scanDomNode();
      return;
    }
    this._diffEditor.updateOptions({readOnly: true});
    const diffIndex = this._findDiffIndex(this._diffEditor.getPosition());
    if (this._diffs[diffIndex] === this._currentDiff) {
      return;
    }
    this._currentDiff = this._diffs[diffIndex];
    const diffs = this._diffs[diffIndex].entries;
    let container = document.createElement("div");
    container.className = "diff-review-table";
    container.setAttribute("role", "list");
    container.setAttribute("aria-label", 'Difference review. Use "Stage | Unstage | Revert Selected Ranges" commands');
    Configuration2.applyFontInfoSlow(container, modifiedOptions.get(36));
    let minOriginalLine = 0;
    let maxOriginalLine = 0;
    let minModifiedLine = 0;
    let maxModifiedLine = 0;
    for (let i = 0, len = diffs.length; i < len; i++) {
      const diffEntry = diffs[i];
      const originalLineStart = diffEntry.originalLineStart;
      const originalLineEnd = diffEntry.originalLineEnd;
      const modifiedLineStart = diffEntry.modifiedLineStart;
      const modifiedLineEnd = diffEntry.modifiedLineEnd;
      if (originalLineStart !== 0 && (minOriginalLine === 0 || originalLineStart < minOriginalLine)) {
        minOriginalLine = originalLineStart;
      }
      if (originalLineEnd !== 0 && (maxOriginalLine === 0 || originalLineEnd > maxOriginalLine)) {
        maxOriginalLine = originalLineEnd;
      }
      if (modifiedLineStart !== 0 && (minModifiedLine === 0 || modifiedLineStart < minModifiedLine)) {
        minModifiedLine = modifiedLineStart;
      }
      if (modifiedLineEnd !== 0 && (maxModifiedLine === 0 || modifiedLineEnd > maxModifiedLine)) {
        maxModifiedLine = modifiedLineEnd;
      }
    }
    let header = document.createElement("div");
    header.className = "diff-review-row";
    let cell = document.createElement("div");
    cell.className = "diff-review-cell diff-review-summary";
    const originalChangedLinesCnt = maxOriginalLine - minOriginalLine + 1;
    const modifiedChangedLinesCnt = maxModifiedLine - minModifiedLine + 1;
    cell.appendChild(document.createTextNode(`${diffIndex + 1}/${this._diffs.length}: @@ -${minOriginalLine},${originalChangedLinesCnt} +${minModifiedLine},${modifiedChangedLinesCnt} @@`));
    header.setAttribute("data-line", String(minModifiedLine));
    const getAriaLines = (lines) => {
      if (lines === 0) {
        return localize("no_lines_changed", "no lines changed");
      } else if (lines === 1) {
        return localize("one_line_changed", "1 line changed");
      } else {
        return localize("more_lines_changed", "{0} lines changed", lines);
      }
    };
    const originalChangedLinesCntAria = getAriaLines(originalChangedLinesCnt);
    const modifiedChangedLinesCntAria = getAriaLines(modifiedChangedLinesCnt);
    header.setAttribute("aria-label", localize({
      key: "header",
      comment: [
        "This is the ARIA label for a git diff header.",
        "A git diff header looks like this: @@ -154,12 +159,39 @@.",
        "That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.",
        "Variables 0 and 1 refer to the diff index out of total number of diffs.",
        "Variables 2 and 4 will be numbers (a line number).",
        'Variables 3 and 5 will be "no lines changed", "1 line changed" or "X lines changed", localized separately.'
      ]
    }, "Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}", diffIndex + 1, this._diffs.length, minOriginalLine, originalChangedLinesCntAria, minModifiedLine, modifiedChangedLinesCntAria));
    header.appendChild(cell);
    header.setAttribute("role", "listitem");
    container.appendChild(header);
    const lineHeight = modifiedOptions.get(51);
    let modLine = minModifiedLine;
    for (let i = 0, len = diffs.length; i < len; i++) {
      const diffEntry = diffs[i];
      DiffReview._renderSection(container, diffEntry, modLine, lineHeight, this._width, originalOptions, originalModel, originalModelOpts, modifiedOptions, modifiedModel, modifiedModelOpts);
      if (diffEntry.modifiedLineStart !== 0) {
        modLine = diffEntry.modifiedLineEnd;
      }
    }
    clearNode(this._content.domNode);
    this._content.domNode.appendChild(container);
    this.scrollbar.scanDomNode();
  }
  static _renderSection(dest, diffEntry, modLine, lineHeight, width, originalOptions, originalModel, originalModelOpts, modifiedOptions, modifiedModel, modifiedModelOpts) {
    const type = diffEntry.getType();
    let rowClassName = "diff-review-row";
    let lineNumbersExtraClassName = "";
    const spacerClassName = "diff-review-spacer";
    let spacerIcon = null;
    switch (type) {
      case 1:
        rowClassName = "diff-review-row line-insert";
        lineNumbersExtraClassName = " char-insert";
        spacerIcon = diffReviewInsertIcon;
        break;
      case 2:
        rowClassName = "diff-review-row line-delete";
        lineNumbersExtraClassName = " char-delete";
        spacerIcon = diffReviewRemoveIcon;
        break;
    }
    const originalLineStart = diffEntry.originalLineStart;
    const originalLineEnd = diffEntry.originalLineEnd;
    const modifiedLineStart = diffEntry.modifiedLineStart;
    const modifiedLineEnd = diffEntry.modifiedLineEnd;
    const cnt = Math.max(modifiedLineEnd - modifiedLineStart, originalLineEnd - originalLineStart);
    const originalLayoutInfo = originalOptions.get(117);
    const originalLineNumbersWidth = originalLayoutInfo.glyphMarginWidth + originalLayoutInfo.lineNumbersWidth;
    const modifiedLayoutInfo = modifiedOptions.get(117);
    const modifiedLineNumbersWidth = 10 + modifiedLayoutInfo.glyphMarginWidth + modifiedLayoutInfo.lineNumbersWidth;
    for (let i = 0; i <= cnt; i++) {
      const originalLine = originalLineStart === 0 ? 0 : originalLineStart + i;
      const modifiedLine = modifiedLineStart === 0 ? 0 : modifiedLineStart + i;
      const row = document.createElement("div");
      row.style.minWidth = width + "px";
      row.className = rowClassName;
      row.setAttribute("role", "listitem");
      if (modifiedLine !== 0) {
        modLine = modifiedLine;
      }
      row.setAttribute("data-line", String(modLine));
      let cell = document.createElement("div");
      cell.className = "diff-review-cell";
      cell.style.height = `${lineHeight}px`;
      row.appendChild(cell);
      const originalLineNumber = document.createElement("span");
      originalLineNumber.style.width = originalLineNumbersWidth + "px";
      originalLineNumber.style.minWidth = originalLineNumbersWidth + "px";
      originalLineNumber.className = "diff-review-line-number" + lineNumbersExtraClassName;
      if (originalLine !== 0) {
        originalLineNumber.appendChild(document.createTextNode(String(originalLine)));
      } else {
        originalLineNumber.innerText = "\xA0";
      }
      cell.appendChild(originalLineNumber);
      const modifiedLineNumber = document.createElement("span");
      modifiedLineNumber.style.width = modifiedLineNumbersWidth + "px";
      modifiedLineNumber.style.minWidth = modifiedLineNumbersWidth + "px";
      modifiedLineNumber.style.paddingRight = "10px";
      modifiedLineNumber.className = "diff-review-line-number" + lineNumbersExtraClassName;
      if (modifiedLine !== 0) {
        modifiedLineNumber.appendChild(document.createTextNode(String(modifiedLine)));
      } else {
        modifiedLineNumber.innerText = "\xA0";
      }
      cell.appendChild(modifiedLineNumber);
      const spacer = document.createElement("span");
      spacer.className = spacerClassName;
      if (spacerIcon) {
        const spacerCodicon = document.createElement("span");
        spacerCodicon.className = spacerIcon.classNames;
        spacerCodicon.innerText = "\xA0\xA0";
        spacer.appendChild(spacerCodicon);
      } else {
        spacer.innerText = "\xA0\xA0";
      }
      cell.appendChild(spacer);
      let lineContent;
      if (modifiedLine !== 0) {
        cell.insertAdjacentHTML("beforeend", this._renderLine(modifiedModel, modifiedOptions, modifiedModelOpts.tabSize, modifiedLine));
        lineContent = modifiedModel.getLineContent(modifiedLine);
      } else {
        cell.insertAdjacentHTML("beforeend", this._renderLine(originalModel, originalOptions, originalModelOpts.tabSize, originalLine));
        lineContent = originalModel.getLineContent(originalLine);
      }
      if (lineContent.length === 0) {
        lineContent = localize("blankLine", "blank");
      }
      let ariaLabel = "";
      switch (type) {
        case 0:
          if (originalLine === modifiedLine) {
            ariaLabel = localize({key: "unchangedLine", comment: ["The placholders are contents of the line and should not be translated."]}, "{0} unchanged line {1}", lineContent, originalLine);
          } else {
            ariaLabel = localize("equalLine", "{0} original line {1} modified line {2}", lineContent, originalLine, modifiedLine);
          }
          break;
        case 1:
          ariaLabel = localize("insertLine", "+ {0} modified line {1}", lineContent, modifiedLine);
          break;
        case 2:
          ariaLabel = localize("deleteLine", "- {0} original line {1}", lineContent, originalLine);
          break;
      }
      row.setAttribute("aria-label", ariaLabel);
      dest.appendChild(row);
    }
  }
  static _renderLine(model2, options, tabSize, lineNumber) {
    const lineContent = model2.getLineContent(lineNumber);
    const fontInfo = options.get(36);
    const defaultMetadata = (0 << 11 | 1 << 14 | 2 << 23) >>> 0;
    const tokens = new Uint32Array(2);
    tokens[0] = lineContent.length;
    tokens[1] = defaultMetadata;
    const lineTokens = new LineTokens(tokens, lineContent);
    const isBasicASCII2 = ViewLineRenderingData.isBasicASCII(lineContent, model2.mightContainNonBasicASCII());
    const containsRTL2 = ViewLineRenderingData.containsRTL(lineContent, isBasicASCII2, model2.mightContainRTL());
    const r = renderViewLine2(new RenderLineInput(fontInfo.isMonospace && !options.get(24), fontInfo.canUseHalfwidthRightwardsArrow, lineContent, false, isBasicASCII2, containsRTL2, 0, lineTokens, [], tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, options.get(95), options.get(80), options.get(74), options.get(37) !== EditorFontLigatures.OFF, null));
    return r.html;
  }
};
registerThemingParticipant((theme, collector) => {
  const lineNumbers = theme.getColor(editorLineNumbers);
  if (lineNumbers) {
    collector.addRule(`.monaco-diff-editor .diff-review-line-number { color: ${lineNumbers}; }`);
  }
  const shadow = theme.getColor(scrollbarShadow);
  if (shadow) {
    collector.addRule(`.monaco-diff-editor .diff-review-shadow { box-shadow: ${shadow} 0 -6px 6px -6px inset; }`);
  }
});
var DiffReviewNext = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.diffReview.next",
      label: localize("editor.action.diffReview.next", "Go to Next Difference"),
      alias: "Go to Next Difference",
      precondition: ContextKeyExpr.has("isInDiffEditor"),
      kbOpts: {
        kbExpr: null,
        primary: 65,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    const diffEditor = findFocusedDiffEditor(accessor);
    if (diffEditor) {
      diffEditor.diffReviewNext();
    }
  }
};
var DiffReviewPrev = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.diffReview.prev",
      label: localize("editor.action.diffReview.prev", "Go to Previous Difference"),
      alias: "Go to Previous Difference",
      precondition: ContextKeyExpr.has("isInDiffEditor"),
      kbOpts: {
        kbExpr: null,
        primary: 1024 | 65,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    const diffEditor = findFocusedDiffEditor(accessor);
    if (diffEditor) {
      diffEditor.diffReviewPrev();
    }
  }
};
function findFocusedDiffEditor(accessor) {
  const codeEditorService = accessor.get(ICodeEditorService);
  const diffEditors = codeEditorService.listDiffEditors();
  const activeCodeEditor = codeEditorService.getActiveCodeEditor();
  if (!activeCodeEditor) {
    return null;
  }
  for (let i = 0, len = diffEditors.length; i < len; i++) {
    const diffEditor = diffEditors[i];
    if (diffEditor.getModifiedEditor().getId() === activeCodeEditor.getId() || diffEditor.getOriginalEditor().getId() === activeCodeEditor.getId()) {
      return diffEditor;
    }
  }
  return null;
}
registerEditorAction(DiffReviewNext);
registerEditorAction(DiffReviewPrev);

// ../../node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextView.js
var IContextViewService = createDecorator("contextViewService");
var IContextMenuService = createDecorator("contextMenuService");

// ../../node_modules/monaco-editor/esm/vs/editor/browser/widget/inlineDiffMargin.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var InlineDiffMargin = class extends Disposable {
  constructor(_viewZoneId, _marginDomNode, editor2, diff, _contextMenuService, _clipboardService) {
    super();
    this._viewZoneId = _viewZoneId;
    this._marginDomNode = _marginDomNode;
    this.editor = editor2;
    this.diff = diff;
    this._contextMenuService = _contextMenuService;
    this._clipboardService = _clipboardService;
    this._visibility = false;
    this._marginDomNode.style.zIndex = "10";
    this._diffActions = document.createElement("div");
    this._diffActions.className = Codicon.lightBulb.classNames + " lightbulb-glyph";
    this._diffActions.style.position = "absolute";
    const lineHeight = editor2.getOption(51);
    const lineFeed = editor2.getModel().getEOL();
    this._diffActions.style.right = "0px";
    this._diffActions.style.visibility = "hidden";
    this._diffActions.style.height = `${lineHeight}px`;
    this._diffActions.style.lineHeight = `${lineHeight}px`;
    this._marginDomNode.appendChild(this._diffActions);
    const actions = [];
    actions.push(new Action("diff.clipboard.copyDeletedContent", diff.originalEndLineNumber > diff.modifiedStartLineNumber ? localize("diff.clipboard.copyDeletedLinesContent.label", "Copy deleted lines") : localize("diff.clipboard.copyDeletedLinesContent.single.label", "Copy deleted line"), void 0, true, () => __awaiter7(this, void 0, void 0, function* () {
      yield this._clipboardService.writeText(diff.originalContent.join(lineFeed) + lineFeed);
    })));
    let currentLineNumberOffset = 0;
    let copyLineAction = void 0;
    if (diff.originalEndLineNumber > diff.modifiedStartLineNumber) {
      copyLineAction = new Action("diff.clipboard.copyDeletedLineContent", localize("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", diff.originalStartLineNumber), void 0, true, () => __awaiter7(this, void 0, void 0, function* () {
        yield this._clipboardService.writeText(diff.originalContent[currentLineNumberOffset]);
      }));
      actions.push(copyLineAction);
    }
    const readOnly = editor2.getOption(72);
    if (!readOnly) {
      actions.push(new Action("diff.inline.revertChange", localize("diff.inline.revertChange.label", "Revert this change"), void 0, true, () => __awaiter7(this, void 0, void 0, function* () {
        if (diff.modifiedEndLineNumber === 0) {
          const column = editor2.getModel().getLineMaxColumn(diff.modifiedStartLineNumber);
          editor2.executeEdits("diffEditor", [
            {
              range: new Range(diff.modifiedStartLineNumber, column, diff.modifiedStartLineNumber, column),
              text: lineFeed + diff.originalContent.join(lineFeed)
            }
          ]);
        } else {
          const column = editor2.getModel().getLineMaxColumn(diff.modifiedEndLineNumber);
          editor2.executeEdits("diffEditor", [
            {
              range: new Range(diff.modifiedStartLineNumber, 1, diff.modifiedEndLineNumber, column),
              text: diff.originalContent.join(lineFeed)
            }
          ]);
        }
      })));
    }
    const showContextMenu = (x, y) => {
      this._contextMenuService.showContextMenu({
        getAnchor: () => {
          return {
            x,
            y
          };
        },
        getActions: () => {
          if (copyLineAction) {
            copyLineAction.label = localize("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", diff.originalStartLineNumber + currentLineNumberOffset);
          }
          return actions;
        },
        autoSelectFirstItem: true
      });
    };
    this._register(addStandardDisposableListener(this._diffActions, "mousedown", (e) => {
      const {top, height} = getDomNodePagePosition(this._diffActions);
      let pad = Math.floor(lineHeight / 3);
      e.preventDefault();
      showContextMenu(e.posx, top + height + pad);
    }));
    this._register(editor2.onMouseMove((e) => {
      if (e.target.type === 8 || e.target.type === 5) {
        const viewZoneId = e.target.detail.viewZoneId;
        if (viewZoneId === this._viewZoneId) {
          this.visibility = true;
          currentLineNumberOffset = this._updateLightBulbPosition(this._marginDomNode, e.event.browserEvent.y, lineHeight);
        } else {
          this.visibility = false;
        }
      } else {
        this.visibility = false;
      }
    }));
    this._register(editor2.onMouseDown((e) => {
      if (!e.event.rightButton) {
        return;
      }
      if (e.target.type === 8 || e.target.type === 5) {
        const viewZoneId = e.target.detail.viewZoneId;
        if (viewZoneId === this._viewZoneId) {
          e.event.preventDefault();
          currentLineNumberOffset = this._updateLightBulbPosition(this._marginDomNode, e.event.browserEvent.y, lineHeight);
          showContextMenu(e.event.posx, e.event.posy + lineHeight);
        }
      }
    }));
  }
  get visibility() {
    return this._visibility;
  }
  set visibility(_visibility) {
    if (this._visibility !== _visibility) {
      this._visibility = _visibility;
      if (_visibility) {
        this._diffActions.style.visibility = "visible";
      } else {
        this._diffActions.style.visibility = "hidden";
      }
    }
  }
  _updateLightBulbPosition(marginDomNode, y, lineHeight) {
    const {top} = getDomNodePagePosition(marginDomNode);
    const offset = y - top;
    const lineNumberOffset = Math.floor(offset / lineHeight);
    const newTop = lineNumberOffset * lineHeight;
    this._diffActions.style.top = `${newTop}px`;
    return lineNumberOffset;
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js
var IClipboardService = createDecorator("clipboardService");

// ../../node_modules/monaco-editor/esm/vs/platform/progress/common/progress.js
var Progress = class {
  constructor(callback) {
    this.callback = callback;
  }
  report(item) {
    this._value = item;
    this.callback(this._value);
  }
};
Progress.None = Object.freeze({report() {
}});
var IEditorProgressService = createDecorator("editorProgressService");

// ../../node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditorWidget.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param6 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var VisualEditorState = class {
  constructor(_contextMenuService, _clipboardService) {
    this._contextMenuService = _contextMenuService;
    this._clipboardService = _clipboardService;
    this._zones = [];
    this.inlineDiffMargins = [];
    this._zonesMap = {};
    this._decorations = [];
  }
  getForeignViewZones(allViewZones) {
    return allViewZones.filter((z) => !this._zonesMap[String(z.id)]);
  }
  clean(editor2) {
    if (this._zones.length > 0) {
      editor2.changeViewZones((viewChangeAccessor) => {
        for (let i = 0, length = this._zones.length; i < length; i++) {
          viewChangeAccessor.removeZone(this._zones[i]);
        }
      });
    }
    this._zones = [];
    this._zonesMap = {};
    this._decorations = editor2.deltaDecorations(this._decorations, []);
  }
  apply(editor2, overviewRuler, newDecorations, restoreScrollState) {
    const scrollState = restoreScrollState ? StableEditorScrollState.capture(editor2) : null;
    editor2.changeViewZones((viewChangeAccessor) => {
      for (let i = 0, length = this._zones.length; i < length; i++) {
        viewChangeAccessor.removeZone(this._zones[i]);
      }
      for (let i = 0, length = this.inlineDiffMargins.length; i < length; i++) {
        this.inlineDiffMargins[i].dispose();
      }
      this._zones = [];
      this._zonesMap = {};
      this.inlineDiffMargins = [];
      for (let i = 0, length = newDecorations.zones.length; i < length; i++) {
        const viewZone = newDecorations.zones[i];
        viewZone.suppressMouseDown = true;
        let zoneId = viewChangeAccessor.addZone(viewZone);
        this._zones.push(zoneId);
        this._zonesMap[String(zoneId)] = true;
        if (newDecorations.zones[i].diff && viewZone.marginDomNode) {
          viewZone.suppressMouseDown = false;
          this.inlineDiffMargins.push(new InlineDiffMargin(zoneId, viewZone.marginDomNode, editor2, newDecorations.zones[i].diff, this._contextMenuService, this._clipboardService));
        }
      }
    });
    if (scrollState) {
      scrollState.restore(editor2);
    }
    this._decorations = editor2.deltaDecorations(this._decorations, newDecorations.decorations);
    if (overviewRuler) {
      overviewRuler.setZones(newDecorations.overviewZones);
    }
  }
};
var DIFF_EDITOR_ID = 0;
var diffInsertIcon = registerIcon("diff-insert", Codicon.add);
var diffRemoveIcon = registerIcon("diff-remove", Codicon.remove);
var DiffEditorWidget = class DiffEditorWidget2 extends Disposable {
  constructor(domElement, options, clipboardService, editorWorkerService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService, contextMenuService, _editorProgressService) {
    super();
    this._editorProgressService = _editorProgressService;
    this._onDidDispose = this._register(new Emitter());
    this.onDidDispose = this._onDidDispose.event;
    this._onDidUpdateDiff = this._register(new Emitter());
    this.onDidUpdateDiff = this._onDidUpdateDiff.event;
    this._onDidContentSizeChange = this._register(new Emitter());
    this._lastOriginalWarning = null;
    this._lastModifiedWarning = null;
    this._editorWorkerService = editorWorkerService;
    this._codeEditorService = codeEditorService;
    this._contextKeyService = this._register(contextKeyService.createScoped(domElement));
    this._contextKeyService.createKey("isInDiffEditor", true);
    this._themeService = themeService;
    this._notificationService = notificationService;
    this.id = ++DIFF_EDITOR_ID;
    this._state = 0;
    this._updatingDiffProgress = null;
    this._domElement = domElement;
    options = options || {};
    this._renderSideBySide = true;
    if (typeof options.renderSideBySide !== "undefined") {
      this._renderSideBySide = options.renderSideBySide;
    }
    this._maxComputationTime = 5e3;
    if (typeof options.maxComputationTime !== "undefined") {
      this._maxComputationTime = options.maxComputationTime;
    }
    this._ignoreTrimWhitespace = true;
    if (typeof options.ignoreTrimWhitespace !== "undefined") {
      this._ignoreTrimWhitespace = options.ignoreTrimWhitespace;
    }
    this._renderIndicators = true;
    if (typeof options.renderIndicators !== "undefined") {
      this._renderIndicators = options.renderIndicators;
    }
    this._originalIsEditable = false;
    if (typeof options.originalEditable !== "undefined") {
      this._originalIsEditable = Boolean(options.originalEditable);
    }
    this._originalCodeLens = false;
    if (typeof options.originalCodeLens !== "undefined") {
      this._originalCodeLens = Boolean(options.originalCodeLens);
    }
    this._modifiedCodeLens = false;
    if (typeof options.modifiedCodeLens !== "undefined") {
      this._modifiedCodeLens = Boolean(options.modifiedCodeLens);
    }
    this._updateDecorationsRunner = this._register(new RunOnceScheduler(() => this._updateDecorations(), 0));
    this._containerDomElement = document.createElement("div");
    this._containerDomElement.className = DiffEditorWidget2._getClassName(this._themeService.getColorTheme(), this._renderSideBySide);
    this._containerDomElement.style.position = "relative";
    this._containerDomElement.style.height = "100%";
    this._domElement.appendChild(this._containerDomElement);
    this._overviewViewportDomElement = createFastDomNode(document.createElement("div"));
    this._overviewViewportDomElement.setClassName("diffViewport");
    this._overviewViewportDomElement.setPosition("absolute");
    this._overviewDomElement = document.createElement("div");
    this._overviewDomElement.className = "diffOverview";
    this._overviewDomElement.style.position = "absolute";
    this._overviewDomElement.appendChild(this._overviewViewportDomElement.domNode);
    this._register(addStandardDisposableListener(this._overviewDomElement, "mousedown", (e) => {
      this.modifiedEditor.delegateVerticalScrollbarMouseDown(e);
    }));
    this._containerDomElement.appendChild(this._overviewDomElement);
    this._originalDomNode = document.createElement("div");
    this._originalDomNode.className = "editor original";
    this._originalDomNode.style.position = "absolute";
    this._originalDomNode.style.height = "100%";
    this._containerDomElement.appendChild(this._originalDomNode);
    this._modifiedDomNode = document.createElement("div");
    this._modifiedDomNode.className = "editor modified";
    this._modifiedDomNode.style.position = "absolute";
    this._modifiedDomNode.style.height = "100%";
    this._containerDomElement.appendChild(this._modifiedDomNode);
    this._beginUpdateDecorationsTimeout = -1;
    this._currentlyChangingViewZones = false;
    this._diffComputationToken = 0;
    this._originalEditorState = new VisualEditorState(contextMenuService, clipboardService);
    this._modifiedEditorState = new VisualEditorState(contextMenuService, clipboardService);
    this._isVisible = true;
    this._isHandlingScrollEvent = false;
    this._elementSizeObserver = this._register(new ElementSizeObserver(this._containerDomElement, void 0, () => this._onDidContainerSizeChanged()));
    if (options.automaticLayout) {
      this._elementSizeObserver.startObserving();
    }
    this._diffComputationResult = null;
    const leftContextKeyService = this._contextKeyService.createScoped();
    const leftServices = new ServiceCollection();
    leftServices.set(IContextKeyService, leftContextKeyService);
    const leftScopedInstantiationService = instantiationService.createChild(leftServices);
    const rightContextKeyService = this._contextKeyService.createScoped();
    const rightServices = new ServiceCollection();
    rightServices.set(IContextKeyService, rightContextKeyService);
    const rightScopedInstantiationService = instantiationService.createChild(rightServices);
    this.originalEditor = this._createLeftHandSideEditor(options, leftScopedInstantiationService, leftContextKeyService);
    this.modifiedEditor = this._createRightHandSideEditor(options, rightScopedInstantiationService, rightContextKeyService);
    this._originalOverviewRuler = null;
    this._modifiedOverviewRuler = null;
    this._reviewPane = new DiffReview(this);
    this._containerDomElement.appendChild(this._reviewPane.domNode.domNode);
    this._containerDomElement.appendChild(this._reviewPane.shadow.domNode);
    this._containerDomElement.appendChild(this._reviewPane.actionBarContainer.domNode);
    this._enableSplitViewResizing = true;
    if (typeof options.enableSplitViewResizing !== "undefined") {
      this._enableSplitViewResizing = options.enableSplitViewResizing;
    }
    if (this._renderSideBySide) {
      this._setStrategy(new DiffEditorWidgetSideBySide(this._createDataSource(), this._enableSplitViewResizing));
    } else {
      this._setStrategy(new DiffEditorWidgetInline(this._createDataSource(), this._enableSplitViewResizing));
    }
    this._register(themeService.onDidColorThemeChange((t) => {
      if (this._strategy && this._strategy.applyColors(t)) {
        this._updateDecorationsRunner.schedule();
      }
      this._containerDomElement.className = DiffEditorWidget2._getClassName(this._themeService.getColorTheme(), this._renderSideBySide);
    }));
    const contributions = EditorExtensionsRegistry.getDiffEditorContributions();
    for (const desc of contributions) {
      try {
        this._register(instantiationService.createInstance(desc.ctor, this));
      } catch (err) {
        onUnexpectedError(err);
      }
    }
    this._codeEditorService.addDiffEditor(this);
  }
  _setState(newState) {
    if (this._state === newState) {
      return;
    }
    this._state = newState;
    if (this._updatingDiffProgress) {
      this._updatingDiffProgress.done();
      this._updatingDiffProgress = null;
    }
    if (this._state === 1) {
      this._updatingDiffProgress = this._editorProgressService.show(true, 1e3);
    }
  }
  diffReviewNext() {
    this._reviewPane.next();
  }
  diffReviewPrev() {
    this._reviewPane.prev();
  }
  static _getClassName(theme, renderSideBySide) {
    let result = "monaco-diff-editor monaco-editor-background ";
    if (renderSideBySide) {
      result += "side-by-side ";
    }
    result += getThemeTypeSelector(theme.type);
    return result;
  }
  _recreateOverviewRulers() {
    if (this._originalOverviewRuler) {
      this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());
      this._originalOverviewRuler.dispose();
    }
    if (this.originalEditor.hasModel()) {
      this._originalOverviewRuler = this.originalEditor.createOverviewRuler("original diffOverviewRuler");
      this._overviewDomElement.appendChild(this._originalOverviewRuler.getDomNode());
    }
    if (this._modifiedOverviewRuler) {
      this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());
      this._modifiedOverviewRuler.dispose();
    }
    if (this.modifiedEditor.hasModel()) {
      this._modifiedOverviewRuler = this.modifiedEditor.createOverviewRuler("modified diffOverviewRuler");
      this._overviewDomElement.appendChild(this._modifiedOverviewRuler.getDomNode());
    }
    this._layoutOverviewRulers();
  }
  _createLeftHandSideEditor(options, instantiationService, contextKeyService) {
    const editor2 = this._createInnerEditor(instantiationService, this._originalDomNode, this._adjustOptionsForLeftHandSide(options, this._originalIsEditable, this._originalCodeLens));
    this._register(editor2.onDidScrollChange((e) => {
      if (this._isHandlingScrollEvent) {
        return;
      }
      if (!e.scrollTopChanged && !e.scrollLeftChanged && !e.scrollHeightChanged) {
        return;
      }
      this._isHandlingScrollEvent = true;
      this.modifiedEditor.setScrollPosition({
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
      });
      this._isHandlingScrollEvent = false;
      this._layoutOverviewViewport();
    }));
    this._register(editor2.onDidChangeViewZones(() => {
      this._onViewZonesChanged();
    }));
    this._register(editor2.onDidChangeModelContent(() => {
      if (this._isVisible) {
        this._beginUpdateDecorationsSoon();
      }
    }));
    const isInDiffLeftEditorKey = contextKeyService.createKey("isInDiffLeftEditor", void 0);
    this._register(editor2.onDidFocusEditorWidget(() => isInDiffLeftEditorKey.set(true)));
    this._register(editor2.onDidBlurEditorWidget(() => isInDiffLeftEditorKey.set(false)));
    this._register(editor2.onDidContentSizeChange((e) => {
      const width = this.originalEditor.getContentWidth() + this.modifiedEditor.getContentWidth() + DiffEditorWidget2.ONE_OVERVIEW_WIDTH;
      const height = Math.max(this.modifiedEditor.getContentHeight(), this.originalEditor.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: height,
        contentWidth: width,
        contentHeightChanged: e.contentHeightChanged,
        contentWidthChanged: e.contentWidthChanged
      });
    }));
    return editor2;
  }
  _createRightHandSideEditor(options, instantiationService, contextKeyService) {
    const editor2 = this._createInnerEditor(instantiationService, this._modifiedDomNode, this._adjustOptionsForRightHandSide(options, this._modifiedCodeLens));
    this._register(editor2.onDidScrollChange((e) => {
      if (this._isHandlingScrollEvent) {
        return;
      }
      if (!e.scrollTopChanged && !e.scrollLeftChanged && !e.scrollHeightChanged) {
        return;
      }
      this._isHandlingScrollEvent = true;
      this.originalEditor.setScrollPosition({
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
      });
      this._isHandlingScrollEvent = false;
      this._layoutOverviewViewport();
    }));
    this._register(editor2.onDidChangeViewZones(() => {
      this._onViewZonesChanged();
    }));
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (e.hasChanged(36) && editor2.getModel()) {
        this._onViewZonesChanged();
      }
    }));
    this._register(editor2.onDidChangeModelContent(() => {
      if (this._isVisible) {
        this._beginUpdateDecorationsSoon();
      }
    }));
    this._register(editor2.onDidChangeModelOptions((e) => {
      if (e.tabSize) {
        this._updateDecorationsRunner.schedule();
      }
    }));
    const isInDiffRightEditorKey = contextKeyService.createKey("isInDiffRightEditor", void 0);
    this._register(editor2.onDidFocusEditorWidget(() => isInDiffRightEditorKey.set(true)));
    this._register(editor2.onDidBlurEditorWidget(() => isInDiffRightEditorKey.set(false)));
    this._register(editor2.onDidContentSizeChange((e) => {
      const width = this.originalEditor.getContentWidth() + this.modifiedEditor.getContentWidth() + DiffEditorWidget2.ONE_OVERVIEW_WIDTH;
      const height = Math.max(this.modifiedEditor.getContentHeight(), this.originalEditor.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: height,
        contentWidth: width,
        contentHeightChanged: e.contentHeightChanged,
        contentWidthChanged: e.contentWidthChanged
      });
    }));
    return editor2;
  }
  _createInnerEditor(instantiationService, container, options) {
    return instantiationService.createInstance(CodeEditorWidget, container, options, {});
  }
  dispose() {
    this._codeEditorService.removeDiffEditor(this);
    if (this._beginUpdateDecorationsTimeout !== -1) {
      window.clearTimeout(this._beginUpdateDecorationsTimeout);
      this._beginUpdateDecorationsTimeout = -1;
    }
    this._cleanViewZonesAndDecorations();
    if (this._originalOverviewRuler) {
      this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());
      this._originalOverviewRuler.dispose();
    }
    if (this._modifiedOverviewRuler) {
      this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());
      this._modifiedOverviewRuler.dispose();
    }
    this._overviewDomElement.removeChild(this._overviewViewportDomElement.domNode);
    this._containerDomElement.removeChild(this._overviewDomElement);
    this._containerDomElement.removeChild(this._originalDomNode);
    this.originalEditor.dispose();
    this._containerDomElement.removeChild(this._modifiedDomNode);
    this.modifiedEditor.dispose();
    this._strategy.dispose();
    this._containerDomElement.removeChild(this._reviewPane.domNode.domNode);
    this._containerDomElement.removeChild(this._reviewPane.shadow.domNode);
    this._containerDomElement.removeChild(this._reviewPane.actionBarContainer.domNode);
    this._reviewPane.dispose();
    this._domElement.removeChild(this._containerDomElement);
    this._onDidDispose.fire();
    super.dispose();
  }
  getId() {
    return this.getEditorType() + ":" + this.id;
  }
  getEditorType() {
    return EditorType.IDiffEditor;
  }
  getLineChanges() {
    if (!this._diffComputationResult) {
      return null;
    }
    return this._diffComputationResult.changes;
  }
  getOriginalEditor() {
    return this.originalEditor;
  }
  getModifiedEditor() {
    return this.modifiedEditor;
  }
  updateOptions(newOptions) {
    let renderSideBySideChanged = false;
    if (typeof newOptions.renderSideBySide !== "undefined") {
      if (this._renderSideBySide !== newOptions.renderSideBySide) {
        this._renderSideBySide = newOptions.renderSideBySide;
        renderSideBySideChanged = true;
      }
    }
    if (typeof newOptions.maxComputationTime !== "undefined") {
      this._maxComputationTime = newOptions.maxComputationTime;
      if (this._isVisible) {
        this._beginUpdateDecorationsSoon();
      }
    }
    let beginUpdateDecorations = false;
    if (typeof newOptions.ignoreTrimWhitespace !== "undefined") {
      if (this._ignoreTrimWhitespace !== newOptions.ignoreTrimWhitespace) {
        this._ignoreTrimWhitespace = newOptions.ignoreTrimWhitespace;
        beginUpdateDecorations = true;
      }
    }
    if (typeof newOptions.renderIndicators !== "undefined") {
      if (this._renderIndicators !== newOptions.renderIndicators) {
        this._renderIndicators = newOptions.renderIndicators;
        beginUpdateDecorations = true;
      }
    }
    if (beginUpdateDecorations) {
      this._beginUpdateDecorations();
    }
    if (typeof newOptions.originalEditable !== "undefined") {
      this._originalIsEditable = Boolean(newOptions.originalEditable);
    }
    if (typeof newOptions.originalCodeLens !== "undefined") {
      this._originalCodeLens = Boolean(newOptions.originalCodeLens);
    }
    if (typeof newOptions.modifiedCodeLens !== "undefined") {
      this._modifiedCodeLens = Boolean(newOptions.modifiedCodeLens);
    }
    this.modifiedEditor.updateOptions(this._adjustOptionsForRightHandSide(newOptions, this._modifiedCodeLens));
    this.originalEditor.updateOptions(this._adjustOptionsForLeftHandSide(newOptions, this._originalIsEditable, this._originalCodeLens));
    if (typeof newOptions.enableSplitViewResizing !== "undefined") {
      this._enableSplitViewResizing = newOptions.enableSplitViewResizing;
    }
    this._strategy.setEnableSplitViewResizing(this._enableSplitViewResizing);
    if (renderSideBySideChanged) {
      if (this._renderSideBySide) {
        this._setStrategy(new DiffEditorWidgetSideBySide(this._createDataSource(), this._enableSplitViewResizing));
      } else {
        this._setStrategy(new DiffEditorWidgetInline(this._createDataSource(), this._enableSplitViewResizing));
      }
      this._containerDomElement.className = DiffEditorWidget2._getClassName(this._themeService.getColorTheme(), this._renderSideBySide);
    }
  }
  getModel() {
    return {
      original: this.originalEditor.getModel(),
      modified: this.modifiedEditor.getModel()
    };
  }
  setModel(model2) {
    if (model2 && (!model2.original || !model2.modified)) {
      throw new Error(!model2.original ? "DiffEditorWidget.setModel: Original model is null" : "DiffEditorWidget.setModel: Modified model is null");
    }
    this._cleanViewZonesAndDecorations();
    this.originalEditor.setModel(model2 ? model2.original : null);
    this.modifiedEditor.setModel(model2 ? model2.modified : null);
    this._updateDecorationsRunner.cancel();
    if (model2) {
      this.originalEditor.setScrollTop(0);
      this.modifiedEditor.setScrollTop(0);
    }
    this._diffComputationResult = null;
    this._diffComputationToken++;
    this._setState(0);
    if (model2) {
      this._recreateOverviewRulers();
      this._beginUpdateDecorations();
    }
    this._layoutOverviewViewport();
  }
  getDomNode() {
    return this._domElement;
  }
  getVisibleColumnFromPosition(position) {
    return this.modifiedEditor.getVisibleColumnFromPosition(position);
  }
  getPosition() {
    return this.modifiedEditor.getPosition();
  }
  setPosition(position) {
    this.modifiedEditor.setPosition(position);
  }
  revealLine(lineNumber, scrollType = 0) {
    this.modifiedEditor.revealLine(lineNumber, scrollType);
  }
  revealLineInCenter(lineNumber, scrollType = 0) {
    this.modifiedEditor.revealLineInCenter(lineNumber, scrollType);
  }
  revealLineInCenterIfOutsideViewport(lineNumber, scrollType = 0) {
    this.modifiedEditor.revealLineInCenterIfOutsideViewport(lineNumber, scrollType);
  }
  revealLineNearTop(lineNumber, scrollType = 0) {
    this.modifiedEditor.revealLineNearTop(lineNumber, scrollType);
  }
  revealPosition(position, scrollType = 0) {
    this.modifiedEditor.revealPosition(position, scrollType);
  }
  revealPositionInCenter(position, scrollType = 0) {
    this.modifiedEditor.revealPositionInCenter(position, scrollType);
  }
  revealPositionInCenterIfOutsideViewport(position, scrollType = 0) {
    this.modifiedEditor.revealPositionInCenterIfOutsideViewport(position, scrollType);
  }
  revealPositionNearTop(position, scrollType = 0) {
    this.modifiedEditor.revealPositionNearTop(position, scrollType);
  }
  getSelection() {
    return this.modifiedEditor.getSelection();
  }
  getSelections() {
    return this.modifiedEditor.getSelections();
  }
  setSelection(something) {
    this.modifiedEditor.setSelection(something);
  }
  setSelections(ranges) {
    this.modifiedEditor.setSelections(ranges);
  }
  revealLines(startLineNumber, endLineNumber, scrollType = 0) {
    this.modifiedEditor.revealLines(startLineNumber, endLineNumber, scrollType);
  }
  revealLinesInCenter(startLineNumber, endLineNumber, scrollType = 0) {
    this.modifiedEditor.revealLinesInCenter(startLineNumber, endLineNumber, scrollType);
  }
  revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType = 0) {
    this.modifiedEditor.revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType);
  }
  revealLinesNearTop(startLineNumber, endLineNumber, scrollType = 0) {
    this.modifiedEditor.revealLinesNearTop(startLineNumber, endLineNumber, scrollType);
  }
  revealRange(range2, scrollType = 0, revealVerticalInCenter = false, revealHorizontal = true) {
    this.modifiedEditor.revealRange(range2, scrollType, revealVerticalInCenter, revealHorizontal);
  }
  revealRangeInCenter(range2, scrollType = 0) {
    this.modifiedEditor.revealRangeInCenter(range2, scrollType);
  }
  revealRangeInCenterIfOutsideViewport(range2, scrollType = 0) {
    this.modifiedEditor.revealRangeInCenterIfOutsideViewport(range2, scrollType);
  }
  revealRangeNearTop(range2, scrollType = 0) {
    this.modifiedEditor.revealRangeNearTop(range2, scrollType);
  }
  revealRangeNearTopIfOutsideViewport(range2, scrollType = 0) {
    this.modifiedEditor.revealRangeNearTopIfOutsideViewport(range2, scrollType);
  }
  revealRangeAtTop(range2, scrollType = 0) {
    this.modifiedEditor.revealRangeAtTop(range2, scrollType);
  }
  getSupportedActions() {
    return this.modifiedEditor.getSupportedActions();
  }
  saveViewState() {
    let originalViewState = this.originalEditor.saveViewState();
    let modifiedViewState = this.modifiedEditor.saveViewState();
    return {
      original: originalViewState,
      modified: modifiedViewState
    };
  }
  restoreViewState(s) {
    if (s.original && s.modified) {
      let diffEditorState = s;
      this.originalEditor.restoreViewState(diffEditorState.original);
      this.modifiedEditor.restoreViewState(diffEditorState.modified);
    }
  }
  layout(dimension) {
    this._elementSizeObserver.observe(dimension);
  }
  focus() {
    this.modifiedEditor.focus();
  }
  hasTextFocus() {
    return this.originalEditor.hasTextFocus() || this.modifiedEditor.hasTextFocus();
  }
  trigger(source, handlerId, payload) {
    this.modifiedEditor.trigger(source, handlerId, payload);
  }
  changeDecorations(callback) {
    return this.modifiedEditor.changeDecorations(callback);
  }
  _onDidContainerSizeChanged() {
    this._doLayout();
  }
  _getReviewHeight() {
    return this._reviewPane.isVisible() ? this._elementSizeObserver.getHeight() : 0;
  }
  _layoutOverviewRulers() {
    if (!this._originalOverviewRuler || !this._modifiedOverviewRuler) {
      return;
    }
    const height = this._elementSizeObserver.getHeight();
    const reviewHeight = this._getReviewHeight();
    let freeSpace = DiffEditorWidget2.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * DiffEditorWidget2.ONE_OVERVIEW_WIDTH;
    let layoutInfo = this.modifiedEditor.getLayoutInfo();
    if (layoutInfo) {
      this._originalOverviewRuler.setLayout({
        top: 0,
        width: DiffEditorWidget2.ONE_OVERVIEW_WIDTH,
        right: freeSpace + DiffEditorWidget2.ONE_OVERVIEW_WIDTH,
        height: height - reviewHeight
      });
      this._modifiedOverviewRuler.setLayout({
        top: 0,
        right: 0,
        width: DiffEditorWidget2.ONE_OVERVIEW_WIDTH,
        height: height - reviewHeight
      });
    }
  }
  _onViewZonesChanged() {
    if (this._currentlyChangingViewZones) {
      return;
    }
    this._updateDecorationsRunner.schedule();
  }
  _beginUpdateDecorationsSoon() {
    if (this._beginUpdateDecorationsTimeout !== -1) {
      window.clearTimeout(this._beginUpdateDecorationsTimeout);
      this._beginUpdateDecorationsTimeout = -1;
    }
    this._beginUpdateDecorationsTimeout = window.setTimeout(() => this._beginUpdateDecorations(), DiffEditorWidget2.UPDATE_DIFF_DECORATIONS_DELAY);
  }
  static _equals(a, b) {
    if (!a && !b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    return a.toString() === b.toString();
  }
  _beginUpdateDecorations() {
    this._beginUpdateDecorationsTimeout = -1;
    const currentOriginalModel = this.originalEditor.getModel();
    const currentModifiedModel = this.modifiedEditor.getModel();
    if (!currentOriginalModel || !currentModifiedModel) {
      return;
    }
    this._diffComputationToken++;
    let currentToken = this._diffComputationToken;
    this._setState(1);
    if (!this._editorWorkerService.canComputeDiff(currentOriginalModel.uri, currentModifiedModel.uri)) {
      if (!DiffEditorWidget2._equals(currentOriginalModel.uri, this._lastOriginalWarning) || !DiffEditorWidget2._equals(currentModifiedModel.uri, this._lastModifiedWarning)) {
        this._lastOriginalWarning = currentOriginalModel.uri;
        this._lastModifiedWarning = currentModifiedModel.uri;
        this._notificationService.warn(localize("diff.tooLarge", "Cannot compare files because one file is too large."));
      }
      return;
    }
    this._editorWorkerService.computeDiff(currentOriginalModel.uri, currentModifiedModel.uri, this._ignoreTrimWhitespace, this._maxComputationTime).then((result) => {
      if (currentToken === this._diffComputationToken && currentOriginalModel === this.originalEditor.getModel() && currentModifiedModel === this.modifiedEditor.getModel()) {
        this._setState(2);
        this._diffComputationResult = result;
        this._updateDecorationsRunner.schedule();
        this._onDidUpdateDiff.fire();
      }
    }, (error) => {
      if (currentToken === this._diffComputationToken && currentOriginalModel === this.originalEditor.getModel() && currentModifiedModel === this.modifiedEditor.getModel()) {
        this._setState(2);
        this._diffComputationResult = null;
        this._updateDecorationsRunner.schedule();
      }
    });
  }
  _cleanViewZonesAndDecorations() {
    this._originalEditorState.clean(this.originalEditor);
    this._modifiedEditorState.clean(this.modifiedEditor);
  }
  _updateDecorations() {
    if (!this.originalEditor.getModel() || !this.modifiedEditor.getModel() || !this._originalOverviewRuler || !this._modifiedOverviewRuler) {
      return;
    }
    const lineChanges = this._diffComputationResult ? this._diffComputationResult.changes : [];
    let foreignOriginal = this._originalEditorState.getForeignViewZones(this.originalEditor.getWhitespaces());
    let foreignModified = this._modifiedEditorState.getForeignViewZones(this.modifiedEditor.getWhitespaces());
    let diffDecorations = this._strategy.getEditorsDiffDecorations(lineChanges, this._ignoreTrimWhitespace, this._renderIndicators, foreignOriginal, foreignModified, this.originalEditor, this.modifiedEditor);
    try {
      this._currentlyChangingViewZones = true;
      this._originalEditorState.apply(this.originalEditor, this._originalOverviewRuler, diffDecorations.original, false);
      this._modifiedEditorState.apply(this.modifiedEditor, this._modifiedOverviewRuler, diffDecorations.modified, true);
    } finally {
      this._currentlyChangingViewZones = false;
    }
  }
  _adjustOptionsForSubEditor(options) {
    let clonedOptions = deepClone(options || {});
    clonedOptions.inDiffEditor = true;
    clonedOptions.wordWrap = "off";
    clonedOptions.wordWrapMinified = false;
    clonedOptions.automaticLayout = false;
    clonedOptions.scrollbar = clonedOptions.scrollbar || {};
    clonedOptions.scrollbar.vertical = "visible";
    clonedOptions.folding = false;
    clonedOptions.codeLens = false;
    clonedOptions.fixedOverflowWidgets = true;
    clonedOptions.overflowWidgetsDomNode = options.overflowWidgetsDomNode;
    if (!clonedOptions.minimap) {
      clonedOptions.minimap = {};
    }
    clonedOptions.minimap.enabled = false;
    return clonedOptions;
  }
  _adjustOptionsForLeftHandSide(options, isEditable, isCodeLensEnabled) {
    let result = this._adjustOptionsForSubEditor(options);
    if (isCodeLensEnabled) {
      result.codeLens = true;
    }
    result.readOnly = !isEditable;
    result.extraEditorClassName = "original-in-monaco-diff-editor";
    return result;
  }
  _adjustOptionsForRightHandSide(options, isCodeLensEnabled) {
    let result = this._adjustOptionsForSubEditor(options);
    if (isCodeLensEnabled) {
      result.codeLens = true;
    }
    result.revealHorizontalRightPadding = EditorOptions.revealHorizontalRightPadding.defaultValue + DiffEditorWidget2.ENTIRE_DIFF_OVERVIEW_WIDTH;
    result.scrollbar.verticalHasArrows = false;
    result.extraEditorClassName = "modified-in-monaco-diff-editor";
    return result;
  }
  doLayout() {
    this._elementSizeObserver.observe();
    this._doLayout();
  }
  _doLayout() {
    const width = this._elementSizeObserver.getWidth();
    const height = this._elementSizeObserver.getHeight();
    const reviewHeight = this._getReviewHeight();
    let splitPoint = this._strategy.layout();
    this._originalDomNode.style.width = splitPoint + "px";
    this._originalDomNode.style.left = "0px";
    this._modifiedDomNode.style.width = width - splitPoint + "px";
    this._modifiedDomNode.style.left = splitPoint + "px";
    this._overviewDomElement.style.top = "0px";
    this._overviewDomElement.style.height = height - reviewHeight + "px";
    this._overviewDomElement.style.width = DiffEditorWidget2.ENTIRE_DIFF_OVERVIEW_WIDTH + "px";
    this._overviewDomElement.style.left = width - DiffEditorWidget2.ENTIRE_DIFF_OVERVIEW_WIDTH + "px";
    this._overviewViewportDomElement.setWidth(DiffEditorWidget2.ENTIRE_DIFF_OVERVIEW_WIDTH);
    this._overviewViewportDomElement.setHeight(30);
    this.originalEditor.layout({width: splitPoint, height: height - reviewHeight});
    this.modifiedEditor.layout({width: width - splitPoint - DiffEditorWidget2.ENTIRE_DIFF_OVERVIEW_WIDTH, height: height - reviewHeight});
    if (this._originalOverviewRuler || this._modifiedOverviewRuler) {
      this._layoutOverviewRulers();
    }
    this._reviewPane.layout(height - reviewHeight, width, reviewHeight);
    this._layoutOverviewViewport();
  }
  _layoutOverviewViewport() {
    let layout2 = this._computeOverviewViewport();
    if (!layout2) {
      this._overviewViewportDomElement.setTop(0);
      this._overviewViewportDomElement.setHeight(0);
    } else {
      this._overviewViewportDomElement.setTop(layout2.top);
      this._overviewViewportDomElement.setHeight(layout2.height);
    }
  }
  _computeOverviewViewport() {
    let layoutInfo = this.modifiedEditor.getLayoutInfo();
    if (!layoutInfo) {
      return null;
    }
    let scrollTop = this.modifiedEditor.getScrollTop();
    let scrollHeight = this.modifiedEditor.getScrollHeight();
    let computedAvailableSize = Math.max(0, layoutInfo.height);
    let computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * 0);
    let computedRatio = scrollHeight > 0 ? computedRepresentableSize / scrollHeight : 0;
    let computedSliderSize = Math.max(0, Math.floor(layoutInfo.height * computedRatio));
    let computedSliderPosition = Math.floor(scrollTop * computedRatio);
    return {
      height: computedSliderSize,
      top: computedSliderPosition
    };
  }
  _createDataSource() {
    return {
      getWidth: () => {
        return this._elementSizeObserver.getWidth();
      },
      getHeight: () => {
        return this._elementSizeObserver.getHeight() - this._getReviewHeight();
      },
      getContainerDomNode: () => {
        return this._containerDomElement;
      },
      relayoutEditors: () => {
        this._doLayout();
      },
      getOriginalEditor: () => {
        return this.originalEditor;
      },
      getModifiedEditor: () => {
        return this.modifiedEditor;
      }
    };
  }
  _setStrategy(newStrategy) {
    if (this._strategy) {
      this._strategy.dispose();
    }
    this._strategy = newStrategy;
    newStrategy.applyColors(this._themeService.getColorTheme());
    if (this._diffComputationResult) {
      this._updateDecorations();
    }
    this._doLayout();
  }
  _getLineChangeAtOrBeforeLineNumber(lineNumber, startLineNumberExtractor) {
    const lineChanges = this._diffComputationResult ? this._diffComputationResult.changes : [];
    if (lineChanges.length === 0 || lineNumber < startLineNumberExtractor(lineChanges[0])) {
      return null;
    }
    let min = 0, max = lineChanges.length - 1;
    while (min < max) {
      let mid = Math.floor((min + max) / 2);
      let midStart = startLineNumberExtractor(lineChanges[mid]);
      let midEnd = mid + 1 <= max ? startLineNumberExtractor(lineChanges[mid + 1]) : 1073741824;
      if (lineNumber < midStart) {
        max = mid - 1;
      } else if (lineNumber >= midEnd) {
        min = mid + 1;
      } else {
        min = mid;
        max = mid;
      }
    }
    return lineChanges[min];
  }
  _getEquivalentLineForOriginalLineNumber(lineNumber) {
    let lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, (lineChange2) => lineChange2.originalStartLineNumber);
    if (!lineChange) {
      return lineNumber;
    }
    let originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
    let modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
    let lineChangeOriginalLength = lineChange.originalEndLineNumber > 0 ? lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1 : 0;
    let lineChangeModifiedLength = lineChange.modifiedEndLineNumber > 0 ? lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1 : 0;
    let delta = lineNumber - originalEquivalentLineNumber;
    if (delta <= lineChangeOriginalLength) {
      return modifiedEquivalentLineNumber + Math.min(delta, lineChangeModifiedLength);
    }
    return modifiedEquivalentLineNumber + lineChangeModifiedLength - lineChangeOriginalLength + delta;
  }
  _getEquivalentLineForModifiedLineNumber(lineNumber) {
    let lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, (lineChange2) => lineChange2.modifiedStartLineNumber);
    if (!lineChange) {
      return lineNumber;
    }
    let originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
    let modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
    let lineChangeOriginalLength = lineChange.originalEndLineNumber > 0 ? lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1 : 0;
    let lineChangeModifiedLength = lineChange.modifiedEndLineNumber > 0 ? lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1 : 0;
    let delta = lineNumber - modifiedEquivalentLineNumber;
    if (delta <= lineChangeModifiedLength) {
      return originalEquivalentLineNumber + Math.min(delta, lineChangeOriginalLength);
    }
    return originalEquivalentLineNumber + lineChangeOriginalLength - lineChangeModifiedLength + delta;
  }
  getDiffLineInformationForOriginal(lineNumber) {
    if (!this._diffComputationResult) {
      return null;
    }
    return {
      equivalentLineNumber: this._getEquivalentLineForOriginalLineNumber(lineNumber)
    };
  }
  getDiffLineInformationForModified(lineNumber) {
    if (!this._diffComputationResult) {
      return null;
    }
    return {
      equivalentLineNumber: this._getEquivalentLineForModifiedLineNumber(lineNumber)
    };
  }
};
DiffEditorWidget.ONE_OVERVIEW_WIDTH = 15;
DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH = 30;
DiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY = 200;
DiffEditorWidget = __decorate7([
  __param6(2, IClipboardService),
  __param6(3, IEditorWorkerService),
  __param6(4, IContextKeyService),
  __param6(5, IInstantiationService),
  __param6(6, ICodeEditorService),
  __param6(7, IThemeService),
  __param6(8, INotificationService),
  __param6(9, IContextMenuService),
  __param6(10, IEditorProgressService)
], DiffEditorWidget);
var DiffEditorWidgetStyle = class extends Disposable {
  constructor(dataSource) {
    super();
    this._dataSource = dataSource;
    this._insertColor = null;
    this._removeColor = null;
  }
  applyColors(theme) {
    let newInsertColor = (theme.getColor(diffInserted) || defaultInsertColor).transparent(2);
    let newRemoveColor = (theme.getColor(diffRemoved) || defaultRemoveColor).transparent(2);
    let hasChanges = !newInsertColor.equals(this._insertColor) || !newRemoveColor.equals(this._removeColor);
    this._insertColor = newInsertColor;
    this._removeColor = newRemoveColor;
    return hasChanges;
  }
  getEditorsDiffDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalWhitespaces, modifiedWhitespaces, originalEditor, modifiedEditor) {
    modifiedWhitespaces = modifiedWhitespaces.sort((a, b) => {
      return a.afterLineNumber - b.afterLineNumber;
    });
    originalWhitespaces = originalWhitespaces.sort((a, b) => {
      return a.afterLineNumber - b.afterLineNumber;
    });
    let zones = this._getViewZones(lineChanges, originalWhitespaces, modifiedWhitespaces, originalEditor, modifiedEditor, renderIndicators);
    let originalDecorations = this._getOriginalEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor);
    let modifiedDecorations = this._getModifiedEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor);
    return {
      original: {
        decorations: originalDecorations.decorations,
        overviewZones: originalDecorations.overviewZones,
        zones: zones.original
      },
      modified: {
        decorations: modifiedDecorations.decorations,
        overviewZones: modifiedDecorations.overviewZones,
        zones: zones.modified
      }
    };
  }
};
var ForeignViewZonesIterator = class {
  constructor(source) {
    this._source = source;
    this._index = -1;
    this.current = null;
    this.advance();
  }
  advance() {
    this._index++;
    if (this._index < this._source.length) {
      this.current = this._source[this._index];
    } else {
      this.current = null;
    }
  }
};
var ViewZonesComputer = class {
  constructor(lineChanges, originalForeignVZ, originalLineHeight, modifiedForeignVZ, modifiedLineHeight) {
    this.lineChanges = lineChanges;
    this.originalForeignVZ = originalForeignVZ;
    this.originalLineHeight = originalLineHeight;
    this.modifiedForeignVZ = modifiedForeignVZ;
    this.modifiedLineHeight = modifiedLineHeight;
  }
  getViewZones() {
    let result = {
      original: [],
      modified: []
    };
    let lineChangeModifiedLength = 0;
    let lineChangeOriginalLength = 0;
    let originalEquivalentLineNumber = 0;
    let modifiedEquivalentLineNumber = 0;
    let originalEndEquivalentLineNumber = 0;
    let modifiedEndEquivalentLineNumber = 0;
    let sortMyViewZones = (a, b) => {
      return a.afterLineNumber - b.afterLineNumber;
    };
    let addAndCombineIfPossible = (destination, item) => {
      if (item.domNode === null && destination.length > 0) {
        let lastItem = destination[destination.length - 1];
        if (lastItem.afterLineNumber === item.afterLineNumber && lastItem.domNode === null) {
          lastItem.heightInLines += item.heightInLines;
          return;
        }
      }
      destination.push(item);
    };
    let modifiedForeignVZ = new ForeignViewZonesIterator(this.modifiedForeignVZ);
    let originalForeignVZ = new ForeignViewZonesIterator(this.originalForeignVZ);
    for (let i = 0, length = this.lineChanges.length; i <= length; i++) {
      let lineChange = i < length ? this.lineChanges[i] : null;
      if (lineChange !== null) {
        originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
        modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
        lineChangeOriginalLength = lineChange.originalEndLineNumber > 0 ? lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1 : 0;
        lineChangeModifiedLength = lineChange.modifiedEndLineNumber > 0 ? lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1 : 0;
        originalEndEquivalentLineNumber = Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);
        modifiedEndEquivalentLineNumber = Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);
      } else {
        originalEquivalentLineNumber += 1e7 + lineChangeOriginalLength;
        modifiedEquivalentLineNumber += 1e7 + lineChangeModifiedLength;
        originalEndEquivalentLineNumber = originalEquivalentLineNumber;
        modifiedEndEquivalentLineNumber = modifiedEquivalentLineNumber;
      }
      let stepOriginal = [];
      let stepModified = [];
      while (modifiedForeignVZ.current && modifiedForeignVZ.current.afterLineNumber <= modifiedEndEquivalentLineNumber) {
        let viewZoneLineNumber;
        if (modifiedForeignVZ.current.afterLineNumber <= modifiedEquivalentLineNumber) {
          viewZoneLineNumber = originalEquivalentLineNumber - modifiedEquivalentLineNumber + modifiedForeignVZ.current.afterLineNumber;
        } else {
          viewZoneLineNumber = originalEndEquivalentLineNumber;
        }
        let marginDomNode = null;
        if (lineChange && lineChange.modifiedStartLineNumber <= modifiedForeignVZ.current.afterLineNumber && modifiedForeignVZ.current.afterLineNumber <= lineChange.modifiedEndLineNumber) {
          marginDomNode = this._createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion();
        }
        stepOriginal.push({
          afterLineNumber: viewZoneLineNumber,
          heightInLines: modifiedForeignVZ.current.height / this.modifiedLineHeight,
          domNode: null,
          marginDomNode
        });
        modifiedForeignVZ.advance();
      }
      while (originalForeignVZ.current && originalForeignVZ.current.afterLineNumber <= originalEndEquivalentLineNumber) {
        let viewZoneLineNumber;
        if (originalForeignVZ.current.afterLineNumber <= originalEquivalentLineNumber) {
          viewZoneLineNumber = modifiedEquivalentLineNumber - originalEquivalentLineNumber + originalForeignVZ.current.afterLineNumber;
        } else {
          viewZoneLineNumber = modifiedEndEquivalentLineNumber;
        }
        stepModified.push({
          afterLineNumber: viewZoneLineNumber,
          heightInLines: originalForeignVZ.current.height / this.originalLineHeight,
          domNode: null
        });
        originalForeignVZ.advance();
      }
      if (lineChange !== null && isChangeOrInsert(lineChange)) {
        let r = this._produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);
        if (r) {
          stepOriginal.push(r);
        }
      }
      if (lineChange !== null && isChangeOrDelete(lineChange)) {
        let r = this._produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);
        if (r) {
          stepModified.push(r);
        }
      }
      let stepOriginalIndex = 0;
      let stepModifiedIndex = 0;
      stepOriginal = stepOriginal.sort(sortMyViewZones);
      stepModified = stepModified.sort(sortMyViewZones);
      while (stepOriginalIndex < stepOriginal.length && stepModifiedIndex < stepModified.length) {
        let original = stepOriginal[stepOriginalIndex];
        let modified = stepModified[stepModifiedIndex];
        let originalDelta = original.afterLineNumber - originalEquivalentLineNumber;
        let modifiedDelta = modified.afterLineNumber - modifiedEquivalentLineNumber;
        if (originalDelta < modifiedDelta) {
          addAndCombineIfPossible(result.original, original);
          stepOriginalIndex++;
        } else if (modifiedDelta < originalDelta) {
          addAndCombineIfPossible(result.modified, modified);
          stepModifiedIndex++;
        } else if (original.shouldNotShrink) {
          addAndCombineIfPossible(result.original, original);
          stepOriginalIndex++;
        } else if (modified.shouldNotShrink) {
          addAndCombineIfPossible(result.modified, modified);
          stepModifiedIndex++;
        } else {
          if (original.heightInLines >= modified.heightInLines) {
            original.heightInLines -= modified.heightInLines;
            stepModifiedIndex++;
          } else {
            modified.heightInLines -= original.heightInLines;
            stepOriginalIndex++;
          }
        }
      }
      while (stepOriginalIndex < stepOriginal.length) {
        addAndCombineIfPossible(result.original, stepOriginal[stepOriginalIndex]);
        stepOriginalIndex++;
      }
      while (stepModifiedIndex < stepModified.length) {
        addAndCombineIfPossible(result.modified, stepModified[stepModifiedIndex]);
        stepModifiedIndex++;
      }
    }
    return {
      original: ViewZonesComputer._ensureDomNodes(result.original),
      modified: ViewZonesComputer._ensureDomNodes(result.modified)
    };
  }
  static _ensureDomNodes(zones) {
    return zones.map((z) => {
      if (!z.domNode) {
        z.domNode = createFakeLinesDiv();
      }
      return z;
    });
  }
};
function createDecoration(startLineNumber, startColumn, endLineNumber, endColumn, options) {
  return {
    range: new Range(startLineNumber, startColumn, endLineNumber, endColumn),
    options
  };
}
var DECORATIONS = {
  charDelete: ModelDecorationOptions.register({
    className: "char-delete"
  }),
  charDeleteWholeLine: ModelDecorationOptions.register({
    className: "char-delete",
    isWholeLine: true
  }),
  charInsert: ModelDecorationOptions.register({
    className: "char-insert"
  }),
  charInsertWholeLine: ModelDecorationOptions.register({
    className: "char-insert",
    isWholeLine: true
  }),
  lineInsert: ModelDecorationOptions.register({
    className: "line-insert",
    marginClassName: "line-insert",
    isWholeLine: true
  }),
  lineInsertWithSign: ModelDecorationOptions.register({
    className: "line-insert",
    linesDecorationsClassName: "insert-sign " + diffInsertIcon.classNames,
    marginClassName: "line-insert",
    isWholeLine: true
  }),
  lineDelete: ModelDecorationOptions.register({
    className: "line-delete",
    marginClassName: "line-delete",
    isWholeLine: true
  }),
  lineDeleteWithSign: ModelDecorationOptions.register({
    className: "line-delete",
    linesDecorationsClassName: "delete-sign " + diffRemoveIcon.classNames,
    marginClassName: "line-delete",
    isWholeLine: true
  }),
  lineDeleteMargin: ModelDecorationOptions.register({
    marginClassName: "line-delete"
  })
};
var DiffEditorWidgetSideBySide = class extends DiffEditorWidgetStyle {
  constructor(dataSource, enableSplitViewResizing) {
    super(dataSource);
    this._disableSash = enableSplitViewResizing === false;
    this._sashRatio = null;
    this._sashPosition = null;
    this._startSashPosition = null;
    this._sash = this._register(new Sash(this._dataSource.getContainerDomNode(), this, {orientation: 0}));
    if (this._disableSash) {
      this._sash.state = 0;
    }
    this._sash.onDidStart(() => this.onSashDragStart());
    this._sash.onDidChange((e) => this.onSashDrag(e));
    this._sash.onDidEnd(() => this.onSashDragEnd());
    this._sash.onDidReset(() => this.onSashReset());
  }
  setEnableSplitViewResizing(enableSplitViewResizing) {
    let newDisableSash = enableSplitViewResizing === false;
    if (this._disableSash !== newDisableSash) {
      this._disableSash = newDisableSash;
      this._sash.state = this._disableSash ? 0 : 3;
    }
  }
  layout(sashRatio = this._sashRatio) {
    let w = this._dataSource.getWidth();
    let contentWidth = w - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;
    let sashPosition = Math.floor((sashRatio || 0.5) * contentWidth);
    let midPoint = Math.floor(0.5 * contentWidth);
    sashPosition = this._disableSash ? midPoint : sashPosition || midPoint;
    if (contentWidth > DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH * 2) {
      if (sashPosition < DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {
        sashPosition = DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;
      }
      if (sashPosition > contentWidth - DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {
        sashPosition = contentWidth - DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;
      }
    } else {
      sashPosition = midPoint;
    }
    if (this._sashPosition !== sashPosition) {
      this._sashPosition = sashPosition;
      this._sash.layout();
    }
    return this._sashPosition;
  }
  onSashDragStart() {
    this._startSashPosition = this._sashPosition;
  }
  onSashDrag(e) {
    let w = this._dataSource.getWidth();
    let contentWidth = w - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;
    let sashPosition = this.layout((this._startSashPosition + (e.currentX - e.startX)) / contentWidth);
    this._sashRatio = sashPosition / contentWidth;
    this._dataSource.relayoutEditors();
  }
  onSashDragEnd() {
    this._sash.layout();
  }
  onSashReset() {
    this._sashRatio = 0.5;
    this._dataSource.relayoutEditors();
    this._sash.layout();
  }
  getVerticalSashTop(sash) {
    return 0;
  }
  getVerticalSashLeft(sash) {
    return this._sashPosition;
  }
  getVerticalSashHeight(sash) {
    return this._dataSource.getHeight();
  }
  _getViewZones(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor) {
    let c = new SideBySideViewZonesComputer(lineChanges, originalForeignVZ, originalEditor.getOption(51), modifiedForeignVZ, modifiedEditor.getOption(51));
    return c.getViewZones();
  }
  _getOriginalEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
    const overviewZoneColor = String(this._removeColor);
    let result = {
      decorations: [],
      overviewZones: []
    };
    let originalModel = originalEditor.getModel();
    for (let i = 0, length = lineChanges.length; i < length; i++) {
      let lineChange = lineChanges[i];
      if (isChangeOrDelete(lineChange)) {
        result.decorations.push({
          range: new Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824),
          options: renderIndicators ? DECORATIONS.lineDeleteWithSign : DECORATIONS.lineDelete
        });
        if (!isChangeOrInsert(lineChange) || !lineChange.charChanges) {
          result.decorations.push(createDecoration(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824, DECORATIONS.charDeleteWholeLine));
        }
        result.overviewZones.push(new OverviewRulerZone(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber, overviewZoneColor));
        if (lineChange.charChanges) {
          for (let j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
            let charChange = lineChange.charChanges[j];
            if (isChangeOrDelete(charChange)) {
              if (ignoreTrimWhitespace) {
                for (let lineNumber = charChange.originalStartLineNumber; lineNumber <= charChange.originalEndLineNumber; lineNumber++) {
                  let startColumn;
                  let endColumn;
                  if (lineNumber === charChange.originalStartLineNumber) {
                    startColumn = charChange.originalStartColumn;
                  } else {
                    startColumn = originalModel.getLineFirstNonWhitespaceColumn(lineNumber);
                  }
                  if (lineNumber === charChange.originalEndLineNumber) {
                    endColumn = charChange.originalEndColumn;
                  } else {
                    endColumn = originalModel.getLineLastNonWhitespaceColumn(lineNumber);
                  }
                  result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charDelete));
                }
              } else {
                result.decorations.push(createDecoration(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn, DECORATIONS.charDelete));
              }
            }
          }
        }
      }
    }
    return result;
  }
  _getModifiedEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
    const overviewZoneColor = String(this._insertColor);
    let result = {
      decorations: [],
      overviewZones: []
    };
    let modifiedModel = modifiedEditor.getModel();
    for (let i = 0, length = lineChanges.length; i < length; i++) {
      let lineChange = lineChanges[i];
      if (isChangeOrInsert(lineChange)) {
        result.decorations.push({
          range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824),
          options: renderIndicators ? DECORATIONS.lineInsertWithSign : DECORATIONS.lineInsert
        });
        if (!isChangeOrDelete(lineChange) || !lineChange.charChanges) {
          result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824, DECORATIONS.charInsertWholeLine));
        }
        result.overviewZones.push(new OverviewRulerZone(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber, overviewZoneColor));
        if (lineChange.charChanges) {
          for (let j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
            let charChange = lineChange.charChanges[j];
            if (isChangeOrInsert(charChange)) {
              if (ignoreTrimWhitespace) {
                for (let lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {
                  let startColumn;
                  let endColumn;
                  if (lineNumber === charChange.modifiedStartLineNumber) {
                    startColumn = charChange.modifiedStartColumn;
                  } else {
                    startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);
                  }
                  if (lineNumber === charChange.modifiedEndLineNumber) {
                    endColumn = charChange.modifiedEndColumn;
                  } else {
                    endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);
                  }
                  result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charInsert));
                }
              } else {
                result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, DECORATIONS.charInsert));
              }
            }
          }
        }
      }
    }
    return result;
  }
};
DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH = 100;
var SideBySideViewZonesComputer = class extends ViewZonesComputer {
  constructor(lineChanges, originalForeignVZ, originalLineHeight, modifiedForeignVZ, modifiedLineHeight) {
    super(lineChanges, originalForeignVZ, originalLineHeight, modifiedForeignVZ, modifiedLineHeight);
  }
  _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {
    return null;
  }
  _produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
    if (lineChangeModifiedLength > lineChangeOriginalLength) {
      return {
        afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),
        heightInLines: lineChangeModifiedLength - lineChangeOriginalLength,
        domNode: null
      };
    }
    return null;
  }
  _produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
    if (lineChangeOriginalLength > lineChangeModifiedLength) {
      return {
        afterLineNumber: Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber),
        heightInLines: lineChangeOriginalLength - lineChangeModifiedLength,
        domNode: null
      };
    }
    return null;
  }
};
var DiffEditorWidgetInline = class extends DiffEditorWidgetStyle {
  constructor(dataSource, enableSplitViewResizing) {
    super(dataSource);
    this.decorationsLeft = dataSource.getOriginalEditor().getLayoutInfo().decorationsLeft;
    this._register(dataSource.getOriginalEditor().onDidLayoutChange((layoutInfo) => {
      if (this.decorationsLeft !== layoutInfo.decorationsLeft) {
        this.decorationsLeft = layoutInfo.decorationsLeft;
        dataSource.relayoutEditors();
      }
    }));
  }
  setEnableSplitViewResizing(enableSplitViewResizing) {
  }
  _getViewZones(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators) {
    let computer = new InlineViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators);
    return computer.getViewZones();
  }
  _getOriginalEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
    const overviewZoneColor = String(this._removeColor);
    let result = {
      decorations: [],
      overviewZones: []
    };
    for (let i = 0, length = lineChanges.length; i < length; i++) {
      let lineChange = lineChanges[i];
      if (isChangeOrDelete(lineChange)) {
        result.decorations.push({
          range: new Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824),
          options: DECORATIONS.lineDeleteMargin
        });
        result.overviewZones.push(new OverviewRulerZone(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber, overviewZoneColor));
      }
    }
    return result;
  }
  _getModifiedEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
    const overviewZoneColor = String(this._insertColor);
    let result = {
      decorations: [],
      overviewZones: []
    };
    let modifiedModel = modifiedEditor.getModel();
    for (let i = 0, length = lineChanges.length; i < length; i++) {
      let lineChange = lineChanges[i];
      if (isChangeOrInsert(lineChange)) {
        result.decorations.push({
          range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824),
          options: renderIndicators ? DECORATIONS.lineInsertWithSign : DECORATIONS.lineInsert
        });
        result.overviewZones.push(new OverviewRulerZone(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber, overviewZoneColor));
        if (lineChange.charChanges) {
          for (let j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
            let charChange = lineChange.charChanges[j];
            if (isChangeOrInsert(charChange)) {
              if (ignoreTrimWhitespace) {
                for (let lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {
                  let startColumn;
                  let endColumn;
                  if (lineNumber === charChange.modifiedStartLineNumber) {
                    startColumn = charChange.modifiedStartColumn;
                  } else {
                    startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);
                  }
                  if (lineNumber === charChange.modifiedEndLineNumber) {
                    endColumn = charChange.modifiedEndColumn;
                  } else {
                    endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);
                  }
                  result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charInsert));
                }
              } else {
                result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, DECORATIONS.charInsert));
              }
            }
          }
        } else {
          result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824, DECORATIONS.charInsertWholeLine));
        }
      }
    }
    return result;
  }
  layout() {
    return Math.max(5, this.decorationsLeft);
  }
};
var InlineViewZonesComputer = class extends ViewZonesComputer {
  constructor(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators) {
    super(lineChanges, originalForeignVZ, originalEditor.getOption(51), modifiedForeignVZ, modifiedEditor.getOption(51));
    this.originalModel = originalEditor.getModel();
    this.modifiedEditorOptions = modifiedEditor.getOptions();
    this.modifiedEditorTabSize = modifiedEditor.getModel().getOptions().tabSize;
    this.renderIndicators = renderIndicators;
  }
  _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {
    let result = document.createElement("div");
    result.className = "inline-added-margin-view-zone";
    return result;
  }
  _produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
    let marginDomNode = document.createElement("div");
    marginDomNode.className = "inline-added-margin-view-zone";
    return {
      afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),
      heightInLines: lineChangeModifiedLength,
      domNode: document.createElement("div"),
      marginDomNode
    };
  }
  _produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
    let decorations = [];
    if (lineChange.charChanges) {
      for (let j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
        let charChange = lineChange.charChanges[j];
        if (isChangeOrDelete(charChange)) {
          decorations.push(new InlineDecoration(new Range(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn), "char-delete", 0));
        }
      }
    }
    let sb = createStringBuilder(1e4);
    let marginHTML = [];
    const layoutInfo = this.modifiedEditorOptions.get(117);
    const fontInfo = this.modifiedEditorOptions.get(36);
    const lineDecorationsWidth = layoutInfo.decorationsWidth;
    let lineHeight = this.modifiedEditorOptions.get(51);
    const typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;
    let maxCharsPerLine = 0;
    const originalContent = [];
    for (let lineNumber = lineChange.originalStartLineNumber; lineNumber <= lineChange.originalEndLineNumber; lineNumber++) {
      maxCharsPerLine = Math.max(maxCharsPerLine, this._renderOriginalLine(lineNumber - lineChange.originalStartLineNumber, this.originalModel, this.modifiedEditorOptions, this.modifiedEditorTabSize, lineNumber, decorations, sb));
      originalContent.push(this.originalModel.getLineContent(lineNumber));
      if (this.renderIndicators) {
        let index = lineNumber - lineChange.originalStartLineNumber;
        marginHTML = marginHTML.concat([
          `<div class="delete-sign ${diffRemoveIcon.classNames}" style="position:absolute;top:${index * lineHeight}px;width:${lineDecorationsWidth}px;height:${lineHeight}px;right:0;"></div>`
        ]);
      }
    }
    maxCharsPerLine += this.modifiedEditorOptions.get(85);
    let domNode = document.createElement("div");
    domNode.className = `view-lines line-delete ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`;
    domNode.innerHTML = sb.build();
    Configuration2.applyFontInfoSlow(domNode, fontInfo);
    let marginDomNode = document.createElement("div");
    marginDomNode.className = "inline-deleted-margin-view-zone";
    marginDomNode.innerHTML = marginHTML.join("");
    Configuration2.applyFontInfoSlow(marginDomNode, fontInfo);
    return {
      shouldNotShrink: true,
      afterLineNumber: lineChange.modifiedEndLineNumber === 0 ? lineChange.modifiedStartLineNumber : lineChange.modifiedStartLineNumber - 1,
      heightInLines: lineChangeOriginalLength,
      minWidthInPx: maxCharsPerLine * typicalHalfwidthCharacterWidth,
      domNode,
      marginDomNode,
      diff: {
        originalStartLineNumber: lineChange.originalStartLineNumber,
        originalEndLineNumber: lineChange.originalEndLineNumber,
        modifiedStartLineNumber: lineChange.modifiedStartLineNumber,
        modifiedEndLineNumber: lineChange.modifiedEndLineNumber,
        originalContent
      }
    };
  }
  _renderOriginalLine(count, originalModel, options, tabSize, lineNumber, decorations, sb) {
    const lineTokens = originalModel.getLineTokens(lineNumber);
    const lineContent = lineTokens.getLineContent();
    const fontInfo = options.get(36);
    const actualDecorations = LineDecoration.filter(decorations, lineNumber, 1, lineContent.length + 1);
    sb.appendASCIIString('<div class="view-line');
    if (decorations.length === 0) {
      sb.appendASCIIString(" char-delete");
    }
    sb.appendASCIIString('" style="top:');
    sb.appendASCIIString(String(count * options.get(51)));
    sb.appendASCIIString('px;width:1000000px;">');
    const isBasicASCII2 = ViewLineRenderingData.isBasicASCII(lineContent, originalModel.mightContainNonBasicASCII());
    const containsRTL2 = ViewLineRenderingData.containsRTL(lineContent, isBasicASCII2, originalModel.mightContainRTL());
    const output = renderViewLine(new RenderLineInput(fontInfo.isMonospace && !options.get(24), fontInfo.canUseHalfwidthRightwardsArrow, lineContent, false, isBasicASCII2, containsRTL2, 0, lineTokens, actualDecorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, options.get(95), options.get(80), options.get(74), options.get(37) !== EditorFontLigatures.OFF, null), sb);
    sb.appendASCIIString("</div>");
    const absoluteOffsets = output.characterMapping.getAbsoluteOffsets();
    return absoluteOffsets.length > 0 ? absoluteOffsets[absoluteOffsets.length - 1] : 0;
  }
};
function isChangeOrInsert(lineChange) {
  return lineChange.modifiedEndLineNumber > 0;
}
function isChangeOrDelete(lineChange) {
  return lineChange.originalEndLineNumber > 0;
}
function createFakeLinesDiv() {
  let r = document.createElement("div");
  r.className = "diagonal-fill";
  return r;
}
registerThemingParticipant((theme, collector) => {
  const added = theme.getColor(diffInserted);
  if (added) {
    collector.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { background-color: ${added}; }`);
    collector.addRule(`.monaco-diff-editor .line-insert, .monaco-diff-editor .char-insert { background-color: ${added}; }`);
    collector.addRule(`.monaco-editor .inline-added-margin-view-zone { background-color: ${added}; }`);
  }
  const removed = theme.getColor(diffRemoved);
  if (removed) {
    collector.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { background-color: ${removed}; }`);
    collector.addRule(`.monaco-diff-editor .line-delete, .monaco-diff-editor .char-delete { background-color: ${removed}; }`);
    collector.addRule(`.monaco-editor .inline-deleted-margin-view-zone { background-color: ${removed}; }`);
  }
  const addedOutline = theme.getColor(diffInsertedOutline);
  if (addedOutline) {
    collector.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { border: 1px ${theme.type === "hc" ? "dashed" : "solid"} ${addedOutline}; }`);
  }
  const removedOutline = theme.getColor(diffRemovedOutline);
  if (removedOutline) {
    collector.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { border: 1px ${theme.type === "hc" ? "dashed" : "solid"} ${removedOutline}; }`);
  }
  const shadow = theme.getColor(scrollbarShadow);
  if (shadow) {
    collector.addRule(`.monaco-diff-editor.side-by-side .editor.modified { box-shadow: -6px 0 5px -5px ${shadow}; }`);
  }
  const border = theme.getColor(diffBorder);
  if (border) {
    collector.addRule(`.monaco-diff-editor.side-by-side .editor.modified { border-left: 1px solid ${border}; }`);
  }
  const scrollbarSliderBackgroundColor = theme.getColor(scrollbarSliderBackground);
  if (scrollbarSliderBackgroundColor) {
    collector.addRule(`
			.monaco-diff-editor .diffViewport {
				background: ${scrollbarSliderBackgroundColor};
			}
		`);
  }
  const scrollbarSliderHoverBackgroundColor = theme.getColor(scrollbarSliderHoverBackground);
  if (scrollbarSliderHoverBackgroundColor) {
    collector.addRule(`
			.monaco-diff-editor .diffViewport:hover {
				background: ${scrollbarSliderHoverBackgroundColor};
			}
		`);
  }
  const scrollbarSliderActiveBackgroundColor = theme.getColor(scrollbarSliderActiveBackground);
  if (scrollbarSliderActiveBackgroundColor) {
    collector.addRule(`
			.monaco-diff-editor .diffViewport:active {
				background: ${scrollbarSliderActiveBackgroundColor};
			}
		`);
  }
  const diffDiagonalFillColor = theme.getColor(diffDiagonalFill);
  collector.addRule(`
	.monaco-editor .diagonal-fill {
		background-image: linear-gradient(
			-45deg,
			${diffDiagonalFillColor} 12.5%,
			#0000 12.5%, #0000 50%,
			${diffDiagonalFillColor} 50%, ${diffDiagonalFillColor} 62.5%,
			#0000 62.5%, #0000 100%
		);
		background-size: 8px 8px;
	}
	`);
});

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/common/standaloneThemeService.js
var IStandaloneThemeService = createDecorator("themeService");

// ../../node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybinding.js
var IKeybindingService = createDecorator("keybindingService");

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneCodeEditor.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var LAST_GENERATED_COMMAND_ID = 0;
var ariaDomNodeCreated = false;
function createAriaDomNode() {
  if (ariaDomNodeCreated) {
    return;
  }
  ariaDomNodeCreated = true;
  setARIAContainer(document.body);
}
var StandaloneCodeEditor = class StandaloneCodeEditor2 extends CodeEditorWidget {
  constructor(domElement, options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, accessibilityService) {
    options = options || {};
    options.ariaLabel = options.ariaLabel || StandaloneCodeEditorNLS.editorViewAccessibleLabel;
    options.ariaLabel = options.ariaLabel + ";" + StandaloneCodeEditorNLS.accessibilityHelpMessage;
    super(domElement, options, {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService);
    if (keybindingService instanceof StandaloneKeybindingService) {
      this._standaloneKeybindingService = keybindingService;
    } else {
      this._standaloneKeybindingService = null;
    }
    createAriaDomNode();
  }
  addCommand(keybinding, handler, context) {
    if (!this._standaloneKeybindingService) {
      console.warn("Cannot add command because the editor is configured with an unrecognized KeybindingService");
      return null;
    }
    let commandId = "DYNAMIC_" + ++LAST_GENERATED_COMMAND_ID;
    let whenExpression = ContextKeyExpr.deserialize(context);
    this._standaloneKeybindingService.addDynamicKeybinding(commandId, keybinding, handler, whenExpression);
    return commandId;
  }
  createContextKey(key, defaultValue) {
    return this._contextKeyService.createKey(key, defaultValue);
  }
  addAction(_descriptor) {
    if (typeof _descriptor.id !== "string" || typeof _descriptor.label !== "string" || typeof _descriptor.run !== "function") {
      throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
    }
    if (!this._standaloneKeybindingService) {
      console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService");
      return Disposable.None;
    }
    const id = _descriptor.id;
    const label = _descriptor.label;
    const precondition = ContextKeyExpr.and(ContextKeyExpr.equals("editorId", this.getId()), ContextKeyExpr.deserialize(_descriptor.precondition));
    const keybindings = _descriptor.keybindings;
    const keybindingsWhen = ContextKeyExpr.and(precondition, ContextKeyExpr.deserialize(_descriptor.keybindingContext));
    const contextMenuGroupId = _descriptor.contextMenuGroupId || null;
    const contextMenuOrder = _descriptor.contextMenuOrder || 0;
    const run = (accessor, ...args) => {
      return Promise.resolve(_descriptor.run(this, ...args));
    };
    const toDispose = new DisposableStore();
    const uniqueId = this.getId() + ":" + id;
    toDispose.add(CommandsRegistry.registerCommand(uniqueId, run));
    if (contextMenuGroupId) {
      let menuItem = {
        command: {
          id: uniqueId,
          title: label
        },
        when: precondition,
        group: contextMenuGroupId,
        order: contextMenuOrder
      };
      toDispose.add(MenuRegistry.appendMenuItem(MenuId.EditorContext, menuItem));
    }
    if (Array.isArray(keybindings)) {
      for (const kb of keybindings) {
        toDispose.add(this._standaloneKeybindingService.addDynamicKeybinding(uniqueId, kb, run, keybindingsWhen));
      }
    }
    let internalAction = new InternalEditorAction(uniqueId, label, label, precondition, run, this._contextKeyService);
    this._actions[id] = internalAction;
    toDispose.add(toDisposable(() => {
      delete this._actions[id];
    }));
    return toDispose;
  }
};
StandaloneCodeEditor = __decorate8([
  __param7(2, IInstantiationService),
  __param7(3, ICodeEditorService),
  __param7(4, ICommandService),
  __param7(5, IContextKeyService),
  __param7(6, IKeybindingService),
  __param7(7, IThemeService),
  __param7(8, INotificationService),
  __param7(9, IAccessibilityService)
], StandaloneCodeEditor);
var StandaloneEditor = class StandaloneEditor2 extends StandaloneCodeEditor {
  constructor(domElement, options, toDispose, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, contextViewService, themeService, notificationService, configurationService, accessibilityService) {
    applyConfigurationValues(configurationService, options, false);
    const themeDomRegistration = themeService.registerEditorContainer(domElement);
    options = options || {};
    if (typeof options.theme === "string") {
      themeService.setTheme(options.theme);
    }
    let _model = options.model;
    delete options.model;
    super(domElement, options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, accessibilityService);
    this._contextViewService = contextViewService;
    this._configurationService = configurationService;
    this._standaloneThemeService = themeService;
    this._register(toDispose);
    this._register(themeDomRegistration);
    let model2;
    if (typeof _model === "undefined") {
      model2 = self.monaco.editor.createModel(options.value || "", options.language || "text/plain");
      this._ownsModel = true;
    } else {
      model2 = _model;
      this._ownsModel = false;
    }
    this._attachModel(model2);
    if (model2) {
      let e = {
        oldModelUrl: null,
        newModelUrl: model2.uri
      };
      this._onDidChangeModel.fire(e);
    }
  }
  dispose() {
    super.dispose();
  }
  updateOptions(newOptions) {
    applyConfigurationValues(this._configurationService, newOptions, false);
    if (typeof newOptions.theme === "string") {
      this._standaloneThemeService.setTheme(newOptions.theme);
    }
    super.updateOptions(newOptions);
  }
  _attachModel(model2) {
    super._attachModel(model2);
    if (this._modelData) {
      this._contextViewService.setContainer(this._modelData.view.domNode.domNode);
    }
  }
  _postDetachModelCleanup(detachedModel) {
    super._postDetachModelCleanup(detachedModel);
    if (detachedModel && this._ownsModel) {
      detachedModel.dispose();
      this._ownsModel = false;
    }
  }
};
StandaloneEditor = __decorate8([
  __param7(3, IInstantiationService),
  __param7(4, ICodeEditorService),
  __param7(5, ICommandService),
  __param7(6, IContextKeyService),
  __param7(7, IKeybindingService),
  __param7(8, IContextViewService),
  __param7(9, IStandaloneThemeService),
  __param7(10, INotificationService),
  __param7(11, IConfigurationService),
  __param7(12, IAccessibilityService)
], StandaloneEditor);
var StandaloneDiffEditor = class StandaloneDiffEditor2 extends DiffEditorWidget {
  constructor(domElement, options, toDispose, instantiationService, contextKeyService, keybindingService, contextViewService, editorWorkerService, codeEditorService, themeService, notificationService, configurationService, contextMenuService, editorProgressService, clipboardService) {
    applyConfigurationValues(configurationService, options, true);
    const themeDomRegistration = themeService.registerEditorContainer(domElement);
    options = options || {};
    if (typeof options.theme === "string") {
      options.theme = themeService.setTheme(options.theme);
    }
    super(domElement, options, clipboardService, editorWorkerService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService, contextMenuService, editorProgressService);
    this._contextViewService = contextViewService;
    this._configurationService = configurationService;
    this._standaloneThemeService = themeService;
    this._register(toDispose);
    this._register(themeDomRegistration);
    this._contextViewService.setContainer(this._containerDomElement);
  }
  dispose() {
    super.dispose();
  }
  updateOptions(newOptions) {
    applyConfigurationValues(this._configurationService, newOptions, true);
    if (typeof newOptions.theme === "string") {
      this._standaloneThemeService.setTheme(newOptions.theme);
    }
    super.updateOptions(newOptions);
  }
  _createInnerEditor(instantiationService, container, options) {
    return instantiationService.createInstance(StandaloneCodeEditor, container, options);
  }
  getOriginalEditor() {
    return super.getOriginalEditor();
  }
  getModifiedEditor() {
    return super.getModifiedEditor();
  }
  addCommand(keybinding, handler, context) {
    return this.getModifiedEditor().addCommand(keybinding, handler, context);
  }
  createContextKey(key, defaultValue) {
    return this.getModifiedEditor().createContextKey(key, defaultValue);
  }
  addAction(descriptor) {
    return this.getModifiedEditor().addAction(descriptor);
  }
};
StandaloneDiffEditor = __decorate8([
  __param7(3, IInstantiationService),
  __param7(4, IContextKeyService),
  __param7(5, IKeybindingService),
  __param7(6, IContextViewService),
  __param7(7, IEditorWorkerService),
  __param7(8, ICodeEditorService),
  __param7(9, IStandaloneThemeService),
  __param7(10, INotificationService),
  __param7(11, IConfigurationService),
  __param7(12, IContextMenuService),
  __param7(13, IEditorProgressService),
  __param7(14, IClipboardService)
], StandaloneDiffEditor);

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/modeService.js
var IModeService = createDecorator("modeService");

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/abstractMode.js
var FrankensteinMode = class {
  constructor(languageIdentifier) {
    this._languageIdentifier = languageIdentifier;
  }
  getId() {
    return this._languageIdentifier.language;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/mime.js
var MIME_TEXT = "text/plain";
var MIME_UNKNOWN = "application/unknown";
var registeredAssociations = [];
var nonUserRegisteredAssociations = [];
var userRegisteredAssociations = [];
function registerTextMime(association, warnOnOverwrite = false) {
  const associationItem = toTextMimeAssociationItem(association);
  registeredAssociations.push(associationItem);
  if (!associationItem.userConfigured) {
    nonUserRegisteredAssociations.push(associationItem);
  } else {
    userRegisteredAssociations.push(associationItem);
  }
  if (warnOnOverwrite && !associationItem.userConfigured) {
    registeredAssociations.forEach((a) => {
      if (a.mime === associationItem.mime || a.userConfigured) {
        return;
      }
      if (associationItem.extension && a.extension === associationItem.extension) {
        console.warn(`Overwriting extension <<${associationItem.extension}>> to now point to mime <<${associationItem.mime}>>`);
      }
      if (associationItem.filename && a.filename === associationItem.filename) {
        console.warn(`Overwriting filename <<${associationItem.filename}>> to now point to mime <<${associationItem.mime}>>`);
      }
      if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {
        console.warn(`Overwriting filepattern <<${associationItem.filepattern}>> to now point to mime <<${associationItem.mime}>>`);
      }
      if (associationItem.firstline && a.firstline === associationItem.firstline) {
        console.warn(`Overwriting firstline <<${associationItem.firstline}>> to now point to mime <<${associationItem.mime}>>`);
      }
    });
  }
}
function toTextMimeAssociationItem(association) {
  return {
    id: association.id,
    mime: association.mime,
    filename: association.filename,
    extension: association.extension,
    filepattern: association.filepattern,
    firstline: association.firstline,
    userConfigured: association.userConfigured,
    filenameLowercase: association.filename ? association.filename.toLowerCase() : void 0,
    extensionLowercase: association.extension ? association.extension.toLowerCase() : void 0,
    filepatternLowercase: association.filepattern ? association.filepattern.toLowerCase() : void 0,
    filepatternOnPath: association.filepattern ? association.filepattern.indexOf(posix.sep) >= 0 : false
  };
}
function guessMimeTypes(resource, firstLine) {
  let path;
  if (resource) {
    switch (resource.scheme) {
      case Schemas.file:
        path = resource.fsPath;
        break;
      case Schemas.data:
        const metadata = DataUri.parseMetaData(resource);
        path = metadata.get(DataUri.META_DATA_LABEL);
        break;
      default:
        path = resource.path;
    }
  }
  if (!path) {
    return [MIME_UNKNOWN];
  }
  path = path.toLowerCase();
  const filename = basename(path);
  const configuredMime = guessMimeTypeByPath(path, filename, userRegisteredAssociations);
  if (configuredMime) {
    return [configuredMime, MIME_TEXT];
  }
  const registeredMime = guessMimeTypeByPath(path, filename, nonUserRegisteredAssociations);
  if (registeredMime) {
    return [registeredMime, MIME_TEXT];
  }
  if (firstLine) {
    const firstlineMime = guessMimeTypeByFirstline(firstLine);
    if (firstlineMime) {
      return [firstlineMime, MIME_TEXT];
    }
  }
  return [MIME_UNKNOWN];
}
function guessMimeTypeByPath(path, filename, associations) {
  let filenameMatch = null;
  let patternMatch = null;
  let extensionMatch = null;
  for (let i = associations.length - 1; i >= 0; i--) {
    const association = associations[i];
    if (filename === association.filenameLowercase) {
      filenameMatch = association;
      break;
    }
    if (association.filepattern) {
      if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {
        const target = association.filepatternOnPath ? path : filename;
        if (match(association.filepatternLowercase, target)) {
          patternMatch = association;
        }
      }
    }
    if (association.extension) {
      if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {
        if (filename.endsWith(association.extensionLowercase)) {
          extensionMatch = association;
        }
      }
    }
  }
  if (filenameMatch) {
    return filenameMatch.mime;
  }
  if (patternMatch) {
    return patternMatch.mime;
  }
  if (extensionMatch) {
    return extensionMatch.mime;
  }
  return null;
}
function guessMimeTypeByFirstline(firstLine) {
  if (startsWithUTF8BOM(firstLine)) {
    firstLine = firstLine.substr(1);
  }
  if (firstLine.length > 0) {
    for (let i = registeredAssociations.length - 1; i >= 0; i--) {
      const association = registeredAssociations[i];
      if (!association.firstline) {
        continue;
      }
      const matches = firstLine.match(association.firstline);
      if (matches && matches.length > 0) {
        return association.mime;
      }
    }
  }
  return null;
}

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/modesRegistry.js
var Extensions7 = {
  ModesRegistry: "editor.modesRegistry"
};
var EditorModesRegistry = class {
  constructor() {
    this._onDidChangeLanguages = new Emitter();
    this.onDidChangeLanguages = this._onDidChangeLanguages.event;
    this._languages = [];
    this._dynamicLanguages = [];
  }
  registerLanguage(def) {
    this._languages.push(def);
    this._onDidChangeLanguages.fire(void 0);
    return {
      dispose: () => {
        for (let i = 0, len = this._languages.length; i < len; i++) {
          if (this._languages[i] === def) {
            this._languages.splice(i, 1);
            return;
          }
        }
      }
    };
  }
  getLanguages() {
    return [].concat(this._languages).concat(this._dynamicLanguages);
  }
};
var ModesRegistry = new EditorModesRegistry();
Registry2.add(Extensions7.ModesRegistry, ModesRegistry);
var PLAINTEXT_MODE_ID = "plaintext";
var PLAINTEXT_LANGUAGE_IDENTIFIER = new LanguageIdentifier(PLAINTEXT_MODE_ID, 1);
ModesRegistry.registerLanguage({
  id: PLAINTEXT_MODE_ID,
  extensions: [".txt"],
  aliases: [localize("plainText.alias", "Plain Text"), "text"],
  mimetypes: ["text/plain"]
});
LanguageConfigurationRegistry.register(PLAINTEXT_LANGUAGE_IDENTIFIER, {
  brackets: [
    ["(", ")"],
    ["[", "]"],
    ["{", "}"]
  ],
  surroundingPairs: [
    {open: "{", close: "}"},
    {open: "[", close: "]"},
    {open: "(", close: ")"},
    {open: "<", close: ">"},
    {open: '"', close: '"'},
    {open: "'", close: "'"},
    {open: "`", close: "`"}
  ],
  folding: {
    offSide: true
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js
var hasOwnProperty4 = Object.prototype.hasOwnProperty;
var LanguagesRegistry = class extends Disposable {
  constructor(useModesRegistry = true, warnOnOverwrite = false) {
    super();
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._warnOnOverwrite = warnOnOverwrite;
    this._nextLanguageId2 = 1;
    this._languageIdToLanguage = [];
    this._languageToLanguageId = Object.create(null);
    this._languages = {};
    this._mimeTypesMap = {};
    this._nameMap = {};
    this._lowercaseNameMap = {};
    if (useModesRegistry) {
      this._initializeFromRegistry();
      this._register(ModesRegistry.onDidChangeLanguages((m) => this._initializeFromRegistry()));
    }
  }
  _initializeFromRegistry() {
    this._languages = {};
    this._mimeTypesMap = {};
    this._nameMap = {};
    this._lowercaseNameMap = {};
    const desc = ModesRegistry.getLanguages();
    this._registerLanguages(desc);
  }
  _registerLanguages(desc) {
    for (const d of desc) {
      this._registerLanguage(d);
    }
    this._mimeTypesMap = {};
    this._nameMap = {};
    this._lowercaseNameMap = {};
    Object.keys(this._languages).forEach((langId) => {
      let language = this._languages[langId];
      if (language.name) {
        this._nameMap[language.name] = language.identifier;
      }
      language.aliases.forEach((alias) => {
        this._lowercaseNameMap[alias.toLowerCase()] = language.identifier;
      });
      language.mimetypes.forEach((mimetype) => {
        this._mimeTypesMap[mimetype] = language.identifier;
      });
    });
    Registry2.as(Extensions2.Configuration).registerOverrideIdentifiers(ModesRegistry.getLanguages().map((language) => language.id));
    this._onDidChange.fire();
  }
  _getLanguageId(language) {
    if (this._languageToLanguageId[language]) {
      return this._languageToLanguageId[language];
    }
    const languageId = this._nextLanguageId2++;
    this._languageIdToLanguage[languageId] = language;
    this._languageToLanguageId[language] = languageId;
    return languageId;
  }
  _registerLanguage(lang) {
    const langId = lang.id;
    let resolvedLanguage;
    if (hasOwnProperty4.call(this._languages, langId)) {
      resolvedLanguage = this._languages[langId];
    } else {
      const languageId = this._getLanguageId(langId);
      resolvedLanguage = {
        identifier: new LanguageIdentifier(langId, languageId),
        name: null,
        mimetypes: [],
        aliases: [],
        extensions: [],
        filenames: [],
        configurationFiles: []
      };
      this._languages[langId] = resolvedLanguage;
    }
    this._mergeLanguage(resolvedLanguage, lang);
  }
  _mergeLanguage(resolvedLanguage, lang) {
    const langId = lang.id;
    let primaryMime = null;
    if (Array.isArray(lang.mimetypes) && lang.mimetypes.length > 0) {
      resolvedLanguage.mimetypes.push(...lang.mimetypes);
      primaryMime = lang.mimetypes[0];
    }
    if (!primaryMime) {
      primaryMime = `text/x-${langId}`;
      resolvedLanguage.mimetypes.push(primaryMime);
    }
    if (Array.isArray(lang.extensions)) {
      if (lang.configuration) {
        resolvedLanguage.extensions = lang.extensions.concat(resolvedLanguage.extensions);
      } else {
        resolvedLanguage.extensions = resolvedLanguage.extensions.concat(lang.extensions);
      }
      for (let extension of lang.extensions) {
        registerTextMime({id: langId, mime: primaryMime, extension}, this._warnOnOverwrite);
      }
    }
    if (Array.isArray(lang.filenames)) {
      for (let filename of lang.filenames) {
        registerTextMime({id: langId, mime: primaryMime, filename}, this._warnOnOverwrite);
        resolvedLanguage.filenames.push(filename);
      }
    }
    if (Array.isArray(lang.filenamePatterns)) {
      for (let filenamePattern of lang.filenamePatterns) {
        registerTextMime({id: langId, mime: primaryMime, filepattern: filenamePattern}, this._warnOnOverwrite);
      }
    }
    if (typeof lang.firstLine === "string" && lang.firstLine.length > 0) {
      let firstLineRegexStr = lang.firstLine;
      if (firstLineRegexStr.charAt(0) !== "^") {
        firstLineRegexStr = "^" + firstLineRegexStr;
      }
      try {
        let firstLineRegex = new RegExp(firstLineRegexStr);
        if (!regExpLeadsToEndlessLoop(firstLineRegex)) {
          registerTextMime({id: langId, mime: primaryMime, firstline: firstLineRegex}, this._warnOnOverwrite);
        }
      } catch (err) {
        onUnexpectedError(err);
      }
    }
    resolvedLanguage.aliases.push(langId);
    let langAliases = null;
    if (typeof lang.aliases !== "undefined" && Array.isArray(lang.aliases)) {
      if (lang.aliases.length === 0) {
        langAliases = [null];
      } else {
        langAliases = lang.aliases;
      }
    }
    if (langAliases !== null) {
      for (const langAlias of langAliases) {
        if (!langAlias || langAlias.length === 0) {
          continue;
        }
        resolvedLanguage.aliases.push(langAlias);
      }
    }
    let containsAliases = langAliases !== null && langAliases.length > 0;
    if (containsAliases && langAliases[0] === null) {
    } else {
      let bestName = (containsAliases ? langAliases[0] : null) || langId;
      if (containsAliases || !resolvedLanguage.name) {
        resolvedLanguage.name = bestName;
      }
    }
    if (lang.configuration) {
      resolvedLanguage.configurationFiles.push(lang.configuration);
    }
  }
  isRegisteredMode(mimetypeOrModeId) {
    if (hasOwnProperty4.call(this._mimeTypesMap, mimetypeOrModeId)) {
      return true;
    }
    return hasOwnProperty4.call(this._languages, mimetypeOrModeId);
  }
  getModeIdForLanguageNameLowercase(languageNameLower) {
    if (!hasOwnProperty4.call(this._lowercaseNameMap, languageNameLower)) {
      return null;
    }
    return this._lowercaseNameMap[languageNameLower].language;
  }
  extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds) {
    if (!commaSeparatedMimetypesOrCommaSeparatedIds) {
      return [];
    }
    return commaSeparatedMimetypesOrCommaSeparatedIds.split(",").map((mimeTypeOrId) => mimeTypeOrId.trim()).map((mimeTypeOrId) => {
      if (hasOwnProperty4.call(this._mimeTypesMap, mimeTypeOrId)) {
        return this._mimeTypesMap[mimeTypeOrId].language;
      }
      return mimeTypeOrId;
    }).filter((modeId) => {
      return hasOwnProperty4.call(this._languages, modeId);
    });
  }
  getLanguageIdentifier(_modeId) {
    if (_modeId === NULL_MODE_ID || _modeId === 0) {
      return NULL_LANGUAGE_IDENTIFIER;
    }
    let modeId;
    if (typeof _modeId === "string") {
      modeId = _modeId;
    } else {
      modeId = this._languageIdToLanguage[_modeId];
      if (!modeId) {
        return null;
      }
    }
    if (!hasOwnProperty4.call(this._languages, modeId)) {
      return null;
    }
    return this._languages[modeId].identifier;
  }
  getModeIdsFromFilepathOrFirstLine(resource, firstLine) {
    if (!resource && !firstLine) {
      return [];
    }
    let mimeTypes = guessMimeTypes(resource, firstLine);
    return this.extractModeIds(mimeTypes.join(","));
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/modeServiceImpl.js
var LanguageSelection = class extends Disposable {
  constructor(onLanguagesMaybeChanged, selector) {
    super();
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._selector = selector;
    this.languageIdentifier = this._selector();
    this._register(onLanguagesMaybeChanged(() => this._evaluate()));
  }
  _evaluate() {
    let languageIdentifier = this._selector();
    if (languageIdentifier.id === this.languageIdentifier.id) {
      return;
    }
    this.languageIdentifier = languageIdentifier;
    this._onDidChange.fire(this.languageIdentifier);
  }
};
var ModeServiceImpl = class {
  constructor(warnOnOverwrite = false) {
    this._onDidCreateMode = new Emitter();
    this.onDidCreateMode = this._onDidCreateMode.event;
    this._onLanguagesMaybeChanged = new Emitter();
    this.onLanguagesMaybeChanged = this._onLanguagesMaybeChanged.event;
    this._instantiatedModes = {};
    this._registry = new LanguagesRegistry(true, warnOnOverwrite);
    this._registry.onDidChange(() => this._onLanguagesMaybeChanged.fire());
  }
  isRegisteredMode(mimetypeOrModeId) {
    return this._registry.isRegisteredMode(mimetypeOrModeId);
  }
  getModeIdForLanguageName(alias) {
    return this._registry.getModeIdForLanguageNameLowercase(alias);
  }
  getModeIdByFilepathOrFirstLine(resource, firstLine) {
    const modeIds = this._registry.getModeIdsFromFilepathOrFirstLine(resource, firstLine);
    return firstOrDefault(modeIds, null);
  }
  getModeId(commaSeparatedMimetypesOrCommaSeparatedIds) {
    const modeIds = this._registry.extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds);
    return firstOrDefault(modeIds, null);
  }
  getLanguageIdentifier(modeId) {
    return this._registry.getLanguageIdentifier(modeId);
  }
  create(commaSeparatedMimetypesOrCommaSeparatedIds) {
    return new LanguageSelection(this.onLanguagesMaybeChanged, () => {
      const modeId = this.getModeId(commaSeparatedMimetypesOrCommaSeparatedIds);
      return this._createModeAndGetLanguageIdentifier(modeId);
    });
  }
  createByFilepathOrFirstLine(resource, firstLine) {
    return new LanguageSelection(this.onLanguagesMaybeChanged, () => {
      const modeId = this.getModeIdByFilepathOrFirstLine(resource, firstLine);
      return this._createModeAndGetLanguageIdentifier(modeId);
    });
  }
  _createModeAndGetLanguageIdentifier(modeId) {
    const languageIdentifier = this.getLanguageIdentifier(modeId || "plaintext") || NULL_LANGUAGE_IDENTIFIER;
    this._getOrCreateMode(languageIdentifier.language);
    return languageIdentifier;
  }
  triggerMode(commaSeparatedMimetypesOrCommaSeparatedIds) {
    const modeId = this.getModeId(commaSeparatedMimetypesOrCommaSeparatedIds);
    this._getOrCreateMode(modeId || "plaintext");
  }
  _getOrCreateMode(modeId) {
    if (!this._instantiatedModes.hasOwnProperty(modeId)) {
      let languageIdentifier = this.getLanguageIdentifier(modeId) || NULL_LANGUAGE_IDENTIFIER;
      this._instantiatedModes[modeId] = new FrankensteinMode(languageIdentifier);
      this._onDidCreateMode.fire(this._instantiatedModes[modeId]);
    }
    return this._instantiatedModes[modeId];
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js
var IUndoRedoService = createDecorator("undoRedoService");
var ResourceEditStackSnapshot = class {
  constructor(resource, elements) {
    this.resource = resource;
    this.elements = elements;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js
var SemanticTokensProviderStyling = class {
  constructor(_legend, _themeService, _logService) {
    this._legend = _legend;
    this._themeService = _themeService;
    this._logService = _logService;
    this._hashTable = new HashTable();
  }
  getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {
    const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, languageId.id);
    let metadata;
    if (entry) {
      metadata = entry.metadata;
      if (this._logService.getLevel() === LogLevel.Trace) {
        this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);
      }
    } else {
      let tokenType = this._legend.tokenTypes[tokenTypeIndex];
      const tokenModifiers = [];
      if (tokenType) {
        let modifierSet = tokenModifierSet;
        for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {
          if (modifierSet & 1) {
            tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);
          }
          modifierSet = modifierSet >> 1;
        }
        if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {
          this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);
          tokenModifiers.push("not-in-legend");
        }
        const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId.language);
        if (typeof tokenStyle === "undefined") {
          metadata = 2147483647;
        } else {
          metadata = 0;
          if (typeof tokenStyle.italic !== "undefined") {
            const italicBit = (tokenStyle.italic ? 1 : 0) << 11;
            metadata |= italicBit | 1;
          }
          if (typeof tokenStyle.bold !== "undefined") {
            const boldBit = (tokenStyle.bold ? 2 : 0) << 11;
            metadata |= boldBit | 2;
          }
          if (typeof tokenStyle.underline !== "undefined") {
            const underlineBit = (tokenStyle.underline ? 4 : 0) << 11;
            metadata |= underlineBit | 4;
          }
          if (tokenStyle.foreground) {
            const foregroundBits = tokenStyle.foreground << 14;
            metadata |= foregroundBits | 8;
          }
          if (metadata === 0) {
            metadata = 2147483647;
          }
        }
      } else {
        if (this._logService.getLevel() === LogLevel.Trace) {
          this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);
        }
        metadata = 2147483647;
        tokenType = "not-in-legend";
      }
      this._hashTable.add(tokenTypeIndex, tokenModifierSet, languageId.id, metadata);
      if (this._logService.getLevel() === LogLevel.Trace) {
        this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(" ")}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);
      }
    }
    return metadata;
  }
};
function toMultilineTokens2(tokens, styling, languageId) {
  const srcData = tokens.data;
  const tokenCount = tokens.data.length / 5 | 0;
  const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024), 400);
  const result = [];
  let tokenIndex = 0;
  let lastLineNumber = 1;
  let lastStartCharacter = 0;
  while (tokenIndex < tokenCount) {
    const tokenStartIndex = tokenIndex;
    let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);
    if (tokenEndIndex < tokenCount) {
      let smallTokenEndIndex = tokenEndIndex;
      while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {
        smallTokenEndIndex--;
      }
      if (smallTokenEndIndex - 1 === tokenStartIndex) {
        let bigTokenEndIndex = tokenEndIndex;
        while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {
          bigTokenEndIndex++;
        }
        tokenEndIndex = bigTokenEndIndex;
      } else {
        tokenEndIndex = smallTokenEndIndex;
      }
    }
    let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);
    let destOffset = 0;
    let areaLine = 0;
    while (tokenIndex < tokenEndIndex) {
      const srcOffset = 5 * tokenIndex;
      const deltaLine = srcData[srcOffset];
      const deltaCharacter = srcData[srcOffset + 1];
      const lineNumber = lastLineNumber + deltaLine;
      const startCharacter = deltaLine === 0 ? lastStartCharacter + deltaCharacter : deltaCharacter;
      const length = srcData[srcOffset + 2];
      const tokenTypeIndex = srcData[srcOffset + 3];
      const tokenModifierSet = srcData[srcOffset + 4];
      const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);
      if (metadata !== 2147483647) {
        if (areaLine === 0) {
          areaLine = lineNumber;
        }
        destData[destOffset] = lineNumber - areaLine;
        destData[destOffset + 1] = startCharacter;
        destData[destOffset + 2] = startCharacter + length;
        destData[destOffset + 3] = metadata;
        destOffset += 4;
      }
      lastLineNumber = lineNumber;
      lastStartCharacter = startCharacter;
      tokenIndex++;
    }
    if (destOffset !== destData.length) {
      destData = destData.subarray(0, destOffset);
    }
    const tokens2 = new MultilineTokens2(areaLine, new SparseEncodedTokens(destData));
    result.push(tokens2);
  }
  return result;
}
var HashTableEntry = class {
  constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {
    this.tokenTypeIndex = tokenTypeIndex;
    this.tokenModifierSet = tokenModifierSet;
    this.languageId = languageId;
    this.metadata = metadata;
    this.next = null;
  }
};
var HashTable = class {
  constructor() {
    this._elementsCount = 0;
    this._currentLengthIndex = 0;
    this._currentLength = HashTable._SIZES[this._currentLengthIndex];
    this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);
    this._elements = [];
    HashTable._nullOutEntries(this._elements, this._currentLength);
  }
  static _nullOutEntries(entries, length) {
    for (let i = 0; i < length; i++) {
      entries[i] = null;
    }
  }
  _hash2(n1, n2) {
    return (n1 << 5) - n1 + n2 | 0;
  }
  _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {
    return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;
  }
  get(tokenTypeIndex, tokenModifierSet, languageId) {
    const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);
    let p = this._elements[hash];
    while (p) {
      if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {
        return p;
      }
      p = p.next;
    }
    return null;
  }
  add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {
    this._elementsCount++;
    if (this._growCount !== 0 && this._elementsCount >= this._growCount) {
      const oldElements = this._elements;
      this._currentLengthIndex++;
      this._currentLength = HashTable._SIZES[this._currentLengthIndex];
      this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);
      this._elements = [];
      HashTable._nullOutEntries(this._elements, this._currentLength);
      for (const first2 of oldElements) {
        let p = first2;
        while (p) {
          const oldNext = p.next;
          p.next = null;
          this._add(p);
          p = oldNext;
        }
      }
    }
    this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));
  }
  _add(element) {
    const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);
    element.next = this._elements[hash];
    this._elements[hash] = element;
  }
};
HashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/modelServiceImpl.js
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function MODEL_ID2(resource) {
  return resource.toString();
}
function computeModelSha1(model2) {
  const shaComputer = new StringSHA1();
  const snapshot = model2.createSnapshot();
  let text;
  while (text = snapshot.read()) {
    shaComputer.update(text);
  }
  return shaComputer.digest();
}
var ModelData2 = class {
  constructor(model2, onWillDispose, onDidChangeLanguage) {
    this._modelEventListeners = new DisposableStore();
    this.model = model2;
    this._languageSelection = null;
    this._languageSelectionListener = null;
    this._modelEventListeners.add(model2.onWillDispose(() => onWillDispose(model2)));
    this._modelEventListeners.add(model2.onDidChangeLanguage((e) => onDidChangeLanguage(model2, e)));
  }
  _disposeLanguageSelection() {
    if (this._languageSelectionListener) {
      this._languageSelectionListener.dispose();
      this._languageSelectionListener = null;
    }
    if (this._languageSelection) {
      this._languageSelection.dispose();
      this._languageSelection = null;
    }
  }
  dispose() {
    this._modelEventListeners.dispose();
    this._disposeLanguageSelection();
  }
  setLanguage(languageSelection) {
    this._disposeLanguageSelection();
    this._languageSelection = languageSelection;
    this._languageSelectionListener = this._languageSelection.onDidChange(() => this.model.setMode(languageSelection.languageIdentifier));
    this.model.setMode(languageSelection.languageIdentifier);
  }
};
var DEFAULT_EOL = isLinux || isMacintosh ? 1 : 2;
var ModelServiceImpl = class ModelServiceImpl2 extends Disposable {
  constructor(_configurationService, _resourcePropertiesService, _themeService, _logService, _undoRedoService) {
    super();
    this._configurationService = _configurationService;
    this._resourcePropertiesService = _resourcePropertiesService;
    this._themeService = _themeService;
    this._logService = _logService;
    this._undoRedoService = _undoRedoService;
    this._onModelAdded = this._register(new Emitter());
    this.onModelAdded = this._onModelAdded.event;
    this._onModelRemoved = this._register(new Emitter());
    this.onModelRemoved = this._onModelRemoved.event;
    this._onModelModeChanged = this._register(new Emitter());
    this.onModelModeChanged = this._onModelModeChanged.event;
    this._modelCreationOptionsByLanguageAndResource = Object.create(null);
    this._models = {};
    this._disposedModels = new Map();
    this._disposedModelsHeapSize = 0;
    this._semanticStyling = this._register(new SemanticStyling(this._themeService, this._logService));
    this._register(this._configurationService.onDidChangeConfiguration(() => this._updateModelOptions()));
    this._updateModelOptions();
    this._register(new SemanticColoringFeature(this, this._themeService, this._configurationService, this._semanticStyling));
  }
  static _readModelOptions(config, isForSimpleWidget) {
    let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;
    if (config.editor && typeof config.editor.tabSize !== "undefined") {
      const parsedTabSize = parseInt(config.editor.tabSize, 10);
      if (!isNaN(parsedTabSize)) {
        tabSize = parsedTabSize;
      }
      if (tabSize < 1) {
        tabSize = 1;
      }
    }
    let indentSize = tabSize;
    if (config.editor && typeof config.editor.indentSize !== "undefined" && config.editor.indentSize !== "tabSize") {
      const parsedIndentSize = parseInt(config.editor.indentSize, 10);
      if (!isNaN(parsedIndentSize)) {
        indentSize = parsedIndentSize;
      }
      if (indentSize < 1) {
        indentSize = 1;
      }
    }
    let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;
    if (config.editor && typeof config.editor.insertSpaces !== "undefined") {
      insertSpaces = config.editor.insertSpaces === "false" ? false : Boolean(config.editor.insertSpaces);
    }
    let newDefaultEOL = DEFAULT_EOL;
    const eol = config.eol;
    if (eol === "\r\n") {
      newDefaultEOL = 2;
    } else if (eol === "\n") {
      newDefaultEOL = 1;
    }
    let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;
    if (config.editor && typeof config.editor.trimAutoWhitespace !== "undefined") {
      trimAutoWhitespace = config.editor.trimAutoWhitespace === "false" ? false : Boolean(config.editor.trimAutoWhitespace);
    }
    let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;
    if (config.editor && typeof config.editor.detectIndentation !== "undefined") {
      detectIndentation = config.editor.detectIndentation === "false" ? false : Boolean(config.editor.detectIndentation);
    }
    let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;
    if (config.editor && typeof config.editor.largeFileOptimizations !== "undefined") {
      largeFileOptimizations = config.editor.largeFileOptimizations === "false" ? false : Boolean(config.editor.largeFileOptimizations);
    }
    return {
      isForSimpleWidget,
      tabSize,
      indentSize,
      insertSpaces,
      detectIndentation,
      defaultEOL: newDefaultEOL,
      trimAutoWhitespace,
      largeFileOptimizations
    };
  }
  _getEOL(resource, language) {
    if (resource) {
      return this._resourcePropertiesService.getEOL(resource, language);
    }
    const eol = this._configurationService.getValue("files.eol", {overrideIdentifier: language});
    if (eol && eol !== "auto") {
      return eol;
    }
    return OS === 3 || OS === 2 ? "\n" : "\r\n";
  }
  getCreationOptions(language, resource, isForSimpleWidget) {
    let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];
    if (!creationOptions) {
      const editor2 = this._configurationService.getValue("editor", {overrideIdentifier: language, resource});
      const eol = this._getEOL(resource, language);
      creationOptions = ModelServiceImpl2._readModelOptions({editor: editor2, eol}, isForSimpleWidget);
      this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;
    }
    return creationOptions;
  }
  _updateModelOptions() {
    const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;
    this._modelCreationOptionsByLanguageAndResource = Object.create(null);
    const keys = Object.keys(this._models);
    for (let i = 0, len = keys.length; i < len; i++) {
      const modelId = keys[i];
      const modelData = this._models[modelId];
      const language = modelData.model.getLanguageIdentifier().language;
      const uri = modelData.model.uri;
      const oldOptions = oldOptionsByLanguageAndResource[language + uri];
      const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);
      ModelServiceImpl2._setModelOptionsForModel(modelData.model, newOptions, oldOptions);
    }
  }
  static _setModelOptionsForModel(model2, newOptions, currentOptions) {
    if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model2.getLineCount() === 1) {
      model2.setEOL(newOptions.defaultEOL === 1 ? 0 : 1);
    }
    if (currentOptions && currentOptions.detectIndentation === newOptions.detectIndentation && currentOptions.insertSpaces === newOptions.insertSpaces && currentOptions.tabSize === newOptions.tabSize && currentOptions.indentSize === newOptions.indentSize && currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace) {
      return;
    }
    if (newOptions.detectIndentation) {
      model2.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);
      model2.updateOptions({
        trimAutoWhitespace: newOptions.trimAutoWhitespace
      });
    } else {
      model2.updateOptions({
        insertSpaces: newOptions.insertSpaces,
        tabSize: newOptions.tabSize,
        indentSize: newOptions.indentSize,
        trimAutoWhitespace: newOptions.trimAutoWhitespace
      });
    }
  }
  _removeDisposedModel(resource) {
    const disposedModelData = this._disposedModels.get(MODEL_ID2(resource));
    if (disposedModelData) {
      this._disposedModelsHeapSize -= disposedModelData.heapSize;
    }
    this._disposedModels.delete(MODEL_ID2(resource));
    return disposedModelData;
  }
  _createModelData(value, languageIdentifier, resource, isForSimpleWidget) {
    const options = this.getCreationOptions(languageIdentifier.language, resource, isForSimpleWidget);
    const model2 = new TextModel(value, options, languageIdentifier, resource, this._undoRedoService);
    if (resource && this._disposedModels.has(MODEL_ID2(resource))) {
      const disposedModelData = this._removeDisposedModel(resource);
      const elements = this._undoRedoService.getElements(resource);
      const sha1IsEqual = computeModelSha1(model2) === disposedModelData.sha1;
      if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {
        for (const element of elements.past) {
          if (isEditStackElement(element) && element.matchesResource(resource)) {
            element.setModel(model2);
          }
        }
        for (const element of elements.future) {
          if (isEditStackElement(element) && element.matchesResource(resource)) {
            element.setModel(model2);
          }
        }
        this._undoRedoService.setElementsValidFlag(resource, true, (element) => isEditStackElement(element) && element.matchesResource(resource));
        if (sha1IsEqual) {
          model2._overwriteVersionId(disposedModelData.versionId);
          model2._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);
          model2._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);
        }
      } else {
        if (disposedModelData.initialUndoRedoSnapshot !== null) {
          this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);
        }
      }
    }
    const modelId = MODEL_ID2(model2.uri);
    if (this._models[modelId]) {
      throw new Error("ModelService: Cannot add model because it already exists!");
    }
    const modelData = new ModelData2(model2, (model3) => this._onWillDispose(model3), (model3, e) => this._onDidChangeLanguage(model3, e));
    this._models[modelId] = modelData;
    return modelData;
  }
  createModel(value, languageSelection, resource, isForSimpleWidget = false) {
    let modelData;
    if (languageSelection) {
      modelData = this._createModelData(value, languageSelection.languageIdentifier, resource, isForSimpleWidget);
      this.setMode(modelData.model, languageSelection);
    } else {
      modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_IDENTIFIER, resource, isForSimpleWidget);
    }
    this._onModelAdded.fire(modelData.model);
    return modelData.model;
  }
  setMode(model2, languageSelection) {
    if (!languageSelection) {
      return;
    }
    const modelData = this._models[MODEL_ID2(model2.uri)];
    if (!modelData) {
      return;
    }
    modelData.setLanguage(languageSelection);
  }
  getModels() {
    const ret = [];
    const keys = Object.keys(this._models);
    for (let i = 0, len = keys.length; i < len; i++) {
      const modelId = keys[i];
      ret.push(this._models[modelId].model);
    }
    return ret;
  }
  getModel(resource) {
    const modelId = MODEL_ID2(resource);
    const modelData = this._models[modelId];
    if (!modelData) {
      return null;
    }
    return modelData.model;
  }
  getSemanticTokensProviderStyling(provider) {
    return this._semanticStyling.get(provider);
  }
  _onWillDispose(model2) {
    const modelId = MODEL_ID2(model2.uri);
    const modelData = this._models[modelId];
    delete this._models[modelId];
    modelData.dispose();
    delete this._modelCreationOptionsByLanguageAndResource[model2.getLanguageIdentifier().language + model2.uri];
    this._onModelRemoved.fire(model2);
  }
  _onDidChangeLanguage(model2, e) {
    const oldModeId = e.oldLanguage;
    const newModeId = model2.getLanguageIdentifier().language;
    const oldOptions = this.getCreationOptions(oldModeId, model2.uri, model2.isForSimpleWidget);
    const newOptions = this.getCreationOptions(newModeId, model2.uri, model2.isForSimpleWidget);
    ModelServiceImpl2._setModelOptionsForModel(model2, newOptions, oldOptions);
    this._onModelModeChanged.fire({model: model2, oldModeId});
  }
};
ModelServiceImpl = __decorate9([
  __param8(0, IConfigurationService),
  __param8(1, ITextResourcePropertiesService),
  __param8(2, IThemeService),
  __param8(3, ILogService),
  __param8(4, IUndoRedoService)
], ModelServiceImpl);
var SEMANTIC_HIGHLIGHTING_SETTING_ID = "editor.semanticHighlighting";
function isSemanticColoringEnabled(model2, themeService, configurationService) {
  var _a;
  const setting = (_a = configurationService.getValue(SEMANTIC_HIGHLIGHTING_SETTING_ID, {overrideIdentifier: model2.getLanguageIdentifier().language, resource: model2.uri})) === null || _a === void 0 ? void 0 : _a.enabled;
  if (typeof setting === "boolean") {
    return setting;
  }
  return themeService.getColorTheme().semanticHighlighting;
}
var SemanticColoringFeature = class extends Disposable {
  constructor(modelService, themeService, configurationService, semanticStyling) {
    super();
    this._watchers = Object.create(null);
    this._semanticStyling = semanticStyling;
    const register3 = (model2) => {
      this._watchers[model2.uri.toString()] = new ModelSemanticColoring(model2, themeService, this._semanticStyling);
    };
    const deregister = (model2, modelSemanticColoring) => {
      modelSemanticColoring.dispose();
      delete this._watchers[model2.uri.toString()];
    };
    const handleSettingOrThemeChange = () => {
      for (let model2 of modelService.getModels()) {
        const curr = this._watchers[model2.uri.toString()];
        if (isSemanticColoringEnabled(model2, themeService, configurationService)) {
          if (!curr) {
            register3(model2);
          }
        } else {
          if (curr) {
            deregister(model2, curr);
          }
        }
      }
    };
    this._register(modelService.onModelAdded((model2) => {
      if (isSemanticColoringEnabled(model2, themeService, configurationService)) {
        register3(model2);
      }
    }));
    this._register(modelService.onModelRemoved((model2) => {
      const curr = this._watchers[model2.uri.toString()];
      if (curr) {
        deregister(model2, curr);
      }
    }));
    this._register(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {
        handleSettingOrThemeChange();
      }
    }));
    this._register(themeService.onDidColorThemeChange(handleSettingOrThemeChange));
  }
};
var SemanticStyling = class extends Disposable {
  constructor(_themeService, _logService) {
    super();
    this._themeService = _themeService;
    this._logService = _logService;
    this._caches = new WeakMap();
    this._register(this._themeService.onDidColorThemeChange(() => {
      this._caches = new WeakMap();
    }));
  }
  get(provider) {
    if (!this._caches.has(provider)) {
      this._caches.set(provider, new SemanticTokensProviderStyling(provider.getLegend(), this._themeService, this._logService));
    }
    return this._caches.get(provider);
  }
};
var SemanticTokensResponse = class {
  constructor(_provider, resultId, data) {
    this._provider = _provider;
    this.resultId = resultId;
    this.data = data;
  }
  dispose() {
    this._provider.releaseDocumentSemanticTokens(this.resultId);
  }
};
var ModelSemanticColoring = class extends Disposable {
  constructor(model2, themeService, stylingProvider) {
    super();
    this._isDisposed = false;
    this._model = model2;
    this._semanticStyling = stylingProvider;
    this._fetchDocumentSemanticTokens = this._register(new RunOnceScheduler(() => this._fetchDocumentSemanticTokensNow(), 300));
    this._currentDocumentResponse = null;
    this._currentDocumentRequestCancellationTokenSource = null;
    this._documentProvidersChangeListeners = [];
    this._register(this._model.onDidChangeContent(() => {
      if (!this._fetchDocumentSemanticTokens.isScheduled()) {
        this._fetchDocumentSemanticTokens.schedule();
      }
    }));
    const bindDocumentChangeListeners = () => {
      dispose(this._documentProvidersChangeListeners);
      this._documentProvidersChangeListeners = [];
      for (const provider of DocumentSemanticTokensProviderRegistry.all(model2)) {
        if (typeof provider.onDidChange === "function") {
          this._documentProvidersChangeListeners.push(provider.onDidChange(() => this._fetchDocumentSemanticTokens.schedule(0)));
        }
      }
    };
    bindDocumentChangeListeners();
    this._register(DocumentSemanticTokensProviderRegistry.onDidChange(() => {
      bindDocumentChangeListeners();
      this._fetchDocumentSemanticTokens.schedule();
    }));
    this._register(themeService.onDidColorThemeChange((_) => {
      this._setDocumentSemanticTokens(null, null, null, []);
      this._fetchDocumentSemanticTokens.schedule();
    }));
    this._fetchDocumentSemanticTokens.schedule(0);
  }
  dispose() {
    if (this._currentDocumentResponse) {
      this._currentDocumentResponse.dispose();
      this._currentDocumentResponse = null;
    }
    if (this._currentDocumentRequestCancellationTokenSource) {
      this._currentDocumentRequestCancellationTokenSource.cancel();
      this._currentDocumentRequestCancellationTokenSource = null;
    }
    this._setDocumentSemanticTokens(null, null, null, []);
    this._isDisposed = true;
    super.dispose();
  }
  _fetchDocumentSemanticTokensNow() {
    if (this._currentDocumentRequestCancellationTokenSource) {
      return;
    }
    const provider = this._getSemanticColoringProvider();
    if (!provider) {
      return;
    }
    this._currentDocumentRequestCancellationTokenSource = new CancellationTokenSource();
    const pendingChanges = [];
    const contentChangeListener = this._model.onDidChangeContent((e) => {
      pendingChanges.push(e);
    });
    const styling = this._semanticStyling.get(provider);
    const lastResultId = this._currentDocumentResponse ? this._currentDocumentResponse.resultId || null : null;
    const request = Promise.resolve(provider.provideDocumentSemanticTokens(this._model, lastResultId, this._currentDocumentRequestCancellationTokenSource.token));
    request.then((res) => {
      this._currentDocumentRequestCancellationTokenSource = null;
      contentChangeListener.dispose();
      this._setDocumentSemanticTokens(provider, res || null, styling, pendingChanges);
    }, (err) => {
      if (!err || typeof err.message !== "string" || err.message.indexOf("busy") === -1) {
        onUnexpectedError(err);
      }
      this._currentDocumentRequestCancellationTokenSource = null;
      contentChangeListener.dispose();
      if (pendingChanges.length > 0) {
        if (!this._fetchDocumentSemanticTokens.isScheduled()) {
          this._fetchDocumentSemanticTokens.schedule();
        }
      }
    });
  }
  static _isSemanticTokens(v) {
    return v && !!v.data;
  }
  static _isSemanticTokensEdits(v) {
    return v && Array.isArray(v.edits);
  }
  static _copy(src, srcOffset, dest, destOffset, length) {
    for (let i = 0; i < length; i++) {
      dest[destOffset + i] = src[srcOffset + i];
    }
  }
  _setDocumentSemanticTokens(provider, tokens, styling, pendingChanges) {
    const currentResponse = this._currentDocumentResponse;
    if (this._currentDocumentResponse) {
      this._currentDocumentResponse.dispose();
      this._currentDocumentResponse = null;
    }
    if (this._isDisposed) {
      if (provider && tokens) {
        provider.releaseDocumentSemanticTokens(tokens.resultId);
      }
      return;
    }
    if (!provider || !styling) {
      this._model.setSemanticTokens(null, false);
      return;
    }
    if (!tokens) {
      this._model.setSemanticTokens(null, true);
      return;
    }
    if (ModelSemanticColoring._isSemanticTokensEdits(tokens)) {
      if (!currentResponse) {
        this._model.setSemanticTokens(null, true);
        return;
      }
      if (tokens.edits.length === 0) {
        tokens = {
          resultId: tokens.resultId,
          data: currentResponse.data
        };
      } else {
        let deltaLength = 0;
        for (const edit of tokens.edits) {
          deltaLength += (edit.data ? edit.data.length : 0) - edit.deleteCount;
        }
        const srcData = currentResponse.data;
        const destData = new Uint32Array(srcData.length + deltaLength);
        let srcLastStart = srcData.length;
        let destLastStart = destData.length;
        for (let i = tokens.edits.length - 1; i >= 0; i--) {
          const edit = tokens.edits[i];
          const copyCount = srcLastStart - (edit.start + edit.deleteCount);
          if (copyCount > 0) {
            ModelSemanticColoring._copy(srcData, srcLastStart - copyCount, destData, destLastStart - copyCount, copyCount);
            destLastStart -= copyCount;
          }
          if (edit.data) {
            ModelSemanticColoring._copy(edit.data, 0, destData, destLastStart - edit.data.length, edit.data.length);
            destLastStart -= edit.data.length;
          }
          srcLastStart = edit.start;
        }
        if (srcLastStart > 0) {
          ModelSemanticColoring._copy(srcData, 0, destData, 0, srcLastStart);
        }
        tokens = {
          resultId: tokens.resultId,
          data: destData
        };
      }
    }
    if (ModelSemanticColoring._isSemanticTokens(tokens)) {
      this._currentDocumentResponse = new SemanticTokensResponse(provider, tokens.resultId, tokens.data);
      const result = toMultilineTokens2(tokens, styling, this._model.getLanguageIdentifier());
      if (pendingChanges.length > 0) {
        for (const change of pendingChanges) {
          for (const area of result) {
            for (const singleChange of change.changes) {
              area.applyEdit(singleChange.range, singleChange.text);
            }
          }
        }
        if (!this._fetchDocumentSemanticTokens.isScheduled()) {
          this._fetchDocumentSemanticTokens.schedule();
        }
      }
      this._model.setSemanticTokens(result, true);
      return;
    }
    this._model.setSemanticTokens(null, true);
  }
  _getSemanticColoringProvider() {
    const result = DocumentSemanticTokensProviderRegistry.ordered(this._model);
    return result.length > 0 ? result[0] : null;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/services/abstractCodeEditorService.js
var AbstractCodeEditorService = class extends Disposable {
  constructor() {
    super();
    this._onCodeEditorAdd = this._register(new Emitter());
    this.onCodeEditorAdd = this._onCodeEditorAdd.event;
    this._onCodeEditorRemove = this._register(new Emitter());
    this.onCodeEditorRemove = this._onCodeEditorRemove.event;
    this._onDiffEditorAdd = this._register(new Emitter());
    this._onDiffEditorRemove = this._register(new Emitter());
    this._modelProperties = new Map();
    this._codeEditors = Object.create(null);
    this._diffEditors = Object.create(null);
  }
  addCodeEditor(editor2) {
    this._codeEditors[editor2.getId()] = editor2;
    this._onCodeEditorAdd.fire(editor2);
  }
  removeCodeEditor(editor2) {
    if (delete this._codeEditors[editor2.getId()]) {
      this._onCodeEditorRemove.fire(editor2);
    }
  }
  listCodeEditors() {
    return Object.keys(this._codeEditors).map((id) => this._codeEditors[id]);
  }
  addDiffEditor(editor2) {
    this._diffEditors[editor2.getId()] = editor2;
    this._onDiffEditorAdd.fire(editor2);
  }
  removeDiffEditor(editor2) {
    if (delete this._diffEditors[editor2.getId()]) {
      this._onDiffEditorRemove.fire(editor2);
    }
  }
  listDiffEditors() {
    return Object.keys(this._diffEditors).map((id) => this._diffEditors[id]);
  }
  getFocusedCodeEditor() {
    let editorWithWidgetFocus = null;
    const editors = this.listCodeEditors();
    for (const editor2 of editors) {
      if (editor2.hasTextFocus()) {
        return editor2;
      }
      if (editor2.hasWidgetFocus()) {
        editorWithWidgetFocus = editor2;
      }
    }
    return editorWithWidgetFocus;
  }
  setModelProperty(resource, key, value) {
    const key1 = resource.toString();
    let dest;
    if (this._modelProperties.has(key1)) {
      dest = this._modelProperties.get(key1);
    } else {
      dest = new Map();
      this._modelProperties.set(key1, dest);
    }
    dest.set(key, value);
  }
  getModelProperty(resource, key) {
    const key1 = resource.toString();
    if (this._modelProperties.has(key1)) {
      const innerMap = this._modelProperties.get(key1);
      return innerMap.get(key);
    }
    return void 0;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/browser/services/codeEditorServiceImpl.js
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RefCountedStyleSheet = class {
  constructor(parent, editorId, styleSheet) {
    this._parent = parent;
    this._editorId = editorId;
    this._styleSheet = styleSheet;
    this._refCount = 0;
  }
  ref() {
    this._refCount++;
  }
  unref() {
    var _a;
    this._refCount--;
    if (this._refCount === 0) {
      (_a = this._styleSheet.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this._styleSheet);
      this._parent._removeEditorStyleSheets(this._editorId);
    }
  }
  insertRule(rule, index) {
    const sheet = this._styleSheet.sheet;
    sheet.insertRule(rule, index);
  }
  removeRulesContainingSelector(ruleName) {
    removeCSSRulesContainingSelector(ruleName, this._styleSheet);
  }
};
var GlobalStyleSheet = class {
  constructor(styleSheet) {
    this._styleSheet = styleSheet;
  }
  ref() {
  }
  unref() {
  }
  insertRule(rule, index) {
    const sheet = this._styleSheet.sheet;
    sheet.insertRule(rule, index);
  }
  removeRulesContainingSelector(ruleName) {
    removeCSSRulesContainingSelector(ruleName, this._styleSheet);
  }
};
var CodeEditorServiceImpl = class CodeEditorServiceImpl2 extends AbstractCodeEditorService {
  constructor(themeService, styleSheet = null) {
    super();
    this._decorationOptionProviders = new Map();
    this._editorStyleSheets = new Map();
    this._globalStyleSheet = styleSheet ? styleSheet : null;
    this._themeService = themeService;
  }
  _getOrCreateGlobalStyleSheet() {
    if (!this._globalStyleSheet) {
      this._globalStyleSheet = new GlobalStyleSheet(createStyleSheet());
    }
    return this._globalStyleSheet;
  }
  _getOrCreateStyleSheet(editor2) {
    if (!editor2) {
      return this._getOrCreateGlobalStyleSheet();
    }
    const domNode = editor2.getContainerDomNode();
    if (!isInShadowDOM(domNode)) {
      return this._getOrCreateGlobalStyleSheet();
    }
    const editorId = editor2.getId();
    if (!this._editorStyleSheets.has(editorId)) {
      const refCountedStyleSheet = new RefCountedStyleSheet(this, editorId, createStyleSheet(domNode));
      this._editorStyleSheets.set(editorId, refCountedStyleSheet);
    }
    return this._editorStyleSheets.get(editorId);
  }
  _removeEditorStyleSheets(editorId) {
    this._editorStyleSheets.delete(editorId);
  }
  registerDecorationType(key, options, parentTypeKey, editor2) {
    let provider = this._decorationOptionProviders.get(key);
    if (!provider) {
      const styleSheet = this._getOrCreateStyleSheet(editor2);
      const providerArgs = {
        styleSheet,
        key,
        parentTypeKey,
        options: options || Object.create(null)
      };
      if (!parentTypeKey) {
        provider = new DecorationTypeOptionsProvider(this._themeService, styleSheet, providerArgs);
      } else {
        provider = new DecorationSubTypeOptionsProvider(this._themeService, styleSheet, providerArgs);
      }
      this._decorationOptionProviders.set(key, provider);
    }
    provider.refCount++;
  }
  removeDecorationType(key) {
    const provider = this._decorationOptionProviders.get(key);
    if (provider) {
      provider.refCount--;
      if (provider.refCount <= 0) {
        this._decorationOptionProviders.delete(key);
        provider.dispose();
        this.listCodeEditors().forEach((ed) => ed.removeDecorations(key));
      }
    }
  }
  resolveDecorationOptions(decorationTypeKey, writable) {
    const provider = this._decorationOptionProviders.get(decorationTypeKey);
    if (!provider) {
      throw new Error("Unknown decoration type key: " + decorationTypeKey);
    }
    return provider.getOptions(this, writable);
  }
};
CodeEditorServiceImpl = __decorate10([
  __param9(0, IThemeService)
], CodeEditorServiceImpl);
var DecorationSubTypeOptionsProvider = class {
  constructor(themeService, styleSheet, providerArgs) {
    this._styleSheet = styleSheet;
    this._styleSheet.ref();
    this._parentTypeKey = providerArgs.parentTypeKey;
    this.refCount = 0;
    this._beforeContentRules = new DecorationCSSRules(3, providerArgs, themeService);
    this._afterContentRules = new DecorationCSSRules(4, providerArgs, themeService);
  }
  getOptions(codeEditorService, writable) {
    const options = codeEditorService.resolveDecorationOptions(this._parentTypeKey, true);
    if (this._beforeContentRules) {
      options.beforeContentClassName = this._beforeContentRules.className;
    }
    if (this._afterContentRules) {
      options.afterContentClassName = this._afterContentRules.className;
    }
    return options;
  }
  dispose() {
    if (this._beforeContentRules) {
      this._beforeContentRules.dispose();
      this._beforeContentRules = null;
    }
    if (this._afterContentRules) {
      this._afterContentRules.dispose();
      this._afterContentRules = null;
    }
    this._styleSheet.unref();
  }
};
var DecorationTypeOptionsProvider = class {
  constructor(themeService, styleSheet, providerArgs) {
    this._disposables = new DisposableStore();
    this._styleSheet = styleSheet;
    this._styleSheet.ref();
    this.refCount = 0;
    const createCSSRules = (type) => {
      const rules = new DecorationCSSRules(type, providerArgs, themeService);
      this._disposables.add(rules);
      if (rules.hasContent) {
        return rules.className;
      }
      return void 0;
    };
    const createInlineCSSRules = (type) => {
      const rules = new DecorationCSSRules(type, providerArgs, themeService);
      this._disposables.add(rules);
      if (rules.hasContent) {
        return {className: rules.className, hasLetterSpacing: rules.hasLetterSpacing};
      }
      return null;
    };
    this.className = createCSSRules(0);
    const inlineData = createInlineCSSRules(1);
    if (inlineData) {
      this.inlineClassName = inlineData.className;
      this.inlineClassNameAffectsLetterSpacing = inlineData.hasLetterSpacing;
    }
    this.beforeContentClassName = createCSSRules(3);
    this.afterContentClassName = createCSSRules(4);
    this.glyphMarginClassName = createCSSRules(2);
    const options = providerArgs.options;
    this.isWholeLine = Boolean(options.isWholeLine);
    this.stickiness = options.rangeBehavior;
    const lightOverviewRulerColor = options.light && options.light.overviewRulerColor || options.overviewRulerColor;
    const darkOverviewRulerColor = options.dark && options.dark.overviewRulerColor || options.overviewRulerColor;
    if (typeof lightOverviewRulerColor !== "undefined" || typeof darkOverviewRulerColor !== "undefined") {
      this.overviewRuler = {
        color: lightOverviewRulerColor || darkOverviewRulerColor,
        darkColor: darkOverviewRulerColor || lightOverviewRulerColor,
        position: options.overviewRulerLane || OverviewRulerLane2.Center
      };
    }
  }
  getOptions(codeEditorService, writable) {
    if (!writable) {
      return this;
    }
    return {
      inlineClassName: this.inlineClassName,
      beforeContentClassName: this.beforeContentClassName,
      afterContentClassName: this.afterContentClassName,
      className: this.className,
      glyphMarginClassName: this.glyphMarginClassName,
      isWholeLine: this.isWholeLine,
      overviewRuler: this.overviewRuler,
      stickiness: this.stickiness
    };
  }
  dispose() {
    this._disposables.dispose();
    this._styleSheet.unref();
  }
};
var _CSS_MAP = {
  color: "color:{0} !important;",
  opacity: "opacity:{0};",
  backgroundColor: "background-color:{0};",
  outline: "outline:{0};",
  outlineColor: "outline-color:{0};",
  outlineStyle: "outline-style:{0};",
  outlineWidth: "outline-width:{0};",
  border: "border:{0};",
  borderColor: "border-color:{0};",
  borderRadius: "border-radius:{0};",
  borderSpacing: "border-spacing:{0};",
  borderStyle: "border-style:{0};",
  borderWidth: "border-width:{0};",
  fontStyle: "font-style:{0};",
  fontWeight: "font-weight:{0};",
  textDecoration: "text-decoration:{0};",
  cursor: "cursor:{0};",
  letterSpacing: "letter-spacing:{0};",
  gutterIconPath: "background:{0} center center no-repeat;",
  gutterIconSize: "background-size:{0};",
  contentText: "content:'{0}';",
  contentIconPath: "content:{0};",
  margin: "margin:{0};",
  width: "width:{0};",
  height: "height:{0};"
};
var DecorationCSSRules = class {
  constructor(ruleType, providerArgs, themeService) {
    this._theme = themeService.getColorTheme();
    this._ruleType = ruleType;
    this._providerArgs = providerArgs;
    this._usesThemeColors = false;
    this._hasContent = false;
    this._hasLetterSpacing = false;
    let className = CSSNameHelper.getClassName(this._providerArgs.key, ruleType);
    if (this._providerArgs.parentTypeKey) {
      className = className + " " + CSSNameHelper.getClassName(this._providerArgs.parentTypeKey, ruleType);
    }
    this._className = className;
    this._unThemedSelector = CSSNameHelper.getSelector(this._providerArgs.key, this._providerArgs.parentTypeKey, ruleType);
    this._buildCSS();
    if (this._usesThemeColors) {
      this._themeListener = themeService.onDidColorThemeChange((theme) => {
        this._theme = themeService.getColorTheme();
        this._removeCSS();
        this._buildCSS();
      });
    } else {
      this._themeListener = null;
    }
  }
  dispose() {
    if (this._hasContent) {
      this._removeCSS();
      this._hasContent = false;
    }
    if (this._themeListener) {
      this._themeListener.dispose();
      this._themeListener = null;
    }
  }
  get hasContent() {
    return this._hasContent;
  }
  get hasLetterSpacing() {
    return this._hasLetterSpacing;
  }
  get className() {
    return this._className;
  }
  _buildCSS() {
    const options = this._providerArgs.options;
    let unthemedCSS, lightCSS, darkCSS;
    switch (this._ruleType) {
      case 0:
        unthemedCSS = this.getCSSTextForModelDecorationClassName(options);
        lightCSS = this.getCSSTextForModelDecorationClassName(options.light);
        darkCSS = this.getCSSTextForModelDecorationClassName(options.dark);
        break;
      case 1:
        unthemedCSS = this.getCSSTextForModelDecorationInlineClassName(options);
        lightCSS = this.getCSSTextForModelDecorationInlineClassName(options.light);
        darkCSS = this.getCSSTextForModelDecorationInlineClassName(options.dark);
        break;
      case 2:
        unthemedCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options);
        lightCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options.light);
        darkCSS = this.getCSSTextForModelDecorationGlyphMarginClassName(options.dark);
        break;
      case 3:
        unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.before);
        lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.before);
        darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.before);
        break;
      case 4:
        unthemedCSS = this.getCSSTextForModelDecorationContentClassName(options.after);
        lightCSS = this.getCSSTextForModelDecorationContentClassName(options.light && options.light.after);
        darkCSS = this.getCSSTextForModelDecorationContentClassName(options.dark && options.dark.after);
        break;
      default:
        throw new Error("Unknown rule type: " + this._ruleType);
    }
    const sheet = this._providerArgs.styleSheet;
    let hasContent = false;
    if (unthemedCSS.length > 0) {
      sheet.insertRule(`${this._unThemedSelector} {${unthemedCSS}}`, 0);
      hasContent = true;
    }
    if (lightCSS.length > 0) {
      sheet.insertRule(`.vs${this._unThemedSelector} {${lightCSS}}`, 0);
      hasContent = true;
    }
    if (darkCSS.length > 0) {
      sheet.insertRule(`.vs-dark${this._unThemedSelector}, .hc-black${this._unThemedSelector} {${darkCSS}}`, 0);
      hasContent = true;
    }
    this._hasContent = hasContent;
  }
  _removeCSS() {
    this._providerArgs.styleSheet.removeRulesContainingSelector(this._unThemedSelector);
  }
  getCSSTextForModelDecorationClassName(opts) {
    if (!opts) {
      return "";
    }
    const cssTextArr = [];
    this.collectCSSText(opts, ["backgroundColor"], cssTextArr);
    this.collectCSSText(opts, ["outline", "outlineColor", "outlineStyle", "outlineWidth"], cssTextArr);
    this.collectBorderSettingsCSSText(opts, cssTextArr);
    return cssTextArr.join("");
  }
  getCSSTextForModelDecorationInlineClassName(opts) {
    if (!opts) {
      return "";
    }
    const cssTextArr = [];
    this.collectCSSText(opts, ["fontStyle", "fontWeight", "textDecoration", "cursor", "color", "opacity", "letterSpacing"], cssTextArr);
    if (opts.letterSpacing) {
      this._hasLetterSpacing = true;
    }
    return cssTextArr.join("");
  }
  getCSSTextForModelDecorationContentClassName(opts) {
    if (!opts) {
      return "";
    }
    const cssTextArr = [];
    if (typeof opts !== "undefined") {
      this.collectBorderSettingsCSSText(opts, cssTextArr);
      if (typeof opts.contentIconPath !== "undefined") {
        cssTextArr.push(format(_CSS_MAP.contentIconPath, asCSSUrl(URI.revive(opts.contentIconPath))));
      }
      if (typeof opts.contentText === "string") {
        const truncated = opts.contentText.match(/^.*$/m)[0];
        const escaped = truncated.replace(/['\\]/g, "\\$&");
        cssTextArr.push(format(_CSS_MAP.contentText, escaped));
      }
      this.collectCSSText(opts, ["fontStyle", "fontWeight", "textDecoration", "color", "opacity", "backgroundColor", "margin"], cssTextArr);
      if (this.collectCSSText(opts, ["width", "height"], cssTextArr)) {
        cssTextArr.push("display:inline-block;");
      }
    }
    return cssTextArr.join("");
  }
  getCSSTextForModelDecorationGlyphMarginClassName(opts) {
    if (!opts) {
      return "";
    }
    const cssTextArr = [];
    if (typeof opts.gutterIconPath !== "undefined") {
      cssTextArr.push(format(_CSS_MAP.gutterIconPath, asCSSUrl(URI.revive(opts.gutterIconPath))));
      if (typeof opts.gutterIconSize !== "undefined") {
        cssTextArr.push(format(_CSS_MAP.gutterIconSize, opts.gutterIconSize));
      }
    }
    return cssTextArr.join("");
  }
  collectBorderSettingsCSSText(opts, cssTextArr) {
    if (this.collectCSSText(opts, ["border", "borderColor", "borderRadius", "borderSpacing", "borderStyle", "borderWidth"], cssTextArr)) {
      cssTextArr.push(format("box-sizing: border-box;"));
      return true;
    }
    return false;
  }
  collectCSSText(opts, properties, cssTextArr) {
    const lenBefore = cssTextArr.length;
    for (let property of properties) {
      const value = this.resolveValue(opts[property]);
      if (typeof value === "string") {
        cssTextArr.push(format(_CSS_MAP[property], value));
      }
    }
    return cssTextArr.length !== lenBefore;
  }
  resolveValue(value) {
    if (isThemeColor(value)) {
      this._usesThemeColors = true;
      const color = this._theme.getColor(value.id);
      if (color) {
        return color.toString();
      }
      return "transparent";
    }
    return value;
  }
};
var CSSNameHelper = class {
  static getClassName(key, type) {
    return "ced-" + key + "-" + type;
  }
  static getSelector(key, parentKey, ruleType) {
    let selector = ".monaco-editor ." + this.getClassName(key, ruleType);
    if (parentKey) {
      selector = selector + "." + this.getClassName(parentKey, ruleType);
    }
    if (ruleType === 3) {
      selector += "::before";
    } else if (ruleType === 4) {
      selector += "::after";
    }
    return selector;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneCodeServiceImpl.js
var StandaloneCodeEditorServiceImpl = class extends CodeEditorServiceImpl {
  getActiveCodeEditor() {
    return null;
  }
  openCodeEditor(input, source, sideBySide) {
    if (!source) {
      return Promise.resolve(null);
    }
    return Promise.resolve(this.doOpenEditor(source, input));
  }
  doOpenEditor(editor2, input) {
    const model2 = this.findModel(editor2, input.resource);
    if (!model2) {
      if (input.resource) {
        const schema = input.resource.scheme;
        if (schema === Schemas.http || schema === Schemas.https) {
          windowOpenNoOpener(input.resource.toString());
          return editor2;
        }
      }
      return null;
    }
    const selection = input.options ? input.options.selection : null;
    if (selection) {
      if (typeof selection.endLineNumber === "number" && typeof selection.endColumn === "number") {
        editor2.setSelection(selection);
        editor2.revealRangeInCenter(selection, 1);
      } else {
        const pos = {
          lineNumber: selection.startLineNumber,
          column: selection.startColumn
        };
        editor2.setPosition(pos);
        editor2.revealPositionInCenter(pos, 1);
      }
    }
    return editor2;
  }
  findModel(editor2, resource) {
    const model2 = editor2.getModel();
    if (model2 && model2.uri.toString() !== resource.toString()) {
      return null;
    }
    return model2;
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/common/modes/supports/tokenization.js
var ParsedTokenThemeRule = class {
  constructor(token, index, fontStyle, foreground2, background) {
    this.token = token;
    this.index = index;
    this.fontStyle = fontStyle;
    this.foreground = foreground2;
    this.background = background;
  }
};
function parseTokenTheme(source) {
  if (!source || !Array.isArray(source)) {
    return [];
  }
  let result = [], resultLen = 0;
  for (let i = 0, len = source.length; i < len; i++) {
    let entry = source[i];
    let fontStyle = -1;
    if (typeof entry.fontStyle === "string") {
      fontStyle = 0;
      let segments = entry.fontStyle.split(" ");
      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {
        let segment = segments[j];
        switch (segment) {
          case "italic":
            fontStyle = fontStyle | 1;
            break;
          case "bold":
            fontStyle = fontStyle | 2;
            break;
          case "underline":
            fontStyle = fontStyle | 4;
            break;
        }
      }
    }
    let foreground2 = null;
    if (typeof entry.foreground === "string") {
      foreground2 = entry.foreground;
    }
    let background = null;
    if (typeof entry.background === "string") {
      background = entry.background;
    }
    result[resultLen++] = new ParsedTokenThemeRule(entry.token || "", i, fontStyle, foreground2, background);
  }
  return result;
}
function resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {
  parsedThemeRules.sort((a, b) => {
    let r = strcmp(a.token, b.token);
    if (r !== 0) {
      return r;
    }
    return a.index - b.index;
  });
  let defaultFontStyle = 0;
  let defaultForeground = "000000";
  let defaultBackground = "ffffff";
  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === "") {
    let incomingDefaults = parsedThemeRules.shift();
    if (incomingDefaults.fontStyle !== -1) {
      defaultFontStyle = incomingDefaults.fontStyle;
    }
    if (incomingDefaults.foreground !== null) {
      defaultForeground = incomingDefaults.foreground;
    }
    if (incomingDefaults.background !== null) {
      defaultBackground = incomingDefaults.background;
    }
  }
  let colorMap = new ColorMap();
  for (let color of customTokenColors) {
    colorMap.getId(color);
  }
  let foregroundColorId = colorMap.getId(defaultForeground);
  let backgroundColorId = colorMap.getId(defaultBackground);
  let defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);
  let root = new ThemeTrieElement(defaults);
  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {
    let rule = parsedThemeRules[i];
    root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));
  }
  return new TokenTheme(colorMap, root);
}
var colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
var ColorMap = class {
  constructor() {
    this._lastColorId = 0;
    this._id2color = [];
    this._color2id = new Map();
  }
  getId(color) {
    if (color === null) {
      return 0;
    }
    const match2 = color.match(colorRegExp);
    if (!match2) {
      throw new Error("Illegal value for token color: " + color);
    }
    color = match2[1].toUpperCase();
    let value = this._color2id.get(color);
    if (value) {
      return value;
    }
    value = ++this._lastColorId;
    this._color2id.set(color, value);
    this._id2color[value] = Color.fromHex("#" + color);
    return value;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
};
var TokenTheme = class {
  constructor(colorMap, root) {
    this._colorMap = colorMap;
    this._root = root;
    this._cache = new Map();
  }
  static createFromRawTokenTheme(source, customTokenColors) {
    return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);
  }
  static createFromParsedTokenTheme(source, customTokenColors) {
    return resolveParsedTokenThemeRules(source, customTokenColors);
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  _match(token) {
    return this._root.match(token);
  }
  match(languageId, token) {
    let result = this._cache.get(token);
    if (typeof result === "undefined") {
      let rule = this._match(token);
      let standardToken = toStandardTokenType(token);
      result = (rule.metadata | standardToken << 8) >>> 0;
      this._cache.set(token, result);
    }
    return (result | languageId << 0) >>> 0;
  }
};
var STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|regexp)\b/;
function toStandardTokenType(tokenType) {
  let m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);
  if (!m) {
    return 0;
  }
  switch (m[1]) {
    case "comment":
      return 1;
    case "string":
      return 2;
    case "regex":
      return 4;
    case "regexp":
      return 4;
  }
  throw new Error("Unexpected match for standard token type!");
}
function strcmp(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
var ThemeTrieElementRule = class {
  constructor(fontStyle, foreground2, background) {
    this._fontStyle = fontStyle;
    this._foreground = foreground2;
    this._background = background;
    this.metadata = (this._fontStyle << 11 | this._foreground << 14 | this._background << 23) >>> 0;
  }
  clone() {
    return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);
  }
  acceptOverwrite(fontStyle, foreground2, background) {
    if (fontStyle !== -1) {
      this._fontStyle = fontStyle;
    }
    if (foreground2 !== 0) {
      this._foreground = foreground2;
    }
    if (background !== 0) {
      this._background = background;
    }
    this.metadata = (this._fontStyle << 11 | this._foreground << 14 | this._background << 23) >>> 0;
  }
};
var ThemeTrieElement = class {
  constructor(mainRule) {
    this._mainRule = mainRule;
    this._children = new Map();
  }
  match(token) {
    if (token === "") {
      return this._mainRule;
    }
    let dotIndex = token.indexOf(".");
    let head;
    let tail3;
    if (dotIndex === -1) {
      head = token;
      tail3 = "";
    } else {
      head = token.substring(0, dotIndex);
      tail3 = token.substring(dotIndex + 1);
    }
    let child = this._children.get(head);
    if (typeof child !== "undefined") {
      return child.match(tail3);
    }
    return this._mainRule;
  }
  insert(token, fontStyle, foreground2, background) {
    if (token === "") {
      this._mainRule.acceptOverwrite(fontStyle, foreground2, background);
      return;
    }
    let dotIndex = token.indexOf(".");
    let head;
    let tail3;
    if (dotIndex === -1) {
      head = token;
      tail3 = "";
    } else {
      head = token.substring(0, dotIndex);
      tail3 = token.substring(dotIndex + 1);
    }
    let child = this._children.get(head);
    if (typeof child === "undefined") {
      child = new ThemeTrieElement(this._mainRule.clone());
      this._children.set(head, child);
    }
    child.insert(tail3, fontStyle, foreground2, background);
  }
};
function generateTokensCSSForColorMap(colorMap) {
  let rules = [];
  for (let i = 1, len = colorMap.length; i < len; i++) {
    let color = colorMap[i];
    rules[i] = `.mtk${i} { color: ${color}; }`;
  }
  rules.push(".mtki { font-style: italic; }");
  rules.push(".mtkb { font-weight: bold; }");
  rules.push(".mtku { text-decoration: underline; text-underline-position: under; }");
  return rules.join("\n");
}

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/common/themes.js
var vs = {
  base: "vs",
  inherit: false,
  rules: [
    {token: "", foreground: "000000", background: "fffffe"},
    {token: "invalid", foreground: "cd3131"},
    {token: "emphasis", fontStyle: "italic"},
    {token: "strong", fontStyle: "bold"},
    {token: "variable", foreground: "001188"},
    {token: "variable.predefined", foreground: "4864AA"},
    {token: "constant", foreground: "dd0000"},
    {token: "comment", foreground: "008000"},
    {token: "number", foreground: "098658"},
    {token: "number.hex", foreground: "3030c0"},
    {token: "regexp", foreground: "800000"},
    {token: "annotation", foreground: "808080"},
    {token: "type", foreground: "008080"},
    {token: "delimiter", foreground: "000000"},
    {token: "delimiter.html", foreground: "383838"},
    {token: "delimiter.xml", foreground: "0000FF"},
    {token: "tag", foreground: "800000"},
    {token: "tag.id.pug", foreground: "4F76AC"},
    {token: "tag.class.pug", foreground: "4F76AC"},
    {token: "meta.scss", foreground: "800000"},
    {token: "metatag", foreground: "e00000"},
    {token: "metatag.content.html", foreground: "FF0000"},
    {token: "metatag.html", foreground: "808080"},
    {token: "metatag.xml", foreground: "808080"},
    {token: "metatag.php", fontStyle: "bold"},
    {token: "key", foreground: "863B00"},
    {token: "string.key.json", foreground: "A31515"},
    {token: "string.value.json", foreground: "0451A5"},
    {token: "attribute.name", foreground: "FF0000"},
    {token: "attribute.value", foreground: "0451A5"},
    {token: "attribute.value.number", foreground: "098658"},
    {token: "attribute.value.unit", foreground: "098658"},
    {token: "attribute.value.html", foreground: "0000FF"},
    {token: "attribute.value.xml", foreground: "0000FF"},
    {token: "string", foreground: "A31515"},
    {token: "string.html", foreground: "0000FF"},
    {token: "string.sql", foreground: "FF0000"},
    {token: "string.yaml", foreground: "0451A5"},
    {token: "keyword", foreground: "0000FF"},
    {token: "keyword.json", foreground: "0451A5"},
    {token: "keyword.flow", foreground: "AF00DB"},
    {token: "keyword.flow.scss", foreground: "0000FF"},
    {token: "operator.scss", foreground: "666666"},
    {token: "operator.sql", foreground: "778899"},
    {token: "operator.swift", foreground: "666666"},
    {token: "predefined.sql", foreground: "FF00FF"}
  ],
  colors: {
    [editorBackground]: "#FFFFFE",
    [editorForeground]: "#000000",
    [editorInactiveSelection]: "#E5EBF1",
    [editorIndentGuides]: "#D3D3D3",
    [editorActiveIndentGuides]: "#939393",
    [editorSelectionHighlight]: "#ADD6FF4D"
  }
};
var vs_dark = {
  base: "vs-dark",
  inherit: false,
  rules: [
    {token: "", foreground: "D4D4D4", background: "1E1E1E"},
    {token: "invalid", foreground: "f44747"},
    {token: "emphasis", fontStyle: "italic"},
    {token: "strong", fontStyle: "bold"},
    {token: "variable", foreground: "74B0DF"},
    {token: "variable.predefined", foreground: "4864AA"},
    {token: "variable.parameter", foreground: "9CDCFE"},
    {token: "constant", foreground: "569CD6"},
    {token: "comment", foreground: "608B4E"},
    {token: "number", foreground: "B5CEA8"},
    {token: "number.hex", foreground: "5BB498"},
    {token: "regexp", foreground: "B46695"},
    {token: "annotation", foreground: "cc6666"},
    {token: "type", foreground: "3DC9B0"},
    {token: "delimiter", foreground: "DCDCDC"},
    {token: "delimiter.html", foreground: "808080"},
    {token: "delimiter.xml", foreground: "808080"},
    {token: "tag", foreground: "569CD6"},
    {token: "tag.id.pug", foreground: "4F76AC"},
    {token: "tag.class.pug", foreground: "4F76AC"},
    {token: "meta.scss", foreground: "A79873"},
    {token: "meta.tag", foreground: "CE9178"},
    {token: "metatag", foreground: "DD6A6F"},
    {token: "metatag.content.html", foreground: "9CDCFE"},
    {token: "metatag.html", foreground: "569CD6"},
    {token: "metatag.xml", foreground: "569CD6"},
    {token: "metatag.php", fontStyle: "bold"},
    {token: "key", foreground: "9CDCFE"},
    {token: "string.key.json", foreground: "9CDCFE"},
    {token: "string.value.json", foreground: "CE9178"},
    {token: "attribute.name", foreground: "9CDCFE"},
    {token: "attribute.value", foreground: "CE9178"},
    {token: "attribute.value.number.css", foreground: "B5CEA8"},
    {token: "attribute.value.unit.css", foreground: "B5CEA8"},
    {token: "attribute.value.hex.css", foreground: "D4D4D4"},
    {token: "string", foreground: "CE9178"},
    {token: "string.sql", foreground: "FF0000"},
    {token: "keyword", foreground: "569CD6"},
    {token: "keyword.flow", foreground: "C586C0"},
    {token: "keyword.json", foreground: "CE9178"},
    {token: "keyword.flow.scss", foreground: "569CD6"},
    {token: "operator.scss", foreground: "909090"},
    {token: "operator.sql", foreground: "778899"},
    {token: "operator.swift", foreground: "909090"},
    {token: "predefined.sql", foreground: "FF00FF"}
  ],
  colors: {
    [editorBackground]: "#1E1E1E",
    [editorForeground]: "#D4D4D4",
    [editorInactiveSelection]: "#3A3D41",
    [editorIndentGuides]: "#404040",
    [editorActiveIndentGuides]: "#707070",
    [editorSelectionHighlight]: "#ADD6FF26"
  }
};
var hc_black = {
  base: "hc-black",
  inherit: false,
  rules: [
    {token: "", foreground: "FFFFFF", background: "000000"},
    {token: "invalid", foreground: "f44747"},
    {token: "emphasis", fontStyle: "italic"},
    {token: "strong", fontStyle: "bold"},
    {token: "variable", foreground: "1AEBFF"},
    {token: "variable.parameter", foreground: "9CDCFE"},
    {token: "constant", foreground: "569CD6"},
    {token: "comment", foreground: "608B4E"},
    {token: "number", foreground: "FFFFFF"},
    {token: "regexp", foreground: "C0C0C0"},
    {token: "annotation", foreground: "569CD6"},
    {token: "type", foreground: "3DC9B0"},
    {token: "delimiter", foreground: "FFFF00"},
    {token: "delimiter.html", foreground: "FFFF00"},
    {token: "tag", foreground: "569CD6"},
    {token: "tag.id.pug", foreground: "4F76AC"},
    {token: "tag.class.pug", foreground: "4F76AC"},
    {token: "meta", foreground: "D4D4D4"},
    {token: "meta.tag", foreground: "CE9178"},
    {token: "metatag", foreground: "569CD6"},
    {token: "metatag.content.html", foreground: "1AEBFF"},
    {token: "metatag.html", foreground: "569CD6"},
    {token: "metatag.xml", foreground: "569CD6"},
    {token: "metatag.php", fontStyle: "bold"},
    {token: "key", foreground: "9CDCFE"},
    {token: "string.key", foreground: "9CDCFE"},
    {token: "string.value", foreground: "CE9178"},
    {token: "attribute.name", foreground: "569CD6"},
    {token: "attribute.value", foreground: "3FF23F"},
    {token: "string", foreground: "CE9178"},
    {token: "string.sql", foreground: "FF0000"},
    {token: "keyword", foreground: "569CD6"},
    {token: "keyword.flow", foreground: "C586C0"},
    {token: "operator.sql", foreground: "778899"},
    {token: "operator.swift", foreground: "909090"},
    {token: "predefined.sql", foreground: "FF00FF"}
  ],
  colors: {
    [editorBackground]: "#000000",
    [editorForeground]: "#FFFFFF",
    [editorIndentGuides]: "#FFFFFF",
    [editorActiveIndentGuides]: "#FFFFFF"
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/codicons/codiconStyles.js
var CodiconStyles = new class {
  constructor() {
    this.onDidChange = iconRegistry.onDidRegister;
  }
  getCSS() {
    const rules = [];
    for (let c of iconRegistry.all) {
      rules.push(formatRule(c));
    }
    return rules.join("\n");
  }
}();
function formatRule(c) {
  let def = c.definition;
  while (def instanceof Codicon) {
    def = def.definition;
  }
  return `.codicon-${c.id}:before { content: '${def.character}'; }`;
}

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneThemeServiceImpl.js
var VS_THEME_NAME = "vs";
var VS_DARK_THEME_NAME = "vs-dark";
var HC_BLACK_THEME_NAME = "hc-black";
var colorRegistry2 = Registry2.as(Extensions6.ColorContribution);
var themingRegistry2 = Registry2.as(Extensions5.ThemingContribution);
var StandaloneTheme = class {
  constructor(name, standaloneThemeData) {
    this.semanticHighlighting = false;
    this.themeData = standaloneThemeData;
    let base = standaloneThemeData.base;
    if (name.length > 0) {
      this.id = base + " " + name;
      this.themeName = name;
    } else {
      this.id = base;
      this.themeName = base;
    }
    this.colors = null;
    this.defaultColors = Object.create(null);
    this._tokenTheme = null;
  }
  get base() {
    return this.themeData.base;
  }
  notifyBaseUpdated() {
    if (this.themeData.inherit) {
      this.colors = null;
      this._tokenTheme = null;
    }
  }
  getColors() {
    if (!this.colors) {
      const colors = new Map();
      for (let id in this.themeData.colors) {
        colors.set(id, Color.fromHex(this.themeData.colors[id]));
      }
      if (this.themeData.inherit) {
        let baseData = getBuiltinRules(this.themeData.base);
        for (let id in baseData.colors) {
          if (!colors.has(id)) {
            colors.set(id, Color.fromHex(baseData.colors[id]));
          }
        }
      }
      this.colors = colors;
    }
    return this.colors;
  }
  getColor(colorId, useDefault) {
    const color = this.getColors().get(colorId);
    if (color) {
      return color;
    }
    if (useDefault !== false) {
      return this.getDefault(colorId);
    }
    return void 0;
  }
  getDefault(colorId) {
    let color = this.defaultColors[colorId];
    if (color) {
      return color;
    }
    color = colorRegistry2.resolveDefaultColor(colorId, this);
    this.defaultColors[colorId] = color;
    return color;
  }
  defines(colorId) {
    return Object.prototype.hasOwnProperty.call(this.getColors(), colorId);
  }
  get type() {
    switch (this.base) {
      case VS_THEME_NAME:
        return "light";
      case HC_BLACK_THEME_NAME:
        return "hc";
      default:
        return "dark";
    }
  }
  get tokenTheme() {
    if (!this._tokenTheme) {
      let rules = [];
      let encodedTokensColors = [];
      if (this.themeData.inherit) {
        let baseData = getBuiltinRules(this.themeData.base);
        rules = baseData.rules;
        if (baseData.encodedTokensColors) {
          encodedTokensColors = baseData.encodedTokensColors;
        }
      }
      rules = rules.concat(this.themeData.rules);
      if (this.themeData.encodedTokensColors) {
        encodedTokensColors = this.themeData.encodedTokensColors;
      }
      this._tokenTheme = TokenTheme.createFromRawTokenTheme(rules, encodedTokensColors);
    }
    return this._tokenTheme;
  }
  getTokenStyleMetadata(type, modifiers, modelLanguage) {
    const style = this.tokenTheme._match([type].concat(modifiers).join("."));
    const metadata = style.metadata;
    const foreground2 = TokenMetadata.getForeground(metadata);
    const fontStyle = TokenMetadata.getFontStyle(metadata);
    return {
      foreground: foreground2,
      italic: Boolean(fontStyle & 1),
      bold: Boolean(fontStyle & 2),
      underline: Boolean(fontStyle & 4)
    };
  }
};
function isBuiltinTheme(themeName) {
  return themeName === VS_THEME_NAME || themeName === VS_DARK_THEME_NAME || themeName === HC_BLACK_THEME_NAME;
}
function getBuiltinRules(builtinTheme) {
  switch (builtinTheme) {
    case VS_THEME_NAME:
      return vs;
    case VS_DARK_THEME_NAME:
      return vs_dark;
    case HC_BLACK_THEME_NAME:
      return hc_black;
  }
}
function newBuiltInTheme(builtinTheme) {
  let themeData = getBuiltinRules(builtinTheme);
  return new StandaloneTheme(builtinTheme, themeData);
}
var StandaloneThemeServiceImpl = class extends Disposable {
  constructor() {
    super();
    this._onColorThemeChange = this._register(new Emitter());
    this.onDidColorThemeChange = this._onColorThemeChange.event;
    this._environment = Object.create(null);
    this._knownThemes = new Map();
    this._knownThemes.set(VS_THEME_NAME, newBuiltInTheme(VS_THEME_NAME));
    this._knownThemes.set(VS_DARK_THEME_NAME, newBuiltInTheme(VS_DARK_THEME_NAME));
    this._knownThemes.set(HC_BLACK_THEME_NAME, newBuiltInTheme(HC_BLACK_THEME_NAME));
    this._codiconCSS = CodiconStyles.getCSS();
    this._themeCSS = "";
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`;
    this._globalStyleElement = null;
    this._styleElements = [];
    this.setTheme(VS_THEME_NAME);
    CodiconStyles.onDidChange(() => {
      this._codiconCSS = CodiconStyles.getCSS();
      this._updateCSS();
    });
  }
  registerEditorContainer(domNode) {
    if (isInShadowDOM(domNode)) {
      return this._registerShadowDomContainer(domNode);
    }
    return this._registerRegularEditorContainer();
  }
  _registerRegularEditorContainer() {
    if (!this._globalStyleElement) {
      this._globalStyleElement = createStyleSheet();
      this._globalStyleElement.className = "monaco-colors";
      this._globalStyleElement.innerHTML = this._allCSS;
      this._styleElements.push(this._globalStyleElement);
    }
    return Disposable.None;
  }
  _registerShadowDomContainer(domNode) {
    const styleElement = createStyleSheet(domNode);
    styleElement.className = "monaco-colors";
    styleElement.innerHTML = this._allCSS;
    this._styleElements.push(styleElement);
    return {
      dispose: () => {
        for (let i = 0; i < this._styleElements.length; i++) {
          if (this._styleElements[i] === styleElement) {
            this._styleElements.splice(i, 1);
            return;
          }
        }
      }
    };
  }
  defineTheme(themeName, themeData) {
    if (!/^[a-z0-9\-]+$/i.test(themeName)) {
      throw new Error("Illegal theme name!");
    }
    if (!isBuiltinTheme(themeData.base) && !isBuiltinTheme(themeName)) {
      throw new Error("Illegal theme base!");
    }
    this._knownThemes.set(themeName, new StandaloneTheme(themeName, themeData));
    if (isBuiltinTheme(themeName)) {
      this._knownThemes.forEach((theme) => {
        if (theme.base === themeName) {
          theme.notifyBaseUpdated();
        }
      });
    }
    if (this._theme && this._theme.themeName === themeName) {
      this.setTheme(themeName);
    }
  }
  getColorTheme() {
    return this._theme;
  }
  setTheme(themeName) {
    let theme;
    if (this._knownThemes.has(themeName)) {
      theme = this._knownThemes.get(themeName);
    } else {
      theme = this._knownThemes.get(VS_THEME_NAME);
    }
    if (this._theme === theme) {
      return theme.id;
    }
    this._theme = theme;
    let cssRules = [];
    let hasRule = {};
    let ruleCollector = {
      addRule: (rule) => {
        if (!hasRule[rule]) {
          cssRules.push(rule);
          hasRule[rule] = true;
        }
      }
    };
    themingRegistry2.getThemingParticipants().forEach((p) => p(theme, ruleCollector, this._environment));
    let tokenTheme = theme.tokenTheme;
    let colorMap = tokenTheme.getColorMap();
    ruleCollector.addRule(generateTokensCSSForColorMap(colorMap));
    this._themeCSS = cssRules.join("\n");
    this._updateCSS();
    TokenizationRegistry.setColorMap(colorMap);
    this._onColorThemeChange.fire(theme);
    return theme.id;
  }
  _updateCSS() {
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`;
    this._styleElements.forEach((styleElement) => styleElement.innerHTML = this._allCSS);
  }
  getFileIconTheme() {
    return {
      hasFileIcons: false,
      hasFolderIcons: false,
      hidesExplorerArrows: false
    };
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/contextkey/browser/contextKeyService.js
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param10 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var KEYBINDING_CONTEXT_ATTR = "data-keybinding-context";
var Context = class {
  constructor(id, parent) {
    this._id = id;
    this._parent = parent;
    this._value = Object.create(null);
    this._value["_contextId"] = id;
  }
  setValue(key, value) {
    if (this._value[key] !== value) {
      this._value[key] = value;
      return true;
    }
    return false;
  }
  removeValue(key) {
    if (key in this._value) {
      delete this._value[key];
      return true;
    }
    return false;
  }
  getValue(key) {
    const ret = this._value[key];
    if (typeof ret === "undefined" && this._parent) {
      return this._parent.getValue(key);
    }
    return ret;
  }
};
var NullContext = class extends Context {
  constructor() {
    super(-1, null);
  }
  setValue(key, value) {
    return false;
  }
  removeValue(key) {
    return false;
  }
  getValue(key) {
    return void 0;
  }
};
NullContext.INSTANCE = new NullContext();
var ConfigAwareContextValuesContainer = class extends Context {
  constructor(id, _configurationService, emitter) {
    super(id, null);
    this._configurationService = _configurationService;
    this._values = new Map();
    this._listener = this._configurationService.onDidChangeConfiguration((event) => {
      if (event.source === 6) {
        const allKeys = Array.from(this._values.keys());
        this._values.clear();
        emitter.fire(new ArrayContextKeyChangeEvent(allKeys));
      } else {
        const changedKeys = [];
        for (const configKey of event.affectedKeys) {
          const contextKey = `config.${configKey}`;
          if (this._values.has(contextKey)) {
            this._values.delete(contextKey);
            changedKeys.push(contextKey);
          }
        }
        emitter.fire(new ArrayContextKeyChangeEvent(changedKeys));
      }
    });
  }
  dispose() {
    this._listener.dispose();
  }
  getValue(key) {
    if (key.indexOf(ConfigAwareContextValuesContainer._keyPrefix) !== 0) {
      return super.getValue(key);
    }
    if (this._values.has(key)) {
      return this._values.get(key);
    }
    const configKey = key.substr(ConfigAwareContextValuesContainer._keyPrefix.length);
    const configValue = this._configurationService.getValue(configKey);
    let value = void 0;
    switch (typeof configValue) {
      case "number":
      case "boolean":
      case "string":
        value = configValue;
        break;
      default:
        if (Array.isArray(configValue)) {
          value = JSON.stringify(configValue);
        }
    }
    this._values.set(key, value);
    return value;
  }
  setValue(key, value) {
    return super.setValue(key, value);
  }
  removeValue(key) {
    return super.removeValue(key);
  }
};
ConfigAwareContextValuesContainer._keyPrefix = "config.";
var ContextKey = class {
  constructor(service, key, defaultValue) {
    this._service = service;
    this._key = key;
    this._defaultValue = defaultValue;
    this.reset();
  }
  set(value) {
    this._service.setContext(this._key, value);
  }
  reset() {
    if (typeof this._defaultValue === "undefined") {
      this._service.removeContext(this._key);
    } else {
      this._service.setContext(this._key, this._defaultValue);
    }
  }
  get() {
    return this._service.getContextKeyValue(this._key);
  }
};
var SimpleContextKeyChangeEvent = class {
  constructor(key) {
    this.key = key;
  }
  affectsSome(keys) {
    return keys.has(this.key);
  }
};
var ArrayContextKeyChangeEvent = class {
  constructor(keys) {
    this.keys = keys;
  }
  affectsSome(keys) {
    for (const key of this.keys) {
      if (keys.has(key)) {
        return true;
      }
    }
    return false;
  }
};
var CompositeContextKeyChangeEvent = class {
  constructor(events) {
    this.events = events;
  }
  affectsSome(keys) {
    for (const e of this.events) {
      if (e.affectsSome(keys)) {
        return true;
      }
    }
    return false;
  }
};
var AbstractContextKeyService = class {
  constructor(myContextId) {
    this._onDidChangeContext = new PauseableEmitter({merge: (input) => new CompositeContextKeyChangeEvent(input)});
    this._isDisposed = false;
    this._myContextId = myContextId;
  }
  createKey(key, defaultValue) {
    if (this._isDisposed) {
      throw new Error(`AbstractContextKeyService has been disposed`);
    }
    return new ContextKey(this, key, defaultValue);
  }
  get onDidChangeContext() {
    return this._onDidChangeContext.event;
  }
  bufferChangeEvents(callback) {
    this._onDidChangeContext.pause();
    try {
      callback();
    } finally {
      this._onDidChangeContext.resume();
    }
  }
  createScoped(domNode) {
    if (this._isDisposed) {
      throw new Error(`AbstractContextKeyService has been disposed`);
    }
    return new ScopedContextKeyService(this, domNode);
  }
  contextMatchesRules(rules) {
    if (this._isDisposed) {
      throw new Error(`AbstractContextKeyService has been disposed`);
    }
    const context = this.getContextValuesContainer(this._myContextId);
    const result = KeybindingResolver.contextMatchesRules(context, rules);
    return result;
  }
  getContextKeyValue(key) {
    if (this._isDisposed) {
      return void 0;
    }
    return this.getContextValuesContainer(this._myContextId).getValue(key);
  }
  setContext(key, value) {
    if (this._isDisposed) {
      return;
    }
    const myContext = this.getContextValuesContainer(this._myContextId);
    if (!myContext) {
      return;
    }
    if (myContext.setValue(key, value)) {
      this._onDidChangeContext.fire(new SimpleContextKeyChangeEvent(key));
    }
  }
  removeContext(key) {
    if (this._isDisposed) {
      return;
    }
    if (this.getContextValuesContainer(this._myContextId).removeValue(key)) {
      this._onDidChangeContext.fire(new SimpleContextKeyChangeEvent(key));
    }
  }
  getContext(target) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this.getContextValuesContainer(findContextAttr(target));
  }
};
var ContextKeyService = class ContextKeyService2 extends AbstractContextKeyService {
  constructor(configurationService) {
    super(0);
    this._contexts = new Map();
    this._toDispose = new DisposableStore();
    this._lastContextId = 0;
    const myContext = new ConfigAwareContextValuesContainer(this._myContextId, configurationService, this._onDidChangeContext);
    this._contexts.set(this._myContextId, myContext);
    this._toDispose.add(myContext);
  }
  dispose() {
    this._isDisposed = true;
    this._toDispose.dispose();
  }
  getContextValuesContainer(contextId) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this._contexts.get(contextId) || NullContext.INSTANCE;
  }
  createChildContext(parentContextId = this._myContextId) {
    if (this._isDisposed) {
      throw new Error(`ContextKeyService has been disposed`);
    }
    let id = ++this._lastContextId;
    this._contexts.set(id, new Context(id, this.getContextValuesContainer(parentContextId)));
    return id;
  }
  disposeContext(contextId) {
    if (!this._isDisposed) {
      this._contexts.delete(contextId);
    }
  }
};
ContextKeyService = __decorate11([
  __param10(0, IConfigurationService)
], ContextKeyService);
var ScopedContextKeyService = class extends AbstractContextKeyService {
  constructor(parent, domNode) {
    super(parent.createChildContext());
    this._parent = parent;
    if (domNode) {
      this._domNode = domNode;
      this._domNode.setAttribute(KEYBINDING_CONTEXT_ATTR, String(this._myContextId));
    }
  }
  dispose() {
    this._isDisposed = true;
    this._parent.disposeContext(this._myContextId);
    if (this._domNode) {
      this._domNode.removeAttribute(KEYBINDING_CONTEXT_ATTR);
      this._domNode = void 0;
    }
  }
  get onDidChangeContext() {
    return Event.any(this._parent.onDidChangeContext, this._onDidChangeContext.event);
  }
  getContextValuesContainer(contextId) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this._parent.getContextValuesContainer(contextId);
  }
  createChildContext(parentContextId = this._myContextId) {
    if (this._isDisposed) {
      throw new Error(`ScopedContextKeyService has been disposed`);
    }
    return this._parent.createChildContext(parentContextId);
  }
  disposeContext(contextId) {
    if (this._isDisposed) {
      return;
    }
    this._parent.disposeContext(contextId);
  }
};
function findContextAttr(domNode) {
  while (domNode) {
    if (domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {
      const attr = domNode.getAttribute(KEYBINDING_CONTEXT_ATTR);
      if (attr) {
        return parseInt(attr, 10);
      }
      return NaN;
    }
    domNode = domNode.parentElement;
  }
  return 0;
}
CommandsRegistry.registerCommand(SET_CONTEXT_COMMAND_ID, function(accessor, contextKey, contextValue) {
  accessor.get(IContextKeyService).createKey(String(contextKey), contextValue);
});

// ../../node_modules/monaco-editor/esm/vs/base/common/range.js
var Range2;
(function(Range4) {
  function intersect(one, other) {
    if (one.start >= other.end || other.start >= one.end) {
      return {start: 0, end: 0};
    }
    const start = Math.max(one.start, other.start);
    const end = Math.min(one.end, other.end);
    if (end - start <= 0) {
      return {start: 0, end: 0};
    }
    return {start, end};
  }
  Range4.intersect = intersect;
  function isEmpty(range2) {
    return range2.end - range2.start <= 0;
  }
  Range4.isEmpty = isEmpty;
  function intersects2(one, other) {
    return !isEmpty(intersect(one, other));
  }
  Range4.intersects = intersects2;
  function relativeComplement2(one, other) {
    const result = [];
    const first2 = {start: one.start, end: Math.min(other.start, one.end)};
    const second = {start: Math.max(other.end, one.start), end: one.end};
    if (!isEmpty(first2)) {
      result.push(first2);
    }
    if (!isEmpty(second)) {
      result.push(second);
    }
    return result;
  }
  Range4.relativeComplement = relativeComplement2;
})(Range2 || (Range2 = {}));

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/contextview/contextview.js
function layout(viewportSize, viewSize, anchor) {
  const anchorEnd = anchor.offset + anchor.size;
  if (anchor.position === 0) {
    if (viewSize <= viewportSize - anchorEnd) {
      return anchorEnd;
    }
    if (viewSize <= anchor.offset) {
      return anchor.offset - viewSize;
    }
    return Math.max(viewportSize - viewSize, 0);
  } else {
    if (viewSize <= anchor.offset) {
      return anchor.offset - viewSize;
    }
    if (viewSize <= viewportSize - anchorEnd) {
      return anchorEnd;
    }
    return 0;
  }
}
var ContextView = class extends Disposable {
  constructor(container, domPosition) {
    super();
    this.container = null;
    this.delegate = null;
    this.toDisposeOnClean = Disposable.None;
    this.toDisposeOnSetContainer = Disposable.None;
    this.shadowRoot = null;
    this.shadowRootHostElement = null;
    this.view = $(".context-view");
    this.useFixedPosition = false;
    this.useShadowDOM = false;
    hide(this.view);
    this.setContainer(container, domPosition);
    this._register(toDisposable(() => this.setContainer(null, 1)));
  }
  setContainer(container, domPosition) {
    if (this.container) {
      this.toDisposeOnSetContainer.dispose();
      if (this.shadowRoot) {
        this.shadowRoot.removeChild(this.view);
        this.shadowRoot = null;
        removeNode(this.shadowRootHostElement);
        this.shadowRootHostElement = null;
      } else {
        this.container.removeChild(this.view);
      }
      this.container = null;
    }
    if (container) {
      this.container = container;
      this.useFixedPosition = domPosition !== 1;
      this.useShadowDOM = domPosition === 3;
      if (this.useShadowDOM) {
        this.shadowRootHostElement = $(".shadow-root-host");
        this.container.appendChild(this.shadowRootHostElement);
        this.shadowRoot = this.shadowRootHostElement.attachShadow({mode: "open"});
        this.shadowRoot.innerHTML = `
					<style>
						${SHADOW_ROOT_CSS}
					</style>
				`;
        this.shadowRoot.appendChild(this.view);
        this.shadowRoot.appendChild($("slot"));
      } else {
        this.container.appendChild(this.view);
      }
      const toDisposeOnSetContainer = new DisposableStore();
      ContextView.BUBBLE_UP_EVENTS.forEach((event) => {
        toDisposeOnSetContainer.add(addStandardDisposableListener(this.container, event, (e) => {
          this.onDOMEvent(e, false);
        }));
      });
      ContextView.BUBBLE_DOWN_EVENTS.forEach((event) => {
        toDisposeOnSetContainer.add(addStandardDisposableListener(this.container, event, (e) => {
          this.onDOMEvent(e, true);
        }, true));
      });
      this.toDisposeOnSetContainer = toDisposeOnSetContainer;
    }
  }
  show(delegate) {
    if (this.isVisible()) {
      this.hide();
    }
    clearNode(this.view);
    this.view.className = "context-view";
    this.view.style.top = "0px";
    this.view.style.left = "0px";
    this.view.style.zIndex = "2500";
    this.view.style.position = this.useFixedPosition ? "fixed" : "absolute";
    show(this.view);
    this.toDisposeOnClean = delegate.render(this.view) || Disposable.None;
    this.delegate = delegate;
    this.doLayout();
    if (this.delegate.focus) {
      this.delegate.focus();
    }
  }
  getViewElement() {
    return this.view;
  }
  layout() {
    if (!this.isVisible()) {
      return;
    }
    if (this.delegate.canRelayout === false && !(isIOS && BrowserFeatures.pointerEvents)) {
      this.hide();
      return;
    }
    if (this.delegate.layout) {
      this.delegate.layout();
    }
    this.doLayout();
  }
  doLayout() {
    if (!this.isVisible()) {
      return;
    }
    let anchor = this.delegate.getAnchor();
    let around;
    if (isHTMLElement(anchor)) {
      let elementPosition = getDomNodePagePosition(anchor);
      around = {
        top: elementPosition.top,
        left: elementPosition.left,
        width: elementPosition.width,
        height: elementPosition.height
      };
    } else {
      around = {
        top: anchor.y,
        left: anchor.x,
        width: anchor.width || 1,
        height: anchor.height || 2
      };
    }
    const viewSizeWidth = getTotalWidth(this.view);
    const viewSizeHeight = getTotalHeight(this.view);
    const anchorPosition = this.delegate.anchorPosition || 0;
    const anchorAlignment = this.delegate.anchorAlignment || 0;
    const verticalAnchor = {offset: around.top - window.pageYOffset, size: around.height, position: anchorPosition === 0 ? 0 : 1};
    let horizontalAnchor;
    if (anchorAlignment === 0) {
      horizontalAnchor = {offset: around.left, size: 0, position: 0};
    } else {
      horizontalAnchor = {offset: around.left + around.width, size: 0, position: 1};
    }
    const top = layout(window.innerHeight, viewSizeHeight, verticalAnchor) + window.pageYOffset;
    if (Range2.intersects({start: top, end: top + viewSizeHeight}, {start: verticalAnchor.offset, end: verticalAnchor.offset + verticalAnchor.size})) {
      horizontalAnchor.size = around.width;
      if (anchorAlignment === 1) {
        horizontalAnchor.offset = around.left;
      }
    }
    const left = layout(window.innerWidth, viewSizeWidth, horizontalAnchor);
    removeClasses(this.view, "top", "bottom", "left", "right");
    addClass(this.view, anchorPosition === 0 ? "bottom" : "top");
    addClass(this.view, anchorAlignment === 0 ? "left" : "right");
    toggleClass(this.view, "fixed", this.useFixedPosition);
    const containerPosition = getDomNodePagePosition(this.container);
    this.view.style.top = `${top - (this.useFixedPosition ? getDomNodePagePosition(this.view).top : containerPosition.top)}px`;
    this.view.style.left = `${left - (this.useFixedPosition ? getDomNodePagePosition(this.view).left : containerPosition.left)}px`;
    this.view.style.width = "initial";
  }
  hide(data) {
    const delegate = this.delegate;
    this.delegate = null;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.onHide) {
      delegate.onHide(data);
    }
    this.toDisposeOnClean.dispose();
    hide(this.view);
  }
  isVisible() {
    return !!this.delegate;
  }
  onDOMEvent(e, onCapture) {
    if (this.delegate) {
      if (this.delegate.onDOMEvent) {
        this.delegate.onDOMEvent(e, document.activeElement);
      } else if (onCapture && !isAncestor(e.target, this.container)) {
        this.hide();
      }
    }
  }
  dispose() {
    this.hide();
    super.dispose();
  }
};
ContextView.BUBBLE_UP_EVENTS = ["click", "keydown", "focus", "blur"];
ContextView.BUBBLE_DOWN_EVENTS = ["click"];
var SHADOW_ROOT_CSS = `
	:host {
		all: initial; /* 1st rule so subsequent properties are reset. */
	}

	@font-face {
		font-family: "codicon";
		src: url("./codicon.ttf?5d4d76ab2ce5108968ad644d591a16a6") format("truetype");
	}

	.codicon[class*='codicon-'] {
		font: normal normal normal 16px/1 codicon;
		display: inline-block;
		text-decoration: none;
		text-rendering: auto;
		text-align: center;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	:host {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", system-ui, "Ubuntu", "Droid Sans", sans-serif;
	}

	:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
	:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", sans-serif; }
	:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang TC", sans-serif; }
	:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic Pro", sans-serif; }
	:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, "Nanum Gothic", "Apple SD Gothic Neo", "AppleGothic", sans-serif; }

	:host-context(.windows) { font-family: "Segoe WPC", "Segoe UI", sans-serif; }
	:host-context(.windows:lang(zh-Hans)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft YaHei", sans-serif; }
	:host-context(.windows:lang(zh-Hant)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft Jhenghei", sans-serif; }
	:host-context(.windows:lang(ja)) { font-family: "Segoe WPC", "Segoe UI", "Yu Gothic UI", "Meiryo UI", sans-serif; }
	:host-context(.windows:lang(ko)) { font-family: "Segoe WPC", "Segoe UI", "Malgun Gothic", "Dotom", sans-serif; }

	:host-context(.linux) { font-family: system-ui, "Ubuntu", "Droid Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans SC", "Source Han Sans CN", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans TC", "Source Han Sans TW", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ja)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans J", "Source Han Sans JP", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ko)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans K", "Source Han Sans JR", "Source Han Sans", "UnDotum", "FBaekmuk Gulim", sans-serif; }
`;

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/menu/menu.js
var MENU_MNEMONIC_REGEX = /\(&([^\s&])\)|(^|[^&])&([^\s&])/;
var MENU_ESCAPED_MNEMONIC_REGEX = /(&amp;)?(&amp;)([^\s&])/g;
var menuSelectionIcon = registerIcon("menu-selection", Codicon.check);
var menuSubmenuIcon = registerIcon("menu-submenu", Codicon.chevronRight);
var Direction;
(function(Direction2) {
  Direction2[Direction2["Right"] = 0] = "Right";
  Direction2[Direction2["Left"] = 1] = "Left";
})(Direction || (Direction = {}));
var Menu = class extends ActionBar {
  constructor(container, actions, options = {}) {
    addClass(container, "monaco-menu-container");
    container.setAttribute("role", "presentation");
    const menuElement = document.createElement("div");
    addClass(menuElement, "monaco-menu");
    menuElement.setAttribute("role", "presentation");
    super(menuElement, {
      orientation: 2,
      actionViewItemProvider: (action) => this.doGetActionViewItem(action, options, parentData),
      context: options.context,
      actionRunner: options.actionRunner,
      ariaLabel: options.ariaLabel,
      triggerKeys: {keys: [3, ...isMacintosh || isLinux ? [10] : []], keyDown: true}
    });
    this.menuElement = menuElement;
    this.actionsList.setAttribute("role", "menu");
    this.actionsList.tabIndex = 0;
    this.menuDisposables = this._register(new DisposableStore());
    this.initializeStyleSheet(container);
    addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(2)) {
        e.preventDefault();
      }
    });
    if (options.enableMnemonics) {
      this.menuDisposables.add(addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {
        const key = e.key.toLocaleLowerCase();
        if (this.mnemonics.has(key)) {
          EventHelper.stop(e, true);
          const actions2 = this.mnemonics.get(key);
          if (actions2.length === 1) {
            if (actions2[0] instanceof SubmenuMenuActionViewItem && actions2[0].container) {
              this.focusItemByElement(actions2[0].container);
            }
            actions2[0].onClick(e);
          }
          if (actions2.length > 1) {
            const action = actions2.shift();
            if (action && action.container) {
              this.focusItemByElement(action.container);
              actions2.push(action);
            }
            this.mnemonics.set(key, actions2);
          }
        }
      }));
    }
    if (isLinux) {
      this._register(addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {
        const event = new StandardKeyboardEvent(e);
        if (event.equals(14) || event.equals(11)) {
          this.focusedItem = this.viewItems.length - 1;
          this.focusNext();
          EventHelper.stop(e, true);
        } else if (event.equals(13) || event.equals(12)) {
          this.focusedItem = 0;
          this.focusPrevious();
          EventHelper.stop(e, true);
        }
      }));
    }
    this._register(addDisposableListener(this.domNode, EventType.MOUSE_OUT, (e) => {
      let relatedTarget = e.relatedTarget;
      if (!isAncestor(relatedTarget, this.domNode)) {
        this.focusedItem = void 0;
        this.updateFocus();
        e.stopPropagation();
      }
    }));
    this._register(addDisposableListener(this.actionsList, EventType.MOUSE_OVER, (e) => {
      let target = e.target;
      if (!target || !isAncestor(target, this.actionsList) || target === this.actionsList) {
        return;
      }
      while (target.parentElement !== this.actionsList && target.parentElement !== null) {
        target = target.parentElement;
      }
      if (hasClass(target, "action-item")) {
        const lastFocusedItem = this.focusedItem;
        this.setFocusedItem(target);
        if (lastFocusedItem !== this.focusedItem) {
          this.updateFocus();
        }
      }
    }));
    let parentData = {
      parent: this
    };
    this.mnemonics = new Map();
    this.scrollableElement = this._register(new DomScrollableElement(menuElement, {
      alwaysConsumeMouseWheel: true,
      horizontal: 2,
      vertical: 3,
      verticalScrollbarSize: 7,
      handleMouseWheel: true,
      useShadows: true
    }));
    const scrollElement = this.scrollableElement.getDomNode();
    scrollElement.style.position = "";
    this._register(addDisposableListener(scrollElement, EventType.MOUSE_UP, (e) => {
      e.preventDefault();
    }));
    menuElement.style.maxHeight = `${Math.max(10, window.innerHeight - container.getBoundingClientRect().top - 35)}px`;
    actions = actions.filter((a) => {
      var _a;
      if ((_a = options.submenuIds) === null || _a === void 0 ? void 0 : _a.has(a.id)) {
        console.warn(`Found submenu cycle: ${a.id}`);
        return false;
      }
      return true;
    });
    this.push(actions, {icon: true, label: true, isMenu: true});
    container.appendChild(this.scrollableElement.getDomNode());
    this.scrollableElement.scanDomNode();
    this.viewItems.filter((item) => !(item instanceof MenuSeparatorActionViewItem)).forEach((item, index, array) => {
      item.updatePositionInSet(index + 1, array.length);
    });
  }
  initializeStyleSheet(container) {
    if (isInShadowDOM(container)) {
      this.styleSheet = createStyleSheet(container);
      this.styleSheet.innerHTML = MENU_WIDGET_CSS;
    } else {
      if (!Menu.globalStyleSheet) {
        Menu.globalStyleSheet = createStyleSheet();
        Menu.globalStyleSheet.innerHTML = MENU_WIDGET_CSS;
      }
      this.styleSheet = Menu.globalStyleSheet;
    }
  }
  style(style) {
    const container = this.getContainer();
    const fgColor = style.foregroundColor ? `${style.foregroundColor}` : "";
    const bgColor = style.backgroundColor ? `${style.backgroundColor}` : "";
    const border = style.borderColor ? `1px solid ${style.borderColor}` : "";
    const shadow = style.shadowColor ? `0 2px 4px ${style.shadowColor}` : "";
    container.style.border = border;
    this.domNode.style.color = fgColor;
    this.domNode.style.backgroundColor = bgColor;
    container.style.boxShadow = shadow;
    if (this.viewItems) {
      this.viewItems.forEach((item) => {
        if (item instanceof BaseMenuActionViewItem || item instanceof MenuSeparatorActionViewItem) {
          item.style(style);
        }
      });
    }
  }
  getContainer() {
    return this.scrollableElement.getDomNode();
  }
  get onScroll() {
    return this.scrollableElement.onScroll;
  }
  focusItemByElement(element) {
    const lastFocusedItem = this.focusedItem;
    this.setFocusedItem(element);
    if (lastFocusedItem !== this.focusedItem) {
      this.updateFocus();
    }
  }
  setFocusedItem(element) {
    for (let i = 0; i < this.actionsList.children.length; i++) {
      let elem = this.actionsList.children[i];
      if (element === elem) {
        this.focusedItem = i;
        break;
      }
    }
  }
  updateFocus(fromRight) {
    super.updateFocus(fromRight, true);
    if (typeof this.focusedItem !== "undefined") {
      this.scrollableElement.setScrollPosition({
        scrollTop: Math.round(this.menuElement.scrollTop)
      });
    }
  }
  doGetActionViewItem(action, options, parentData) {
    if (action instanceof Separator) {
      return new MenuSeparatorActionViewItem(options.context, action, {icon: true});
    } else if (action instanceof SubmenuAction) {
      const menuActionViewItem = new SubmenuMenuActionViewItem(action, action.actions, parentData, Object.assign(Object.assign({}, options), {submenuIds: new Set([...options.submenuIds || [], action.id])}));
      if (options.enableMnemonics) {
        const mnemonic = menuActionViewItem.getMnemonic();
        if (mnemonic && menuActionViewItem.isEnabled()) {
          let actionViewItems = [];
          if (this.mnemonics.has(mnemonic)) {
            actionViewItems = this.mnemonics.get(mnemonic);
          }
          actionViewItems.push(menuActionViewItem);
          this.mnemonics.set(mnemonic, actionViewItems);
        }
      }
      return menuActionViewItem;
    } else {
      const menuItemOptions = {enableMnemonics: options.enableMnemonics, useEventAsContext: options.useEventAsContext};
      if (options.getKeyBinding) {
        const keybinding = options.getKeyBinding(action);
        if (keybinding) {
          const keybindingLabel = keybinding.getLabel();
          if (keybindingLabel) {
            menuItemOptions.keybinding = keybindingLabel;
          }
        }
      }
      const menuActionViewItem = new BaseMenuActionViewItem(options.context, action, menuItemOptions);
      if (options.enableMnemonics) {
        const mnemonic = menuActionViewItem.getMnemonic();
        if (mnemonic && menuActionViewItem.isEnabled()) {
          let actionViewItems = [];
          if (this.mnemonics.has(mnemonic)) {
            actionViewItems = this.mnemonics.get(mnemonic);
          }
          actionViewItems.push(menuActionViewItem);
          this.mnemonics.set(mnemonic, actionViewItems);
        }
      }
      return menuActionViewItem;
    }
  }
};
var BaseMenuActionViewItem = class extends BaseActionViewItem {
  constructor(ctx, action, options = {}) {
    options.isMenu = true;
    super(action, action, options);
    this.options = options;
    this.options.icon = options.icon !== void 0 ? options.icon : false;
    this.options.label = options.label !== void 0 ? options.label : true;
    this.cssClass = "";
    if (this.options.label && options.enableMnemonics) {
      let label = this.getAction().label;
      if (label) {
        let matches = MENU_MNEMONIC_REGEX.exec(label);
        if (matches) {
          this.mnemonic = (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase();
        }
      }
    }
    this.runOnceToEnableMouseUp = new RunOnceScheduler(() => {
      if (!this.element) {
        return;
      }
      this._register(addDisposableListener(this.element, EventType.MOUSE_UP, (e) => {
        EventHelper.stop(e, true);
        if (isFirefox) {
          const mouseEvent = new StandardMouseEvent(e);
          if (mouseEvent.rightButton) {
            return;
          }
          this.onClick(e);
        }
        setTimeout(() => {
          this.onClick(e);
        }, 0);
      }));
      this._register(addDisposableListener(this.element, EventType.CONTEXT_MENU, (e) => {
        EventHelper.stop(e, true);
      }));
    }, 100);
    this._register(this.runOnceToEnableMouseUp);
  }
  render(container) {
    super.render(container);
    if (!this.element) {
      return;
    }
    this.container = container;
    this.item = append(this.element, $("a.action-menu-item"));
    if (this._action.id === Separator.ID) {
      this.item.setAttribute("role", "presentation");
    } else {
      this.item.setAttribute("role", "menuitem");
      if (this.mnemonic) {
        this.item.setAttribute("aria-keyshortcuts", `${this.mnemonic}`);
      }
    }
    this.check = append(this.item, $("span.menu-item-check" + menuSelectionIcon.cssSelector));
    this.check.setAttribute("role", "none");
    this.label = append(this.item, $("span.action-label"));
    if (this.options.label && this.options.keybinding) {
      append(this.item, $("span.keybinding")).textContent = this.options.keybinding;
    }
    this.runOnceToEnableMouseUp.schedule();
    this.updateClass();
    this.updateLabel();
    this.updateTooltip();
    this.updateEnabled();
    this.updateChecked();
  }
  blur() {
    super.blur();
    this.applyStyle();
  }
  focus() {
    super.focus();
    if (this.item) {
      this.item.focus();
    }
    this.applyStyle();
  }
  updatePositionInSet(pos, setSize) {
    if (this.item) {
      this.item.setAttribute("aria-posinset", `${pos}`);
      this.item.setAttribute("aria-setsize", `${setSize}`);
    }
  }
  updateLabel() {
    if (!this.label) {
      return;
    }
    if (this.options.label) {
      clearNode(this.label);
      let label = stripCodicons(this.getAction().label);
      if (label) {
        const cleanLabel = cleanMnemonic(label);
        if (!this.options.enableMnemonics) {
          label = cleanLabel;
        }
        this.label.setAttribute("aria-label", cleanLabel.replace(/&&/g, "&"));
        const matches = MENU_MNEMONIC_REGEX.exec(label);
        if (matches) {
          label = escape(label);
          MENU_ESCAPED_MNEMONIC_REGEX.lastIndex = 0;
          let escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label);
          while (escMatch && escMatch[1]) {
            escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label);
          }
          const replaceDoubleEscapes = (str) => str.replace(/&amp;&amp;/g, "&amp;");
          if (escMatch) {
            this.label.append(ltrim(replaceDoubleEscapes(label.substr(0, escMatch.index)), " "), $("u", {"aria-hidden": "true"}, escMatch[3]), rtrim(replaceDoubleEscapes(label.substr(escMatch.index + escMatch[0].length)), " "));
          } else {
            this.label.innerText = replaceDoubleEscapes(label).trim();
          }
          if (this.item) {
            this.item.setAttribute("aria-keyshortcuts", (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase());
          }
        } else {
          this.label.innerText = label.replace(/&&/g, "&").trim();
        }
      }
    }
  }
  updateTooltip() {
    let title = null;
    if (this.getAction().tooltip) {
      title = this.getAction().tooltip;
    } else if (!this.options.label && this.getAction().label && this.options.icon) {
      title = this.getAction().label;
      if (this.options.keybinding) {
        title = localize({key: "titleLabel", comment: ["action title", "action keybinding"]}, "{0} ({1})", title, this.options.keybinding);
      }
    }
    if (title && this.item) {
      this.item.title = title;
    }
  }
  updateClass() {
    if (this.cssClass && this.item) {
      removeClasses(this.item, this.cssClass);
    }
    if (this.options.icon && this.label) {
      this.cssClass = this.getAction().class || "";
      addClass(this.label, "icon");
      if (this.cssClass) {
        addClasses(this.label, this.cssClass);
      }
      this.updateEnabled();
    } else if (this.label) {
      removeClass(this.label, "icon");
    }
  }
  updateEnabled() {
    if (this.getAction().enabled) {
      if (this.element) {
        removeClass(this.element, "disabled");
      }
      if (this.item) {
        removeClass(this.item, "disabled");
        this.item.tabIndex = 0;
      }
    } else {
      if (this.element) {
        addClass(this.element, "disabled");
      }
      if (this.item) {
        addClass(this.item, "disabled");
        removeTabIndexAndUpdateFocus(this.item);
      }
    }
  }
  updateChecked() {
    if (!this.item) {
      return;
    }
    if (this.getAction().checked) {
      addClass(this.item, "checked");
      this.item.setAttribute("role", "menuitemcheckbox");
      this.item.setAttribute("aria-checked", "true");
    } else {
      removeClass(this.item, "checked");
      this.item.setAttribute("role", "menuitem");
      this.item.setAttribute("aria-checked", "false");
    }
  }
  getMnemonic() {
    return this.mnemonic;
  }
  applyStyle() {
    if (!this.menuStyle) {
      return;
    }
    const isSelected = this.element && hasClass(this.element, "focused");
    const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    const bgColor = isSelected && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : void 0;
    const border = isSelected && this.menuStyle.selectionBorderColor ? `thin solid ${this.menuStyle.selectionBorderColor}` : "";
    if (this.item) {
      this.item.style.color = fgColor ? fgColor.toString() : "";
      this.item.style.backgroundColor = bgColor ? bgColor.toString() : "";
    }
    if (this.check) {
      this.check.style.color = fgColor ? fgColor.toString() : "";
    }
    if (this.container) {
      this.container.style.border = border;
    }
  }
  style(style) {
    this.menuStyle = style;
    this.applyStyle();
  }
};
var SubmenuMenuActionViewItem = class extends BaseMenuActionViewItem {
  constructor(action, submenuActions, parentData, submenuOptions) {
    super(action, action, submenuOptions);
    this.submenuActions = submenuActions;
    this.parentData = parentData;
    this.submenuOptions = submenuOptions;
    this.mysubmenu = null;
    this.submenuDisposables = this._register(new DisposableStore());
    this.mouseOver = false;
    this.expandDirection = submenuOptions && submenuOptions.expandDirection !== void 0 ? submenuOptions.expandDirection : Direction.Right;
    this.showScheduler = new RunOnceScheduler(() => {
      if (this.mouseOver) {
        this.cleanupExistingSubmenu(false);
        this.createSubmenu(false);
      }
    }, 250);
    this.hideScheduler = new RunOnceScheduler(() => {
      if (this.element && (!isAncestor(getActiveElement(), this.element) && this.parentData.submenu === this.mysubmenu)) {
        this.parentData.parent.focus(false);
        this.cleanupExistingSubmenu(true);
      }
    }, 750);
  }
  render(container) {
    super.render(container);
    if (!this.element) {
      return;
    }
    if (this.item) {
      addClass(this.item, "monaco-submenu-item");
      this.item.setAttribute("aria-haspopup", "true");
      this.updateAriaExpanded("false");
      this.submenuIndicator = append(this.item, $("span.submenu-indicator" + menuSubmenuIcon.cssSelector));
      this.submenuIndicator.setAttribute("aria-hidden", "true");
    }
    this._register(addDisposableListener(this.element, EventType.KEY_UP, (e) => {
      let event = new StandardKeyboardEvent(e);
      if (event.equals(17) || event.equals(3)) {
        EventHelper.stop(e, true);
        this.createSubmenu(true);
      }
    }));
    this._register(addDisposableListener(this.element, EventType.KEY_DOWN, (e) => {
      let event = new StandardKeyboardEvent(e);
      if (getActiveElement() === this.item) {
        if (event.equals(17) || event.equals(3)) {
          EventHelper.stop(e, true);
        }
      }
    }));
    this._register(addDisposableListener(this.element, EventType.MOUSE_OVER, (e) => {
      if (!this.mouseOver) {
        this.mouseOver = true;
        this.showScheduler.schedule();
      }
    }));
    this._register(addDisposableListener(this.element, EventType.MOUSE_LEAVE, (e) => {
      this.mouseOver = false;
    }));
    this._register(addDisposableListener(this.element, EventType.FOCUS_OUT, (e) => {
      if (this.element && !isAncestor(getActiveElement(), this.element)) {
        this.hideScheduler.schedule();
      }
    }));
    this._register(this.parentData.parent.onScroll(() => {
      this.parentData.parent.focus(false);
      this.cleanupExistingSubmenu(false);
    }));
  }
  onClick(e) {
    EventHelper.stop(e, true);
    this.cleanupExistingSubmenu(false);
    this.createSubmenu(true);
  }
  cleanupExistingSubmenu(force) {
    if (this.parentData.submenu && (force || this.parentData.submenu !== this.mysubmenu)) {
      try {
        this.parentData.submenu.dispose();
      } catch (_a) {
      }
      this.parentData.submenu = void 0;
      this.updateAriaExpanded("false");
      if (this.submenuContainer) {
        this.submenuDisposables.clear();
        this.submenuContainer = void 0;
      }
    }
  }
  calculateSubmenuMenuLayout(windowDimensions, submenu, entry, expandDirection) {
    const ret = {top: 0, left: 0};
    ret.left = layout(windowDimensions.width, submenu.width, {position: expandDirection === Direction.Right ? 0 : 1, offset: entry.left, size: entry.width});
    if (ret.left >= entry.left && ret.left < entry.left + entry.width) {
      if (entry.left + 10 + submenu.width <= windowDimensions.width) {
        ret.left = entry.left + 10;
      }
      entry.top += 10;
      entry.height = 0;
    }
    ret.top = layout(windowDimensions.height, submenu.height, {position: 0, offset: entry.top, size: 0});
    if (ret.top + submenu.height === entry.top && ret.top + entry.height + submenu.height <= windowDimensions.height) {
      ret.top += entry.height;
    }
    return ret;
  }
  createSubmenu(selectFirstItem = true) {
    if (!this.element) {
      return;
    }
    if (!this.parentData.submenu) {
      this.updateAriaExpanded("true");
      this.submenuContainer = append(this.element, $("div.monaco-submenu"));
      addClasses(this.submenuContainer, "menubar-menu-items-holder", "context-view");
      const computedStyles = getComputedStyle(this.parentData.parent.domNode);
      const paddingTop = parseFloat(computedStyles.paddingTop || "0") || 0;
      this.submenuContainer.style.zIndex = "1";
      this.submenuContainer.style.position = "fixed";
      this.submenuContainer.style.top = "0";
      this.submenuContainer.style.left = "0";
      this.parentData.submenu = new Menu(this.submenuContainer, this.submenuActions, this.submenuOptions);
      if (this.menuStyle) {
        this.parentData.submenu.style(this.menuStyle);
      }
      const entryBox = this.element.getBoundingClientRect();
      const entryBoxUpdated = {
        top: entryBox.top - paddingTop,
        left: entryBox.left,
        height: entryBox.height + 2 * paddingTop,
        width: entryBox.width
      };
      const viewBox = this.submenuContainer.getBoundingClientRect();
      const {top, left} = this.calculateSubmenuMenuLayout({height: window.innerHeight, width: window.innerWidth}, viewBox, entryBoxUpdated, this.expandDirection);
      this.submenuContainer.style.left = `${left}px`;
      this.submenuContainer.style.top = `${top}px`;
      this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_UP, (e) => {
        let event = new StandardKeyboardEvent(e);
        if (event.equals(15)) {
          EventHelper.stop(e, true);
          this.parentData.parent.focus();
          this.cleanupExistingSubmenu(true);
        }
      }));
      this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_DOWN, (e) => {
        let event = new StandardKeyboardEvent(e);
        if (event.equals(15)) {
          EventHelper.stop(e, true);
        }
      }));
      this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {
        this.parentData.parent.focus();
        this.cleanupExistingSubmenu(true);
      }));
      this.parentData.submenu.focus(selectFirstItem);
      this.mysubmenu = this.parentData.submenu;
    } else {
      this.parentData.submenu.focus(false);
    }
  }
  updateAriaExpanded(value) {
    var _a;
    if (this.item) {
      (_a = this.item) === null || _a === void 0 ? void 0 : _a.setAttribute("aria-expanded", value);
    }
  }
  applyStyle() {
    super.applyStyle();
    if (!this.menuStyle) {
      return;
    }
    const isSelected = this.element && hasClass(this.element, "focused");
    const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    if (this.submenuIndicator) {
      this.submenuIndicator.style.color = fgColor ? `${fgColor}` : "";
    }
    if (this.parentData.submenu) {
      this.parentData.submenu.style(this.menuStyle);
    }
  }
  dispose() {
    super.dispose();
    this.hideScheduler.dispose();
    if (this.mysubmenu) {
      this.mysubmenu.dispose();
      this.mysubmenu = null;
    }
    if (this.submenuContainer) {
      this.submenuContainer = void 0;
    }
  }
};
var MenuSeparatorActionViewItem = class extends ActionViewItem {
  style(style) {
    if (this.label) {
      this.label.style.borderBottomColor = style.separatorColor ? `${style.separatorColor}` : "";
    }
  }
};
function cleanMnemonic(label) {
  const regex = MENU_MNEMONIC_REGEX;
  const matches = regex.exec(label);
  if (!matches) {
    return label;
  }
  const mnemonicInText = !matches[1];
  return label.replace(regex, mnemonicInText ? "$2$3" : "").trim();
}
var MENU_WIDGET_CSS = `
.monaco-menu {
	font-size: 13px;

}

${formatRule(menuSelectionIcon)}
${formatRule(menuSubmenuIcon)}

.monaco-menu .monaco-action-bar {
	text-align: right;
	overflow: hidden;
	white-space: nowrap;
}

.monaco-menu .monaco-action-bar .actions-container {
	display: flex;
	margin: 0 auto;
	padding: 0;
	width: 100%;
	justify-content: flex-end;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: inline-block;
}

.monaco-menu .monaco-action-bar.reverse .actions-container {
	flex-direction: row-reverse;
}

.monaco-menu .monaco-action-bar .action-item {
	cursor: pointer;
	display: inline-block;
	transition: transform 50ms ease;
	position: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */
}

.monaco-menu .monaco-action-bar .action-item.disabled {
	cursor: default;
}

.monaco-menu .monaco-action-bar.animated .action-item.active {
	transform: scale(1.272019649, 1.272019649); /* 1.272019649 = \u221A\u03C6 */
}

.monaco-menu .monaco-action-bar .action-item .icon,
.monaco-menu .monaco-action-bar .action-item .codicon {
	display: inline-block;
}

.monaco-menu .monaco-action-bar .action-item .codicon {
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar .action-label {
	font-size: 11px;
	margin-right: 4px;
}

.monaco-menu .monaco-action-bar .action-item.disabled .action-label,
.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {
	opacity: 0.4;
}

/* Vertical actions */

.monaco-menu .monaco-action-bar.vertical {
	text-align: left;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	display: block;
	border-bottom: 1px solid #bbb;
	padding-top: 1px;
	margin-left: .8em;
	margin-right: .8em;
}

.monaco-menu .secondary-actions .monaco-action-bar .action-label {
	margin-left: 6px;
}

/* Action Items */
.monaco-menu .monaco-action-bar .action-item.select-container {
	overflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */
	flex: 1;
	max-width: 170px;
	min-width: 60px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-right: 10px;
}

.monaco-menu .monaco-action-bar.vertical {
	margin-left: 0;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	padding: 0;
	transform: none;
	display: flex;
}

.monaco-menu .monaco-action-bar.vertical .action-item.active {
	transform: none;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	flex: 1 1 auto;
	display: flex;
	height: 2em;
	align-items: center;
	position: relative;
}

.monaco-menu .monaco-action-bar.vertical .action-label {
	flex: 1 1 auto;
	text-decoration: none;
	padding: 0 1em;
	background: none;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .keybinding,
.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	display: inline-block;
	flex: 2 1 auto;
	padding: 0 1em;
	text-align: right;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {
	font-size: 16px !important;
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {
	margin-left: auto;
	margin-right: -20px;
}

.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {
	opacity: 0.4;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {
	display: inline-block;
	box-sizing: border-box;
	margin: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	position: static;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {
	position: absolute;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	padding: 0.5em 0 0 0;
	margin-bottom: 0.5em;
	width: 100%;
	height: 0px !important;
	margin-left: .8em !important;
	margin-right: .8em !important;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {
	padding: 0.7em 1em 0.1em 1em;
	font-weight: bold;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label:hover {
	color: inherit;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	position: absolute;
	visibility: hidden;
	width: 1em;
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {
	visibility: visible;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Context Menu */

.context-view.monaco-menu-container {
	outline: 0;
	border: none;
	animation: fadeIn 0.083s linear;
}

.context-view.monaco-menu-container :focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {
	outline: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	border: thin solid transparent; /* prevents jumping behaviour on hover or focus */
}


/* High Contrast Theming */
:host-context(.hc-black) .context-view.monaco-menu-container {
	box-shadow: none;
}

:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused {
	background: none;
}

/* Vertical Action Bar Styles */

.monaco-menu .monaco-action-bar.vertical {
	padding: .5em 0;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	height: 1.8em;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),
.monaco-menu .monaco-action-bar.vertical .keybinding {
	font-size: inherit;
	padding: 0 2em;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	font-size: inherit;
	width: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	font-size: inherit;
	padding: 0.2em 0 0 0;
	margin-bottom: 0.2em;
}

:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {
	margin-left: 0;
	margin-right: 0;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	font-size: 60%;
	padding: 0 1.8em;
}

:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
	mask-size: 10px 10px;
	-webkit-mask-size: 10px 10px;
}

.monaco-menu .action-item {
	cursor: default;
}

/* Arrows */
.monaco-scrollable-element > .scrollbar > .scra {
	cursor: pointer;
	font-size: 11px !important;
}

.monaco-scrollable-element > .visible {
	opacity: 1;

	/* Background rule added for IE9 - to allow clicks on dom node */
	background:rgba(0,0,0,0);

	transition: opacity 100ms linear;
}
.monaco-scrollable-element > .invisible {
	opacity: 0;
	pointer-events: none;
}
.monaco-scrollable-element > .invisible.fade {
	transition: opacity 800ms linear;
}

/* Scrollable Content Inset Shadow */
.monaco-scrollable-element > .shadow {
	position: absolute;
	display: none;
}
.monaco-scrollable-element > .shadow.top {
	display: block;
	top: 0;
	left: 3px;
	height: 3px;
	width: 100%;
	box-shadow: #DDD 0 6px 6px -6px inset;
}
.monaco-scrollable-element > .shadow.left {
	display: block;
	top: 3px;
	left: 0;
	height: 100%;
	width: 3px;
	box-shadow: #DDD 6px 0 6px -6px inset;
}
.monaco-scrollable-element > .shadow.top-left-corner {
	display: block;
	top: 0;
	left: 0;
	height: 3px;
	width: 3px;
}
.monaco-scrollable-element > .shadow.top.left {
	box-shadow: #DDD 6px 6px 6px -6px inset;
}

/* ---------- Default Style ---------- */

:host-context(.vs) .monaco-scrollable-element > .scrollbar > .slider {
	background: rgba(100, 100, 100, .4);
}
:host-context(.vs-dark) .monaco-scrollable-element > .scrollbar > .slider {
	background: rgba(121, 121, 121, .4);
}
:host-context(.hc-black) .monaco-scrollable-element > .scrollbar > .slider {
	background: rgba(111, 195, 223, .6);
}

.monaco-scrollable-element > .scrollbar > .slider:hover {
	background: rgba(100, 100, 100, .7);
}
:host-context(.hc-black) .monaco-scrollable-element > .scrollbar > .slider:hover {
	background: rgba(111, 195, 223, .8);
}

.monaco-scrollable-element > .scrollbar > .slider.active {
	background: rgba(0, 0, 0, .6);
}
:host-context(.vs-dark) .monaco-scrollable-element > .scrollbar > .slider.active {
	background: rgba(191, 191, 191, .4);
}
:host-context(.hc-black) .monaco-scrollable-element > .scrollbar > .slider.active {
	background: rgba(111, 195, 223, 1);
}

:host-context(.vs-dark) .monaco-scrollable-element .shadow.top {
	box-shadow: none;
}

:host-context(.vs-dark) .monaco-scrollable-element .shadow.left {
	box-shadow: #000 6px 0 6px -6px inset;
}

:host-context(.vs-dark) .monaco-scrollable-element .shadow.top.left {
	box-shadow: #000 6px 6px 6px -6px inset;
}

:host-context(.hc-black) .monaco-scrollable-element .shadow.top {
	box-shadow: none;
}

:host-context(.hc-black) .monaco-scrollable-element .shadow.left {
	box-shadow: none;
}

:host-context(.hc-black) .monaco-scrollable-element .shadow.top.left {
	box-shadow: none;
}
`;

// ../../node_modules/monaco-editor/esm/vs/platform/theme/common/styler.js
function computeStyles(theme, styleMap) {
  const styles = Object.create(null);
  for (let key in styleMap) {
    const value = styleMap[key];
    if (value) {
      styles[key] = resolveColorValue(value, theme);
    }
  }
  return styles;
}
function attachStyler(themeService, styleMap, widgetOrCallback) {
  function applyStyles(theme) {
    const styles = computeStyles(themeService.getColorTheme(), styleMap);
    if (typeof widgetOrCallback === "function") {
      widgetOrCallback(styles);
    } else {
      widgetOrCallback.style(styles);
    }
  }
  applyStyles(themeService.getColorTheme());
  return themeService.onDidColorThemeChange(applyStyles);
}
function attachListStyler(widget, themeService, overrides) {
  return attachStyler(themeService, Object.assign(Object.assign({}, defaultListStyles), overrides || {}), widget);
}
var defaultListStyles = {
  listFocusBackground,
  listFocusForeground,
  listActiveSelectionBackground: darken(listActiveSelectionBackground, 0.1),
  listActiveSelectionForeground,
  listFocusAndSelectionBackground: listActiveSelectionBackground,
  listFocusAndSelectionForeground: listActiveSelectionForeground,
  listInactiveSelectionBackground,
  listInactiveSelectionForeground,
  listInactiveFocusBackground,
  listHoverBackground,
  listHoverForeground,
  listDropBackground,
  listFocusOutline: activeContrastBorder,
  listSelectionOutline: activeContrastBorder,
  listHoverOutline: activeContrastBorder,
  listFilterWidgetBackground,
  listFilterWidgetOutline,
  listFilterWidgetNoMatchesOutline,
  listMatchesShadow: widgetShadow,
  treeIndentGuidesStroke
};
var defaultMenuStyles = {
  shadowColor: widgetShadow,
  borderColor: menuBorder,
  foregroundColor: menuForeground,
  backgroundColor: menuBackground,
  selectionForegroundColor: menuSelectionForeground,
  selectionBackgroundColor: menuSelectionBackground,
  selectionBorderColor: menuSelectionBorder,
  separatorColor: menuSeparatorBackground
};
function attachMenuStyler(widget, themeService, style) {
  return attachStyler(themeService, Object.assign(Object.assign({}, defaultMenuStyles), style), widget);
}

// ../../node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuHandler.js
var ContextMenuHandler = class {
  constructor(contextViewService, telemetryService, notificationService, keybindingService, themeService) {
    this.contextViewService = contextViewService;
    this.telemetryService = telemetryService;
    this.notificationService = notificationService;
    this.keybindingService = keybindingService;
    this.themeService = themeService;
    this.focusToReturn = null;
    this.block = null;
    this.options = {blockMouse: true};
  }
  configure(options) {
    this.options = options;
  }
  showContextMenu(delegate) {
    const actions = delegate.getActions();
    if (!actions.length) {
      return;
    }
    this.focusToReturn = document.activeElement;
    let menu;
    let shadowRootElement = isHTMLElement(delegate.domForShadowRoot) ? delegate.domForShadowRoot : void 0;
    this.contextViewService.showContextView({
      getAnchor: () => delegate.getAnchor(),
      canRelayout: false,
      anchorAlignment: delegate.anchorAlignment,
      render: (container) => {
        let className = delegate.getMenuClassName ? delegate.getMenuClassName() : "";
        if (className) {
          container.className += " " + className;
        }
        if (this.options.blockMouse) {
          this.block = container.appendChild($(".context-view-block"));
          this.block.style.position = "fixed";
          this.block.style.cursor = "initial";
          this.block.style.left = "0";
          this.block.style.top = "0";
          this.block.style.width = "100%";
          this.block.style.height = "100%";
          this.block.style.zIndex = "-1";
          domEvent(this.block, EventType.MOUSE_DOWN)((e) => e.stopPropagation());
        }
        const menuDisposables = new DisposableStore();
        const actionRunner = delegate.actionRunner || new ActionRunner();
        actionRunner.onDidBeforeRun(this.onActionRun, this, menuDisposables);
        actionRunner.onDidRun(this.onDidActionRun, this, menuDisposables);
        menu = new Menu(container, actions, {
          actionViewItemProvider: delegate.getActionViewItem,
          context: delegate.getActionsContext ? delegate.getActionsContext() : null,
          actionRunner,
          getKeyBinding: delegate.getKeyBinding ? delegate.getKeyBinding : (action) => this.keybindingService.lookupKeybinding(action.id)
        });
        menuDisposables.add(attachMenuStyler(menu, this.themeService));
        menu.onDidCancel(() => this.contextViewService.hideContextView(true), null, menuDisposables);
        menu.onDidBlur(() => this.contextViewService.hideContextView(true), null, menuDisposables);
        domEvent(window, EventType.BLUR)(() => {
          this.contextViewService.hideContextView(true);
        }, null, menuDisposables);
        domEvent(window, EventType.MOUSE_DOWN)((e) => {
          if (e.defaultPrevented) {
            return;
          }
          let event = new StandardMouseEvent(e);
          let element = event.target;
          if (event.rightButton) {
            return;
          }
          while (element) {
            if (element === container) {
              return;
            }
            element = element.parentElement;
          }
          this.contextViewService.hideContextView(true);
        }, null, menuDisposables);
        return combinedDisposable(menuDisposables, menu);
      },
      focus: () => {
        if (menu) {
          menu.focus(!!delegate.autoSelectFirstItem);
        }
      },
      onHide: (didCancel) => {
        if (delegate.onHide) {
          delegate.onHide(!!didCancel);
        }
        if (this.block) {
          removeNode(this.block);
          this.block = null;
        }
        if (this.focusToReturn) {
          this.focusToReturn.focus();
        }
      }
    }, shadowRootElement, !!shadowRootElement);
  }
  onActionRun(e) {
    if (this.telemetryService) {
      this.telemetryService.publicLog2("workbenchActionExecuted", {id: e.action.id, from: "contextMenu"});
    }
    this.contextViewService.hideContextView(false);
    if (this.focusToReturn) {
      this.focusToReturn.focus();
    }
  }
  onDidActionRun(e) {
    if (e.error && this.notificationService) {
      this.notificationService.error(e.error);
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuService.js
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param11 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContextMenuService = class ContextMenuService2 extends Disposable {
  constructor(telemetryService, notificationService, contextViewService, keybindingService, themeService) {
    super();
    this._onDidContextMenu = this._register(new Emitter());
    this.onDidContextMenu = this._onDidContextMenu.event;
    this.contextMenuHandler = new ContextMenuHandler(contextViewService, telemetryService, notificationService, keybindingService, themeService);
  }
  configure(options) {
    this.contextMenuHandler.configure(options);
  }
  showContextMenu(delegate) {
    this.contextMenuHandler.showContextMenu(delegate);
    this._onDidContextMenu.fire();
  }
};
ContextMenuService = __decorate12([
  __param11(0, ITelemetryService),
  __param11(1, INotificationService),
  __param11(2, IContextViewService),
  __param11(3, IKeybindingService),
  __param11(4, IThemeService)
], ContextMenuService);

// ../../node_modules/monaco-editor/esm/vs/platform/layout/browser/layoutService.js
var ILayoutService = createDecorator("layoutService");

// ../../node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextViewService.js
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param12 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContextViewService = class ContextViewService2 extends Disposable {
  constructor(layoutService) {
    super();
    this.layoutService = layoutService;
    this.currentViewDisposable = Disposable.None;
    this.container = layoutService.container;
    this.contextView = this._register(new ContextView(this.container, 1));
    this.layout();
    this._register(layoutService.onLayout(() => this.layout()));
  }
  setContainer(container, domPosition) {
    this.contextView.setContainer(container, domPosition || 1);
  }
  showContextView(delegate, container, shadowRoot) {
    if (container) {
      if (container !== this.container) {
        this.container = container;
        this.setContainer(container, shadowRoot ? 3 : 2);
      }
    } else {
      if (this.container !== this.layoutService.container) {
        this.container = this.layoutService.container;
        this.setContainer(this.container, 1);
      }
    }
    this.contextView.show(delegate);
    const disposable = toDisposable(() => {
      if (this.currentViewDisposable === disposable) {
        this.hideContextView();
      }
    });
    this.currentViewDisposable = disposable;
    return disposable;
  }
  getContextViewElement() {
    return this.contextView.getViewElement();
  }
  layout() {
    this.contextView.layout();
  }
  hideContextView(data) {
    this.contextView.hide(data);
  }
};
ContextViewService = __decorate13([
  __param12(0, ILayoutService)
], ContextViewService);

// ../../node_modules/monaco-editor/esm/vs/platform/dialogs/common/dialogs.js
var IDialogService = createDecorator("dialogService");

// ../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/graph.js
var Node3 = class {
  constructor(data) {
    this.incoming = new Map();
    this.outgoing = new Map();
    this.data = data;
  }
};
var Graph = class {
  constructor(_hashFn) {
    this._hashFn = _hashFn;
    this._nodes = new Map();
  }
  roots() {
    const ret = [];
    for (let node of this._nodes.values()) {
      if (node.outgoing.size === 0) {
        ret.push(node);
      }
    }
    return ret;
  }
  insertEdge(from, to) {
    const fromNode = this.lookupOrInsertNode(from);
    const toNode = this.lookupOrInsertNode(to);
    fromNode.outgoing.set(this._hashFn(to), toNode);
    toNode.incoming.set(this._hashFn(from), fromNode);
  }
  removeNode(data) {
    const key = this._hashFn(data);
    this._nodes.delete(key);
    for (let node of this._nodes.values()) {
      node.outgoing.delete(key);
      node.incoming.delete(key);
    }
  }
  lookupOrInsertNode(data) {
    const key = this._hashFn(data);
    let node = this._nodes.get(key);
    if (!node) {
      node = new Node3(data);
      this._nodes.set(key, node);
    }
    return node;
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    let data = [];
    for (let [key, value] of this._nodes) {
      data.push(`${key}, (incoming)[${[...value.incoming.keys()].join(", ")}], (outgoing)[${[...value.outgoing.keys()].join(",")}]`);
    }
    return data.join("\n");
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js
var _enableTracing = false;
var CyclicDependencyError = class extends Error {
  constructor(graph) {
    super("cyclic dependency between services");
    this.message = graph.toString();
  }
};
var InstantiationService = class {
  constructor(services = new ServiceCollection(), strict = false, parent) {
    this._services = services;
    this._strict = strict;
    this._parent = parent;
    this._services.set(IInstantiationService, this);
  }
  createChild(services) {
    return new InstantiationService(services, this._strict, this);
  }
  invokeFunction(fn, ...args) {
    let _trace = Trace.traceInvocation(fn);
    let _done = false;
    try {
      const accessor = {
        get: (id, isOptional) => {
          if (_done) {
            throw illegalState("service accessor is only valid during the invocation of its target method");
          }
          const result = this._getOrCreateServiceInstance(id, _trace);
          if (!result && isOptional !== optional) {
            throw new Error(`[invokeFunction] unknown service '${id}'`);
          }
          return result;
        }
      };
      return fn(accessor, ...args);
    } finally {
      _done = true;
      _trace.stop();
    }
  }
  createInstance(ctorOrDescriptor, ...rest) {
    let _trace;
    let result;
    if (ctorOrDescriptor instanceof SyncDescriptor) {
      _trace = Trace.traceCreation(ctorOrDescriptor.ctor);
      result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);
    } else {
      _trace = Trace.traceCreation(ctorOrDescriptor);
      result = this._createInstance(ctorOrDescriptor, rest, _trace);
    }
    _trace.stop();
    return result;
  }
  _createInstance(ctor, args = [], _trace) {
    let serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);
    let serviceArgs = [];
    for (const dependency of serviceDependencies) {
      let service = this._getOrCreateServiceInstance(dependency.id, _trace);
      if (!service && this._strict && !dependency.optional) {
        throw new Error(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`);
      }
      serviceArgs.push(service);
    }
    let firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;
    if (args.length !== firstServiceArgPos) {
      console.warn(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);
      let delta = firstServiceArgPos - args.length;
      if (delta > 0) {
        args = args.concat(new Array(delta));
      } else {
        args = args.slice(0, firstServiceArgPos);
      }
    }
    return new ctor(...[...args, ...serviceArgs]);
  }
  _setServiceInstance(id, instance) {
    if (this._services.get(id) instanceof SyncDescriptor) {
      this._services.set(id, instance);
    } else if (this._parent) {
      this._parent._setServiceInstance(id, instance);
    } else {
      throw new Error("illegalState - setting UNKNOWN service instance");
    }
  }
  _getServiceInstanceOrDescriptor(id) {
    let instanceOrDesc = this._services.get(id);
    if (!instanceOrDesc && this._parent) {
      return this._parent._getServiceInstanceOrDescriptor(id);
    } else {
      return instanceOrDesc;
    }
  }
  _getOrCreateServiceInstance(id, _trace) {
    let thing = this._getServiceInstanceOrDescriptor(id);
    if (thing instanceof SyncDescriptor) {
      return this._createAndCacheServiceInstance(id, thing, _trace.branch(id, true));
    } else {
      _trace.branch(id, false);
      return thing;
    }
  }
  _createAndCacheServiceInstance(id, desc, _trace) {
    const graph = new Graph((data) => data.id.toString());
    let cycleCount = 0;
    const stack = [{id, desc, _trace}];
    while (stack.length) {
      const item = stack.pop();
      graph.lookupOrInsertNode(item);
      if (cycleCount++ > 1e3) {
        throw new CyclicDependencyError(graph);
      }
      for (let dependency of _util.getServiceDependencies(item.desc.ctor)) {
        let instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);
        if (!instanceOrDesc && !dependency.optional) {
          console.warn(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`);
        }
        if (instanceOrDesc instanceof SyncDescriptor) {
          const d = {id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true)};
          graph.insertEdge(item, d);
          stack.push(d);
        }
      }
    }
    while (true) {
      const roots = graph.roots();
      if (roots.length === 0) {
        if (!graph.isEmpty()) {
          throw new CyclicDependencyError(graph);
        }
        break;
      }
      for (const {data} of roots) {
        const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);
        this._setServiceInstance(data.id, instance);
        graph.removeNode(data);
      }
    }
    return this._getServiceInstanceOrDescriptor(id);
  }
  _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {
    if (this._services.get(id) instanceof SyncDescriptor) {
      return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);
    } else if (this._parent) {
      return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);
    } else {
      throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);
    }
  }
  _createServiceInstance(ctor, args = [], _supportsDelayedInstantiation, _trace) {
    if (!_supportsDelayedInstantiation) {
      return this._createInstance(ctor, args, _trace);
    } else {
      const idle = new IdleValue(() => this._createInstance(ctor, args, _trace));
      return new Proxy(Object.create(null), {
        get(target, key) {
          if (key in target) {
            return target[key];
          }
          let obj = idle.value;
          let prop = obj[key];
          if (typeof prop !== "function") {
            return prop;
          }
          prop = prop.bind(obj);
          target[key] = prop;
          return prop;
        },
        set(_target, p, value) {
          idle.value[p] = value;
          return true;
        }
      });
    }
  }
};
var Trace = class {
  constructor(type, name) {
    this.type = type;
    this.name = name;
    this._start = Date.now();
    this._dep = [];
  }
  static traceInvocation(ctor) {
    return !_enableTracing ? Trace._None : new Trace(1, ctor.name || ctor.toString().substring(0, 42).replace(/\n/g, ""));
  }
  static traceCreation(ctor) {
    return !_enableTracing ? Trace._None : new Trace(0, ctor.name);
  }
  branch(id, first2) {
    let child = new Trace(2, id.toString());
    this._dep.push([id, first2, child]);
    return child;
  }
  stop() {
    let dur = Date.now() - this._start;
    Trace._totals += dur;
    let causedCreation = false;
    function printChild(n, trace) {
      let res = [];
      let prefix = new Array(n + 1).join("	");
      for (const [id, first2, child] of trace._dep) {
        if (first2 && child) {
          causedCreation = true;
          res.push(`${prefix}CREATES -> ${id}`);
          let nested = printChild(n + 1, child);
          if (nested) {
            res.push(nested);
          }
        } else {
          res.push(`${prefix}uses -> ${id}`);
        }
      }
      return res.join("\n");
    }
    let lines = [
      `${this.type === 0 ? "CREATE" : "CALL"} ${this.name}`,
      `${printChild(1, this)}`,
      `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`
    ];
    if (dur > 2 || causedCreation) {
      console.log(lines.join("\n"));
    }
  }
};
Trace._None = new class extends Trace {
  constructor() {
    super(-1, null);
  }
  stop() {
  }
  branch() {
    return this;
  }
}();
Trace._totals = 0;

// ../../node_modules/monaco-editor/esm/vs/platform/label/common/label.js
var ILabelService = createDecorator("labelService");

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/list.js
var ListError = class extends Error {
  constructor(user, message) {
    super(`ListError [${user}] ${message}`);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/rangeMap.js
function groupIntersect(range2, groups) {
  const result = [];
  for (let r of groups) {
    if (range2.start >= r.range.end) {
      continue;
    }
    if (range2.end < r.range.start) {
      break;
    }
    const intersection = Range2.intersect(range2, r.range);
    if (Range2.isEmpty(intersection)) {
      continue;
    }
    result.push({
      range: intersection,
      size: r.size
    });
  }
  return result;
}
function shift({start, end}, much) {
  return {start: start + much, end: end + much};
}
function consolidate(groups) {
  const result = [];
  let previousGroup = null;
  for (let group of groups) {
    const start = group.range.start;
    const end = group.range.end;
    const size = group.size;
    if (previousGroup && size === previousGroup.size) {
      previousGroup.range.end = end;
      continue;
    }
    previousGroup = {range: {start, end}, size};
    result.push(previousGroup);
  }
  return result;
}
function concat(...groups) {
  return consolidate(groups.reduce((r, g) => r.concat(g), []));
}
var RangeMap = class {
  constructor() {
    this.groups = [];
    this._size = 0;
  }
  splice(index, deleteCount, items = []) {
    const diff = items.length - deleteCount;
    const before = groupIntersect({start: 0, end: index}, this.groups);
    const after = groupIntersect({start: index + deleteCount, end: Number.POSITIVE_INFINITY}, this.groups).map((g) => ({range: shift(g.range, diff), size: g.size}));
    const middle = items.map((item, i) => ({
      range: {start: index + i, end: index + i + 1},
      size: item.size
    }));
    this.groups = concat(before, middle, after);
    this._size = this.groups.reduce((t, g) => t + g.size * (g.range.end - g.range.start), 0);
  }
  get count() {
    const len = this.groups.length;
    if (!len) {
      return 0;
    }
    return this.groups[len - 1].range.end;
  }
  get size() {
    return this._size;
  }
  indexAt(position) {
    if (position < 0) {
      return -1;
    }
    let index = 0;
    let size = 0;
    for (let group of this.groups) {
      const count = group.range.end - group.range.start;
      const newSize = size + count * group.size;
      if (position < newSize) {
        return index + Math.floor((position - size) / group.size);
      }
      index += count;
      size = newSize;
    }
    return index;
  }
  indexAfter(position) {
    return Math.min(this.indexAt(position) + 1, this.count);
  }
  positionAt(index) {
    if (index < 0) {
      return -1;
    }
    let position = 0;
    let count = 0;
    for (let group of this.groups) {
      const groupCount = group.range.end - group.range.start;
      const newCount = count + groupCount;
      if (index < newCount) {
        return position + (index - count) * group.size;
      }
      position += groupCount * group.size;
      count = newCount;
    }
    return -1;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/rowCache.js
function removeFromParent(element) {
  try {
    if (element.parentElement) {
      element.parentElement.removeChild(element);
    }
  } catch (e) {
  }
}
var RowCache = class {
  constructor(renderers) {
    this.renderers = renderers;
    this.cache = new Map();
  }
  alloc(templateId) {
    let result = this.getTemplateCache(templateId).pop();
    if (!result) {
      const domNode = $(".monaco-list-row");
      const renderer = this.getRenderer(templateId);
      const templateData = renderer.renderTemplate(domNode);
      result = {domNode, templateId, templateData};
    }
    return result;
  }
  release(row) {
    if (!row) {
      return;
    }
    this.releaseRow(row);
  }
  releaseRow(row) {
    const {domNode, templateId} = row;
    if (domNode) {
      removeClass(domNode, "scrolling");
      removeFromParent(domNode);
    }
    const cache = this.getTemplateCache(templateId);
    cache.push(row);
  }
  getTemplateCache(templateId) {
    let result = this.cache.get(templateId);
    if (!result) {
      result = [];
      this.cache.set(templateId, result);
    }
    return result;
  }
  dispose() {
    this.cache.forEach((cachedRows, templateId) => {
      for (const cachedRow of cachedRows) {
        const renderer = this.getRenderer(templateId);
        renderer.disposeTemplate(cachedRow.templateData);
        cachedRow.domNode = null;
        cachedRow.templateData = null;
      }
    });
    this.cache.clear();
  }
  getRenderer(templateId) {
    const renderer = this.renderers.get(templateId);
    if (!renderer) {
      throw new Error(`No renderer found for ${templateId}`);
    }
    return renderer;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/listView.js
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultOptions = {
  useShadows: true,
  verticalScrollMode: 1,
  setRowLineHeight: true,
  setRowHeight: true,
  supportDynamicHeights: false,
  dnd: {
    getDragElements(e) {
      return [e];
    },
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return false;
    },
    drop() {
    }
  },
  horizontalScrolling: false,
  transformOptimization: true
};
var ElementsDragAndDropData = class {
  constructor(elements) {
    this.elements = elements;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
};
var ExternalElementsDragAndDropData = class {
  constructor(elements) {
    this.elements = elements;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
};
var NativeDragAndDropData = class {
  constructor() {
    this.types = [];
    this.files = [];
  }
  update(dataTransfer) {
    if (dataTransfer.types) {
      this.types.splice(0, this.types.length, ...dataTransfer.types);
    }
    if (dataTransfer.files) {
      this.files.splice(0, this.files.length);
      for (let i = 0; i < dataTransfer.files.length; i++) {
        const file = dataTransfer.files.item(i);
        if (file && (file.size || file.type)) {
          this.files.push(file);
        }
      }
    }
  }
  getData() {
    return {
      types: this.types,
      files: this.files
    };
  }
};
function equalsDragFeedback(f1, f2) {
  if (Array.isArray(f1) && Array.isArray(f2)) {
    return equals(f1, f2);
  }
  return f1 === f2;
}
var ListViewAccessibilityProvider = class {
  constructor(accessibilityProvider) {
    if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getSetSize) {
      this.getSetSize = accessibilityProvider.getSetSize.bind(accessibilityProvider);
    } else {
      this.getSetSize = (e, i, l) => l;
    }
    if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getPosInSet) {
      this.getPosInSet = accessibilityProvider.getPosInSet.bind(accessibilityProvider);
    } else {
      this.getPosInSet = (e, i) => i + 1;
    }
    if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getRole) {
      this.getRole = accessibilityProvider.getRole.bind(accessibilityProvider);
    } else {
      this.getRole = (_) => "listitem";
    }
    if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.isChecked) {
      this.isChecked = accessibilityProvider.isChecked.bind(accessibilityProvider);
    } else {
      this.isChecked = (_) => void 0;
    }
  }
};
var ListView = class {
  constructor(container, virtualDelegate, renderers, options = DefaultOptions) {
    this.virtualDelegate = virtualDelegate;
    this.domId = `list_id_${++ListView.InstanceCount}`;
    this.renderers = new Map();
    this.renderWidth = 0;
    this._scrollHeight = 0;
    this.scrollableElementUpdateDisposable = null;
    this.scrollableElementWidthDelayer = new Delayer(50);
    this.splicing = false;
    this.dragOverAnimationStopDisposable = Disposable.None;
    this.dragOverMouseY = 0;
    this.canDrop = false;
    this.currentDragFeedbackDisposable = Disposable.None;
    this.onDragLeaveTimeout = Disposable.None;
    this.disposables = new DisposableStore();
    this._onDidChangeContentHeight = new Emitter();
    this._horizontalScrolling = false;
    if (options.horizontalScrolling && options.supportDynamicHeights) {
      throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
    }
    this.items = [];
    this.itemId = 0;
    this.rangeMap = new RangeMap();
    for (const renderer of renderers) {
      this.renderers.set(renderer.templateId, renderer);
    }
    this.cache = this.disposables.add(new RowCache(this.renderers));
    this.lastRenderTop = 0;
    this.lastRenderHeight = 0;
    this.domNode = document.createElement("div");
    this.domNode.className = "monaco-list";
    addClass(this.domNode, this.domId);
    this.domNode.tabIndex = 0;
    toggleClass(this.domNode, "mouse-support", typeof options.mouseSupport === "boolean" ? options.mouseSupport : true);
    this._horizontalScrolling = getOrDefault(options, (o) => o.horizontalScrolling, DefaultOptions.horizontalScrolling);
    toggleClass(this.domNode, "horizontal-scrolling", this._horizontalScrolling);
    this.additionalScrollHeight = typeof options.additionalScrollHeight === "undefined" ? 0 : options.additionalScrollHeight;
    this.accessibilityProvider = new ListViewAccessibilityProvider(options.accessibilityProvider);
    this.rowsContainer = document.createElement("div");
    this.rowsContainer.className = "monaco-list-rows";
    const transformOptimization = getOrDefault(options, (o) => o.transformOptimization, DefaultOptions.transformOptimization);
    if (transformOptimization) {
      this.rowsContainer.style.transform = "translate3d(0px, 0px, 0px)";
    }
    this.disposables.add(Gesture.addTarget(this.rowsContainer));
    this.scrollable = new Scrollable(getOrDefault(options, (o) => o.smoothScrolling, false) ? 125 : 0, (cb) => scheduleAtNextAnimationFrame(cb));
    this.scrollableElement = this.disposables.add(new SmoothScrollableElement(this.rowsContainer, {
      alwaysConsumeMouseWheel: true,
      horizontal: 1,
      vertical: getOrDefault(options, (o) => o.verticalScrollMode, DefaultOptions.verticalScrollMode),
      useShadows: getOrDefault(options, (o) => o.useShadows, DefaultOptions.useShadows)
    }, this.scrollable));
    this.domNode.appendChild(this.scrollableElement.getDomNode());
    container.appendChild(this.domNode);
    this.scrollableElement.onScroll(this.onScroll, this, this.disposables);
    domEvent(this.rowsContainer, EventType2.Change)(this.onTouchChange, this, this.disposables);
    domEvent(this.scrollableElement.getDomNode(), "scroll")((e) => e.target.scrollTop = 0, null, this.disposables);
    Event.map(domEvent(this.domNode, "dragover"), (e) => this.toDragEvent(e))(this.onDragOver, this, this.disposables);
    Event.map(domEvent(this.domNode, "drop"), (e) => this.toDragEvent(e))(this.onDrop, this, this.disposables);
    domEvent(this.domNode, "dragleave")(this.onDragLeave, this, this.disposables);
    domEvent(window, "dragend")(this.onDragEnd, this, this.disposables);
    this.setRowLineHeight = getOrDefault(options, (o) => o.setRowLineHeight, DefaultOptions.setRowLineHeight);
    this.setRowHeight = getOrDefault(options, (o) => o.setRowHeight, DefaultOptions.setRowHeight);
    this.supportDynamicHeights = getOrDefault(options, (o) => o.supportDynamicHeights, DefaultOptions.supportDynamicHeights);
    this.dnd = getOrDefault(options, (o) => o.dnd, DefaultOptions.dnd);
    this.layout();
  }
  get contentHeight() {
    return this.rangeMap.size;
  }
  get horizontalScrolling() {
    return this._horizontalScrolling;
  }
  set horizontalScrolling(value) {
    if (value === this._horizontalScrolling) {
      return;
    }
    if (value && this.supportDynamicHeights) {
      throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
    }
    this._horizontalScrolling = value;
    toggleClass(this.domNode, "horizontal-scrolling", this._horizontalScrolling);
    if (this._horizontalScrolling) {
      for (const item of this.items) {
        this.measureItemWidth(item);
      }
      this.updateScrollWidth();
      this.scrollableElement.setScrollDimensions({width: getContentWidth(this.domNode)});
      this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;
    } else {
      this.scrollableElementWidthDelayer.cancel();
      this.scrollableElement.setScrollDimensions({width: this.renderWidth, scrollWidth: this.renderWidth});
      this.rowsContainer.style.width = "";
    }
  }
  updateOptions(options) {
    if (options.additionalScrollHeight !== void 0) {
      this.additionalScrollHeight = options.additionalScrollHeight;
    }
    if (options.smoothScrolling !== void 0) {
      this.scrollable.setSmoothScrollDuration(options.smoothScrolling ? 125 : 0);
    }
    if (options.horizontalScrolling !== void 0) {
      this.horizontalScrolling = options.horizontalScrolling;
    }
  }
  splice(start, deleteCount, elements = []) {
    if (this.splicing) {
      throw new Error("Can't run recursive splices.");
    }
    this.splicing = true;
    try {
      return this._splice(start, deleteCount, elements);
    } finally {
      this.splicing = false;
      this._onDidChangeContentHeight.fire(this.contentHeight);
    }
  }
  _splice(start, deleteCount, elements = []) {
    const previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
    const deleteRange = {start, end: start + deleteCount};
    const removeRange = Range2.intersect(previousRenderRange, deleteRange);
    for (let i = removeRange.start; i < removeRange.end; i++) {
      this.removeItemFromDOM(i);
    }
    const previousRestRange = {start: start + deleteCount, end: this.items.length};
    const previousRenderedRestRange = Range2.intersect(previousRestRange, previousRenderRange);
    const previousUnrenderedRestRanges = Range2.relativeComplement(previousRestRange, previousRenderRange);
    const inserted = elements.map((element) => ({
      id: String(this.itemId++),
      element,
      templateId: this.virtualDelegate.getTemplateId(element),
      size: this.virtualDelegate.getHeight(element),
      width: void 0,
      hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(element),
      lastDynamicHeightWidth: void 0,
      row: null,
      uri: void 0,
      dropTarget: false,
      dragStartDisposable: Disposable.None
    }));
    let deleted;
    if (start === 0 && deleteCount >= this.items.length) {
      this.rangeMap = new RangeMap();
      this.rangeMap.splice(0, 0, inserted);
      this.items = inserted;
      deleted = [];
    } else {
      this.rangeMap.splice(start, deleteCount, inserted);
      deleted = this.items.splice(start, deleteCount, ...inserted);
    }
    const delta = elements.length - deleteCount;
    const renderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
    const renderedRestRange = shift(previousRenderedRestRange, delta);
    const updateRange = Range2.intersect(renderRange, renderedRestRange);
    for (let i = updateRange.start; i < updateRange.end; i++) {
      this.updateItemInDOM(this.items[i], i);
    }
    const removeRanges = Range2.relativeComplement(renderedRestRange, renderRange);
    for (const range2 of removeRanges) {
      for (let i = range2.start; i < range2.end; i++) {
        this.removeItemFromDOM(i);
      }
    }
    const unrenderedRestRanges = previousUnrenderedRestRanges.map((r) => shift(r, delta));
    const elementsRange = {start, end: start + elements.length};
    const insertRanges = [elementsRange, ...unrenderedRestRanges].map((r) => Range2.intersect(renderRange, r));
    const beforeElement = this.getNextToLastElement(insertRanges);
    for (const range2 of insertRanges) {
      for (let i = range2.start; i < range2.end; i++) {
        this.insertItemInDOM(i, beforeElement);
      }
    }
    this.eventuallyUpdateScrollDimensions();
    if (this.supportDynamicHeights) {
      this._rerender(this.scrollTop, this.renderHeight);
    }
    return deleted.map((i) => i.element);
  }
  eventuallyUpdateScrollDimensions() {
    this._scrollHeight = this.contentHeight;
    this.rowsContainer.style.height = `${this._scrollHeight}px`;
    if (!this.scrollableElementUpdateDisposable) {
      this.scrollableElementUpdateDisposable = scheduleAtNextAnimationFrame(() => {
        this.scrollableElement.setScrollDimensions({scrollHeight: this.scrollHeight});
        this.updateScrollWidth();
        this.scrollableElementUpdateDisposable = null;
      });
    }
  }
  eventuallyUpdateScrollWidth() {
    if (!this.horizontalScrolling) {
      this.scrollableElementWidthDelayer.cancel();
      return;
    }
    this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());
  }
  updateScrollWidth() {
    if (!this.horizontalScrolling) {
      return;
    }
    let scrollWidth = 0;
    for (const item of this.items) {
      if (typeof item.width !== "undefined") {
        scrollWidth = Math.max(scrollWidth, item.width);
      }
    }
    this.scrollWidth = scrollWidth;
    this.scrollableElement.setScrollDimensions({scrollWidth: scrollWidth === 0 ? 0 : scrollWidth + 10});
  }
  rerender() {
    if (!this.supportDynamicHeights) {
      return;
    }
    for (const item of this.items) {
      item.lastDynamicHeightWidth = void 0;
    }
    this._rerender(this.lastRenderTop, this.lastRenderHeight);
  }
  get length() {
    return this.items.length;
  }
  get renderHeight() {
    const scrollDimensions = this.scrollableElement.getScrollDimensions();
    return scrollDimensions.height;
  }
  element(index) {
    return this.items[index].element;
  }
  domElement(index) {
    const row = this.items[index].row;
    return row && row.domNode;
  }
  elementHeight(index) {
    return this.items[index].size;
  }
  elementTop(index) {
    return this.rangeMap.positionAt(index);
  }
  indexAt(position) {
    return this.rangeMap.indexAt(position);
  }
  indexAfter(position) {
    return this.rangeMap.indexAfter(position);
  }
  layout(height, width) {
    let scrollDimensions = {
      height: typeof height === "number" ? height : getContentHeight(this.domNode)
    };
    if (this.scrollableElementUpdateDisposable) {
      this.scrollableElementUpdateDisposable.dispose();
      this.scrollableElementUpdateDisposable = null;
      scrollDimensions.scrollHeight = this.scrollHeight;
    }
    this.scrollableElement.setScrollDimensions(scrollDimensions);
    if (typeof width !== "undefined") {
      this.renderWidth = width;
      if (this.supportDynamicHeights) {
        this._rerender(this.scrollTop, this.renderHeight);
      }
      if (this.horizontalScrolling) {
        this.scrollableElement.setScrollDimensions({
          width: typeof width === "number" ? width : getContentWidth(this.domNode)
        });
      }
    }
  }
  render(previousRenderRange, renderTop, renderHeight, renderLeft, scrollWidth, updateItemsInDOM = false) {
    const renderRange = this.getRenderRange(renderTop, renderHeight);
    const rangesToInsert = Range2.relativeComplement(renderRange, previousRenderRange);
    const rangesToRemove = Range2.relativeComplement(previousRenderRange, renderRange);
    const beforeElement = this.getNextToLastElement(rangesToInsert);
    if (updateItemsInDOM) {
      const rangesToUpdate = Range2.intersect(previousRenderRange, renderRange);
      for (let i = rangesToUpdate.start; i < rangesToUpdate.end; i++) {
        this.updateItemInDOM(this.items[i], i);
      }
    }
    for (const range2 of rangesToInsert) {
      for (let i = range2.start; i < range2.end; i++) {
        this.insertItemInDOM(i, beforeElement);
      }
    }
    for (const range2 of rangesToRemove) {
      for (let i = range2.start; i < range2.end; i++) {
        this.removeItemFromDOM(i);
      }
    }
    if (renderLeft !== void 0) {
      this.rowsContainer.style.left = `-${renderLeft}px`;
    }
    this.rowsContainer.style.top = `-${renderTop}px`;
    if (this.horizontalScrolling && scrollWidth !== void 0) {
      this.rowsContainer.style.width = `${Math.max(scrollWidth, this.renderWidth)}px`;
    }
    this.lastRenderTop = renderTop;
    this.lastRenderHeight = renderHeight;
  }
  insertItemInDOM(index, beforeElement) {
    const item = this.items[index];
    if (!item.row) {
      item.row = this.cache.alloc(item.templateId);
      const role = this.accessibilityProvider.getRole(item.element) || "listitem";
      item.row.domNode.setAttribute("role", role);
      const checked = this.accessibilityProvider.isChecked(item.element);
      if (typeof checked !== "undefined") {
        item.row.domNode.setAttribute("aria-checked", String(!!checked));
      }
    }
    if (!item.row.domNode.parentElement) {
      if (beforeElement) {
        this.rowsContainer.insertBefore(item.row.domNode, beforeElement);
      } else {
        this.rowsContainer.appendChild(item.row.domNode);
      }
    }
    this.updateItemInDOM(item, index);
    const renderer = this.renderers.get(item.templateId);
    if (!renderer) {
      throw new Error(`No renderer found for template id ${item.templateId}`);
    }
    if (renderer) {
      renderer.renderElement(item.element, index, item.row.templateData, item.size);
    }
    const uri = this.dnd.getDragURI(item.element);
    item.dragStartDisposable.dispose();
    item.row.domNode.draggable = !!uri;
    if (uri) {
      const onDragStart = domEvent(item.row.domNode, "dragstart");
      item.dragStartDisposable = onDragStart((event) => this.onDragStart(item.element, uri, event));
    }
    if (this.horizontalScrolling) {
      this.measureItemWidth(item);
      this.eventuallyUpdateScrollWidth();
    }
  }
  measureItemWidth(item) {
    if (!item.row || !item.row.domNode) {
      return;
    }
    item.row.domNode.style.width = isFirefox ? "-moz-fit-content" : "fit-content";
    item.width = getContentWidth(item.row.domNode);
    const style = window.getComputedStyle(item.row.domNode);
    if (style.paddingLeft) {
      item.width += parseFloat(style.paddingLeft);
    }
    if (style.paddingRight) {
      item.width += parseFloat(style.paddingRight);
    }
    item.row.domNode.style.width = "";
  }
  updateItemInDOM(item, index) {
    item.row.domNode.style.top = `${this.elementTop(index)}px`;
    if (this.setRowHeight) {
      item.row.domNode.style.height = `${item.size}px`;
    }
    if (this.setRowLineHeight) {
      item.row.domNode.style.lineHeight = `${item.size}px`;
    }
    item.row.domNode.setAttribute("data-index", `${index}`);
    item.row.domNode.setAttribute("data-last-element", index === this.length - 1 ? "true" : "false");
    item.row.domNode.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(item.element, index, this.length)));
    item.row.domNode.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(item.element, index)));
    item.row.domNode.setAttribute("id", this.getElementDomId(index));
    toggleClass(item.row.domNode, "drop-target", item.dropTarget);
  }
  removeItemFromDOM(index) {
    const item = this.items[index];
    item.dragStartDisposable.dispose();
    const renderer = this.renderers.get(item.templateId);
    if (item.row && renderer && renderer.disposeElement) {
      renderer.disposeElement(item.element, index, item.row.templateData, item.size);
    }
    this.cache.release(item.row);
    item.row = null;
    if (this.horizontalScrolling) {
      this.eventuallyUpdateScrollWidth();
    }
  }
  getScrollTop() {
    const scrollPosition = this.scrollableElement.getScrollPosition();
    return scrollPosition.scrollTop;
  }
  setScrollTop(scrollTop) {
    if (this.scrollableElementUpdateDisposable) {
      this.scrollableElementUpdateDisposable.dispose();
      this.scrollableElementUpdateDisposable = null;
      this.scrollableElement.setScrollDimensions({scrollHeight: this.scrollHeight});
    }
    this.scrollableElement.setScrollPosition({scrollTop});
  }
  get scrollTop() {
    return this.getScrollTop();
  }
  set scrollTop(scrollTop) {
    this.setScrollTop(scrollTop);
  }
  get scrollHeight() {
    return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.additionalScrollHeight;
  }
  get onMouseClick() {
    return Event.map(domEvent(this.domNode, "click"), (e) => this.toMouseEvent(e));
  }
  get onMouseDblClick() {
    return Event.map(domEvent(this.domNode, "dblclick"), (e) => this.toMouseEvent(e));
  }
  get onMouseMiddleClick() {
    return Event.filter(Event.map(domEvent(this.domNode, "auxclick"), (e) => this.toMouseEvent(e)), (e) => e.browserEvent.button === 1);
  }
  get onMouseDown() {
    return Event.map(domEvent(this.domNode, "mousedown"), (e) => this.toMouseEvent(e));
  }
  get onContextMenu() {
    return Event.map(domEvent(this.domNode, "contextmenu"), (e) => this.toMouseEvent(e));
  }
  get onTouchStart() {
    return Event.map(domEvent(this.domNode, "touchstart"), (e) => this.toTouchEvent(e));
  }
  get onTap() {
    return Event.map(domEvent(this.rowsContainer, EventType2.Tap), (e) => this.toGestureEvent(e));
  }
  toMouseEvent(browserEvent) {
    const index = this.getItemIndexFromEventTarget(browserEvent.target || null);
    const item = typeof index === "undefined" ? void 0 : this.items[index];
    const element = item && item.element;
    return {browserEvent, index, element};
  }
  toTouchEvent(browserEvent) {
    const index = this.getItemIndexFromEventTarget(browserEvent.target || null);
    const item = typeof index === "undefined" ? void 0 : this.items[index];
    const element = item && item.element;
    return {browserEvent, index, element};
  }
  toGestureEvent(browserEvent) {
    const index = this.getItemIndexFromEventTarget(browserEvent.initialTarget || null);
    const item = typeof index === "undefined" ? void 0 : this.items[index];
    const element = item && item.element;
    return {browserEvent, index, element};
  }
  toDragEvent(browserEvent) {
    const index = this.getItemIndexFromEventTarget(browserEvent.target || null);
    const item = typeof index === "undefined" ? void 0 : this.items[index];
    const element = item && item.element;
    return {browserEvent, index, element};
  }
  onScroll(e) {
    try {
      const previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
      this.render(previousRenderRange, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth);
      if (this.supportDynamicHeights) {
        this._rerender(e.scrollTop, e.height);
      }
    } catch (err) {
      console.error("Got bad scroll event:", e);
      throw err;
    }
  }
  onTouchChange(event) {
    event.preventDefault();
    event.stopPropagation();
    this.scrollTop -= event.translationY;
  }
  onDragStart(element, uri, event) {
    if (!event.dataTransfer) {
      return;
    }
    const elements = this.dnd.getDragElements(element);
    event.dataTransfer.effectAllowed = "copyMove";
    event.dataTransfer.setData(DataTransfers.RESOURCES, JSON.stringify([uri]));
    if (event.dataTransfer.setDragImage) {
      let label;
      if (this.dnd.getDragLabel) {
        label = this.dnd.getDragLabel(elements, event);
      }
      if (typeof label === "undefined") {
        label = String(elements.length);
      }
      const dragImage = $(".monaco-drag-image");
      dragImage.textContent = label;
      document.body.appendChild(dragImage);
      event.dataTransfer.setDragImage(dragImage, -10, -10);
      setTimeout(() => document.body.removeChild(dragImage), 0);
    }
    this.currentDragData = new ElementsDragAndDropData(elements);
    StaticDND.CurrentDragAndDropData = new ExternalElementsDragAndDropData(elements);
    if (this.dnd.onDragStart) {
      this.dnd.onDragStart(this.currentDragData, event);
    }
  }
  onDragOver(event) {
    event.browserEvent.preventDefault();
    this.onDragLeaveTimeout.dispose();
    if (StaticDND.CurrentDragAndDropData && StaticDND.CurrentDragAndDropData.getData() === "vscode-ui") {
      return false;
    }
    this.setupDragAndDropScrollTopAnimation(event.browserEvent);
    if (!event.browserEvent.dataTransfer) {
      return false;
    }
    if (!this.currentDragData) {
      if (StaticDND.CurrentDragAndDropData) {
        this.currentDragData = StaticDND.CurrentDragAndDropData;
      } else {
        if (!event.browserEvent.dataTransfer.types) {
          return false;
        }
        this.currentDragData = new NativeDragAndDropData();
      }
    }
    const result = this.dnd.onDragOver(this.currentDragData, event.element, event.index, event.browserEvent);
    this.canDrop = typeof result === "boolean" ? result : result.accept;
    if (!this.canDrop) {
      this.currentDragFeedback = void 0;
      this.currentDragFeedbackDisposable.dispose();
      return false;
    }
    event.browserEvent.dataTransfer.dropEffect = typeof result !== "boolean" && result.effect === 0 ? "copy" : "move";
    let feedback;
    if (typeof result !== "boolean" && result.feedback) {
      feedback = result.feedback;
    } else {
      if (typeof event.index === "undefined") {
        feedback = [-1];
      } else {
        feedback = [event.index];
      }
    }
    feedback = distinct(feedback).filter((i) => i >= -1 && i < this.length).sort((a, b) => a - b);
    feedback = feedback[0] === -1 ? [-1] : feedback;
    if (equalsDragFeedback(this.currentDragFeedback, feedback)) {
      return true;
    }
    this.currentDragFeedback = feedback;
    this.currentDragFeedbackDisposable.dispose();
    if (feedback[0] === -1) {
      addClass(this.domNode, "drop-target");
      addClass(this.rowsContainer, "drop-target");
      this.currentDragFeedbackDisposable = toDisposable(() => {
        removeClass(this.domNode, "drop-target");
        removeClass(this.rowsContainer, "drop-target");
      });
    } else {
      for (const index of feedback) {
        const item = this.items[index];
        item.dropTarget = true;
        if (item.row && item.row.domNode) {
          addClass(item.row.domNode, "drop-target");
        }
      }
      this.currentDragFeedbackDisposable = toDisposable(() => {
        for (const index of feedback) {
          const item = this.items[index];
          item.dropTarget = false;
          if (item.row && item.row.domNode) {
            removeClass(item.row.domNode, "drop-target");
          }
        }
      });
    }
    return true;
  }
  onDragLeave() {
    this.onDragLeaveTimeout.dispose();
    this.onDragLeaveTimeout = disposableTimeout(() => this.clearDragOverFeedback(), 100);
  }
  onDrop(event) {
    if (!this.canDrop) {
      return;
    }
    const dragData = this.currentDragData;
    this.teardownDragAndDropScrollTopAnimation();
    this.clearDragOverFeedback();
    this.currentDragData = void 0;
    StaticDND.CurrentDragAndDropData = void 0;
    if (!dragData || !event.browserEvent.dataTransfer) {
      return;
    }
    event.browserEvent.preventDefault();
    dragData.update(event.browserEvent.dataTransfer);
    this.dnd.drop(dragData, event.element, event.index, event.browserEvent);
  }
  onDragEnd(event) {
    this.canDrop = false;
    this.teardownDragAndDropScrollTopAnimation();
    this.clearDragOverFeedback();
    this.currentDragData = void 0;
    StaticDND.CurrentDragAndDropData = void 0;
    if (this.dnd.onDragEnd) {
      this.dnd.onDragEnd(event);
    }
  }
  clearDragOverFeedback() {
    this.currentDragFeedback = void 0;
    this.currentDragFeedbackDisposable.dispose();
    this.currentDragFeedbackDisposable = Disposable.None;
  }
  setupDragAndDropScrollTopAnimation(event) {
    if (!this.dragOverAnimationDisposable) {
      const viewTop = getTopLeftOffset(this.domNode).top;
      this.dragOverAnimationDisposable = animate(this.animateDragAndDropScrollTop.bind(this, viewTop));
    }
    this.dragOverAnimationStopDisposable.dispose();
    this.dragOverAnimationStopDisposable = disposableTimeout(() => {
      if (this.dragOverAnimationDisposable) {
        this.dragOverAnimationDisposable.dispose();
        this.dragOverAnimationDisposable = void 0;
      }
    }, 1e3);
    this.dragOverMouseY = event.pageY;
  }
  animateDragAndDropScrollTop(viewTop) {
    if (this.dragOverMouseY === void 0) {
      return;
    }
    const diff = this.dragOverMouseY - viewTop;
    const upperLimit = this.renderHeight - 35;
    if (diff < 35) {
      this.scrollTop += Math.max(-14, Math.floor(0.3 * (diff - 35)));
    } else if (diff > upperLimit) {
      this.scrollTop += Math.min(14, Math.floor(0.3 * (diff - upperLimit)));
    }
  }
  teardownDragAndDropScrollTopAnimation() {
    this.dragOverAnimationStopDisposable.dispose();
    if (this.dragOverAnimationDisposable) {
      this.dragOverAnimationDisposable.dispose();
      this.dragOverAnimationDisposable = void 0;
    }
  }
  getItemIndexFromEventTarget(target) {
    const scrollableElement = this.scrollableElement.getDomNode();
    let element = target;
    while (element instanceof HTMLElement && element !== this.rowsContainer && scrollableElement.contains(element)) {
      const rawIndex = element.getAttribute("data-index");
      if (rawIndex) {
        const index = Number(rawIndex);
        if (!isNaN(index)) {
          return index;
        }
      }
      element = element.parentElement;
    }
    return void 0;
  }
  getRenderRange(renderTop, renderHeight) {
    return {
      start: this.rangeMap.indexAt(renderTop),
      end: this.rangeMap.indexAfter(renderTop + renderHeight - 1)
    };
  }
  _rerender(renderTop, renderHeight) {
    const previousRenderRange = this.getRenderRange(renderTop, renderHeight);
    let anchorElementIndex;
    let anchorElementTopDelta;
    if (renderTop === this.elementTop(previousRenderRange.start)) {
      anchorElementIndex = previousRenderRange.start;
      anchorElementTopDelta = 0;
    } else if (previousRenderRange.end - previousRenderRange.start > 1) {
      anchorElementIndex = previousRenderRange.start + 1;
      anchorElementTopDelta = this.elementTop(anchorElementIndex) - renderTop;
    }
    let heightDiff = 0;
    while (true) {
      const renderRange = this.getRenderRange(renderTop, renderHeight);
      let didChange = false;
      for (let i = renderRange.start; i < renderRange.end; i++) {
        const diff = this.probeDynamicHeight(i);
        if (diff !== 0) {
          this.rangeMap.splice(i, 1, [this.items[i]]);
        }
        heightDiff += diff;
        didChange = didChange || diff !== 0;
      }
      if (!didChange) {
        if (heightDiff !== 0) {
          this.eventuallyUpdateScrollDimensions();
        }
        const unrenderRanges = Range2.relativeComplement(previousRenderRange, renderRange);
        for (const range2 of unrenderRanges) {
          for (let i = range2.start; i < range2.end; i++) {
            if (this.items[i].row) {
              this.removeItemFromDOM(i);
            }
          }
        }
        const renderRanges = Range2.relativeComplement(renderRange, previousRenderRange);
        for (const range2 of renderRanges) {
          for (let i = range2.start; i < range2.end; i++) {
            const afterIndex = i + 1;
            const beforeRow = afterIndex < this.items.length ? this.items[afterIndex].row : null;
            const beforeElement = beforeRow ? beforeRow.domNode : null;
            this.insertItemInDOM(i, beforeElement);
          }
        }
        for (let i = renderRange.start; i < renderRange.end; i++) {
          if (this.items[i].row) {
            this.updateItemInDOM(this.items[i], i);
          }
        }
        if (typeof anchorElementIndex === "number") {
          this.scrollTop = this.elementTop(anchorElementIndex) - anchorElementTopDelta;
        }
        this._onDidChangeContentHeight.fire(this.contentHeight);
        return;
      }
    }
  }
  probeDynamicHeight(index) {
    const item = this.items[index];
    if (!item.hasDynamicHeight || item.lastDynamicHeightWidth === this.renderWidth) {
      return 0;
    }
    if (!!this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(item.element)) {
      return 0;
    }
    const size = item.size;
    if (!this.setRowHeight && item.row && item.row.domNode) {
      let newSize = item.row.domNode.offsetHeight;
      item.size = newSize;
      item.lastDynamicHeightWidth = this.renderWidth;
      return newSize - size;
    }
    const row = this.cache.alloc(item.templateId);
    row.domNode.style.height = "";
    this.rowsContainer.appendChild(row.domNode);
    const renderer = this.renderers.get(item.templateId);
    if (renderer) {
      renderer.renderElement(item.element, index, row.templateData, void 0);
      if (renderer.disposeElement) {
        renderer.disposeElement(item.element, index, row.templateData, void 0);
      }
    }
    item.size = row.domNode.offsetHeight;
    if (this.virtualDelegate.setDynamicHeight) {
      this.virtualDelegate.setDynamicHeight(item.element, item.size);
    }
    item.lastDynamicHeightWidth = this.renderWidth;
    this.rowsContainer.removeChild(row.domNode);
    this.cache.release(row);
    return item.size - size;
  }
  getNextToLastElement(ranges) {
    const lastRange = ranges[ranges.length - 1];
    if (!lastRange) {
      return null;
    }
    const nextToLastItem = this.items[lastRange.end];
    if (!nextToLastItem) {
      return null;
    }
    if (!nextToLastItem.row) {
      return null;
    }
    return nextToLastItem.row.domNode;
  }
  getElementDomId(index) {
    return `${this.domId}_${index}`;
  }
  dispose() {
    if (this.items) {
      for (const item of this.items) {
        if (item.row) {
          const renderer = this.renderers.get(item.row.templateId);
          if (renderer) {
            renderer.disposeTemplate(item.row.templateData);
          }
        }
      }
      this.items = [];
    }
    if (this.domNode && this.domNode.parentNode) {
      this.domNode.parentNode.removeChild(this.domNode);
    }
    dispose(this.disposables);
  }
};
ListView.InstanceCount = 0;
__decorate14([
  memoize
], ListView.prototype, "onMouseClick", null);
__decorate14([
  memoize
], ListView.prototype, "onMouseDblClick", null);
__decorate14([
  memoize
], ListView.prototype, "onMouseMiddleClick", null);
__decorate14([
  memoize
], ListView.prototype, "onMouseDown", null);
__decorate14([
  memoize
], ListView.prototype, "onContextMenu", null);
__decorate14([
  memoize
], ListView.prototype, "onTouchStart", null);
__decorate14([
  memoize
], ListView.prototype, "onTap", null);

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/splice.js
var CombinedSpliceable = class {
  constructor(spliceables) {
    this.spliceables = spliceables;
  }
  splice(start, deleteCount, elements) {
    this.spliceables.forEach((s) => s.splice(start, deleteCount, elements));
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/numbers.js
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/listWidget.js
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TraitRenderer = class {
  constructor(trait) {
    this.trait = trait;
    this.renderedElements = [];
  }
  get templateId() {
    return `template:${this.trait.trait}`;
  }
  renderTemplate(container) {
    return container;
  }
  renderElement(element, index, templateData) {
    const renderedElementIndex = firstIndex(this.renderedElements, (el) => el.templateData === templateData);
    if (renderedElementIndex >= 0) {
      const rendered = this.renderedElements[renderedElementIndex];
      this.trait.unrender(templateData);
      rendered.index = index;
    } else {
      const rendered = {index, templateData};
      this.renderedElements.push(rendered);
    }
    this.trait.renderIndex(index, templateData);
  }
  splice(start, deleteCount, insertCount) {
    const rendered = [];
    for (const renderedElement of this.renderedElements) {
      if (renderedElement.index < start) {
        rendered.push(renderedElement);
      } else if (renderedElement.index >= start + deleteCount) {
        rendered.push({
          index: renderedElement.index + insertCount - deleteCount,
          templateData: renderedElement.templateData
        });
      }
    }
    this.renderedElements = rendered;
  }
  renderIndexes(indexes) {
    for (const {index, templateData} of this.renderedElements) {
      if (indexes.indexOf(index) > -1) {
        this.trait.renderIndex(index, templateData);
      }
    }
  }
  disposeTemplate(templateData) {
    const index = firstIndex(this.renderedElements, (el) => el.templateData === templateData);
    if (index < 0) {
      return;
    }
    this.renderedElements.splice(index, 1);
  }
};
var Trait = class {
  constructor(_trait) {
    this._trait = _trait;
    this.indexes = [];
    this.sortedIndexes = [];
    this._onChange = new Emitter();
    this.onChange = this._onChange.event;
  }
  get trait() {
    return this._trait;
  }
  get renderer() {
    return new TraitRenderer(this);
  }
  splice(start, deleteCount, elements) {
    const diff = elements.length - deleteCount;
    const end = start + deleteCount;
    const indexes = [
      ...this.sortedIndexes.filter((i) => i < start),
      ...elements.map((hasTrait, i) => hasTrait ? i + start : -1).filter((i) => i !== -1),
      ...this.sortedIndexes.filter((i) => i >= end).map((i) => i + diff)
    ];
    this.renderer.splice(start, deleteCount, elements.length);
    this._set(indexes, indexes);
  }
  renderIndex(index, container) {
    toggleClass(container, this._trait, this.contains(index));
  }
  unrender(container) {
    removeClass(container, this._trait);
  }
  set(indexes, browserEvent) {
    return this._set(indexes, [...indexes].sort(numericSort), browserEvent);
  }
  _set(indexes, sortedIndexes, browserEvent) {
    const result = this.indexes;
    const sortedResult = this.sortedIndexes;
    this.indexes = indexes;
    this.sortedIndexes = sortedIndexes;
    const toRender = disjunction(sortedResult, indexes);
    this.renderer.renderIndexes(toRender);
    this._onChange.fire({indexes, browserEvent});
    return result;
  }
  get() {
    return this.indexes;
  }
  contains(index) {
    return binarySearch(this.sortedIndexes, index, numericSort) >= 0;
  }
  dispose() {
    dispose(this._onChange);
  }
};
__decorate15([
  memoize
], Trait.prototype, "renderer", null);
var SelectionTrait = class extends Trait {
  constructor(setAriaSelected) {
    super("selected");
    this.setAriaSelected = setAriaSelected;
  }
  renderIndex(index, container) {
    super.renderIndex(index, container);
    if (this.setAriaSelected) {
      if (this.contains(index)) {
        container.setAttribute("aria-selected", "true");
      } else {
        container.setAttribute("aria-selected", "false");
      }
    }
  }
};
var TraitSpliceable = class {
  constructor(trait, view, identityProvider) {
    this.trait = trait;
    this.view = view;
    this.identityProvider = identityProvider;
  }
  splice(start, deleteCount, elements) {
    if (!this.identityProvider) {
      return this.trait.splice(start, deleteCount, elements.map(() => false));
    }
    const pastElementsWithTrait = this.trait.get().map((i) => this.identityProvider.getId(this.view.element(i)).toString());
    const elementsWithTrait = elements.map((e) => pastElementsWithTrait.indexOf(this.identityProvider.getId(e).toString()) > -1);
    this.trait.splice(start, deleteCount, elementsWithTrait);
  }
};
function isInputElement(e) {
  return e.tagName === "INPUT" || e.tagName === "TEXTAREA";
}
function isMonacoEditor(e) {
  if (hasClass(e, "monaco-editor")) {
    return true;
  }
  if (hasClass(e, "monaco-list")) {
    return false;
  }
  if (!e.parentElement) {
    return false;
  }
  return isMonacoEditor(e.parentElement);
}
var KeyboardController = class {
  constructor(list, view, options) {
    this.list = list;
    this.view = view;
    this.disposables = new DisposableStore();
    const multipleSelectionSupport = options.multipleSelectionSupport !== false;
    const onKeyDown = Event.chain(domEvent(view.domNode, "keydown")).filter((e) => !isInputElement(e.target)).map((e) => new StandardKeyboardEvent(e));
    onKeyDown.filter((e) => e.keyCode === 3).on(this.onEnter, this, this.disposables);
    onKeyDown.filter((e) => e.keyCode === 16).on(this.onUpArrow, this, this.disposables);
    onKeyDown.filter((e) => e.keyCode === 18).on(this.onDownArrow, this, this.disposables);
    onKeyDown.filter((e) => e.keyCode === 11).on(this.onPageUpArrow, this, this.disposables);
    onKeyDown.filter((e) => e.keyCode === 12).on(this.onPageDownArrow, this, this.disposables);
    onKeyDown.filter((e) => e.keyCode === 9).on(this.onEscape, this, this.disposables);
    if (multipleSelectionSupport) {
      onKeyDown.filter((e) => (isMacintosh ? e.metaKey : e.ctrlKey) && e.keyCode === 31).on(this.onCtrlA, this, this.disposables);
    }
  }
  onEnter(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.setSelection(this.list.getFocus(), e.browserEvent);
  }
  onUpArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.focusPrevious(1, false, e.browserEvent);
    this.list.reveal(this.list.getFocus()[0]);
    this.view.domNode.focus();
  }
  onDownArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.focusNext(1, false, e.browserEvent);
    this.list.reveal(this.list.getFocus()[0]);
    this.view.domNode.focus();
  }
  onPageUpArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.focusPreviousPage(e.browserEvent);
    this.list.reveal(this.list.getFocus()[0]);
    this.view.domNode.focus();
  }
  onPageDownArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.focusNextPage(e.browserEvent);
    this.list.reveal(this.list.getFocus()[0]);
    this.view.domNode.focus();
  }
  onCtrlA(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.setSelection(range(this.list.length), e.browserEvent);
    this.view.domNode.focus();
  }
  onEscape(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.setSelection([], e.browserEvent);
    this.view.domNode.focus();
  }
  dispose() {
    this.disposables.dispose();
  }
};
var TypeLabelControllerState;
(function(TypeLabelControllerState2) {
  TypeLabelControllerState2[TypeLabelControllerState2["Idle"] = 0] = "Idle";
  TypeLabelControllerState2[TypeLabelControllerState2["Typing"] = 1] = "Typing";
})(TypeLabelControllerState || (TypeLabelControllerState = {}));
var DefaultKeyboardNavigationDelegate = new class {
  mightProducePrintableCharacter(event) {
    if (event.ctrlKey || event.metaKey || event.altKey) {
      return false;
    }
    return event.keyCode >= 31 && event.keyCode <= 56 || event.keyCode >= 21 && event.keyCode <= 30 || event.keyCode >= 93 && event.keyCode <= 102 || event.keyCode >= 80 && event.keyCode <= 90;
  }
}();
var TypeLabelController = class {
  constructor(list, view, keyboardNavigationLabelProvider, delegate) {
    this.list = list;
    this.view = view;
    this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;
    this.delegate = delegate;
    this.enabled = false;
    this.state = TypeLabelControllerState.Idle;
    this.automaticKeyboardNavigation = true;
    this.triggered = false;
    this.previouslyFocused = -1;
    this.enabledDisposables = new DisposableStore();
    this.disposables = new DisposableStore();
    this.updateOptions(list.options);
  }
  updateOptions(options) {
    const enableKeyboardNavigation = typeof options.enableKeyboardNavigation === "undefined" ? true : !!options.enableKeyboardNavigation;
    if (enableKeyboardNavigation) {
      this.enable();
    } else {
      this.disable();
    }
    if (typeof options.automaticKeyboardNavigation !== "undefined") {
      this.automaticKeyboardNavigation = options.automaticKeyboardNavigation;
    }
  }
  enable() {
    if (this.enabled) {
      return;
    }
    const onChar = Event.chain(domEvent(this.view.domNode, "keydown")).filter((e) => !isInputElement(e.target)).filter(() => this.automaticKeyboardNavigation || this.triggered).map((event) => new StandardKeyboardEvent(event)).filter((e) => this.delegate.mightProducePrintableCharacter(e)).forEach((e) => {
      e.stopPropagation();
      e.preventDefault();
    }).map((event) => event.browserEvent.key).event;
    const onClear = Event.debounce(onChar, () => null, 800);
    const onInput = Event.reduce(Event.any(onChar, onClear), (r, i) => i === null ? null : (r || "") + i);
    onInput(this.onInput, this, this.enabledDisposables);
    onClear(this.onClear, this, this.enabledDisposables);
    this.enabled = true;
    this.triggered = false;
  }
  disable() {
    if (!this.enabled) {
      return;
    }
    this.enabledDisposables.clear();
    this.enabled = false;
    this.triggered = false;
  }
  onClear() {
    var _a;
    const focus = this.list.getFocus();
    if (focus.length > 0 && focus[0] === this.previouslyFocused) {
      const ariaLabel = (_a = this.list.options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getAriaLabel(this.list.element(focus[0]));
      if (ariaLabel) {
        alert(ariaLabel);
      }
    }
    this.previouslyFocused = -1;
  }
  onInput(word) {
    if (!word) {
      this.state = TypeLabelControllerState.Idle;
      this.triggered = false;
      return;
    }
    const focus = this.list.getFocus();
    const start = focus.length > 0 ? focus[0] : 0;
    const delta = this.state === TypeLabelControllerState.Idle ? 1 : 0;
    this.state = TypeLabelControllerState.Typing;
    for (let i = 0; i < this.list.length; i++) {
      const index = (start + i + delta) % this.list.length;
      const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(index));
      const labelStr = label && label.toString();
      if (typeof labelStr === "undefined" || matchesPrefix(word, labelStr)) {
        this.previouslyFocused = start;
        this.list.setFocus([index]);
        this.list.reveal(index);
        return;
      }
    }
  }
  dispose() {
    this.disable();
    this.enabledDisposables.dispose();
    this.disposables.dispose();
  }
};
var DOMFocusController = class {
  constructor(list, view) {
    this.list = list;
    this.view = view;
    this.disposables = new DisposableStore();
    const onKeyDown = Event.chain(domEvent(view.domNode, "keydown")).filter((e) => !isInputElement(e.target)).map((e) => new StandardKeyboardEvent(e));
    onKeyDown.filter((e) => e.keyCode === 2 && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey).on(this.onTab, this, this.disposables);
  }
  onTab(e) {
    if (e.target !== this.view.domNode) {
      return;
    }
    const focus = this.list.getFocus();
    if (focus.length === 0) {
      return;
    }
    const focusedDomElement = this.view.domElement(focus[0]);
    if (!focusedDomElement) {
      return;
    }
    const tabIndexElement = focusedDomElement.querySelector("[tabIndex]");
    if (!tabIndexElement || !(tabIndexElement instanceof HTMLElement) || tabIndexElement.tabIndex === -1) {
      return;
    }
    const style = window.getComputedStyle(tabIndexElement);
    if (style.visibility === "hidden" || style.display === "none") {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    tabIndexElement.focus();
  }
  dispose() {
    this.disposables.dispose();
  }
};
function isSelectionSingleChangeEvent(event) {
  return isMacintosh ? event.browserEvent.metaKey : event.browserEvent.ctrlKey;
}
function isSelectionRangeChangeEvent(event) {
  return event.browserEvent.shiftKey;
}
function isMouseRightClick(event) {
  return event instanceof MouseEvent && event.button === 2;
}
var DefaultMultipleSelectionController = {
  isSelectionSingleChangeEvent,
  isSelectionRangeChangeEvent
};
var MouseController = class {
  constructor(list) {
    this.list = list;
    this.disposables = new DisposableStore();
    this._onPointer = new Emitter();
    this.onPointer = this._onPointer.event;
    this.multipleSelectionSupport = !(list.options.multipleSelectionSupport === false);
    if (this.multipleSelectionSupport) {
      this.multipleSelectionController = list.options.multipleSelectionController || DefaultMultipleSelectionController;
    }
    this.mouseSupport = typeof list.options.mouseSupport === "undefined" || !!list.options.mouseSupport;
    if (this.mouseSupport) {
      list.onMouseDown(this.onMouseDown, this, this.disposables);
      list.onContextMenu(this.onContextMenu, this, this.disposables);
      list.onMouseDblClick(this.onDoubleClick, this, this.disposables);
      list.onTouchStart(this.onMouseDown, this, this.disposables);
      this.disposables.add(Gesture.addTarget(list.getHTMLElement()));
    }
    Event.any(list.onMouseClick, list.onMouseMiddleClick, list.onTap)(this.onViewPointer, this, this.disposables);
  }
  isSelectionSingleChangeEvent(event) {
    if (this.multipleSelectionController) {
      return this.multipleSelectionController.isSelectionSingleChangeEvent(event);
    }
    return isMacintosh ? event.browserEvent.metaKey : event.browserEvent.ctrlKey;
  }
  isSelectionRangeChangeEvent(event) {
    if (this.multipleSelectionController) {
      return this.multipleSelectionController.isSelectionRangeChangeEvent(event);
    }
    return event.browserEvent.shiftKey;
  }
  isSelectionChangeEvent(event) {
    return this.isSelectionSingleChangeEvent(event) || this.isSelectionRangeChangeEvent(event);
  }
  onMouseDown(e) {
    if (isMonacoEditor(e.browserEvent.target)) {
      return;
    }
    if (document.activeElement !== e.browserEvent.target) {
      this.list.domFocus();
    }
  }
  onContextMenu(e) {
    if (isMonacoEditor(e.browserEvent.target)) {
      return;
    }
    const focus = typeof e.index === "undefined" ? [] : [e.index];
    this.list.setFocus(focus, e.browserEvent);
  }
  onViewPointer(e) {
    if (!this.mouseSupport) {
      return;
    }
    if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {
      return;
    }
    let reference = this.list.getFocus()[0];
    const selection = this.list.getSelection();
    reference = reference === void 0 ? selection[0] : reference;
    const focus = e.index;
    if (typeof focus === "undefined") {
      this.list.setFocus([], e.browserEvent);
      this.list.setSelection([], e.browserEvent);
      return;
    }
    if (this.multipleSelectionSupport && this.isSelectionRangeChangeEvent(e)) {
      return this.changeSelection(e, reference);
    }
    if (this.multipleSelectionSupport && this.isSelectionChangeEvent(e)) {
      return this.changeSelection(e, reference);
    }
    this.list.setFocus([focus], e.browserEvent);
    if (!isMouseRightClick(e.browserEvent)) {
      this.list.setSelection([focus], e.browserEvent);
    }
    this._onPointer.fire(e);
  }
  onDoubleClick(e) {
    if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {
      return;
    }
    if (this.multipleSelectionSupport && this.isSelectionChangeEvent(e)) {
      return;
    }
    const focus = this.list.getFocus();
    this.list.setSelection(focus, e.browserEvent);
  }
  changeSelection(e, reference) {
    const focus = e.index;
    if (this.isSelectionRangeChangeEvent(e) && reference !== void 0) {
      const min = Math.min(reference, focus);
      const max = Math.max(reference, focus);
      const rangeSelection = range(min, max + 1);
      const selection = this.list.getSelection();
      const contiguousRange = getContiguousRangeContaining(disjunction(selection, [reference]), reference);
      if (contiguousRange.length === 0) {
        return;
      }
      const newSelection = disjunction(rangeSelection, relativeComplement(selection, contiguousRange));
      this.list.setSelection(newSelection, e.browserEvent);
    } else if (this.isSelectionSingleChangeEvent(e)) {
      const selection = this.list.getSelection();
      const newSelection = selection.filter((i) => i !== focus);
      this.list.setFocus([focus]);
      if (selection.length === newSelection.length) {
        this.list.setSelection([...newSelection, focus], e.browserEvent);
      } else {
        this.list.setSelection(newSelection, e.browserEvent);
      }
    }
  }
  dispose() {
    this.disposables.dispose();
  }
};
var DefaultStyleController = class {
  constructor(styleElement, selectorSuffix) {
    this.styleElement = styleElement;
    this.selectorSuffix = selectorSuffix;
  }
  style(styles) {
    const suffix = this.selectorSuffix && `.${this.selectorSuffix}`;
    const content = [];
    if (styles.listBackground) {
      if (styles.listBackground.isOpaque()) {
        content.push(`.monaco-list${suffix} .monaco-list-rows { background: ${styles.listBackground}; }`);
      } else if (!isMacintosh) {
        console.warn(`List with id '${this.selectorSuffix}' was styled with a non-opaque background color. This will break sub-pixel antialiasing.`);
      }
    }
    if (styles.listFocusBackground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { background-color: ${styles.listFocusBackground}; }`);
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused:hover { background-color: ${styles.listFocusBackground}; }`);
    }
    if (styles.listFocusForeground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { color: ${styles.listFocusForeground}; }`);
    }
    if (styles.listActiveSelectionBackground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { background-color: ${styles.listActiveSelectionBackground}; }`);
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected:hover { background-color: ${styles.listActiveSelectionBackground}; }`);
    }
    if (styles.listActiveSelectionForeground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { color: ${styles.listActiveSelectionForeground}; }`);
    }
    if (styles.listFocusAndSelectionBackground) {
      content.push(`
				.monaco-drag-image,
				.monaco-list${suffix}:focus .monaco-list-row.selected.focused { background-color: ${styles.listFocusAndSelectionBackground}; }
			`);
    }
    if (styles.listFocusAndSelectionForeground) {
      content.push(`
				.monaco-drag-image,
				.monaco-list${suffix}:focus .monaco-list-row.selected.focused { color: ${styles.listFocusAndSelectionForeground}; }
			`);
    }
    if (styles.listInactiveFocusBackground) {
      content.push(`.monaco-list${suffix} .monaco-list-row.focused { background-color:  ${styles.listInactiveFocusBackground}; }`);
      content.push(`.monaco-list${suffix} .monaco-list-row.focused:hover { background-color:  ${styles.listInactiveFocusBackground}; }`);
    }
    if (styles.listInactiveSelectionBackground) {
      content.push(`.monaco-list${suffix} .monaco-list-row.selected { background-color:  ${styles.listInactiveSelectionBackground}; }`);
      content.push(`.monaco-list${suffix} .monaco-list-row.selected:hover { background-color:  ${styles.listInactiveSelectionBackground}; }`);
    }
    if (styles.listInactiveSelectionForeground) {
      content.push(`.monaco-list${suffix} .monaco-list-row.selected { color: ${styles.listInactiveSelectionForeground}; }`);
    }
    if (styles.listHoverBackground) {
      content.push(`.monaco-list${suffix}:not(.drop-target) .monaco-list-row:hover:not(.selected):not(.focused) { background-color:  ${styles.listHoverBackground}; }`);
    }
    if (styles.listHoverForeground) {
      content.push(`.monaco-list${suffix} .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${styles.listHoverForeground}; }`);
    }
    if (styles.listSelectionOutline) {
      content.push(`.monaco-list${suffix} .monaco-list-row.selected { outline: 1px dotted ${styles.listSelectionOutline}; outline-offset: -1px; }`);
    }
    if (styles.listFocusOutline) {
      content.push(`
				.monaco-drag-image,
				.monaco-list${suffix}:focus .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }
			`);
    }
    if (styles.listInactiveFocusOutline) {
      content.push(`.monaco-list${suffix} .monaco-list-row.focused { outline: 1px dotted ${styles.listInactiveFocusOutline}; outline-offset: -1px; }`);
    }
    if (styles.listHoverOutline) {
      content.push(`.monaco-list${suffix} .monaco-list-row:hover { outline: 1px dashed ${styles.listHoverOutline}; outline-offset: -1px; }`);
    }
    if (styles.listDropBackground) {
      content.push(`
				.monaco-list${suffix}.drop-target,
				.monaco-list${suffix} .monaco-list-rows.drop-target,
				.monaco-list${suffix} .monaco-list-row.drop-target { background-color: ${styles.listDropBackground} !important; color: inherit !important; }
			`);
    }
    if (styles.listFilterWidgetBackground) {
      content.push(`.monaco-list-type-filter { background-color: ${styles.listFilterWidgetBackground} }`);
    }
    if (styles.listFilterWidgetOutline) {
      content.push(`.monaco-list-type-filter { border: 1px solid ${styles.listFilterWidgetOutline}; }`);
    }
    if (styles.listFilterWidgetNoMatchesOutline) {
      content.push(`.monaco-list-type-filter.no-matches { border: 1px solid ${styles.listFilterWidgetNoMatchesOutline}; }`);
    }
    if (styles.listMatchesShadow) {
      content.push(`.monaco-list-type-filter { box-shadow: 1px 1px 1px ${styles.listMatchesShadow}; }`);
    }
    const newStyles = content.join("\n");
    if (newStyles !== this.styleElement.innerHTML) {
      this.styleElement.innerHTML = newStyles;
    }
  }
};
var defaultStyles = {
  listFocusBackground: Color.fromHex("#7FB0D0"),
  listActiveSelectionBackground: Color.fromHex("#0E639C"),
  listActiveSelectionForeground: Color.fromHex("#FFFFFF"),
  listFocusAndSelectionBackground: Color.fromHex("#094771"),
  listFocusAndSelectionForeground: Color.fromHex("#FFFFFF"),
  listInactiveSelectionBackground: Color.fromHex("#3F3F46"),
  listHoverBackground: Color.fromHex("#2A2D2E"),
  listDropBackground: Color.fromHex("#383B3D"),
  treeIndentGuidesStroke: Color.fromHex("#a9a9a9")
};
var DefaultOptions2 = {
  keyboardSupport: true,
  mouseSupport: true,
  multipleSelectionSupport: true,
  dnd: {
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return false;
    },
    drop() {
    }
  }
};
function getContiguousRangeContaining(range2, value) {
  const index = range2.indexOf(value);
  if (index === -1) {
    return [];
  }
  const result = [];
  let i = index - 1;
  while (i >= 0 && range2[i] === value - (index - i)) {
    result.push(range2[i--]);
  }
  result.reverse();
  i = index;
  while (i < range2.length && range2[i] === value + (i - index)) {
    result.push(range2[i++]);
  }
  return result;
}
function disjunction(one, other) {
  const result = [];
  let i = 0, j = 0;
  while (i < one.length || j < other.length) {
    if (i >= one.length) {
      result.push(other[j++]);
    } else if (j >= other.length) {
      result.push(one[i++]);
    } else if (one[i] === other[j]) {
      result.push(one[i]);
      i++;
      j++;
      continue;
    } else if (one[i] < other[j]) {
      result.push(one[i++]);
    } else {
      result.push(other[j++]);
    }
  }
  return result;
}
function relativeComplement(one, other) {
  const result = [];
  let i = 0, j = 0;
  while (i < one.length || j < other.length) {
    if (i >= one.length) {
      result.push(other[j++]);
    } else if (j >= other.length) {
      result.push(one[i++]);
    } else if (one[i] === other[j]) {
      i++;
      j++;
      continue;
    } else if (one[i] < other[j]) {
      result.push(one[i++]);
    } else {
      j++;
    }
  }
  return result;
}
var numericSort = (a, b) => a - b;
var PipelineRenderer = class {
  constructor(_templateId, renderers) {
    this._templateId = _templateId;
    this.renderers = renderers;
  }
  get templateId() {
    return this._templateId;
  }
  renderTemplate(container) {
    return this.renderers.map((r) => r.renderTemplate(container));
  }
  renderElement(element, index, templateData, height) {
    let i = 0;
    for (const renderer of this.renderers) {
      renderer.renderElement(element, index, templateData[i++], height);
    }
  }
  disposeElement(element, index, templateData, height) {
    let i = 0;
    for (const renderer of this.renderers) {
      if (renderer.disposeElement) {
        renderer.disposeElement(element, index, templateData[i], height);
      }
      i += 1;
    }
  }
  disposeTemplate(templateData) {
    let i = 0;
    for (const renderer of this.renderers) {
      renderer.disposeTemplate(templateData[i++]);
    }
  }
};
var AccessibiltyRenderer = class {
  constructor(accessibilityProvider) {
    this.accessibilityProvider = accessibilityProvider;
    this.templateId = "a18n";
  }
  renderTemplate(container) {
    return container;
  }
  renderElement(element, index, container) {
    const ariaLabel = this.accessibilityProvider.getAriaLabel(element);
    if (ariaLabel) {
      container.setAttribute("aria-label", ariaLabel);
    } else {
      container.removeAttribute("aria-label");
    }
    const ariaLevel = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(element);
    if (typeof ariaLevel === "number") {
      container.setAttribute("aria-level", `${ariaLevel}`);
    } else {
      container.removeAttribute("aria-level");
    }
  }
  disposeTemplate(templateData) {
  }
};
var ListViewDragAndDrop = class {
  constructor(list, dnd) {
    this.list = list;
    this.dnd = dnd;
  }
  getDragElements(element) {
    const selection = this.list.getSelectedElements();
    const elements = selection.indexOf(element) > -1 ? selection : [element];
    return elements;
  }
  getDragURI(element) {
    return this.dnd.getDragURI(element);
  }
  getDragLabel(elements, originalEvent) {
    if (this.dnd.getDragLabel) {
      return this.dnd.getDragLabel(elements, originalEvent);
    }
    return void 0;
  }
  onDragStart(data, originalEvent) {
    if (this.dnd.onDragStart) {
      this.dnd.onDragStart(data, originalEvent);
    }
  }
  onDragOver(data, targetElement, targetIndex, originalEvent) {
    return this.dnd.onDragOver(data, targetElement, targetIndex, originalEvent);
  }
  onDragEnd(originalEvent) {
    if (this.dnd.onDragEnd) {
      this.dnd.onDragEnd(originalEvent);
    }
  }
  drop(data, targetElement, targetIndex, originalEvent) {
    this.dnd.drop(data, targetElement, targetIndex, originalEvent);
  }
};
var List = class {
  constructor(user, container, virtualDelegate, renderers, _options = DefaultOptions2) {
    var _a;
    this.user = user;
    this._options = _options;
    this.eventBufferer = new EventBufferer();
    this._ariaLabel = "";
    this.disposables = new DisposableStore();
    this.didJustPressContextMenuKey = false;
    this._onDidDispose = new Emitter();
    this.onDidDispose = this._onDidDispose.event;
    const role = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (_a = this._options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getWidgetRole() : "list";
    this.selection = new SelectionTrait(role !== "listbox");
    this.focus = new Trait("focused");
    mixin(_options, defaultStyles, false);
    const baseRenderers = [this.focus.renderer, this.selection.renderer];
    this.accessibilityProvider = _options.accessibilityProvider;
    if (this.accessibilityProvider) {
      baseRenderers.push(new AccessibiltyRenderer(this.accessibilityProvider));
      if (this.accessibilityProvider.onDidChangeActiveDescendant) {
        this.accessibilityProvider.onDidChangeActiveDescendant(this.onDidChangeActiveDescendant, this, this.disposables);
      }
    }
    renderers = renderers.map((r) => new PipelineRenderer(r.templateId, [...baseRenderers, r]));
    const viewOptions = Object.assign(Object.assign({}, _options), {dnd: _options.dnd && new ListViewDragAndDrop(this, _options.dnd)});
    this.view = new ListView(container, virtualDelegate, renderers, viewOptions);
    this.view.domNode.setAttribute("role", role);
    if (_options.styleController) {
      this.styleController = _options.styleController(this.view.domId);
    } else {
      const styleElement = createStyleSheet(this.view.domNode);
      this.styleController = new DefaultStyleController(styleElement, this.view.domId);
    }
    this.spliceable = new CombinedSpliceable([
      new TraitSpliceable(this.focus, this.view, _options.identityProvider),
      new TraitSpliceable(this.selection, this.view, _options.identityProvider),
      this.view
    ]);
    this.disposables.add(this.focus);
    this.disposables.add(this.selection);
    this.disposables.add(this.view);
    this.disposables.add(this._onDidDispose);
    this.onDidFocus = Event.map(domEvent(this.view.domNode, "focus", true), () => null);
    this.onDidBlur = Event.map(domEvent(this.view.domNode, "blur", true), () => null);
    this.disposables.add(new DOMFocusController(this, this.view));
    if (typeof _options.keyboardSupport !== "boolean" || _options.keyboardSupport) {
      const controller = new KeyboardController(this, this.view, _options);
      this.disposables.add(controller);
    }
    if (_options.keyboardNavigationLabelProvider) {
      const delegate = _options.keyboardNavigationDelegate || DefaultKeyboardNavigationDelegate;
      this.typeLabelController = new TypeLabelController(this, this.view, _options.keyboardNavigationLabelProvider, delegate);
      this.disposables.add(this.typeLabelController);
    }
    this.mouseController = this.createMouseController(_options);
    this.disposables.add(this.mouseController);
    this.onDidChangeFocus(this._onFocusChange, this, this.disposables);
    this.onDidChangeSelection(this._onSelectionChange, this, this.disposables);
    if (this.accessibilityProvider) {
      this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel();
    }
    if (_options.multipleSelectionSupport) {
      this.view.domNode.setAttribute("aria-multiselectable", "true");
    }
  }
  get onDidChangeFocus() {
    return Event.map(this.eventBufferer.wrapEvent(this.focus.onChange), (e) => this.toListEvent(e));
  }
  get onDidChangeSelection() {
    return Event.map(this.eventBufferer.wrapEvent(this.selection.onChange), (e) => this.toListEvent(e));
  }
  get domId() {
    return this.view.domId;
  }
  get onMouseClick() {
    return this.view.onMouseClick;
  }
  get onMouseDblClick() {
    return this.view.onMouseDblClick;
  }
  get onMouseMiddleClick() {
    return this.view.onMouseMiddleClick;
  }
  get onPointer() {
    return this.mouseController.onPointer;
  }
  get onMouseDown() {
    return this.view.onMouseDown;
  }
  get onTouchStart() {
    return this.view.onTouchStart;
  }
  get onTap() {
    return this.view.onTap;
  }
  get onContextMenu() {
    const fromKeydown = Event.chain(domEvent(this.view.domNode, "keydown")).map((e) => new StandardKeyboardEvent(e)).filter((e) => this.didJustPressContextMenuKey = e.keyCode === 58 || e.shiftKey && e.keyCode === 68).filter((e) => {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }).event;
    const fromKeyup = Event.chain(domEvent(this.view.domNode, "keyup")).filter(() => {
      const didJustPressContextMenuKey = this.didJustPressContextMenuKey;
      this.didJustPressContextMenuKey = false;
      return didJustPressContextMenuKey;
    }).filter(() => this.getFocus().length > 0 && !!this.view.domElement(this.getFocus()[0])).map((browserEvent) => {
      const index = this.getFocus()[0];
      const element = this.view.element(index);
      const anchor = this.view.domElement(index);
      return {index, element, anchor, browserEvent};
    }).event;
    const fromMouse = Event.chain(this.view.onContextMenu).filter(() => !this.didJustPressContextMenuKey).map(({element, index, browserEvent}) => ({element, index, anchor: {x: browserEvent.clientX + 1, y: browserEvent.clientY}, browserEvent})).event;
    return Event.any(fromKeydown, fromKeyup, fromMouse);
  }
  get onKeyDown() {
    return domEvent(this.view.domNode, "keydown");
  }
  createMouseController(options) {
    return new MouseController(this);
  }
  updateOptions(optionsUpdate = {}) {
    this._options = Object.assign(Object.assign({}, this._options), optionsUpdate);
    if (this.typeLabelController) {
      this.typeLabelController.updateOptions(this._options);
    }
    this.view.updateOptions(optionsUpdate);
  }
  get options() {
    return this._options;
  }
  splice(start, deleteCount, elements = []) {
    if (start < 0 || start > this.view.length) {
      throw new ListError(this.user, `Invalid start index: ${start}`);
    }
    if (deleteCount < 0) {
      throw new ListError(this.user, `Invalid delete count: ${deleteCount}`);
    }
    if (deleteCount === 0 && elements.length === 0) {
      return;
    }
    this.eventBufferer.bufferEvents(() => this.spliceable.splice(start, deleteCount, elements));
  }
  rerender() {
    this.view.rerender();
  }
  element(index) {
    return this.view.element(index);
  }
  get length() {
    return this.view.length;
  }
  get contentHeight() {
    return this.view.contentHeight;
  }
  get scrollTop() {
    return this.view.getScrollTop();
  }
  set scrollTop(scrollTop) {
    this.view.setScrollTop(scrollTop);
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  set ariaLabel(value) {
    this._ariaLabel = value;
    this.view.domNode.setAttribute("aria-label", value);
  }
  domFocus() {
    this.view.domNode.focus();
  }
  layout(height, width) {
    this.view.layout(height, width);
  }
  setSelection(indexes, browserEvent) {
    for (const index of indexes) {
      if (index < 0 || index >= this.length) {
        throw new ListError(this.user, `Invalid index ${index}`);
      }
    }
    this.selection.set(indexes, browserEvent);
  }
  getSelection() {
    return this.selection.get();
  }
  getSelectedElements() {
    return this.getSelection().map((i) => this.view.element(i));
  }
  setFocus(indexes, browserEvent) {
    for (const index of indexes) {
      if (index < 0 || index >= this.length) {
        throw new ListError(this.user, `Invalid index ${index}`);
      }
    }
    this.focus.set(indexes, browserEvent);
  }
  focusNext(n = 1, loop = false, browserEvent, filter) {
    if (this.length === 0) {
      return;
    }
    const focus = this.focus.get();
    const index = this.findNextIndex(focus.length > 0 ? focus[0] + n : 0, loop, filter);
    if (index > -1) {
      this.setFocus([index], browserEvent);
    }
  }
  focusPrevious(n = 1, loop = false, browserEvent, filter) {
    if (this.length === 0) {
      return;
    }
    const focus = this.focus.get();
    const index = this.findPreviousIndex(focus.length > 0 ? focus[0] - n : 0, loop, filter);
    if (index > -1) {
      this.setFocus([index], browserEvent);
    }
  }
  focusNextPage(browserEvent, filter) {
    let lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
    lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;
    const lastPageElement = this.view.element(lastPageIndex);
    const currentlyFocusedElement = this.getFocusedElements()[0];
    if (currentlyFocusedElement !== lastPageElement) {
      const lastGoodPageIndex = this.findPreviousIndex(lastPageIndex, false, filter);
      if (lastGoodPageIndex > -1 && currentlyFocusedElement !== this.view.element(lastGoodPageIndex)) {
        this.setFocus([lastGoodPageIndex], browserEvent);
      } else {
        this.setFocus([lastPageIndex], browserEvent);
      }
    } else {
      const previousScrollTop = this.view.getScrollTop();
      this.view.setScrollTop(previousScrollTop + this.view.renderHeight - this.view.elementHeight(lastPageIndex));
      if (this.view.getScrollTop() !== previousScrollTop) {
        setTimeout(() => this.focusNextPage(browserEvent, filter), 0);
      }
    }
  }
  focusPreviousPage(browserEvent, filter) {
    let firstPageIndex;
    const scrollTop = this.view.getScrollTop();
    if (scrollTop === 0) {
      firstPageIndex = this.view.indexAt(scrollTop);
    } else {
      firstPageIndex = this.view.indexAfter(scrollTop - 1);
    }
    const firstPageElement = this.view.element(firstPageIndex);
    const currentlyFocusedElement = this.getFocusedElements()[0];
    if (currentlyFocusedElement !== firstPageElement) {
      const firstGoodPageIndex = this.findNextIndex(firstPageIndex, false, filter);
      if (firstGoodPageIndex > -1 && currentlyFocusedElement !== this.view.element(firstGoodPageIndex)) {
        this.setFocus([firstGoodPageIndex], browserEvent);
      } else {
        this.setFocus([firstPageIndex], browserEvent);
      }
    } else {
      const previousScrollTop = scrollTop;
      this.view.setScrollTop(scrollTop - this.view.renderHeight);
      if (this.view.getScrollTop() !== previousScrollTop) {
        setTimeout(() => this.focusPreviousPage(browserEvent, filter), 0);
      }
    }
  }
  focusLast(browserEvent, filter) {
    if (this.length === 0) {
      return;
    }
    const index = this.findPreviousIndex(this.length - 1, false, filter);
    if (index > -1) {
      this.setFocus([index], browserEvent);
    }
  }
  focusFirst(browserEvent, filter) {
    this.focusNth(0, browserEvent, filter);
  }
  focusNth(n, browserEvent, filter) {
    if (this.length === 0) {
      return;
    }
    const index = this.findNextIndex(n, false, filter);
    if (index > -1) {
      this.setFocus([index], browserEvent);
    }
  }
  findNextIndex(index, loop = false, filter) {
    for (let i = 0; i < this.length; i++) {
      if (index >= this.length && !loop) {
        return -1;
      }
      index = index % this.length;
      if (!filter || filter(this.element(index))) {
        return index;
      }
      index++;
    }
    return -1;
  }
  findPreviousIndex(index, loop = false, filter) {
    for (let i = 0; i < this.length; i++) {
      if (index < 0 && !loop) {
        return -1;
      }
      index = (this.length + index % this.length) % this.length;
      if (!filter || filter(this.element(index))) {
        return index;
      }
      index--;
    }
    return -1;
  }
  getFocus() {
    return this.focus.get();
  }
  getFocusedElements() {
    return this.getFocus().map((i) => this.view.element(i));
  }
  reveal(index, relativeTop) {
    if (index < 0 || index >= this.length) {
      throw new ListError(this.user, `Invalid index ${index}`);
    }
    const scrollTop = this.view.getScrollTop();
    const elementTop = this.view.elementTop(index);
    const elementHeight = this.view.elementHeight(index);
    if (isNumber(relativeTop)) {
      const m = elementHeight - this.view.renderHeight;
      this.view.setScrollTop(m * clamp(relativeTop, 0, 1) + elementTop);
    } else {
      const viewItemBottom = elementTop + elementHeight;
      const wrapperBottom = scrollTop + this.view.renderHeight;
      if (elementTop < scrollTop && viewItemBottom >= wrapperBottom) {
      } else if (elementTop < scrollTop) {
        this.view.setScrollTop(elementTop);
      } else if (viewItemBottom >= wrapperBottom) {
        this.view.setScrollTop(viewItemBottom - this.view.renderHeight);
      }
    }
  }
  getRelativeTop(index) {
    if (index < 0 || index >= this.length) {
      throw new ListError(this.user, `Invalid index ${index}`);
    }
    const scrollTop = this.view.getScrollTop();
    const elementTop = this.view.elementTop(index);
    const elementHeight = this.view.elementHeight(index);
    if (elementTop < scrollTop || elementTop + elementHeight > scrollTop + this.view.renderHeight) {
      return null;
    }
    const m = elementHeight - this.view.renderHeight;
    return Math.abs((scrollTop - elementTop) / m);
  }
  getHTMLElement() {
    return this.view.domNode;
  }
  style(styles) {
    this.styleController.style(styles);
  }
  toListEvent({indexes, browserEvent}) {
    return {indexes, elements: indexes.map((i) => this.view.element(i)), browserEvent};
  }
  _onFocusChange() {
    const focus = this.focus.get();
    toggleClass(this.view.domNode, "element-focused", focus.length > 0);
    this.onDidChangeActiveDescendant();
  }
  onDidChangeActiveDescendant() {
    var _a;
    const focus = this.focus.get();
    if (focus.length > 0) {
      let id;
      if ((_a = this.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getActiveDescendantId) {
        id = this.accessibilityProvider.getActiveDescendantId(this.view.element(focus[0]));
      }
      this.view.domNode.setAttribute("aria-activedescendant", id || this.view.getElementDomId(focus[0]));
    } else {
      this.view.domNode.removeAttribute("aria-activedescendant");
    }
  }
  _onSelectionChange() {
    const selection = this.selection.get();
    toggleClass(this.view.domNode, "selection-none", selection.length === 0);
    toggleClass(this.view.domNode, "selection-single", selection.length === 1);
    toggleClass(this.view.domNode, "selection-multiple", selection.length > 1);
  }
  dispose() {
    this._onDidDispose.fire();
    this.disposables.dispose();
    this._onDidDispose.dispose();
  }
};
__decorate15([
  memoize
], List.prototype, "onDidChangeFocus", null);
__decorate15([
  memoize
], List.prototype, "onDidChangeSelection", null);
__decorate15([
  memoize
], List.prototype, "onContextMenu", null);

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/listPaging.js
var PagedRenderer = class {
  constructor(renderer, modelProvider) {
    this.renderer = renderer;
    this.modelProvider = modelProvider;
  }
  get templateId() {
    return this.renderer.templateId;
  }
  renderTemplate(container) {
    const data = this.renderer.renderTemplate(container);
    return {data, disposable: Disposable.None};
  }
  renderElement(index, _, data, height) {
    if (data.disposable) {
      data.disposable.dispose();
    }
    if (!data.data) {
      return;
    }
    const model2 = this.modelProvider();
    if (model2.isResolved(index)) {
      return this.renderer.renderElement(model2.get(index), index, data.data, height);
    }
    const cts = new CancellationTokenSource();
    const promise = model2.resolve(index, cts.token);
    data.disposable = {dispose: () => cts.cancel()};
    this.renderer.renderPlaceholder(index, data.data);
    promise.then((entry) => this.renderer.renderElement(entry, index, data.data, height));
  }
  disposeTemplate(data) {
    if (data.disposable) {
      data.disposable.dispose();
      data.disposable = void 0;
    }
    if (data.data) {
      this.renderer.disposeTemplate(data.data);
      data.data = void 0;
    }
  }
};
var PagedAccessibilityProvider = class {
  constructor(modelProvider, accessibilityProvider) {
    this.modelProvider = modelProvider;
    this.accessibilityProvider = accessibilityProvider;
  }
  getWidgetAriaLabel() {
    return this.accessibilityProvider.getWidgetAriaLabel();
  }
  getAriaLabel(index) {
    const model2 = this.modelProvider();
    if (!model2.isResolved(index)) {
      return null;
    }
    return this.accessibilityProvider.getAriaLabel(model2.get(index));
  }
};
function fromPagedListOptions(modelProvider, options) {
  return Object.assign(Object.assign({}, options), {accessibilityProvider: options.accessibilityProvider && new PagedAccessibilityProvider(modelProvider, options.accessibilityProvider)});
}
var PagedList = class {
  constructor(user, container, virtualDelegate, renderers, options = {}) {
    const modelProvider = () => this.model;
    const pagedRenderers = renderers.map((r) => new PagedRenderer(r, modelProvider));
    this.list = new List(user, container, virtualDelegate, pagedRenderers, fromPagedListOptions(modelProvider, options));
  }
  updateOptions(options) {
    this.list.updateOptions(options);
  }
  getHTMLElement() {
    return this.list.getHTMLElement();
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  get onMouseDblClick() {
    return Event.map(this.list.onMouseDblClick, ({element, index, browserEvent}) => ({element: element === void 0 ? void 0 : this._model.get(element), index, browserEvent}));
  }
  get onPointer() {
    return Event.map(this.list.onPointer, ({element, index, browserEvent}) => ({element: element === void 0 ? void 0 : this._model.get(element), index, browserEvent}));
  }
  get onDidChangeFocus() {
    return Event.map(this.list.onDidChangeFocus, ({elements, indexes, browserEvent}) => ({elements: elements.map((e) => this._model.get(e)), indexes, browserEvent}));
  }
  get onDidChangeSelection() {
    return Event.map(this.list.onDidChangeSelection, ({elements, indexes, browserEvent}) => ({elements: elements.map((e) => this._model.get(e)), indexes, browserEvent}));
  }
  get model() {
    return this._model;
  }
  set model(model2) {
    this._model = model2;
    this.list.splice(0, this.list.length, range(model2.length));
  }
  getFocus() {
    return this.list.getFocus();
  }
  setSelection(indexes, browserEvent) {
    this.list.setSelection(indexes, browserEvent);
  }
  getSelection() {
    return this.list.getSelection();
  }
  style(styles) {
    this.list.style(styles);
  }
  dispose() {
    this.list.dispose();
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkeys.js
var InputFocusedContextKey = "inputFocus";

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/tree.js
var TreeMouseEventTarget;
(function(TreeMouseEventTarget2) {
  TreeMouseEventTarget2[TreeMouseEventTarget2["Unknown"] = 0] = "Unknown";
  TreeMouseEventTarget2[TreeMouseEventTarget2["Twistie"] = 1] = "Twistie";
  TreeMouseEventTarget2[TreeMouseEventTarget2["Element"] = 2] = "Element";
})(TreeMouseEventTarget || (TreeMouseEventTarget = {}));
var TreeError = class extends Error {
  constructor(user, message) {
    super(`TreeError [${user}] ${message}`);
  }
};
var WeakMapper = class {
  constructor(fn) {
    this.fn = fn;
    this._map = new WeakMap();
  }
  map(key) {
    let result = this._map.get(key);
    if (!result) {
      result = this.fn(key);
      this._map.set(key, result);
    }
    return result;
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/indexTreeModel.js
function isFilterResult(obj) {
  return typeof obj === "object" && "visibility" in obj && "data" in obj;
}
function getVisibleState(visibility) {
  switch (visibility) {
    case true:
      return 1;
    case false:
      return 0;
    default:
      return visibility;
  }
}
function isCollapsibleStateUpdate(update) {
  return typeof update.collapsible === "boolean";
}
var IndexTreeModel = class {
  constructor(user, list, rootElement, options = {}) {
    this.user = user;
    this.list = list;
    this.rootRef = [];
    this.eventBufferer = new EventBufferer();
    this._onDidChangeCollapseState = new Emitter();
    this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);
    this._onDidChangeRenderNodeCount = new Emitter();
    this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);
    this._onDidSplice = new Emitter();
    this.onDidSplice = this._onDidSplice.event;
    this.collapseByDefault = typeof options.collapseByDefault === "undefined" ? false : options.collapseByDefault;
    this.filter = options.filter;
    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === "undefined" ? false : options.autoExpandSingleChildren;
    this.root = {
      parent: void 0,
      element: rootElement,
      children: [],
      depth: 0,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: false,
      collapsed: false,
      renderNodeCount: 0,
      visibility: 1,
      visible: true,
      filterData: void 0
    };
  }
  splice(location, deleteCount, toInsert = Iterable.empty(), onDidCreateNode, onDidDeleteNode) {
    if (location.length === 0) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    const {parentNode, listIndex, revealed, visible} = this.getParentNodeWithListIndex(location);
    const treeListElementsToInsert = [];
    const nodesToInsertIterator = Iterable.map(toInsert, (el) => this.createTreeNode(el, parentNode, parentNode.visible ? 1 : 0, revealed, treeListElementsToInsert, onDidCreateNode));
    const lastIndex = location[location.length - 1];
    let visibleChildStartIndex = 0;
    for (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {
      const child = parentNode.children[i];
      if (child.visible) {
        visibleChildStartIndex = child.visibleChildIndex;
        break;
      }
    }
    const nodesToInsert = [];
    let insertedVisibleChildrenCount = 0;
    let renderNodeCount = 0;
    for (const child of nodesToInsertIterator) {
      nodesToInsert.push(child);
      renderNodeCount += child.renderNodeCount;
      if (child.visible) {
        child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;
      }
    }
    const deletedNodes = parentNode.children.splice(lastIndex, deleteCount, ...nodesToInsert);
    let deletedVisibleChildrenCount = 0;
    for (const child of deletedNodes) {
      if (child.visible) {
        deletedVisibleChildrenCount++;
      }
    }
    if (deletedVisibleChildrenCount !== 0) {
      for (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {
        const child = parentNode.children[i];
        if (child.visible) {
          child.visibleChildIndex -= deletedVisibleChildrenCount;
        }
      }
    }
    parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;
    if (revealed && visible) {
      const visibleDeleteCount = deletedNodes.reduce((r, node2) => r + (node2.visible ? node2.renderNodeCount : 0), 0);
      this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);
      this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);
    }
    if (deletedNodes.length > 0 && onDidDeleteNode) {
      const visit = (node2) => {
        onDidDeleteNode(node2);
        node2.children.forEach(visit);
      };
      deletedNodes.forEach(visit);
    }
    this._onDidSplice.fire({insertedNodes: nodesToInsert, deletedNodes});
    let node = parentNode;
    while (node) {
      if (node.visibility === 2) {
        this.refilter();
        break;
      }
      node = node.parent;
    }
  }
  rerender(location) {
    if (location.length === 0) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    const {node, listIndex, revealed} = this.getTreeNodeWithListIndex(location);
    if (node.visible && revealed) {
      this.list.splice(listIndex, 1, [node]);
    }
  }
  has(location) {
    return this.hasTreeNode(location);
  }
  getListIndex(location) {
    const {listIndex, visible, revealed} = this.getTreeNodeWithListIndex(location);
    return visible && revealed ? listIndex : -1;
  }
  getListRenderCount(location) {
    return this.getTreeNode(location).renderNodeCount;
  }
  isCollapsible(location) {
    return this.getTreeNode(location).collapsible;
  }
  setCollapsible(location, collapsible) {
    const node = this.getTreeNode(location);
    if (typeof collapsible === "undefined") {
      collapsible = !node.collapsible;
    }
    const update = {collapsible};
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));
  }
  isCollapsed(location) {
    return this.getTreeNode(location).collapsed;
  }
  setCollapsed(location, collapsed, recursive) {
    const node = this.getTreeNode(location);
    if (typeof collapsed === "undefined") {
      collapsed = !node.collapsed;
    }
    const update = {collapsed, recursive: recursive || false};
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));
  }
  _setCollapseState(location, update) {
    const {node, listIndex, revealed} = this.getTreeNodeWithListIndex(location);
    const result = this._setListNodeCollapseState(node, listIndex, revealed, update);
    if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {
      let onlyVisibleChildIndex = -1;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (child.visible) {
          if (onlyVisibleChildIndex > -1) {
            onlyVisibleChildIndex = -1;
            break;
          } else {
            onlyVisibleChildIndex = i;
          }
        }
      }
      if (onlyVisibleChildIndex > -1) {
        this._setCollapseState([...location, onlyVisibleChildIndex], update);
      }
    }
    return result;
  }
  _setListNodeCollapseState(node, listIndex, revealed, update) {
    const result = this._setNodeCollapseState(node, update, false);
    if (!revealed || !node.visible || !result) {
      return result;
    }
    const previousRenderNodeCount = node.renderNodeCount;
    const toInsert = this.updateNodeAfterCollapseChange(node);
    const deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);
    this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));
    return result;
  }
  _setNodeCollapseState(node, update, deep) {
    let result;
    if (node === this.root) {
      result = false;
    } else {
      if (isCollapsibleStateUpdate(update)) {
        result = node.collapsible !== update.collapsible;
        node.collapsible = update.collapsible;
      } else if (!node.collapsible) {
        result = false;
      } else {
        result = node.collapsed !== update.collapsed;
        node.collapsed = update.collapsed;
      }
      if (result) {
        this._onDidChangeCollapseState.fire({node, deep});
      }
    }
    if (!isCollapsibleStateUpdate(update) && update.recursive) {
      for (const child of node.children) {
        result = this._setNodeCollapseState(child, update, true) || result;
      }
    }
    return result;
  }
  expandTo(location) {
    this.eventBufferer.bufferEvents(() => {
      let node = this.getTreeNode(location);
      while (node.parent) {
        node = node.parent;
        location = location.slice(0, location.length - 1);
        if (node.collapsed) {
          this._setCollapseState(location, {collapsed: false, recursive: false});
        }
      }
    });
  }
  refilter() {
    const previousRenderNodeCount = this.root.renderNodeCount;
    const toInsert = this.updateNodeAfterFilterChange(this.root);
    this.list.splice(0, previousRenderNodeCount, toInsert);
  }
  createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {
    const node = {
      parent,
      element: treeElement.element,
      children: [],
      depth: parent.depth + 1,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: typeof treeElement.collapsible === "boolean" ? treeElement.collapsible : typeof treeElement.collapsed !== "undefined",
      collapsed: typeof treeElement.collapsed === "undefined" ? this.collapseByDefault : treeElement.collapsed,
      renderNodeCount: 1,
      visibility: 1,
      visible: true,
      filterData: void 0
    };
    const visibility = this._filterNode(node, parentVisibility);
    node.visibility = visibility;
    if (revealed) {
      treeListElements.push(node);
    }
    const childElements = treeElement.children || Iterable.empty();
    const childRevealed = revealed && visibility !== 0 && !node.collapsed;
    const childNodes = Iterable.map(childElements, (el) => this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode));
    let visibleChildrenCount = 0;
    let renderNodeCount = 1;
    for (const child of childNodes) {
      node.children.push(child);
      renderNodeCount += child.renderNodeCount;
      if (child.visible) {
        child.visibleChildIndex = visibleChildrenCount++;
      }
    }
    node.collapsible = node.collapsible || node.children.length > 0;
    node.visibleChildrenCount = visibleChildrenCount;
    node.visible = visibility === 2 ? visibleChildrenCount > 0 : visibility === 1;
    if (!node.visible) {
      node.renderNodeCount = 0;
      if (revealed) {
        treeListElements.pop();
      }
    } else if (!node.collapsed) {
      node.renderNodeCount = renderNodeCount;
    }
    if (onDidCreateNode) {
      onDidCreateNode(node);
    }
    return node;
  }
  updateNodeAfterCollapseChange(node) {
    const previousRenderNodeCount = node.renderNodeCount;
    const result = [];
    this._updateNodeAfterCollapseChange(node, result);
    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);
    return result;
  }
  _updateNodeAfterCollapseChange(node, result) {
    if (node.visible === false) {
      return 0;
    }
    result.push(node);
    node.renderNodeCount = 1;
    if (!node.collapsed) {
      for (const child of node.children) {
        node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);
      }
    }
    this._onDidChangeRenderNodeCount.fire(node);
    return node.renderNodeCount;
  }
  updateNodeAfterFilterChange(node) {
    const previousRenderNodeCount = node.renderNodeCount;
    const result = [];
    this._updateNodeAfterFilterChange(node, node.visible ? 1 : 0, result);
    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);
    return result;
  }
  _updateNodeAfterFilterChange(node, parentVisibility, result, revealed = true) {
    let visibility;
    if (node !== this.root) {
      visibility = this._filterNode(node, parentVisibility);
      if (visibility === 0) {
        node.visible = false;
        node.renderNodeCount = 0;
        return false;
      }
      if (revealed) {
        result.push(node);
      }
    }
    const resultStartLength = result.length;
    node.renderNodeCount = node === this.root ? 0 : 1;
    let hasVisibleDescendants = false;
    if (!node.collapsed || visibility !== 0) {
      let visibleChildIndex = 0;
      for (const child of node.children) {
        hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;
        if (child.visible) {
          child.visibleChildIndex = visibleChildIndex++;
        }
      }
      node.visibleChildrenCount = visibleChildIndex;
    } else {
      node.visibleChildrenCount = 0;
    }
    if (node !== this.root) {
      node.visible = visibility === 2 ? hasVisibleDescendants : visibility === 1;
    }
    if (!node.visible) {
      node.renderNodeCount = 0;
      if (revealed) {
        result.pop();
      }
    } else if (!node.collapsed) {
      node.renderNodeCount += result.length - resultStartLength;
    }
    this._onDidChangeRenderNodeCount.fire(node);
    return node.visible;
  }
  _updateAncestorsRenderNodeCount(node, diff) {
    if (diff === 0) {
      return;
    }
    while (node) {
      node.renderNodeCount += diff;
      this._onDidChangeRenderNodeCount.fire(node);
      node = node.parent;
    }
  }
  _filterNode(node, parentVisibility) {
    const result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1;
    if (typeof result === "boolean") {
      node.filterData = void 0;
      return result ? 1 : 0;
    } else if (isFilterResult(result)) {
      node.filterData = result.data;
      return getVisibleState(result.visibility);
    } else {
      node.filterData = void 0;
      return getVisibleState(result);
    }
  }
  hasTreeNode(location, node = this.root) {
    if (!location || location.length === 0) {
      return true;
    }
    const [index, ...rest] = location;
    if (index < 0 || index > node.children.length) {
      return false;
    }
    return this.hasTreeNode(rest, node.children[index]);
  }
  getTreeNode(location, node = this.root) {
    if (!location || location.length === 0) {
      return node;
    }
    const [index, ...rest] = location;
    if (index < 0 || index > node.children.length) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    return this.getTreeNode(rest, node.children[index]);
  }
  getTreeNodeWithListIndex(location) {
    if (location.length === 0) {
      return {node: this.root, listIndex: -1, revealed: true, visible: false};
    }
    const {parentNode, listIndex, revealed, visible} = this.getParentNodeWithListIndex(location);
    const index = location[location.length - 1];
    if (index < 0 || index > parentNode.children.length) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    const node = parentNode.children[index];
    return {node, listIndex, revealed, visible: visible && node.visible};
  }
  getParentNodeWithListIndex(location, node = this.root, listIndex = 0, revealed = true, visible = true) {
    const [index, ...rest] = location;
    if (index < 0 || index > node.children.length) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    for (let i = 0; i < index; i++) {
      listIndex += node.children[i].renderNodeCount;
    }
    revealed = revealed && !node.collapsed;
    visible = visible && node.visible;
    if (rest.length === 0) {
      return {parentNode: node, listIndex, revealed, visible};
    }
    return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);
  }
  getNode(location = []) {
    return this.getTreeNode(location);
  }
  getNodeLocation(node) {
    const location = [];
    let indexTreeNode = node;
    while (indexTreeNode.parent) {
      location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));
      indexTreeNode = indexTreeNode.parent;
    }
    return location.reverse();
  }
  getParentNodeLocation(location) {
    if (location.length === 0) {
      return void 0;
    } else if (location.length === 1) {
      return [];
    } else {
      return tail2(location)[0];
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/treeIcons.js
var treeItemExpandedIcon = registerIcon("tree-item-expanded", Codicon.chevronDown);
var treeFilterOnTypeOnIcon = registerIcon("tree-filter-on-type-on", Codicon.listFilter);
var treeFilterOnTypeOffIcon = registerIcon("tree-filter-on-type-off", Codicon.listSelection);
var treeFilterClearIcon = registerIcon("tree-filter-clear", Codicon.close);
var treeItemLoadingIcon = registerIcon("tree-item-loading", Codicon.loading);

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/abstractTree.js
var TreeElementsDragAndDropData = class extends ElementsDragAndDropData {
  constructor(data) {
    super(data.elements.map((node) => node.element));
    this.data = data;
  }
};
function asTreeDragAndDropData(data) {
  if (data instanceof ElementsDragAndDropData) {
    return new TreeElementsDragAndDropData(data);
  }
  return data;
}
var TreeNodeListDragAndDrop = class {
  constructor(modelProvider, dnd) {
    this.modelProvider = modelProvider;
    this.dnd = dnd;
    this.autoExpandDisposable = Disposable.None;
  }
  getDragURI(node) {
    return this.dnd.getDragURI(node.element);
  }
  getDragLabel(nodes, originalEvent) {
    if (this.dnd.getDragLabel) {
      return this.dnd.getDragLabel(nodes.map((node) => node.element), originalEvent);
    }
    return void 0;
  }
  onDragStart(data, originalEvent) {
    if (this.dnd.onDragStart) {
      this.dnd.onDragStart(asTreeDragAndDropData(data), originalEvent);
    }
  }
  onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {
    const result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
    const didChangeAutoExpandNode = this.autoExpandNode !== targetNode;
    if (didChangeAutoExpandNode) {
      this.autoExpandDisposable.dispose();
      this.autoExpandNode = targetNode;
    }
    if (typeof targetNode === "undefined") {
      return result;
    }
    if (didChangeAutoExpandNode && typeof result !== "boolean" && result.autoExpand) {
      this.autoExpandDisposable = disposableTimeout(() => {
        const model3 = this.modelProvider();
        const ref2 = model3.getNodeLocation(targetNode);
        if (model3.isCollapsed(ref2)) {
          model3.setCollapsed(ref2, false);
        }
        this.autoExpandNode = void 0;
      }, 500);
    }
    if (typeof result === "boolean" || !result.accept || typeof result.bubble === "undefined" || result.feedback) {
      if (!raw) {
        const accept = typeof result === "boolean" ? result : result.accept;
        const effect = typeof result === "boolean" ? void 0 : result.effect;
        return {accept, effect, feedback: [targetIndex]};
      }
      return result;
    }
    if (result.bubble === 1) {
      const model3 = this.modelProvider();
      const ref2 = model3.getNodeLocation(targetNode);
      const parentRef = model3.getParentNodeLocation(ref2);
      const parentNode = model3.getNode(parentRef);
      const parentIndex = parentRef && model3.getListIndex(parentRef);
      return this.onDragOver(data, parentNode, parentIndex, originalEvent, false);
    }
    const model2 = this.modelProvider();
    const ref = model2.getNodeLocation(targetNode);
    const start = model2.getListIndex(ref);
    const length = model2.getListRenderCount(ref);
    return Object.assign(Object.assign({}, result), {feedback: range(start, start + length)});
  }
  drop(data, targetNode, targetIndex, originalEvent) {
    this.autoExpandDisposable.dispose();
    this.autoExpandNode = void 0;
    this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
  }
  onDragEnd(originalEvent) {
    if (this.dnd.onDragEnd) {
      this.dnd.onDragEnd(originalEvent);
    }
  }
};
function asListOptions(modelProvider, options) {
  return options && Object.assign(Object.assign({}, options), {identityProvider: options.identityProvider && {
    getId(el) {
      return options.identityProvider.getId(el.element);
    }
  }, dnd: options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd), multipleSelectionController: options.multipleSelectionController && {
    isSelectionSingleChangeEvent(e) {
      return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), {element: e.element}));
    },
    isSelectionRangeChangeEvent(e) {
      return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), {element: e.element}));
    }
  }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), {
    getSetSize(node) {
      const model2 = modelProvider();
      const ref = model2.getNodeLocation(node);
      const parentRef = model2.getParentNodeLocation(ref);
      const parentNode = model2.getNode(parentRef);
      return parentNode.visibleChildrenCount;
    },
    getPosInSet(node) {
      return node.visibleChildIndex + 1;
    },
    isChecked: options.accessibilityProvider && options.accessibilityProvider.isChecked ? (node) => {
      return options.accessibilityProvider.isChecked(node.element);
    } : void 0,
    getRole: options.accessibilityProvider && options.accessibilityProvider.getRole ? (node) => {
      return options.accessibilityProvider.getRole(node.element);
    } : () => "treeitem",
    getAriaLabel(e) {
      return options.accessibilityProvider.getAriaLabel(e.element);
    },
    getWidgetAriaLabel() {
      return options.accessibilityProvider.getWidgetAriaLabel();
    },
    getWidgetRole: options.accessibilityProvider && options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => "tree",
    getAriaLevel(node) {
      return node.depth;
    },
    getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && ((node) => {
      return options.accessibilityProvider.getActiveDescendantId(node.element);
    })
  }), keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), {getKeyboardNavigationLabel(node) {
    return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);
  }}), enableKeyboardNavigation: options.simpleKeyboardNavigation});
}
var ComposedTreeDelegate = class {
  constructor(delegate) {
    this.delegate = delegate;
  }
  getHeight(element) {
    return this.delegate.getHeight(element.element);
  }
  getTemplateId(element) {
    return this.delegate.getTemplateId(element.element);
  }
  hasDynamicHeight(element) {
    return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);
  }
  setDynamicHeight(element, height) {
    if (this.delegate.setDynamicHeight) {
      this.delegate.setDynamicHeight(element.element, height);
    }
  }
};
var RenderIndentGuides;
(function(RenderIndentGuides2) {
  RenderIndentGuides2["None"] = "none";
  RenderIndentGuides2["OnHover"] = "onHover";
  RenderIndentGuides2["Always"] = "always";
})(RenderIndentGuides || (RenderIndentGuides = {}));
var EventCollection = class {
  constructor(onDidChange, _elements = []) {
    this._elements = _elements;
    this.onDidChange = Event.forEach(onDidChange, (elements) => this._elements = elements);
  }
  get elements() {
    return this._elements;
  }
};
var TreeRenderer = class {
  constructor(renderer, modelProvider, onDidChangeCollapseState, activeNodes, options = {}) {
    this.renderer = renderer;
    this.modelProvider = modelProvider;
    this.activeNodes = activeNodes;
    this.renderedElements = new Map();
    this.renderedNodes = new Map();
    this.indent = TreeRenderer.DefaultIndent;
    this.hideTwistiesOfChildlessElements = false;
    this.shouldRenderIndentGuides = false;
    this.renderedIndentGuides = new SetMap();
    this.activeIndentNodes = new Set();
    this.indentGuidesDisposable = Disposable.None;
    this.disposables = new DisposableStore();
    this.templateId = renderer.templateId;
    this.updateOptions(options);
    Event.map(onDidChangeCollapseState, (e) => e.node)(this.onDidChangeNodeTwistieState, this, this.disposables);
    if (renderer.onDidChangeTwistieState) {
      renderer.onDidChangeTwistieState(this.onDidChangeTwistieState, this, this.disposables);
    }
  }
  updateOptions(options = {}) {
    if (typeof options.indent !== "undefined") {
      this.indent = clamp(options.indent, 0, 40);
    }
    if (typeof options.renderIndentGuides !== "undefined") {
      const shouldRenderIndentGuides = options.renderIndentGuides !== RenderIndentGuides.None;
      if (shouldRenderIndentGuides !== this.shouldRenderIndentGuides) {
        this.shouldRenderIndentGuides = shouldRenderIndentGuides;
        this.indentGuidesDisposable.dispose();
        if (shouldRenderIndentGuides) {
          const disposables = new DisposableStore();
          this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, disposables);
          this.indentGuidesDisposable = disposables;
          this._onDidChangeActiveNodes(this.activeNodes.elements);
        }
      }
    }
    if (typeof options.hideTwistiesOfChildlessElements !== "undefined") {
      this.hideTwistiesOfChildlessElements = options.hideTwistiesOfChildlessElements;
    }
  }
  renderTemplate(container) {
    const el = append(container, $(".monaco-tl-row"));
    const indent = append(el, $(".monaco-tl-indent"));
    const twistie = append(el, $(".monaco-tl-twistie"));
    const contents = append(el, $(".monaco-tl-contents"));
    const templateData = this.renderer.renderTemplate(contents);
    return {container, indent, twistie, indentGuidesDisposable: Disposable.None, templateData};
  }
  renderElement(node, index, templateData, height) {
    if (typeof height === "number") {
      this.renderedNodes.set(node, {templateData, height});
      this.renderedElements.set(node.element, node);
    }
    const indent = TreeRenderer.DefaultIndent + (node.depth - 1) * this.indent;
    templateData.twistie.style.paddingLeft = `${indent}px`;
    templateData.indent.style.width = `${indent + this.indent - 16}px`;
    this.renderTwistie(node, templateData);
    if (typeof height === "number") {
      this.renderIndentGuides(node, templateData);
    }
    this.renderer.renderElement(node, index, templateData.templateData, height);
  }
  disposeElement(node, index, templateData, height) {
    templateData.indentGuidesDisposable.dispose();
    if (this.renderer.disposeElement) {
      this.renderer.disposeElement(node, index, templateData.templateData, height);
    }
    if (typeof height === "number") {
      this.renderedNodes.delete(node);
      this.renderedElements.delete(node.element);
    }
  }
  disposeTemplate(templateData) {
    this.renderer.disposeTemplate(templateData.templateData);
  }
  onDidChangeTwistieState(element) {
    const node = this.renderedElements.get(element);
    if (!node) {
      return;
    }
    this.onDidChangeNodeTwistieState(node);
  }
  onDidChangeNodeTwistieState(node) {
    const data = this.renderedNodes.get(node);
    if (!data) {
      return;
    }
    this.renderTwistie(node, data.templateData);
    this._onDidChangeActiveNodes(this.activeNodes.elements);
    this.renderIndentGuides(node, data.templateData);
  }
  renderTwistie(node, templateData) {
    if (this.renderer.renderTwistie) {
      this.renderer.renderTwistie(node.element, templateData.twistie);
    }
    if (node.collapsible && (!this.hideTwistiesOfChildlessElements || node.visibleChildrenCount > 0)) {
      addClasses(templateData.twistie, treeItemExpandedIcon.classNames, "collapsible");
      toggleClass(templateData.twistie, "collapsed", node.collapsed);
    } else {
      removeClasses(templateData.twistie, treeItemExpandedIcon.classNames, "collapsible", "collapsed");
    }
    if (node.collapsible) {
      templateData.container.setAttribute("aria-expanded", String(!node.collapsed));
    } else {
      templateData.container.removeAttribute("aria-expanded");
    }
  }
  renderIndentGuides(target, templateData) {
    clearNode(templateData.indent);
    templateData.indentGuidesDisposable.dispose();
    if (!this.shouldRenderIndentGuides) {
      return;
    }
    const disposableStore = new DisposableStore();
    const model2 = this.modelProvider();
    let node = target;
    while (true) {
      const ref = model2.getNodeLocation(node);
      const parentRef = model2.getParentNodeLocation(ref);
      if (!parentRef) {
        break;
      }
      const parent = model2.getNode(parentRef);
      const guide = $(".indent-guide", {style: `width: ${this.indent}px`});
      if (this.activeIndentNodes.has(parent)) {
        addClass(guide, "active");
      }
      if (templateData.indent.childElementCount === 0) {
        templateData.indent.appendChild(guide);
      } else {
        templateData.indent.insertBefore(guide, templateData.indent.firstElementChild);
      }
      this.renderedIndentGuides.add(parent, guide);
      disposableStore.add(toDisposable(() => this.renderedIndentGuides.delete(parent, guide)));
      node = parent;
    }
    templateData.indentGuidesDisposable = disposableStore;
  }
  _onDidChangeActiveNodes(nodes) {
    if (!this.shouldRenderIndentGuides) {
      return;
    }
    const set = new Set();
    const model2 = this.modelProvider();
    nodes.forEach((node) => {
      const ref = model2.getNodeLocation(node);
      try {
        const parentRef = model2.getParentNodeLocation(ref);
        if (node.collapsible && node.children.length > 0 && !node.collapsed) {
          set.add(node);
        } else if (parentRef) {
          set.add(model2.getNode(parentRef));
        }
      } catch (_a) {
      }
    });
    this.activeIndentNodes.forEach((node) => {
      if (!set.has(node)) {
        this.renderedIndentGuides.forEach(node, (line) => removeClass(line, "active"));
      }
    });
    set.forEach((node) => {
      if (!this.activeIndentNodes.has(node)) {
        this.renderedIndentGuides.forEach(node, (line) => addClass(line, "active"));
      }
    });
    this.activeIndentNodes = set;
  }
  dispose() {
    this.renderedNodes.clear();
    this.renderedElements.clear();
    this.indentGuidesDisposable.dispose();
    dispose(this.disposables);
  }
};
TreeRenderer.DefaultIndent = 8;
var TypeFilter = class {
  constructor(tree, keyboardNavigationLabelProvider, _filter) {
    this.tree = tree;
    this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;
    this._filter = _filter;
    this._totalCount = 0;
    this._matchCount = 0;
    this._pattern = "";
    this._lowercasePattern = "";
    this.disposables = new DisposableStore();
    tree.onWillRefilter(this.reset, this, this.disposables);
  }
  get totalCount() {
    return this._totalCount;
  }
  get matchCount() {
    return this._matchCount;
  }
  set pattern(pattern) {
    this._pattern = pattern;
    this._lowercasePattern = pattern.toLowerCase();
  }
  filter(element, parentVisibility) {
    if (this._filter) {
      const result = this._filter.filter(element, parentVisibility);
      if (this.tree.options.simpleKeyboardNavigation) {
        return result;
      }
      let visibility;
      if (typeof result === "boolean") {
        visibility = result ? 1 : 0;
      } else if (isFilterResult(result)) {
        visibility = getVisibleState(result.visibility);
      } else {
        visibility = result;
      }
      if (visibility === 0) {
        return false;
      }
    }
    this._totalCount++;
    if (this.tree.options.simpleKeyboardNavigation || !this._pattern) {
      this._matchCount++;
      return {data: FuzzyScore.Default, visibility: true};
    }
    const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(element);
    const labelStr = label && label.toString();
    if (typeof labelStr === "undefined") {
      return {data: FuzzyScore.Default, visibility: true};
    }
    const score2 = fuzzyScore(this._pattern, this._lowercasePattern, 0, labelStr, labelStr.toLowerCase(), 0, true);
    if (!score2) {
      if (this.tree.options.filterOnType) {
        return 2;
      } else {
        return {data: FuzzyScore.Default, visibility: true};
      }
    }
    this._matchCount++;
    return {data: score2, visibility: true};
  }
  reset() {
    this._totalCount = 0;
    this._matchCount = 0;
  }
  dispose() {
    dispose(this.disposables);
  }
};
var TypeFilterController = class {
  constructor(tree, model2, view, filter, keyboardNavigationDelegate) {
    this.tree = tree;
    this.view = view;
    this.filter = filter;
    this.keyboardNavigationDelegate = keyboardNavigationDelegate;
    this._enabled = false;
    this._pattern = "";
    this._empty = false;
    this._onDidChangeEmptyState = new Emitter();
    this.positionClassName = "ne";
    this.automaticKeyboardNavigation = true;
    this.triggered = false;
    this._onDidChangePattern = new Emitter();
    this.enabledDisposables = new DisposableStore();
    this.disposables = new DisposableStore();
    this.domNode = $(`.monaco-list-type-filter.${this.positionClassName}`);
    this.domNode.draggable = true;
    domEvent(this.domNode, "dragstart")(this.onDragStart, this, this.disposables);
    this.messageDomNode = append(view.getHTMLElement(), $(`.monaco-list-type-filter-message`));
    this.labelDomNode = append(this.domNode, $("span.label"));
    const controls = append(this.domNode, $(".controls"));
    this._filterOnType = !!tree.options.filterOnType;
    this.filterOnTypeDomNode = append(controls, $("input.filter"));
    this.filterOnTypeDomNode.type = "checkbox";
    this.filterOnTypeDomNode.checked = this._filterOnType;
    this.filterOnTypeDomNode.tabIndex = -1;
    this.updateFilterOnTypeTitleAndIcon();
    domEvent(this.filterOnTypeDomNode, "input")(this.onDidChangeFilterOnType, this, this.disposables);
    this.clearDomNode = append(controls, $("button.clear" + treeFilterClearIcon.cssSelector));
    this.clearDomNode.tabIndex = -1;
    this.clearDomNode.title = localize("clear", "Clear");
    this.keyboardNavigationEventFilter = tree.options.keyboardNavigationEventFilter;
    model2.onDidSplice(this.onDidSpliceModel, this, this.disposables);
    this.updateOptions(tree.options);
  }
  get enabled() {
    return this._enabled;
  }
  get pattern() {
    return this._pattern;
  }
  get filterOnType() {
    return this._filterOnType;
  }
  updateOptions(options) {
    if (options.simpleKeyboardNavigation) {
      this.disable();
    } else {
      this.enable();
    }
    if (typeof options.filterOnType !== "undefined") {
      this._filterOnType = !!options.filterOnType;
      this.filterOnTypeDomNode.checked = this._filterOnType;
    }
    if (typeof options.automaticKeyboardNavigation !== "undefined") {
      this.automaticKeyboardNavigation = options.automaticKeyboardNavigation;
    }
    this.tree.refilter();
    this.render();
    if (!this.automaticKeyboardNavigation) {
      this.onEventOrInput("");
    }
  }
  enable() {
    if (this._enabled) {
      return;
    }
    const onKeyDown = Event.chain(domEvent(this.view.getHTMLElement(), "keydown")).filter((e) => !isInputElement(e.target) || e.target === this.filterOnTypeDomNode).filter((e) => e.key !== "Dead" && !/^Media/.test(e.key)).map((e) => new StandardKeyboardEvent(e)).filter(this.keyboardNavigationEventFilter || (() => true)).filter(() => this.automaticKeyboardNavigation || this.triggered).filter((e) => this.keyboardNavigationDelegate.mightProducePrintableCharacter(e) && !(e.keyCode === 18 || e.keyCode === 16 || e.keyCode === 15 || e.keyCode === 17) || ((this.pattern.length > 0 || this.triggered) && ((e.keyCode === 9 || e.keyCode === 1) && !e.altKey && !e.ctrlKey && !e.metaKey) || e.keyCode === 1 && (isMacintosh ? e.altKey && !e.metaKey : e.ctrlKey) && !e.shiftKey)).forEach((e) => {
      e.stopPropagation();
      e.preventDefault();
    }).event;
    const onClear = domEvent(this.clearDomNode, "click");
    Event.chain(Event.any(onKeyDown, onClear)).event(this.onEventOrInput, this, this.enabledDisposables);
    this.filter.pattern = "";
    this.tree.refilter();
    this.render();
    this._enabled = true;
    this.triggered = false;
  }
  disable() {
    if (!this._enabled) {
      return;
    }
    this.domNode.remove();
    this.enabledDisposables.clear();
    this.tree.refilter();
    this.render();
    this._enabled = false;
    this.triggered = false;
  }
  onEventOrInput(e) {
    if (typeof e === "string") {
      this.onInput(e);
    } else if (e instanceof MouseEvent || e.keyCode === 9 || e.keyCode === 1 && (isMacintosh ? e.altKey : e.ctrlKey)) {
      this.onInput("");
    } else if (e.keyCode === 1) {
      this.onInput(this.pattern.length === 0 ? "" : this.pattern.substr(0, this.pattern.length - 1));
    } else {
      this.onInput(this.pattern + e.browserEvent.key);
    }
  }
  onInput(pattern) {
    const container = this.view.getHTMLElement();
    if (pattern && !this.domNode.parentElement) {
      container.append(this.domNode);
    } else if (!pattern && this.domNode.parentElement) {
      this.domNode.remove();
      this.tree.domFocus();
    }
    this._pattern = pattern;
    this._onDidChangePattern.fire(pattern);
    this.filter.pattern = pattern;
    this.tree.refilter();
    if (pattern) {
      this.tree.focusNext(0, true, void 0, (node) => !FuzzyScore.isDefault(node.filterData));
    }
    const focus = this.tree.getFocus();
    if (focus.length > 0) {
      const element = focus[0];
      if (this.tree.getRelativeTop(element) === null) {
        this.tree.reveal(element, 0.5);
      }
    }
    this.render();
    if (!pattern) {
      this.triggered = false;
    }
  }
  onDragStart() {
    const container = this.view.getHTMLElement();
    const {left} = getDomNodePagePosition(container);
    const containerWidth = container.clientWidth;
    const midContainerWidth = containerWidth / 2;
    const width = this.domNode.clientWidth;
    const disposables = new DisposableStore();
    let positionClassName = this.positionClassName;
    const updatePosition = () => {
      switch (positionClassName) {
        case "nw":
          this.domNode.style.top = `4px`;
          this.domNode.style.left = `4px`;
          break;
        case "ne":
          this.domNode.style.top = `4px`;
          this.domNode.style.left = `${containerWidth - width - 6}px`;
          break;
      }
    };
    const onDragOver = (event) => {
      event.preventDefault();
      const x = event.screenX - left;
      if (event.dataTransfer) {
        event.dataTransfer.dropEffect = "none";
      }
      if (x < midContainerWidth) {
        positionClassName = "nw";
      } else {
        positionClassName = "ne";
      }
      updatePosition();
    };
    const onDragEnd = () => {
      this.positionClassName = positionClassName;
      this.domNode.className = `monaco-list-type-filter ${this.positionClassName}`;
      this.domNode.style.top = "";
      this.domNode.style.left = "";
      dispose(disposables);
    };
    updatePosition();
    removeClass(this.domNode, positionClassName);
    addClass(this.domNode, "dragging");
    disposables.add(toDisposable(() => removeClass(this.domNode, "dragging")));
    domEvent(document, "dragover")(onDragOver, null, disposables);
    domEvent(this.domNode, "dragend")(onDragEnd, null, disposables);
    StaticDND.CurrentDragAndDropData = new DragAndDropData("vscode-ui");
    disposables.add(toDisposable(() => StaticDND.CurrentDragAndDropData = void 0));
  }
  onDidSpliceModel() {
    if (!this._enabled || this.pattern.length === 0) {
      return;
    }
    this.tree.refilter();
    this.render();
  }
  onDidChangeFilterOnType() {
    this.tree.updateOptions({filterOnType: this.filterOnTypeDomNode.checked});
    this.tree.refilter();
    this.tree.domFocus();
    this.render();
    this.updateFilterOnTypeTitleAndIcon();
  }
  updateFilterOnTypeTitleAndIcon() {
    if (this.filterOnType) {
      removeClasses(this.filterOnTypeDomNode, treeFilterOnTypeOffIcon.classNames);
      addClasses(this.filterOnTypeDomNode, treeFilterOnTypeOnIcon.classNames);
      this.filterOnTypeDomNode.title = localize("disable filter on type", "Disable Filter on Type");
    } else {
      removeClasses(this.filterOnTypeDomNode, treeFilterOnTypeOnIcon.classNames);
      addClasses(this.filterOnTypeDomNode, treeFilterOnTypeOffIcon.classNames);
      this.filterOnTypeDomNode.title = localize("enable filter on type", "Enable Filter on Type");
    }
  }
  render() {
    const noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;
    if (this.pattern && this.tree.options.filterOnType && noMatches) {
      this.messageDomNode.textContent = localize("empty", "No elements found");
      this._empty = true;
    } else {
      this.messageDomNode.innerText = "";
      this._empty = false;
    }
    toggleClass(this.domNode, "no-matches", noMatches);
    this.domNode.title = localize("found", "Matched {0} out of {1} elements", this.filter.matchCount, this.filter.totalCount);
    this.labelDomNode.textContent = this.pattern.length > 16 ? "\u2026" + this.pattern.substr(this.pattern.length - 16) : this.pattern;
    this._onDidChangeEmptyState.fire(this._empty);
  }
  shouldAllowFocus(node) {
    if (!this.enabled || !this.pattern || this.filterOnType) {
      return true;
    }
    if (this.filter.totalCount > 0 && this.filter.matchCount <= 1) {
      return true;
    }
    return !FuzzyScore.isDefault(node.filterData);
  }
  dispose() {
    if (this._enabled) {
      this.domNode.remove();
      this.enabledDisposables.dispose();
      this._enabled = false;
      this.triggered = false;
    }
    this._onDidChangePattern.dispose();
    dispose(this.disposables);
  }
};
function asTreeMouseEvent(event) {
  let target = TreeMouseEventTarget.Unknown;
  if (hasParentWithClass(event.browserEvent.target, "monaco-tl-twistie", "monaco-tl-row")) {
    target = TreeMouseEventTarget.Twistie;
  } else if (hasParentWithClass(event.browserEvent.target, "monaco-tl-contents", "monaco-tl-row")) {
    target = TreeMouseEventTarget.Element;
  }
  return {
    browserEvent: event.browserEvent,
    element: event.element ? event.element.element : null,
    target
  };
}
function dfs(node, fn) {
  fn(node);
  node.children.forEach((child) => dfs(child, fn));
}
var Trait2 = class {
  constructor(identityProvider) {
    this.identityProvider = identityProvider;
    this.nodes = [];
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
  }
  get nodeSet() {
    if (!this._nodeSet) {
      this._nodeSet = this.createNodeSet();
    }
    return this._nodeSet;
  }
  set(nodes, browserEvent) {
    if (equals(this.nodes, nodes)) {
      return;
    }
    this._set(nodes, false, browserEvent);
  }
  _set(nodes, silent, browserEvent) {
    this.nodes = [...nodes];
    this.elements = void 0;
    this._nodeSet = void 0;
    if (!silent) {
      const that = this;
      this._onDidChange.fire({get elements() {
        return that.get();
      }, browserEvent});
    }
  }
  get() {
    if (!this.elements) {
      this.elements = this.nodes.map((node) => node.element);
    }
    return [...this.elements];
  }
  getNodes() {
    return this.nodes;
  }
  has(node) {
    return this.nodeSet.has(node);
  }
  onDidModelSplice({insertedNodes, deletedNodes}) {
    if (!this.identityProvider) {
      const set = this.createNodeSet();
      const visit = (node) => set.delete(node);
      deletedNodes.forEach((node) => dfs(node, visit));
      this.set([...set.values()]);
      return;
    }
    const deletedNodesIdSet = new Set();
    const deletedNodesVisitor = (node) => deletedNodesIdSet.add(this.identityProvider.getId(node.element).toString());
    deletedNodes.forEach((node) => dfs(node, deletedNodesVisitor));
    const insertedNodesMap = new Map();
    const insertedNodesVisitor = (node) => insertedNodesMap.set(this.identityProvider.getId(node.element).toString(), node);
    insertedNodes.forEach((node) => dfs(node, insertedNodesVisitor));
    const nodes = [];
    for (const node of this.nodes) {
      const id = this.identityProvider.getId(node.element).toString();
      const wasDeleted = deletedNodesIdSet.has(id);
      if (!wasDeleted) {
        nodes.push(node);
      } else {
        const insertedNode = insertedNodesMap.get(id);
        if (insertedNode) {
          nodes.push(insertedNode);
        }
      }
    }
    this._set(nodes, true);
  }
  createNodeSet() {
    const set = new Set();
    for (const node of this.nodes) {
      set.add(node);
    }
    return set;
  }
};
var TreeNodeListMouseController = class extends MouseController {
  constructor(list, tree) {
    super(list);
    this.tree = tree;
  }
  onViewPointer(e) {
    if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {
      return;
    }
    const node = e.element;
    if (!node) {
      return super.onViewPointer(e);
    }
    if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) {
      return super.onViewPointer(e);
    }
    const target = e.browserEvent.target;
    const onTwistie = hasClass(target, "monaco-tl-twistie") || hasClass(target, "monaco-icon-label") && hasClass(target, "folder-icon") && e.browserEvent.offsetX < 16;
    let expandOnlyOnTwistieClick = false;
    if (typeof this.tree.expandOnlyOnTwistieClick === "function") {
      expandOnlyOnTwistieClick = this.tree.expandOnlyOnTwistieClick(node.element);
    } else {
      expandOnlyOnTwistieClick = !!this.tree.expandOnlyOnTwistieClick;
    }
    if (expandOnlyOnTwistieClick && !onTwistie) {
      return super.onViewPointer(e);
    }
    if (this.tree.expandOnlyOnDoubleClick && e.browserEvent.detail !== 2 && !onTwistie) {
      return super.onViewPointer(e);
    }
    if (node.collapsible) {
      const model2 = this.tree.model;
      const location = model2.getNodeLocation(node);
      const recursive = e.browserEvent.altKey;
      model2.setCollapsed(location, void 0, recursive);
      if (expandOnlyOnTwistieClick && onTwistie) {
        return;
      }
    }
    super.onViewPointer(e);
  }
  onDoubleClick(e) {
    const onTwistie = hasClass(e.browserEvent.target, "monaco-tl-twistie");
    if (onTwistie) {
      return;
    }
    super.onDoubleClick(e);
  }
};
var TreeNodeList = class extends List {
  constructor(user, container, virtualDelegate, renderers, focusTrait, selectionTrait, options) {
    super(user, container, virtualDelegate, renderers, options);
    this.focusTrait = focusTrait;
    this.selectionTrait = selectionTrait;
  }
  createMouseController(options) {
    return new TreeNodeListMouseController(this, options.tree);
  }
  splice(start, deleteCount, elements = []) {
    super.splice(start, deleteCount, elements);
    if (elements.length === 0) {
      return;
    }
    const additionalFocus = [];
    const additionalSelection = [];
    elements.forEach((node, index) => {
      if (this.focusTrait.has(node)) {
        additionalFocus.push(start + index);
      }
      if (this.selectionTrait.has(node)) {
        additionalSelection.push(start + index);
      }
    });
    if (additionalFocus.length > 0) {
      super.setFocus(distinctES6([...super.getFocus(), ...additionalFocus]));
    }
    if (additionalSelection.length > 0) {
      super.setSelection(distinctES6([...super.getSelection(), ...additionalSelection]));
    }
  }
  setFocus(indexes, browserEvent, fromAPI = false) {
    super.setFocus(indexes, browserEvent);
    if (!fromAPI) {
      this.focusTrait.set(indexes.map((i) => this.element(i)), browserEvent);
    }
  }
  setSelection(indexes, browserEvent, fromAPI = false) {
    super.setSelection(indexes, browserEvent);
    if (!fromAPI) {
      this.selectionTrait.set(indexes.map((i) => this.element(i)), browserEvent);
    }
  }
};
var AbstractTree = class {
  constructor(user, container, delegate, renderers, _options = {}) {
    this._options = _options;
    this.eventBufferer = new EventBufferer();
    this.disposables = new DisposableStore();
    this._onWillRefilter = new Emitter();
    this.onWillRefilter = this._onWillRefilter.event;
    this._onDidUpdateOptions = new Emitter();
    const treeDelegate = new ComposedTreeDelegate(delegate);
    const onDidChangeCollapseStateRelay = new Relay();
    const onDidChangeActiveNodes = new Relay();
    const activeNodes = new EventCollection(onDidChangeActiveNodes.event);
    this.renderers = renderers.map((r) => new TreeRenderer(r, () => this.model, onDidChangeCollapseStateRelay.event, activeNodes, _options));
    for (let r of this.renderers) {
      this.disposables.add(r);
    }
    let filter;
    if (_options.keyboardNavigationLabelProvider) {
      filter = new TypeFilter(this, _options.keyboardNavigationLabelProvider, _options.filter);
      _options = Object.assign(Object.assign({}, _options), {filter});
      this.disposables.add(filter);
    }
    this.focus = new Trait2(_options.identityProvider);
    this.selection = new Trait2(_options.identityProvider);
    this.view = new TreeNodeList(user, container, treeDelegate, this.renderers, this.focus, this.selection, Object.assign(Object.assign({}, asListOptions(() => this.model, _options)), {tree: this}));
    this.model = this.createModel(user, this.view, _options);
    onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;
    const onDidModelSplice = Event.forEach(this.model.onDidSplice, (e) => {
      this.eventBufferer.bufferEvents(() => {
        this.focus.onDidModelSplice(e);
        this.selection.onDidModelSplice(e);
      });
    });
    onDidModelSplice(() => null, null, this.disposables);
    onDidChangeActiveNodes.input = Event.chain(Event.any(onDidModelSplice, this.focus.onDidChange, this.selection.onDidChange)).debounce(() => null, 0).map(() => {
      const set = new Set();
      for (const node of this.focus.getNodes()) {
        set.add(node);
      }
      for (const node of this.selection.getNodes()) {
        set.add(node);
      }
      return [...set.values()];
    }).event;
    if (_options.keyboardSupport !== false) {
      const onKeyDown = Event.chain(this.view.onKeyDown).filter((e) => !isInputElement(e.target)).map((e) => new StandardKeyboardEvent(e));
      onKeyDown.filter((e) => e.keyCode === 15).on(this.onLeftArrow, this, this.disposables);
      onKeyDown.filter((e) => e.keyCode === 17).on(this.onRightArrow, this, this.disposables);
      onKeyDown.filter((e) => e.keyCode === 10).on(this.onSpace, this, this.disposables);
    }
    if (_options.keyboardNavigationLabelProvider) {
      const delegate2 = _options.keyboardNavigationDelegate || DefaultKeyboardNavigationDelegate;
      this.typeFilterController = new TypeFilterController(this, this.model, this.view, filter, delegate2);
      this.focusNavigationFilter = (node) => this.typeFilterController.shouldAllowFocus(node);
      this.disposables.add(this.typeFilterController);
    }
    this.styleElement = createStyleSheet(this.view.getHTMLElement());
    toggleClass(this.getHTMLElement(), "always", this._options.renderIndentGuides === RenderIndentGuides.Always);
  }
  get onDidChangeFocus() {
    return this.eventBufferer.wrapEvent(this.focus.onDidChange);
  }
  get onDidChangeSelection() {
    return this.eventBufferer.wrapEvent(this.selection.onDidChange);
  }
  get onMouseDblClick() {
    return Event.map(this.view.onMouseDblClick, asTreeMouseEvent);
  }
  get onPointer() {
    return Event.map(this.view.onPointer, asTreeMouseEvent);
  }
  get onDidFocus() {
    return this.view.onDidFocus;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get expandOnlyOnDoubleClick() {
    var _a;
    return (_a = this._options.expandOnlyOnDoubleClick) !== null && _a !== void 0 ? _a : false;
  }
  get expandOnlyOnTwistieClick() {
    return typeof this._options.expandOnlyOnTwistieClick === "undefined" ? false : this._options.expandOnlyOnTwistieClick;
  }
  get onDidDispose() {
    return this.view.onDidDispose;
  }
  updateOptions(optionsUpdate = {}) {
    this._options = Object.assign(Object.assign({}, this._options), optionsUpdate);
    for (const renderer of this.renderers) {
      renderer.updateOptions(optionsUpdate);
    }
    this.view.updateOptions({
      enableKeyboardNavigation: this._options.simpleKeyboardNavigation,
      automaticKeyboardNavigation: this._options.automaticKeyboardNavigation,
      smoothScrolling: this._options.smoothScrolling,
      horizontalScrolling: this._options.horizontalScrolling
    });
    if (this.typeFilterController) {
      this.typeFilterController.updateOptions(this._options);
    }
    this._onDidUpdateOptions.fire(this._options);
    toggleClass(this.getHTMLElement(), "always", this._options.renderIndentGuides === RenderIndentGuides.Always);
  }
  get options() {
    return this._options;
  }
  getHTMLElement() {
    return this.view.getHTMLElement();
  }
  get scrollTop() {
    return this.view.scrollTop;
  }
  set scrollTop(scrollTop) {
    this.view.scrollTop = scrollTop;
  }
  domFocus() {
    this.view.domFocus();
  }
  layout(height, width) {
    this.view.layout(height, width);
  }
  style(styles) {
    const suffix = `.${this.view.domId}`;
    const content = [];
    if (styles.treeIndentGuidesStroke) {
      content.push(`.monaco-list${suffix}:hover .monaco-tl-indent > .indent-guide, .monaco-list${suffix}.always .monaco-tl-indent > .indent-guide  { border-color: ${styles.treeIndentGuidesStroke.transparent(0.4)}; }`);
      content.push(`.monaco-list${suffix} .monaco-tl-indent > .indent-guide.active { border-color: ${styles.treeIndentGuidesStroke}; }`);
    }
    const newStyles = content.join("\n");
    if (newStyles !== this.styleElement.innerHTML) {
      this.styleElement.innerHTML = newStyles;
    }
    this.view.style(styles);
  }
  collapse(location, recursive = false) {
    return this.model.setCollapsed(location, true, recursive);
  }
  expand(location, recursive = false) {
    return this.model.setCollapsed(location, false, recursive);
  }
  isCollapsible(location) {
    return this.model.isCollapsible(location);
  }
  setCollapsible(location, collapsible) {
    return this.model.setCollapsible(location, collapsible);
  }
  isCollapsed(location) {
    return this.model.isCollapsed(location);
  }
  refilter() {
    this._onWillRefilter.fire(void 0);
    this.model.refilter();
  }
  setSelection(elements, browserEvent) {
    const nodes = elements.map((e) => this.model.getNode(e));
    this.selection.set(nodes, browserEvent);
    const indexes = elements.map((e) => this.model.getListIndex(e)).filter((i) => i > -1);
    this.view.setSelection(indexes, browserEvent, true);
  }
  getSelection() {
    return this.selection.get();
  }
  setFocus(elements, browserEvent) {
    const nodes = elements.map((e) => this.model.getNode(e));
    this.focus.set(nodes, browserEvent);
    const indexes = elements.map((e) => this.model.getListIndex(e)).filter((i) => i > -1);
    this.view.setFocus(indexes, browserEvent, true);
  }
  focusNext(n = 1, loop = false, browserEvent, filter = this.focusNavigationFilter) {
    this.view.focusNext(n, loop, browserEvent, filter);
  }
  getFocus() {
    return this.focus.get();
  }
  reveal(location, relativeTop) {
    this.model.expandTo(location);
    const index = this.model.getListIndex(location);
    if (index === -1) {
      return;
    }
    this.view.reveal(index, relativeTop);
  }
  getRelativeTop(location) {
    const index = this.model.getListIndex(location);
    if (index === -1) {
      return null;
    }
    return this.view.getRelativeTop(index);
  }
  onLeftArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    const nodes = this.view.getFocusedElements();
    if (nodes.length === 0) {
      return;
    }
    const node = nodes[0];
    const location = this.model.getNodeLocation(node);
    const didChange = this.model.setCollapsed(location, true);
    if (!didChange) {
      const parentLocation = this.model.getParentNodeLocation(location);
      if (!parentLocation) {
        return;
      }
      const parentListIndex = this.model.getListIndex(parentLocation);
      this.view.reveal(parentListIndex);
      this.view.setFocus([parentListIndex]);
    }
  }
  onRightArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    const nodes = this.view.getFocusedElements();
    if (nodes.length === 0) {
      return;
    }
    const node = nodes[0];
    const location = this.model.getNodeLocation(node);
    const didChange = this.model.setCollapsed(location, false);
    if (!didChange) {
      if (!node.children.some((child) => child.visible)) {
        return;
      }
      const [focusedIndex] = this.view.getFocus();
      const firstChildIndex = focusedIndex + 1;
      this.view.reveal(firstChildIndex);
      this.view.setFocus([firstChildIndex]);
    }
  }
  onSpace(e) {
    e.preventDefault();
    e.stopPropagation();
    const nodes = this.view.getFocusedElements();
    if (nodes.length === 0) {
      return;
    }
    const node = nodes[0];
    const location = this.model.getNodeLocation(node);
    const recursive = e.browserEvent.altKey;
    this.model.setCollapsed(location, void 0, recursive);
  }
  dispose() {
    dispose(this.disposables);
    this.view.dispose();
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/objectTreeModel.js
var ObjectTreeModel = class {
  constructor(user, list, options = {}) {
    this.user = user;
    this.rootRef = null;
    this.nodes = new Map();
    this.nodesByIdentity = new Map();
    this.model = new IndexTreeModel(user, list, null, options);
    this.onDidSplice = this.model.onDidSplice;
    this.onDidChangeCollapseState = this.model.onDidChangeCollapseState;
    this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount;
    if (options.sorter) {
      this.sorter = {
        compare(a, b) {
          return options.sorter.compare(a.element, b.element);
        }
      };
    }
    this.identityProvider = options.identityProvider;
  }
  setChildren(element, children = Iterable.empty(), onDidCreateNode, onDidDeleteNode) {
    const location = this.getElementLocation(element);
    this._setChildren(location, this.preserveCollapseState(children), onDidCreateNode, onDidDeleteNode);
  }
  _setChildren(location, children = Iterable.empty(), onDidCreateNode, onDidDeleteNode) {
    const insertedElements = new Set();
    const insertedElementIds = new Set();
    const _onDidCreateNode = (node) => {
      if (node.element === null) {
        return;
      }
      const tnode = node;
      insertedElements.add(tnode.element);
      this.nodes.set(tnode.element, tnode);
      if (this.identityProvider) {
        const id = this.identityProvider.getId(tnode.element).toString();
        insertedElementIds.add(id);
        this.nodesByIdentity.set(id, tnode);
      }
      if (onDidCreateNode) {
        onDidCreateNode(tnode);
      }
    };
    const _onDidDeleteNode = (node) => {
      if (node.element === null) {
        return;
      }
      const tnode = node;
      if (!insertedElements.has(tnode.element)) {
        this.nodes.delete(tnode.element);
      }
      if (this.identityProvider) {
        const id = this.identityProvider.getId(tnode.element).toString();
        if (!insertedElementIds.has(id)) {
          this.nodesByIdentity.delete(id);
        }
      }
      if (onDidDeleteNode) {
        onDidDeleteNode(tnode);
      }
    };
    this.model.splice([...location, 0], Number.MAX_VALUE, children, _onDidCreateNode, _onDidDeleteNode);
  }
  preserveCollapseState(elements = Iterable.empty()) {
    if (this.sorter) {
      elements = mergeSort([...elements], this.sorter.compare.bind(this.sorter));
    }
    return Iterable.map(elements, (treeElement) => {
      let node = this.nodes.get(treeElement.element);
      if (!node && this.identityProvider) {
        const id = this.identityProvider.getId(treeElement.element).toString();
        node = this.nodesByIdentity.get(id);
      }
      if (!node) {
        return Object.assign(Object.assign({}, treeElement), {children: this.preserveCollapseState(treeElement.children)});
      }
      const collapsible = typeof treeElement.collapsible === "boolean" ? treeElement.collapsible : node.collapsible;
      const collapsed = typeof treeElement.collapsed !== "undefined" ? treeElement.collapsed : node.collapsed;
      return Object.assign(Object.assign({}, treeElement), {
        collapsible,
        collapsed,
        children: this.preserveCollapseState(treeElement.children)
      });
    });
  }
  rerender(element) {
    const location = this.getElementLocation(element);
    this.model.rerender(location);
  }
  has(element) {
    return this.nodes.has(element);
  }
  getListIndex(element) {
    const location = this.getElementLocation(element);
    return this.model.getListIndex(location);
  }
  getListRenderCount(element) {
    const location = this.getElementLocation(element);
    return this.model.getListRenderCount(location);
  }
  isCollapsible(element) {
    const location = this.getElementLocation(element);
    return this.model.isCollapsible(location);
  }
  setCollapsible(element, collapsible) {
    const location = this.getElementLocation(element);
    return this.model.setCollapsible(location, collapsible);
  }
  isCollapsed(element) {
    const location = this.getElementLocation(element);
    return this.model.isCollapsed(location);
  }
  setCollapsed(element, collapsed, recursive) {
    const location = this.getElementLocation(element);
    return this.model.setCollapsed(location, collapsed, recursive);
  }
  expandTo(element) {
    const location = this.getElementLocation(element);
    this.model.expandTo(location);
  }
  refilter() {
    this.model.refilter();
  }
  getNode(element = null) {
    if (element === null) {
      return this.model.getNode(this.model.rootRef);
    }
    const node = this.nodes.get(element);
    if (!node) {
      throw new TreeError(this.user, `Tree element not found: ${element}`);
    }
    return node;
  }
  getNodeLocation(node) {
    return node.element;
  }
  getParentNodeLocation(element) {
    if (element === null) {
      throw new TreeError(this.user, `Invalid getParentNodeLocation call`);
    }
    const node = this.nodes.get(element);
    if (!node) {
      throw new TreeError(this.user, `Tree element not found: ${element}`);
    }
    const location = this.model.getNodeLocation(node);
    const parentLocation = this.model.getParentNodeLocation(location);
    const parent = this.model.getNode(parentLocation);
    return parent.element;
  }
  getElementLocation(element) {
    if (element === null) {
      return [];
    }
    const node = this.nodes.get(element);
    if (!node) {
      throw new TreeError(this.user, `Tree element not found: ${element}`);
    }
    return this.model.getNodeLocation(node);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/compressedObjectTreeModel.js
function noCompress(element) {
  const elements = [element.element];
  const incompressible = element.incompressible || false;
  return {
    element: {elements, incompressible},
    children: Iterable.map(Iterable.from(element.children), noCompress),
    collapsible: element.collapsible,
    collapsed: element.collapsed
  };
}
function compress(element) {
  const elements = [element.element];
  const incompressible = element.incompressible || false;
  let childrenIterator;
  let children;
  while (true) {
    [children, childrenIterator] = Iterable.consume(Iterable.from(element.children), 2);
    if (children.length !== 1) {
      break;
    }
    element = children[0];
    if (element.incompressible) {
      break;
    }
    elements.push(element.element);
  }
  return {
    element: {elements, incompressible},
    children: Iterable.map(Iterable.concat(children, childrenIterator), compress),
    collapsible: element.collapsible,
    collapsed: element.collapsed
  };
}
function _decompress(element, index = 0) {
  let children;
  if (index < element.element.elements.length - 1) {
    children = [_decompress(element, index + 1)];
  } else {
    children = Iterable.map(Iterable.from(element.children), (el) => _decompress(el, 0));
  }
  if (index === 0 && element.element.incompressible) {
    return {
      element: element.element.elements[index],
      children,
      incompressible: true,
      collapsible: element.collapsible,
      collapsed: element.collapsed
    };
  }
  return {
    element: element.element.elements[index],
    children,
    collapsible: element.collapsible,
    collapsed: element.collapsed
  };
}
function decompress(element) {
  return _decompress(element, 0);
}
function splice(treeElement, element, children) {
  if (treeElement.element === element) {
    return Object.assign(Object.assign({}, treeElement), {children});
  }
  return Object.assign(Object.assign({}, treeElement), {children: Iterable.map(Iterable.from(treeElement.children), (e) => splice(e, element, children))});
}
var CompressedObjectTreeModel = class {
  constructor(user, list, options = {}) {
    this.user = user;
    this.rootRef = null;
    this.nodes = new Map();
    this.model = new ObjectTreeModel(user, list, options);
    this.enabled = typeof options.compressionEnabled === "undefined" ? true : options.compressionEnabled;
  }
  get onDidSplice() {
    return this.model.onDidSplice;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get onDidChangeRenderNodeCount() {
    return this.model.onDidChangeRenderNodeCount;
  }
  setChildren(element, children = Iterable.empty()) {
    if (element === null) {
      const compressedChildren = Iterable.map(children, this.enabled ? compress : noCompress);
      this._setChildren(null, compressedChildren);
      return;
    }
    const compressedNode = this.nodes.get(element);
    if (!compressedNode) {
      throw new Error("Unknown compressed tree node");
    }
    const node = this.model.getNode(compressedNode);
    const compressedParentNode = this.model.getParentNodeLocation(compressedNode);
    const parent = this.model.getNode(compressedParentNode);
    const decompressedElement = decompress(node);
    const splicedElement = splice(decompressedElement, element, children);
    const recompressedElement = (this.enabled ? compress : noCompress)(splicedElement);
    const parentChildren = parent.children.map((child) => child === node ? recompressedElement : child);
    this._setChildren(parent.element, parentChildren);
  }
  setCompressionEnabled(enabled) {
    if (enabled === this.enabled) {
      return;
    }
    this.enabled = enabled;
    const root = this.model.getNode();
    const rootChildren = root.children;
    const decompressedRootChildren = Iterable.map(rootChildren, decompress);
    const recompressedRootChildren = Iterable.map(decompressedRootChildren, enabled ? compress : noCompress);
    this._setChildren(null, recompressedRootChildren);
  }
  _setChildren(node, children) {
    const insertedElements = new Set();
    const _onDidCreateNode = (node2) => {
      for (const element of node2.element.elements) {
        insertedElements.add(element);
        this.nodes.set(element, node2.element);
      }
    };
    const _onDidDeleteNode = (node2) => {
      for (const element of node2.element.elements) {
        if (!insertedElements.has(element)) {
          this.nodes.delete(element);
        }
      }
    };
    this.model.setChildren(node, children, _onDidCreateNode, _onDidDeleteNode);
  }
  has(element) {
    return this.nodes.has(element);
  }
  getListIndex(location) {
    const node = this.getCompressedNode(location);
    return this.model.getListIndex(node);
  }
  getListRenderCount(location) {
    const node = this.getCompressedNode(location);
    return this.model.getListRenderCount(node);
  }
  getNode(location) {
    if (typeof location === "undefined") {
      return this.model.getNode();
    }
    const node = this.getCompressedNode(location);
    return this.model.getNode(node);
  }
  getNodeLocation(node) {
    const compressedNode = this.model.getNodeLocation(node);
    if (compressedNode === null) {
      return null;
    }
    return compressedNode.elements[compressedNode.elements.length - 1];
  }
  getParentNodeLocation(location) {
    const compressedNode = this.getCompressedNode(location);
    const parentNode = this.model.getParentNodeLocation(compressedNode);
    if (parentNode === null) {
      return null;
    }
    return parentNode.elements[parentNode.elements.length - 1];
  }
  isCollapsible(location) {
    const compressedNode = this.getCompressedNode(location);
    return this.model.isCollapsible(compressedNode);
  }
  setCollapsible(location, collapsible) {
    const compressedNode = this.getCompressedNode(location);
    return this.model.setCollapsible(compressedNode, collapsible);
  }
  isCollapsed(location) {
    const compressedNode = this.getCompressedNode(location);
    return this.model.isCollapsed(compressedNode);
  }
  setCollapsed(location, collapsed, recursive) {
    const compressedNode = this.getCompressedNode(location);
    return this.model.setCollapsed(compressedNode, collapsed, recursive);
  }
  expandTo(location) {
    const compressedNode = this.getCompressedNode(location);
    this.model.expandTo(compressedNode);
  }
  rerender(location) {
    const compressedNode = this.getCompressedNode(location);
    this.model.rerender(compressedNode);
  }
  refilter() {
    this.model.refilter();
  }
  getCompressedNode(element) {
    if (element === null) {
      return null;
    }
    const node = this.nodes.get(element);
    if (!node) {
      throw new TreeError(this.user, `Tree element not found: ${element}`);
    }
    return node;
  }
};
var DefaultElementMapper = (elements) => elements[elements.length - 1];
var CompressedTreeNodeWrapper = class {
  constructor(unwrapper, node) {
    this.unwrapper = unwrapper;
    this.node = node;
  }
  get element() {
    return this.node.element === null ? null : this.unwrapper(this.node.element);
  }
  get children() {
    return this.node.children.map((node) => new CompressedTreeNodeWrapper(this.unwrapper, node));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
};
function mapList(nodeMapper, list) {
  return {
    splice(start, deleteCount, toInsert) {
      list.splice(start, deleteCount, toInsert.map((node) => nodeMapper.map(node)));
    },
    updateElementHeight(index, height) {
      list.updateElementHeight(index, height);
    }
  };
}
function mapOptions(compressedNodeUnwrapper, options) {
  return Object.assign(Object.assign({}, options), {sorter: options.sorter && {
    compare(node, otherNode) {
      return options.sorter.compare(node.elements[0], otherNode.elements[0]);
    }
  }, identityProvider: options.identityProvider && {
    getId(node) {
      return options.identityProvider.getId(compressedNodeUnwrapper(node));
    }
  }, filter: options.filter && {
    filter(node, parentVisibility) {
      return options.filter.filter(compressedNodeUnwrapper(node), parentVisibility);
    }
  }});
}
var CompressibleObjectTreeModel = class {
  constructor(user, list, options = {}) {
    this.rootRef = null;
    this.elementMapper = options.elementMapper || DefaultElementMapper;
    const compressedNodeUnwrapper = (node) => this.elementMapper(node.elements);
    this.nodeMapper = new WeakMapper((node) => new CompressedTreeNodeWrapper(compressedNodeUnwrapper, node));
    this.model = new CompressedObjectTreeModel(user, mapList(this.nodeMapper, list), mapOptions(compressedNodeUnwrapper, options));
  }
  get onDidSplice() {
    return Event.map(this.model.onDidSplice, ({insertedNodes, deletedNodes}) => ({
      insertedNodes: insertedNodes.map((node) => this.nodeMapper.map(node)),
      deletedNodes: deletedNodes.map((node) => this.nodeMapper.map(node))
    }));
  }
  get onDidChangeCollapseState() {
    return Event.map(this.model.onDidChangeCollapseState, ({node, deep}) => ({
      node: this.nodeMapper.map(node),
      deep
    }));
  }
  get onDidChangeRenderNodeCount() {
    return Event.map(this.model.onDidChangeRenderNodeCount, (node) => this.nodeMapper.map(node));
  }
  setChildren(element, children = Iterable.empty()) {
    this.model.setChildren(element, children);
  }
  setCompressionEnabled(enabled) {
    this.model.setCompressionEnabled(enabled);
  }
  has(location) {
    return this.model.has(location);
  }
  getListIndex(location) {
    return this.model.getListIndex(location);
  }
  getListRenderCount(location) {
    return this.model.getListRenderCount(location);
  }
  getNode(location) {
    return this.nodeMapper.map(this.model.getNode(location));
  }
  getNodeLocation(node) {
    return node.element;
  }
  getParentNodeLocation(location) {
    return this.model.getParentNodeLocation(location);
  }
  isCollapsible(location) {
    return this.model.isCollapsible(location);
  }
  setCollapsible(location, collapsed) {
    return this.model.setCollapsible(location, collapsed);
  }
  isCollapsed(location) {
    return this.model.isCollapsed(location);
  }
  setCollapsed(location, collapsed, recursive) {
    return this.model.setCollapsed(location, collapsed, recursive);
  }
  expandTo(location) {
    return this.model.expandTo(location);
  }
  rerender(location) {
    return this.model.rerender(location);
  }
  refilter() {
    return this.model.refilter();
  }
  getCompressedTreeNode(location = null) {
    return this.model.getNode(location);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/objectTree.js
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ObjectTree = class extends AbstractTree {
  constructor(user, container, delegate, renderers, options = {}) {
    super(user, container, delegate, renderers, options);
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  setChildren(element, children = Iterable.empty()) {
    this.model.setChildren(element, children);
  }
  rerender(element) {
    if (element === void 0) {
      this.view.rerender();
      return;
    }
    this.model.rerender(element);
  }
  hasElement(element) {
    return this.model.has(element);
  }
  createModel(user, view, options) {
    return new ObjectTreeModel(user, view, options);
  }
};
var CompressibleRenderer = class {
  constructor(_compressedTreeNodeProvider, renderer) {
    this._compressedTreeNodeProvider = _compressedTreeNodeProvider;
    this.renderer = renderer;
    this.templateId = renderer.templateId;
    if (renderer.onDidChangeTwistieState) {
      this.onDidChangeTwistieState = renderer.onDidChangeTwistieState;
    }
  }
  get compressedTreeNodeProvider() {
    return this._compressedTreeNodeProvider();
  }
  renderTemplate(container) {
    const data = this.renderer.renderTemplate(container);
    return {compressedTreeNode: void 0, data};
  }
  renderElement(node, index, templateData, height) {
    const compressedTreeNode = this.compressedTreeNodeProvider.getCompressedTreeNode(node.element);
    if (compressedTreeNode.element.elements.length === 1) {
      templateData.compressedTreeNode = void 0;
      this.renderer.renderElement(node, index, templateData.data, height);
    } else {
      templateData.compressedTreeNode = compressedTreeNode;
      this.renderer.renderCompressedElements(compressedTreeNode, index, templateData.data, height);
    }
  }
  disposeElement(node, index, templateData, height) {
    if (templateData.compressedTreeNode) {
      if (this.renderer.disposeCompressedElements) {
        this.renderer.disposeCompressedElements(templateData.compressedTreeNode, index, templateData.data, height);
      }
    } else {
      if (this.renderer.disposeElement) {
        this.renderer.disposeElement(node, index, templateData.data, height);
      }
    }
  }
  disposeTemplate(templateData) {
    this.renderer.disposeTemplate(templateData.data);
  }
  renderTwistie(element, twistieElement) {
    if (this.renderer.renderTwistie) {
      this.renderer.renderTwistie(element, twistieElement);
    }
  }
};
__decorate16([
  memoize
], CompressibleRenderer.prototype, "compressedTreeNodeProvider", null);
function asObjectTreeOptions(compressedTreeNodeProvider, options) {
  return options && Object.assign(Object.assign({}, options), {keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {
    getKeyboardNavigationLabel(e) {
      let compressedTreeNode;
      try {
        compressedTreeNode = compressedTreeNodeProvider().getCompressedTreeNode(e);
      } catch (_a) {
        return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e);
      }
      if (compressedTreeNode.element.elements.length === 1) {
        return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e);
      } else {
        return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(compressedTreeNode.element.elements);
      }
    }
  }});
}
var CompressibleObjectTree = class extends ObjectTree {
  constructor(user, container, delegate, renderers, options = {}) {
    const compressedTreeNodeProvider = () => this;
    const compressibleRenderers = renderers.map((r) => new CompressibleRenderer(compressedTreeNodeProvider, r));
    super(user, container, delegate, compressibleRenderers, asObjectTreeOptions(compressedTreeNodeProvider, options));
  }
  setChildren(element, children = Iterable.empty()) {
    this.model.setChildren(element, children);
  }
  createModel(user, view, options) {
    return new CompressibleObjectTreeModel(user, view, options);
  }
  updateOptions(optionsUpdate = {}) {
    super.updateOptions(optionsUpdate);
    if (typeof optionsUpdate.compressionEnabled !== "undefined") {
      this.model.setCompressionEnabled(optionsUpdate.compressionEnabled);
    }
  }
  getCompressedTreeNode(element = null) {
    return this.model.getCompressedTreeNode(element);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/asyncDataTree.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function createAsyncDataTreeNode(props) {
  return Object.assign(Object.assign({}, props), {children: [], refreshPromise: void 0, stale: true, slow: false, collapsedByDefault: void 0});
}
function isAncestor2(ancestor, descendant) {
  if (!descendant.parent) {
    return false;
  } else if (descendant.parent === ancestor) {
    return true;
  } else {
    return isAncestor2(ancestor, descendant.parent);
  }
}
function intersects(node, other) {
  return node === other || isAncestor2(node, other) || isAncestor2(other, node);
}
var AsyncDataTreeNodeWrapper = class {
  constructor(node) {
    this.node = node;
  }
  get element() {
    return this.node.element.element;
  }
  get children() {
    return this.node.children.map((node) => new AsyncDataTreeNodeWrapper(node));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
};
var AsyncDataTreeRenderer = class {
  constructor(renderer, nodeMapper, onDidChangeTwistieState) {
    this.renderer = renderer;
    this.nodeMapper = nodeMapper;
    this.onDidChangeTwistieState = onDidChangeTwistieState;
    this.renderedNodes = new Map();
    this.templateId = renderer.templateId;
  }
  renderTemplate(container) {
    const templateData = this.renderer.renderTemplate(container);
    return {templateData};
  }
  renderElement(node, index, templateData, height) {
    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);
  }
  renderTwistie(element, twistieElement) {
    if (element.slow) {
      addClasses(twistieElement, treeItemLoadingIcon.classNames);
    } else {
      removeClasses(twistieElement, treeItemLoadingIcon.classNames);
    }
    return false;
  }
  disposeElement(node, index, templateData, height) {
    if (this.renderer.disposeElement) {
      this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);
    }
  }
  disposeTemplate(templateData) {
    this.renderer.disposeTemplate(templateData.templateData);
  }
  dispose() {
    this.renderedNodes.clear();
  }
};
function asTreeEvent(e) {
  return {
    browserEvent: e.browserEvent,
    elements: e.elements.map((e2) => e2.element)
  };
}
function asTreeMouseEvent2(e) {
  return {
    browserEvent: e.browserEvent,
    element: e.element && e.element.element,
    target: e.target
  };
}
var AsyncDataTreeElementsDragAndDropData = class extends ElementsDragAndDropData {
  constructor(data) {
    super(data.elements.map((node) => node.element));
    this.data = data;
  }
};
function asAsyncDataTreeDragAndDropData(data) {
  if (data instanceof ElementsDragAndDropData) {
    return new AsyncDataTreeElementsDragAndDropData(data);
  }
  return data;
}
var AsyncDataTreeNodeListDragAndDrop = class {
  constructor(dnd) {
    this.dnd = dnd;
  }
  getDragURI(node) {
    return this.dnd.getDragURI(node.element);
  }
  getDragLabel(nodes, originalEvent) {
    if (this.dnd.getDragLabel) {
      return this.dnd.getDragLabel(nodes.map((node) => node.element), originalEvent);
    }
    return void 0;
  }
  onDragStart(data, originalEvent) {
    if (this.dnd.onDragStart) {
      this.dnd.onDragStart(asAsyncDataTreeDragAndDropData(data), originalEvent);
    }
  }
  onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {
    return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
  }
  drop(data, targetNode, targetIndex, originalEvent) {
    this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
  }
  onDragEnd(originalEvent) {
    if (this.dnd.onDragEnd) {
      this.dnd.onDragEnd(originalEvent);
    }
  }
};
function asObjectTreeOptions2(options) {
  return options && Object.assign(Object.assign({}, options), {collapseByDefault: true, identityProvider: options.identityProvider && {
    getId(el) {
      return options.identityProvider.getId(el.element);
    }
  }, dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd), multipleSelectionController: options.multipleSelectionController && {
    isSelectionSingleChangeEvent(e) {
      return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), {element: e.element}));
    },
    isSelectionRangeChangeEvent(e) {
      return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), {element: e.element}));
    }
  }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), {
    getPosInSet: void 0,
    getSetSize: void 0,
    getRole: options.accessibilityProvider.getRole ? (el) => {
      return options.accessibilityProvider.getRole(el.element);
    } : () => "treeitem",
    isChecked: options.accessibilityProvider.isChecked ? (e) => {
      var _a;
      return !!((_a = options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.isChecked(e.element));
    } : void 0,
    getAriaLabel(e) {
      return options.accessibilityProvider.getAriaLabel(e.element);
    },
    getWidgetAriaLabel() {
      return options.accessibilityProvider.getWidgetAriaLabel();
    },
    getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => "tree",
    getAriaLevel: options.accessibilityProvider.getAriaLevel && ((node) => {
      return options.accessibilityProvider.getAriaLevel(node.element);
    }),
    getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && ((node) => {
      return options.accessibilityProvider.getActiveDescendantId(node.element);
    })
  }), filter: options.filter && {
    filter(e, parentVisibility) {
      return options.filter.filter(e.element, parentVisibility);
    }
  }, keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), {getKeyboardNavigationLabel(e) {
    return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
  }}), sorter: void 0, expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === "undefined" ? void 0 : typeof options.expandOnlyOnTwistieClick !== "function" ? options.expandOnlyOnTwistieClick : (e) => options.expandOnlyOnTwistieClick(e.element), additionalScrollHeight: options.additionalScrollHeight});
}
function dfs2(node, fn) {
  fn(node);
  node.children.forEach((child) => dfs2(child, fn));
}
var AsyncDataTree = class {
  constructor(user, container, delegate, renderers, dataSource, options = {}) {
    this.user = user;
    this.dataSource = dataSource;
    this.nodes = new Map();
    this.subTreeRefreshPromises = new Map();
    this.refreshPromises = new Map();
    this._onDidRender = new Emitter();
    this._onDidChangeNodeSlowState = new Emitter();
    this.nodeMapper = new WeakMapper((node) => new AsyncDataTreeNodeWrapper(node));
    this.disposables = new DisposableStore();
    this.identityProvider = options.identityProvider;
    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === "undefined" ? false : options.autoExpandSingleChildren;
    this.sorter = options.sorter;
    this.collapseByDefault = options.collapseByDefault;
    this.tree = this.createTree(user, container, delegate, renderers, options);
    this.root = createAsyncDataTreeNode({
      element: void 0,
      parent: null,
      hasChildren: true
    });
    if (this.identityProvider) {
      this.root = Object.assign(Object.assign({}, this.root), {id: null});
    }
    this.nodes.set(null, this.root);
    this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
  }
  get onDidChangeFocus() {
    return Event.map(this.tree.onDidChangeFocus, asTreeEvent);
  }
  get onDidChangeSelection() {
    return Event.map(this.tree.onDidChangeSelection, asTreeEvent);
  }
  get onMouseDblClick() {
    return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent2);
  }
  get onPointer() {
    return Event.map(this.tree.onPointer, asTreeMouseEvent2);
  }
  get onDidFocus() {
    return this.tree.onDidFocus;
  }
  get onDidDispose() {
    return this.tree.onDidDispose;
  }
  createTree(user, container, delegate, renderers, options) {
    const objectTreeDelegate = new ComposedTreeDelegate(delegate);
    const objectTreeRenderers = renderers.map((r) => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));
    const objectTreeOptions = asObjectTreeOptions2(options) || {};
    return new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);
  }
  updateOptions(options = {}) {
    this.tree.updateOptions(options);
  }
  getHTMLElement() {
    return this.tree.getHTMLElement();
  }
  get scrollTop() {
    return this.tree.scrollTop;
  }
  set scrollTop(scrollTop) {
    this.tree.scrollTop = scrollTop;
  }
  domFocus() {
    this.tree.domFocus();
  }
  layout(height, width) {
    this.tree.layout(height, width);
  }
  style(styles) {
    this.tree.style(styles);
  }
  getInput() {
    return this.root.element;
  }
  setInput(input, viewState) {
    return __awaiter8(this, void 0, void 0, function* () {
      this.refreshPromises.forEach((promise) => promise.cancel());
      this.refreshPromises.clear();
      this.root.element = input;
      const viewStateContext = viewState && {viewState, focus: [], selection: []};
      yield this._updateChildren(input, true, false, viewStateContext);
      if (viewStateContext) {
        this.tree.setFocus(viewStateContext.focus);
        this.tree.setSelection(viewStateContext.selection);
      }
      if (viewState && typeof viewState.scrollTop === "number") {
        this.scrollTop = viewState.scrollTop;
      }
    });
  }
  _updateChildren(element = this.root.element, recursive = true, rerender = false, viewStateContext) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (typeof this.root.element === "undefined") {
        throw new TreeError(this.user, "Tree input not set");
      }
      if (this.root.refreshPromise) {
        yield this.root.refreshPromise;
        yield Event.toPromise(this._onDidRender.event);
      }
      const node = this.getDataNode(element);
      yield this.refreshAndRenderNode(node, recursive, viewStateContext);
      if (rerender) {
        try {
          this.tree.rerender(node);
        } catch (_a) {
        }
      }
    });
  }
  rerender(element) {
    if (element === void 0 || element === this.root.element) {
      this.tree.rerender();
      return;
    }
    const node = this.getDataNode(element);
    this.tree.rerender(node);
  }
  collapse(element, recursive = false) {
    const node = this.getDataNode(element);
    return this.tree.collapse(node === this.root ? null : node, recursive);
  }
  expand(element, recursive = false) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (typeof this.root.element === "undefined") {
        throw new TreeError(this.user, "Tree input not set");
      }
      if (this.root.refreshPromise) {
        yield this.root.refreshPromise;
        yield Event.toPromise(this._onDidRender.event);
      }
      const node = this.getDataNode(element);
      if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {
        return false;
      }
      if (node.refreshPromise) {
        yield this.root.refreshPromise;
        yield Event.toPromise(this._onDidRender.event);
      }
      if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {
        return false;
      }
      const result = this.tree.expand(node === this.root ? null : node, recursive);
      if (node.refreshPromise) {
        yield this.root.refreshPromise;
        yield Event.toPromise(this._onDidRender.event);
      }
      return result;
    });
  }
  setSelection(elements, browserEvent) {
    const nodes = elements.map((e) => this.getDataNode(e));
    this.tree.setSelection(nodes, browserEvent);
  }
  getSelection() {
    const nodes = this.tree.getSelection();
    return nodes.map((n) => n.element);
  }
  setFocus(elements, browserEvent) {
    const nodes = elements.map((e) => this.getDataNode(e));
    this.tree.setFocus(nodes, browserEvent);
  }
  getFocus() {
    const nodes = this.tree.getFocus();
    return nodes.map((n) => n.element);
  }
  reveal(element, relativeTop) {
    this.tree.reveal(this.getDataNode(element), relativeTop);
  }
  getDataNode(element) {
    const node = this.nodes.get(element === this.root.element ? null : element);
    if (!node) {
      throw new TreeError(this.user, `Data tree node not found: ${element}`);
    }
    return node;
  }
  refreshAndRenderNode(node, recursive, viewStateContext) {
    return __awaiter8(this, void 0, void 0, function* () {
      yield this.refreshNode(node, recursive, viewStateContext);
      this.render(node, viewStateContext);
    });
  }
  refreshNode(node, recursive, viewStateContext) {
    return __awaiter8(this, void 0, void 0, function* () {
      let result;
      this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {
        if (!result && intersects(refreshNode, node)) {
          result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));
        }
      });
      if (result) {
        return result;
      }
      return this.doRefreshSubTree(node, recursive, viewStateContext);
    });
  }
  doRefreshSubTree(node, recursive, viewStateContext) {
    return __awaiter8(this, void 0, void 0, function* () {
      let done;
      node.refreshPromise = new Promise((c) => done = c);
      this.subTreeRefreshPromises.set(node, node.refreshPromise);
      node.refreshPromise.finally(() => {
        node.refreshPromise = void 0;
        this.subTreeRefreshPromises.delete(node);
      });
      try {
        const childrenToRefresh = yield this.doRefreshNode(node, recursive, viewStateContext);
        node.stale = false;
        yield Promise.all(childrenToRefresh.map((child) => this.doRefreshSubTree(child, recursive, viewStateContext)));
      } finally {
        done();
      }
    });
  }
  doRefreshNode(node, recursive, viewStateContext) {
    return __awaiter8(this, void 0, void 0, function* () {
      node.hasChildren = !!this.dataSource.hasChildren(node.element);
      let childrenPromise;
      if (!node.hasChildren) {
        childrenPromise = Promise.resolve(Iterable.empty());
      } else {
        const slowTimeout = timeout(800);
        slowTimeout.then(() => {
          node.slow = true;
          this._onDidChangeNodeSlowState.fire(node);
        }, (_) => null);
        childrenPromise = this.doGetChildren(node).finally(() => slowTimeout.cancel());
      }
      try {
        const children = yield childrenPromise;
        return this.setChildren(node, children, recursive, viewStateContext);
      } catch (err) {
        if (node !== this.root) {
          this.tree.collapse(node === this.root ? null : node);
        }
        if (isPromiseCanceledError(err)) {
          return [];
        }
        throw err;
      } finally {
        if (node.slow) {
          node.slow = false;
          this._onDidChangeNodeSlowState.fire(node);
        }
      }
    });
  }
  doGetChildren(node) {
    let result = this.refreshPromises.get(node);
    if (result) {
      return result;
    }
    result = createCancelablePromise(() => __awaiter8(this, void 0, void 0, function* () {
      const children = yield this.dataSource.getChildren(node.element);
      return this.processChildren(children);
    }));
    this.refreshPromises.set(node, result);
    return result.finally(() => {
      this.refreshPromises.delete(node);
    });
  }
  _onDidChangeCollapseState({node, deep}) {
    if (node.element === null) {
      return;
    }
    if (!node.collapsed && node.element.stale) {
      if (deep) {
        this.collapse(node.element.element);
      } else {
        this.refreshAndRenderNode(node.element, false).catch(onUnexpectedError);
      }
    }
  }
  setChildren(node, childrenElementsIterable, recursive, viewStateContext) {
    const childrenElements = [...childrenElementsIterable];
    if (node.children.length === 0 && childrenElements.length === 0) {
      return [];
    }
    const nodesToForget = new Map();
    const childrenTreeNodesById = new Map();
    for (const child of node.children) {
      nodesToForget.set(child.element, child);
      if (this.identityProvider) {
        const collapsed = this.tree.isCollapsed(child);
        childrenTreeNodesById.set(child.id, {node: child, collapsed});
      }
    }
    const childrenToRefresh = [];
    const children = childrenElements.map((element) => {
      const hasChildren = !!this.dataSource.hasChildren(element);
      if (!this.identityProvider) {
        const asyncDataTreeNode = createAsyncDataTreeNode({element, parent: node, hasChildren});
        if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {
          asyncDataTreeNode.collapsedByDefault = false;
          childrenToRefresh.push(asyncDataTreeNode);
        }
        return asyncDataTreeNode;
      }
      const id = this.identityProvider.getId(element).toString();
      const result = childrenTreeNodesById.get(id);
      if (result) {
        const asyncDataTreeNode = result.node;
        nodesToForget.delete(asyncDataTreeNode.element);
        this.nodes.delete(asyncDataTreeNode.element);
        this.nodes.set(element, asyncDataTreeNode);
        asyncDataTreeNode.element = element;
        asyncDataTreeNode.hasChildren = hasChildren;
        if (recursive) {
          if (result.collapsed) {
            asyncDataTreeNode.children.forEach((node2) => dfs2(node2, (node3) => this.nodes.delete(node3.element)));
            asyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);
            asyncDataTreeNode.stale = true;
          } else {
            childrenToRefresh.push(asyncDataTreeNode);
          }
        } else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {
          asyncDataTreeNode.collapsedByDefault = false;
          childrenToRefresh.push(asyncDataTreeNode);
        }
        return asyncDataTreeNode;
      }
      const childAsyncDataTreeNode = createAsyncDataTreeNode({element, parent: node, id, hasChildren});
      if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {
        viewStateContext.focus.push(childAsyncDataTreeNode);
      }
      if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {
        viewStateContext.selection.push(childAsyncDataTreeNode);
      }
      if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {
        childrenToRefresh.push(childAsyncDataTreeNode);
      } else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {
        childAsyncDataTreeNode.collapsedByDefault = false;
        childrenToRefresh.push(childAsyncDataTreeNode);
      }
      return childAsyncDataTreeNode;
    });
    for (const node2 of nodesToForget.values()) {
      dfs2(node2, (node3) => this.nodes.delete(node3.element));
    }
    for (const child of children) {
      this.nodes.set(child.element, child);
    }
    node.children.splice(0, node.children.length, ...children);
    if (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {
      children[0].collapsedByDefault = false;
      childrenToRefresh.push(children[0]);
    }
    return childrenToRefresh;
  }
  render(node, viewStateContext) {
    const children = node.children.map((node2) => this.asTreeElement(node2, viewStateContext));
    this.tree.setChildren(node === this.root ? null : node, children);
    if (node !== this.root) {
      this.tree.setCollapsible(node, node.hasChildren);
    }
    this._onDidRender.fire();
  }
  asTreeElement(node, viewStateContext) {
    if (node.stale) {
      return {
        element: node,
        collapsible: node.hasChildren,
        collapsed: true
      };
    }
    let collapsed;
    if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {
      collapsed = false;
    } else {
      collapsed = node.collapsedByDefault;
    }
    node.collapsedByDefault = void 0;
    return {
      element: node,
      children: node.hasChildren ? Iterable.map(node.children, (child) => this.asTreeElement(child, viewStateContext)) : [],
      collapsible: node.hasChildren,
      collapsed
    };
  }
  processChildren(children) {
    if (this.sorter) {
      children = [...children].sort(this.sorter.compare.bind(this.sorter));
    }
    return children;
  }
  dispose() {
    this.disposables.dispose();
  }
};
var CompressibleAsyncDataTreeNodeWrapper = class {
  constructor(node) {
    this.node = node;
  }
  get element() {
    return {
      elements: this.node.element.elements.map((e) => e.element),
      incompressible: this.node.element.incompressible
    };
  }
  get children() {
    return this.node.children.map((node) => new CompressibleAsyncDataTreeNodeWrapper(node));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
};
var CompressibleAsyncDataTreeRenderer = class {
  constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {
    this.renderer = renderer;
    this.nodeMapper = nodeMapper;
    this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;
    this.onDidChangeTwistieState = onDidChangeTwistieState;
    this.renderedNodes = new Map();
    this.disposables = [];
    this.templateId = renderer.templateId;
  }
  renderTemplate(container) {
    const templateData = this.renderer.renderTemplate(container);
    return {templateData};
  }
  renderElement(node, index, templateData, height) {
    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);
  }
  renderCompressedElements(node, index, templateData, height) {
    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);
  }
  renderTwistie(element, twistieElement) {
    if (element.slow) {
      addClasses(twistieElement, treeItemLoadingIcon.classNames);
    } else {
      removeClasses(twistieElement, treeItemLoadingIcon.classNames);
    }
    return false;
  }
  disposeElement(node, index, templateData, height) {
    if (this.renderer.disposeElement) {
      this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);
    }
  }
  disposeCompressedElements(node, index, templateData, height) {
    if (this.renderer.disposeCompressedElements) {
      this.renderer.disposeCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);
    }
  }
  disposeTemplate(templateData) {
    this.renderer.disposeTemplate(templateData.templateData);
  }
  dispose() {
    this.renderedNodes.clear();
    this.disposables = dispose(this.disposables);
  }
};
function asCompressibleObjectTreeOptions(options) {
  const objectTreeOptions = options && asObjectTreeOptions2(options);
  return objectTreeOptions && Object.assign(Object.assign({}, objectTreeOptions), {keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, objectTreeOptions.keyboardNavigationLabelProvider), {getCompressedNodeKeyboardNavigationLabel(els) {
    return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map((e) => e.element));
  }})});
}
var CompressibleAsyncDataTree = class extends AsyncDataTree {
  constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options = {}) {
    super(user, container, virtualDelegate, renderers, dataSource, options);
    this.compressionDelegate = compressionDelegate;
    this.compressibleNodeMapper = new WeakMapper((node) => new CompressibleAsyncDataTreeNodeWrapper(node));
    this.filter = options.filter;
  }
  createTree(user, container, delegate, renderers, options) {
    const objectTreeDelegate = new ComposedTreeDelegate(delegate);
    const objectTreeRenderers = renderers.map((r) => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));
    const objectTreeOptions = asCompressibleObjectTreeOptions(options) || {};
    return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);
  }
  asTreeElement(node, viewStateContext) {
    return Object.assign({incompressible: this.compressionDelegate.isIncompressible(node.element)}, super.asTreeElement(node, viewStateContext));
  }
  updateOptions(options = {}) {
    this.tree.updateOptions(options);
  }
  render(node, viewStateContext) {
    if (!this.identityProvider) {
      return super.render(node, viewStateContext);
    }
    const getId = (element) => this.identityProvider.getId(element).toString();
    const getUncompressedIds = (nodes) => {
      const result = new Set();
      for (const node2 of nodes) {
        const compressedNode = this.tree.getCompressedTreeNode(node2 === this.root ? null : node2);
        if (!compressedNode.element) {
          continue;
        }
        for (const node3 of compressedNode.element.elements) {
          result.add(getId(node3.element));
        }
      }
      return result;
    };
    const oldSelection = getUncompressedIds(this.tree.getSelection());
    const oldFocus = getUncompressedIds(this.tree.getFocus());
    super.render(node, viewStateContext);
    const selection = this.getSelection();
    let didChangeSelection = false;
    const focus = this.getFocus();
    let didChangeFocus = false;
    const visit = (node2) => {
      const compressedNode = node2.element;
      if (compressedNode) {
        for (let i = 0; i < compressedNode.elements.length; i++) {
          const id = getId(compressedNode.elements[i].element);
          const element = compressedNode.elements[compressedNode.elements.length - 1].element;
          if (oldSelection.has(id) && selection.indexOf(element) === -1) {
            selection.push(element);
            didChangeSelection = true;
          }
          if (oldFocus.has(id) && focus.indexOf(element) === -1) {
            focus.push(element);
            didChangeFocus = true;
          }
        }
      }
      node2.children.forEach(visit);
    };
    visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));
    if (didChangeSelection) {
      this.setSelection(selection);
    }
    if (didChangeFocus) {
      this.setFocus(focus);
    }
  }
  processChildren(children) {
    if (this.filter) {
      children = Iterable.filter(children, (e) => {
        const result = this.filter.filter(e, 1);
        const visibility = getVisibility(result);
        if (visibility === 2) {
          throw new Error("Recursive tree visibility not supported in async data compressed trees");
        }
        return visibility === 1;
      });
    }
    return super.processChildren(children);
  }
};
function getVisibility(filterResult) {
  if (typeof filterResult === "boolean") {
    return filterResult ? 1 : 0;
  } else if (isFilterResult(filterResult)) {
    return getVisibleState(filterResult.visibility);
  } else {
    return getVisibleState(filterResult);
  }
}

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/dataTree.js
var DataTree = class extends AbstractTree {
  constructor(user, container, delegate, renderers, dataSource, options = {}) {
    super(user, container, delegate, renderers, options);
    this.user = user;
    this.dataSource = dataSource;
    this.identityProvider = options.identityProvider;
  }
  createModel(user, view, options) {
    return new ObjectTreeModel(user, view, options);
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/list/browser/listService.js
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param13 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var IListService = createDecorator("listService");
var ListService = class ListService2 {
  constructor(_themeService) {
    this._themeService = _themeService;
    this.disposables = new DisposableStore();
    this.lists = [];
    this._lastFocusedWidget = void 0;
    this._hasCreatedStyleController = false;
  }
  get lastFocusedList() {
    return this._lastFocusedWidget;
  }
  register(widget, extraContextKeys) {
    if (!this._hasCreatedStyleController) {
      this._hasCreatedStyleController = true;
      const styleController = new DefaultStyleController(createStyleSheet(), "");
      this.disposables.add(attachListStyler(styleController, this._themeService));
    }
    if (this.lists.some((l) => l.widget === widget)) {
      throw new Error("Cannot register the same widget multiple times");
    }
    const registeredList = {widget, extraContextKeys};
    this.lists.push(registeredList);
    if (widget.getHTMLElement() === document.activeElement) {
      this._lastFocusedWidget = widget;
    }
    return combinedDisposable(widget.onDidFocus(() => this._lastFocusedWidget = widget), toDisposable(() => this.lists.splice(this.lists.indexOf(registeredList), 1)), widget.onDidDispose(() => {
      this.lists = this.lists.filter((l) => l !== registeredList);
      if (this._lastFocusedWidget === widget) {
        this._lastFocusedWidget = void 0;
      }
    }));
  }
  dispose() {
    this.disposables.dispose();
  }
};
ListService = __decorate17([
  __param13(0, IThemeService)
], ListService);
var RawWorkbenchListFocusContextKey = new RawContextKey("listFocus", true);
var WorkbenchListSupportsMultiSelectContextKey = new RawContextKey("listSupportsMultiselect", true);
var WorkbenchListFocusContextKey = ContextKeyExpr.and(RawWorkbenchListFocusContextKey, ContextKeyExpr.not(InputFocusedContextKey));
var WorkbenchListHasSelectionOrFocus = new RawContextKey("listHasSelectionOrFocus", false);
var WorkbenchListDoubleSelection = new RawContextKey("listDoubleSelection", false);
var WorkbenchListMultiSelection = new RawContextKey("listMultiSelection", false);
var WorkbenchListSupportsKeyboardNavigation = new RawContextKey("listSupportsKeyboardNavigation", true);
var WorkbenchListAutomaticKeyboardNavigationKey = "listAutomaticKeyboardNavigation";
var WorkbenchListAutomaticKeyboardNavigation = new RawContextKey(WorkbenchListAutomaticKeyboardNavigationKey, true);
var didBindWorkbenchListAutomaticKeyboardNavigation = false;
function createScopedContextKeyService(contextKeyService, widget) {
  const result = contextKeyService.createScoped(widget.getHTMLElement());
  RawWorkbenchListFocusContextKey.bindTo(result);
  return result;
}
var multiSelectModifierSettingKey = "workbench.list.multiSelectModifier";
var openModeSettingKey = "workbench.list.openMode";
var horizontalScrollingKey = "workbench.list.horizontalScrolling";
var keyboardNavigationSettingKey = "workbench.list.keyboardNavigation";
var automaticKeyboardNavigationSettingKey = "workbench.list.automaticKeyboardNavigation";
var treeIndentKey = "workbench.tree.indent";
var treeRenderIndentGuidesKey = "workbench.tree.renderIndentGuides";
var listSmoothScrolling = "workbench.list.smoothScrolling";
function useAltAsMultipleSelectionModifier(configurationService) {
  return configurationService.getValue(multiSelectModifierSettingKey) === "alt";
}
var MultipleSelectionController = class extends Disposable {
  constructor(configurationService) {
    super();
    this.configurationService = configurationService;
    this.useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this.useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(this.configurationService);
      }
    }));
  }
  isSelectionSingleChangeEvent(event) {
    if (this.useAltAsMultipleSelectionModifier) {
      return event.browserEvent.altKey;
    }
    return isSelectionSingleChangeEvent(event);
  }
  isSelectionRangeChangeEvent(event) {
    return isSelectionRangeChangeEvent(event);
  }
};
function toWorkbenchListOptions(options, configurationService, keybindingService) {
  const disposables = new DisposableStore();
  const result = Object.assign({}, options);
  if (options.multipleSelectionSupport !== false && !options.multipleSelectionController) {
    const multipleSelectionController = new MultipleSelectionController(configurationService);
    result.multipleSelectionController = multipleSelectionController;
    disposables.add(multipleSelectionController);
  }
  result.keyboardNavigationDelegate = {
    mightProducePrintableCharacter(e) {
      return keybindingService.mightProducePrintableCharacter(e);
    }
  };
  result.smoothScrolling = configurationService.getValue(listSmoothScrolling);
  return [result, disposables];
}
var WorkbenchList = class WorkbenchList2 extends List {
  constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService) {
    const horizontalScrolling = typeof options.horizontalScrolling !== "undefined" ? options.horizontalScrolling : configurationService.getValue(horizontalScrollingKey);
    const [workbenchListOptions, workbenchListOptionsDisposable] = toWorkbenchListOptions(options, configurationService, keybindingService);
    super(user, container, delegate, renderers, Object.assign(Object.assign(Object.assign({keyboardSupport: false}, computeStyles(themeService.getColorTheme(), defaultListStyles)), workbenchListOptions), {horizontalScrolling}));
    this.disposables.add(workbenchListOptionsDisposable);
    this.contextKeyService = createScopedContextKeyService(contextKeyService, this);
    this.themeService = themeService;
    const listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);
    listSupportsMultiSelect.set(!(options.multipleSelectionSupport === false));
    this.listHasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);
    this.listDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);
    this.listMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);
    this.horizontalScrolling = options.horizontalScrolling;
    this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    this.disposables.add(this.contextKeyService);
    this.disposables.add(listService.register(this));
    if (options.overrideStyles) {
      this.updateStyles(options.overrideStyles);
    }
    this.disposables.add(this.onDidChangeSelection(() => {
      const selection = this.getSelection();
      const focus = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
        this.listMultiSelection.set(selection.length > 1);
        this.listDoubleSelection.set(selection.length === 2);
      });
    }));
    this.disposables.add(this.onDidChangeFocus(() => {
      const selection = this.getSelection();
      const focus = this.getFocus();
      this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
    }));
    this.disposables.add(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
      }
      let options2 = {};
      if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === void 0) {
        const horizontalScrolling2 = configurationService.getValue(horizontalScrollingKey);
        options2 = Object.assign(Object.assign({}, options2), {horizontalScrolling: horizontalScrolling2});
      }
      if (e.affectsConfiguration(listSmoothScrolling)) {
        const smoothScrolling = configurationService.getValue(listSmoothScrolling);
        options2 = Object.assign(Object.assign({}, options2), {smoothScrolling});
      }
      if (Object.keys(options2).length > 0) {
        this.updateOptions(options2);
      }
    }));
  }
  updateOptions(options) {
    super.updateOptions(options);
    if (options.overrideStyles) {
      this.updateStyles(options.overrideStyles);
    }
  }
  dispose() {
    super.dispose();
    if (this._styler) {
      this._styler.dispose();
    }
  }
  updateStyles(styles) {
    if (this._styler) {
      this._styler.dispose();
    }
    this._styler = attachListStyler(this, this.themeService, styles);
  }
};
WorkbenchList = __decorate17([
  __param13(5, IContextKeyService),
  __param13(6, IListService),
  __param13(7, IThemeService),
  __param13(8, IConfigurationService),
  __param13(9, IKeybindingService)
], WorkbenchList);
var WorkbenchPagedList = class WorkbenchPagedList2 extends PagedList {
  constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService) {
    const horizontalScrolling = typeof options.horizontalScrolling !== "undefined" ? options.horizontalScrolling : configurationService.getValue(horizontalScrollingKey);
    const [workbenchListOptions, workbenchListOptionsDisposable] = toWorkbenchListOptions(options, configurationService, keybindingService);
    super(user, container, delegate, renderers, Object.assign(Object.assign(Object.assign({keyboardSupport: false}, computeStyles(themeService.getColorTheme(), defaultListStyles)), workbenchListOptions), {horizontalScrolling}));
    this.disposables = new DisposableStore();
    this.disposables.add(workbenchListOptionsDisposable);
    this.contextKeyService = createScopedContextKeyService(contextKeyService, this);
    this.horizontalScrolling = options.horizontalScrolling;
    const listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);
    listSupportsMultiSelect.set(!(options.multipleSelectionSupport === false));
    this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    this.disposables.add(this.contextKeyService);
    this.disposables.add(listService.register(this));
    if (options.overrideStyles) {
      this.disposables.add(attachListStyler(this, themeService, options.overrideStyles));
    }
    this.disposables.add(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
      }
      let options2 = {};
      if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === void 0) {
        const horizontalScrolling2 = configurationService.getValue(horizontalScrollingKey);
        options2 = Object.assign(Object.assign({}, options2), {horizontalScrolling: horizontalScrolling2});
      }
      if (e.affectsConfiguration(listSmoothScrolling)) {
        const smoothScrolling = configurationService.getValue(listSmoothScrolling);
        options2 = Object.assign(Object.assign({}, options2), {smoothScrolling});
      }
      if (Object.keys(options2).length > 0) {
        this.updateOptions(options2);
      }
    }));
  }
  dispose() {
    super.dispose();
    this.disposables.dispose();
  }
};
WorkbenchPagedList = __decorate17([
  __param13(5, IContextKeyService),
  __param13(6, IListService),
  __param13(7, IThemeService),
  __param13(8, IConfigurationService),
  __param13(9, IKeybindingService)
], WorkbenchPagedList);
var ResourceNavigator = class extends Disposable {
  constructor(widget, options) {
    var _a, _b;
    super();
    this.widget = widget;
    this._onDidOpen = new Emitter();
    this.onDidOpen = this._onDidOpen.event;
    this.openOnFocus = (_a = options === null || options === void 0 ? void 0 : options.openOnFocus) !== null && _a !== void 0 ? _a : false;
    this._register(Event.filter(this.widget.onDidChangeSelection, (e) => e.browserEvent instanceof KeyboardEvent)((e) => this.onSelectionFromKeyboard(e)));
    this._register(this.widget.onPointer((e) => this.onPointer(e.browserEvent)));
    this._register(this.widget.onMouseDblClick((e) => this.onMouseDblClick(e.browserEvent)));
    if (this.openOnFocus) {
      this._register(Event.filter(this.widget.onDidChangeFocus, (e) => e.browserEvent instanceof KeyboardEvent)((e) => this.onFocusFromKeyboard(e)));
    }
    if (typeof (options === null || options === void 0 ? void 0 : options.openOnSingleClick) !== "boolean" && (options === null || options === void 0 ? void 0 : options.configurationService)) {
      this.openOnSingleClick = (options === null || options === void 0 ? void 0 : options.configurationService.getValue(openModeSettingKey)) !== "doubleClick";
      this._register(options === null || options === void 0 ? void 0 : options.configurationService.onDidChangeConfiguration(() => {
        this.openOnSingleClick = (options === null || options === void 0 ? void 0 : options.configurationService.getValue(openModeSettingKey)) !== "doubleClick";
      }));
    } else {
      this.openOnSingleClick = (_b = options === null || options === void 0 ? void 0 : options.openOnSingleClick) !== null && _b !== void 0 ? _b : true;
    }
  }
  onFocusFromKeyboard(event) {
    const focus = this.widget.getFocus();
    this.widget.setSelection(focus, event.browserEvent);
    const preserveFocus = typeof event.browserEvent.preserveFocus === "boolean" ? event.browserEvent.preserveFocus : true;
    const pinned = false;
    const sideBySide = false;
    this._open(preserveFocus, pinned, sideBySide, event.browserEvent);
  }
  onSelectionFromKeyboard(event) {
    if (event.elements.length !== 1) {
      return;
    }
    const preserveFocus = typeof event.browserEvent.preserveFocus === "boolean" ? event.browserEvent.preserveFocus : true;
    const pinned = false;
    const sideBySide = false;
    this._open(preserveFocus, pinned, sideBySide, event.browserEvent);
  }
  onPointer(browserEvent) {
    if (!this.openOnSingleClick) {
      return;
    }
    const isDoubleClick = browserEvent.detail === 2;
    if (isDoubleClick) {
      return;
    }
    const isMiddleClick = browserEvent.button === 1;
    const preserveFocus = true;
    const pinned = isMiddleClick;
    const sideBySide = browserEvent.ctrlKey || browserEvent.metaKey || browserEvent.altKey;
    this._open(preserveFocus, pinned, sideBySide, browserEvent);
  }
  onMouseDblClick(browserEvent) {
    if (!browserEvent) {
      return;
    }
    const preserveFocus = false;
    const pinned = true;
    const sideBySide = browserEvent.ctrlKey || browserEvent.metaKey || browserEvent.altKey;
    this._open(preserveFocus, pinned, sideBySide, browserEvent);
  }
  _open(preserveFocus, pinned, sideBySide, browserEvent) {
    this._onDidOpen.fire({
      editorOptions: {
        preserveFocus,
        pinned,
        revealIfVisible: true
      },
      sideBySide,
      element: this.widget.getSelection()[0],
      browserEvent
    });
  }
};
var TreeResourceNavigator = class extends ResourceNavigator {
  constructor(tree, options) {
    super(tree, options);
  }
};
function createKeyboardNavigationEventFilter(container, keybindingService) {
  let inChord = false;
  return (event) => {
    if (inChord) {
      inChord = false;
      return false;
    }
    const result = keybindingService.softDispatch(event, container);
    if (result && result.enterChord) {
      inChord = true;
      return false;
    }
    inChord = false;
    return true;
  };
}
var WorkbenchObjectTree = class WorkbenchObjectTree2 extends ObjectTree {
  constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {
    const {options: treeOptions, getAutomaticKeyboardNavigation, disposable} = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);
    super(user, container, delegate, renderers, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);
    this.disposables.add(this.internals);
  }
};
WorkbenchObjectTree = __decorate17([
  __param13(5, IContextKeyService),
  __param13(6, IListService),
  __param13(7, IThemeService),
  __param13(8, IConfigurationService),
  __param13(9, IKeybindingService),
  __param13(10, IAccessibilityService)
], WorkbenchObjectTree);
var WorkbenchCompressibleObjectTree = class WorkbenchCompressibleObjectTree2 extends CompressibleObjectTree {
  constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {
    const {options: treeOptions, getAutomaticKeyboardNavigation, disposable} = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);
    super(user, container, delegate, renderers, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);
    this.disposables.add(this.internals);
  }
  updateOptions(options = {}) {
    super.updateOptions(options);
    if (options.overrideStyles) {
      this.internals.updateStyleOverrides(options.overrideStyles);
    }
  }
};
WorkbenchCompressibleObjectTree = __decorate17([
  __param13(5, IContextKeyService),
  __param13(6, IListService),
  __param13(7, IThemeService),
  __param13(8, IConfigurationService),
  __param13(9, IKeybindingService),
  __param13(10, IAccessibilityService)
], WorkbenchCompressibleObjectTree);
var WorkbenchDataTree = class WorkbenchDataTree2 extends DataTree {
  constructor(user, container, delegate, renderers, dataSource, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {
    const {options: treeOptions, getAutomaticKeyboardNavigation, disposable} = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);
    super(user, container, delegate, renderers, dataSource, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);
    this.disposables.add(this.internals);
  }
  updateOptions(options = {}) {
    super.updateOptions(options);
    if (options.overrideStyles) {
      this.internals.updateStyleOverrides(options.overrideStyles);
    }
  }
};
WorkbenchDataTree = __decorate17([
  __param13(6, IContextKeyService),
  __param13(7, IListService),
  __param13(8, IThemeService),
  __param13(9, IConfigurationService),
  __param13(10, IKeybindingService),
  __param13(11, IAccessibilityService)
], WorkbenchDataTree);
var WorkbenchAsyncDataTree = class WorkbenchAsyncDataTree2 extends AsyncDataTree {
  constructor(user, container, delegate, renderers, dataSource, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {
    const {options: treeOptions, getAutomaticKeyboardNavigation, disposable} = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);
    super(user, container, delegate, renderers, dataSource, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);
    this.disposables.add(this.internals);
  }
  get onDidOpen() {
    return this.internals.onDidOpen;
  }
  updateOptions(options = {}) {
    super.updateOptions(options);
    if (options.overrideStyles) {
      this.internals.updateStyleOverrides(options.overrideStyles);
    }
  }
};
WorkbenchAsyncDataTree = __decorate17([
  __param13(6, IContextKeyService),
  __param13(7, IListService),
  __param13(8, IThemeService),
  __param13(9, IConfigurationService),
  __param13(10, IKeybindingService),
  __param13(11, IAccessibilityService)
], WorkbenchAsyncDataTree);
var WorkbenchCompressibleAsyncDataTree = class WorkbenchCompressibleAsyncDataTree2 extends CompressibleAsyncDataTree {
  constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {
    const {options: treeOptions, getAutomaticKeyboardNavigation, disposable} = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);
    super(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);
    this.disposables.add(this.internals);
  }
};
WorkbenchCompressibleAsyncDataTree = __decorate17([
  __param13(7, IContextKeyService),
  __param13(8, IListService),
  __param13(9, IThemeService),
  __param13(10, IConfigurationService),
  __param13(11, IKeybindingService),
  __param13(12, IAccessibilityService)
], WorkbenchCompressibleAsyncDataTree);
function workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService) {
  WorkbenchListSupportsKeyboardNavigation.bindTo(contextKeyService);
  if (!didBindWorkbenchListAutomaticKeyboardNavigation) {
    WorkbenchListAutomaticKeyboardNavigation.bindTo(contextKeyService);
    didBindWorkbenchListAutomaticKeyboardNavigation = true;
  }
  const getAutomaticKeyboardNavigation = () => {
    let automaticKeyboardNavigation = contextKeyService.getContextKeyValue(WorkbenchListAutomaticKeyboardNavigationKey);
    if (automaticKeyboardNavigation) {
      automaticKeyboardNavigation = configurationService.getValue(automaticKeyboardNavigationSettingKey);
    }
    return automaticKeyboardNavigation;
  };
  const accessibilityOn = accessibilityService.isScreenReaderOptimized();
  const keyboardNavigation = accessibilityOn ? "simple" : configurationService.getValue(keyboardNavigationSettingKey);
  const horizontalScrolling = options.horizontalScrolling !== void 0 ? options.horizontalScrolling : configurationService.getValue(horizontalScrollingKey);
  const [workbenchListOptions, disposable] = toWorkbenchListOptions(options, configurationService, keybindingService);
  const additionalScrollHeight = options.additionalScrollHeight;
  return {
    getAutomaticKeyboardNavigation,
    disposable,
    options: Object.assign(Object.assign({
      keyboardSupport: false
    }, workbenchListOptions), {indent: configurationService.getValue(treeIndentKey), renderIndentGuides: configurationService.getValue(treeRenderIndentGuidesKey), smoothScrolling: configurationService.getValue(listSmoothScrolling), automaticKeyboardNavigation: getAutomaticKeyboardNavigation(), simpleKeyboardNavigation: keyboardNavigation === "simple", filterOnType: keyboardNavigation === "filter", horizontalScrolling, keyboardNavigationEventFilter: createKeyboardNavigationEventFilter(container, keybindingService), additionalScrollHeight, hideTwistiesOfChildlessElements: options.hideTwistiesOfChildlessElements, expandOnlyOnDoubleClick: configurationService.getValue(openModeSettingKey) === "doubleClick"})
  };
}
var WorkbenchTreeInternals = class WorkbenchTreeInternals2 {
  constructor(tree, options, getAutomaticKeyboardNavigation, overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService) {
    this.tree = tree;
    this.themeService = themeService;
    this.disposables = [];
    this.contextKeyService = createScopedContextKeyService(contextKeyService, tree);
    const listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);
    listSupportsMultiSelect.set(!(options.multipleSelectionSupport === false));
    this.hasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);
    this.hasDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);
    this.hasMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);
    this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    const interestingContextKeys = new Set();
    interestingContextKeys.add(WorkbenchListAutomaticKeyboardNavigationKey);
    const updateKeyboardNavigation = () => {
      const accessibilityOn = accessibilityService.isScreenReaderOptimized();
      const keyboardNavigation = accessibilityOn ? "simple" : configurationService.getValue(keyboardNavigationSettingKey);
      tree.updateOptions({
        simpleKeyboardNavigation: keyboardNavigation === "simple",
        filterOnType: keyboardNavigation === "filter"
      });
    };
    this.updateStyleOverrides(overrideStyles);
    this.disposables.push(this.contextKeyService, listService.register(tree), tree.onDidChangeSelection(() => {
      const selection = tree.getSelection();
      const focus = tree.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.hasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
        this.hasMultiSelection.set(selection.length > 1);
        this.hasDoubleSelection.set(selection.length === 2);
      });
    }), tree.onDidChangeFocus(() => {
      const selection = tree.getSelection();
      const focus = tree.getFocus();
      this.hasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
    }), configurationService.onDidChangeConfiguration((e) => {
      let newOptions = {};
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
      }
      if (e.affectsConfiguration(treeIndentKey)) {
        const indent = configurationService.getValue(treeIndentKey);
        newOptions = Object.assign(Object.assign({}, newOptions), {indent});
      }
      if (e.affectsConfiguration(treeRenderIndentGuidesKey)) {
        const renderIndentGuides = configurationService.getValue(treeRenderIndentGuidesKey);
        newOptions = Object.assign(Object.assign({}, newOptions), {renderIndentGuides});
      }
      if (e.affectsConfiguration(listSmoothScrolling)) {
        const smoothScrolling = configurationService.getValue(listSmoothScrolling);
        newOptions = Object.assign(Object.assign({}, newOptions), {smoothScrolling});
      }
      if (e.affectsConfiguration(keyboardNavigationSettingKey)) {
        updateKeyboardNavigation();
      }
      if (e.affectsConfiguration(automaticKeyboardNavigationSettingKey)) {
        newOptions = Object.assign(Object.assign({}, newOptions), {automaticKeyboardNavigation: getAutomaticKeyboardNavigation()});
      }
      if (e.affectsConfiguration(horizontalScrollingKey) && options.horizontalScrolling === void 0) {
        const horizontalScrolling = configurationService.getValue(horizontalScrollingKey);
        newOptions = Object.assign(Object.assign({}, newOptions), {horizontalScrolling});
      }
      if (e.affectsConfiguration(openModeSettingKey)) {
        newOptions = Object.assign(Object.assign({}, newOptions), {expandOnlyOnDoubleClick: configurationService.getValue(openModeSettingKey) === "doubleClick"});
      }
      if (Object.keys(newOptions).length > 0) {
        tree.updateOptions(newOptions);
      }
    }), this.contextKeyService.onDidChangeContext((e) => {
      if (e.affectsSome(interestingContextKeys)) {
        tree.updateOptions({automaticKeyboardNavigation: getAutomaticKeyboardNavigation()});
      }
    }), accessibilityService.onDidChangeScreenReaderOptimized(() => updateKeyboardNavigation()));
    this.navigator = new TreeResourceNavigator(tree, Object.assign({configurationService}, options));
    this.disposables.push(this.navigator);
  }
  get onDidOpen() {
    return this.navigator.onDidOpen;
  }
  updateStyleOverrides(overrideStyles) {
    dispose(this.styler);
    this.styler = overrideStyles ? attachListStyler(this.tree, this.themeService, overrideStyles) : Disposable.None;
  }
  dispose() {
    this.disposables = dispose(this.disposables);
    dispose(this.styler);
    this.styler = void 0;
  }
};
WorkbenchTreeInternals = __decorate17([
  __param13(4, IContextKeyService),
  __param13(5, IListService),
  __param13(6, IThemeService),
  __param13(7, IConfigurationService),
  __param13(8, IAccessibilityService)
], WorkbenchTreeInternals);
var configurationRegistry3 = Registry2.as(Extensions2.Configuration);
configurationRegistry3.registerConfiguration({
  id: "workbench",
  order: 7,
  title: localize("workbenchConfigurationTitle", "Workbench"),
  type: "object",
  properties: {
    [multiSelectModifierSettingKey]: {
      type: "string",
      enum: ["ctrlCmd", "alt"],
      enumDescriptions: [
        localize("multiSelectModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
        localize("multiSelectModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
      ],
      default: "ctrlCmd",
      description: localize({
        key: "multiSelectModifier",
        comment: [
          "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
          "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
        ]
      }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.")
    },
    [openModeSettingKey]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: localize({
        key: "openModeModifier",
        comment: ["`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized."]
      }, "Controls how to open items in trees and lists using the mouse (if supported). For parents with children in trees, this setting will control if a single click expands the parent or a double click. Note that some trees and lists might choose to ignore this setting if it is not applicable. ")
    },
    [horizontalScrollingKey]: {
      type: "boolean",
      default: false,
      description: localize("horizontalScrolling setting", "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
    },
    [treeIndentKey]: {
      type: "number",
      default: 8,
      minimum: 0,
      maximum: 40,
      description: localize("tree indent setting", "Controls tree indentation in pixels.")
    },
    [treeRenderIndentGuidesKey]: {
      type: "string",
      enum: ["none", "onHover", "always"],
      default: "onHover",
      description: localize("render tree indent guides", "Controls whether the tree should render indent guides.")
    },
    [listSmoothScrolling]: {
      type: "boolean",
      default: false,
      description: localize("list smoothScrolling setting", "Controls whether lists and trees have smooth scrolling.")
    },
    [keyboardNavigationSettingKey]: {
      type: "string",
      enum: ["simple", "highlight", "filter"],
      enumDescriptions: [
        localize("keyboardNavigationSettingKey.simple", "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
        localize("keyboardNavigationSettingKey.highlight", "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
        localize("keyboardNavigationSettingKey.filter", "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
      ],
      default: "highlight",
      description: localize("keyboardNavigationSettingKey", "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter.")
    },
    [automaticKeyboardNavigationSettingKey]: {
      type: "boolean",
      default: true,
      markdownDescription: localize("automatic keyboard navigation setting", "Controls whether keyboard navigation in lists and trees is automatically triggered simply by typing. If set to `false`, keyboard navigation is only triggered when executing the `list.toggleKeyboardNavigation` command, for which you can assign a keyboard shortcut.")
    }
  }
});

// ../../node_modules/monaco-editor/esm/vs/platform/markers/common/markers.js
var MarkerSeverity2;
(function(MarkerSeverity4) {
  MarkerSeverity4[MarkerSeverity4["Hint"] = 1] = "Hint";
  MarkerSeverity4[MarkerSeverity4["Info"] = 2] = "Info";
  MarkerSeverity4[MarkerSeverity4["Warning"] = 4] = "Warning";
  MarkerSeverity4[MarkerSeverity4["Error"] = 8] = "Error";
})(MarkerSeverity2 || (MarkerSeverity2 = {}));
(function(MarkerSeverity4) {
  function compare2(a, b) {
    return b - a;
  }
  MarkerSeverity4.compare = compare2;
  const _displayStrings = Object.create(null);
  _displayStrings[MarkerSeverity4.Error] = localize("sev.error", "Error");
  _displayStrings[MarkerSeverity4.Warning] = localize("sev.warning", "Warning");
  _displayStrings[MarkerSeverity4.Info] = localize("sev.info", "Info");
  function toString(a) {
    return _displayStrings[a] || "";
  }
  MarkerSeverity4.toString = toString;
  function fromSeverity(severity) {
    switch (severity) {
      case severity_default.Error:
        return MarkerSeverity4.Error;
      case severity_default.Warning:
        return MarkerSeverity4.Warning;
      case severity_default.Info:
        return MarkerSeverity4.Info;
      case severity_default.Ignore:
        return MarkerSeverity4.Hint;
    }
  }
  MarkerSeverity4.fromSeverity = fromSeverity;
  function toSeverity(severity) {
    switch (severity) {
      case MarkerSeverity4.Error:
        return severity_default.Error;
      case MarkerSeverity4.Warning:
        return severity_default.Warning;
      case MarkerSeverity4.Info:
        return severity_default.Info;
      case MarkerSeverity4.Hint:
        return severity_default.Ignore;
    }
  }
  MarkerSeverity4.toSeverity = toSeverity;
})(MarkerSeverity2 || (MarkerSeverity2 = {}));
var IMarkerData;
(function(IMarkerData2) {
  const emptyString = "";
  function makeKey(markerData) {
    return makeKeyOptionalMessage(markerData, true);
  }
  IMarkerData2.makeKey = makeKey;
  function makeKeyOptionalMessage(markerData, useMessage) {
    let result = [emptyString];
    if (markerData.source) {
      result.push(markerData.source.replace("\xA6", "\\\xA6"));
    } else {
      result.push(emptyString);
    }
    if (markerData.code) {
      if (typeof markerData.code === "string") {
        result.push(markerData.code.replace("\xA6", "\\\xA6"));
      } else {
        result.push(markerData.code.value.replace("\xA6", "\\\xA6"));
      }
    } else {
      result.push(emptyString);
    }
    if (markerData.severity !== void 0 && markerData.severity !== null) {
      result.push(MarkerSeverity2.toString(markerData.severity));
    } else {
      result.push(emptyString);
    }
    if (markerData.message && useMessage) {
      result.push(markerData.message.replace("\xA6", "\\\xA6"));
    } else {
      result.push(emptyString);
    }
    if (markerData.startLineNumber !== void 0 && markerData.startLineNumber !== null) {
      result.push(markerData.startLineNumber.toString());
    } else {
      result.push(emptyString);
    }
    if (markerData.startColumn !== void 0 && markerData.startColumn !== null) {
      result.push(markerData.startColumn.toString());
    } else {
      result.push(emptyString);
    }
    if (markerData.endLineNumber !== void 0 && markerData.endLineNumber !== null) {
      result.push(markerData.endLineNumber.toString());
    } else {
      result.push(emptyString);
    }
    if (markerData.endColumn !== void 0 && markerData.endColumn !== null) {
      result.push(markerData.endColumn.toString());
    } else {
      result.push(emptyString);
    }
    result.push(emptyString);
    return result.join("\xA6");
  }
  IMarkerData2.makeKeyOptionalMessage = makeKeyOptionalMessage;
})(IMarkerData || (IMarkerData = {}));
var IMarkerService = createDecorator("markerService");

// ../../node_modules/monaco-editor/esm/vs/platform/markers/common/markerService.js
var DoubleResourceMap = class {
  constructor() {
    this._byResource = new ResourceMap();
    this._byOwner = new Map();
  }
  set(resource, owner, value) {
    let ownerMap = this._byResource.get(resource);
    if (!ownerMap) {
      ownerMap = new Map();
      this._byResource.set(resource, ownerMap);
    }
    ownerMap.set(owner, value);
    let resourceMap = this._byOwner.get(owner);
    if (!resourceMap) {
      resourceMap = new ResourceMap();
      this._byOwner.set(owner, resourceMap);
    }
    resourceMap.set(resource, value);
  }
  get(resource, owner) {
    let ownerMap = this._byResource.get(resource);
    return ownerMap === null || ownerMap === void 0 ? void 0 : ownerMap.get(owner);
  }
  delete(resource, owner) {
    let removedA = false;
    let removedB = false;
    let ownerMap = this._byResource.get(resource);
    if (ownerMap) {
      removedA = ownerMap.delete(owner);
    }
    let resourceMap = this._byOwner.get(owner);
    if (resourceMap) {
      removedB = resourceMap.delete(resource);
    }
    if (removedA !== removedB) {
      throw new Error("illegal state");
    }
    return removedA && removedB;
  }
  values(key) {
    var _a, _b, _c, _d;
    if (typeof key === "string") {
      return (_b = (_a = this._byOwner.get(key)) === null || _a === void 0 ? void 0 : _a.values()) !== null && _b !== void 0 ? _b : Iterable.empty();
    }
    if (URI.isUri(key)) {
      return (_d = (_c = this._byResource.get(key)) === null || _c === void 0 ? void 0 : _c.values()) !== null && _d !== void 0 ? _d : Iterable.empty();
    }
    return Iterable.map(Iterable.concat(...this._byOwner.values()), (map) => map[1]);
  }
};
var MarkerStats = class {
  constructor(service) {
    this.errors = 0;
    this.infos = 0;
    this.warnings = 0;
    this.unknowns = 0;
    this._data = new ResourceMap();
    this._service = service;
    this._subscription = service.onMarkerChanged(this._update, this);
  }
  dispose() {
    this._subscription.dispose();
  }
  _update(resources2) {
    for (const resource of resources2) {
      const oldStats = this._data.get(resource);
      if (oldStats) {
        this._substract(oldStats);
      }
      const newStats = this._resourceStats(resource);
      this._add(newStats);
      this._data.set(resource, newStats);
    }
  }
  _resourceStats(resource) {
    const result = {errors: 0, warnings: 0, infos: 0, unknowns: 0};
    if (resource.scheme === Schemas.inMemory || resource.scheme === Schemas.walkThrough || resource.scheme === Schemas.walkThroughSnippet) {
      return result;
    }
    for (const {severity} of this._service.read({resource})) {
      if (severity === MarkerSeverity2.Error) {
        result.errors += 1;
      } else if (severity === MarkerSeverity2.Warning) {
        result.warnings += 1;
      } else if (severity === MarkerSeverity2.Info) {
        result.infos += 1;
      } else {
        result.unknowns += 1;
      }
    }
    return result;
  }
  _substract(op) {
    this.errors -= op.errors;
    this.warnings -= op.warnings;
    this.infos -= op.infos;
    this.unknowns -= op.unknowns;
  }
  _add(op) {
    this.errors += op.errors;
    this.warnings += op.warnings;
    this.infos += op.infos;
    this.unknowns += op.unknowns;
  }
};
var MarkerService = class {
  constructor() {
    this._onMarkerChanged = new Emitter();
    this.onMarkerChanged = Event.debounce(this._onMarkerChanged.event, MarkerService._debouncer, 0);
    this._data = new DoubleResourceMap();
    this._stats = new MarkerStats(this);
  }
  dispose() {
    this._stats.dispose();
  }
  remove(owner, resources2) {
    for (const resource of resources2 || []) {
      this.changeOne(owner, resource, []);
    }
  }
  changeOne(owner, resource, markerData) {
    if (isFalsyOrEmpty(markerData)) {
      const removed = this._data.delete(resource, owner);
      if (removed) {
        this._onMarkerChanged.fire([resource]);
      }
    } else {
      const markers = [];
      for (const data of markerData) {
        const marker = MarkerService._toMarker(owner, resource, data);
        if (marker) {
          markers.push(marker);
        }
      }
      this._data.set(resource, owner, markers);
      this._onMarkerChanged.fire([resource]);
    }
  }
  static _toMarker(owner, resource, data) {
    let {code, severity, message, source, startLineNumber, startColumn, endLineNumber, endColumn, relatedInformation, tags} = data;
    if (!message) {
      return void 0;
    }
    startLineNumber = startLineNumber > 0 ? startLineNumber : 1;
    startColumn = startColumn > 0 ? startColumn : 1;
    endLineNumber = endLineNumber >= startLineNumber ? endLineNumber : startLineNumber;
    endColumn = endColumn > 0 ? endColumn : startColumn;
    return {
      resource,
      owner,
      code,
      severity,
      message,
      source,
      startLineNumber,
      startColumn,
      endLineNumber,
      endColumn,
      relatedInformation,
      tags
    };
  }
  read(filter = Object.create(null)) {
    let {owner, resource, severities, take} = filter;
    if (!take || take < 0) {
      take = -1;
    }
    if (owner && resource) {
      const data = this._data.get(resource, owner);
      if (!data) {
        return [];
      } else {
        const result = [];
        for (const marker of data) {
          if (MarkerService._accept(marker, severities)) {
            const newLen = result.push(marker);
            if (take > 0 && newLen === take) {
              break;
            }
          }
        }
        return result;
      }
    } else if (!owner && !resource) {
      const result = [];
      for (let markers of this._data.values()) {
        for (let data of markers) {
          if (MarkerService._accept(data, severities)) {
            const newLen = result.push(data);
            if (take > 0 && newLen === take) {
              return result;
            }
          }
        }
      }
      return result;
    } else {
      const iterable = this._data.values(resource !== null && resource !== void 0 ? resource : owner);
      const result = [];
      for (const markers of iterable) {
        for (const data of markers) {
          if (MarkerService._accept(data, severities)) {
            const newLen = result.push(data);
            if (take > 0 && newLen === take) {
              return result;
            }
          }
        }
      }
      return result;
    }
  }
  static _accept(marker, severities) {
    return severities === void 0 || (severities & marker.severity) === marker.severity;
  }
  static _debouncer(last, event) {
    if (!last) {
      MarkerService._dedupeMap = new ResourceMap();
      last = [];
    }
    for (const uri of event) {
      if (!MarkerService._dedupeMap.has(uri)) {
        MarkerService._dedupeMap.set(uri, true);
        last.push(uri);
      }
    }
    return last;
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/storage/common/storage.js
var IStorageService = createDecorator("storageService");
var WillSaveStateReason;
(function(WillSaveStateReason2) {
  WillSaveStateReason2[WillSaveStateReason2["NONE"] = 0] = "NONE";
  WillSaveStateReason2[WillSaveStateReason2["SHUTDOWN"] = 1] = "SHUTDOWN";
})(WillSaveStateReason || (WillSaveStateReason = {}));
var InMemoryStorageService = class extends Disposable {
  constructor() {
    super(...arguments);
    this._onDidChangeStorage = this._register(new Emitter());
    this._onWillSaveState = this._register(new Emitter());
    this.onWillSaveState = this._onWillSaveState.event;
    this.globalCache = new Map();
    this.workspaceCache = new Map();
  }
  getCache(scope) {
    return scope === 0 ? this.globalCache : this.workspaceCache;
  }
  get(key, scope, fallbackValue) {
    const value = this.getCache(scope).get(key);
    if (isUndefinedOrNull(value)) {
      return fallbackValue;
    }
    return value;
  }
  getBoolean(key, scope, fallbackValue) {
    const value = this.getCache(scope).get(key);
    if (isUndefinedOrNull(value)) {
      return fallbackValue;
    }
    return value === "true";
  }
  getNumber(key, scope, fallbackValue) {
    const value = this.getCache(scope).get(key);
    if (isUndefinedOrNull(value)) {
      return fallbackValue;
    }
    return parseInt(value, 10);
  }
  store(key, value, scope) {
    if (isUndefinedOrNull(value)) {
      return this.remove(key, scope);
    }
    const valueStr = String(value);
    const currentValue = this.getCache(scope).get(key);
    if (currentValue === valueStr) {
      return Promise.resolve();
    }
    this.getCache(scope).set(key, valueStr);
    this._onDidChangeStorage.fire({scope, key});
    return Promise.resolve();
  }
  remove(key, scope) {
    const wasDeleted = this.getCache(scope).delete(key);
    if (!wasDeleted) {
      return Promise.resolve();
    }
    this._onDidChangeStorage.fire({scope, key});
    return Promise.resolve();
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/actions/common/menuService.js
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param14 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MenuService = class MenuService2 {
  constructor(_commandService) {
    this._commandService = _commandService;
  }
  createMenu(id, contextKeyService) {
    return new Menu2(id, this._commandService, contextKeyService, this);
  }
};
MenuService = __decorate18([
  __param14(0, ICommandService)
], MenuService);
var Menu2 = class Menu3 {
  constructor(_id, _commandService, _contextKeyService, _menuService) {
    this._id = _id;
    this._commandService = _commandService;
    this._contextKeyService = _contextKeyService;
    this._menuService = _menuService;
    this._onDidChange = new Emitter();
    this._dispoables = new DisposableStore();
    this._menuGroups = [];
    this._contextKeys = new Set();
    this._build();
    this._dispoables.add(Event.debounce(Event.filter(MenuRegistry.onDidChangeMenu, (set) => set.has(this._id)), () => {
    }, 50)(this._build, this));
    this._dispoables.add(Event.debounce(this._contextKeyService.onDidChangeContext, (last, event) => last || event.affectsSome(this._contextKeys), 50)((e) => e && this._onDidChange.fire(void 0), this));
  }
  dispose() {
    this._dispoables.dispose();
    this._onDidChange.dispose();
  }
  _build() {
    this._menuGroups.length = 0;
    this._contextKeys.clear();
    const menuItems = MenuRegistry.getMenuItems(this._id);
    let group;
    menuItems.sort(Menu3._compareMenuItems);
    for (let item of menuItems) {
      const groupName = item.group || "";
      if (!group || group[0] !== groupName) {
        group = [groupName, []];
        this._menuGroups.push(group);
      }
      group[1].push(item);
      Menu3._fillInKbExprKeys(item.when, this._contextKeys);
      if (isIMenuItem(item) && item.command.precondition) {
        Menu3._fillInKbExprKeys(item.command.precondition, this._contextKeys);
      }
      if (isIMenuItem(item) && item.command.toggled) {
        const toggledExpression = item.command.toggled.condition || item.command.toggled;
        Menu3._fillInKbExprKeys(toggledExpression, this._contextKeys);
      }
    }
    this._onDidChange.fire(this);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  getActions(options) {
    const result = [];
    for (let group of this._menuGroups) {
      const [id, items] = group;
      const activeActions = [];
      for (const item of items) {
        if (this._contextKeyService.contextMatchesRules(item.when)) {
          const action = isIMenuItem(item) ? new MenuItemAction(item.command, item.alt, options, this._contextKeyService, this._commandService) : new SubmenuItemAction(item, this._menuService, this._contextKeyService, options);
          activeActions.push(action);
        }
      }
      if (activeActions.length > 0) {
        result.push([id, activeActions]);
      }
    }
    return result;
  }
  static _fillInKbExprKeys(exp, set) {
    if (exp) {
      for (let key of exp.keys()) {
        set.add(key);
      }
    }
  }
  static _compareMenuItems(a, b) {
    let aGroup = a.group;
    let bGroup = b.group;
    if (aGroup !== bGroup) {
      if (!aGroup) {
        return 1;
      } else if (!bGroup) {
        return -1;
      }
      if (aGroup === "navigation") {
        return -1;
      } else if (bGroup === "navigation") {
        return 1;
      }
      let value = aGroup.localeCompare(bGroup);
      if (value !== 0) {
        return value;
      }
    }
    let aPrio = a.order || 0;
    let bPrio = b.order || 0;
    if (aPrio < bPrio) {
      return -1;
    } else if (aPrio > bPrio) {
      return 1;
    }
    return Menu3._compareTitles(isIMenuItem(a) ? a.command.title : a.title, isIMenuItem(b) ? b.command.title : b.title);
  }
  static _compareTitles(a, b) {
    const aStr = typeof a === "string" ? a : a.value;
    const bStr = typeof b === "string" ? b : b.value;
    return aStr.localeCompare(bStr);
  }
};
Menu2 = __decorate18([
  __param14(1, ICommandService),
  __param14(2, IContextKeyService),
  __param14(3, IMenuService)
], Menu2);

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/markersDecorationService.js
var IMarkerDecorationsService = createDecorator("markerDecorationsService");

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorationsServiceImpl.js
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param15 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function MODEL_ID3(resource) {
  return resource.toString();
}
var MarkerDecorations = class extends Disposable {
  constructor(model2) {
    super();
    this.model = model2;
    this._markersData = new Map();
    this._register(toDisposable(() => {
      this.model.deltaDecorations([...this._markersData.keys()], []);
      this._markersData.clear();
    }));
  }
  update(markers, newDecorations) {
    const oldIds = [...this._markersData.keys()];
    this._markersData.clear();
    const ids = this.model.deltaDecorations(oldIds, newDecorations);
    for (let index = 0; index < ids.length; index++) {
      this._markersData.set(ids[index], markers[index]);
    }
    return oldIds.length !== 0 || ids.length !== 0;
  }
  getMarker(decoration) {
    return this._markersData.get(decoration.id);
  }
};
var MarkerDecorationsService = class MarkerDecorationsService2 extends Disposable {
  constructor(modelService, _markerService) {
    super();
    this._markerService = _markerService;
    this._onDidChangeMarker = this._register(new Emitter());
    this._markerDecorations = new Map();
    modelService.getModels().forEach((model2) => this._onModelAdded(model2));
    this._register(modelService.onModelAdded(this._onModelAdded, this));
    this._register(modelService.onModelRemoved(this._onModelRemoved, this));
    this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));
  }
  dispose() {
    super.dispose();
    this._markerDecorations.forEach((value) => value.dispose());
    this._markerDecorations.clear();
  }
  getMarker(model2, decoration) {
    const markerDecorations = this._markerDecorations.get(MODEL_ID3(model2.uri));
    return markerDecorations ? markerDecorations.getMarker(decoration) || null : null;
  }
  _handleMarkerChange(changedResources) {
    changedResources.forEach((resource) => {
      const markerDecorations = this._markerDecorations.get(MODEL_ID3(resource));
      if (markerDecorations) {
        this._updateDecorations(markerDecorations);
      }
    });
  }
  _onModelAdded(model2) {
    const markerDecorations = new MarkerDecorations(model2);
    this._markerDecorations.set(MODEL_ID3(model2.uri), markerDecorations);
    this._updateDecorations(markerDecorations);
  }
  _onModelRemoved(model2) {
    const markerDecorations = this._markerDecorations.get(MODEL_ID3(model2.uri));
    if (markerDecorations) {
      markerDecorations.dispose();
      this._markerDecorations.delete(MODEL_ID3(model2.uri));
    }
    if (model2.uri.scheme === Schemas.inMemory || model2.uri.scheme === Schemas.internal || model2.uri.scheme === Schemas.vscode) {
      if (this._markerService) {
        this._markerService.read({resource: model2.uri}).map((marker) => marker.owner).forEach((owner) => this._markerService.remove(owner, [model2.uri]));
      }
    }
  }
  _updateDecorations(markerDecorations) {
    const markers = this._markerService.read({resource: markerDecorations.model.uri, take: 500});
    let newModelDecorations = markers.map((marker) => {
      return {
        range: this._createDecorationRange(markerDecorations.model, marker),
        options: this._createDecorationOption(marker)
      };
    });
    if (markerDecorations.update(markers, newModelDecorations)) {
      this._onDidChangeMarker.fire(markerDecorations.model);
    }
  }
  _createDecorationRange(model2, rawMarker) {
    let ret = Range.lift(rawMarker);
    if (rawMarker.severity === MarkerSeverity2.Hint && !this._hasMarkerTag(rawMarker, 1) && !this._hasMarkerTag(rawMarker, 2)) {
      ret = ret.setEndPosition(ret.startLineNumber, ret.startColumn + 2);
    }
    ret = model2.validateRange(ret);
    if (ret.isEmpty()) {
      let word = model2.getWordAtPosition(ret.getStartPosition());
      if (word) {
        ret = new Range(ret.startLineNumber, word.startColumn, ret.endLineNumber, word.endColumn);
      } else {
        let maxColumn = model2.getLineLastNonWhitespaceColumn(ret.startLineNumber) || model2.getLineMaxColumn(ret.startLineNumber);
        if (maxColumn === 1) {
        } else if (ret.endColumn >= maxColumn) {
          ret = new Range(ret.startLineNumber, maxColumn - 1, ret.endLineNumber, maxColumn);
        } else {
          ret = new Range(ret.startLineNumber, ret.startColumn, ret.endLineNumber, ret.endColumn + 1);
        }
      }
    } else if (rawMarker.endColumn === Number.MAX_VALUE && rawMarker.startColumn === 1 && ret.startLineNumber === ret.endLineNumber) {
      let minColumn = model2.getLineFirstNonWhitespaceColumn(rawMarker.startLineNumber);
      if (minColumn < ret.endColumn) {
        ret = new Range(ret.startLineNumber, minColumn, ret.endLineNumber, ret.endColumn);
        rawMarker.startColumn = minColumn;
      }
    }
    return ret;
  }
  _createDecorationOption(marker) {
    let className;
    let color = void 0;
    let zIndex;
    let inlineClassName = void 0;
    let minimap;
    switch (marker.severity) {
      case MarkerSeverity2.Hint:
        if (this._hasMarkerTag(marker, 2)) {
          className = void 0;
        } else if (this._hasMarkerTag(marker, 1)) {
          className = "squiggly-unnecessary";
        } else {
          className = "squiggly-hint";
        }
        zIndex = 0;
        break;
      case MarkerSeverity2.Warning:
        className = "squiggly-warning";
        color = themeColorFromId(overviewRulerWarning);
        zIndex = 20;
        minimap = {
          color: themeColorFromId(minimapWarning),
          position: MinimapPosition2.Inline
        };
        break;
      case MarkerSeverity2.Info:
        className = "squiggly-info";
        color = themeColorFromId(overviewRulerInfo);
        zIndex = 10;
        break;
      case MarkerSeverity2.Error:
      default:
        className = "squiggly-error";
        color = themeColorFromId(overviewRulerError);
        zIndex = 30;
        minimap = {
          color: themeColorFromId(minimapError),
          position: MinimapPosition2.Inline
        };
        break;
    }
    if (marker.tags) {
      if (marker.tags.indexOf(1) !== -1) {
        inlineClassName = "squiggly-inline-unnecessary";
      }
      if (marker.tags.indexOf(2) !== -1) {
        inlineClassName = "squiggly-inline-deprecated";
      }
    }
    return {
      stickiness: 1,
      className,
      showIfCollapsed: true,
      overviewRuler: {
        color,
        position: OverviewRulerLane2.Right
      },
      minimap,
      zIndex,
      inlineClassName
    };
  }
  _hasMarkerTag(marker, tag) {
    if (marker.tags) {
      return marker.tags.indexOf(tag) >= 0;
    }
    return false;
  }
};
MarkerDecorationsService = __decorate19([
  __param15(0, IModelService),
  __param15(1, IMarkerService)
], MarkerDecorationsService);

// ../../node_modules/monaco-editor/esm/vs/platform/accessibility/common/accessibilityService.js
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param16 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var AccessibilityService = class AccessibilityService2 extends Disposable {
  constructor(_contextKeyService, _configurationService) {
    super();
    this._contextKeyService = _contextKeyService;
    this._configurationService = _configurationService;
    this._accessibilitySupport = 0;
    this._onDidChangeScreenReaderOptimized = new Emitter();
    this._accessibilityModeEnabledContext = CONTEXT_ACCESSIBILITY_MODE_ENABLED.bindTo(this._contextKeyService);
    const updateContextKey = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("editor.accessibilitySupport")) {
        updateContextKey();
        this._onDidChangeScreenReaderOptimized.fire();
      }
    }));
    updateContextKey();
    this.onDidChangeScreenReaderOptimized(() => updateContextKey());
  }
  get onDidChangeScreenReaderOptimized() {
    return this._onDidChangeScreenReaderOptimized.event;
  }
  isScreenReaderOptimized() {
    const config = this._configurationService.getValue("editor.accessibilitySupport");
    return config === "on" || config === "auto" && this._accessibilitySupport === 2;
  }
  getAccessibilitySupport() {
    return this._accessibilitySupport;
  }
};
AccessibilityService = __decorate20([
  __param16(0, IContextKeyService),
  __param16(1, IConfigurationService)
], AccessibilityService);

// ../../node_modules/monaco-editor/esm/vs/platform/clipboard/browser/clipboardService.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BrowserClipboardService = class {
  constructor() {
    this.mapTextToType = new Map();
    this.findText = "";
  }
  writeText(text, type) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (type) {
        this.mapTextToType.set(type, text);
        return;
      }
      try {
        return yield navigator.clipboard.writeText(text);
      } catch (error) {
        console.error(error);
      }
      const activeElement = document.activeElement;
      const textArea = document.body.appendChild($("textarea", {"aria-hidden": true}));
      textArea.style.height = "1px";
      textArea.style.width = "1px";
      textArea.style.position = "absolute";
      textArea.value = text;
      textArea.focus();
      textArea.select();
      document.execCommand("copy");
      if (activeElement instanceof HTMLElement) {
        activeElement.focus();
      }
      document.body.removeChild(textArea);
      return;
    });
  }
  readText(type) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (type) {
        return this.mapTextToType.get(type) || "";
      }
      try {
        return yield navigator.clipboard.readText();
      } catch (error) {
        console.error(error);
        return "";
      }
    });
  }
  readFindText() {
    return __awaiter9(this, void 0, void 0, function* () {
      return this.findText;
    });
  }
  writeFindText(text) {
    return __awaiter9(this, void 0, void 0, function* () {
      this.findText = text;
    });
  }
};

// ../../node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param17 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEBUG2 = false;
function getResourceLabel(resource) {
  return resource.scheme === Schemas.file ? resource.fsPath : resource.path;
}
var stackElementCounter = 0;
var ResourceStackElement = class {
  constructor(actual, resourceLabel, strResource) {
    this.id = ++stackElementCounter;
    this.type = 0;
    this.actual = actual;
    this.label = actual.label;
    this.resourceLabel = resourceLabel;
    this.strResource = strResource;
    this.resourceLabels = [this.resourceLabel];
    this.strResources = [this.strResource];
    this.isValid = true;
  }
  setValid(isValid) {
    this.isValid = isValid;
  }
  toString() {
    return `[${this.id}] [${this.isValid ? "VALID" : "INVALID"}] ${this.actual}`;
  }
};
var ResourceReasonPair = class {
  constructor(resourceLabel, reason) {
    this.resourceLabel = resourceLabel;
    this.reason = reason;
  }
};
var RemovedResources = class {
  constructor() {
    this.elements = new Map();
  }
  createMessage() {
    const externalRemoval = [];
    const noParallelUniverses = [];
    for (const [, element] of this.elements) {
      const dest = element.reason === 0 ? externalRemoval : noParallelUniverses;
      dest.push(element.resourceLabel);
    }
    let messages = [];
    if (externalRemoval.length > 0) {
      messages.push(localize({key: "externalRemoval", comment: ["{0} is a list of filenames"]}, "The following files have been closed and modified on disk: {0}.", externalRemoval.join(", ")));
    }
    if (noParallelUniverses.length > 0) {
      messages.push(localize({key: "noParallelUniverses", comment: ["{0} is a list of filenames"]}, "The following files have been modified in an incompatible way: {0}.", noParallelUniverses.join(", ")));
    }
    return messages.join("\n");
  }
  get size() {
    return this.elements.size;
  }
  has(strResource) {
    return this.elements.has(strResource);
  }
  set(strResource, value) {
    this.elements.set(strResource, value);
  }
  delete(strResource) {
    return this.elements.delete(strResource);
  }
};
var WorkspaceStackElement = class {
  constructor(actual, resourceLabels, strResources) {
    this.id = ++stackElementCounter;
    this.type = 1;
    this.actual = actual;
    this.label = actual.label;
    this.resourceLabels = resourceLabels;
    this.strResources = strResources;
    this.removedResources = null;
    this.invalidatedResources = null;
  }
  canSplit() {
    return typeof this.actual.split === "function";
  }
  removeResource(resourceLabel, strResource, reason) {
    if (!this.removedResources) {
      this.removedResources = new RemovedResources();
    }
    if (!this.removedResources.has(strResource)) {
      this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));
    }
  }
  setValid(resourceLabel, strResource, isValid) {
    if (isValid) {
      if (this.invalidatedResources) {
        this.invalidatedResources.delete(strResource);
        if (this.invalidatedResources.size === 0) {
          this.invalidatedResources = null;
        }
      }
    } else {
      if (!this.invalidatedResources) {
        this.invalidatedResources = new RemovedResources();
      }
      if (!this.invalidatedResources.has(strResource)) {
        this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0));
      }
    }
  }
  toString() {
    return `[${this.id}] [${this.invalidatedResources ? "INVALID" : "VALID"}] ${this.actual}`;
  }
};
var ResourceEditStack = class {
  constructor(resourceLabel, strResource) {
    this.resourceLabel = resourceLabel;
    this.strResource = strResource;
    this._past = [];
    this._future = [];
    this.locked = false;
    this.versionId = 1;
  }
  dispose() {
    for (const element of this._past) {
      if (element.type === 1) {
        element.removeResource(this.resourceLabel, this.strResource, 0);
      }
    }
    for (const element of this._future) {
      if (element.type === 1) {
        element.removeResource(this.resourceLabel, this.strResource, 0);
      }
    }
    this.versionId++;
  }
  toString() {
    let result = [];
    result.push(`* ${this.strResource}:`);
    for (let i = 0; i < this._past.length; i++) {
      result.push(`   * [UNDO] ${this._past[i]}`);
    }
    for (let i = this._future.length - 1; i >= 0; i--) {
      result.push(`   * [REDO] ${this._future[i]}`);
    }
    return result.join("\n");
  }
  flushAllElements() {
    this._past = [];
    this._future = [];
    this.versionId++;
  }
  _setElementValidFlag(element, isValid) {
    if (element.type === 1) {
      element.setValid(this.resourceLabel, this.strResource, isValid);
    } else {
      element.setValid(isValid);
    }
  }
  setElementsValidFlag(isValid, filter) {
    for (const element of this._past) {
      if (filter(element.actual)) {
        this._setElementValidFlag(element, isValid);
      }
    }
    for (const element of this._future) {
      if (filter(element.actual)) {
        this._setElementValidFlag(element, isValid);
      }
    }
  }
  pushElement(element) {
    for (const futureElement of this._future) {
      if (futureElement.type === 1) {
        futureElement.removeResource(this.resourceLabel, this.strResource, 1);
      }
    }
    this._future = [];
    if (this._past.length > 0) {
      const lastElement = this._past[this._past.length - 1];
      if (lastElement.type === 0 && !lastElement.isValid) {
        this._past = [];
      }
    }
    this._past.push(element);
    this.versionId++;
  }
  createSnapshot(resource) {
    const elements = [];
    for (let i = 0, len = this._past.length; i < len; i++) {
      elements.push(this._past[i].id);
    }
    for (let i = this._future.length - 1; i >= 0; i--) {
      elements.push(this._future[i].id);
    }
    return new ResourceEditStackSnapshot(resource, elements);
  }
  restoreSnapshot(snapshot) {
    const snapshotLength = snapshot.elements.length;
    let isOK = true;
    let snapshotIndex = 0;
    let removePastAfter = -1;
    for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {
      const element = this._past[i];
      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {
        isOK = false;
        removePastAfter = 0;
      }
      if (!isOK && element.type === 1) {
        element.removeResource(this.resourceLabel, this.strResource, 0);
      }
    }
    let removeFutureBefore = -1;
    for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {
      const element = this._future[i];
      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {
        isOK = false;
        removeFutureBefore = i;
      }
      if (!isOK && element.type === 1) {
        element.removeResource(this.resourceLabel, this.strResource, 0);
      }
    }
    if (removePastAfter !== -1) {
      this._past = this._past.slice(0, removePastAfter);
    }
    if (removeFutureBefore !== -1) {
      this._future = this._future.slice(removeFutureBefore + 1);
    }
    this.versionId++;
  }
  getElements() {
    const past = [];
    const future = [];
    for (const element of this._past) {
      past.push(element.actual);
    }
    for (const element of this._future) {
      future.push(element.actual);
    }
    return {past, future};
  }
  getClosestPastElement() {
    if (this._past.length === 0) {
      return null;
    }
    return this._past[this._past.length - 1];
  }
  getClosestFutureElement() {
    if (this._future.length === 0) {
      return null;
    }
    return this._future[this._future.length - 1];
  }
  hasPastElements() {
    return this._past.length > 0;
  }
  hasFutureElements() {
    return this._future.length > 0;
  }
  splitPastWorkspaceElement(toRemove, individualMap) {
    for (let j = this._past.length - 1; j >= 0; j--) {
      if (this._past[j] === toRemove) {
        if (individualMap.has(this.strResource)) {
          this._past[j] = individualMap.get(this.strResource);
        } else {
          this._past.splice(j, 1);
        }
        break;
      }
    }
    this.versionId++;
  }
  splitFutureWorkspaceElement(toRemove, individualMap) {
    for (let j = this._future.length - 1; j >= 0; j--) {
      if (this._future[j] === toRemove) {
        if (individualMap.has(this.strResource)) {
          this._future[j] = individualMap.get(this.strResource);
        } else {
          this._future.splice(j, 1);
        }
        break;
      }
    }
    this.versionId++;
  }
  moveBackward(element) {
    this._past.pop();
    this._future.push(element);
    this.versionId++;
  }
  moveForward(element) {
    this._future.pop();
    this._past.push(element);
    this.versionId++;
  }
};
var EditStackSnapshot = class {
  constructor(editStacks) {
    this.editStacks = editStacks;
    this._versionIds = [];
    for (let i = 0, len = this.editStacks.length; i < len; i++) {
      this._versionIds[i] = this.editStacks[i].versionId;
    }
  }
  isValid() {
    for (let i = 0, len = this.editStacks.length; i < len; i++) {
      if (this._versionIds[i] !== this.editStacks[i].versionId) {
        return false;
      }
    }
    return true;
  }
};
var missingEditStack = new ResourceEditStack("", "");
missingEditStack.locked = true;
var UndoRedoService = class UndoRedoService2 {
  constructor(_dialogService, _notificationService) {
    this._dialogService = _dialogService;
    this._notificationService = _notificationService;
    this._editStacks = new Map();
    this._uriComparisonKeyComputers = [];
  }
  getUriComparisonKey(resource) {
    for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {
      if (uriComparisonKeyComputer[0] === resource.scheme) {
        return uriComparisonKeyComputer[1].getComparisonKey(resource);
      }
    }
    return resource.toString();
  }
  _print(label) {
    console.log(`------------------------------------`);
    console.log(`AFTER ${label}: `);
    let str = [];
    for (const element of this._editStacks) {
      str.push(element[1].toString());
    }
    console.log(str.join("\n"));
  }
  pushElement(element) {
    if (element.type === 0) {
      const resourceLabel = getResourceLabel(element.resource);
      const strResource = this.getUriComparisonKey(element.resource);
      this._pushElement(new ResourceStackElement(element, resourceLabel, strResource));
    } else {
      const seen = new Set();
      const resourceLabels = [];
      const strResources = [];
      for (const resource of element.resources) {
        const resourceLabel = getResourceLabel(resource);
        const strResource = this.getUriComparisonKey(resource);
        if (seen.has(strResource)) {
          continue;
        }
        seen.add(strResource);
        resourceLabels.push(resourceLabel);
        strResources.push(strResource);
      }
      if (resourceLabels.length === 1) {
        this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0]));
      } else {
        this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources));
      }
    }
    if (DEBUG2) {
      this._print("pushElement");
    }
  }
  _pushElement(element) {
    for (let i = 0, len = element.strResources.length; i < len; i++) {
      const resourceLabel = element.resourceLabels[i];
      const strResource = element.strResources[i];
      let editStack;
      if (this._editStacks.has(strResource)) {
        editStack = this._editStacks.get(strResource);
      } else {
        editStack = new ResourceEditStack(resourceLabel, strResource);
        this._editStacks.set(strResource, editStack);
      }
      editStack.pushElement(element);
    }
  }
  getLastElement(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      if (editStack.hasFutureElements()) {
        return null;
      }
      const closestPastElement = editStack.getClosestPastElement();
      return closestPastElement ? closestPastElement.actual : null;
    }
    return null;
  }
  _splitPastWorkspaceElement(toRemove, ignoreResources) {
    const individualArr = toRemove.actual.split();
    const individualMap = new Map();
    for (const _element of individualArr) {
      const resourceLabel = getResourceLabel(_element.resource);
      const strResource = this.getUriComparisonKey(_element.resource);
      const element = new ResourceStackElement(_element, resourceLabel, strResource);
      individualMap.set(element.strResource, element);
    }
    for (const strResource of toRemove.strResources) {
      if (ignoreResources && ignoreResources.has(strResource)) {
        continue;
      }
      const editStack = this._editStacks.get(strResource);
      editStack.splitPastWorkspaceElement(toRemove, individualMap);
    }
  }
  _splitFutureWorkspaceElement(toRemove, ignoreResources) {
    const individualArr = toRemove.actual.split();
    const individualMap = new Map();
    for (const _element of individualArr) {
      const resourceLabel = getResourceLabel(_element.resource);
      const strResource = this.getUriComparisonKey(_element.resource);
      const element = new ResourceStackElement(_element, resourceLabel, strResource);
      individualMap.set(element.strResource, element);
    }
    for (const strResource of toRemove.strResources) {
      if (ignoreResources && ignoreResources.has(strResource)) {
        continue;
      }
      const editStack = this._editStacks.get(strResource);
      editStack.splitFutureWorkspaceElement(toRemove, individualMap);
    }
  }
  removeElements(resource) {
    const strResource = typeof resource === "string" ? resource : this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      editStack.dispose();
      this._editStacks.delete(strResource);
    }
    if (DEBUG2) {
      this._print("removeElements");
    }
  }
  setElementsValidFlag(resource, isValid, filter) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      editStack.setElementsValidFlag(isValid, filter);
    }
    if (DEBUG2) {
      this._print("setElementsValidFlag");
    }
  }
  createSnapshot(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.createSnapshot(resource);
    }
    return new ResourceEditStackSnapshot(resource, []);
  }
  restoreSnapshot(snapshot) {
    const strResource = this.getUriComparisonKey(snapshot.resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      editStack.restoreSnapshot(snapshot);
      if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {
        editStack.dispose();
        this._editStacks.delete(strResource);
      }
    }
    if (DEBUG2) {
      this._print("restoreSnapshot");
    }
  }
  getElements(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.getElements();
    }
    return {past: [], future: []};
  }
  canUndo(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.hasPastElements();
    }
    return false;
  }
  _onError(err, element) {
    onUnexpectedError(err);
    for (const strResource of element.strResources) {
      this.removeElements(strResource);
    }
    this._notificationService.error(err);
  }
  _acquireLocks(editStackSnapshot) {
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.locked) {
        throw new Error("Cannot acquire edit stack lock");
      }
    }
    for (const editStack of editStackSnapshot.editStacks) {
      editStack.locked = true;
    }
    return () => {
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.locked = false;
      }
    };
  }
  _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup = Disposable.None) {
    const releaseLocks = this._acquireLocks(editStackSnapshot);
    let result;
    try {
      result = invoke();
    } catch (err) {
      releaseLocks();
      cleanup.dispose();
      return this._onError(err, element);
    }
    if (result) {
      return result.then(() => {
        releaseLocks();
        cleanup.dispose();
      }, (err) => {
        releaseLocks();
        cleanup.dispose();
        return this._onError(err, element);
      });
    } else {
      releaseLocks();
      cleanup.dispose();
    }
  }
  _invokeWorkspacePrepare(element) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (typeof element.actual.prepareUndoRedo === "undefined") {
        return Disposable.None;
      }
      const result = element.actual.prepareUndoRedo();
      if (typeof result === "undefined") {
        return Disposable.None;
      }
      return result;
    });
  }
  _invokeResourcePrepare(element, callback) {
    if (element.actual.type !== 1 || typeof element.actual.prepareUndoRedo === "undefined") {
      callback(Disposable.None);
      return;
    }
    const r = element.actual.prepareUndoRedo();
    if (!r) {
      callback(Disposable.None);
      return;
    }
    if (isDisposable(r)) {
      callback(r);
      return;
    }
    return r.then((disposable) => {
      callback(disposable);
    });
  }
  _getAffectedEditStacks(element) {
    const affectedEditStacks = [];
    for (const strResource of element.strResources) {
      affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);
    }
    return new EditStackSnapshot(affectedEditStacks);
  }
  _tryToSplitAndUndo(strResource, element, ignoreResources, message) {
    if (element.canSplit()) {
      this._splitPastWorkspaceElement(element, ignoreResources);
      this._notificationService.info(message);
      return new WorkspaceVerificationError(this.undo(strResource));
    } else {
      for (const strResource2 of element.strResources) {
        this.removeElements(strResource2);
      }
      this._notificationService.info(message);
      return new WorkspaceVerificationError();
    }
  }
  _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {
    if (element.removedResources) {
      return this._tryToSplitAndUndo(strResource, element, element.removedResources, localize({key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."]}, "Could not undo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
    }
    if (checkInvalidatedResources && element.invalidatedResources) {
      return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, localize({key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."]}, "Could not undo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
    }
    const cannotUndoDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.getClosestPastElement() !== element) {
        cannotUndoDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotUndoDueToResources.length > 0) {
      return this._tryToSplitAndUndo(strResource, element, null, localize({key: "cannotWorkspaceUndoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."]}, "Could not undo '{0}' across all files because changes were made to {1}", element.label, cannotUndoDueToResources.join(", ")));
    }
    const cannotLockDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.locked) {
        cannotLockDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotLockDueToResources.length > 0) {
      return this._tryToSplitAndUndo(strResource, element, null, localize({key: "cannotWorkspaceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."]}, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, cannotLockDueToResources.join(", ")));
    }
    if (!editStackSnapshot.isValid()) {
      return this._tryToSplitAndUndo(strResource, element, null, localize({key: "cannotWorkspaceUndoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."]}, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
    }
    return null;
  }
  _workspaceUndo(strResource, element) {
    const affectedEditStacks = this._getAffectedEditStacks(element);
    const verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks, false);
    if (verificationError) {
      return verificationError.returnValue;
    }
    return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks);
  }
  _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (element.canSplit()) {
        const result = yield this._dialogService.show(severity_default.Info, localize("confirmWorkspace", "Would you like to undo '{0}' across all files?", element.label), [
          localize({key: "ok", comment: ["{0} denotes a number that is > 1"]}, "Undo in {0} Files", editStackSnapshot.editStacks.length),
          localize("nok", "Undo this File"),
          localize("cancel", "Cancel")
        ], {
          cancelId: 2
        });
        if (result.choice === 2) {
          return;
        }
        if (result.choice === 1) {
          this._splitPastWorkspaceElement(element, null);
          return this.undo(strResource);
        }
        const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, false);
        if (verificationError1) {
          return verificationError1.returnValue;
        }
      }
      let cleanup;
      try {
        cleanup = yield this._invokeWorkspacePrepare(element);
      } catch (err) {
        return this._onError(err, element);
      }
      const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, true);
      if (verificationError2) {
        cleanup.dispose();
        return verificationError2.returnValue;
      }
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.moveBackward(element);
      }
      return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup);
    });
  }
  _resourceUndo(editStack, element) {
    if (!element.isValid) {
      editStack.flushAllElements();
      return;
    }
    if (editStack.locked) {
      const message = localize({key: "cannotResourceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."]}, "Could not undo '{0}' because there is already an undo or redo operation running.", element.label);
      this._notificationService.info(message);
      return;
    }
    return this._invokeResourcePrepare(element, (cleanup) => {
      editStack.moveBackward(element);
      return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup);
    });
  }
  undo(resource) {
    const strResource = typeof resource === "string" ? resource : this.getUriComparisonKey(resource);
    if (!this._editStacks.has(strResource)) {
      return;
    }
    const editStack = this._editStacks.get(strResource);
    const element = editStack.getClosestPastElement();
    if (!element) {
      return;
    }
    try {
      if (element.type === 1) {
        return this._workspaceUndo(strResource, element);
      } else {
        return this._resourceUndo(editStack, element);
      }
    } finally {
      if (DEBUG2) {
        this._print("undo");
      }
    }
  }
  canRedo(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.hasFutureElements();
    }
    return false;
  }
  _tryToSplitAndRedo(strResource, element, ignoreResources, message) {
    if (element.canSplit()) {
      this._splitFutureWorkspaceElement(element, ignoreResources);
      this._notificationService.info(message);
      return new WorkspaceVerificationError(this.redo(strResource));
    } else {
      for (const strResource2 of element.strResources) {
        this.removeElements(strResource2);
      }
      this._notificationService.info(message);
      return new WorkspaceVerificationError();
    }
  }
  _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {
    if (element.removedResources) {
      return this._tryToSplitAndRedo(strResource, element, element.removedResources, localize({key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."]}, "Could not redo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
    }
    if (checkInvalidatedResources && element.invalidatedResources) {
      return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, localize({key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."]}, "Could not redo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
    }
    const cannotRedoDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.getClosestFutureElement() !== element) {
        cannotRedoDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotRedoDueToResources.length > 0) {
      return this._tryToSplitAndRedo(strResource, element, null, localize({key: "cannotWorkspaceRedoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."]}, "Could not redo '{0}' across all files because changes were made to {1}", element.label, cannotRedoDueToResources.join(", ")));
    }
    const cannotLockDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.locked) {
        cannotLockDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotLockDueToResources.length > 0) {
      return this._tryToSplitAndRedo(strResource, element, null, localize({key: "cannotWorkspaceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."]}, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, cannotLockDueToResources.join(", ")));
    }
    if (!editStackSnapshot.isValid()) {
      return this._tryToSplitAndRedo(strResource, element, null, localize({key: "cannotWorkspaceRedoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."]}, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
    }
    return null;
  }
  _workspaceRedo(strResource, element) {
    const affectedEditStacks = this._getAffectedEditStacks(element);
    const verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks, false);
    if (verificationError) {
      return verificationError.returnValue;
    }
    return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);
  }
  _executeWorkspaceRedo(strResource, element, editStackSnapshot) {
    return __awaiter10(this, void 0, void 0, function* () {
      let cleanup;
      try {
        cleanup = yield this._invokeWorkspacePrepare(element);
      } catch (err) {
        return this._onError(err, element);
      }
      const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, true);
      if (verificationError) {
        cleanup.dispose();
        return verificationError.returnValue;
      }
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.moveForward(element);
      }
      return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup);
    });
  }
  _resourceRedo(editStack, element) {
    if (!element.isValid) {
      editStack.flushAllElements();
      return;
    }
    if (editStack.locked) {
      const message = localize({key: "cannotResourceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."]}, "Could not redo '{0}' because there is already an undo or redo operation running.", element.label);
      this._notificationService.info(message);
      return;
    }
    return this._invokeResourcePrepare(element, (cleanup) => {
      editStack.moveForward(element);
      return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup);
    });
  }
  redo(resource) {
    const strResource = typeof resource === "string" ? resource : this.getUriComparisonKey(resource);
    if (!this._editStacks.has(strResource)) {
      return;
    }
    const editStack = this._editStacks.get(strResource);
    const element = editStack.getClosestFutureElement();
    if (!element) {
      return;
    }
    try {
      if (element.type === 1) {
        return this._workspaceRedo(strResource, element);
      } else {
        return this._resourceRedo(editStack, element);
      }
    } finally {
      if (DEBUG2) {
        this._print("redo");
      }
    }
  }
};
UndoRedoService = __decorate21([
  __param17(0, IDialogService),
  __param17(1, INotificationService)
], UndoRedoService);
var WorkspaceVerificationError = class {
  constructor(returnValue) {
    this.returnValue = returnValue;
  }
};
registerSingleton(IUndoRedoService, UndoRedoService);

// ../../node_modules/monaco-editor/esm/vs/base/parts/quickinput/common/quickInput.js
var NO_KEY_MODS = {ctrlCmd: false, alt: false};
var ItemActivation;
(function(ItemActivation2) {
  ItemActivation2[ItemActivation2["NONE"] = 0] = "NONE";
  ItemActivation2[ItemActivation2["FIRST"] = 1] = "FIRST";
  ItemActivation2[ItemActivation2["SECOND"] = 2] = "SECOND";
  ItemActivation2[ItemActivation2["LAST"] = 3] = "LAST";
})(ItemActivation || (ItemActivation = {}));

// ../../node_modules/monaco-editor/esm/vs/base/common/comparers.js
var intlFileNameCollatorBaseNumeric = new IdleValue(() => {
  const collator = new Intl.Collator(void 0, {numeric: true, sensitivity: "base"});
  return {
    collator,
    collatorIsNumeric: collator.resolvedOptions().numeric
  };
});
function compareFileNames(one, other, caseSensitive = false) {
  const a = one || "";
  const b = other || "";
  const result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);
  if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {
    return a < b ? -1 : 1;
  }
  return result;
}
function compareAnything(one, other, lookFor) {
  const elementAName = one.toLowerCase();
  const elementBName = other.toLowerCase();
  const prefixCompare = compareByPrefix(one, other, lookFor);
  if (prefixCompare) {
    return prefixCompare;
  }
  const elementASuffixMatch = elementAName.endsWith(lookFor);
  const elementBSuffixMatch = elementBName.endsWith(lookFor);
  if (elementASuffixMatch !== elementBSuffixMatch) {
    return elementASuffixMatch ? -1 : 1;
  }
  const r = compareFileNames(elementAName, elementBName);
  if (r !== 0) {
    return r;
  }
  return elementAName.localeCompare(elementBName);
}
function compareByPrefix(one, other, lookFor) {
  const elementAName = one.toLowerCase();
  const elementBName = other.toLowerCase();
  const elementAPrefixMatch = elementAName.startsWith(lookFor);
  const elementBPrefixMatch = elementBName.startsWith(lookFor);
  if (elementAPrefixMatch !== elementBPrefixMatch) {
    return elementAPrefixMatch ? -1 : 1;
  } else if (elementAPrefixMatch && elementBPrefixMatch) {
    if (elementAName.length < elementBName.length) {
      return -1;
    }
    if (elementAName.length > elementBName.length) {
      return 1;
    }
  }
  return 0;
}

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/highlightedlabel/highlightedLabel.js
var HighlightedLabel = class {
  constructor(container, supportCodicons) {
    this.supportCodicons = supportCodicons;
    this.text = "";
    this.title = "";
    this.highlights = [];
    this.didEverRender = false;
    this.domNode = document.createElement("span");
    this.domNode.className = "monaco-highlighted-label";
    container.appendChild(this.domNode);
  }
  get element() {
    return this.domNode;
  }
  set(text, highlights = [], title = "", escapeNewLines) {
    if (!text) {
      text = "";
    }
    if (escapeNewLines) {
      text = HighlightedLabel.escapeNewLines(text, highlights);
    }
    if (this.didEverRender && this.text === text && this.title === title && equals2(this.highlights, highlights)) {
      return;
    }
    if (!Array.isArray(highlights)) {
      highlights = [];
    }
    this.text = text;
    this.title = title;
    this.highlights = highlights;
    this.render();
  }
  render() {
    let htmlContent = "";
    let pos = 0;
    for (const highlight of this.highlights) {
      if (highlight.end === highlight.start) {
        continue;
      }
      if (pos < highlight.start) {
        htmlContent += "<span>";
        const substring2 = this.text.substring(pos, highlight.start);
        htmlContent += this.supportCodicons ? renderCodicons(escape(substring2)) : escape(substring2);
        htmlContent += "</span>";
        pos = highlight.end;
      }
      if (highlight.extraClasses) {
        htmlContent += `<span class="highlight ${highlight.extraClasses}">`;
      } else {
        htmlContent += `<span class="highlight">`;
      }
      const substring = this.text.substring(highlight.start, highlight.end);
      htmlContent += this.supportCodicons ? renderCodicons(escape(substring)) : escape(substring);
      htmlContent += "</span>";
      pos = highlight.end;
    }
    if (pos < this.text.length) {
      htmlContent += "<span>";
      const substring = this.text.substring(pos);
      htmlContent += this.supportCodicons ? renderCodicons(escape(substring)) : escape(substring);
      htmlContent += "</span>";
    }
    this.domNode.innerHTML = htmlContent;
    if (this.title) {
      this.domNode.title = this.title;
    } else {
      this.domNode.removeAttribute("title");
    }
    this.didEverRender = true;
  }
  static escapeNewLines(text, highlights) {
    let total = 0;
    let extra = 0;
    return text.replace(/\r\n|\r|\n/g, (match2, offset) => {
      extra = match2 === "\r\n" ? -1 : 0;
      offset += total;
      for (const highlight of highlights) {
        if (highlight.end <= offset) {
          continue;
        }
        if (highlight.start >= offset) {
          highlight.start += extra;
        }
        if (highlight.end >= offset) {
          highlight.end += extra;
        }
      }
      total += extra;
      return "\u23CE";
    });
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabel.js
var FastLabelNode = class {
  constructor(_element) {
    this._element = _element;
  }
  get element() {
    return this._element;
  }
  set textContent(content) {
    if (this.disposed || content === this._textContent) {
      return;
    }
    this._textContent = content;
    this._element.textContent = content;
  }
  set className(className) {
    if (this.disposed || className === this._className) {
      return;
    }
    this._className = className;
    this._element.className = className;
  }
  set title(title) {
    if (this.disposed || title === this._title) {
      return;
    }
    this._title = title;
    if (this._title) {
      this._element.title = title;
    } else {
      this._element.removeAttribute("title");
    }
  }
  set empty(empty2) {
    if (this.disposed || empty2 === this._empty) {
      return;
    }
    this._empty = empty2;
    this._element.style.marginLeft = empty2 ? "0" : "";
  }
  dispose() {
    this.disposed = true;
  }
};
var IconLabel = class extends Disposable {
  constructor(container, options) {
    super();
    this.domNode = this._register(new FastLabelNode(append(container, $(".monaco-icon-label"))));
    const labelContainer = append(this.domNode.element, $(".monaco-icon-label-container"));
    const nameContainer = append(labelContainer, $("span.monaco-icon-name-container"));
    this.descriptionContainer = this._register(new FastLabelNode(append(labelContainer, $("span.monaco-icon-description-container"))));
    if (options === null || options === void 0 ? void 0 : options.supportHighlights) {
      this.nameNode = new LabelWithHighlights(nameContainer, !!options.supportCodicons);
    } else {
      this.nameNode = new Label(nameContainer);
    }
    if (options === null || options === void 0 ? void 0 : options.supportDescriptionHighlights) {
      this.descriptionNodeFactory = () => new HighlightedLabel(append(this.descriptionContainer.element, $("span.label-description")), !!options.supportCodicons);
    } else {
      this.descriptionNodeFactory = () => this._register(new FastLabelNode(append(this.descriptionContainer.element, $("span.label-description"))));
    }
  }
  setLabel(label, description, options) {
    const classes = ["monaco-icon-label"];
    if (options) {
      if (options.extraClasses) {
        classes.push(...options.extraClasses);
      }
      if (options.italic) {
        classes.push("italic");
      }
      if (options.strikethrough) {
        classes.push("strikethrough");
      }
    }
    this.domNode.className = classes.join(" ");
    this.domNode.title = (options === null || options === void 0 ? void 0 : options.title) || "";
    this.nameNode.setLabel(label, options);
    if (description || this.descriptionNode) {
      if (!this.descriptionNode) {
        this.descriptionNode = this.descriptionNodeFactory();
      }
      if (this.descriptionNode instanceof HighlightedLabel) {
        this.descriptionNode.set(description || "", options ? options.descriptionMatches : void 0);
        if (options === null || options === void 0 ? void 0 : options.descriptionTitle) {
          this.descriptionNode.element.title = options.descriptionTitle;
        } else {
          this.descriptionNode.element.removeAttribute("title");
        }
      } else {
        this.descriptionNode.textContent = description || "";
        this.descriptionNode.title = (options === null || options === void 0 ? void 0 : options.descriptionTitle) || "";
        this.descriptionNode.empty = !description;
      }
    }
  }
};
var Label = class {
  constructor(container) {
    this.container = container;
    this.label = void 0;
    this.singleLabel = void 0;
  }
  setLabel(label, options) {
    if (this.label === label && equals2(this.options, options)) {
      return;
    }
    this.label = label;
    this.options = options;
    if (typeof label === "string") {
      if (!this.singleLabel) {
        this.container.innerText = "";
        removeClass(this.container, "multiple");
        this.singleLabel = append(this.container, $("a.label-name", {id: options === null || options === void 0 ? void 0 : options.domId}));
      }
      this.singleLabel.textContent = label;
    } else {
      this.container.innerText = "";
      addClass(this.container, "multiple");
      this.singleLabel = void 0;
      for (let i = 0; i < label.length; i++) {
        const l = label[i];
        const id = (options === null || options === void 0 ? void 0 : options.domId) && `${options === null || options === void 0 ? void 0 : options.domId}_${i}`;
        append(this.container, $("a.label-name", {id, "data-icon-label-count": label.length, "data-icon-label-index": i, role: "treeitem"}, l));
        if (i < label.length - 1) {
          append(this.container, $("span.label-separator", void 0, (options === null || options === void 0 ? void 0 : options.separator) || "/"));
        }
      }
    }
  }
};
function splitMatches(labels, separator, matches) {
  if (!matches) {
    return void 0;
  }
  let labelStart = 0;
  return labels.map((label) => {
    const labelRange = {start: labelStart, end: labelStart + label.length};
    const result = matches.map((match2) => Range2.intersect(labelRange, match2)).filter((range2) => !Range2.isEmpty(range2)).map(({start, end}) => ({start: start - labelStart, end: end - labelStart}));
    labelStart = labelRange.end + separator.length;
    return result;
  });
}
var LabelWithHighlights = class {
  constructor(container, supportCodicons) {
    this.container = container;
    this.supportCodicons = supportCodicons;
    this.label = void 0;
    this.singleLabel = void 0;
  }
  setLabel(label, options) {
    if (this.label === label && equals2(this.options, options)) {
      return;
    }
    this.label = label;
    this.options = options;
    if (typeof label === "string") {
      if (!this.singleLabel) {
        this.container.innerText = "";
        removeClass(this.container, "multiple");
        this.singleLabel = new HighlightedLabel(append(this.container, $("a.label-name", {id: options === null || options === void 0 ? void 0 : options.domId})), this.supportCodicons);
      }
      this.singleLabel.set(label, options === null || options === void 0 ? void 0 : options.matches, options === null || options === void 0 ? void 0 : options.title, options === null || options === void 0 ? void 0 : options.labelEscapeNewLines);
    } else {
      this.container.innerText = "";
      addClass(this.container, "multiple");
      this.singleLabel = void 0;
      const separator = (options === null || options === void 0 ? void 0 : options.separator) || "/";
      const matches = splitMatches(label, separator, options === null || options === void 0 ? void 0 : options.matches);
      for (let i = 0; i < label.length; i++) {
        const l = label[i];
        const m = matches ? matches[i] : void 0;
        const id = (options === null || options === void 0 ? void 0 : options.domId) && `${options === null || options === void 0 ? void 0 : options.domId}_${i}`;
        const name = $("a.label-name", {id, "data-icon-label-count": label.length, "data-icon-label-index": i, role: "treeitem"});
        const highlightedLabel = new HighlightedLabel(append(this.container, name), this.supportCodicons);
        highlightedLabel.set(l, m, options === null || options === void 0 ? void 0 : options.title, options === null || options === void 0 ? void 0 : options.labelEscapeNewLines);
        if (i < label.length - 1) {
          append(name, $("span.label-separator", void 0, separator));
        }
      }
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/common/idGenerator.js
var IdGenerator = class {
  constructor(prefix) {
    this._prefix = prefix;
    this._lastId = 0;
  }
  nextId() {
    return this._prefix + ++this._lastId;
  }
};
var defaultGenerator = new IdGenerator("id#");

// ../../node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/quickInputUtils.js
var iconPathToClass = {};
var iconClassGenerator = new IdGenerator("quick-input-button-icon-");
function getIconClass(iconPath) {
  if (!iconPath) {
    return void 0;
  }
  let iconClass;
  const key = iconPath.dark.toString();
  if (iconPathToClass[key]) {
    iconClass = iconPathToClass[key];
  } else {
    iconClass = iconClassGenerator.nextId();
    createCSSRule(`.${iconClass}`, `background-image: ${asCSSUrl(iconPath.light || iconPath.dark)}`);
    createCSSRule(`.vs-dark .${iconClass}, .hc-black .${iconClass}`, `background-image: ${asCSSUrl(iconPath.dark)}`);
    iconPathToClass[key] = iconClass;
  }
  return iconClass;
}

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/keybindingLabel/keybindingLabel.js
var $2 = $;
var KeybindingLabel = class {
  constructor(container, os, options) {
    this.os = os;
    this.options = options;
    this.domNode = append(container, $2(".monaco-keybinding"));
    this.didEverRender = false;
    container.appendChild(this.domNode);
  }
  set(keybinding, matches) {
    if (this.didEverRender && this.keybinding === keybinding && KeybindingLabel.areSame(this.matches, matches)) {
      return;
    }
    this.keybinding = keybinding;
    this.matches = matches;
    this.render();
  }
  render() {
    clearNode(this.domNode);
    if (this.keybinding) {
      let [firstPart, chordPart] = this.keybinding.getParts();
      if (firstPart) {
        this.renderPart(this.domNode, firstPart, this.matches ? this.matches.firstPart : null);
      }
      if (chordPart) {
        append(this.domNode, $2("span.monaco-keybinding-key-chord-separator", void 0, " "));
        this.renderPart(this.domNode, chordPart, this.matches ? this.matches.chordPart : null);
      }
      this.domNode.title = this.keybinding.getAriaLabel() || "";
    } else if (this.options && this.options.renderUnboundKeybindings) {
      this.renderUnbound(this.domNode);
    }
    this.didEverRender = true;
  }
  renderPart(parent, part, match2) {
    const modifierLabels = UILabelProvider.modifierLabels[this.os];
    if (part.ctrlKey) {
      this.renderKey(parent, modifierLabels.ctrlKey, Boolean(match2 === null || match2 === void 0 ? void 0 : match2.ctrlKey), modifierLabels.separator);
    }
    if (part.shiftKey) {
      this.renderKey(parent, modifierLabels.shiftKey, Boolean(match2 === null || match2 === void 0 ? void 0 : match2.shiftKey), modifierLabels.separator);
    }
    if (part.altKey) {
      this.renderKey(parent, modifierLabels.altKey, Boolean(match2 === null || match2 === void 0 ? void 0 : match2.altKey), modifierLabels.separator);
    }
    if (part.metaKey) {
      this.renderKey(parent, modifierLabels.metaKey, Boolean(match2 === null || match2 === void 0 ? void 0 : match2.metaKey), modifierLabels.separator);
    }
    const keyLabel = part.keyLabel;
    if (keyLabel) {
      this.renderKey(parent, keyLabel, Boolean(match2 === null || match2 === void 0 ? void 0 : match2.keyCode), "");
    }
  }
  renderKey(parent, label, highlight, separator) {
    append(parent, $2("span.monaco-keybinding-key" + (highlight ? ".highlight" : ""), void 0, label));
    if (separator) {
      append(parent, $2("span.monaco-keybinding-key-separator", void 0, separator));
    }
  }
  renderUnbound(parent) {
    append(parent, $2("span.monaco-keybinding-key", void 0, localize("unbound", "Unbound")));
  }
  static areSame(a, b) {
    if (a === b || !a && !b) {
      return true;
    }
    return !!a && !!b && equals2(a.firstPart, b.firstPart) && equals2(a.chordPart, b.chordPart);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/quickInputList.js
var __decorate22 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var $3 = $;
var ListElement = class {
  constructor(init) {
    this.hidden = false;
    this._onChecked = new Emitter();
    this.onChecked = this._onChecked.event;
    assign(this, init);
  }
  get checked() {
    return !!this._checked;
  }
  set checked(value) {
    if (value !== this._checked) {
      this._checked = value;
      this._onChecked.fire(value);
    }
  }
  dispose() {
    this._onChecked.dispose();
  }
};
var ListElementRenderer = class {
  get templateId() {
    return ListElementRenderer.ID;
  }
  renderTemplate(container) {
    const data = Object.create(null);
    data.toDisposeElement = [];
    data.toDisposeTemplate = [];
    data.entry = append(container, $3(".quick-input-list-entry"));
    const label = append(data.entry, $3("label.quick-input-list-label"));
    data.toDisposeTemplate.push(addStandardDisposableListener(label, EventType.CLICK, (e) => {
      if (!data.checkbox.offsetParent) {
        e.preventDefault();
      }
    }));
    data.checkbox = append(label, $3("input.quick-input-list-checkbox"));
    data.checkbox.type = "checkbox";
    data.toDisposeTemplate.push(addStandardDisposableListener(data.checkbox, EventType.CHANGE, (e) => {
      data.element.checked = data.checkbox.checked;
    }));
    const rows = append(label, $3(".quick-input-list-rows"));
    const row1 = append(rows, $3(".quick-input-list-row"));
    const row2 = append(rows, $3(".quick-input-list-row"));
    data.label = new IconLabel(row1, {supportHighlights: true, supportDescriptionHighlights: true, supportCodicons: true});
    const keybindingContainer = append(row1, $3(".quick-input-list-entry-keybinding"));
    data.keybinding = new KeybindingLabel(keybindingContainer, OS);
    const detailContainer = append(row2, $3(".quick-input-list-label-meta"));
    data.detail = new HighlightedLabel(detailContainer, true);
    data.separator = append(data.entry, $3(".quick-input-list-separator"));
    data.actionBar = new ActionBar(data.entry);
    data.actionBar.domNode.classList.add("quick-input-list-entry-action-bar");
    data.toDisposeTemplate.push(data.actionBar);
    return data;
  }
  renderElement(element, index, data) {
    data.toDisposeElement = dispose(data.toDisposeElement);
    data.element = element;
    data.checkbox.checked = element.checked;
    data.toDisposeElement.push(element.onChecked((checked) => data.checkbox.checked = checked));
    const {labelHighlights, descriptionHighlights, detailHighlights} = element;
    const options = Object.create(null);
    options.matches = labelHighlights || [];
    options.descriptionTitle = element.saneDescription;
    options.descriptionMatches = descriptionHighlights || [];
    options.extraClasses = element.item.iconClasses;
    options.italic = element.item.italic;
    options.strikethrough = element.item.strikethrough;
    data.label.setLabel(element.saneLabel, element.saneDescription, options);
    data.keybinding.set(element.item.keybinding);
    data.detail.set(element.saneDetail, detailHighlights);
    if (element.separator && element.separator.label) {
      data.separator.textContent = element.separator.label;
      data.separator.style.display = "";
    } else {
      data.separator.style.display = "none";
    }
    if (element.separator) {
      addClass(data.entry, "quick-input-list-separator-border");
    } else {
      removeClass(data.entry, "quick-input-list-separator-border");
    }
    data.actionBar.clear();
    const buttons = element.item.buttons;
    if (buttons && buttons.length) {
      data.actionBar.push(buttons.map((button, index2) => {
        let cssClasses = button.iconClass || (button.iconPath ? getIconClass(button.iconPath) : void 0);
        if (button.alwaysVisible) {
          cssClasses = cssClasses ? `${cssClasses} always-visible` : "always-visible";
        }
        const action = new Action(`id-${index2}`, "", cssClasses, true, () => {
          element.fireButtonTriggered({
            button,
            item: element.item
          });
          return Promise.resolve();
        });
        action.tooltip = button.tooltip || "";
        return action;
      }), {icon: true, label: false});
      addClass(data.entry, "has-actions");
    } else {
      removeClass(data.entry, "has-actions");
    }
  }
  disposeElement(element, index, data) {
    data.toDisposeElement = dispose(data.toDisposeElement);
  }
  disposeTemplate(data) {
    data.toDisposeElement = dispose(data.toDisposeElement);
    data.toDisposeTemplate = dispose(data.toDisposeTemplate);
  }
};
ListElementRenderer.ID = "listelement";
var ListElementDelegate = class {
  getHeight(element) {
    return element.saneDetail ? 44 : 22;
  }
  getTemplateId(element) {
    return ListElementRenderer.ID;
  }
};
var QuickInputListFocus;
(function(QuickInputListFocus2) {
  QuickInputListFocus2[QuickInputListFocus2["First"] = 1] = "First";
  QuickInputListFocus2[QuickInputListFocus2["Second"] = 2] = "Second";
  QuickInputListFocus2[QuickInputListFocus2["Last"] = 3] = "Last";
  QuickInputListFocus2[QuickInputListFocus2["Next"] = 4] = "Next";
  QuickInputListFocus2[QuickInputListFocus2["Previous"] = 5] = "Previous";
  QuickInputListFocus2[QuickInputListFocus2["NextPage"] = 6] = "NextPage";
  QuickInputListFocus2[QuickInputListFocus2["PreviousPage"] = 7] = "PreviousPage";
})(QuickInputListFocus || (QuickInputListFocus = {}));
var QuickInputList = class {
  constructor(parent, id, options) {
    this.parent = parent;
    this.inputElements = [];
    this.elements = [];
    this.elementsToIndexes = new Map();
    this.matchOnDescription = false;
    this.matchOnDetail = false;
    this.matchOnLabel = true;
    this.sortByLabel = true;
    this._onChangedAllVisibleChecked = new Emitter();
    this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event;
    this._onChangedCheckedCount = new Emitter();
    this.onChangedCheckedCount = this._onChangedCheckedCount.event;
    this._onChangedVisibleCount = new Emitter();
    this.onChangedVisibleCount = this._onChangedVisibleCount.event;
    this._onChangedCheckedElements = new Emitter();
    this.onChangedCheckedElements = this._onChangedCheckedElements.event;
    this._onButtonTriggered = new Emitter();
    this.onButtonTriggered = this._onButtonTriggered.event;
    this._onKeyDown = new Emitter();
    this.onKeyDown = this._onKeyDown.event;
    this._onLeave = new Emitter();
    this.onLeave = this._onLeave.event;
    this._fireCheckedEvents = true;
    this.elementDisposables = [];
    this.disposables = [];
    this.id = id;
    this.container = append(this.parent, $3(".quick-input-list"));
    const delegate = new ListElementDelegate();
    const accessibilityProvider = new QuickInputAccessibilityProvider();
    this.list = options.createList("QuickInput", this.container, delegate, [new ListElementRenderer()], {
      identityProvider: {getId: (element) => element.saneLabel},
      setRowLineHeight: false,
      multipleSelectionSupport: false,
      horizontalScrolling: false,
      accessibilityProvider
    });
    this.list.getHTMLElement().id = id;
    this.disposables.push(this.list);
    this.disposables.push(this.list.onKeyDown((e) => {
      const event = new StandardKeyboardEvent(e);
      switch (event.keyCode) {
        case 10:
          this.toggleCheckbox();
          break;
        case 31:
          if (isMacintosh ? e.metaKey : e.ctrlKey) {
            this.list.setFocus(range(this.list.length));
          }
          break;
        case 16:
          const focus1 = this.list.getFocus();
          if (focus1.length === 1 && focus1[0] === 0) {
            this._onLeave.fire();
          }
          break;
        case 18:
          const focus2 = this.list.getFocus();
          if (focus2.length === 1 && focus2[0] === this.list.length - 1) {
            this._onLeave.fire();
          }
          break;
      }
      this._onKeyDown.fire(event);
    }));
    this.disposables.push(this.list.onMouseDown((e) => {
      if (e.browserEvent.button !== 2) {
        e.browserEvent.preventDefault();
      }
    }));
    this.disposables.push(addDisposableListener(this.container, EventType.CLICK, (e) => {
      if (e.x || e.y) {
        this._onLeave.fire();
      }
    }));
    this.disposables.push(this.list.onMouseMiddleClick((e) => {
      this._onLeave.fire();
    }));
    this.disposables.push(this.list.onContextMenu((e) => {
      if (typeof e.index === "number") {
        e.browserEvent.preventDefault();
        this.list.setSelection([e.index]);
      }
    }));
    this.disposables.push(this._onChangedAllVisibleChecked, this._onChangedCheckedCount, this._onChangedVisibleCount, this._onChangedCheckedElements, this._onButtonTriggered, this._onLeave, this._onKeyDown);
  }
  get onDidChangeFocus() {
    return Event.map(this.list.onDidChangeFocus, (e) => e.elements.map((e2) => e2.item));
  }
  get onDidChangeSelection() {
    return Event.map(this.list.onDidChangeSelection, (e) => ({items: e.elements.map((e2) => e2.item), event: e.browserEvent}));
  }
  getAllVisibleChecked() {
    return this.allVisibleChecked(this.elements, false);
  }
  allVisibleChecked(elements, whenNoneVisible = true) {
    for (let i = 0, n = elements.length; i < n; i++) {
      const element = elements[i];
      if (!element.hidden) {
        if (!element.checked) {
          return false;
        } else {
          whenNoneVisible = true;
        }
      }
    }
    return whenNoneVisible;
  }
  getCheckedCount() {
    let count = 0;
    const elements = this.elements;
    for (let i = 0, n = elements.length; i < n; i++) {
      if (elements[i].checked) {
        count++;
      }
    }
    return count;
  }
  getVisibleCount() {
    let count = 0;
    const elements = this.elements;
    for (let i = 0, n = elements.length; i < n; i++) {
      if (!elements[i].hidden) {
        count++;
      }
    }
    return count;
  }
  setAllVisibleChecked(checked) {
    try {
      this._fireCheckedEvents = false;
      this.elements.forEach((element) => {
        if (!element.hidden) {
          element.checked = checked;
        }
      });
    } finally {
      this._fireCheckedEvents = true;
      this.fireCheckedEvents();
    }
  }
  setElements(inputElements) {
    this.elementDisposables = dispose(this.elementDisposables);
    const fireButtonTriggered = (event) => this.fireButtonTriggered(event);
    this.inputElements = inputElements;
    this.elements = inputElements.reduce((result, item, index) => {
      var _a, _b, _c;
      if (item.type !== "separator") {
        const previous = index && inputElements[index - 1];
        const saneLabel = item.label && item.label.replace(/\r?\n/g, " ");
        const saneDescription = item.description && item.description.replace(/\r?\n/g, " ");
        const saneDetail = item.detail && item.detail.replace(/\r?\n/g, " ");
        const saneAriaLabel = item.ariaLabel || [saneLabel, saneDescription, saneDetail].map((s) => s && parseCodicons(s).text).filter((s) => !!s).join(", ");
        result.push(new ListElement({
          index,
          item,
          saneLabel,
          saneAriaLabel,
          saneDescription,
          saneDetail,
          labelHighlights: (_a = item.highlights) === null || _a === void 0 ? void 0 : _a.label,
          descriptionHighlights: (_b = item.highlights) === null || _b === void 0 ? void 0 : _b.description,
          detailHighlights: (_c = item.highlights) === null || _c === void 0 ? void 0 : _c.detail,
          checked: false,
          separator: previous && previous.type === "separator" ? previous : void 0,
          fireButtonTriggered
        }));
      }
      return result;
    }, []);
    this.elementDisposables.push(...this.elements);
    this.elementDisposables.push(...this.elements.map((element) => element.onChecked(() => this.fireCheckedEvents())));
    this.elementsToIndexes = this.elements.reduce((map, element, index) => {
      map.set(element.item, index);
      return map;
    }, new Map());
    this.list.splice(0, this.list.length);
    this.list.splice(0, this.list.length, this.elements);
    this._onChangedVisibleCount.fire(this.elements.length);
  }
  getFocusedElements() {
    return this.list.getFocusedElements().map((e) => e.item);
  }
  setFocusedElements(items) {
    this.list.setFocus(items.filter((item) => this.elementsToIndexes.has(item)).map((item) => this.elementsToIndexes.get(item)));
    if (items.length > 0) {
      const focused = this.list.getFocus()[0];
      if (typeof focused === "number") {
        this.list.reveal(focused);
      }
    }
  }
  getActiveDescendant() {
    return this.list.getHTMLElement().getAttribute("aria-activedescendant");
  }
  setSelectedElements(items) {
    this.list.setSelection(items.filter((item) => this.elementsToIndexes.has(item)).map((item) => this.elementsToIndexes.get(item)));
  }
  getCheckedElements() {
    return this.elements.filter((e) => e.checked).map((e) => e.item);
  }
  setCheckedElements(items) {
    try {
      this._fireCheckedEvents = false;
      const checked = new Set();
      for (const item of items) {
        checked.add(item);
      }
      for (const element of this.elements) {
        element.checked = checked.has(element.item);
      }
    } finally {
      this._fireCheckedEvents = true;
      this.fireCheckedEvents();
    }
  }
  set enabled(value) {
    this.list.getHTMLElement().style.pointerEvents = value ? "" : "none";
  }
  focus(what) {
    if (!this.list.length) {
      return;
    }
    if (what === QuickInputListFocus.Next && this.list.getFocus()[0] === this.list.length - 1) {
      what = QuickInputListFocus.First;
    }
    if (what === QuickInputListFocus.Previous && this.list.getFocus()[0] === 0) {
      what = QuickInputListFocus.Last;
    }
    if (what === QuickInputListFocus.Second && this.list.length < 2) {
      what = QuickInputListFocus.First;
    }
    switch (what) {
      case QuickInputListFocus.First:
        this.list.focusFirst();
        break;
      case QuickInputListFocus.Second:
        this.list.focusNth(1);
        break;
      case QuickInputListFocus.Last:
        this.list.focusLast();
        break;
      case QuickInputListFocus.Next:
        this.list.focusNext();
        break;
      case QuickInputListFocus.Previous:
        this.list.focusPrevious();
        break;
      case QuickInputListFocus.NextPage:
        this.list.focusNextPage();
        break;
      case QuickInputListFocus.PreviousPage:
        this.list.focusPreviousPage();
        break;
    }
    const focused = this.list.getFocus()[0];
    if (typeof focused === "number") {
      this.list.reveal(focused);
    }
  }
  clearFocus() {
    this.list.setFocus([]);
  }
  domFocus() {
    this.list.domFocus();
  }
  layout(maxHeight) {
    this.list.getHTMLElement().style.maxHeight = maxHeight ? `calc(${Math.floor(maxHeight / 44) * 44}px)` : "";
    this.list.layout();
  }
  filter(query) {
    if (!(this.sortByLabel || this.matchOnLabel || this.matchOnDescription || this.matchOnDetail)) {
      this.list.layout();
      return false;
    }
    query = query.trim();
    if (!query || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail)) {
      this.elements.forEach((element) => {
        element.labelHighlights = void 0;
        element.descriptionHighlights = void 0;
        element.detailHighlights = void 0;
        element.hidden = false;
        const previous = element.index && this.inputElements[element.index - 1];
        element.separator = previous && previous.type === "separator" ? previous : void 0;
      });
    } else {
      this.elements.forEach((element) => {
        const labelHighlights = this.matchOnLabel ? withNullAsUndefined(matchesFuzzyCodiconAware(query, parseCodicons(element.saneLabel))) : void 0;
        const descriptionHighlights = this.matchOnDescription ? withNullAsUndefined(matchesFuzzyCodiconAware(query, parseCodicons(element.saneDescription || ""))) : void 0;
        const detailHighlights = this.matchOnDetail ? withNullAsUndefined(matchesFuzzyCodiconAware(query, parseCodicons(element.saneDetail || ""))) : void 0;
        if (labelHighlights || descriptionHighlights || detailHighlights) {
          element.labelHighlights = labelHighlights;
          element.descriptionHighlights = descriptionHighlights;
          element.detailHighlights = detailHighlights;
          element.hidden = false;
        } else {
          element.labelHighlights = void 0;
          element.descriptionHighlights = void 0;
          element.detailHighlights = void 0;
          element.hidden = !element.item.alwaysShow;
        }
        element.separator = void 0;
      });
    }
    const shownElements = this.elements.filter((element) => !element.hidden);
    if (this.sortByLabel && query) {
      const normalizedSearchValue = query.toLowerCase();
      shownElements.sort((a, b) => {
        return compareEntries(a, b, normalizedSearchValue);
      });
    }
    this.elementsToIndexes = shownElements.reduce((map, element, index) => {
      map.set(element.item, index);
      return map;
    }, new Map());
    this.list.splice(0, this.list.length, shownElements);
    this.list.setFocus([]);
    this.list.layout();
    this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());
    this._onChangedVisibleCount.fire(shownElements.length);
    return true;
  }
  toggleCheckbox() {
    try {
      this._fireCheckedEvents = false;
      const elements = this.list.getFocusedElements();
      const allChecked = this.allVisibleChecked(elements);
      for (const element of elements) {
        element.checked = !allChecked;
      }
    } finally {
      this._fireCheckedEvents = true;
      this.fireCheckedEvents();
    }
  }
  display(display) {
    this.container.style.display = display ? "" : "none";
  }
  isDisplayed() {
    return this.container.style.display !== "none";
  }
  dispose() {
    this.elementDisposables = dispose(this.elementDisposables);
    this.disposables = dispose(this.disposables);
  }
  fireCheckedEvents() {
    if (this._fireCheckedEvents) {
      this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());
      this._onChangedCheckedCount.fire(this.getCheckedCount());
      this._onChangedCheckedElements.fire(this.getCheckedElements());
    }
  }
  fireButtonTriggered(event) {
    this._onButtonTriggered.fire(event);
  }
  style(styles) {
    this.list.style(styles);
  }
};
__decorate22([
  memoize
], QuickInputList.prototype, "onDidChangeFocus", null);
__decorate22([
  memoize
], QuickInputList.prototype, "onDidChangeSelection", null);
function compareEntries(elementA, elementB, lookFor) {
  const labelHighlightsA = elementA.labelHighlights || [];
  const labelHighlightsB = elementB.labelHighlights || [];
  if (labelHighlightsA.length && !labelHighlightsB.length) {
    return -1;
  }
  if (!labelHighlightsA.length && labelHighlightsB.length) {
    return 1;
  }
  if (labelHighlightsA.length === 0 && labelHighlightsB.length === 0) {
    return 0;
  }
  return compareAnything(elementA.saneLabel, elementB.saneLabel, lookFor);
}
var QuickInputAccessibilityProvider = class {
  getWidgetAriaLabel() {
    return localize("quickInput", "Quick Input");
  }
  getAriaLabel(element) {
    return element.saneAriaLabel;
  }
  getWidgetRole() {
    return "listbox";
  }
  getRole() {
    return "option";
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/formattedTextRenderer.js
function renderText(text, options = {}) {
  const element = createElement(options);
  element.textContent = text;
  return element;
}
function renderFormattedText(formattedText, options = {}) {
  const element = createElement(options);
  _renderFormattedText(element, parseFormattedText(formattedText), options.actionHandler);
  return element;
}
function createElement(options) {
  const tagName = options.inline ? "span" : "div";
  const element = document.createElement(tagName);
  if (options.className) {
    element.className = options.className;
  }
  return element;
}
var StringStream = class {
  constructor(source) {
    this.source = source;
    this.index = 0;
  }
  eos() {
    return this.index >= this.source.length;
  }
  next() {
    const next = this.peek();
    this.advance();
    return next;
  }
  peek() {
    return this.source[this.index];
  }
  advance() {
    this.index++;
  }
};
function _renderFormattedText(element, treeNode, actionHandler) {
  let child;
  if (treeNode.type === 2) {
    child = document.createTextNode(treeNode.content || "");
  } else if (treeNode.type === 3) {
    child = document.createElement("b");
  } else if (treeNode.type === 4) {
    child = document.createElement("i");
  } else if (treeNode.type === 5 && actionHandler) {
    const a = document.createElement("a");
    a.href = "#";
    actionHandler.disposeables.add(addStandardDisposableListener(a, "click", (event) => {
      actionHandler.callback(String(treeNode.index), event);
    }));
    child = a;
  } else if (treeNode.type === 7) {
    child = document.createElement("br");
  } else if (treeNode.type === 1) {
    child = element;
  }
  if (child && element !== child) {
    element.appendChild(child);
  }
  if (child && Array.isArray(treeNode.children)) {
    treeNode.children.forEach((nodeChild) => {
      _renderFormattedText(child, nodeChild, actionHandler);
    });
  }
}
function parseFormattedText(content) {
  const root = {
    type: 1,
    children: []
  };
  let actionViewItemIndex = 0;
  let current = root;
  const stack = [];
  const stream = new StringStream(content);
  while (!stream.eos()) {
    let next = stream.next();
    const isEscapedFormatType = next === "\\" && formatTagType(stream.peek()) !== 0;
    if (isEscapedFormatType) {
      next = stream.next();
    }
    if (!isEscapedFormatType && isFormatTag(next) && next === stream.peek()) {
      stream.advance();
      if (current.type === 2) {
        current = stack.pop();
      }
      const type = formatTagType(next);
      if (current.type === type || current.type === 5 && type === 6) {
        current = stack.pop();
      } else {
        const newCurrent = {
          type,
          children: []
        };
        if (type === 5) {
          newCurrent.index = actionViewItemIndex;
          actionViewItemIndex++;
        }
        current.children.push(newCurrent);
        stack.push(current);
        current = newCurrent;
      }
    } else if (next === "\n") {
      if (current.type === 2) {
        current = stack.pop();
      }
      current.children.push({
        type: 7
      });
    } else {
      if (current.type !== 2) {
        const textCurrent = {
          type: 2,
          content: next
        };
        current.children.push(textCurrent);
        stack.push(current);
        current = textCurrent;
      } else {
        current.content += next;
      }
    }
  }
  if (current.type === 2) {
    current = stack.pop();
  }
  if (stack.length) {
  }
  return root;
}
function isFormatTag(char) {
  return formatTagType(char) !== 0;
}
function formatTagType(char) {
  switch (char) {
    case "*":
      return 3;
    case "_":
      return 4;
    case "[":
      return 5;
    case "]":
      return 6;
    default:
      return 0;
  }
}

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.js
var $4 = $;
var defaultOpts = {
  inputBackground: Color.fromHex("#3C3C3C"),
  inputForeground: Color.fromHex("#CCCCCC"),
  inputValidationInfoBorder: Color.fromHex("#55AAFF"),
  inputValidationInfoBackground: Color.fromHex("#063B49"),
  inputValidationWarningBorder: Color.fromHex("#B89500"),
  inputValidationWarningBackground: Color.fromHex("#352A05"),
  inputValidationErrorBorder: Color.fromHex("#BE1100"),
  inputValidationErrorBackground: Color.fromHex("#5A1D1D")
};
var InputBox = class extends Widget2 {
  constructor(container, contextViewProvider, options) {
    super();
    this.state = "idle";
    this.maxHeight = Number.POSITIVE_INFINITY;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._onDidHeightChange = this._register(new Emitter());
    this.onDidHeightChange = this._onDidHeightChange.event;
    this.contextViewProvider = contextViewProvider;
    this.options = options || Object.create(null);
    mixin(this.options, defaultOpts, false);
    this.message = null;
    this.placeholder = this.options.placeholder || "";
    this.ariaLabel = this.options.ariaLabel || "";
    this.inputBackground = this.options.inputBackground;
    this.inputForeground = this.options.inputForeground;
    this.inputBorder = this.options.inputBorder;
    this.inputValidationInfoBorder = this.options.inputValidationInfoBorder;
    this.inputValidationInfoBackground = this.options.inputValidationInfoBackground;
    this.inputValidationInfoForeground = this.options.inputValidationInfoForeground;
    this.inputValidationWarningBorder = this.options.inputValidationWarningBorder;
    this.inputValidationWarningBackground = this.options.inputValidationWarningBackground;
    this.inputValidationWarningForeground = this.options.inputValidationWarningForeground;
    this.inputValidationErrorBorder = this.options.inputValidationErrorBorder;
    this.inputValidationErrorBackground = this.options.inputValidationErrorBackground;
    this.inputValidationErrorForeground = this.options.inputValidationErrorForeground;
    if (this.options.validationOptions) {
      this.validation = this.options.validationOptions.validation;
    }
    this.element = append(container, $4(".monaco-inputbox.idle"));
    let tagName = this.options.flexibleHeight ? "textarea" : "input";
    let wrapper = append(this.element, $4(".wrapper"));
    this.input = append(wrapper, $4(tagName + ".input.empty"));
    this.input.setAttribute("autocorrect", "off");
    this.input.setAttribute("autocapitalize", "off");
    this.input.setAttribute("spellcheck", "false");
    this.onfocus(this.input, () => this.element.classList.add("synthetic-focus"));
    this.onblur(this.input, () => this.element.classList.remove("synthetic-focus"));
    if (this.options.flexibleHeight) {
      this.maxHeight = typeof this.options.flexibleMaxHeight === "number" ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY;
      this.mirror = append(wrapper, $4("div.mirror"));
      this.mirror.innerText = "\xA0";
      this.scrollableElement = new ScrollableElement(this.element, {vertical: 1});
      if (this.options.flexibleWidth) {
        this.input.setAttribute("wrap", "off");
        this.mirror.style.whiteSpace = "pre";
        this.mirror.style.wordWrap = "initial";
      }
      append(container, this.scrollableElement.getDomNode());
      this._register(this.scrollableElement);
      this._register(this.scrollableElement.onScroll((e) => this.input.scrollTop = e.scrollTop));
      const onSelectionChange = Event.filter(domEvent(document, "selectionchange"), () => {
        const selection = document.getSelection();
        return (selection === null || selection === void 0 ? void 0 : selection.anchorNode) === wrapper;
      });
      this._register(onSelectionChange(this.updateScrollDimensions, this));
      this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
    } else {
      this.input.type = this.options.type || "text";
      this.input.setAttribute("wrap", "off");
    }
    if (this.ariaLabel) {
      this.input.setAttribute("aria-label", this.ariaLabel);
    }
    if (this.placeholder) {
      this.setPlaceHolder(this.placeholder);
    }
    this.oninput(this.input, () => this.onValueChange());
    this.onblur(this.input, () => this.onBlur());
    this.onfocus(this.input, () => this.onFocus());
    this.ignoreGesture(this.input);
    setTimeout(() => this.updateMirror(), 0);
    if (this.options.actions) {
      this.actionbar = this._register(new ActionBar(this.element));
      this.actionbar.push(this.options.actions, {icon: true, label: false});
    }
    this.applyStyles();
  }
  onBlur() {
    this._hideMessage();
  }
  onFocus() {
    this._showMessage();
  }
  setPlaceHolder(placeHolder) {
    this.placeholder = placeHolder;
    this.input.setAttribute("placeholder", placeHolder);
    this.input.title = placeHolder;
  }
  setAriaLabel(label) {
    this.ariaLabel = label;
    if (label) {
      this.input.setAttribute("aria-label", this.ariaLabel);
    } else {
      this.input.removeAttribute("aria-label");
    }
  }
  getAriaLabel() {
    return this.ariaLabel;
  }
  get inputElement() {
    return this.input;
  }
  get value() {
    return this.input.value;
  }
  set value(newValue) {
    if (this.input.value !== newValue) {
      this.input.value = newValue;
      this.onValueChange();
    }
  }
  get height() {
    return typeof this.cachedHeight === "number" ? this.cachedHeight : getTotalHeight(this.element);
  }
  focus() {
    this.input.focus();
  }
  blur() {
    this.input.blur();
  }
  hasFocus() {
    return document.activeElement === this.input;
  }
  select(range2 = null) {
    this.input.select();
    if (range2) {
      this.input.setSelectionRange(range2.start, range2.end);
    }
  }
  isSelectionAtEnd() {
    return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
  }
  enable() {
    this.input.removeAttribute("disabled");
  }
  disable() {
    this.blur();
    this.input.disabled = true;
    this._hideMessage();
  }
  get width() {
    return getTotalWidth(this.input);
  }
  set width(width) {
    if (this.options.flexibleHeight && this.options.flexibleWidth) {
      let horizontalPadding = 0;
      if (this.mirror) {
        const paddingLeft = parseFloat(this.mirror.style.paddingLeft || "") || 0;
        const paddingRight = parseFloat(this.mirror.style.paddingRight || "") || 0;
        horizontalPadding = paddingLeft + paddingRight;
      }
      this.input.style.width = width - horizontalPadding + "px";
    } else {
      this.input.style.width = width + "px";
    }
    if (this.mirror) {
      this.mirror.style.width = width + "px";
    }
  }
  set paddingRight(paddingRight) {
    if (this.options.flexibleHeight && this.options.flexibleWidth) {
      this.input.style.width = `calc(100% - ${paddingRight}px)`;
    } else {
      this.input.style.paddingRight = paddingRight + "px";
    }
    if (this.mirror) {
      this.mirror.style.paddingRight = paddingRight + "px";
    }
  }
  updateScrollDimensions() {
    if (typeof this.cachedContentHeight !== "number" || typeof this.cachedHeight !== "number" || !this.scrollableElement) {
      return;
    }
    const scrollHeight = this.cachedContentHeight;
    const height = this.cachedHeight;
    const scrollTop = this.input.scrollTop;
    this.scrollableElement.setScrollDimensions({scrollHeight, height});
    this.scrollableElement.setScrollPosition({scrollTop});
  }
  showMessage(message, force) {
    this.message = message;
    this.element.classList.remove("idle");
    this.element.classList.remove("info");
    this.element.classList.remove("warning");
    this.element.classList.remove("error");
    this.element.classList.add(this.classForType(message.type));
    const styles = this.stylesForType(this.message.type);
    this.element.style.border = styles.border ? `1px solid ${styles.border}` : "";
    if (this.hasFocus() || force) {
      this._showMessage();
    }
  }
  hideMessage() {
    this.message = null;
    this.element.classList.remove("info");
    this.element.classList.remove("warning");
    this.element.classList.remove("error");
    this.element.classList.add("idle");
    this._hideMessage();
    this.applyStyles();
  }
  validate() {
    let errorMsg = null;
    if (this.validation) {
      errorMsg = this.validation(this.value);
      if (errorMsg) {
        this.inputElement.setAttribute("aria-invalid", "true");
        this.showMessage(errorMsg);
      } else if (this.inputElement.hasAttribute("aria-invalid")) {
        this.inputElement.removeAttribute("aria-invalid");
        this.hideMessage();
      }
    }
    return !errorMsg;
  }
  stylesForType(type) {
    switch (type) {
      case 1:
        return {border: this.inputValidationInfoBorder, background: this.inputValidationInfoBackground, foreground: this.inputValidationInfoForeground};
      case 2:
        return {border: this.inputValidationWarningBorder, background: this.inputValidationWarningBackground, foreground: this.inputValidationWarningForeground};
      default:
        return {border: this.inputValidationErrorBorder, background: this.inputValidationErrorBackground, foreground: this.inputValidationErrorForeground};
    }
  }
  classForType(type) {
    switch (type) {
      case 1:
        return "info";
      case 2:
        return "warning";
      default:
        return "error";
    }
  }
  _showMessage() {
    if (!this.contextViewProvider || !this.message) {
      return;
    }
    let div;
    let layout2 = () => div.style.width = getTotalWidth(this.element) + "px";
    this.contextViewProvider.showContextView({
      getAnchor: () => this.element,
      anchorAlignment: 1,
      render: (container) => {
        if (!this.message) {
          return null;
        }
        div = append(container, $4(".monaco-inputbox-container"));
        layout2();
        const renderOptions = {
          inline: true,
          className: "monaco-inputbox-message"
        };
        const spanElement = this.message.formatContent ? renderFormattedText(this.message.content, renderOptions) : renderText(this.message.content, renderOptions);
        spanElement.classList.add(this.classForType(this.message.type));
        const styles = this.stylesForType(this.message.type);
        spanElement.style.backgroundColor = styles.background ? styles.background.toString() : "";
        spanElement.style.color = styles.foreground ? styles.foreground.toString() : "";
        spanElement.style.border = styles.border ? `1px solid ${styles.border}` : "";
        append(div, spanElement);
        return null;
      },
      onHide: () => {
        this.state = "closed";
      },
      layout: layout2
    });
    let alertText;
    if (this.message.type === 3) {
      alertText = localize("alertErrorMessage", "Error: {0}", this.message.content);
    } else if (this.message.type === 2) {
      alertText = localize("alertWarningMessage", "Warning: {0}", this.message.content);
    } else {
      alertText = localize("alertInfoMessage", "Info: {0}", this.message.content);
    }
    alert(alertText);
    this.state = "open";
  }
  _hideMessage() {
    if (!this.contextViewProvider) {
      return;
    }
    if (this.state === "open") {
      this.contextViewProvider.hideContextView();
    }
    this.state = "idle";
  }
  onValueChange() {
    this._onDidChange.fire(this.value);
    this.validate();
    this.updateMirror();
    this.input.classList.toggle("empty", !this.value);
    if (this.state === "open" && this.contextViewProvider) {
      this.contextViewProvider.layout();
    }
  }
  updateMirror() {
    if (!this.mirror) {
      return;
    }
    const value = this.value;
    const lastCharCode = value.charCodeAt(value.length - 1);
    const suffix = lastCharCode === 10 ? " " : "";
    const mirrorTextContent = value + suffix;
    if (mirrorTextContent) {
      this.mirror.textContent = value + suffix;
    } else {
      this.mirror.innerText = "\xA0";
    }
    this.layout();
  }
  style(styles) {
    this.inputBackground = styles.inputBackground;
    this.inputForeground = styles.inputForeground;
    this.inputBorder = styles.inputBorder;
    this.inputValidationInfoBackground = styles.inputValidationInfoBackground;
    this.inputValidationInfoForeground = styles.inputValidationInfoForeground;
    this.inputValidationInfoBorder = styles.inputValidationInfoBorder;
    this.inputValidationWarningBackground = styles.inputValidationWarningBackground;
    this.inputValidationWarningForeground = styles.inputValidationWarningForeground;
    this.inputValidationWarningBorder = styles.inputValidationWarningBorder;
    this.inputValidationErrorBackground = styles.inputValidationErrorBackground;
    this.inputValidationErrorForeground = styles.inputValidationErrorForeground;
    this.inputValidationErrorBorder = styles.inputValidationErrorBorder;
    this.applyStyles();
  }
  applyStyles() {
    const background = this.inputBackground ? this.inputBackground.toString() : "";
    const foreground2 = this.inputForeground ? this.inputForeground.toString() : "";
    const border = this.inputBorder ? this.inputBorder.toString() : "";
    this.element.style.backgroundColor = background;
    this.element.style.color = foreground2;
    this.input.style.backgroundColor = "inherit";
    this.input.style.color = foreground2;
    this.element.style.borderWidth = border ? "1px" : "";
    this.element.style.borderStyle = border ? "solid" : "";
    this.element.style.borderColor = border;
  }
  layout() {
    if (!this.mirror) {
      return;
    }
    const previousHeight = this.cachedContentHeight;
    this.cachedContentHeight = getTotalHeight(this.mirror);
    if (previousHeight !== this.cachedContentHeight) {
      this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight);
      this.input.style.height = this.cachedHeight + "px";
      this._onDidHeightChange.fire(this.cachedContentHeight);
    }
  }
  insertAtCursor(text) {
    const inputElement = this.inputElement;
    const start = inputElement.selectionStart;
    const end = inputElement.selectionEnd;
    const content = inputElement.value;
    if (start !== null && end !== null) {
      this.value = content.substr(0, start) + text + content.substr(end);
      inputElement.setSelectionRange(start + 1, start + 1);
      this.layout();
    }
  }
  dispose() {
    this._hideMessage();
    this.message = null;
    if (this.actionbar) {
      this.actionbar.dispose();
    }
    super.dispose();
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/quickInputBox.js
var $5 = $;
var QuickInputBox = class extends Disposable {
  constructor(parent) {
    super();
    this.parent = parent;
    this.onKeyDown = (handler) => {
      return addDisposableListener(this.inputBox.inputElement, EventType.KEY_DOWN, (e) => {
        handler(new StandardKeyboardEvent(e));
      });
    };
    this.onMouseDown = (handler) => {
      return addDisposableListener(this.inputBox.inputElement, EventType.MOUSE_DOWN, (e) => {
        handler(new StandardMouseEvent(e));
      });
    };
    this.onDidChange = (handler) => {
      return this.inputBox.onDidChange(handler);
    };
    this.container = append(this.parent, $5(".quick-input-box"));
    this.inputBox = this._register(new InputBox(this.container, void 0));
  }
  get value() {
    return this.inputBox.value;
  }
  set value(value) {
    this.inputBox.value = value;
  }
  select(range2 = null) {
    this.inputBox.select(range2);
  }
  isSelectionAtEnd() {
    return this.inputBox.isSelectionAtEnd();
  }
  get placeholder() {
    return this.inputBox.inputElement.getAttribute("placeholder") || "";
  }
  set placeholder(placeholder) {
    this.inputBox.setPlaceHolder(placeholder);
  }
  get ariaLabel() {
    return this.inputBox.getAriaLabel();
  }
  set ariaLabel(ariaLabel) {
    this.inputBox.setAriaLabel(ariaLabel);
  }
  get password() {
    return this.inputBox.inputElement.type === "password";
  }
  set password(password) {
    this.inputBox.inputElement.type = password ? "password" : "text";
  }
  setAttribute(name, value) {
    this.inputBox.inputElement.setAttribute(name, value);
  }
  removeAttribute(name) {
    this.inputBox.inputElement.removeAttribute(name);
  }
  showDecoration(decoration) {
    if (decoration === severity_default.Ignore) {
      this.inputBox.hideMessage();
    } else {
      this.inputBox.showMessage({type: decoration === severity_default.Info ? 1 : decoration === severity_default.Warning ? 2 : 3, content: ""});
    }
  }
  stylesForType(decoration) {
    return this.inputBox.stylesForType(decoration === severity_default.Info ? 1 : decoration === severity_default.Warning ? 2 : 3);
  }
  setFocus() {
    this.inputBox.focus();
  }
  layout() {
    this.inputBox.layout();
  }
  style(styles) {
    this.inputBox.style(styles);
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/countBadge/countBadge.js
var defaultOpts2 = {
  badgeBackground: Color.fromHex("#4D4D4D"),
  badgeForeground: Color.fromHex("#FFFFFF")
};
var CountBadge = class {
  constructor(container, options) {
    this.count = 0;
    this.options = options || Object.create(null);
    mixin(this.options, defaultOpts2, false);
    this.badgeBackground = this.options.badgeBackground;
    this.badgeForeground = this.options.badgeForeground;
    this.badgeBorder = this.options.badgeBorder;
    this.element = append(container, $(".monaco-count-badge"));
    this.countFormat = this.options.countFormat || "{0}";
    this.titleFormat = this.options.titleFormat || "";
    this.setCount(this.options.count || 0);
  }
  setCount(count) {
    this.count = count;
    this.render();
  }
  setTitleFormat(titleFormat) {
    this.titleFormat = titleFormat;
    this.render();
  }
  render() {
    this.element.textContent = format(this.countFormat, this.count);
    this.element.title = format(this.titleFormat, this.count);
    this.applyStyles();
  }
  style(styles) {
    this.badgeBackground = styles.badgeBackground;
    this.badgeForeground = styles.badgeForeground;
    this.badgeBorder = styles.badgeBorder;
    this.applyStyles();
  }
  applyStyles() {
    if (this.element) {
      const background = this.badgeBackground ? this.badgeBackground.toString() : "";
      const foreground2 = this.badgeForeground ? this.badgeForeground.toString() : "";
      const border = this.badgeBorder ? this.badgeBorder.toString() : "";
      this.element.style.backgroundColor = background;
      this.element.style.color = foreground2;
      this.element.style.borderWidth = border ? "1px" : "";
      this.element.style.borderStyle = border ? "solid" : "";
      this.element.style.borderColor = border;
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/progressbar/progressbar.js
var css_done = "done";
var css_active = "active";
var css_infinite = "infinite";
var css_discrete = "discrete";
var css_progress_container = "monaco-progress-container";
var css_progress_bit = "progress-bit";
var defaultOpts3 = {
  progressBarBackground: Color.fromHex("#0E70C0")
};
var ProgressBar = class extends Disposable {
  constructor(container, options) {
    super();
    this.options = options || Object.create(null);
    mixin(this.options, defaultOpts3, false);
    this.workedVal = 0;
    this.progressBarBackground = this.options.progressBarBackground;
    this._register(this.showDelayedScheduler = new RunOnceScheduler(() => show(this.element), 0));
    this.create(container);
  }
  create(container) {
    this.element = document.createElement("div");
    addClass(this.element, css_progress_container);
    container.appendChild(this.element);
    this.bit = document.createElement("div");
    addClass(this.bit, css_progress_bit);
    this.element.appendChild(this.bit);
    this.applyStyles();
  }
  off() {
    this.bit.style.width = "inherit";
    this.bit.style.opacity = "1";
    removeClasses(this.element, css_active, css_infinite, css_discrete);
    this.workedVal = 0;
    this.totalWork = void 0;
  }
  stop() {
    return this.doDone(false);
  }
  doDone(delayed) {
    addClass(this.element, css_done);
    if (!hasClass(this.element, css_infinite)) {
      this.bit.style.width = "inherit";
      if (delayed) {
        setTimeout(() => this.off(), 200);
      } else {
        this.off();
      }
    } else {
      this.bit.style.opacity = "0";
      if (delayed) {
        setTimeout(() => this.off(), 200);
      } else {
        this.off();
      }
    }
    return this;
  }
  infinite() {
    this.bit.style.width = "2%";
    this.bit.style.opacity = "1";
    removeClasses(this.element, css_discrete, css_done);
    addClasses(this.element, css_active, css_infinite);
    return this;
  }
  getContainer() {
    return this.element;
  }
  style(styles) {
    this.progressBarBackground = styles.progressBarBackground;
    this.applyStyles();
  }
  applyStyles() {
    if (this.bit) {
      const background = this.progressBarBackground ? this.progressBarBackground.toString() : "";
      this.bit.style.backgroundColor = background;
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/browser/codicons.js
function renderCodiconsAsElement(text) {
  const elements = new Array();
  let match2;
  let textStart = 0, textStop = 0;
  while ((match2 = renderCodiconsRegex.exec(text)) !== null) {
    textStop = match2.index || 0;
    elements.push(text.substring(textStart, textStop));
    textStart = (match2.index || 0) + match2[0].length;
    const [, escaped, codicon, name, animation] = match2;
    elements.push(escaped ? `$(${codicon})` : $(`span.codicon.codicon-${name}${animation ? `.codicon-animation-${animation}` : ""}`));
  }
  if (textStart < text.length) {
    elements.push(text.substring(textStart));
  }
  return elements;
}

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/button/button.js
var defaultOptions2 = {
  buttonBackground: Color.fromHex("#0E639C"),
  buttonHoverBackground: Color.fromHex("#006BB3"),
  buttonForeground: Color.white
};
var Button = class extends Disposable {
  constructor(container, options) {
    super();
    this._onDidClick = this._register(new Emitter());
    this.options = options || Object.create(null);
    mixin(this.options, defaultOptions2, false);
    this.buttonForeground = this.options.buttonForeground;
    this.buttonBackground = this.options.buttonBackground;
    this.buttonHoverBackground = this.options.buttonHoverBackground;
    this.buttonSecondaryForeground = this.options.buttonSecondaryForeground;
    this.buttonSecondaryBackground = this.options.buttonSecondaryBackground;
    this.buttonSecondaryHoverBackground = this.options.buttonSecondaryHoverBackground;
    this.buttonBorder = this.options.buttonBorder;
    this._element = document.createElement("a");
    addClass(this._element, "monaco-button");
    this._element.tabIndex = 0;
    this._element.setAttribute("role", "button");
    container.appendChild(this._element);
    this._register(Gesture.addTarget(this._element));
    [EventType.CLICK, EventType2.Tap].forEach((eventType) => {
      this._register(addDisposableListener(this._element, eventType, (e) => {
        if (!this.enabled) {
          EventHelper.stop(e);
          return;
        }
        this._onDidClick.fire(e);
      }));
    });
    this._register(addDisposableListener(this._element, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      let eventHandled = false;
      if (this.enabled && (event.equals(3) || event.equals(10))) {
        this._onDidClick.fire(e);
        eventHandled = true;
      } else if (event.equals(9)) {
        this._element.blur();
        eventHandled = true;
      }
      if (eventHandled) {
        EventHelper.stop(event, true);
      }
    }));
    this._register(addDisposableListener(this._element, EventType.MOUSE_OVER, (e) => {
      if (!hasClass(this._element, "disabled")) {
        this.setHoverBackground();
      }
    }));
    this._register(addDisposableListener(this._element, EventType.MOUSE_OUT, (e) => {
      this.applyStyles();
    }));
    this.focusTracker = this._register(trackFocus(this._element));
    this._register(this.focusTracker.onDidFocus(() => this.setHoverBackground()));
    this._register(this.focusTracker.onDidBlur(() => this.applyStyles()));
    this.applyStyles();
  }
  get onDidClick() {
    return this._onDidClick.event;
  }
  setHoverBackground() {
    let hoverBackground;
    if (this.options.secondary) {
      hoverBackground = this.buttonSecondaryHoverBackground ? this.buttonSecondaryHoverBackground.toString() : null;
    } else {
      hoverBackground = this.buttonHoverBackground ? this.buttonHoverBackground.toString() : null;
    }
    if (hoverBackground) {
      this._element.style.backgroundColor = hoverBackground;
    }
  }
  style(styles) {
    this.buttonForeground = styles.buttonForeground;
    this.buttonBackground = styles.buttonBackground;
    this.buttonHoverBackground = styles.buttonHoverBackground;
    this.buttonSecondaryForeground = styles.buttonSecondaryForeground;
    this.buttonSecondaryBackground = styles.buttonSecondaryBackground;
    this.buttonSecondaryHoverBackground = styles.buttonSecondaryHoverBackground;
    this.buttonBorder = styles.buttonBorder;
    this.applyStyles();
  }
  applyStyles() {
    if (this._element) {
      let background, foreground2;
      if (this.options.secondary) {
        foreground2 = this.buttonSecondaryForeground ? this.buttonSecondaryForeground.toString() : "";
        background = this.buttonSecondaryBackground ? this.buttonSecondaryBackground.toString() : "";
      } else {
        foreground2 = this.buttonForeground ? this.buttonForeground.toString() : "";
        background = this.buttonBackground ? this.buttonBackground.toString() : "";
      }
      const border = this.buttonBorder ? this.buttonBorder.toString() : "";
      this._element.style.color = foreground2;
      this._element.style.backgroundColor = background;
      this._element.style.borderWidth = border ? "1px" : "";
      this._element.style.borderStyle = border ? "solid" : "";
      this._element.style.borderColor = border;
    }
  }
  get element() {
    return this._element;
  }
  set label(value) {
    if (!hasClass(this._element, "monaco-text-button")) {
      addClass(this._element, "monaco-text-button");
    }
    if (this.options.supportCodicons) {
      reset(this._element, ...renderCodiconsAsElement(value));
    } else {
      this._element.textContent = value;
    }
    if (typeof this.options.title === "string") {
      this._element.title = this.options.title;
    } else if (this.options.title) {
      this._element.title = value;
    }
  }
  set enabled(value) {
    if (value) {
      removeClass(this._element, "disabled");
      this._element.setAttribute("aria-disabled", String(false));
      this._element.tabIndex = 0;
    } else {
      addClass(this._element, "disabled");
      this._element.setAttribute("aria-disabled", String(true));
      removeTabIndexAndUpdateFocus(this._element);
    }
  }
  get enabled() {
    return !hasClass(this._element, "disabled");
  }
};

// ../../node_modules/monaco-editor/esm/vs/base/parts/quickinput/browser/quickInput.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var $6 = $;
var backButtonIcon = registerIcon("quick-input-back", Codicon.arrowLeft);
var backButton = {
  iconClass: backButtonIcon.classNames,
  tooltip: localize("quickInput.back", "Back"),
  handle: -1
};
var QuickInput = class extends Disposable {
  constructor(ui) {
    super();
    this.ui = ui;
    this.visible = false;
    this._enabled = true;
    this._busy = false;
    this._ignoreFocusOut = false;
    this._buttons = [];
    this.buttonsUpdated = false;
    this.onDidTriggerButtonEmitter = this._register(new Emitter());
    this.onDidHideEmitter = this._register(new Emitter());
    this.onDisposeEmitter = this._register(new Emitter());
    this.visibleDisposables = this._register(new DisposableStore());
    this.onDidHide = this.onDidHideEmitter.event;
  }
  get title() {
    return this._title;
  }
  set title(title) {
    this._title = title;
    this.update();
  }
  get description() {
    return this._description;
  }
  set description(description) {
    this._description = description;
    this.update();
  }
  get step() {
    return this._steps;
  }
  set step(step) {
    this._steps = step;
    this.update();
  }
  get totalSteps() {
    return this._totalSteps;
  }
  set totalSteps(totalSteps) {
    this._totalSteps = totalSteps;
    this.update();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    this._enabled = enabled;
    this.update();
  }
  get contextKey() {
    return this._contextKey;
  }
  set contextKey(contextKey) {
    this._contextKey = contextKey;
    this.update();
  }
  get busy() {
    return this._busy;
  }
  set busy(busy) {
    this._busy = busy;
    this.update();
  }
  get ignoreFocusOut() {
    return this._ignoreFocusOut;
  }
  set ignoreFocusOut(ignoreFocusOut) {
    this._ignoreFocusOut = ignoreFocusOut;
    this.update();
  }
  get buttons() {
    return this._buttons;
  }
  set buttons(buttons) {
    this._buttons = buttons;
    this.buttonsUpdated = true;
    this.update();
  }
  show() {
    if (this.visible) {
      return;
    }
    this.visibleDisposables.add(this.ui.onDidTriggerButton((button) => {
      if (this.buttons.indexOf(button) !== -1) {
        this.onDidTriggerButtonEmitter.fire(button);
      }
    }));
    this.ui.show(this);
    this.visible = true;
    this.update();
  }
  hide() {
    if (!this.visible) {
      return;
    }
    this.ui.hide();
  }
  didHide() {
    this.visible = false;
    this.visibleDisposables.clear();
    this.onDidHideEmitter.fire();
  }
  update() {
    if (!this.visible) {
      return;
    }
    const title = this.getTitle();
    if (title && this.ui.title.textContent !== title) {
      this.ui.title.textContent = title;
    } else if (!title && this.ui.title.innerHTML !== "&nbsp;") {
      this.ui.title.innerText = "\xA0;";
    }
    const description = this.getDescription();
    if (this.ui.description.textContent !== description) {
      this.ui.description.textContent = description;
    }
    if (this.busy && !this.busyDelay) {
      this.busyDelay = new TimeoutTimer();
      this.busyDelay.setIfNotSet(() => {
        if (this.visible) {
          this.ui.progressBar.infinite();
        }
      }, 800);
    }
    if (!this.busy && this.busyDelay) {
      this.ui.progressBar.stop();
      this.busyDelay.cancel();
      this.busyDelay = void 0;
    }
    if (this.buttonsUpdated) {
      this.buttonsUpdated = false;
      this.ui.leftActionBar.clear();
      const leftButtons = this.buttons.filter((button) => button === backButton);
      this.ui.leftActionBar.push(leftButtons.map((button, index) => {
        const action = new Action(`id-${index}`, "", button.iconClass || getIconClass(button.iconPath), true, () => __awaiter11(this, void 0, void 0, function* () {
          this.onDidTriggerButtonEmitter.fire(button);
        }));
        action.tooltip = button.tooltip || "";
        return action;
      }), {icon: true, label: false});
      this.ui.rightActionBar.clear();
      const rightButtons = this.buttons.filter((button) => button !== backButton);
      this.ui.rightActionBar.push(rightButtons.map((button, index) => {
        const action = new Action(`id-${index}`, "", button.iconClass || getIconClass(button.iconPath), true, () => __awaiter11(this, void 0, void 0, function* () {
          this.onDidTriggerButtonEmitter.fire(button);
        }));
        action.tooltip = button.tooltip || "";
        return action;
      }), {icon: true, label: false});
    }
    this.ui.ignoreFocusOut = this.ignoreFocusOut;
    this.ui.setEnabled(this.enabled);
    this.ui.setContextKey(this.contextKey);
  }
  getTitle() {
    if (this.title && this.step) {
      return `${this.title} (${this.getSteps()})`;
    }
    if (this.title) {
      return this.title;
    }
    if (this.step) {
      return this.getSteps();
    }
    return "";
  }
  getDescription() {
    return this.description || "";
  }
  getSteps() {
    if (this.step && this.totalSteps) {
      return localize("quickInput.steps", "{0}/{1}", this.step, this.totalSteps);
    }
    if (this.step) {
      return String(this.step);
    }
    return "";
  }
  showMessageDecoration(severity) {
    this.ui.inputBox.showDecoration(severity);
    if (severity === severity_default.Error) {
      const styles = this.ui.inputBox.stylesForType(severity);
      this.ui.message.style.color = styles.foreground ? `${styles.foreground}` : "";
      this.ui.message.style.backgroundColor = styles.background ? `${styles.background}` : "";
      this.ui.message.style.border = styles.border ? `1px solid ${styles.border}` : "";
      this.ui.message.style.paddingBottom = "4px";
    } else {
      this.ui.message.style.color = "";
      this.ui.message.style.backgroundColor = "";
      this.ui.message.style.border = "";
      this.ui.message.style.paddingBottom = "";
    }
  }
  dispose() {
    this.hide();
    this.onDisposeEmitter.fire();
    super.dispose();
  }
};
var QuickPick = class extends QuickInput {
  constructor() {
    super(...arguments);
    this._value = "";
    this.onDidChangeValueEmitter = this._register(new Emitter());
    this.onDidAcceptEmitter = this._register(new Emitter());
    this.onDidCustomEmitter = this._register(new Emitter());
    this._items = [];
    this.itemsUpdated = false;
    this._canSelectMany = false;
    this._canAcceptInBackground = false;
    this._matchOnDescription = false;
    this._matchOnDetail = false;
    this._matchOnLabel = true;
    this._sortByLabel = true;
    this._autoFocusOnList = true;
    this._itemActivation = this.ui.isScreenReaderOptimized() ? ItemActivation.NONE : ItemActivation.FIRST;
    this._activeItems = [];
    this.activeItemsUpdated = false;
    this.activeItemsToConfirm = [];
    this.onDidChangeActiveEmitter = this._register(new Emitter());
    this._selectedItems = [];
    this.selectedItemsUpdated = false;
    this.selectedItemsToConfirm = [];
    this.onDidChangeSelectionEmitter = this._register(new Emitter());
    this.onDidTriggerItemButtonEmitter = this._register(new Emitter());
    this.valueSelectionUpdated = true;
    this._ok = "default";
    this._customButton = false;
    this.filterValue = (value) => value;
    this.onDidChangeValue = this.onDidChangeValueEmitter.event;
    this.onDidAccept = this.onDidAcceptEmitter.event;
    this.onDidChangeActive = this.onDidChangeActiveEmitter.event;
    this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event;
    this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event;
  }
  get quickNavigate() {
    return this._quickNavigate;
  }
  set quickNavigate(quickNavigate) {
    this._quickNavigate = quickNavigate;
    this.update();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value || "";
    this.update();
  }
  set ariaLabel(ariaLabel) {
    this._ariaLabel = ariaLabel;
    this.update();
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(placeholder) {
    this._placeholder = placeholder;
    this.update();
  }
  get items() {
    return this._items;
  }
  set items(items) {
    this._items = items;
    this.itemsUpdated = true;
    this.update();
  }
  get canSelectMany() {
    return this._canSelectMany;
  }
  set canSelectMany(canSelectMany) {
    this._canSelectMany = canSelectMany;
    this.update();
  }
  get canAcceptInBackground() {
    return this._canAcceptInBackground;
  }
  set canAcceptInBackground(canAcceptInBackground) {
    this._canAcceptInBackground = canAcceptInBackground;
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(matchOnDescription) {
    this._matchOnDescription = matchOnDescription;
    this.update();
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(matchOnDetail) {
    this._matchOnDetail = matchOnDetail;
    this.update();
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(matchOnLabel) {
    this._matchOnLabel = matchOnLabel;
    this.update();
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(sortByLabel) {
    this._sortByLabel = sortByLabel;
    this.update();
  }
  get autoFocusOnList() {
    return this._autoFocusOnList;
  }
  set autoFocusOnList(autoFocusOnList) {
    this._autoFocusOnList = autoFocusOnList;
    this.update();
  }
  get itemActivation() {
    return this._itemActivation;
  }
  set itemActivation(itemActivation) {
    this._itemActivation = itemActivation;
  }
  get activeItems() {
    return this._activeItems;
  }
  set activeItems(activeItems) {
    this._activeItems = activeItems;
    this.activeItemsUpdated = true;
    this.update();
  }
  get selectedItems() {
    return this._selectedItems;
  }
  set selectedItems(selectedItems) {
    this._selectedItems = selectedItems;
    this.selectedItemsUpdated = true;
    this.update();
  }
  get keyMods() {
    if (this._quickNavigate) {
      return NO_KEY_MODS;
    }
    return this.ui.keyMods;
  }
  set valueSelection(valueSelection) {
    this._valueSelection = valueSelection;
    this.valueSelectionUpdated = true;
    this.update();
  }
  get validationMessage() {
    return this._validationMessage;
  }
  set validationMessage(validationMessage) {
    this._validationMessage = validationMessage;
    this.update();
  }
  get customButton() {
    return this._customButton;
  }
  set customButton(showCustomButton) {
    this._customButton = showCustomButton;
    this.update();
  }
  get customLabel() {
    return this._customButtonLabel;
  }
  set customLabel(label) {
    this._customButtonLabel = label;
    this.update();
  }
  get customHover() {
    return this._customButtonHover;
  }
  set customHover(hover) {
    this._customButtonHover = hover;
    this.update();
  }
  get ok() {
    return this._ok;
  }
  set ok(showOkButton) {
    this._ok = showOkButton;
    this.update();
  }
  get hideInput() {
    return !!this._hideInput;
  }
  set hideInput(hideInput) {
    this._hideInput = hideInput;
    this.update();
  }
  trySelectFirst() {
    if (this.autoFocusOnList) {
      if (!this.canSelectMany) {
        this.ui.list.focus(QuickInputListFocus.First);
      }
    }
  }
  show() {
    if (!this.visible) {
      this.visibleDisposables.add(this.ui.inputBox.onDidChange((value) => {
        if (value === this.value) {
          return;
        }
        this._value = value;
        const didFilter = this.ui.list.filter(this.filterValue(this.ui.inputBox.value));
        if (didFilter) {
          this.trySelectFirst();
        }
        this.onDidChangeValueEmitter.fire(value);
      }));
      this.visibleDisposables.add(this.ui.inputBox.onMouseDown((event) => {
        if (!this.autoFocusOnList) {
          this.ui.list.clearFocus();
        }
      }));
      this.visibleDisposables.add((this._hideInput ? this.ui.list : this.ui.inputBox).onKeyDown((event) => {
        switch (event.keyCode) {
          case 18:
            this.ui.list.focus(QuickInputListFocus.Next);
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 16:
            if (this.ui.list.getFocusedElements().length) {
              this.ui.list.focus(QuickInputListFocus.Previous);
            } else {
              this.ui.list.focus(QuickInputListFocus.Last);
            }
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 12:
            this.ui.list.focus(QuickInputListFocus.NextPage);
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 11:
            this.ui.list.focus(QuickInputListFocus.PreviousPage);
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 17:
            if (!this._canAcceptInBackground) {
              return;
            }
            if (!this.ui.inputBox.isSelectionAtEnd()) {
              return;
            }
            if (this.activeItems[0]) {
              this._selectedItems = [this.activeItems[0]];
              this.onDidChangeSelectionEmitter.fire(this.selectedItems);
              this.onDidAcceptEmitter.fire({inBackground: true});
            }
            break;
          case 14:
            if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {
              this.ui.list.focus(QuickInputListFocus.First);
              EventHelper.stop(event, true);
            }
            break;
          case 13:
            if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {
              this.ui.list.focus(QuickInputListFocus.Last);
              EventHelper.stop(event, true);
            }
            break;
        }
      }));
      this.visibleDisposables.add(this.ui.onDidAccept(() => {
        if (!this.canSelectMany && this.activeItems[0]) {
          this._selectedItems = [this.activeItems[0]];
          this.onDidChangeSelectionEmitter.fire(this.selectedItems);
        }
        this.onDidAcceptEmitter.fire({inBackground: false});
      }));
      this.visibleDisposables.add(this.ui.onDidCustom(() => {
        this.onDidCustomEmitter.fire();
      }));
      this.visibleDisposables.add(this.ui.list.onDidChangeFocus((focusedItems) => {
        if (this.activeItemsUpdated) {
          return;
        }
        if (this.activeItemsToConfirm !== this._activeItems && equals(focusedItems, this._activeItems, (a, b) => a === b)) {
          return;
        }
        this._activeItems = focusedItems;
        this.onDidChangeActiveEmitter.fire(focusedItems);
      }));
      this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({items: selectedItems, event}) => {
        if (this.canSelectMany) {
          if (selectedItems.length) {
            this.ui.list.setSelectedElements([]);
          }
          return;
        }
        if (this.selectedItemsToConfirm !== this._selectedItems && equals(selectedItems, this._selectedItems, (a, b) => a === b)) {
          return;
        }
        this._selectedItems = selectedItems;
        this.onDidChangeSelectionEmitter.fire(selectedItems);
        if (selectedItems.length) {
          this.onDidAcceptEmitter.fire({inBackground: event instanceof MouseEvent && event.button === 1});
        }
      }));
      this.visibleDisposables.add(this.ui.list.onChangedCheckedElements((checkedItems) => {
        if (!this.canSelectMany) {
          return;
        }
        if (this.selectedItemsToConfirm !== this._selectedItems && equals(checkedItems, this._selectedItems, (a, b) => a === b)) {
          return;
        }
        this._selectedItems = checkedItems;
        this.onDidChangeSelectionEmitter.fire(checkedItems);
      }));
      this.visibleDisposables.add(this.ui.list.onButtonTriggered((event) => this.onDidTriggerItemButtonEmitter.fire(event)));
      this.visibleDisposables.add(this.registerQuickNavigation());
      this.valueSelectionUpdated = true;
    }
    super.show();
  }
  registerQuickNavigation() {
    return addDisposableListener(this.ui.container, EventType.KEY_UP, (e) => {
      if (this.canSelectMany || !this._quickNavigate) {
        return;
      }
      const keyboardEvent = new StandardKeyboardEvent(e);
      const keyCode = keyboardEvent.keyCode;
      const quickNavKeys = this._quickNavigate.keybindings;
      const wasTriggerKeyPressed = quickNavKeys.some((k) => {
        const [firstPart, chordPart] = k.getParts();
        if (chordPart) {
          return false;
        }
        if (firstPart.shiftKey && keyCode === 4) {
          if (keyboardEvent.ctrlKey || keyboardEvent.altKey || keyboardEvent.metaKey) {
            return false;
          }
          return true;
        }
        if (firstPart.altKey && keyCode === 6) {
          return true;
        }
        if (firstPart.ctrlKey && keyCode === 5) {
          return true;
        }
        if (firstPart.metaKey && keyCode === 57) {
          return true;
        }
        return false;
      });
      if (wasTriggerKeyPressed) {
        if (this.activeItems[0]) {
          this._selectedItems = [this.activeItems[0]];
          this.onDidChangeSelectionEmitter.fire(this.selectedItems);
          this.onDidAcceptEmitter.fire({inBackground: false});
        }
        this._quickNavigate = void 0;
      }
    });
  }
  update() {
    if (!this.visible) {
      return;
    }
    let hideInput = false;
    let inputShownJustForScreenReader = false;
    if (!!this._hideInput && this._items.length > 0) {
      if (this.ui.isScreenReaderOptimized()) {
        inputShownJustForScreenReader = true;
      } else {
        hideInput = true;
      }
    }
    toggleClass(this.ui.container, "hidden-input", hideInput);
    const visibilities = {
      title: !!this.title || !!this.step || !!this.buttons.length,
      description: !!this.description,
      checkAll: this.canSelectMany,
      inputBox: !hideInput,
      progressBar: !hideInput,
      visibleCount: true,
      count: this.canSelectMany,
      ok: this.ok === "default" ? this.canSelectMany : this.ok,
      list: true,
      message: !!this.validationMessage,
      customButton: this.customButton
    };
    this.ui.setVisibilities(visibilities);
    super.update();
    if (this.ui.inputBox.value !== this.value) {
      this.ui.inputBox.value = this.value;
    }
    if (this.valueSelectionUpdated) {
      this.valueSelectionUpdated = false;
      this.ui.inputBox.select(this._valueSelection && {start: this._valueSelection[0], end: this._valueSelection[1]});
    }
    if (this.ui.inputBox.placeholder !== (this.placeholder || "")) {
      this.ui.inputBox.placeholder = this.placeholder || "";
    }
    if (inputShownJustForScreenReader) {
      this.ui.inputBox.ariaLabel = "";
    } else {
      const ariaLabel = this.ariaLabel || this.placeholder || QuickPick.DEFAULT_ARIA_LABEL;
      if (this.ui.inputBox.ariaLabel !== ariaLabel) {
        this.ui.inputBox.ariaLabel = ariaLabel;
      }
    }
    this.ui.list.matchOnDescription = this.matchOnDescription;
    this.ui.list.matchOnDetail = this.matchOnDetail;
    this.ui.list.matchOnLabel = this.matchOnLabel;
    this.ui.list.sortByLabel = this.sortByLabel;
    if (this.itemsUpdated) {
      this.itemsUpdated = false;
      this.ui.list.setElements(this.items);
      this.ui.list.filter(this.filterValue(this.ui.inputBox.value));
      this.ui.checkAll.checked = this.ui.list.getAllVisibleChecked();
      this.ui.visibleCount.setCount(this.ui.list.getVisibleCount());
      this.ui.count.setCount(this.ui.list.getCheckedCount());
      switch (this._itemActivation) {
        case ItemActivation.NONE:
          this._itemActivation = ItemActivation.FIRST;
          break;
        case ItemActivation.SECOND:
          this.ui.list.focus(QuickInputListFocus.Second);
          this._itemActivation = ItemActivation.FIRST;
          break;
        case ItemActivation.LAST:
          this.ui.list.focus(QuickInputListFocus.Last);
          this._itemActivation = ItemActivation.FIRST;
          break;
        default:
          this.trySelectFirst();
          break;
      }
    }
    if (this.ui.container.classList.contains("show-checkboxes") !== !!this.canSelectMany) {
      if (this.canSelectMany) {
        this.ui.list.clearFocus();
      } else {
        this.trySelectFirst();
      }
    }
    if (this.activeItemsUpdated) {
      this.activeItemsUpdated = false;
      this.activeItemsToConfirm = this._activeItems;
      this.ui.list.setFocusedElements(this.activeItems);
      if (this.activeItemsToConfirm === this._activeItems) {
        this.activeItemsToConfirm = null;
      }
    }
    if (this.selectedItemsUpdated) {
      this.selectedItemsUpdated = false;
      this.selectedItemsToConfirm = this._selectedItems;
      if (this.canSelectMany) {
        this.ui.list.setCheckedElements(this.selectedItems);
      } else {
        this.ui.list.setSelectedElements(this.selectedItems);
      }
      if (this.selectedItemsToConfirm === this._selectedItems) {
        this.selectedItemsToConfirm = null;
      }
    }
    if (this.validationMessage) {
      this.ui.message.textContent = this.validationMessage;
      this.showMessageDecoration(severity_default.Error);
    } else {
      this.ui.message.textContent = null;
      this.showMessageDecoration(severity_default.Ignore);
    }
    this.ui.customButton.label = this.customLabel || "";
    this.ui.customButton.element.title = this.customHover || "";
    this.ui.setComboboxAccessibility(true);
    if (!visibilities.inputBox) {
      this.ui.list.domFocus();
    }
  }
};
QuickPick.DEFAULT_ARIA_LABEL = localize("quickInputBox.ariaLabel", "Type to narrow down results.");
var QuickInputController = class extends Disposable {
  constructor(options) {
    super();
    this.options = options;
    this.comboboxAccessibility = false;
    this.enabled = true;
    this.onDidAcceptEmitter = this._register(new Emitter());
    this.onDidCustomEmitter = this._register(new Emitter());
    this.onDidTriggerButtonEmitter = this._register(new Emitter());
    this.keyMods = {ctrlCmd: false, alt: false};
    this.controller = null;
    this.onShowEmitter = this._register(new Emitter());
    this.onShow = this.onShowEmitter.event;
    this.onHideEmitter = this._register(new Emitter());
    this.onHide = this.onHideEmitter.event;
    this.idPrefix = options.idPrefix;
    this.parentElement = options.container;
    this.styles = options.styles;
    this.registerKeyModsListeners();
  }
  registerKeyModsListeners() {
    const listener = (e) => {
      this.keyMods.ctrlCmd = e.ctrlKey || e.metaKey;
      this.keyMods.alt = e.altKey;
    };
    this._register(addDisposableListener(window, EventType.KEY_DOWN, listener, true));
    this._register(addDisposableListener(window, EventType.KEY_UP, listener, true));
    this._register(addDisposableListener(window, EventType.MOUSE_DOWN, listener, true));
  }
  getUI() {
    if (this.ui) {
      return this.ui;
    }
    const container = append(this.parentElement, $6(".quick-input-widget.show-file-icons"));
    container.tabIndex = -1;
    container.style.display = "none";
    const styleSheet = createStyleSheet(container);
    const titleBar = append(container, $6(".quick-input-titlebar"));
    const leftActionBar = this._register(new ActionBar(titleBar));
    leftActionBar.domNode.classList.add("quick-input-left-action-bar");
    const title = append(titleBar, $6(".quick-input-title"));
    const rightActionBar = this._register(new ActionBar(titleBar));
    rightActionBar.domNode.classList.add("quick-input-right-action-bar");
    const description = append(container, $6(".quick-input-description"));
    const headerContainer = append(container, $6(".quick-input-header"));
    const checkAll = append(headerContainer, $6("input.quick-input-check-all"));
    checkAll.type = "checkbox";
    this._register(addStandardDisposableListener(checkAll, EventType.CHANGE, (e) => {
      const checked = checkAll.checked;
      list.setAllVisibleChecked(checked);
    }));
    this._register(addDisposableListener(checkAll, EventType.CLICK, (e) => {
      if (e.x || e.y) {
        inputBox.setFocus();
      }
    }));
    const extraContainer = append(headerContainer, $6(".quick-input-and-message"));
    const filterContainer = append(extraContainer, $6(".quick-input-filter"));
    const inputBox = this._register(new QuickInputBox(filterContainer));
    inputBox.setAttribute("aria-describedby", `${this.idPrefix}message`);
    const visibleCountContainer = append(filterContainer, $6(".quick-input-visible-count"));
    visibleCountContainer.setAttribute("aria-live", "polite");
    visibleCountContainer.setAttribute("aria-atomic", "true");
    const visibleCount = new CountBadge(visibleCountContainer, {countFormat: localize({key: "quickInput.visibleCount", comment: ["This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers."]}, "{0} Results")});
    const countContainer = append(filterContainer, $6(".quick-input-count"));
    countContainer.setAttribute("aria-live", "polite");
    const count = new CountBadge(countContainer, {countFormat: localize({key: "quickInput.countSelected", comment: ["This tells the user how many items are selected in a list of items to select from. The items can be anything."]}, "{0} Selected")});
    const okContainer = append(headerContainer, $6(".quick-input-action"));
    const ok2 = new Button(okContainer);
    ok2.label = localize("ok", "OK");
    this._register(ok2.onDidClick((e) => {
      this.onDidAcceptEmitter.fire();
    }));
    const customButtonContainer = append(headerContainer, $6(".quick-input-action"));
    const customButton = new Button(customButtonContainer);
    customButton.label = localize("custom", "Custom");
    this._register(customButton.onDidClick((e) => {
      this.onDidCustomEmitter.fire();
    }));
    const message = append(extraContainer, $6(`#${this.idPrefix}message.quick-input-message`));
    const progressBar = new ProgressBar(container);
    addClass(progressBar.getContainer(), "quick-input-progress");
    const list = this._register(new QuickInputList(container, this.idPrefix + "list", this.options));
    this._register(list.onChangedAllVisibleChecked((checked) => {
      checkAll.checked = checked;
    }));
    this._register(list.onChangedVisibleCount((c) => {
      visibleCount.setCount(c);
    }));
    this._register(list.onChangedCheckedCount((c) => {
      count.setCount(c);
    }));
    this._register(list.onLeave(() => {
      setTimeout(() => {
        inputBox.setFocus();
        if (this.controller instanceof QuickPick && this.controller.canSelectMany) {
          list.clearFocus();
        }
      }, 0);
    }));
    this._register(list.onDidChangeFocus(() => {
      if (this.comboboxAccessibility) {
        this.getUI().inputBox.setAttribute("aria-activedescendant", this.getUI().list.getActiveDescendant() || "");
      }
    }));
    const focusTracker = trackFocus(container);
    this._register(focusTracker);
    this._register(addDisposableListener(container, EventType.FOCUS, (e) => {
      this.previousFocusElement = e.relatedTarget instanceof HTMLElement ? e.relatedTarget : void 0;
    }, true));
    this._register(focusTracker.onDidBlur(() => {
      if (!this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut()) {
        this.hide();
      }
      this.previousFocusElement = void 0;
    }));
    this._register(addDisposableListener(container, EventType.FOCUS, (e) => {
      inputBox.setFocus();
    }));
    this._register(addDisposableListener(container, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      switch (event.keyCode) {
        case 3:
          EventHelper.stop(e, true);
          this.onDidAcceptEmitter.fire();
          break;
        case 9:
          EventHelper.stop(e, true);
          this.hide();
          break;
        case 2:
          if (!event.altKey && !event.ctrlKey && !event.metaKey) {
            const selectors = [".action-label.codicon"];
            if (container.classList.contains("show-checkboxes")) {
              selectors.push("input");
            } else {
              selectors.push("input[type=text]");
            }
            if (this.getUI().list.isDisplayed()) {
              selectors.push(".monaco-list");
            }
            const stops = container.querySelectorAll(selectors.join(", "));
            if (event.shiftKey && event.target === stops[0]) {
              EventHelper.stop(e, true);
              stops[stops.length - 1].focus();
            } else if (!event.shiftKey && event.target === stops[stops.length - 1]) {
              EventHelper.stop(e, true);
              stops[0].focus();
            }
          }
          break;
      }
    }));
    this.ui = {
      container,
      styleSheet,
      leftActionBar,
      titleBar,
      title,
      description,
      rightActionBar,
      checkAll,
      filterContainer,
      inputBox,
      visibleCountContainer,
      visibleCount,
      countContainer,
      count,
      okContainer,
      ok: ok2,
      message,
      customButtonContainer,
      customButton,
      progressBar,
      list,
      onDidAccept: this.onDidAcceptEmitter.event,
      onDidCustom: this.onDidCustomEmitter.event,
      onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
      ignoreFocusOut: false,
      keyMods: this.keyMods,
      isScreenReaderOptimized: () => this.options.isScreenReaderOptimized(),
      show: (controller) => this.show(controller),
      hide: () => this.hide(),
      setVisibilities: (visibilities) => this.setVisibilities(visibilities),
      setComboboxAccessibility: (enabled) => this.setComboboxAccessibility(enabled),
      setEnabled: (enabled) => this.setEnabled(enabled),
      setContextKey: (contextKey) => this.options.setContextKey(contextKey)
    };
    this.updateStyles();
    return this.ui;
  }
  pick(picks, options = {}, token = CancellationToken.None) {
    return new Promise((doResolve, reject) => {
      let resolve2 = (result) => {
        resolve2 = doResolve;
        if (options.onKeyMods) {
          options.onKeyMods(input.keyMods);
        }
        doResolve(result);
      };
      if (token.isCancellationRequested) {
        resolve2(void 0);
        return;
      }
      const input = this.createQuickPick();
      let activeItem;
      const disposables = [
        input,
        input.onDidAccept(() => {
          if (input.canSelectMany) {
            resolve2(input.selectedItems.slice());
            input.hide();
          } else {
            const result = input.activeItems[0];
            if (result) {
              resolve2(result);
              input.hide();
            }
          }
        }),
        input.onDidChangeActive((items) => {
          const focused = items[0];
          if (focused && options.onDidFocus) {
            options.onDidFocus(focused);
          }
        }),
        input.onDidChangeSelection((items) => {
          if (!input.canSelectMany) {
            const result = items[0];
            if (result) {
              resolve2(result);
              input.hide();
            }
          }
        }),
        input.onDidTriggerItemButton((event) => options.onDidTriggerItemButton && options.onDidTriggerItemButton(Object.assign(Object.assign({}, event), {removeItem: () => {
          const index = input.items.indexOf(event.item);
          if (index !== -1) {
            const items = input.items.slice();
            items.splice(index, 1);
            input.items = items;
          }
        }}))),
        input.onDidChangeValue((value) => {
          if (activeItem && !value && (input.activeItems.length !== 1 || input.activeItems[0] !== activeItem)) {
            input.activeItems = [activeItem];
          }
        }),
        token.onCancellationRequested(() => {
          input.hide();
        }),
        input.onDidHide(() => {
          dispose(disposables);
          resolve2(void 0);
        })
      ];
      input.canSelectMany = !!options.canPickMany;
      input.placeholder = options.placeHolder;
      input.ignoreFocusOut = !!options.ignoreFocusLost;
      input.matchOnDescription = !!options.matchOnDescription;
      input.matchOnDetail = !!options.matchOnDetail;
      input.matchOnLabel = options.matchOnLabel === void 0 || options.matchOnLabel;
      input.autoFocusOnList = options.autoFocusOnList === void 0 || options.autoFocusOnList;
      input.quickNavigate = options.quickNavigate;
      input.contextKey = options.contextKey;
      input.busy = true;
      Promise.all([picks, options.activeItem]).then(([items, _activeItem]) => {
        activeItem = _activeItem;
        input.busy = false;
        input.items = items;
        if (input.canSelectMany) {
          input.selectedItems = items.filter((item) => item.type !== "separator" && item.picked);
        }
        if (activeItem) {
          input.activeItems = [activeItem];
        }
      });
      input.show();
      Promise.resolve(picks).then(void 0, (err) => {
        reject(err);
        input.hide();
      });
    });
  }
  createQuickPick() {
    const ui = this.getUI();
    return new QuickPick(ui);
  }
  show(controller) {
    const ui = this.getUI();
    this.onShowEmitter.fire();
    const oldController = this.controller;
    this.controller = controller;
    if (oldController) {
      oldController.didHide();
    }
    this.setEnabled(true);
    ui.leftActionBar.clear();
    ui.title.textContent = "";
    ui.description.textContent = "";
    ui.rightActionBar.clear();
    ui.checkAll.checked = false;
    ui.inputBox.placeholder = "";
    ui.inputBox.password = false;
    ui.inputBox.showDecoration(severity_default.Ignore);
    ui.visibleCount.setCount(0);
    ui.count.setCount(0);
    ui.message.textContent = "";
    ui.progressBar.stop();
    ui.list.setElements([]);
    ui.list.matchOnDescription = false;
    ui.list.matchOnDetail = false;
    ui.list.matchOnLabel = true;
    ui.list.sortByLabel = true;
    ui.ignoreFocusOut = false;
    this.setComboboxAccessibility(false);
    ui.inputBox.ariaLabel = "";
    const backKeybindingLabel = this.options.backKeybindingLabel();
    backButton.tooltip = backKeybindingLabel ? localize("quickInput.backWithKeybinding", "Back ({0})", backKeybindingLabel) : localize("quickInput.back", "Back");
    ui.container.style.display = "";
    this.updateLayout();
    ui.inputBox.setFocus();
  }
  setVisibilities(visibilities) {
    const ui = this.getUI();
    ui.title.style.display = visibilities.title ? "" : "none";
    ui.description.style.display = visibilities.description ? "" : "none";
    ui.checkAll.style.display = visibilities.checkAll ? "" : "none";
    ui.filterContainer.style.display = visibilities.inputBox ? "" : "none";
    ui.visibleCountContainer.style.display = visibilities.visibleCount ? "" : "none";
    ui.countContainer.style.display = visibilities.count ? "" : "none";
    ui.okContainer.style.display = visibilities.ok ? "" : "none";
    ui.customButtonContainer.style.display = visibilities.customButton ? "" : "none";
    ui.message.style.display = visibilities.message ? "" : "none";
    ui.progressBar.getContainer().style.display = visibilities.progressBar ? "" : "none";
    ui.list.display(!!visibilities.list);
    ui.container.classList[visibilities.checkAll ? "add" : "remove"]("show-checkboxes");
    this.updateLayout();
  }
  setComboboxAccessibility(enabled) {
    if (enabled !== this.comboboxAccessibility) {
      const ui = this.getUI();
      this.comboboxAccessibility = enabled;
      if (this.comboboxAccessibility) {
        ui.inputBox.setAttribute("role", "combobox");
        ui.inputBox.setAttribute("aria-haspopup", "true");
        ui.inputBox.setAttribute("aria-autocomplete", "list");
        ui.inputBox.setAttribute("aria-activedescendant", ui.list.getActiveDescendant() || "");
      } else {
        ui.inputBox.removeAttribute("role");
        ui.inputBox.removeAttribute("aria-haspopup");
        ui.inputBox.removeAttribute("aria-autocomplete");
        ui.inputBox.removeAttribute("aria-activedescendant");
      }
    }
  }
  setEnabled(enabled) {
    if (enabled !== this.enabled) {
      this.enabled = enabled;
      for (const item of this.getUI().leftActionBar.viewItems) {
        item.getAction().enabled = enabled;
      }
      for (const item of this.getUI().rightActionBar.viewItems) {
        item.getAction().enabled = enabled;
      }
      this.getUI().checkAll.disabled = !enabled;
      this.getUI().ok.enabled = enabled;
      this.getUI().list.enabled = enabled;
    }
  }
  hide() {
    var _a;
    const controller = this.controller;
    if (controller) {
      const focusChanged = !((_a = this.ui) === null || _a === void 0 ? void 0 : _a.container.contains(document.activeElement));
      this.controller = null;
      this.onHideEmitter.fire();
      this.getUI().container.style.display = "none";
      if (!focusChanged) {
        if (this.previousFocusElement && this.previousFocusElement.offsetParent) {
          this.previousFocusElement.focus();
          this.previousFocusElement = void 0;
        } else {
          this.options.returnFocus();
        }
      }
      controller.didHide();
    }
  }
  layout(dimension, titleBarOffset) {
    this.dimension = dimension;
    this.titleBarOffset = titleBarOffset;
    this.updateLayout();
  }
  updateLayout() {
    if (this.ui) {
      this.ui.container.style.top = `${this.titleBarOffset}px`;
      const style = this.ui.container.style;
      const width = Math.min(this.dimension.width * 0.62, QuickInputController.MAX_WIDTH);
      style.width = width + "px";
      style.marginLeft = "-" + width / 2 + "px";
      this.ui.inputBox.layout();
      this.ui.list.layout(this.dimension && this.dimension.height * 0.4);
    }
  }
  applyStyles(styles) {
    this.styles = styles;
    this.updateStyles();
  }
  updateStyles() {
    if (this.ui) {
      const {quickInputTitleBackground: quickInputTitleBackground2, quickInputBackground: quickInputBackground2, quickInputForeground: quickInputForeground2, contrastBorder: contrastBorder2, widgetShadow: widgetShadow2} = this.styles.widget;
      this.ui.titleBar.style.backgroundColor = quickInputTitleBackground2 ? quickInputTitleBackground2.toString() : "";
      this.ui.container.style.backgroundColor = quickInputBackground2 ? quickInputBackground2.toString() : "";
      this.ui.container.style.color = quickInputForeground2 ? quickInputForeground2.toString() : "";
      this.ui.container.style.border = contrastBorder2 ? `1px solid ${contrastBorder2}` : "";
      this.ui.container.style.boxShadow = widgetShadow2 ? `0 5px 8px ${widgetShadow2}` : "";
      this.ui.inputBox.style(this.styles.inputBox);
      this.ui.count.style(this.styles.countBadge);
      this.ui.ok.style(this.styles.button);
      this.ui.customButton.style(this.styles.button);
      this.ui.progressBar.style(this.styles.progressBar);
      this.ui.list.style(this.styles.list);
      const content = [];
      if (this.styles.list.listInactiveFocusForeground) {
        content.push(`.monaco-list .monaco-list-row.focused { color:  ${this.styles.list.listInactiveFocusForeground}; }`);
        content.push(`.monaco-list .monaco-list-row.focused:hover { color:  ${this.styles.list.listInactiveFocusForeground}; }`);
      }
      if (this.styles.list.pickerGroupBorder) {
        content.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.list.pickerGroupBorder}; }`);
      }
      if (this.styles.list.pickerGroupForeground) {
        content.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.list.pickerGroupForeground}; }`);
      }
      const newStyles = content.join("\n");
      if (newStyles !== this.ui.styleSheet.innerHTML) {
        this.ui.styleSheet.innerHTML = newStyles;
      }
    }
  }
};
QuickInputController.MAX_WIDTH = 600;

// ../../node_modules/monaco-editor/esm/vs/platform/quickinput/common/quickInput.js
var IQuickInputService = createDecorator("quickInputService");

// ../../node_modules/monaco-editor/esm/vs/platform/quickinput/common/quickAccess.js
var DefaultQuickAccessFilterValue;
(function(DefaultQuickAccessFilterValue2) {
  DefaultQuickAccessFilterValue2[DefaultQuickAccessFilterValue2["PRESERVE"] = 0] = "PRESERVE";
  DefaultQuickAccessFilterValue2[DefaultQuickAccessFilterValue2["LAST"] = 1] = "LAST";
})(DefaultQuickAccessFilterValue || (DefaultQuickAccessFilterValue = {}));
var Extensions8 = {
  Quickaccess: "workbench.contributions.quickaccess"
};
var QuickAccessRegistry = class {
  constructor() {
    this.providers = [];
    this.defaultProvider = void 0;
  }
  registerQuickAccessProvider(provider) {
    if (provider.prefix.length === 0) {
      this.defaultProvider = provider;
    } else {
      this.providers.push(provider);
    }
    this.providers.sort((providerA, providerB) => providerB.prefix.length - providerA.prefix.length);
    return toDisposable(() => {
      this.providers.splice(this.providers.indexOf(provider), 1);
      if (this.defaultProvider === provider) {
        this.defaultProvider = void 0;
      }
    });
  }
  getQuickAccessProviders() {
    return coalesce([this.defaultProvider, ...this.providers]);
  }
  getQuickAccessProvider(prefix) {
    const result = prefix ? this.providers.find((provider) => prefix.startsWith(provider.prefix)) || void 0 : void 0;
    return result || this.defaultProvider;
  }
};
Registry2.add(Extensions8.Quickaccess, new QuickAccessRegistry());

// ../../node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickAccess.js
var __decorate23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param18 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var QuickAccessController = class QuickAccessController2 extends Disposable {
  constructor(quickInputService, instantiationService) {
    super();
    this.quickInputService = quickInputService;
    this.instantiationService = instantiationService;
    this.registry = Registry2.as(Extensions8.Quickaccess);
    this.mapProviderToDescriptor = new Map();
    this.lastAcceptedPickerValues = new Map();
    this.visibleQuickAccess = void 0;
  }
  show(value = "", options) {
    var _a;
    const [provider, descriptor] = this.getOrInstantiateProvider(value);
    const visibleQuickAccess = this.visibleQuickAccess;
    const visibleDescriptor = visibleQuickAccess === null || visibleQuickAccess === void 0 ? void 0 : visibleQuickAccess.descriptor;
    if (visibleQuickAccess && descriptor && visibleDescriptor === descriptor) {
      if (value !== descriptor.prefix && !(options === null || options === void 0 ? void 0 : options.preserveValue)) {
        visibleQuickAccess.picker.value = value;
      }
      this.adjustValueSelection(visibleQuickAccess.picker, descriptor, options);
      return;
    }
    if (descriptor && !(options === null || options === void 0 ? void 0 : options.preserveValue)) {
      let newValue = void 0;
      if (visibleQuickAccess && visibleDescriptor && visibleDescriptor !== descriptor) {
        const newValueCandidateWithoutPrefix = visibleQuickAccess.value.substr(visibleDescriptor.prefix.length);
        if (newValueCandidateWithoutPrefix) {
          newValue = `${descriptor.prefix}${newValueCandidateWithoutPrefix}`;
        }
      }
      if (!newValue) {
        const defaultFilterValue = provider === null || provider === void 0 ? void 0 : provider.defaultFilterValue;
        if (defaultFilterValue === DefaultQuickAccessFilterValue.LAST) {
          newValue = this.lastAcceptedPickerValues.get(descriptor);
        } else if (typeof defaultFilterValue === "string") {
          newValue = `${descriptor.prefix}${defaultFilterValue}`;
        }
      }
      if (typeof newValue === "string") {
        value = newValue;
      }
    }
    const disposables = new DisposableStore();
    const picker = disposables.add(this.quickInputService.createQuickPick());
    picker.value = value;
    this.adjustValueSelection(picker, descriptor, options);
    picker.placeholder = descriptor === null || descriptor === void 0 ? void 0 : descriptor.placeholder;
    picker.quickNavigate = options === null || options === void 0 ? void 0 : options.quickNavigateConfiguration;
    picker.hideInput = !!picker.quickNavigate && !visibleQuickAccess;
    if (typeof (options === null || options === void 0 ? void 0 : options.itemActivation) === "number" || (options === null || options === void 0 ? void 0 : options.quickNavigateConfiguration)) {
      picker.itemActivation = (_a = options === null || options === void 0 ? void 0 : options.itemActivation) !== null && _a !== void 0 ? _a : ItemActivation.SECOND;
    }
    picker.contextKey = descriptor === null || descriptor === void 0 ? void 0 : descriptor.contextKey;
    picker.filterValue = (value2) => value2.substring(descriptor ? descriptor.prefix.length : 0);
    if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.placeholder) {
      picker.ariaLabel = descriptor === null || descriptor === void 0 ? void 0 : descriptor.placeholder;
    }
    const cancellationToken = this.registerPickerListeners(picker, provider, descriptor, value, disposables);
    if (provider) {
      disposables.add(provider.provide(picker, cancellationToken));
    }
    picker.show();
  }
  adjustValueSelection(picker, descriptor, options) {
    var _a;
    let valueSelection;
    if (options === null || options === void 0 ? void 0 : options.preserveValue) {
      valueSelection = [picker.value.length, picker.value.length];
    } else {
      valueSelection = [(_a = descriptor === null || descriptor === void 0 ? void 0 : descriptor.prefix.length) !== null && _a !== void 0 ? _a : 0, picker.value.length];
    }
    picker.valueSelection = valueSelection;
  }
  registerPickerListeners(picker, provider, descriptor, value, disposables) {
    const visibleQuickAccess = this.visibleQuickAccess = {picker, descriptor, value};
    disposables.add(toDisposable(() => {
      if (visibleQuickAccess === this.visibleQuickAccess) {
        this.visibleQuickAccess = void 0;
      }
    }));
    disposables.add(picker.onDidChangeValue((value2) => {
      const [providerForValue] = this.getOrInstantiateProvider(value2);
      if (providerForValue !== provider) {
        this.show(value2, {preserveValue: true});
      } else {
        visibleQuickAccess.value = value2;
      }
    }));
    if (descriptor) {
      disposables.add(picker.onDidAccept(() => {
        this.lastAcceptedPickerValues.set(descriptor, picker.value);
      }));
    }
    const cts = disposables.add(new CancellationTokenSource());
    once2(picker.onDidHide)(() => {
      if (picker.selectedItems.length === 0) {
        cts.cancel();
      }
      disposables.dispose();
    });
    return cts.token;
  }
  getOrInstantiateProvider(value) {
    const providerDescriptor = this.registry.getQuickAccessProvider(value);
    if (!providerDescriptor) {
      return [void 0, void 0];
    }
    let provider = this.mapProviderToDescriptor.get(providerDescriptor);
    if (!provider) {
      provider = this.instantiationService.createInstance(providerDescriptor.ctor);
      this.mapProviderToDescriptor.set(providerDescriptor, provider);
    }
    return [provider, providerDescriptor];
  }
};
QuickAccessController = __decorate23([
  __param18(0, IQuickInputService),
  __param18(1, IInstantiationService)
], QuickAccessController);

// ../../node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInput.js
var __decorate24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param19 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var QuickInputService = class QuickInputService2 extends Themable {
  constructor(instantiationService, contextKeyService, themeService, accessibilityService, layoutService) {
    super(themeService);
    this.instantiationService = instantiationService;
    this.contextKeyService = contextKeyService;
    this.accessibilityService = accessibilityService;
    this.layoutService = layoutService;
    this.contexts = new Map();
  }
  get controller() {
    if (!this._controller) {
      this._controller = this._register(this.createController());
    }
    return this._controller;
  }
  get quickAccess() {
    if (!this._quickAccess) {
      this._quickAccess = this._register(this.instantiationService.createInstance(QuickAccessController));
    }
    return this._quickAccess;
  }
  createController(host = this.layoutService, options) {
    var _a, _b;
    const defaultOptions3 = {
      idPrefix: "quickInput_",
      container: host.container,
      ignoreFocusOut: () => false,
      isScreenReaderOptimized: () => this.accessibilityService.isScreenReaderOptimized(),
      backKeybindingLabel: () => void 0,
      setContextKey: (id) => this.setContextKey(id),
      returnFocus: () => host.focus(),
      createList: (user, container, delegate, renderers, options2) => this.instantiationService.createInstance(WorkbenchList, user, container, delegate, renderers, options2),
      styles: this.computeStyles()
    };
    const controller = this._register(new QuickInputController(Object.assign(Object.assign({}, defaultOptions3), options)));
    controller.layout(host.dimension, (_b = (_a = host.offset) === null || _a === void 0 ? void 0 : _a.top) !== null && _b !== void 0 ? _b : 0);
    this._register(host.onLayout((dimension) => {
      var _a2, _b2;
      return controller.layout(dimension, (_b2 = (_a2 = host.offset) === null || _a2 === void 0 ? void 0 : _a2.top) !== null && _b2 !== void 0 ? _b2 : 0);
    }));
    this._register(controller.onShow(() => this.resetContextKeys()));
    this._register(controller.onHide(() => this.resetContextKeys()));
    return controller;
  }
  setContextKey(id) {
    let key;
    if (id) {
      key = this.contexts.get(id);
      if (!key) {
        key = new RawContextKey(id, false).bindTo(this.contextKeyService);
        this.contexts.set(id, key);
      }
    }
    if (key && key.get()) {
      return;
    }
    this.resetContextKeys();
    if (key) {
      key.set(true);
    }
  }
  resetContextKeys() {
    this.contexts.forEach((context) => {
      if (context.get()) {
        context.reset();
      }
    });
  }
  pick(picks, options = {}, token = CancellationToken.None) {
    return this.controller.pick(picks, options, token);
  }
  createQuickPick() {
    return this.controller.createQuickPick();
  }
  updateStyles() {
    this.controller.applyStyles(this.computeStyles());
  }
  computeStyles() {
    return {
      widget: Object.assign({}, computeStyles(this.theme, {
        quickInputBackground,
        quickInputForeground,
        quickInputTitleBackground,
        contrastBorder,
        widgetShadow
      })),
      inputBox: computeStyles(this.theme, {
        inputForeground,
        inputBackground,
        inputBorder,
        inputValidationInfoBackground,
        inputValidationInfoForeground,
        inputValidationInfoBorder,
        inputValidationWarningBackground,
        inputValidationWarningForeground,
        inputValidationWarningBorder,
        inputValidationErrorBackground,
        inputValidationErrorForeground,
        inputValidationErrorBorder
      }),
      countBadge: computeStyles(this.theme, {
        badgeBackground,
        badgeForeground,
        badgeBorder: contrastBorder
      }),
      button: computeStyles(this.theme, {
        buttonForeground,
        buttonBackground,
        buttonHoverBackground,
        buttonBorder: contrastBorder
      }),
      progressBar: computeStyles(this.theme, {
        progressBarBackground
      }),
      list: computeStyles(this.theme, {
        listBackground: quickInputBackground,
        listInactiveFocusForeground: listFocusForeground,
        listInactiveFocusBackground: listFocusBackground,
        listFocusOutline: activeContrastBorder,
        listInactiveFocusOutline: activeContrastBorder,
        pickerGroupBorder,
        pickerGroupForeground
      })
    };
  }
};
QuickInputService = __decorate24([
  __param19(0, IInstantiationService),
  __param19(1, IContextKeyService),
  __param19(2, IThemeService),
  __param19(3, IAccessibilityService),
  __param19(4, ILayoutService)
], QuickInputService);

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickInput/standaloneQuickInputServiceImpl.js
var __decorate25 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param20 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var EditorScopedQuickInputServiceImpl = class EditorScopedQuickInputServiceImpl2 extends QuickInputService {
  constructor(editor2, instantiationService, contextKeyService, themeService, accessibilityService, layoutService) {
    super(instantiationService, contextKeyService, themeService, accessibilityService, layoutService);
    this.host = void 0;
    const contribution = QuickInputEditorContribution.get(editor2);
    this.host = {
      _serviceBrand: void 0,
      get container() {
        return contribution.widget.getDomNode();
      },
      get dimension() {
        return editor2.getLayoutInfo();
      },
      get onLayout() {
        return editor2.onDidLayoutChange;
      },
      focus: () => editor2.focus()
    };
  }
  createController() {
    return super.createController(this.host);
  }
};
EditorScopedQuickInputServiceImpl = __decorate25([
  __param20(1, IInstantiationService),
  __param20(2, IContextKeyService),
  __param20(3, IThemeService),
  __param20(4, IAccessibilityService),
  __param20(5, ILayoutService)
], EditorScopedQuickInputServiceImpl);
var StandaloneQuickInputServiceImpl = class StandaloneQuickInputServiceImpl2 {
  constructor(instantiationService, codeEditorService) {
    this.instantiationService = instantiationService;
    this.codeEditorService = codeEditorService;
    this.mapEditorToService = new Map();
  }
  get activeService() {
    const editor2 = this.codeEditorService.getFocusedCodeEditor();
    if (!editor2) {
      throw new Error("Quick input service needs a focused editor to work.");
    }
    let quickInputService = this.mapEditorToService.get(editor2);
    if (!quickInputService) {
      const newQuickInputService = quickInputService = this.instantiationService.createInstance(EditorScopedQuickInputServiceImpl, editor2);
      this.mapEditorToService.set(editor2, quickInputService);
      once2(editor2.onDidDispose)(() => {
        newQuickInputService.dispose();
        this.mapEditorToService.delete(editor2);
      });
    }
    return quickInputService;
  }
  get quickAccess() {
    return this.activeService.quickAccess;
  }
  pick(picks, options = {}, token = CancellationToken.None) {
    return this.activeService.pick(picks, options, token);
  }
  createQuickPick() {
    return this.activeService.createQuickPick();
  }
};
StandaloneQuickInputServiceImpl = __decorate25([
  __param20(0, IInstantiationService),
  __param20(1, ICodeEditorService)
], StandaloneQuickInputServiceImpl);
var QuickInputEditorContribution = class {
  constructor(editor2) {
    this.editor = editor2;
    this.widget = new QuickInputEditorWidget(this.editor);
  }
  static get(editor2) {
    return editor2.getContribution(QuickInputEditorContribution.ID);
  }
  dispose() {
    this.widget.dispose();
  }
};
QuickInputEditorContribution.ID = "editor.controller.quickInput";
var QuickInputEditorWidget = class {
  constructor(codeEditor) {
    this.codeEditor = codeEditor;
    this.domNode = document.createElement("div");
    this.codeEditor.addOverlayWidget(this);
  }
  getId() {
    return QuickInputEditorWidget.ID;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {preference: 2};
  }
  dispose() {
    this.codeEditor.removeOverlayWidget(this);
  }
};
QuickInputEditorWidget.ID = "editor.contrib.quickInputWidget";
registerEditorContribution(QuickInputEditorContribution.ID, QuickInputEditorContribution);

// ../../node_modules/monaco-editor/esm/vs/platform/userDataSync/common/storageKeys.js
var IStorageKeysSyncRegistryService = createDecorator("IStorageKeysSyncRegistryService");
var StorageKeysSyncRegistryService = class extends Disposable {
  constructor() {
    super();
    this._storageKeys = new Map();
    this._onDidChangeStorageKeys = this._register(new Emitter());
    this._register(toDisposable(() => this._storageKeys.clear()));
  }
  get storageKeys() {
    return [...this._storageKeys.values()];
  }
  registerStorageKey(storageKey) {
    if (!this._storageKeys.has(storageKey.key)) {
      this._storageKeys.set(storageKey.key, storageKey);
      this._onDidChangeStorageKeys.fire(this.storageKeys);
    }
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
var StaticServices;
(function(StaticServices2) {
  const _serviceCollection = new ServiceCollection();
  class LazyStaticService {
    constructor(serviceId, factory) {
      this._serviceId = serviceId;
      this._factory = factory;
      this._value = null;
    }
    get id() {
      return this._serviceId;
    }
    get(overrides) {
      if (!this._value) {
        if (overrides) {
          this._value = overrides[this._serviceId.toString()];
        }
        if (!this._value) {
          this._value = this._factory(overrides);
        }
        if (!this._value) {
          throw new Error("Service " + this._serviceId + " is missing!");
        }
        _serviceCollection.set(this._serviceId, this._value);
      }
      return this._value;
    }
  }
  StaticServices2.LazyStaticService = LazyStaticService;
  let _all = [];
  function define(serviceId, factory) {
    let r = new LazyStaticService(serviceId, factory);
    _all.push(r);
    return r;
  }
  function init(overrides) {
    let result = new ServiceCollection();
    for (const [id, descriptor] of getSingletonServiceDescriptors()) {
      result.set(id, descriptor);
    }
    for (let serviceId in overrides) {
      if (overrides.hasOwnProperty(serviceId)) {
        result.set(createDecorator(serviceId), overrides[serviceId]);
      }
    }
    _all.forEach((service) => result.set(service.id, service.get(overrides)));
    let instantiationService = new InstantiationService(result, true);
    result.set(IInstantiationService, instantiationService);
    return [result, instantiationService];
  }
  StaticServices2.init = init;
  StaticServices2.instantiationService = define(IInstantiationService, () => new InstantiationService(_serviceCollection, true));
  const configurationServiceImpl = new SimpleConfigurationService();
  StaticServices2.configurationService = define(IConfigurationService, () => configurationServiceImpl);
  StaticServices2.resourceConfigurationService = define(ITextResourceConfigurationService, () => new SimpleResourceConfigurationService(configurationServiceImpl));
  StaticServices2.resourcePropertiesService = define(ITextResourcePropertiesService, () => new SimpleResourcePropertiesService(configurationServiceImpl));
  StaticServices2.contextService = define(IWorkspaceContextService, () => new SimpleWorkspaceContextService());
  StaticServices2.labelService = define(ILabelService, () => new SimpleUriLabelService());
  StaticServices2.telemetryService = define(ITelemetryService, () => new StandaloneTelemetryService());
  StaticServices2.dialogService = define(IDialogService, () => new SimpleDialogService());
  StaticServices2.notificationService = define(INotificationService, () => new SimpleNotificationService());
  StaticServices2.markerService = define(IMarkerService, () => new MarkerService());
  StaticServices2.modeService = define(IModeService, (o) => new ModeServiceImpl());
  StaticServices2.standaloneThemeService = define(IStandaloneThemeService, () => new StandaloneThemeServiceImpl());
  StaticServices2.logService = define(ILogService, () => new ConsoleLogService());
  StaticServices2.undoRedoService = define(IUndoRedoService, (o) => new UndoRedoService(StaticServices2.dialogService.get(o), StaticServices2.notificationService.get(o)));
  StaticServices2.modelService = define(IModelService, (o) => new ModelServiceImpl(StaticServices2.configurationService.get(o), StaticServices2.resourcePropertiesService.get(o), StaticServices2.standaloneThemeService.get(o), StaticServices2.logService.get(o), StaticServices2.undoRedoService.get(o)));
  StaticServices2.markerDecorationsService = define(IMarkerDecorationsService, (o) => new MarkerDecorationsService(StaticServices2.modelService.get(o), StaticServices2.markerService.get(o)));
  StaticServices2.codeEditorService = define(ICodeEditorService, (o) => new StandaloneCodeEditorServiceImpl(StaticServices2.standaloneThemeService.get(o)));
  StaticServices2.editorProgressService = define(IEditorProgressService, () => new SimpleEditorProgressService());
  StaticServices2.storageService = define(IStorageService, () => new InMemoryStorageService());
  StaticServices2.storageSyncService = define(IStorageKeysSyncRegistryService, () => new StorageKeysSyncRegistryService());
  StaticServices2.editorWorkerService = define(IEditorWorkerService, (o) => new EditorWorkerServiceImpl(StaticServices2.modelService.get(o), StaticServices2.resourceConfigurationService.get(o), StaticServices2.logService.get(o)));
})(StaticServices || (StaticServices = {}));
var DynamicStandaloneServices = class extends Disposable {
  constructor(domElement, overrides) {
    super();
    const [_serviceCollection, _instantiationService] = StaticServices.init(overrides);
    this._serviceCollection = _serviceCollection;
    this._instantiationService = _instantiationService;
    const configurationService = this.get(IConfigurationService);
    const notificationService = this.get(INotificationService);
    const telemetryService = this.get(ITelemetryService);
    const themeService = this.get(IThemeService);
    const logService = this.get(ILogService);
    let ensure = (serviceId, factory) => {
      let value = null;
      if (overrides) {
        value = overrides[serviceId.toString()];
      }
      if (!value) {
        value = factory();
      }
      this._serviceCollection.set(serviceId, value);
      return value;
    };
    let contextKeyService = ensure(IContextKeyService, () => this._register(new ContextKeyService(configurationService)));
    ensure(IAccessibilityService, () => new AccessibilityService(contextKeyService, configurationService));
    ensure(IListService, () => new ListService(themeService));
    let commandService = ensure(ICommandService, () => new StandaloneCommandService(this._instantiationService));
    let keybindingService = ensure(IKeybindingService, () => this._register(new StandaloneKeybindingService(contextKeyService, commandService, telemetryService, notificationService, logService, domElement)));
    let layoutService = ensure(ILayoutService, () => new SimpleLayoutService(StaticServices.codeEditorService.get(ICodeEditorService), domElement));
    ensure(IQuickInputService, () => new StandaloneQuickInputServiceImpl(_instantiationService, StaticServices.codeEditorService.get(ICodeEditorService)));
    let contextViewService = ensure(IContextViewService, () => this._register(new ContextViewService(layoutService)));
    ensure(IClipboardService, () => new BrowserClipboardService());
    ensure(IContextMenuService, () => {
      const contextMenuService = new ContextMenuService(telemetryService, notificationService, contextViewService, keybindingService, themeService);
      contextMenuService.configure({blockMouse: false});
      return this._register(contextMenuService);
    });
    ensure(IMenuService, () => new MenuService(commandService));
    ensure(IBulkEditService, () => new SimpleBulkEditService(StaticServices.modelService.get(IModelService)));
  }
  get(serviceId) {
    let r = this._serviceCollection.get(serviceId);
    if (!r) {
      throw new Error("Missing service " + serviceId);
    }
    return r;
  }
  set(serviceId, instance) {
    this._serviceCollection.set(serviceId, instance);
  }
  has(serviceId) {
    return this._serviceCollection.has(serviceId);
  }
};

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneEditor.js
function withAllStandaloneServices(domElement, override, callback) {
  let services = new DynamicStandaloneServices(domElement, override);
  let simpleEditorModelResolverService = null;
  if (!services.has(ITextModelService)) {
    simpleEditorModelResolverService = new SimpleEditorModelResolverService(StaticServices.modelService.get());
    services.set(ITextModelService, simpleEditorModelResolverService);
  }
  if (!services.has(IOpenerService)) {
    services.set(IOpenerService, new OpenerService(services.get(ICodeEditorService), services.get(ICommandService)));
  }
  let result = callback(services);
  if (simpleEditorModelResolverService) {
    simpleEditorModelResolverService.setEditor(result);
  }
  return result;
}
function create(domElement, options, override) {
  return withAllStandaloneServices(domElement, override || {}, (services) => {
    return new StandaloneEditor(domElement, options, services, services.get(IInstantiationService), services.get(ICodeEditorService), services.get(ICommandService), services.get(IContextKeyService), services.get(IKeybindingService), services.get(IContextViewService), services.get(IStandaloneThemeService), services.get(INotificationService), services.get(IConfigurationService), services.get(IAccessibilityService));
  });
}
function onDidCreateEditor(listener) {
  return StaticServices.codeEditorService.get().onCodeEditorAdd((editor2) => {
    listener(editor2);
  });
}
function createDiffEditor(domElement, options, override) {
  return withAllStandaloneServices(domElement, override || {}, (services) => {
    return new StandaloneDiffEditor(domElement, options, services, services.get(IInstantiationService), services.get(IContextKeyService), services.get(IKeybindingService), services.get(IContextViewService), services.get(IEditorWorkerService), services.get(ICodeEditorService), services.get(IStandaloneThemeService), services.get(INotificationService), services.get(IConfigurationService), services.get(IContextMenuService), services.get(IEditorProgressService), services.get(IClipboardService));
  });
}
function createDiffNavigator(diffEditor, opts) {
  return new DiffNavigator(diffEditor, opts);
}
function doCreateModel(value, languageSelection, uri) {
  return StaticServices.modelService.get().createModel(value, languageSelection, uri);
}
function createModel(value, language, uri) {
  value = value || "";
  if (!language) {
    let firstLF = value.indexOf("\n");
    let firstLine = value;
    if (firstLF !== -1) {
      firstLine = value.substring(0, firstLF);
    }
    return doCreateModel(value, StaticServices.modeService.get().createByFilepathOrFirstLine(uri || null, firstLine), uri);
  }
  return doCreateModel(value, StaticServices.modeService.get().create(language), uri);
}
function setModelLanguage(model2, languageId) {
  StaticServices.modelService.get().setMode(model2, StaticServices.modeService.get().create(languageId));
}
function setModelMarkers(model2, owner, markers) {
  if (model2) {
    StaticServices.markerService.get().changeOne(owner, model2.uri, markers);
  }
}
function getModelMarkers(filter) {
  return StaticServices.markerService.get().read(filter);
}
function getModel(uri) {
  return StaticServices.modelService.get().getModel(uri);
}
function getModels() {
  return StaticServices.modelService.get().getModels();
}
function onDidCreateModel(listener) {
  return StaticServices.modelService.get().onModelAdded(listener);
}
function onWillDisposeModel(listener) {
  return StaticServices.modelService.get().onModelRemoved(listener);
}
function onDidChangeModelLanguage(listener) {
  return StaticServices.modelService.get().onModelModeChanged((e) => {
    listener({
      model: e.model,
      oldLanguage: e.oldModeId
    });
  });
}
function createWebWorker2(opts) {
  return createWebWorker(StaticServices.modelService.get(), opts);
}
function colorizeElement(domNode, options) {
  const themeService = StaticServices.standaloneThemeService.get();
  themeService.registerEditorContainer(domNode);
  return Colorizer.colorizeElement(themeService, StaticServices.modeService.get(), domNode, options);
}
function colorize(text, languageId, options) {
  const themeService = StaticServices.standaloneThemeService.get();
  themeService.registerEditorContainer(document.body);
  return Colorizer.colorize(StaticServices.modeService.get(), text, languageId, options);
}
function colorizeModelLine(model2, lineNumber, tabSize = 4) {
  const themeService = StaticServices.standaloneThemeService.get();
  themeService.registerEditorContainer(document.body);
  return Colorizer.colorizeModelLine(model2, lineNumber, tabSize);
}
function getSafeTokenizationSupport(language) {
  let tokenizationSupport = TokenizationRegistry.get(language);
  if (tokenizationSupport) {
    return tokenizationSupport;
  }
  return {
    getInitialState: () => NULL_STATE,
    tokenize: (line, state, deltaOffset) => nullTokenize(language, line, state, deltaOffset)
  };
}
function tokenize(text, languageId) {
  let modeService = StaticServices.modeService.get();
  modeService.triggerMode(languageId);
  let tokenizationSupport = getSafeTokenizationSupport(languageId);
  let lines = text.split(/\r\n|\r|\n/);
  let result = [];
  let state = tokenizationSupport.getInitialState();
  for (let i = 0, len = lines.length; i < len; i++) {
    let line = lines[i];
    let tokenizationResult = tokenizationSupport.tokenize(line, state, 0);
    result[i] = tokenizationResult.tokens;
    state = tokenizationResult.endState;
  }
  return result;
}
function defineTheme(themeName, themeData) {
  StaticServices.standaloneThemeService.get().defineTheme(themeName, themeData);
}
function setTheme(themeName) {
  StaticServices.standaloneThemeService.get().setTheme(themeName);
}
function remeasureFonts() {
  clearAllFontInfos();
}
function createMonacoEditorAPI() {
  return {
    create,
    onDidCreateEditor,
    createDiffEditor,
    createDiffNavigator,
    createModel,
    setModelLanguage,
    setModelMarkers,
    getModelMarkers,
    getModels,
    getModel,
    onDidCreateModel,
    onWillDisposeModel,
    onDidChangeModelLanguage,
    createWebWorker: createWebWorker2,
    colorizeElement,
    colorize,
    colorizeModelLine,
    tokenize,
    defineTheme,
    setTheme,
    remeasureFonts,
    AccessibilitySupport,
    ContentWidgetPositionPreference,
    CursorChangeReason,
    DefaultEndOfLine,
    EditorAutoIndentStrategy,
    EditorOption,
    EndOfLinePreference,
    EndOfLineSequence,
    MinimapPosition,
    MouseTargetType,
    OverlayWidgetPositionPreference,
    OverviewRulerLane,
    RenderLineNumbersType,
    RenderMinimap,
    ScrollbarVisibility,
    ScrollType,
    TextEditorCursorBlinkingStyle,
    TextEditorCursorStyle: TextEditorCursorStyle2,
    TrackedRangeStickiness,
    WrappingIndent,
    ConfigurationChangedEvent,
    BareFontInfo,
    FontInfo,
    TextModelResolvedOptions,
    FindMatch,
    EditorType,
    EditorOptions
  };
}

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCompile.js
function isArrayOf(elemType, obj) {
  if (!obj) {
    return false;
  }
  if (!Array.isArray(obj)) {
    return false;
  }
  for (const el of obj) {
    if (!elemType(el)) {
      return false;
    }
  }
  return true;
}
function bool(prop, defValue) {
  if (typeof prop === "boolean") {
    return prop;
  }
  return defValue;
}
function string(prop, defValue) {
  if (typeof prop === "string") {
    return prop;
  }
  return defValue;
}
function arrayToHash(array) {
  const result = {};
  for (const e of array) {
    result[e] = true;
  }
  return result;
}
function createKeywordMatcher(arr, caseInsensitive = false) {
  if (caseInsensitive) {
    arr = arr.map(function(x) {
      return x.toLowerCase();
    });
  }
  const hash = arrayToHash(arr);
  if (caseInsensitive) {
    return function(word) {
      return hash[word.toLowerCase()] !== void 0 && hash.hasOwnProperty(word.toLowerCase());
    };
  } else {
    return function(word) {
      return hash[word] !== void 0 && hash.hasOwnProperty(word);
    };
  }
}
function compileRegExp(lexer, str) {
  let n = 0;
  while (str.indexOf("@") >= 0 && n < 5) {
    n++;
    str = str.replace(/@(\w+)/g, function(s, attr) {
      let sub = "";
      if (typeof lexer[attr] === "string") {
        sub = lexer[attr];
      } else if (lexer[attr] && lexer[attr] instanceof RegExp) {
        sub = lexer[attr].source;
      } else {
        if (lexer[attr] === void 0) {
          throw createError(lexer, "language definition does not contain attribute '" + attr + "', used at: " + str);
        } else {
          throw createError(lexer, "attribute reference '" + attr + "' must be a string, used at: " + str);
        }
      }
      return empty(sub) ? "" : "(?:" + sub + ")";
    });
  }
  let flags = (lexer.ignoreCase ? "i" : "") + (lexer.unicode ? "u" : "");
  return new RegExp(str, flags);
}
function selectScrutinee(id, matches, state, num) {
  if (num < 0) {
    return id;
  }
  if (num < matches.length) {
    return matches[num];
  }
  if (num >= 100) {
    num = num - 100;
    let parts = state.split(".");
    parts.unshift(state);
    if (num < parts.length) {
      return parts[num];
    }
  }
  return null;
}
function createGuard(lexer, ruleName, tkey, val) {
  let scrut = -1;
  let oppat = tkey;
  let matches = tkey.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
  if (matches) {
    if (matches[3]) {
      scrut = parseInt(matches[3]);
      if (matches[2]) {
        scrut = scrut + 100;
      }
    }
    oppat = matches[4];
  }
  let op = "~";
  let pat = oppat;
  if (!oppat || oppat.length === 0) {
    op = "!=";
    pat = "";
  } else if (/^\w*$/.test(pat)) {
    op = "==";
  } else {
    matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);
    if (matches) {
      op = matches[1];
      pat = matches[2];
    }
  }
  let tester;
  if ((op === "~" || op === "!~") && /^(\w|\|)*$/.test(pat)) {
    let inWords = createKeywordMatcher(pat.split("|"), lexer.ignoreCase);
    tester = function(s) {
      return op === "~" ? inWords(s) : !inWords(s);
    };
  } else if (op === "@" || op === "!@") {
    let words = lexer[pat];
    if (!words) {
      throw createError(lexer, "the @ match target '" + pat + "' is not defined, in rule: " + ruleName);
    }
    if (!isArrayOf(function(elem) {
      return typeof elem === "string";
    }, words)) {
      throw createError(lexer, "the @ match target '" + pat + "' must be an array of strings, in rule: " + ruleName);
    }
    let inWords = createKeywordMatcher(words, lexer.ignoreCase);
    tester = function(s) {
      return op === "@" ? inWords(s) : !inWords(s);
    };
  } else if (op === "~" || op === "!~") {
    if (pat.indexOf("$") < 0) {
      let re = compileRegExp(lexer, "^" + pat + "$");
      tester = function(s) {
        return op === "~" ? re.test(s) : !re.test(s);
      };
    } else {
      tester = function(s, id, matches2, state) {
        let re = compileRegExp(lexer, "^" + substituteMatches(lexer, pat, id, matches2, state) + "$");
        return re.test(s);
      };
    }
  } else {
    if (pat.indexOf("$") < 0) {
      let patx = fixCase(lexer, pat);
      tester = function(s) {
        return op === "==" ? s === patx : s !== patx;
      };
    } else {
      let patx = fixCase(lexer, pat);
      tester = function(s, id, matches2, state, eos) {
        let patexp = substituteMatches(lexer, patx, id, matches2, state);
        return op === "==" ? s === patexp : s !== patexp;
      };
    }
  }
  if (scrut === -1) {
    return {
      name: tkey,
      value: val,
      test: function(id, matches2, state, eos) {
        return tester(id, id, matches2, state, eos);
      }
    };
  } else {
    return {
      name: tkey,
      value: val,
      test: function(id, matches2, state, eos) {
        let scrutinee = selectScrutinee(id, matches2, state, scrut);
        return tester(!scrutinee ? "" : scrutinee, id, matches2, state, eos);
      }
    };
  }
}
function compileAction(lexer, ruleName, action) {
  if (!action) {
    return {token: ""};
  } else if (typeof action === "string") {
    return action;
  } else if (action.token || action.token === "") {
    if (typeof action.token !== "string") {
      throw createError(lexer, "a 'token' attribute must be of type string, in rule: " + ruleName);
    } else {
      let newAction = {token: action.token};
      if (action.token.indexOf("$") >= 0) {
        newAction.tokenSubst = true;
      }
      if (typeof action.bracket === "string") {
        if (action.bracket === "@open") {
          newAction.bracket = 1;
        } else if (action.bracket === "@close") {
          newAction.bracket = -1;
        } else {
          throw createError(lexer, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + ruleName);
        }
      }
      if (action.next) {
        if (typeof action.next !== "string") {
          throw createError(lexer, "the next state must be a string value in rule: " + ruleName);
        } else {
          let next = action.next;
          if (!/^(@pop|@push|@popall)$/.test(next)) {
            if (next[0] === "@") {
              next = next.substr(1);
            }
            if (next.indexOf("$") < 0) {
              if (!stateExists(lexer, substituteMatches(lexer, next, "", [], ""))) {
                throw createError(lexer, "the next state '" + action.next + "' is not defined in rule: " + ruleName);
              }
            }
          }
          newAction.next = next;
        }
      }
      if (typeof action.goBack === "number") {
        newAction.goBack = action.goBack;
      }
      if (typeof action.switchTo === "string") {
        newAction.switchTo = action.switchTo;
      }
      if (typeof action.log === "string") {
        newAction.log = action.log;
      }
      if (typeof action.nextEmbedded === "string") {
        newAction.nextEmbedded = action.nextEmbedded;
        lexer.usesEmbedded = true;
      }
      return newAction;
    }
  } else if (Array.isArray(action)) {
    let results = [];
    for (let i = 0, len = action.length; i < len; i++) {
      results[i] = compileAction(lexer, ruleName, action[i]);
    }
    return {group: results};
  } else if (action.cases) {
    let cases = [];
    for (let tkey in action.cases) {
      if (action.cases.hasOwnProperty(tkey)) {
        const val = compileAction(lexer, ruleName, action.cases[tkey]);
        if (tkey === "@default" || tkey === "@" || tkey === "") {
          cases.push({test: void 0, value: val, name: tkey});
        } else if (tkey === "@eos") {
          cases.push({test: function(id, matches, state, eos) {
            return eos;
          }, value: val, name: tkey});
        } else {
          cases.push(createGuard(lexer, ruleName, tkey, val));
        }
      }
    }
    const def = lexer.defaultToken;
    return {
      test: function(id, matches, state, eos) {
        for (const _case of cases) {
          const didmatch = !_case.test || _case.test(id, matches, state, eos);
          if (didmatch) {
            return _case.value;
          }
        }
        return def;
      }
    };
  } else {
    throw createError(lexer, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + ruleName);
  }
}
var Rule = class {
  constructor(name) {
    this.regex = new RegExp("");
    this.action = {token: ""};
    this.matchOnlyAtLineStart = false;
    this.name = "";
    this.name = name;
  }
  setRegex(lexer, re) {
    let sregex;
    if (typeof re === "string") {
      sregex = re;
    } else if (re instanceof RegExp) {
      sregex = re.source;
    } else {
      throw createError(lexer, "rules must start with a match string or regular expression: " + this.name);
    }
    this.matchOnlyAtLineStart = sregex.length > 0 && sregex[0] === "^";
    this.name = this.name + ": " + sregex;
    this.regex = compileRegExp(lexer, "^(?:" + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + ")");
  }
  setAction(lexer, act) {
    this.action = compileAction(lexer, this.name, act);
  }
};
function compile(languageId, json) {
  if (!json || typeof json !== "object") {
    throw new Error("Monarch: expecting a language definition object");
  }
  let lexer = {};
  lexer.languageId = languageId;
  lexer.noThrow = false;
  lexer.maxStack = 100;
  lexer.start = typeof json.start === "string" ? json.start : null;
  lexer.ignoreCase = bool(json.ignoreCase, false);
  lexer.unicode = bool(json.unicode, false);
  lexer.tokenPostfix = string(json.tokenPostfix, "." + lexer.languageId);
  lexer.defaultToken = string(json.defaultToken, "source");
  lexer.usesEmbedded = false;
  let lexerMin = json;
  lexerMin.languageId = languageId;
  lexerMin.ignoreCase = lexer.ignoreCase;
  lexerMin.unicode = lexer.unicode;
  lexerMin.noThrow = lexer.noThrow;
  lexerMin.usesEmbedded = lexer.usesEmbedded;
  lexerMin.stateNames = json.tokenizer;
  lexerMin.defaultToken = lexer.defaultToken;
  function addRules(state, newrules, rules) {
    for (const rule of rules) {
      let include = rule.include;
      if (include) {
        if (typeof include !== "string") {
          throw createError(lexer, "an 'include' attribute must be a string at: " + state);
        }
        if (include[0] === "@") {
          include = include.substr(1);
        }
        if (!json.tokenizer[include]) {
          throw createError(lexer, "include target '" + include + "' is not defined at: " + state);
        }
        addRules(state + "." + include, newrules, json.tokenizer[include]);
      } else {
        const newrule = new Rule(state);
        if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {
          newrule.setRegex(lexerMin, rule[0]);
          if (rule.length >= 3) {
            if (typeof rule[1] === "string") {
              newrule.setAction(lexerMin, {token: rule[1], next: rule[2]});
            } else if (typeof rule[1] === "object") {
              const rule1 = rule[1];
              rule1.next = rule[2];
              newrule.setAction(lexerMin, rule1);
            } else {
              throw createError(lexer, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + state);
            }
          } else {
            newrule.setAction(lexerMin, rule[1]);
          }
        } else {
          if (!rule.regex) {
            throw createError(lexer, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + state);
          }
          if (rule.name) {
            if (typeof rule.name === "string") {
              newrule.name = rule.name;
            }
          }
          if (rule.matchOnlyAtStart) {
            newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart, false);
          }
          newrule.setRegex(lexerMin, rule.regex);
          newrule.setAction(lexerMin, rule.action);
        }
        newrules.push(newrule);
      }
    }
  }
  if (!json.tokenizer || typeof json.tokenizer !== "object") {
    throw createError(lexer, "a language definition must define the 'tokenizer' attribute as an object");
  }
  lexer.tokenizer = [];
  for (let key in json.tokenizer) {
    if (json.tokenizer.hasOwnProperty(key)) {
      if (!lexer.start) {
        lexer.start = key;
      }
      const rules = json.tokenizer[key];
      lexer.tokenizer[key] = new Array();
      addRules("tokenizer." + key, lexer.tokenizer[key], rules);
    }
  }
  lexer.usesEmbedded = lexerMin.usesEmbedded;
  if (json.brackets) {
    if (!Array.isArray(json.brackets)) {
      throw createError(lexer, "the 'brackets' attribute must be defined as an array");
    }
  } else {
    json.brackets = [
      {open: "{", close: "}", token: "delimiter.curly"},
      {open: "[", close: "]", token: "delimiter.square"},
      {open: "(", close: ")", token: "delimiter.parenthesis"},
      {open: "<", close: ">", token: "delimiter.angle"}
    ];
  }
  let brackets = [];
  for (let el of json.brackets) {
    let desc = el;
    if (desc && Array.isArray(desc) && desc.length === 3) {
      desc = {token: desc[2], open: desc[0], close: desc[1]};
    }
    if (desc.open === desc.close) {
      throw createError(lexer, "open and close brackets in a 'brackets' attribute must be different: " + desc.open + "\n hint: use the 'bracket' attribute if matching on equal brackets is required.");
    }
    if (typeof desc.open === "string" && typeof desc.token === "string" && typeof desc.close === "string") {
      brackets.push({
        token: desc.token + lexer.tokenPostfix,
        open: fixCase(lexer, desc.open),
        close: fixCase(lexer, desc.close)
      });
    } else {
      throw createError(lexer, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
    }
  }
  lexer.brackets = brackets;
  lexer.noThrow = true;
  return lexer;
}

// ../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneLanguages.js
function register2(language) {
  ModesRegistry.registerLanguage(language);
}
function getLanguages() {
  let result = [];
  result = result.concat(ModesRegistry.getLanguages());
  return result;
}
function getEncodedLanguageId(languageId) {
  let lid = StaticServices.modeService.get().getLanguageIdentifier(languageId);
  return lid ? lid.id : 0;
}
function onLanguage(languageId, callback) {
  let disposable = StaticServices.modeService.get().onDidCreateMode((mode) => {
    if (mode.getId() === languageId) {
      disposable.dispose();
      callback();
    }
  });
  return disposable;
}
function setLanguageConfiguration(languageId, configuration) {
  let languageIdentifier = StaticServices.modeService.get().getLanguageIdentifier(languageId);
  if (!languageIdentifier) {
    throw new Error(`Cannot set configuration for unknown language ${languageId}`);
  }
  return LanguageConfigurationRegistry.register(languageIdentifier, configuration);
}
var EncodedTokenizationSupport2Adapter = class {
  constructor(actual) {
    this._actual = actual;
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  tokenize(line, state, offsetDelta) {
    throw new Error("Not supported!");
  }
  tokenize2(line, state) {
    let result = this._actual.tokenizeEncoded(line, state);
    return new TokenizationResult2(result.tokens, result.endState);
  }
};
var TokenizationSupport2Adapter = class {
  constructor(standaloneThemeService, languageIdentifier, actual) {
    this._standaloneThemeService = standaloneThemeService;
    this._languageIdentifier = languageIdentifier;
    this._actual = actual;
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  _toClassicTokens(tokens, language, offsetDelta) {
    let result = [];
    let previousStartIndex = 0;
    for (let i = 0, len = tokens.length; i < len; i++) {
      const t = tokens[i];
      let startIndex = t.startIndex;
      if (i === 0) {
        startIndex = 0;
      } else if (startIndex < previousStartIndex) {
        startIndex = previousStartIndex;
      }
      result[i] = new Token(startIndex + offsetDelta, t.scopes, language);
      previousStartIndex = startIndex;
    }
    return result;
  }
  tokenize(line, state, offsetDelta) {
    let actualResult = this._actual.tokenize(line, state);
    let tokens = this._toClassicTokens(actualResult.tokens, this._languageIdentifier.language, offsetDelta);
    let endState;
    if (actualResult.endState.equals(state)) {
      endState = state;
    } else {
      endState = actualResult.endState;
    }
    return new TokenizationResult(tokens, endState);
  }
  _toBinaryTokens(tokens, offsetDelta) {
    const languageId = this._languageIdentifier.id;
    const tokenTheme = this._standaloneThemeService.getColorTheme().tokenTheme;
    let result = [], resultLen = 0;
    let previousStartIndex = 0;
    for (let i = 0, len = tokens.length; i < len; i++) {
      const t = tokens[i];
      const metadata = tokenTheme.match(languageId, t.scopes);
      if (resultLen > 0 && result[resultLen - 1] === metadata) {
        continue;
      }
      let startIndex = t.startIndex;
      if (i === 0) {
        startIndex = 0;
      } else if (startIndex < previousStartIndex) {
        startIndex = previousStartIndex;
      }
      result[resultLen++] = startIndex + offsetDelta;
      result[resultLen++] = metadata;
      previousStartIndex = startIndex;
    }
    let actualResult = new Uint32Array(resultLen);
    for (let i = 0; i < resultLen; i++) {
      actualResult[i] = result[i];
    }
    return actualResult;
  }
  tokenize2(line, state, offsetDelta) {
    let actualResult = this._actual.tokenize(line, state);
    let tokens = this._toBinaryTokens(actualResult.tokens, offsetDelta);
    let endState;
    if (actualResult.endState.equals(state)) {
      endState = state;
    } else {
      endState = actualResult.endState;
    }
    return new TokenizationResult2(tokens, endState);
  }
};
function isEncodedTokensProvider(provider) {
  return "tokenizeEncoded" in provider;
}
function isThenable2(obj) {
  return obj && typeof obj.then === "function";
}
function setTokensProvider(languageId, provider) {
  let languageIdentifier = StaticServices.modeService.get().getLanguageIdentifier(languageId);
  if (!languageIdentifier) {
    throw new Error(`Cannot set tokens provider for unknown language ${languageId}`);
  }
  const create2 = (provider2) => {
    if (isEncodedTokensProvider(provider2)) {
      return new EncodedTokenizationSupport2Adapter(provider2);
    } else {
      return new TokenizationSupport2Adapter(StaticServices.standaloneThemeService.get(), languageIdentifier, provider2);
    }
  };
  if (isThenable2(provider)) {
    return TokenizationRegistry.registerPromise(languageId, provider.then((provider2) => create2(provider2)));
  }
  return TokenizationRegistry.register(languageId, create2(provider));
}
function setMonarchTokensProvider(languageId, languageDef) {
  const create2 = (languageDef2) => {
    return createTokenizationSupport(StaticServices.modeService.get(), StaticServices.standaloneThemeService.get(), languageId, compile(languageId, languageDef2));
  };
  if (isThenable2(languageDef)) {
    return TokenizationRegistry.registerPromise(languageId, languageDef.then((languageDef2) => create2(languageDef2)));
  }
  return TokenizationRegistry.register(languageId, create2(languageDef));
}
function registerReferenceProvider(languageId, provider) {
  return ReferenceProviderRegistry.register(languageId, provider);
}
function registerRenameProvider(languageId, provider) {
  return RenameProviderRegistry.register(languageId, provider);
}
function registerSignatureHelpProvider(languageId, provider) {
  return SignatureHelpProviderRegistry.register(languageId, provider);
}
function registerHoverProvider(languageId, provider) {
  return HoverProviderRegistry.register(languageId, {
    provideHover: (model2, position, token) => {
      let word = model2.getWordAtPosition(position);
      return Promise.resolve(provider.provideHover(model2, position, token)).then((value) => {
        if (!value) {
          return void 0;
        }
        if (!value.range && word) {
          value.range = new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
        }
        if (!value.range) {
          value.range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
        }
        return value;
      });
    }
  });
}
function registerDocumentSymbolProvider(languageId, provider) {
  return DocumentSymbolProviderRegistry.register(languageId, provider);
}
function registerDocumentHighlightProvider(languageId, provider) {
  return DocumentHighlightProviderRegistry.register(languageId, provider);
}
function registerOnTypeRenameProvider(languageId, provider) {
  return OnTypeRenameProviderRegistry.register(languageId, provider);
}
function registerDefinitionProvider(languageId, provider) {
  return DefinitionProviderRegistry.register(languageId, provider);
}
function registerImplementationProvider(languageId, provider) {
  return ImplementationProviderRegistry.register(languageId, provider);
}
function registerTypeDefinitionProvider(languageId, provider) {
  return TypeDefinitionProviderRegistry.register(languageId, provider);
}
function registerCodeLensProvider(languageId, provider) {
  return CodeLensProviderRegistry.register(languageId, provider);
}
function registerCodeActionProvider(languageId, provider) {
  return CodeActionProviderRegistry.register(languageId, {
    provideCodeActions: (model2, range2, context, token) => {
      let markers = StaticServices.markerService.get().read({resource: model2.uri}).filter((m) => {
        return Range.areIntersectingOrTouching(m, range2);
      });
      return provider.provideCodeActions(model2, range2, {markers, only: context.only}, token);
    }
  });
}
function registerDocumentFormattingEditProvider(languageId, provider) {
  return DocumentFormattingEditProviderRegistry.register(languageId, provider);
}
function registerDocumentRangeFormattingEditProvider(languageId, provider) {
  return DocumentRangeFormattingEditProviderRegistry.register(languageId, provider);
}
function registerOnTypeFormattingEditProvider(languageId, provider) {
  return OnTypeFormattingEditProviderRegistry.register(languageId, provider);
}
function registerLinkProvider(languageId, provider) {
  return LinkProviderRegistry.register(languageId, provider);
}
function registerCompletionItemProvider(languageId, provider) {
  return CompletionProviderRegistry.register(languageId, provider);
}
function registerColorProvider(languageId, provider) {
  return ColorProviderRegistry.register(languageId, provider);
}
function registerFoldingRangeProvider(languageId, provider) {
  return FoldingRangeProviderRegistry.register(languageId, provider);
}
function registerDeclarationProvider(languageId, provider) {
  return DeclarationProviderRegistry.register(languageId, provider);
}
function registerSelectionRangeProvider(languageId, provider) {
  return SelectionRangeRegistry.register(languageId, provider);
}
function registerDocumentSemanticTokensProvider(languageId, provider) {
  return DocumentSemanticTokensProviderRegistry.register(languageId, provider);
}
function registerDocumentRangeSemanticTokensProvider(languageId, provider) {
  return DocumentRangeSemanticTokensProviderRegistry.register(languageId, provider);
}
function createMonacoLanguagesAPI() {
  return {
    register: register2,
    getLanguages,
    onLanguage,
    getEncodedLanguageId,
    setLanguageConfiguration,
    setTokensProvider,
    setMonarchTokensProvider,
    registerReferenceProvider,
    registerRenameProvider,
    registerCompletionItemProvider,
    registerSignatureHelpProvider,
    registerHoverProvider,
    registerDocumentSymbolProvider,
    registerDocumentHighlightProvider,
    registerOnTypeRenameProvider,
    registerDefinitionProvider,
    registerImplementationProvider,
    registerTypeDefinitionProvider,
    registerCodeLensProvider,
    registerCodeActionProvider,
    registerDocumentFormattingEditProvider,
    registerDocumentRangeFormattingEditProvider,
    registerOnTypeFormattingEditProvider,
    registerLinkProvider,
    registerColorProvider,
    registerFoldingRangeProvider,
    registerDeclarationProvider,
    registerSelectionRangeProvider,
    registerDocumentSemanticTokensProvider,
    registerDocumentRangeSemanticTokensProvider,
    DocumentHighlightKind,
    CompletionItemKind,
    CompletionItemTag,
    CompletionItemInsertTextRule,
    SymbolKind,
    SymbolTag,
    IndentAction,
    CompletionTriggerKind,
    SignatureHelpTriggerKind,
    FoldingRangeKind
  };
}

// ../../node_modules/monaco-editor/esm/vs/editor/editor.api.js
var global2 = self;
EditorOptions.wrappingIndent.defaultValue = 0;
EditorOptions.glyphMargin.defaultValue = false;
EditorOptions.autoIndent.defaultValue = 3;
EditorOptions.overviewRulerLanes.defaultValue = 2;
var api = createMonacoBaseAPI();
api.editor = createMonacoEditorAPI();
api.languages = createMonacoLanguagesAPI();
var CancellationTokenSource2 = api.CancellationTokenSource;
var Emitter2 = api.Emitter;
var KeyCode2 = api.KeyCode;
var KeyMod2 = api.KeyMod;
var Position2 = api.Position;
var Range3 = api.Range;
var Selection2 = api.Selection;
var SelectionDirection2 = api.SelectionDirection;
var MarkerSeverity3 = api.MarkerSeverity;
var MarkerTag2 = api.MarkerTag;
var Uri2 = api.Uri;
var Token2 = api.Token;
var editor = api.editor;
var languages = api.languages;
global2.monaco = api;
if (typeof global2.require !== "undefined" && typeof global2.require.config === "function") {
  global2.require.config({
    ignoreDuplicateModules: [
      "vscode-languageserver-types",
      "vscode-languageserver-types/main",
      "vscode-languageserver-textdocument",
      "vscode-languageserver-textdocument/main",
      "vscode-nls",
      "vscode-nls/vscode-nls",
      "jsonc-parser",
      "jsonc-parser/main",
      "vscode-uri",
      "vscode-uri/index",
      "vs/basic-languages/typescript/typescript"
    ]
  });
}

export {
  IdGenerator,
  Iterable,
  Position,
  OverviewRulerLane2 as OverviewRulerLane,
  IndentAction2 as IndentAction,
  AccessibilityHelpNLS,
  BrowserFeatures,
  isFalsyOrWhitespace,
  ICodeEditorService,
  ReplaceCommand,
  EditorZoom,
  CharacterClassifier,
  EditOperation,
  LineTokens,
  Range,
  EditorContextKeys,
  IMarkerDecorationsService,
  IModeService,
  IModelService,
  ITextModelService,
  ITextResourceConfigurationService,
  IStandaloneThemeService,
  IClipboardService,
  IContextViewService,
  IDialogService,
  IKeybindingService,
  ILabelService,
  Progress,
  IQuickInputService,
  ITelemetryService,
  IUndoRedoService,
  domEvent,
  Schemas,
  StopWatch,
  isCodeEditor,
  EditorType,
  MinimapPosition2 as MinimapPosition,
  IEditorWorkerService,
  IContextMenuService,
  StandardMouseEvent,
  LinkedList,
  clamp,
  Selection,
  InspectTokensNLS,
  IAccessibilityService,
  ariaContainer,
  HighlightedLabel,
  RGBA,
  defaultGenerator,
  isString,
  CONTEXT_ACCESSIBILITY_MODE_ENABLED,
  INotificationService,
  once2 as once,
  IBulkEditService,
  IConfigurationService,
  IInstantiationService,
  ILogService,
  MarkerSeverity2 as MarkerSeverity,
  markTracked,
  parse,
  GoToLineNLS,
  registerSingleton,
  IStorageKeysSyncRegistryService,
  IWorkspaceContextService,
  statusContainer,
  Event,
  deepClone,
  isObject,
  Extensions2 as Extensions,
  IStorageService,
  IThemeService,
  statusContainer2,
  Widget2 as Widget,
  CancellationToken,
  WordOperations,
  IEditorProgressService,
  Extensions8 as Extensions2,
  WillSaveStateReason,
  renderFormattedText,
  SearchParams,
  QuickHelpNLS,
  Registry2 as Registry,
  CountBadge,
  or,
  numberHash,
  trackDisposable,
  isNumber,
  NULL_STATE,
  Emitter2 as Emitter,
  ContextKeyExpr,
  themeColorFromId,
  errorHandler,
  matchesPrefix,
  CursorMoveCommands,
  ICommandService,
  ThemeIcon,
  severity_default,
  ResourceEdit,
  getMapForWordSeparators,
  QuickCommandNLS,
  localize,
  CommandsRegistry,
  standardMouseMoveMerger,
  originalFSPath,
  IEditorCancellationTokens,
  MoveOperations,
  createElement,
  GlobalMouseMoveMonitor,
  ActionBar,
  equals,
  onUnexpectedError,
  Range3 as Range2,
  EventType2 as EventType,
  _hasOwnProperty,
  ShiftCommand,
  TokenMetadata,
  QuickOutlineNLS,
  isWindows,
  isUndefined,
  onDidChangeZoomLevel,
  BaseActionViewItem,
  isDisposable,
  isMacintosh,
  CopyOptions,
  MarkerSeverity3 as MarkerSeverity2,
  Gesture,
  alert,
  registerIcon,
  isLinux,
  format,
  InMemoryClipboardMetadataManager,
  PLAINTEXT_MODE_ID,
  nullTokenize,
  MarkerTag2 as MarkerTag,
  Codicon,
  isNative,
  isUndefinedOrNull,
  Uri2 as Uri,
  createDecorator,
  StandardKeyboardEvent,
  stringHash,
  isWeb,
  URI,
  CancellationTokenSource,
  isIOS,
  ToggleHighContrastNLS,
  editor,
  matchesContiguousSubString,
  TabFocus,
  languages,
  isEdge,
  IconLabel,
  binarySearch,
  dispose,
  escape,
  isFirefox,
  IMarkerData,
  clearNode,
  insertMessage,
  InputBox,
  createCancelablePromise,
  TypeOperations,
  nullTokenize2,
  combinedDisposable,
  escapeRegExpCharacters,
  optional,
  isPromiseCanceledError,
  Action,
  isIPad,
  Sash,
  canceled,
  toDisposable,
  isStandalone,
  isInDOM,
  DisposableStore,
  editorCodeLensForeground,
  Delayer,
  editorBracketMatchBackground,
  illegalArgument,
  editorBracketMatchBorder,
  IOpenerService,
  HIGH_CONTRAST,
  mergeSort,
  NullOpenerService,
  mixin,
  KeybindingsRegistry,
  IMarkerService,
  ltrim,
  MenuId,
  Disposable,
  StableEditorScrollState,
  completionKindToCssClass,
  overviewRulerRangeHighlight,
  MultiCommand,
  IMenuService,
  MenuRegistry,
  registerColor,
  KeyChord,
  foreground,
  attachStyler,
  errorForeground,
  isWhitespace,
  rtrim,
  completionKindFromString,
  iconForeground,
  wordSeparators,
  focusBorder,
  contrastBorder,
  renderCodicons,
  activeContrastBorder,
  registerThemingParticipant,
  textLinkForeground,
  textCodeBlockBackground,
  HSVA,
  widgetShadow,
  SignatureHelpTriggerKind2 as SignatureHelpTriggerKind,
  inputBackground,
  timeout,
  inputForeground,
  attachListStyler,
  inputBorder,
  DocumentHighlightKind2 as DocumentHighlightKind,
  toMultilineTokens2,
  inputActiveOptionBorder,
  stripCodicons,
  startsWith,
  inputActiveOptionBackground,
  hasClass,
  extUri,
  inputActiveOptionForeground,
  addClass,
  ActionViewItem,
  disposableTimeout,
  isEqual,
  ReplaceCommandThatPreservesSelection,
  inputValidationInfoBackground,
  addClasses,
  basenameOrAuthority,
  inputValidationInfoForeground,
  removeClass,
  basename2 as basename,
  inputValidationInfoBorder,
  removeClasses,
  createFastDomNode,
  join,
  SimpleKeybinding,
  dirname2 as dirname,
  SymbolKinds,
  inputValidationWarningBackground,
  toggleClass,
  joinPath,
  EditorCommand,
  inputValidationWarningForeground,
  withNullAsUndefined,
  inputValidationWarningBorder,
  relativePath,
  inputValidationErrorBackground,
  ActionRunner,
  coalesce,
  resolvePath,
  inputValidationErrorForeground,
  inputValidationErrorBorder,
  DataUri,
  isFalsyOrEmpty,
  IListService,
  isNonEmptyArray,
  TimeoutTimer,
  badgeBackground,
  badgeForeground,
  addDisposableListener,
  Separator,
  ResourceMap,
  FoldingRangeKind,
  editorErrorForeground,
  firstNonWhitespaceIndex,
  editorErrorBorder,
  _wrapAsStandardMouseEvent,
  editorWarningForeground,
  SubmenuAction,
  EditorAction,
  ReferenceProviderRegistry,
  editorWarningBorder,
  Color,
  RenameProviderRegistry,
  editorInfoForeground,
  CompletionProviderRegistry,
  editorInfoBorder,
  SignatureHelpProviderRegistry,
  WorkbenchListFocusContextKey,
  HoverProviderRegistry,
  addStandardDisposableListener,
  getLeadingWhitespace,
  TextModel,
  DocumentSymbolProviderRegistry,
  DocumentHighlightProviderRegistry,
  SubmenuItemAction,
  editorForeground,
  OnTypeRenameProviderRegistry,
  editorWidgetBackground,
  DefinitionProviderRegistry,
  editorWidgetForeground,
  firstIndex,
  DeclarationProviderRegistry,
  editorWidgetBorder,
  RunOnceScheduler,
  ImplementationProviderRegistry,
  editorWidgetResizeBorder,
  lastNonWhitespaceIndex,
  CursorState,
  TypeDefinitionProviderRegistry,
  CodeLensProviderRegistry,
  CodeActionProviderRegistry,
  DocumentFormattingEditProviderRegistry,
  compare,
  DocumentRangeFormattingEditProviderRegistry,
  OnTypeFormattingEditProviderRegistry,
  editorSelectionBackground,
  LinkProviderRegistry,
  ColorProviderRegistry,
  MenuItemAction,
  SelectionRangeRegistry,
  editorSelectionHighlight,
  FoldingRangeProviderRegistry,
  editorSelectionHighlightBorder,
  editorFindMatch,
  runWhenIdle,
  CodeEditorWidget,
  DocumentRangeSemanticTokensProviderRegistry,
  editorFindMatchHighlight,
  TokenizationRegistry,
  editorFindRangeHighlight,
  editorFindMatchBorder,
  editorFindMatchHighlightBorder,
  ScrollableElement,
  editorFindRangeHighlightBorder,
  editorHoverHighlight,
  editorHoverBackground,
  editorHoverForeground,
  range,
  editorHoverBorder,
  editorHoverStatusBarBackground,
  editorActiveLinkForeground,
  editorLightBulbForeground,
  editorLightBulbAutoFixForeground,
  addDisposableNonBubblingMouseOutListener,
  IdleValue,
  listFocusBackground,
  DomScrollableElement,
  isLowerAsciiLetter,
  isUpperAsciiLetter,
  listHighlightForeground,
  snippetTabstopHighlightBackground,
  snippetTabstopHighlightBorder,
  snippetFinalTabstopHighlightBackground,
  snippetFinalTabstopHighlightBorder,
  overviewRulerFindMatchForeground,
  overviewRulerSelectionHighlightForeground,
  startsWithIgnoreCase,
  minimapFindMatch,
  posix,
  commonPrefixLength,
  problemsErrorIconForeground,
  registerEditorCommand,
  problemsWarningIconForeground,
  problemsInfoIconForeground,
  registerEditorAction,
  commonSuffixLength,
  _maxLen,
  isHighSurrogate,
  isLowSurrogate,
  registerEditorContribution,
  transparent,
  getComputedStyle2 as getComputedStyle,
  SEMANTIC_HIGHLIGHTING_SETTING_ID,
  Emitter as Emitter2,
  LRUCache,
  EditorContributionRegistry,
  isSemanticColoringEnabled,
  resolveColorValue,
  LanguageConfigurationRegistry,
  FuzzyScore,
  normalize,
  dirname as dirname2,
  basename as basename2,
  sep,
  getTopLeftOffset,
  getDomNodePagePosition,
  getTotalWidth,
  fuzzyScore,
  isInShadowDOM,
  getShadowRoot,
  createStyleSheet,
  WorkbenchAsyncDataTree,
  createCSSRule,
  RawContextKey,
  removeCSSRulesContainingSelector,
  EventType as EventType2,
  IContextKeyService,
  EventHelper,
  trackFocus,
  append,
  reset,
  CoreEditingCommands,
  $,
  show,
  hide,
  List,
  removeTabIndexAndUpdateFocus,
  asDomUri,
  asCSSUrl,
  EditorOptions,
  ModelDecorationOptions
};
//# sourceMappingURL=chunk.VI6DZMGL.js.map
